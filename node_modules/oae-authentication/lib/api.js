/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var events = require('events');
var passport = require('passport');

var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var Cassandra = require('oae-util/lib/cassandra');
var ConfigAPI = require('oae-config');
var Context = require('oae-context').Context;
var Locking = require('oae-util/lib/locking');
var OaeEmitter = require('oae-util/lib/emitter');
var OaeServer = require('oae-util/lib/server');
var PrincipalsAPI = require('oae-principals');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var TenantsAPI = require('oae-tenants');
var log = require('oae-logger').logger('oae-authentication');
var Validator = require('oae-authz/lib/validator').Validator;

var AuthenticationConfig = ConfigAPI.config('oae-authentication');
var AuthenticationConstants = require('oae-authentication/lib/constants').AuthenticationConstants;
var AuthenticationUtil = require('oae-authentication/lib/util');
var LoginId = require('oae-authentication/lib/model').LoginId;

var globalTenantAlias = null;

// Holds the strategies for each tenant
var strategies = {};

// Setup functions for different strategies, keyed by the strategy name
var strategySetup = {};

// When a tenant starts up, configure its authentication strategies
TenantsAPI.on('start', function(tenant) {
    refreshStrategies(tenant);
});

// When a tenant is refreshed, refresh its authentication strategies
TenantsAPI.on('refresh', function(tenant) {
    refreshStrategies(tenant);
});

// When the server has started up, we enable all the strategies for all the tenants
OaeEmitter.on('ready', function() {
    _refreshAllTenantStrategies();
});

ConfigAPI.on('update', function(tenantAlias) {
    if (tenantAlias === globalTenantAlias) {
        // We updated the global tenant, which means we'll have to update all tenant authentication strategies, as they may have changed transiently
        _refreshAllTenantStrategies();
    } else {
        var tenant = TenantsAPI.getTenant(tenantAlias);
        if (!tenant) {
            return log().error({'tenantAlias': tenantAlias}, 'Error fetching tenant to update authentication configuration.');
        }

        refreshStrategies(tenant);
    }
});

/**
 * ### Events
 *
 * The `AuthenticationAPI`, as enumerated in `AuthenticationConstants.events`, emits the following events:
 *
 * * `refreshedStrategies(tenant)`: The authentication strategies have been refreshed with the current configuration. The tenant that was refreshed is returned as a `Tenant` object.
 */
var AuthenticationAPI = module.exports = new events.EventEmitter();

/**
 * Initializes the configuration of the authentication module.
 *
 * @param  {String} globalTenantAlias   The alias of the global tenant
 */
var init = module.exports.init = function(_globalTenantAlias) {
    globalTenantAlias = _globalTenantAlias;
};



////////////////////////
////////////////////////
// USER ID MANAGEMENT //
////////////////////////
////////////////////////

/**
 * Check whether or not a user with a certain username already exists on a given tenant
 *
 * @param  {Context}   ctx                The current context
 * @param  {String}    [tenantAlias]      The alias of the tenant in which to check for the username. Defaults to the current tenant
 * @param  {String}    username           The username that we want to check existence for
 * @param  {Function}  callback           Standard callback function
 * @param  {Object}    callback.err       An error that occured, if any
 * @param  {Boolean}   callback.exists    Whether or not the username exists on the current tenant
 */
var localUsernameExists = module.exports.localUsernameExists = function(ctx, tenantAlias, username, callback) {
    tenantAlias = tenantAlias || ctx.tenant().alias;

    // Create the loginid object first, so it can be passed into the validation
    var loginId = new LoginId(tenantAlias, AuthenticationConstants.providers.LOCAL, username);

    // Parameter validation
    var validator = new Validator();
    validator.check(username, {'code': 400, 'msg': 'Please specify a username'}).notEmpty();
    _validateLoginIdForLookup(validator, loginId);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getUserIdFromLoginId(loginId, function(err, userId) {
        if (err && err.code !== 404) {
            return callback(err);
        } else if (!userId) {
            return callback(null, false);
        }

        return callback(null, true);
    });
};

/**
 * Get the global administrator with the given username. If no user exists with the given username,
 * create a private user with the provided username, password and profile information and make them
 * a global admin
 *
 * @param  {Context}    ctx                 The current context, must be authenticated to the global admin tenant with a user with global administrator privileges
 * @param  {String}     username            The local username of the global administrator
 * @param  {String}     password            The password of the global administrator
 * @param  {String}     displayName         The display name of the global administrator
 * @param  {String}     [opts]              Optional user profile parameters
 * @param  {String}     [opts.locale]       The global administrator's locale
 * @param  {String}     [opts.email]        The global administrator's email address
 * @param  {String}     [opts.timezone]     The global administrator's timezone
 * @param  {String}     [opts.publicAlias]  The alias to show when the global administrator is private / inaccessible by the current user
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occured, if any
 * @param  {User}       callback.user       The user associated with the provided username
 * @param  {Boolean}    callback.created    `true` if a global administrator was created with the provided username, `false` otherwise
 */
var getOrCreateGlobalAdminUser = module.exports.getOrCreateGlobalAdminUser = function(ctx, username, password, displayName, opts, callback) {
    opts = opts || {};

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You must be authenticated to the global admin tenant to create a global administrator user'}).isLoggedInUser(ctx, globalTenantAlias);
    validator.check(null, {'code': 401, 'msg': 'You must be a global administrator to create a global administraotr user'}).isGlobalAdministratorUser(ctx);
    validator.check(username, {'code': 400, 'msg': 'You must provide a username'}).notEmpty();
    validator.check(password, {'code': 400, 'msg': 'You must provide a password'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'You must provide a display name'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'A display name can be at most 1000 characters long'}).isShortString();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Global admin users always start out private
    opts.visibility = AuthzConstants.visibility.PRIVATE;

    var providerProperties = {'password': password};
    getOrCreateUser(ctx, AuthenticationConstants.providers.LOCAL, username, providerProperties, displayName, opts, function(err, user, created) {
        if (err) {
            return callback(err);
        } else if (!created) {
            // The user already existed, just return the existing user
            return callback(null, user, false);
        }

        // The user was created, mark them as a global admin user
        PrincipalsAPI.setGlobalAdmin(ctx, user.id, true, function(err) {
            if (err) {
                return callback(err);
            }

            log().info({'user': user, 'username': username}, 'Global Admin account created');

            // Fetch the user again to get the updated version of the user
            PrincipalsAPI.getUser(ctx, user.id, function(err, user) {
                if (err) {
                    return callback(err);
                }

                return callback(null, user, true);
            });
        });
    });
};

/**
 * Utility methods that gets a user by the login id. If the user doesn't exist yet, it will be created.
 *
 * @param  {Context}      ctx                       The current context, used to determine the tenant of the user to get / create
 * @param  {String}       authProvider              The authentication provider of the login id
 * @param  {String}       externalId                The desired externalId/username for this user
 * @param  {String}       displayName               The user's display name
 * @param  {String}       [opts]                    Optional user profile parameters
 * @param  {String}       [opts.locale]             The user's locale
 * @param  {String}       [opts.email]              The user's email address
 * @param  {String}       [opts.visibility]         The user's visibility. One of: @see AuthzConstants.visibility
 * @param  {String}       [opts.publicAlias]        The alias to show when the user is private / inaccessible by the current user
 * @param  {String}       [opts.emailPreference]    The user's email preference. One of: @see PrincipalsConstants.emailPreference
 * @param  {Function}     callback                  Standard callback function
 * @param  {Object}       callback.err              An error that occured, if any
 * @param  {Boolean}      callback.user             The user object
 * @param  {Boolean}      callback.created          Whether or not a new user was created
 */
var getOrCreateUser = module.exports.getOrCreateUser = function(ctx, authProvider, externalId, providerProperties, displayName, opts, callback) {
    var validator = new Validator();
    validator.check(displayName, {'code': 400, 'msg': 'You must provide a display name'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'A display name can be at most 1000 characters long'}).isShortString();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Create the expected login id and ensure it is valid for potentially persisting into storage
    var loginId = new LoginId(ctx.tenant().alias, authProvider, externalId, providerProperties);
    _validateLoginIdForPersistence(validator, loginId);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getOrCreateUser(ctx, loginId, displayName, opts, callback);
};

/**
 * Create a user with the given login id if no user exists for it yet
 *
 * @param  {Context}    ctx                 The context of the current request
 * @param  {LoginId}    loginId             The login id to use to fetch or create the user
 * @param  {String}     displayName         The display name to give the user if created
 * @param  {Object}     opts                The optional user fields to give the user if created
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {User}       callback.user       The user that was fetched or created
 * @param  {Boolean}    callback.created    `true` if the user was created, `false` otherwise
 * @api private
 */
var _getOrCreateUser = function(ctx, loginId, displayName, opts, callback) {
    _getUserIdFromLoginId(loginId, function(err, userId) {
        if (err && err.code !== 404) {
            return callback(err);
        } else if (!userId) {
            // No user mapped to this login id so we will create a user for it
            log(ctx).trace({
                'authProvider': loginId.provider,
                'externalId': loginId.externalId,
                'displayName': displayName,
                'opts': opts
            }, 'Auto-creating a user on login');

            createUser(ctx, loginId, displayName, opts, function(err, user) {
                if (err) {
                    return (err);
                }

                return callback(null, user, true);
            });
        } else {
            // The user existed, simply fetch their profile
            PrincipalsAPI.getUser(ctx, userId, function(err, user) {
                if (err) {
                    return (err);
                }

                return callback(null, user, false);
            });
        }
    });
};

/**
 * Create a private tenant administrator user with the provided login id
 *
 * @param  {Context}    ctx                         The current context
 * @param  {LoginId}    loginId                     The login id that will be associated with the tenant administrator so they may log in
 * @param  {String}     displayName                 The tenant administrator's display name
 * @param  {Object}     [opts]                      Optional user profile parameters
 * @param  {String}     [opts.email]                The tenant administrator's email address
 * @param  {String}     [opts.locale]               The tenant administrator's locale
 * @param  {String}     [opts.publicAlias]          The alias to show when the tenant administrator is private / inaccessible by the current user
 * @param  {String}     [opts.emailPreference]      The tenant administrator's email preference. One of: @see PrincipalsConstants.emailPreference
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error that occurred, if any
 * @param  {User}       callback.user               User object representing the created tenant administrator
 */
var createTenantAdminUser = module.exports.createTenantAdminUser = function(ctx, loginId, displayName, opts, callback) {
    opts = opts || {};

    var validator = new Validator();
    validator.check(null, {'code': 400, 'msg': 'A LoginId must be provided'}).isObject(loginId);
    validator.check(displayName, {'code': 400, 'msg': 'You must provide a display name'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'A display name can be at most 1000 characters long'}).isShortString();
    _validateLoginIdForPersistence(validator, loginId);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var targetTenant = TenantsAPI.getTenant(loginId.tenantAlias);
    if (!targetTenant) {
        return callback({'code': 404, 'msg': 'A non-existing tenant was specified as the target for this user'});
    } else if (targetTenant.isGlobalAdminServer) {
        return callback({'code': 400, 'msg': 'A tenant administrator cannot be created on the global admin tenant'});
    } else if (!ctx.user() || !ctx.user().isAdmin(targetTenant.alias)) {
        return callback({'code': 401, 'msg': 'Only administrators can create new tenant administrators'});
    }

    // Tenant administrators always start private
    opts.visibility = AuthzConstants.visibility.PRIVATE;

    // Create the user object with their login id
    _createUser(ctx, loginId, displayName, opts, function(err, user) {
        if (err) {
            return callback(err);
        }

        // Make the created user a tenant admin
        PrincipalsAPI.setTenantAdmin(ctx, user.id, true, function(err) {
            if (err) {
                return callback(err);
            }

            return callback(null, user);
        });
    });
};

/**
 * Create a user with the provided login id
 *
 * @param  {Context}    ctx                         The current context
 * @param  {LoginId}    loginId                     The login id that will be associated with the user so they may log in
 * @param  {String}     displayName                 The user's display name
 * @param  {Object}     [opts]                      Optional user profile parameters
 * @param  {String}     [opts.locale]               The user's locale
 * @param  {String}     [opts.email]                The user's email address
 * @param  {String}     [opts.visibility]           The user's visibility. One of: @see AuthzConstants.visibility
 * @param  {String}     [opts.publicAlias]          The alias to show when the user is private / inaccessible by the current user
 * @param  {String}     [opts.emailPreference]      The user's email preference. One of: @see PrincipalsConstants.emailPreference
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error that occurred, if any
 * @param  {User}       callback.user               User object representing the created user
 */
var createUser = module.exports.createUser = function(ctx, loginId, displayName, opts, callback) {
    var validator = new Validator();
    validator.check(displayName, {'code': 400, 'msg': 'You must provide a display name'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'A display name can be at most 1000 characters long'}).isShortString();
    _validateLoginIdForPersistence(validator, loginId);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var targetTenant = TenantsAPI.getTenant(loginId.tenantAlias);
    if (!targetTenant) {
        return callback({'code': 404, 'msg': 'A non-existing tenant was specified as the target for this user'});
    }

    var isGlobalAdmin = (ctx.user() && ctx.user().isGlobalAdmin());
    if (targetTenant.isGlobalAdminServer && !isGlobalAdmin) {
        // Only global admins can create users on the global admin tenant
        return callback({'code': 401, 'msg': 'Only global administrators may create a user on the global admin tenant'});
    } else if (ctx.tenant().alias !== targetTenant.alias && !isGlobalAdmin) {
        // Only global admins can create users on a tenant other than the current
        return callback({'code': 401, 'msg': 'Only global administrators may create users on a tenant that is not the current'});
    }

    _createUser(ctx, loginId, displayName, opts, callback);
};

/**
 * Internal utility function to create a user. Validation on inputs should be performed before
 * calling this function
 *
 * @param  {Context}    ctx                 The current context
 * @param  {LoginId}    loginId             The login id that will be associated with the user so they may log in
 * @param  {String}     displayName         The user's display name
 * @param  {Object}     [opts]              Optional user profile parameters
 * @param  {String}     [opts.locale]       The user's locale
 * @param  {String}     [opts.email]        The user's email address
 * @param  {String}     [opts.timezone]     The user's timezone
 * @param  {String}     [opts.visibility]   The user's visibility. One of: @see AuthzConstants.visibility
 * @param  {String}     [opts.publicAlias]  The alias to show when the user is private / inaccessible by the current user
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {User}       callback.user       User object representing the created user
 * @api private
 */
var _createUser = function(ctx, loginId, displayName, opts, callback) {
    // Lock on externalId to make sure we're not already making an account for this user
    var lockKey = loginId.externalId;
    Locking.acquire(lockKey, 15, function(err, lockToken) {
        if (err) {
            return callback(err);
        } else if (!lockToken) {
            return callback({'code': 400, 'msg': 'This login id already exists and is already associated to a user'});
        }

        // Make sure the loginId is not already associated to a user
        _getUserIdFromLoginId(loginId, function(err, userId) {
            if (userId) {
                return callback({'code': 400, 'msg': 'This login id already exists and is already associated to a user'});
            }

            // Hash the user password
            if (loginId.provider === AuthenticationConstants.providers.LOCAL) {
                loginId.properties.password = AuthenticationUtil.hashPassword(loginId.properties.password);
            }

            // Create the user and immediately associate the login id
            PrincipalsAPI.createUser(ctx, loginId.tenantAlias, displayName, opts, function(err, user) {
                if (err) {
                    Locking.release(lockKey, lockToken, function() {
                        callback(err);
                    });
                    return;
                }

                loginId.userId = user.id;
                _associateLoginId(loginId, user.id, function(err) {
                    // Immediately release the lock, regardless of whether or not
                    // association worked
                    Locking.release(lockKey, lockToken, function() {
                        if (err) {
                            return callback(err);
                        }

                        log(ctx).info({
                            'loginId': {
                                'tenantAlias': loginId.tenantAlias,
                                'provider': loginId.provider,
                                'externalId': loginId.externalId
                            },
                            'userId': user.id
                        }, 'Created user with a mapped login id');

                        return callback(null, user);
                    });
                });
            });
        });
    });
};

/**
 * Associate the given Login ID info to the specified user. This makes it possible for the associated user to login with the provided
 * login credentials.
 *
 * @param  {Context}   ctx             The current context
 * @param  {LoginId}   loginId         The login id to associate to the user
 * @param  {String}    userId          The id of the user to which to associate the login id
 * @param  {Function}  callback        Invoked when the process completes
 * @param  {Object}    callback.err    An error that occurred, if any
 */
var associateLoginId = module.exports.associateLoginId = function(ctx, loginId, userId, callback) {
    var validator = new Validator();
    _validateLoginIdForPersistence(validator, loginId);
    validator.check(null, {'code': 401, 'msg': 'You must be authenticated to associate a login id to a user'}).isLoggedInUser(ctx);
    validator.check(userId, {'code': 400, 'msg': 'You must specify a user id'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var isAdmin = ctx.user().isAdmin(loginId.tenantAlias);
    var isTargetUser = (ctx.user().id === userId);
    if (!isAdmin && !isTargetUser) {
        // Only admin and the user themself can associate a login id to the account
        return callback({'code': 401, 'msg': 'You cannot associate a login id to a user other than your own'});
    }

    _getUserIdFromLoginId(loginId, function(err, existingUserIdMapping) {
        if (err && err.code !== 404) {
            return callback(err);
        } else if (existingUserIdMapping && !isAdmin) {
            // Only admin can re-associate a login id to another user
            return callback({'code': 401, 'msg': 'Login ID is already associated to a user'});
        }

        // Verify we don't assign 2 ids of the same provider to a user
        _getUserLoginIds(userId, function(err, loginIds) {
            if (err) {
                return callback(err);
            } else if (loginIds[loginId.provider]) {
                return  callback({'code': 400, 'msg': 'User already has a login id of type ' + loginId.provider});
            }

            // Ensure that the target user exists
            PrincipalsAPI.getUser(ctx, userId, function(err, user) {
                if (err) {
                    return callback(err);
                }

                _associateLoginId(loginId, userId, function(err) {
                    if (err) {
                        callback(err);
                    } else {
                        log(ctx).info({
                            loginId: {
                                tenantAlias: loginId.tenantAlias,
                                provider: loginId.provider,
                                externalId: loginId.externalId
                            },
                            userId: userId
                        }, 'Mapped login id to user account');
                        callback();
                    }
                });
            });
        });
    });
};

/**
 * Changes the local password of a user.
 *
 * @param  {Context}  ctx           The current context
 * @param  {String}   userId        The user id of the user whose password that needs to be changed
 * @param  {String}   oldPassword   The old password that can be used to authenticate this change request
 * @param  {String}   newPassword   The new password
 * @param  {Function} callback      Invoked when the process completes
 * @param  {Object}   callback.err  An error that occurred, if any
 */
var changePassword = module.exports.changePassword = function(ctx, userId, oldPassword, newPassword, callback) {

    // Parameter validation
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to change a password'}).isLoggedInUser(ctx);
    validator.check(userId, {'code': 400, 'msg': 'A user id must be provided'}).isUserId();
    validator.check(newPassword, {'code': 400, 'msg': 'A new password must be provided'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the local login id for the user
    _getUserLoginIds(userId, function(err, loginIds) {
        if (err) {
            return callback(err);
        }

        // can only change password on the local account type
        var localLoginId = loginIds[AuthenticationConstants.providers.LOCAL];
        if (localLoginId) {

            // determine the current user access
            var isAdmin = ctx.user().isAdmin(localLoginId.tenantAlias);
            var isTargetUser = ctx.user().id === userId;

            if (!isAdmin && !isTargetUser) {
                log().info('Failed attempt to change password for user %s by user %s', userId, ctx.user().id);
                return callback({'code': 401, 'msg': 'You\'re not authorized to change this user\'s password'});
            } else if (isAdmin) {
                // if the user is admin we don't care about the old password
                log().info('User %s is changing the password for user %s', ctx.user().id, userId);
                return _changePassword(localLoginId, newPassword, callback);
            } else {
                // if it's the current user, we need to verify the old password
                checkPassword(localLoginId.tenantAlias, localLoginId.externalId, oldPassword, function(err, checkedUserId) {
                    if (err) {
                        // old password was probably incorrect
                        log().error({'err': err}, 'User %s failed to change password for %s', ctx.user().id, userId);
                        return callback(err);
                    }

                    log().info('User %s is changing the password for user %s', ctx.user().id, userId);
                    return _changePassword(localLoginId, newPassword, callback);
                });
            }
        } else {
            return callback({'code': 400, 'msg': 'User does not have a local account mapping'});
        }
    });
};

/**
 * Checks the password for a specified tenant/username combination
 *
 * @param  {String}    tenantAlias      The alias of the tenant to which the user belongs
 * @param  {String}    username         The local username of the user
 * @param  {String}    password         The password that should be checked
 * @param  {Function}  callback         Standard callback function
 * @param  {Object}    callback.err     If the password check fails, this will be an error with `err.code === 401`. If there is an unexpected internal error, this will be that error
 * @param  {object}    callback.userId  The ID of the user if the passwords match
 */
var checkPassword = module.exports.checkPassword = function(tenantAlias, username, password, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(tenantAlias, {'code': 401, 'msg': 'A tenant must be provided'}).notEmpty();
    validator.check(username, {'code': 400, 'msg': 'A username must be provided'}).notEmpty();
    validator.check(password, {'code': 400, 'msg': 'A password must be provided'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // we can only check password on local authentication
    var loginId = new LoginId(tenantAlias, AuthenticationConstants.providers.LOCAL, username);

    _validateLoginIdForLookup(validator, loginId);
    if (validator.hasErrors()) {
        return new callback(validator.getFirstError());
    }

    Cassandra.runQuery('SELECT "userId", "password" FROM "AuthenticationLoginId" WHERE "loginId" = ?', [_flattenLoginId(loginId)], function(err, rows) {
        if (err) {
            return callback(err);
        } else if (_.isEmpty(rows)) {
            // No user found with that login id
            return callback({'code': 401, 'msg': 'No password found for this principal'});
        }

        // Check if the user provided password matches the stored password
        var result = Cassandra.rowToHash(rows[0]);
        var passwordMatches = result.userId && result.password && AuthenticationUtil.hashAndComparePassword(password, result.password);
        if (passwordMatches) {
            callback(null, result.userId);
        } else {
            log().info('Invalid password check for user %s', username);
            callback({'code': 401, 'msg': 'User name and/or password do not match'});
        }
    });
};

/**
 * Gets the userId that is associated to the provided login ID, if any.
 *
 * @param  {String}    tenantAlias     The tenant of the login id
 * @param  {String}    provider        The provider of the login id (e.g., twitter, local, google...)
 * @param  {String}    externalId      The id of the user in the external authentication service
 * @param  {Function}  callback        Invoked when the process completes
 * @param  {Object}    callback.err    An error that occurred, if any
 * @param  {String}    callback.userId The id of the user that was associated to the login id, if any
 */
var getUserIdFromLoginId = module.exports.getUserIdFromLoginId = function(tenantAlias, provider, externalId, callback) {
    var loginId = new LoginId(tenantAlias, provider, externalId);

    var validator = new Validator();
    _validateLoginIdForLookup(validator, loginId);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getUserIdFromLoginId(loginId, callback);
};

/**
 * Hash `newPassword` and store it as the new password for the given `loginId`.
 *
 * @param  {LoginId}   loginId         The login id whose password to change
 * @param  {String}    newPassword     The password to which to change the local login id
 * @param  {Function}  callback        Invoked when the process completes
 * @param  {Object}    callback.err    An error that occurred, if any
 * @api private
 */
var _changePassword = function(loginId, newPassword, callback) {
    var hash = AuthenticationUtil.hashPassword(newPassword);
    Cassandra.runQuery('UPDATE "AuthenticationLoginId" SET "password" = ? WHERE "loginId" = ?', [hash, _flattenLoginId(loginId)], function(err) {
        if (err) {
            log().error({'err': err}, 'Error changing a user password');
            return callback(err);
        }

        return callback();
    });
};

/**
 * Associate the given Login ID info to the specified user. This makes it possible for the associated user to login with the provided
 * login credentials.
 *
 * @param  {LoginId}   loginId         The login id to associate
 * @param  {String}    userId          The id of the user to which to associate the login id
 * @param  {Function}  callback        Invoked when the process completes
 * @param  {Object}    callback.err    An error that occurred, if any
 * @api private
 */
var _associateLoginId = function(loginId, userId, callback) {
    loginId.properties = loginId.properties || {};
    var flattenedLoginId = _flattenLoginId(loginId);

    // sanitize and prepare the columns for the upsert
    delete loginId.properties.loginId;
    loginId.properties.userId = userId;

    var query = Cassandra.constructUpsertCQL('AuthenticationLoginId', 'loginId', flattenedLoginId, loginId.properties);
    if (query) {
        var queries = [];
        queries.push(query);
        queries.push({
            'query': 'INSERT INTO "AuthenticationUserLoginId" ("userId", "loginId", "value") VALUES (?, ?, ?)',
            'parameters': [userId, flattenedLoginId, '1']
        });
        return Cassandra.runBatchQuery(queries, callback);
    } else {
        log().error({
            loginId: loginId,
            userId: userId
        }, 'Error constructing query to associate login id to user');
        return callback({'code': 500, 'msg': 'Error associating login id to user ' + userId});
    }
};

/**
 * Get the login ids that are mapped to a user.
 *
 * @param  {String}      userId              The id of the user
 * @param  {Function}    callback            Invoked when the prcess completes
 * @param  {Object}      callback.err        An error that occurred, fi any
 * @param  {Object}      callback.loginIds   A hash whose keys are the authentication providers, and values are the LoginId objects that are mapped to the user
 * @api private
 */
var _getUserLoginIds = function(userId, callback) {
    if (!userId) {
        return callback(null, {});
    }

    Cassandra.runQuery('SELECT "loginId" FROM "AuthenticationUserLoginId" WHERE "userId" = ?', [userId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var loginIds = {};
        _.each(rows, function(row) {
            row = Cassandra.rowToHash(row);
            if (row.loginId) {
                var loginId = _expandLoginId(row.loginId);
                loginIds[loginId.provider] = loginId;
            }
        });

        return callback(null, loginIds);
    });
};

/**
 * Gets the userId that is associated to the provided login ID, if any.
 *
 * @param  {LoginId}   loginId         The login id to search
 * @param  {Function}  callback        Invoked when the process completes
 * @param  {Object}    callback.err    An error that occurred, if any
 * @param  {String}    callback.userId The id of the user that was associated to the login id, if any
 * @api private
 */
var _getUserIdFromLoginId = function(loginId, callback) {
    Cassandra.runQuery('SELECT "userId" FROM "AuthenticationLoginId" WHERE "loginId" = ?', [_flattenLoginId(loginId)], function(err, rows) {
        if (err) {
            return callback(err);
        } else if (_.isEmpty(rows)) {
            return callback({'code': 404, 'msg': 'No user could be found with the provided login id'});
        }

        var result = Cassandra.rowToHash(rows[0]);
        return callback(null, result.userId);
    });
};

/**
 * Flatten a LoginId object into a string representation that can be used for a storage key. This is in the following format:
 *
 * `<tenantAlias>:<authentication provider>:<external id>`
 *
 * @param  {LoginId}   loginId     The login id to flatten
 * @return {String}                The flattened string key representation of the login id
 * @api private
 */
var _flattenLoginId = function(loginId) {
    if (!loginId || !loginId.tenantAlias || !loginId.provider || !loginId.externalId) {
        return null;
    }
    return loginId.tenantAlias + ':' + loginId.provider + ':' + loginId.externalId;
};

/**
 * Expand a flattened key representation of a login id into a LoginId object. This is the opposite of #_flattenLoginId.
 *
 * @param  {String}    loginIdStr  The flat string key representation of the login id
 * @return {LoginId}               The LoginId object that is represented by the flat string
 * @api private
 */
var _expandLoginId = function(loginIdStr) {
    if (!loginIdStr) {
        return null;
    }

    var loginIdSplit = loginIdStr.split(':');
    if (loginIdSplit.length < 3) {
        return null;
    }

    // the externalId can contain *anything*, including colons. keep that in-tact with a slice-and-join.
    return new LoginId(loginIdSplit[0], loginIdSplit[1], loginIdSplit.slice(2).join(':'));
};

/**
 * Verify that the given login ID is suitable to be used to look up a user id mapping.
 *
 * @param  {Validator}       validator   The validator to use to validate the loginId
 * @param  {LoginId}         loginId     The login id to validate
 * @api private
 */
var _validateLoginIdForLookup = function(validator, loginId) {
    var numErrors = validator.getErrorCount();
    validator.check(null, {'code': 400, 'msg': 'Must specify a login id'}).isObject(loginId);
    if (validator.getErrorCount() === numErrors) {
        // only validate these if loginId is a valid object
        validator.check(loginId.tenantAlias, {'code': 400, 'msg': 'Must specify a tenant id on the login id'}).notEmpty();
        validator.check(loginId.provider, {'code': 400, 'msg': 'Must specify an authentication provider on the login id'}).notEmpty();
        validator.check(loginId.externalId, {'code': 400, 'msg': 'Must specify an external id on the login id'}).notEmpty();
    }
};

/**
 * Verify that the given login ID is suitable to be persisted to storage.
 *
 * @param  {Validator}       validator   The validator to use to validate the loginId
 * @param  {LoginId}         loginId     The login id to validate
 * @api private
 */
var _validateLoginIdForPersistence = function(validator, loginId) {
    var numErrors = validator.getErrorCount();
    _validateLoginIdForLookup(validator, loginId);

    // only continue validating if the login id is valid so far
    if (validator.getErrorCount() === numErrors) {
        loginId.properties = loginId.properties || {};

        // custom handling for local authentication (i.e., username and password)
        if (loginId.provider === AuthenticationConstants.providers.LOCAL) {
            validator.check(loginId.properties.password, {'code': 400, 'msg': 'Must specify a password at least 6 characters long'}).len(6);
        }
    }
};



///////////////////////////////
///////////////////////////////
// AUTHENTICATION STRATEGIES //
///////////////////////////////
///////////////////////////////

/**
 * Register an authentication strategy. A strategy needs to be registered during the start-up phase and will then
 * be made active when the server has fully started up.
 *
 * @param  {String}     strategyName    The name under which this strategy should be registered. This string will be used in the Passport registry mechanism
 * @param  {Strategy}   strategy        The OAE strategy that needs to be registered
 * @throws {Error}                      An error is thrown if another strategy was already registered with the provided strategy name
 */
var registerStrategy = module.exports.registerStrategy = function(strategyName, strategy) {
    if (strategies[strategyName]) {
        throw new Error('Attempted to register duplicate authentication strategy');
    }

    strategies[strategyName] = strategy;
    log().info('Registered authentication strategy "%s"', strategyName);
};

/**
 * Refresh the known passport login strategies for a given tenant. This will be called for all registered tenants upon start-up
 * and when new tenants are being started on the fly.
 *
 * @param  {Tenant} tenant  The tenant for which we want to refresh the authentication capabilities
 */
var refreshStrategies = module.exports.refreshStrategies = function(tenant) {
    _.each(strategies, function(strategy, strategyName) {
        // Get the name we used to register this strategy with passport. This is a combination of the tenant and strategy name
        var passportStrategyName = AuthenticationUtil.getStrategyId(tenant, strategyName);

        // Disable the passport strategy if we registered it previously.
        if (passport._strategy(passportStrategyName)) {
            passport.unuse(passportStrategyName);
        }

        // If the tenant wants the strategy enabled, we enable it. We also create a new instance of the passport strategy so that
        // configuration updates to the strategy are taken into account
        if (strategy.shouldBeEnabled(tenant.alias)) {
            passport.use(passportStrategyName, strategy.getPassportStrategy(tenant));
            log().info({'tenant': tenant.alias, 'strategy': strategyName, 'passportStrategyName': passportStrategyName}, 'Enabling strategy');
        }
    });

    AuthenticationAPI.emit(AuthenticationConstants.events.REFRESHED_STRATEGIES, tenant);

    log().info({'tenant': tenant}, 'Refreshed authentication strategies for tenant');
};

/**
 * Refreshes all the authentication strategies on all the tenants.
 *
 * @api private
 */
var _refreshAllTenantStrategies = function() {
    var tenants = TenantsAPI.getTenants();
    // Refresh all the tenant auth strategies
    _.each(_.values(tenants), refreshStrategies);
};


////////////////////////
////////////////////////
// SESSION MANAGEMENT //
////////////////////////
////////////////////////

/**
 * Log a user out from a session. This method will take care of committing the response object.
 *
 * @param  {Request}    req     The ExpressJS request object
 * @param  {Response}   res     The ExpressJS response object
 */
var logout = module.exports.logout = function(req, res) {
    // We need to grab the authentication info before we call `logOut()`
    // as the property would otherwise be removed
    var authInfo = req.oaeAuthInfo;

    // In all cases, we destroy the session within OAE
    req.logout();

    // If the full unique strategy was not made available on the request, there is nothing we can do any further
    if (!authInfo || !authInfo.strategyId) {
        return res.redirect('/');
    }

    // If no strategy name was set on the request we're done
    var passportStrategyName = AuthenticationUtil.parseStrategyId(authInfo.strategyId).strategyName;
    if (!passportStrategyName) {
        return res.redirect('/');
    }

    // If the strategy didn't implement a logout function we're done
    var strategy = strategies[passportStrategyName];
    if (!strategy || !strategy.logout) {
        return res.redirect('/');
    }

    // If the strategy implemented a logout function, they can take care of the further request cycle
    return strategy.logout(req, res);
};
