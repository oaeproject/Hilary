/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var fs = require('fs');
var gm = require('gm');
var Path = require('path');

var ImageUtil = require('oae-util/lib/image');
var IO = require('oae-util/lib/io');
var log = require('oae-logger').logger('oae-preview-processor');

var PreviewConstants = require('oae-preview-processor/lib/constants');


/**
 * @borrows Interface.test as Images.test
 */
var test = module.exports.test = function(ctx, contentObj, callback) {
    if (contentObj.resourceSubType === 'file' && PreviewConstants.TYPES.IMAGE.indexOf(contentObj.mime) !== -1) {
        callback(null, 10);
    } else {
        callback(null, -1);
    }
};

/**
 * @borrows Interface.generatePreviews as Images.generatePreviews
 */
var generatePreviews = module.exports.generatePreviews = function(ctx, contentObj, callback) {
    // Download the file.
    ctx.download(function(err, path) {
        if (err) {
            return callback(err);
        }

        // Generate different sizes.
        var sizes = [
            { 'width': PreviewConstants.SIZES.IMAGE.MEDIUM, 'height': PreviewConstants.SIZES.IMAGE.MEDIUM, 'size': 'medium' },
            { 'width': PreviewConstants.SIZES.IMAGE.SMALL, 'height': PreviewConstants.SIZES.IMAGE.SMALL, 'size': 'small' }
        ];
        resizeImages(ctx, path, sizes, function(err) {
            if (err) {
                return callback(err);
            }

            // Intelligently crop out a part of the image.
            cropThumbnail(ctx, path, callback);
        });
    });
};

/**
 * Resizes an image to one or multiple different sizes.
 *
 * @param {PreviewContext}      ctx             The preview context associated to this file.
 * @param {String}              path            The path where the image can be found on disk.
 * @param {Object[]}            sizes           An array of size object. Each object should have a `width`, `height` and `size` key, the `prefix` key is optional.
 * @param {Function}            callback        Standard callback method.
 * @param {Object}              callback.err    Standard error object (if any.)
 */
var resizeImages = module.exports.resizeImages = function(ctx, path, sizes, callback) {
    var todo = sizes.length;
    var called = false;
    sizes.forEach(function(size) {
        _resize(ctx, path, size, function(err) {
            todo--;
            if (err) {
                if (!called) {
                    called = true;
                    return callback(err);
                }
            }

            if (todo === 0 && !called) {
                called = true;
                callback();
            }
        });
    });
};

/**
 * Resizes an image to the specified size.
 * The image will be stored at basedir/previews/filename.<size name>.png
 * The filename will be a concatenation of `size.prefix`, `size.size` and `.png`
 *
 * @param {PreviewContext}      ctx             The preview context associated to this file.
 * @param {String}              path            The path where the image can be found on disk.
 * @param {Object}              size            A size object
 * @param {Number}              size.width      The width in pixels.
 * @param {Number}              size.height     The height in pixels.
 * @param {String}              size.size       The size of the desired image. One of 'small', 'medium' or 'large'.
 * @param {String}              [size.prefix]   The prefix that should be used in the filename. The end filename will look like <prefix><size>.png . If no prefix is specified, an empty string will be used.
 * @param {Function}            callback        Standard callback method.
 * @param {Object}              callback.err    Standard error object (if any.)
 * @api private
 */
var _resize = function(ctx, path, size, callback) {
    log().trace({'contentId': ctx.contentId}, 'Resizing image %s to %s x %s', path, size.width, size.height);
    ImageUtil.resizeImage(path, size, function(err, file) {
        if (err) {
            return callback(err);
        }

        // Move the resized image to the base directory for this piece of content.
        var prefix = size.prefix || '';
        var resizedPath = ctx.baseDir + '/' + prefix + size.size + '.png';
        IO.moveFile(file.path, resizedPath, function(err) {
            if (err) {
                return callback(err);
            }

            // Add it to the set of previews that should be attached to it.
            ctx.addPreview(resizedPath, size.size);
            callback();
        });
    });
};

/**
 * Intelligently crops out thumbnail images.
 * Two images will be cropped.
 * 1/ A square small image to display in list views
 * 2/ A rectangle that can be used in activity feeds
 *
 * In landscape mode we crop out a box the size of the image height in the (horizontal) center of the image
 * In portrait mode we crop out a box the size of the image width at the top of the image.
 *
 * @param  {PreviewContext}      ctx             The preview context associated to this file.
 * @param  {String}              path            The path where the image can be found on disk.
 * @param  {Function}            callback        Standard callback method.
 * @param  {Object}              callback.err    Standard error object (if any.)
 */
var cropThumbnail = module.exports.cropThumbnail = function(ctx, path, callback) {
    // First, crop the square thumbnail
    _cropIntelligently(ctx, path, PreviewConstants.SIZES.IMAGE.THUMBNAIL, PreviewConstants.SIZES.IMAGE.THUMBNAIL, 'thumbnail.png', function(err, thumbnailPath) {
        if (err) {
            return callback(err);
        } else if (!thumbnailPath) {
            // If we weren't able to generate the thumbnail, that means the source image is too small.
            // There is no point in trying to render the large rectangle.
            return callback();
        }

        // Use the cropped image as the thumbnail.
        ctx.setThumbnail(thumbnailPath);

        // Now, crop the large rectangle for activity feeds.
        _cropIntelligently(ctx, path, PreviewConstants.SIZES.IMAGE.WIDE_WIDTH, PreviewConstants.SIZES.IMAGE.WIDE_HEIGHT, 'wide.png', function(err, widePath) {
            if (err) {
                return callback(err);
            }

            ctx.addPreview(widePath, 'wide');
            callback();
        });
    });
};

/**
 * Crops a subimage out of a base image.
 * In landscape mode we crop out a box the size of the image height in the (horizontal) center of the image
 * In portrait mode we crop out a box the size of the image width at the top of the image.
 *
 * @param  {PreviewContext}     ctx             The preview context associated to this file.
 * @param  {String}             path            The path where the image can be found on disk.
 * @param  {Number}             width           The desired width of the subimage.
 * @param  {Number}             height          The desired height of the subimage.
 * @param  {String}             filename        The filename of the generated subimage. The file will be moved to the basedir of the current preview context.
 * @param  {Function}           callback        Standard callback method.
 * @param  {Object}             callback.err    Standard error object, if any.
 * @param  {String}             callback.path   The full path where the subimage can be found. If the base image was too small, this will be null (no error, will be passed)
 * @api private
 */
var _cropIntelligently = function(ctx, path, width, height, filename, callback) {
    log().trace({'contentId': ctx.contentId}, 'Cropping image: %s', path);
    gm(path).size(function (err, size) {
        if (err) {
            log().error({'err': err}, 'Could not get the image size for the large image.');
            return callback({'code': 500, 'msg': 'Could not get the image size for the large image.'});
        }

        // Ignore if the image is too small.
        if (imageWidth < width || imageHeight < height) {
            return callback(null, null);
        }

        var imageWidth = size.width;
        var imageHeight = size.height;

        // Find the smallest ratio
        var widthRatio = imageWidth / width;
        var heightRatio = imageHeight / height;
        var ratio = (widthRatio < heightRatio) ? widthRatio : heightRatio;

        var cropWidth = Math.floor(width * ratio);
        var cropHeight = Math.floor(height * ratio);

        // In portrait mode we crop out a box the size of the image width at the top of the image.
        // This is to get the top of the page for content items such as PDFs, Office files, ...
        var selectedArea = {
            'x': 0,
            'y': 0,
            'width': cropWidth,
            'height': cropHeight
        };

        // In landscape mode we crop out a box the size of the image height in the (absolute) center of the image.
        if (imageWidth > imageHeight) {
            selectedArea.x = Math.floor((imageWidth - cropWidth) / 2);
            selectedArea.y = Math.floor((imageHeight - cropHeight) / 2);
        }

        // Crop the correct square.
        ImageUtil.cropAndResize(path, selectedArea, [ {'width': width, 'height': height} ], function(err, files) {
            if (err) {
                log().error({'err': err}, 'Could not crop the image.');
                return callback(err);
            }

            // Move the files to the thumbnail path
            var key = width + 'x' + height;
            var croppedPath = ctx.baseDir + '/' + filename;
            IO.moveFile(files[key].path, croppedPath, function(err) {
                if (err) {
                    return callback(err);
                }

                callback(null, croppedPath);
            });
        });
    });
};
