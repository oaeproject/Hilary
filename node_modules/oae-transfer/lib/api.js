/*!
 * Copyright 2017 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var async = require('async');
var ShortId = require('shortid');
var Validator = require('oae-util/lib/validator').Validator;

var EmailAPI = require('oae-email/lib/api');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var TenantsUtil = require('oae-tenants/lib/util');

var TransferDAO = require('./internal/dao');

/**
 * PUBLIC FUNCTIONS
 */

/**
 * Create a new transfer.
 *
 * @param  {Context}    ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}     originalEmail       The email of the account from which the data will be transferred
 * @param  {String}     targetEmail         The email of the account to which the data will be transferred
 * @param  {String}     originalUserId      The account identifier from which the data will be transferred
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred
 * @api private
 */
var initiateTransfer = module.exports.initiateTransfer = function (ctx, originalUserId, originalEmail, targetEmail, callback) {
    callback = callback || function() {};

    // Verify basic properties
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Anonymous users cannot create a transfer'}).isLoggedInUser(ctx);
    validator.check(originalUserId, {'code': 400, 'msg': 'An originalUserId must be provided'}).notEmpty();
    validator.check(originalEmail, {'code': 400, 'msg': 'An originalEmail must be provided'}).notEmpty();
    validator.check(targetEmail, {'code': 400, 'msg': 'A targetEmail must be provided'}).notEmpty();
    validator.check(originalEmail, {'code': 400, 'msg': 'Invalid email'}).isEmail();
    validator.check(targetEmail, {'code': 400, 'msg': 'Invalid email'}).isEmail();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    TransferDAO.initiateTransfer(ctx, originalUserId, originalEmail, targetEmail, function(err, transfer) {
        if (err) {
            return callback(err);
        }
        return callback(null, transfer);
    });
};

/**
 * Get a transfer by id.
 *
 * @param  {Context}    ctx                 Standard context object containing the current user and the current tenant
 * @param  {string}     originalUserId      The account identifier from which the data will be transferred
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred
 * @api private
 */
var getTransferById = module.exports.getTransferById = function (ctx, originalUserId, callback) {
    callback = callback || function() {};

    // Verify basic properties
    var validator = new Validator();
    validator.check(originalUserId, {'code': 400, 'msg': 'Id cannot be empty'}).notEmpty();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    TransferDAO.getTransferById(originalUserId, function(err, transfer) {
        if (err) {
            return callback(err);
        }

        if (transfer === undefined) {
            var err = {'code': 404, 'msg': 'Transfer not found'};
            return callback(err);
        }

        return callback(null, transfer);
    });
};

/**
 * Start the transfer.
 *
 * @param  {Context}    ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}     originalEmail           The email of the account from which the data will be transferred
 * @param  {String}     code                    The code used by the user to secure the transfer
 * @param  {String}     targetEmail             The email of the account to which the data will be transferred
 * @param  {String}     targetUserId            Id user target
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred
 * @param  {Object}     callback.parsedData     Return array of updated users
 * @api private
 */
var completeTransfer = module.exports.completeTransfer = function (ctx, originalEmail, code, targetEmail, targetUserId, callback) {

    callback = callback || function() {};

    // Verify basic properties
    var validator = new Validator();

    validator.check(null, {'code': 401, 'msg': 'Anonymous users cannot make a transfer'}).isLoggedInUser(ctx);
    validator.check(code, {'code': 400, 'msg': 'Code cannot be empty'}).notEmpty();
    validator.check(targetUserId, {'code': 400, 'msg': 'An targetUserId must be provided'}).notEmpty();
    validator.check(originalEmail, {'code': 400, 'msg': 'An originalEmail must be provided'}).notEmpty();
    validator.check(targetEmail, {'code': 400, 'msg': 'A targetEmail must be provided'}).notEmpty();
    validator.check(originalEmail, {'code': 400, 'msg': 'Invalid email'}).isEmail();
    validator.check(targetEmail, {'code': 400, 'msg': 'Invalid email'}).isEmail();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Find transfer
    TransferDAO.getTransferByEmail(originalEmail, code, function(err, transfer) {
        if (err) {
            return callback(err);
        }

        if (transfer === undefined) {
            var err = {'code': 404, 'msg': 'Transfer not found'};
            return callback(err);
        }

        if (transfer.code !== code || transfer.targetEmail !== targetEmail) {
            var err = {'code': 400, 'msg': 'Code or e-mails doesn\'t match'};
            return callback(err);
        } 

        TransferDAO.completeTransfer(ctx, originalEmail, code, targetEmail, targetUserId, transfer, function(err, members) {
            if (err) {
                return callback(err);
            }

            if (_.isEmpty(members)) {Â 
                return callback();
            } else {

                // If there is no error, send emails to manager to advice them
                _sendEmail(ctx, members, targetUserId, originalEmail, targetEmail, function(err, parsedData) {
                    if (err) {
                        return callback(err);
                    }
                    return callback(null, parsedData);
                });
            }
        });
    });
};

/**
 * Delete the transfer.
 *
 * @param  {Context}    ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}     originalEmail       The email of the account from which the data will be transferred  
 * @param  {String}     code                The code used by the user to secure the transfer
 * @param  {string}     originalUserId      The account identifier from which the data will be transferred
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred
 * @api private
 */
var cancelTransfer = module.exports.cancelTransfer = function (ctx, originalEmail, code, originalUserId, callback) {
    callback = callback || function() {};

    // Verify basic properties
    var validator = new Validator();

    validator.check(code, {'code': 400, 'msg': 'Code cannot be empty'}).notEmpty();
    validator.check(originalUserId, {'code': 400, 'msg': 'Id cannot be empty'}).notEmpty();
    validator.check(originalEmail, {'code': 400, 'msg': 'Invalid email'}).isEmail();
    validator.check(originalEmail, {'code': 400, 'msg': 'Email cannot be empty'}).notEmpty();


    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    TransferDAO.cancelTransfer(originalEmail, code, originalUserId, function(err) {
        if (err) {
            return callback(err);
        } 
        return callback();
    });
};


/**
 * Send an email token to a user that can be used to notify the user transfer
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {Manager}    members         Liste of couple member-resource
 * @param  {String}     oldUserMail     The email of the account from which the data will be transferred
 * @param  {String}     newUserMail     The email of the account to which the data will be transferred
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred
 * @api private
 */
var _sendEmail = function(ctx, members, targetUserId, oldUserMail, newUserMail, callback) {

    // ParseData from variable informations to make an union on user. Start with members
    _parseData(members, function(err, parsedData) {
        if (err) {
            return callback(err);
        }

        async.forEachOf(parsedData, function (hash, i, callback) {

            // Generate a token
            var token = ShortId.generate();

            // Store the token
            PrincipalsDAO.storeEmailToken(ctx.user().id, hash.profile.email, token, function(err) {
                if (err) {
                    return callback(err);
                }

                var userToEmail = _.extend({}, hash.profile, {'email': hash.profile.email, 'id': hash.profile.principalId,'tenant':{'alias': hash.profile.tenantAlias}});
                
                // Send an email to the specified e-mail address
                var data = {
                    'actor': ctx.user(),
                    'transferringAccount': ctx.user(),
                    'tenant': ctx.tenant().displayName,
                    'user': userToEmail,
                    'baseUrl': TenantsUtil.getBaseUrl(ctx.tenant()),
                    'skinVariables': require('oae-ui').getTenantSkinVariables(ctx.tenant().alias),
                    'token': token,
                    'oldUserMail': oldUserMail,
                    'newUserMail': newUserMail,
                    'resources': hash.resources,
                };

                EmailAPI.sendEmail('oae-transfer', 'notify', userToEmail, data, {'hash': Date.now()});
                callback();
            });
        }, function (err) {
            if (err) {
                return callback(err);
            }

            return callback(null, parsedData);
        });
    });
};

/**
 * This function have the objectif to restructure the variable memberHashes because we have for each resource a member 
 * and his associated resource. But in order to send mail, we would need another structure that is a member associated 
 * to several resources.
 *
 * The variable associationMemberResource at the beggining have this structure :
 *            [ [ { profile: [Object] }, { resource: [Object] } ],
 *            [ { profile: [Object] }, { resource: [Object] } ],
 *            [ { profile: [Object] }, { resource: [Object] } ],
 *            [ { profile: [Object] }, { resource: [Object] } ],
 *            [ { profile: [Object] }, { resource: [Object] } ] ]
 *
 * This function will transform the previous structure to this one : 
 *            [ { profile: 
 *                { principalId: 'u:camtest:r1IlKuv8sof',
 *                  displayName: 'random-user-HyNeFOPUisM',
 *                  email: 'random-user-bkqey_viijf_hksgf_wijjg@cam.ac.uk',
 *                  emailPreference: 'immediate',
 *                  locale: 'en_GB',
 *                  publicAlias: 'random-user-HyNeFOPUisM',
 *                  tenantAlias: 'camtest',
 *                  visibility: 'public' },
 *               resources: [ Object, Object ] },
 *             { profile: 
 *                { principalId: 'u:camtest:Sy5xFdw8sjf',
 *                  displayName: 'random-user-SyugtOvUjsf',
 *                  email: 'random-user-h1pefddlojf_h1kgkod8sjz@cam.ac.uk',
 *                  emailPreference: 'immediate',
 *                  locale: 'en_GB',
 *                  publicAlias: 'random-user-SyugtOvUjsf',
 *                  tenantAlias: 'camtest',
 *                  visibility: 'public' },
 *               resources: [ Object, Object, Object ] } ];
 *
 * @param  {Object}     associationMemberResource           List of member associated to a unique resource
 * @param  {Function}   callback                            Standard callback function
 * @param  {Object}     callback._listOfResourcesByMember   List of resources by members
 * @param  {Object}     callback.err                        An error that occurred, if any
 */
var _parseData = function(associationMemberResource, callback, _listOfResourcesByMember) {

    // Return when there are no more association user-elemnt in the array '_listOfResourcesByMember'
    if (!associationMemberResource || _.isEmpty(associationMemberResource)) {
        return callback(null, _listOfResourcesByMember);
    }
    
    // Create another list make a list of resource by user 
    var _listOfResourcesByMember = _listOfResourcesByMember || [];

    // Get the user and the resource form the association to analyse
    var memberAndResource = associationMemberResource.shift();
    var member = memberAndResource[0];
    var resource = memberAndResource[1];

    if (_.isEmpty(_listOfResourcesByMember)) {
        _listOfResourcesByMember.push({'profile': member.profile, 'resources': []});
    }

    var userFoundOnTheList = false;
    var iterate = 0;
    
    async.eachSeries(_listOfResourcesByMember, function (element, callback) {
        
        // If the user is found on '_listOfResourcesByMember', add the resource to user 
        if (element.profile.principalId === member.profile.principalId) {
            userFoundOnTheList = true;
            element.resources.push(resource);
        } 
        iterate += 1;

        return callback();

    }, function () {

        // If user was not found in the list, create it
        if (!userFoundOnTheList) {
            _listOfResourcesByMember.push({'profile': member.profile, 'resources': []});
            _listOfResourcesByMember[iterate].resources.push(resource);   
        }

        return _parseData(associationMemberResource, callback, _listOfResourcesByMember);
    });
};
