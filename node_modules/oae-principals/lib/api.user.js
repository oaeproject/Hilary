/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var csv = require('csv');
var events = require('events');
var fs = require('fs');
var Path = require('path');
var ShortId = require('shortid');
var util = require('util');

var AuthenticationConstants = require('oae-authentication/lib/constants').AuthenticationConstants;
var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var Config = require('oae-config/lib/api').config('oae-principals');
var Context = require('oae-context').Context;
var log = require('oae-logger').logger('oae-principals');
var Redis = require('oae-util/lib/redis');
var Validator = require('oae-util/lib/validator').Validator;
var TenantsAPI = require('oae-tenants');
var TZ = require('oae-util/lib/tz');
var Validator = require('oae-util/lib/validator').Validator;

var PrincipalsConstants = require('./constants').PrincipalsConstants;
var PrincipalsDAO = require('./internal/dao');
var PrincipalsEmitter = require('./internal/emitter');
var PrincipalsModel = require('./model');
var PrincipalsUtil = require('./util');

/**
 * Create a new user on the current tenant.
 *
 * @param  {Context}   ctx                     The current context
 * @param  {String}    displayName             A display name to represent the user on the UI
 * @param  {Object}    [opts]                  Optional parameters for the user
 * @param  {String}    [opts.visibility]       The user's visibility setting (One of PrincipalsConstants.visibility)
 * @param  {String}    [opts.locale]           The user's locale
 * @param  {String}    [opts.timezone]         The user's timezone
 * @param  {String}    [opts.publicAlias]      This name will be what is seen when when the user is displayed to someone who does not have access to the profile
 * @param  {String}    [opts.smallPictureUri]  The URI for the small picture
 * @param  {String}    [opts.mediumPictureUri] The URI for the medium picture
 * @param  {String}    [opts.largePictureUri]  The URI for the large picture
 * @param  {Function}  callback                Standard callback function
 * @param  {Object}    callback.err            Error object containing the error message
 * @param  {User}      callback.createdUser    A User object representing the created user
 */
var createUser = module.exports.createUser = function(ctx, displayName, opts, callback) {
    opts = opts || {};
    callback = callback || function(err) {
        if (err) {
            log().error({
                'err': err,
                'displayName': displayName
            }, 'Error creating user');
        }
    };

    var tenantAlias = ctx.tenant().alias;

    opts.locale = opts.locale || Config.getValue(tenantAlias, 'user', 'defaultLanguage');
    opts.timezone = TZ.getClosestSupportedTimezone(opts.timezone);
    opts.visibility = opts.visibility || PrincipalsConstants.visibility.PUBLIC;
    opts.publicAlias = opts.publicAlias || displayName;

    var validator = new Validator();
    validator.check(displayName, {'code': 400, 'msg': 'A display name must be provided'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'A displayName can only be 1000 characters long'}).isShortString();
    validator.check(opts.visibility, {'code': 400, 'msg': 'The specified visibility setting is unknown'}).isIn(_.values(PrincipalsConstants.visibility));
    validator.check(opts.timezone, {'code': 400, 'msg': 'The specified timezone is invalid'}).isValidTimeZone();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var id = AuthzUtil.toId('u', tenantAlias, ShortId.generate());

    var values = {
        'tenantAlias': tenantAlias,
        'displayName': displayName,
        'visibility': opts.visibility,
        'email': opts.email,
        'locale': opts.locale,
        'timezone': opts.timezone,
        'publicAlias': opts.publicAlias,
        'smallPictureUri': opts.smallPictureUri,
        'mediumPictureUri': opts.mediumPictureUri,
        'largePictureUri': opts.lagePictureUri
    };

    var q = Cassandra.constructUpsertCQL('Principals', 'principalId', id, values);
    if (!q) {
        return callback({'code': 500, 'msg': 'Could not create a proper CQL query'});
    }

    // Create the user
    Cassandra.runQuery(q.query, q.parameters, function (err) {
        if (err) {
            return callback(err);
        }

        var createdUser = new PrincipalsModel.User(tenantAlias, id, displayName, opts);
        PrincipalsEmitter.emit(PrincipalsConstants.events.CREATED_USER, ctx, createdUser);
        return callback(null, createdUser);
    });
};

/**
 * Import a batch of users from a CSV file. The CSV file should be formatted in the following way:
 *
 *  `externalId, lastName, firstName, email`
 *
 * When importing a set of users using the local authentication strategy, the CSV format should be the following:
 *
 *  `externalId, password, lastName, firstName, email`
 *
 * When an external id for the provided authentication method cannot be found, a new user will be created. When that
 * user can be found, no new user will be created. When that user's display name is the same as their external id and
 * a real display name is available in the CSV file, the user's display name will be updated to be the one in the CSV
 * file. This accounts for the scenario where an external authentication provider that doesn't release the required
 * basic profile attributes was configured and users signed into it before the full user list with appropriate basic
 * profile attributes was imported.
 *
 * @param  {Context}        ctx                     The current context
 * @param  {String}         [tenantAlias]           The alias of the tenant on which the users should be loaded
 * @param  {Object}         userCSV                 File object representing the uploaded CSV file as returned by express
 * @param  {String}         authenticationMethod    The authentication method with which the provided external ids should be associated (One of AuthenticationConstants.providers)
 * @param  {Function}       callback                Standard callback function. In case a valid request has been made, this will be called after the CSV file has been parsed and before the users are imported. Therefore, it does not take import failures into account
 * @param  {Object}         callback.err            Error object containing the error message
 */
var importUsers = module.exports.importUsers = function(ctx, tenantAlias, userCSV, authenticationMethod, callback) {
    callback = callback || function() {};

    // If no tenant alias has been provided, we fall back to the current context tenant
    tenantAlias = tenantAlias || ctx.user().tenant.alias;
    var tenant = TenantsAPI.getTenant(tenantAlias);

    // Only global or tenant administrators should be able to import users
    if (!ctx.user() || !ctx.user().isAdmin(tenantAlias)) {
        return callback({'code': 401, 'msg': 'Only authorized admins can import users'});
    }

    // Parameter validation
    var validator = new Validator();
    validator.check(tenant, {'code': 400, 'msg': 'An existing tenant alias must be provided'}).notNull();
    validator.check(userCSV, {'code': 400, 'msg': 'A CSV file must be provided'}).notNull();
    if (userCSV) {
        validator.check(userCSV.size, {'code': 400, 'msg': 'Missing size on the CSV file'}).notEmpty();
        validator.check(userCSV.size, {'code': 400, 'msg': 'Invalid size on the CSV file'}).isInt();
        validator.check(userCSV.size, {'code': 400, 'msg': 'Invalid size on the CSV file'}).min(0);
        validator.check(userCSV.name, {'code': 400, 'msg': 'Missing name on the CSV file'}).notEmpty();
    }
    validator.check(authenticationMethod, {'code': 400, 'msg': 'An authentication method must be provided'}).notEmpty();
    validator.check(authenticationMethod, {'code': 400, 'msg': 'The specified authentication method is unknown'}).isIn(_.values(AuthenticationConstants.providers));
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Create a new context object on the request tenant
    var adminCtx = new Context(tenant, ctx.user());

    // Read and parse the CSV file into an array
    csv().from.path(userCSV.path).to.array(function(data) {

        // If the CSV parse was successful, we call the callback to prevent the request from timing out
        // whilst the users are being loaded
        PrincipalsEmitter.emit('preCSVUserImport');
        callback();

        log(ctx).info({
            'tenantAlias': tenantAlias,
            'authenticationMethod': authenticationMethod
        }, 'Starting user import from CSV');

        /*!
         * Process an invidual user from the CSV file and create a new user if no user exists for the provided
         * external id - authentication method combination.
         *
         * @param  {String[][]}     data        Parsed CSV file
         */
        var processUser = function(data) {
            // Get the next user from the stack
            var user = data.pop();

            // Extract the password in case local authentication is used
            var opts = {};
            if (authenticationMethod === AuthenticationConstants.providers.LOCAL) {
                opts.password = user.splice(1, 1);
            }

            // Extract the basic profile data
            var externalId = user[0];
            // Construct the first name and last name into a display name
            var displayName = util.format('%s %s', user[2], user[1]).trim();
            opts.email = user[3];

            // Check if the user already exists and create a new user if it doesn't
            // TODO: Fix cross-dependency between the Authentication API and the Principals API
            require('oae-authentication').getOrCreateUser(adminCtx, authenticationMethod, externalId, displayName, opts, function(err, user) {

                if (err) {
                    log(ctx).error({
                        'err': err,
                        'externalId': externalId,
                        'displayName': displayName
                    }, 'Failed to import user from CSV');
                // If the user already existed and its displayName is the same as the external id, we update the user's display
                // name to be the one provided in the CSV file
                } else if (user.displayName === externalId && user.displayName !== displayName) {
                    log(ctx).info({
                        'externalId': externalId,
                        'user': user,
                        'displayName': displayName
                    }, 'Updating display name during import from CSV');
                    updateUser(adminCtx, user.id, {'displayName': displayName});
                }

                log(ctx).info({
                    'externalId': externalId,
                    'user': user
                }, 'Imported user. ' + data.length + ' users left to import');

                if (data.length === 0) {
                    // Send out an event indicating that the import has finished
                    PrincipalsEmitter.emit('postCSVUserImport');
                } else {
                    // Process the next user
                    processUser(data);
                }
            });
        };

        // Process the first user
        processUser(data);

    }).on('error', function(err){
        // Parsing error
        callback({'code': 500, 'msg': err.message});
    });
};

/**
 * Update a user
 *
 * @param  {Context}        ctx             The current context
 * @param  {String}         userId          The userId of the user you wish to update
 * @param  {Object}         profileFields   Object that represent the profile fields that should be updated. Possible keys are visibility, displayName, publicAlias, locale and timezone
 * @param  {Function}       callback        Standard callback function
 * @param  {Object}         callback.err    Error object containing the error message
 * @param  {User}           callback.user   A user object representing the updated profile
 */
var updateUser = module.exports.updateUser = function(ctx, userId, profileFields, callback) {
    callback = callback || function() {};
    profileFields = profileFields || {};

    var profileFieldKeys = _.keys(profileFields);

    // Parameter validation
    var validator = new Validator();
    validator.check(userId, {'code': 400, 'msg': 'A user id must be provided'}).notEmpty();
    // Check that there is at least one updated profile field.
    validator.check(profileFieldKeys.length, {'code': 400, 'msg': 'At least one basic profile field should be specified'}).min(1);

    // verify that restricted properties aren't set here
    var invalidKeys = _.intersection(PrincipalsDAO.getRestrictedFields(), profileFieldKeys);
    validator.check(invalidKeys.length, {'code': 400, 'msg': 'Restricted property was attempted to be set.'}).max(0);

    if (profileFields['displayName']) {
        validator.check(profileFields['displayName'], {'code': 400, 'msg': 'A displayName cannot be empty'}).notEmpty();
        validator.check(profileFields['displayName'], {'code': 400, 'msg': 'A displayName can only be 1000 characters long'}).isShortString();
    }

    // In case a new visibility has been passed in, we check for its validity
    if (profileFields['visibility']) {
        validator.check(profileFields['visibility'], {'code': 400, 'msg': 'An invalid visibility option has been specified'}).isIn(_.values(PrincipalsConstants.visibility));
    }
    if (profileFields['timezone']) {
        validator.check(profileFields['timezone'], {'code': 400, 'msg': 'The specified timezone is invalid'}).isValidTimeZone();
        profileFields.timezone = TZ.getClosestSupportedTimezone(profileFields.timezone);
    }
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a user'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Only update existing users
    getUser(ctx, userId, function(err, oldUser) {
        if (err) {
            return callback(err);
        }

        // Only the current user or an admin can update a user
        var principalResource = AuthzUtil.getResourceFromId(userId);
        if (ctx.user().id === userId || ctx.user().isAdmin(principalResource.tenantAlias)) {
            PrincipalsDAO.updatePrincipal(userId, profileFields, function(err) {
                if (err) {
                    return callback(err);
                }

                var newUser = PrincipalsUtil.createUpdatedUser(oldUser, profileFields);
                PrincipalsEmitter.emit(PrincipalsConstants.events.UPDATED_USER, ctx, newUser, oldUser);
                return getUser(ctx, userId, callback);
            });
        } else {
            callback({'code': 401, 'msg': 'You are not authorized to update this user\'s profile.'});
        }
    });
};

/**
 * Get a user from the DB
 *
 * @param  {Context}   ctx             The current context
 * @param  {String}    userId          The userId for the user you wish to retrieve
 * @param  {Function}  callback        Standard callback function
 * @param  {Object}    callback.err    Error object containing the error message
 * @param  {User}      callback.user   The user object
 */
var getUser = module.exports.getUser = function(ctx, userId, callback) {

    var validator = new Validator();
    validator.check(userId, {'code': 400, 'msg': 'Must provide a user id'}).isValidId();
    validator.check(userId, {'code': 400, 'msg': 'The provided userId is not a user identifier'}).isUserId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    PrincipalsUtil.getPrincipal(ctx, userId, callback);
};

/**
 * Gets the me feed for the current user, if anonymous returns 'anon': true
 * If logged in returns structured me feed object in the callback
 *
 *     {
 *         "profilePath": "/person/u:global:bert",
 *         "id": "u:global:bert",
 *         "displayName": "Bert Pareyn",
 *         "publicAlias": "Bert the Merciful"
 *         "visibility": "private",
 *         "isTenantAdmin": true,
 *         "isGlobalAdmin": false,
 *         "resourceType": "user"
 *         "extra": {
 *             <Extra basic profile fields>
 *         },
 *         "locale": {
 *             "locale": "en_GB",
 *             "timezone": {
 *                 "name": "Europe/London",
 *                 "offset": 1
 *             }
 *         }
 *     }
 *
 * If error returns error object
 *
 * @param  {Context}   ctx            The current context
 * @param  {Function}  callback       Standard callback function
 * @param  {Object}    callback.err   Error object containing the error message
 * @param  {Object}    callback.data  The me feed data for the user
 */
var getMe = module.exports.getMe = function(ctx, callback) {
    if (!ctx.user()) {
        return callback({'code': 200,'msg': {
                'anon': true,
                'tenant': ctx.tenant().compact()
            }
        });
    }

    getUser(ctx, ctx.user().id, function(err, data) {
        if (err) {
            return callback(err);
        }

        // Calculate timezone offset in hours.
        var now = new TZ.Date(ctx.user().timezone);
        var offset = -1 * now.getTimezoneOffset() / 60;

        data.isTenantAdmin = ctx.user().isTenantAdmin(ctx.user().tenant.alias);
        data.isGlobalAdmin = ctx.user().isGlobalAdmin();

        data.locale = {
            'locale': ctx.user().locale,
            'timezone': {
                'name': ctx.user().timezone,
                'offset': offset
            }
        };

        callback(null, data);
    });
};

/**
 * Set a flag that indicates whether a user is a tenant admin.
 * The ctx user must be a tenant or global admin to be able to do this.
 *
 * @param  {Context}   ctx             Context that holds the tenant
 * @param  {User}      principalId     The user that needs the flag
 * @param  {Boolean}   isAdmin         Flag that indicates whether the provided user should be a tenant admin
 * @param  {Function}  callback        Standard callback function
 * @param  {Object}    callback.err    Error object containing the error message
 */
var setTenantAdmin = module.exports.setTenantAdmin = function(ctx, principalId, isAdmin, callback) {
    var principalResource = AuthzUtil.getResourceFromId(principalId);
    if (ctx.user() && ctx.user().isAdmin(principalResource.tenantAlias)) {
        _setAdmin(ctx, 'admin:tenant', isAdmin, principalId, callback);
    } else {
        return callback({'code': 401, 'msg': 'You do not have sufficient rights to make someone an admin.'});
    }
};

/**
 * Set a flag that indicates whether a user is a glbal admin.
 * The ctx user must be a global admin to be able to do this.
 *
 * @param  {Context}   ctx             Context that holds the tenant
 * @param  {User}      user            The user that needs the flag
 * @param  {Boolean}   isAdmin         Flag that indicates whether the provided user should be a global admin
 * @param  {Function}  callback        Standard callback function
 * @param  {Object}    callback.err    Error object containing the error message
 */
var setGlobalAdmin = module.exports.setGlobalAdmin = function(ctx, principalId, isAdmin, callback) {
    if (ctx.user() && ctx.user().isGlobalAdmin && ctx.user().isGlobalAdmin()) {
        _setAdmin(ctx, 'admin:global', isAdmin, principalId, callback);
    } else {
        return callback({'code': 401, 'msg': 'You do not have sufficient rights to make someone an admin.'});
    }
};

/**
 * Internal method that makes a user an admin. This method will do all the necessary validation
 * of the user ctx and passed in parameters.
 *
 * @param  {Context}        ctx             Context that holds the current user and tenant
 * @param  {String}         adminType       One of `admin:global` or `admin:tenant`
 * @param  {Boolean}        isAdmin         Flag that indicates whether this user should be an admin or not
 * @param  {String}         principalId     The uuid of the user that needs to be made an admin
 * @param  {Function}       callback        Standard callback function
 * @param  {Object}         callback.err    Error object containing the error message
 * @api private
 */
var _setAdmin = function(ctx, adminType, isAdmin, principalId, callback) {
    if (!PrincipalsUtil.isUser(principalId)) {
        return callback({'code': 400, 'msg': 'The provided principalId is not a user.'});
    }

    // Double-check that this user exists.
    getUser(ctx, principalId, function(err, user) {
        if (err) {
            return callback(err);
        }

        PrincipalsDAO.setAdmin(adminType, isAdmin, principalId, callback);
    });
};
