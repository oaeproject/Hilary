/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var passport = require('passport');

var crypto = require('crypto');

var util = require('util');

var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzInvitationsDAO = require('oae-authz/lib/invitations/dao');
var Cassandra = require('oae-util/lib/cassandra');
var ConfigAPI = require('oae-config');
var EmitterAPI = require('oae-emitter');
var Locking = require('oae-util/lib/locking');
var EmailAPI = require('oae-email');
var OaeEmitter = require('oae-util/lib/emitter');
var OaeServer = require('oae-util/lib/server');
var OaeUtil = require('oae-util/lib/util');
var PrincipalsAPI = require('oae-principals');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var TenantsAPI = require('oae-tenants');
var TenantsUtil = require('oae-tenants/lib/util');
var log = require('oae-logger').logger('oae-authentication');
var Validator = require('oae-authz/lib/validator').Validator;
var AuthenticationConfig = ConfigAPI.config('oae-authentication');
var AuthenticationConstants = require('oae-authentication/lib/constants').AuthenticationConstants;
var AuthenticationUtil = require('oae-authentication/lib/util');

var LoginId = require('oae-authentication/lib/model').LoginId;

var globalTenantAlias = null;

// Holds the strategies for each tenant
var strategies = {};

// Setup functions for different strategies, keyed by the strategy name
var strategySetup = {};

// When a tenant is created, configure the default authentication strategies
TenantsAPI.on('created', function(tenant) {
    refreshStrategies(tenant);
});

// When a tenant starts up, configure its authentication strategies
TenantsAPI.on('start', function(tenant) {
    refreshStrategies(tenant);
});

// When a tenant is refreshed, refresh its authentication strategies
TenantsAPI.on('refresh', function(tenant) {
    refreshStrategies(tenant);
});

// When the server has started up, we enable all the strategies for all the tenants
OaeEmitter.on('ready', function() {
    _refreshAllTenantStrategies();
});

/**
 * Refresh the tenant authentication strategies when the configuration for a tenant has been updated.
 * In case the configuration of the global admin tenant was updated, all authentication strategies will
 * be refreshed. In case the configuration for an individual tenant was updated, only the authentication
 * strategies for that tenant will be refreshed.
 *
 * @param  {String}     [tenantAlias]       The alias of the tenant for which to refresh the authentication strategies. If `null` or the global tenant alias is specified, all strategies will be refreshed
 * @api private
 */
var _configUpdate = function(tenantAlias) {
    if (!tenantAlias || tenantAlias === globalTenantAlias) {
        // We updated the global tenant, which means we'll have to update all
        // tenant authentication strategies, as they may have changed transiently
        _refreshAllTenantStrategies();
    } else {
        var tenant = TenantsAPI.getTenant(tenantAlias);
        if (!tenant) {
            return log().error({'tenantAlias': tenantAlias}, 'Error fetching tenant to update authentication configuration');
        }

        refreshStrategies(tenant);
    }
};

ConfigAPI.on('update', _configUpdate);

/**
 * ### Events
 *
 * The `AuthenticationAPI`, as enumerated in `AuthenticationConstants.events`, emits the following events:
 *
 * * `refreshedStrategies(tenant)`: The authentication strategies have been refreshed with the current configuration. The tenant that was refreshed is returned as a `Tenant` object.
 * * `userImpostered(imposter, user)`: A user was impostered by another user
 * * `userLoggedIn(user, strategyName)`: A user logged into the system. The strategy that was used to log in is provided
 * * `userLoggedOut(ctx)`: A user logged out of the system
 */
var AuthenticationAPI = module.exports = new EmitterAPI.EventEmitter();

/**
 * Initializes the configuration of the authentication module.
 *
 * @param  {String} globalTenantAlias   The alias of the global tenant
 */
var init = module.exports.init = function(_globalTenantAlias) {
    globalTenantAlias = _globalTenantAlias;
};



////////////////////////
////////////////////////
// USER ID MANAGEMENT //
////////////////////////
////////////////////////

/**
 * Determine if a local username already exists
 *
 * @param  {Context}   ctx                Standard context object containing the current user and the current tenant
 * @param  {String}    [tenantAlias]      The alias of the tenant on which to check for existence. Defaults to the current tenant
 * @param  {String}    username           The username to check existence for
 * @param  {Function}  callback           Standard callback function
 * @param  {Object}    callback.err       An error that occurred, if any
 * @param  {Boolean}   callback.exists    Whether or not the username exists on the current tenant
 */
var localUsernameExists = module.exports.localUsernameExists = function(ctx, tenantAlias, username, callback) {
    tenantAlias = tenantAlias || ctx.tenant().alias;

    // Create the loginid object first, so it can be passed into the validation
    var loginId = new LoginId(tenantAlias, AuthenticationConstants.providers.LOCAL, username);

    // Parameter validation
    var validator = new Validator();
    validator.check(username, {'code': 400, 'msg': 'Please specify a username'}).notEmpty();
    _validateLoginIdForLookup(validator, loginId);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getUserIdFromLoginId(loginId, function(err, userId) {
        if (err && err.code !== 404) {
            return callback(err);
        } else if (!userId) {
            return callback(null, false);
        }

        return callback(null, true);
    });
};

/**
 * Get the global administrator with the given username. If no user exists with the given username,
 * create a private user with the provided username, password and profile information and make them
 * a global admin
 *
 * @param  {Context}    ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}     username                The unique username for the global administrator
 * @param  {String}     password                The password for the global administrator
 * @param  {String}     displayName             The display name for the global administrator
 * @param  {String}     [opts]                  Optional user profile parameters
 * @param  {String}     [opts.locale]           The locale for the global administrator
 * @param  {String}     [opts.email]            The email address for the global administrator
 * @param  {string}     [opts.emailPreference]  The email preference for the global administrator
 * @param  {String}     [opts.publicAlias]      The name to show when the global administrator is inaccessible to a user
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {User}       callback.user           The user associated with the provided username
 * @param  {String}     callback.loginId        The *flattened* loginId for this user
 * @param  {Boolean}    callback.created        `true` if a global administrator was created with the provided username, `false` otherwise
 */
var getOrCreateGlobalAdminUser = module.exports.getOrCreateGlobalAdminUser = function(ctx, username, password, displayName, opts, callback) {
    opts = opts || {};

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You must be authenticated to the global admin tenant to create a global administrator user'}).isLoggedInUser(ctx, globalTenantAlias);
    validator.check(null, {'code': 401, 'msg': 'You must be a global administrator to create a global administrator user'}).isGlobalAdministratorUser(ctx);
    validator.check(username, {'code': 400, 'msg': 'You must provide a username'}).notEmpty();
    validator.check(password, {'code': 400, 'msg': 'You must provide a password'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'You must provide a display name'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'A display name can be at most 1000 characters long'}).isShortString();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Global admin users always start out private
    opts.visibility = AuthzConstants.visibility.PRIVATE;

    // Global admins can only be created by other global administrators,
    // who probably know the email address is accurate
    opts.emailVerified = true;

    var providerProperties = {'password': password};
    getOrCreateUser(ctx, AuthenticationConstants.providers.LOCAL, username, providerProperties, displayName, opts, function(err, user, loginId, created) {
        if (err) {
            return callback(err);
        } else if (!created) {
            // The user already existed, just return the existing user
            return callback(null, user, loginId, false);
        }

        // The user was created, mark them as a global admin user
        PrincipalsAPI.setGlobalAdmin(ctx, user.id, true, function(err) {
            if (err) {
                return callback(err);
            } else if (created) {
                log().info({'user': user, 'username': username}, 'Global Admin account created');
            }

            // Fetch the user again to get the updated version of the user
            PrincipalsAPI.getUser(ctx, user.id, function(err, user) {
                if (err) {
                    return callback(err);
                }

                return callback(null, user, loginId, true);
            });
        });
    });
};

/**
 * Utility methods that gets a user by the login id. If the user doesn't exist yet, it will be created.
 *
 * @param  {Context}    ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}     authProvider            The authentication provider of the login id
 * @param  {String}     externalId              The desired externalId/username for this user
 * @param  {String}     displayName             The display name for the user
 * @param  {String}     [opts]                  Optional user profile parameters
 * @param  {String}     [opts.locale]           The locale for the user
 * @param  {String}     [opts.email]            The email address for the user
 * @param  {String}     [opts.emailPreference]  The email preference for the user
 * @param  {String}     [opts.visibility]       The visibility of the user. One of: @see AuthzConstants.visibility
 * @param  {String}     [opts.publicAlias]      The name to show when the user is inaccessible to a user
 * @param  {String}     [opts.invitationToken]  If specified indicates that there was an invitation token available when creating the account. If it is for an email that matches the user's specified email, then the email will be considered verified
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {User}       callback.user           The user that was fetched or created
 * @param  {String}     callback.loginId        The *flattened* loginId for this user
 * @param  {Boolean}    callback.created        `true` if the user was created, `false` otherwise
 */
var getOrCreateUser = module.exports.getOrCreateUser = function(ctx, authProvider, externalId, providerProperties, displayName, opts, callback) {
    var validator = new Validator();
    validator.check(displayName, {'code': 400, 'msg': 'You must provide a display name'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'A display name can be at most 1000 characters long'}).isShortString();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Create the expected login id and ensure it is valid for potentially persisting into storage
    var loginId = new LoginId(ctx.tenant().alias, authProvider, externalId, providerProperties);
    _validateLoginIdForPersistence(validator, loginId);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    return _getOrCreateUser(ctx, loginId, displayName, opts, callback);
};

/**
 * Create a user with the given login id if no user exists for it yet
 *
 * @param  {Context}    ctx                     Standard context object containing the current user and the current tenant
 * @param  {LoginId}    loginId                 The login id to use to fetch or create the user
 * @param  {String}     displayName             The display name for the user
 * @param  {Object}     [opts]                  Optional user profile parameters
 * @param  {String}     [opts.invitationToken]  Will be specified to auto-validate the user's email address. If the user account does not exist yet, and the invitation token is not valid, then account creation will fail
 * @param  {Boolean}    [opts.authoritative]    When `true`, the email domain validation check will be skipped and the user account will be created
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {User}       callback.user           The user that was fetched or created
 * @param  {String}     callback.loginId        The *flattened* loginId for this user
 * @param  {Boolean}    callback.created        `true` if the user was created, `false` otherwise
 * @api private
 */
var _getOrCreateUser = function(ctx, loginId, displayName, opts, callback) {
    opts = opts || {};

    _getUserIdFromLoginId(loginId, function(err, userId) {
        if (err && err.code !== 404) {
            return callback(err);
        } else if (!userId) {
            // No user mapped to this login id so we will create a user for it
            log(ctx).trace({
                'authProvider': loginId.provider,
                'externalId': loginId.externalId,
                'displayName': displayName,
                'opts': opts
            }, 'Auto-creating a user on login');

            // Remove invalid email address if they come from authoritative sources. This happens
            // when a Shib or Cas IdP has been misconfigured
            if (opts.authoritative && opts.email) {
                var validator = new Validator();
                validator.check(opts.email, {'code': 400, 'msg': 'Invalid email'}).isEmail();
                if (validator.hasErrors()) {
                    delete opts.email;
                }
            }

            OaeUtil.invokeIfNecessary(opts.invitationToken, AuthzInvitationsDAO.getEmailByToken, opts.invitationToken, function(err, email) {
                if (err) {
                    return callback(err);
                } else if (email && !opts.email) {
                    // If no email is provided by the auth provider, set the email associated to the
                    // token as the verified email
                    opts.email = email;
                    opts.emailVerified = true;
                } else if (email && email === opts.email) {
                    // If an email is provided by the auth provider and it matches that of the
                    // invitation token (if any), mark the email as verified
                    opts.emailVerified = true;
                }

                var isAdmin = (ctx.user() && ctx.user().isAdmin(ctx.tenant().alias));

                // If an email address was provided by a non authoritative source (Facebook, Twitter,
                // Google, Local authentication) by a user that is not an administrator we should
                // check whether the email address matches the tenant's configured email domain
                var shouldCheckEmail = (!_.isEmpty(ctx.tenant().emailDomains) && !isAdmin && !opts.authoritative);

                // However, if a user followed a link from an invitation email we do not check whether
                // the email belongs to the configured tenant's email domain. This is to allow for the
                // situation where a tenant's email domain gets changed after a user gets invited
                // but before the user has accepted the invitation
                if (opts.invitationToken && opts.emailVerified) {
                    shouldCheckEmail = false;
                }

                OaeUtil.invokeIfNecessary(shouldCheckEmail, _validateEmailBelongsToTenant, ctx, opts.email, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    createUser(ctx, loginId, displayName, opts, function(err, user) {
                        if (err) {
                            return callback(err);
                        }

                        return callback(null, user, _flattenLoginId(loginId), true);
                    });
                });
            });
        } else {
            // The user existed, simply fetch their profile
            PrincipalsDAO.getPrincipal(userId, function(err, user) {
                if (err) {
                    return callback(err);
                } else if (user.deleted) {
                    return callback({'code': 401, 'msg': 'Provided login id belongs to a deleted user'});
                }

                return callback(null, user, _flattenLoginId(loginId), false);
            });
        }
    });
};

/**
 * Validate that an email address belongs to the tenant in context
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     email           The email address to validate
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 * @api private
 */
var _validateEmailBelongsToTenant = function(ctx, email, callback) {
    // Ensure an email address has been provided
    if (!email) {
        return callback({
            'code': 400,
            'msg': 'An email address was not provided when a tenant email domain has been configured',
            'reason': 'email_missing'
        });
    }

    // Ensure the email address belongs to the current tenant
    var tenant = TenantsAPI.getTenantByEmail(email);
    if (ctx.tenant().alias !== tenant.alias) {
        return callback({
            'code': 400,
            'msg': 'An email address was provided that does not match the configured email domain',
            'reason': 'email_domain_mismatch'
        });
    }

    return callback();
};

/**
 * Create a private tenant administrator user with the provided login id
 *
 * @param  {Context}    ctx                         Standard context object containing the current user and the current tenant
 * @param  {LoginId}    loginId                     The login id that will be associated with the tenant administrator so they may log in
 * @param  {String}     displayName                 The display name for the tenant administrator
 * @param  {Object}     [opts]                      Optional user profile parameters
 * @param  {String}     [opts.email]                The email address for the user
 * @param  {String}     [opts.emailPreference]      The email preference for the tenant administrator. One of: @see PrincipalsConstants.emailPreference
 * @param  {String}     [opts.locale]               The locale for the tenant administrator
 * @param  {String}     [opts.publicAlias]          The name to show when the tenant administrator is inaccessible to a user
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error that occurred, if any
 * @param  {User}       callback.user               The created tenant administrator
 */
var createTenantAdminUser = module.exports.createTenantAdminUser = function(ctx, loginId, displayName, opts, callback) {
    opts = opts || {};

    var validator = new Validator();
    validator.check(null, {'code': 400, 'msg': 'A LoginId must be provided'}).isObject(loginId);
    validator.check(displayName, {'code': 400, 'msg': 'You must provide a display name'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'A display name can be at most 1000 characters long'}).isShortString();
    _validateLoginIdForPersistence(validator, loginId);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var targetTenant = TenantsAPI.getTenant(loginId.tenantAlias);
    if (!targetTenant) {
        return callback({'code': 404, 'msg': 'A non-existing tenant was specified as the target for this user'});
    } else if (targetTenant.isGlobalAdminServer) {
        return callback({'code': 400, 'msg': 'A tenant administrator cannot be created on the global admin tenant'});
    } else if (!ctx.user() || !ctx.user().isAdmin(targetTenant.alias)) {
        return callback({'code': 401, 'msg': 'Only administrators can create new tenant administrators'});
    }

    // Tenant administrators always start private
    opts.visibility = AuthzConstants.visibility.PRIVATE;

    // Tenant administrators can only be created by other administrators,
    // who probably know the email address is accurate
    opts.emailVerified = true;

    // Create the user object with their login id
    _createUser(ctx, loginId, displayName, opts, function(err, user) {
        if (err) {
            return callback(err);
        }

        // Make the created user a tenant admin
        PrincipalsAPI.setTenantAdmin(ctx, user.id, true, function(err) {
            if (err) {
                return callback(err);
            }

            return callback(null, user);
        });
    });
};

/**
 * Create a user with the provided login id
 *
 * @param  {Context}    ctx                         Standard context object containing the current user and the current tenant
 * @param  {LoginId}    loginId                     The login id that will be associated with the user so they may log in
 * @param  {String}     displayName                 The display name for the user
 * @param  {Object}     [opts]                      Optional user profile parameters
 * @param  {Boolean}    [opts.acceptedTC]           Whether or not the user has accepted the Terms and Conditions
 * @param  {String}     [opts.locale]               The locale for the user
 * @param  {String}     [opts.email]                The email address for the user
 * @param  {String}     [opts.emailPreference]      The email preference for the user. One of: @see PrincipalsConstants.emailPreference
 * @param  {String}     [opts.visibility]           The visibility of the user. One of: @see AuthzConstants.visibility
 * @param  {String}     [opts.publicAlias]          The name to show when the user is inaccessible to a user
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error that occurred, if any
 * @param  {User}       callback.user               The created user
 */
var createUser = module.exports.createUser = function(ctx, loginId, displayName, opts, callback) {
    var validator = new Validator();
    validator.check(displayName, {'code': 400, 'msg': 'You must provide a display name'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'A display name can be at most 1000 characters long'}).isShortString();
    _validateLoginIdForPersistence(validator, loginId);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var targetTenant = TenantsAPI.getTenant(loginId.tenantAlias);
    if (!targetTenant) {
        return callback({'code': 404, 'msg': 'A non-existing tenant was specified as the target for this user'});
    }

    var isGlobalAdmin = (ctx.user() && ctx.user().isGlobalAdmin());
    if (targetTenant.isGlobalAdminServer && !isGlobalAdmin) {
        // Only global admins can create users on the global admin tenant
        return callback({'code': 401, 'msg': 'Only global administrators may create a user on the global admin tenant'});
    } else if (ctx.tenant().alias !== targetTenant.alias && !isGlobalAdmin) {
        // Only global admins can create users on a tenant other than the current
        return callback({'code': 401, 'msg': 'Only global administrators may create users on a tenant that is not the current'});
    }

    _createUser(ctx, loginId, displayName, opts, callback);
};

/**
 * Internal utility function to create a user. Validation on inputs should be performed before
 * calling this function
 *
 * @param  {Context}    ctx                         Standard context object containing the current user and the current tenant
 * @param  {LoginId}    loginId                     The login id that will be associated with the user so they may log in
 * @param  {String}     displayName                 The display name for the user
 * @param  {Object}     [opts]                      Optional user profile parameters
 * @param  {Boolean}    [opts.acceptedTC]           Whether or not the user has accepted the Terms and Conditions
 * @param  {String}     [opts.locale]               The locale for the user
 * @param  {String}     [opts.email]                The email address for the user
 * @param  {String}     [opts.emailPreference]      The email preference for the user. One of: @see PrincipalsConstants.emailPreference
 * @param  {String}     [opts.visibility]           The visibility of the user. One of: @see AuthzConstants.visibility
 * @param  {String}     [opts.publicAlias]          The name to show when the user is inaccessible to a user
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error that occurred, if any
 * @param  {User}       callback.user               The created user
 * @api private
 */
var _createUser = function(ctx, loginId, displayName, opts, callback) {
    // Lock on externalId to make sure we're not already making an account for this user
    var lockKey = loginId.externalId;
    Locking.acquire(lockKey, 15, function(err, lockToken) {
        if (err) {
            return callback(err);
        } else if (!lockToken) {
            return callback({'code': 400, 'msg': 'This login id already exists and is already associated to a user'});
        }

        // Make sure the loginId is not already associated to a user
        _getUserIdFromLoginId(loginId, function(err, userId) {
            if (err && err.code !== 404) {
                return callback(err);
            } else if (userId) {
                return callback({'code': 400, 'msg': 'This login id already exists and is already associated to a user'});
            }

            // Hash the user password
            if (loginId.provider === AuthenticationConstants.providers.LOCAL) {
                loginId.properties.password = AuthenticationUtil.hashPassword(loginId.properties.password);
            }

            // Create the user and immediately associate the login id
            PrincipalsAPI.createUser(ctx, loginId.tenantAlias, displayName, opts, function(err, user) {
                if (err) {
                    Locking.release(lockKey, lockToken, function() {
                        return callback(err);
                    });
                    return;
                }

                loginId.userId = user.id;
                _associateLoginId(loginId, user.id, function(err) {
                    // Immediately release the lock, regardless of whether or not
                    // association worked
                    Locking.release(lockKey, lockToken, function() {
                        if (err) {
                            return callback(err);
                        }

                        log(ctx).info({
                            'loginId': {
                                'tenantAlias': loginId.tenantAlias,
                                'provider': loginId.provider,
                                'externalId': loginId.externalId
                            },
                            'userId': user.id
                        }, 'Created user with a mapped login id');

                        return callback(null, user);
                    });
                });
            });
        });
    });
};

/**
 * Associate the given Login ID info to the specified user. This makes it possible for the associated user to login with the provided
 * login credentials.
 *
 * @param  {Context}   ctx             Standard context object containing the current user and the current tenant
 * @param  {LoginId}   loginId         The login id to associate to the user
 * @param  {String}    userId          The id of the user to which to associate the login id
 * @param  {Function}  callback        Standard callback function
 * @param  {Object}    callback.err    An error that occurred, if any
 */
var associateLoginId = module.exports.associateLoginId = function(ctx, loginId, userId, callback) {
    var validator = new Validator();
    _validateLoginIdForPersistence(validator, loginId);
    validator.check(null, {'code': 401, 'msg': 'You must be authenticated to associate a login id to a user'}).isLoggedInUser(ctx);
    validator.check(userId, {'code': 400, 'msg': 'You must specify a user id'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var isAdmin = ctx.user().isAdmin(loginId.tenantAlias);
    var isTargetUser = (ctx.user().id === userId);
    if (!isAdmin && !isTargetUser) {
        // Only admin and the user themself can associate a login id to the account
        return callback({'code': 401, 'msg': 'You cannot associate a login id to a user other than your own'});
    }

    _getUserIdFromLoginId(loginId, function(err, existingUserIdMapping) {
        if (err && err.code !== 404) {
            return callback(err);
        } else if (existingUserIdMapping && !isAdmin) {
            // Only admin can re-associate a login id to another user
            return callback({'code': 401, 'msg': 'Login ID is already associated to a user'});
        }

        // Verify we don't assign 2 ids of the same provider to a user
        _getUserLoginIds(userId, function(err, loginIds) {
            if (err) {
                return callback(err);
            } else if (loginIds[loginId.provider]) {
                return  callback({'code': 400, 'msg': 'User already has a login id of type ' + loginId.provider});
            }

            // Ensure that the target user exists
            PrincipalsAPI.getUser(ctx, userId, function(err, user) {
                if (err) {
                    return callback(err);
                } else if (user.deleted) {
                    return callback({'code': 404, 'msg': util.format('Couldn\'t find principal: ', userId)});
                }

                _associateLoginId(loginId, userId, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    log(ctx).info({
                        'loginId': {
                            'tenantAlias': loginId.tenantAlias,
                            'provider': loginId.provider,
                            'externalId': loginId.externalId
                        },
                        'userId': userId
                    }, 'Mapped login id to user account');

                    return callback();
                });
            });
        });
    });
};

/**
 * Change a user's local password
 *
 * @param  {Context}    ctx               Standard context object containing the current user and the current tenant
 * @param  {String}     userId            The id of user for which to change the local password
 * @param  {String}     [oldPassword]     The previous password for the user. This is only required when the current user is not an administrator
 * @param  {String}     newPassword       The new password for the user
 * @param  {Function}   callback          Standard callback function
 * @param  {Object}     callback.err      An error that occurred, if any
 */
var changePassword = module.exports.changePassword = function(ctx, userId, oldPassword, newPassword, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to change a password'}).isLoggedInUser(ctx);
    validator.check(userId, {'code': 400, 'msg': 'A user id must be provided'}).isUserId();
    validator.check(newPassword, {'code': 400, 'msg': 'A new password must be provided'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure the user changing their password exists
    PrincipalsAPI.getUser(ctx, userId, function(err, user) {
        if (err) {
            return callback(err);
        } else if (user.deleted) {
            return callback({'code': 404, 'msg': util.format('Couldn\'t find principal: ', userId)});
        }

        // Get the local login id for the user
        _getUserLoginIds(userId, function(err, loginIds) {
            if (err) {
                return callback(err);
            }

            // Can only change password on the local account type
            var localLoginId = loginIds[AuthenticationConstants.providers.LOCAL];
            if (!localLoginId) {
                return callback({'code': 400, 'msg': 'User does not have a local account mapping'});
            }

            // Determine the current user access
            var isAdmin = ctx.user().isAdmin(localLoginId.tenantAlias);
            var isTargetUser = ctx.user().id === userId;
            if (!isAdmin && !isTargetUser) {
                log().info('Failed attempt to change password for user %s by user %s', userId, ctx.user().id);
                return callback({'code': 401, 'msg': 'You\'re not authorized to change this user\'s password'});
            } else if (isAdmin) {
                // If the user is admin we don't care about the old password
                log().info('User %s is changing the password for user %s', ctx.user().id, userId);
                return _changePassword(localLoginId, newPassword, callback);
            }

            // If it's the current user, we need to verify the old password
            checkPassword(localLoginId.tenantAlias, localLoginId.externalId, oldPassword, function(err, user) {
                if (err) {
                    // Old password was probably incorrect
                    log().error({'err': err}, 'User %s failed to change password for %s', ctx.user().id, userId);
                    return callback(err);
                }

                log().info('User %s is changing the password for user %s', ctx.user().id, userId);
                return _changePassword(localLoginId, newPassword, callback);
            });
        });
    });
};

/**
 * Checks the password for a specified tenant/username combination
 *
 * @param  {String}    tenantAlias      The alias of the tenant to which the user belongs
 * @param  {String}    username         The local username of the user
 * @param  {String}    password         The password that should be checked
 * @param  {Function}  callback         Standard callback function
 * @param  {Object}    callback.err     An error that occurred, if any
 * @param  {String}    callback.userId  The ID of the user if the passwords match
 */
var checkPassword = module.exports.checkPassword = function(tenantAlias, username, password, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(tenantAlias, {'code': 401, 'msg': 'A tenant must be provided'}).notEmpty();
    validator.check(username, {'code': 400, 'msg': 'A username must be provided'}).notEmpty();
    validator.check(password, {'code': 400, 'msg': 'A password must be provided'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // we can only check password on local authentication
    var loginId = new LoginId(tenantAlias, AuthenticationConstants.providers.LOCAL, username);

    _validateLoginIdForLookup(validator, loginId);
    if (validator.hasErrors()) {
        return new callback(validator.getFirstError());
    }

    Cassandra.runQuery('SELECT "userId", "password" FROM "AuthenticationLoginId" WHERE "loginId" = ?', [_flattenLoginId(loginId)], function(err, rows) {
        if (err) {
            return callback(err);
        } else if (_.isEmpty(rows)) {
            // No user found with that login id
            return callback({'code': 401, 'msg': 'No password found for this principal'});
        }

        // Check if the user provided password matches the stored password
        var result = Cassandra.rowToHash(rows[0]);
        var passwordMatches = result.userId && result.password && AuthenticationUtil.hashAndComparePassword(password, result.password);
        if (passwordMatches) {
            callback(null, result.userId);
        } else {
            log().info('Invalid password check for user %s', username);
            callback({'code': 401, 'msg': 'User name and/or password do not match'});
        }
    });
};

/**
 * Gets the userId that is associated to the provided login ID, if any.
 *
 * @param  {String}    tenantAlias     The tenant of the login id
 * @param  {String}    provider        The provider of the login id (e.g., twitter, local, google...)
 * @param  {String}    externalId      The id of the user in the external authentication service
 * @param  {Function}  callback        Standard callback function
 * @param  {Object}    callback.err    An error that occurred, if any
 * @param  {String}    callback.userId The id of the user that was associated to the login id, if any
 */
var getUserIdFromLoginId = module.exports.getUserIdFromLoginId = function(tenantAlias, provider, externalId, callback) {
    var loginId = new LoginId(tenantAlias, provider, externalId);

    var validator = new Validator();
    _validateLoginIdForLookup(validator, loginId);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getUserIdFromLoginId(loginId, callback);
};


/**
 * Get the secret for an existing user's resetpassword request
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     userName        The user's own unique username
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 * @param  {Object}     callback.secret The secret token that will be returned
 */
var getResetPasswordSecret = module.exports.getResetPasswordSecret = function(ctx, username, callback) {

    // Default to the current tenant's alias
    var tenantAlias = ctx.tenant().alias;

    // Create the loginid object first, so it can be passed into the validation
    var loginId = new LoginId(tenantAlias, AuthenticationConstants.providers.LOCAL, username);

    // Check if we can get an existing userID using the userName the user provided
    _getUserIdFromLoginId(loginId, function(err, userId) {
        if (err) {
            return callback({'code': 404, 'msg': 'No user could be found with the provided username'});
        }

        // Get user's object as we will try to send the user an email with token
        PrincipalsDAO.getPrincipal(userId, function(err, user) {
            if (err) {
                return callback(err);
            } else if (!user.email) {
                log().warn({'userId': userId}, 'Used asked for password reset but has no email address');
                return callback({'code': 400, 'msg': 'This user has no email address, you will have to ask an admin to reset the password'});
            }

            // Generate a secret token
            var secret = crypto.randomBytes(16).toString('hex');

            // The secret is stored for 24 hours
            Cassandra.runQuery('UPDATE "AuthenticationLoginId" USING TTL 86400 SET "secret" = ? WHERE "loginId" = ?', [secret, _flattenLoginId(loginId)], function(err) {
                if (err) {
                    log().error({'err': err}, 'Error in creating a secret token');
                    return callback(err);
                }

                // Generate the email content with secret token
                var emailData = {
                    'tenant': ctx.tenant(),
                    'user': user,
                    'username': username,
                    'baseUrl': TenantsUtil.getBaseUrl(ctx.tenant()),
                    'skinVariables': require('oae-ui').getTenantSkinVariables(ctx.tenant().alias),
                    'secret': secret,
                };

                // Send the email to the user
                EmailAPI.sendEmail('oae-authentication', 'reset', user, emailData, null, callback);
            });
        });
    });

};

/**
 * Reset the password for an user with an existing username and a valid token
 *
 * @param  {Context}    ctx            Standard context object containing the current user and the current tenant
 * @param  {String}     userName       The user's own unique username
 * @param  {String}     token          The token that user generated within 24 hours
 * @param  {String}     newPassword    The new password for the user
 * @param  {Function}   callback       Standard callback function
 * @param  {Object}     callback.err   An error that occurred, if any
 */
var resetPassword = module.exports.resetPassword = function(ctx, username, secret, newPassword, callback) {

    // Parameter validation
    var validator = new Validator();
    validator.check(username, {'code': 400, 'msg': 'A username must be provided'}).notEmpty();
    validator.check(secret, {'code': 400, 'msg': 'A secret must be provided'}).notEmpty();
    validator.check(newPassword, {'code': 400, 'msg': 'A new password must be provided'}).notEmpty();
    validator.check(newPassword, {'code': 400, 'msg': 'Must specify a password at least 6 characters long'}).len(6);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Default to the current tenant's alias
    var tenantAlias = ctx.tenant().alias;

    // Associate the userID with loginID for later operations
    var loginId = new LoginId(tenantAlias, AuthenticationConstants.providers.LOCAL, username);

    // Lookup the database to check whether a token is associated with the current
    Cassandra.runQuery('SELECT "userId", "secret" FROM "AuthenticationLoginId" WHERE "loginId" = ?', [_flattenLoginId(loginId)], function(err, rows) {

        if (err) {
            return callback(err);
        } else if (_.isEmpty(rows)) {
            // No user found with that login id
            return callback({'code': 401, 'msg': 'No user found for this login ID'});
        }

        // Get the secret column out of the row
        var dbSecret = rows[0].get('secret');

        // If the secret column was not found or its value didn't match, something is wrong.
        if (!dbSecret || dbSecret.value !== secret) {
            log().warn({'loginId': loginId}, 'Someone tried to use an expired password reset secret');
            return callback({'code': 401, 'msg': 'The secret was not found or incorrect'});

	    // If the secret column was found.
        } else {
	        return _changePassword(loginId, newPassword, callback);
        }
    });
};

/**
 * Hash `newPassword` and store it as the new password for the given `loginId`.
 *
 * @param  {LoginId}   loginId         The login id whose password to change
 * @param  {String}    newPassword     The password to which to change the local login id
 * @param  {Function}  callback        Standard callback function
 * @param  {Object}    callback.err    An error that occurred, if any
 * @api private
 */
var _changePassword = function(loginId, newPassword, callback) {
    var hash = AuthenticationUtil.hashPassword(newPassword);
    Cassandra.runQuery('UPDATE "AuthenticationLoginId" SET "password" = ? WHERE "loginId" = ?', [hash, _flattenLoginId(loginId)], function(err) {
        if (err) {
            log().error({'err': err}, 'Error changing a user password');
            return callback(err);
        }

        return callback();
    });
};

/**
 * Associate the given Login ID info to the specified user. This makes it possible for the associated user to login with the provided
 * login credentials.
 *
 * @param  {LoginId}   loginId         The login id to associate
 * @param  {String}    userId          The id of the user to which to associate the login id
 * @param  {Function}  callback        Standard callback function
 * @param  {Object}    callback.err    An error that occurred, if any
 * @api private
 */
var _associateLoginId = function(loginId, userId, callback) {
    loginId.properties = loginId.properties || {};
    var flattenedLoginId = _flattenLoginId(loginId);

    // sanitize and prepare the columns for the upsert
    delete loginId.properties.loginId;
    loginId.properties.userId = userId;

    var query = Cassandra.constructUpsertCQL('AuthenticationLoginId', 'loginId', flattenedLoginId, loginId.properties);
    if (query) {
        var queries = [];
        queries.push(query);
        queries.push({
            'query': 'INSERT INTO "AuthenticationUserLoginId" ("userId", "loginId", "value") VALUES (?, ?, ?)',
            'parameters': [userId, flattenedLoginId, '1']
        });
        return Cassandra.runBatchQuery(queries, callback);
    } else {
        log().error({
            loginId: loginId,
            userId: userId
        }, 'Error constructing query to associate login id to user');
        return callback({'code': 500, 'msg': 'Error associating login id to user ' + userId});
    }
};

/**
 * Get the login ids that are mapped to a user.
 *
 * @param  {Context}     ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}      userId              The id of the user
 * @param  {Function}    callback            Standard callback function
 * @param  {Object}      callback.err        An error that occurred, if any
 * @param  {Object}      callback.loginIds   A hash whose keys are the authentication providers, and values are the LoginId objects that are mapped to the user
 */
var getUserLoginIds = module.exports.getUserLoginIds = function(ctx, userId, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to request the login ids for a user'}).isLoggedInUser(ctx);
    validator.check(userId, {'code': 400, 'msg': 'A user id must be provided'}).isUserId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Request the user details
    PrincipalsAPI.getUser(ctx, userId, function(err, user) {
        if (err) {
            return callback(err);
        } else if (!ctx.user().isAdmin(user.tenant.alias)) {
            // Only global administrators and administrators of the tenant the user belongs to can request the login ids
            return callback({'code': 401, 'msg': 'You are not authorized to request the login ids for this user'});
        }

        _getUserLoginIds(userId, function(err, _loginIds) {
            if (err) {
                return callback(err);
            }

            // Only return the strategies and their corresponding external id
            var loginIds = {};
            _.each(_loginIds, function(values, strategy) {
                loginIds[strategy] = values.externalId;
            });

            return callback(null, loginIds);
        });
    });
};

/**
 * Get the login ids that are mapped to a user.
 *
 * @param  {String}      userId              The id of the user
 * @param  {Function}    callback            Standard callback function
 * @param  {Object}      callback.err        An error that occurred, if any
 * @param  {Object}      callback.loginIds   A hash whose keys are the authentication providers, and values are the LoginId objects that are mapped to the user
 * @api private
 */
var _getUserLoginIds = function(userId, callback) {
    if (!userId) {
        return callback(null, {});
    }

    Cassandra.runQuery('SELECT "loginId" FROM "AuthenticationUserLoginId" WHERE "userId" = ?', [userId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var loginIds = {};
        _.each(rows, function(row) {
            row = Cassandra.rowToHash(row);
            if (row.loginId) {
                var loginId = _expandLoginId(row.loginId);
                loginIds[loginId.provider] = loginId;
            }
        });

        return callback(null, loginIds);
    });
};

/**
 * Gets the userId that is associated to the provided login ID, if any.
 *
 * @param  {LoginId}   loginId         The login id to search
 * @param  {Function}  callback        Standard callback function
 * @param  {Object}    callback.err    An error that occurred, if any
 * @param  {String}    callback.userId The id of the user that was associated to the login id, if any
 * @api private
 */
var _getUserIdFromLoginId = function(loginId, callback) {
    Cassandra.runQuery('SELECT "userId" FROM "AuthenticationLoginId" WHERE "loginId" = ?', [_flattenLoginId(loginId)], function(err, rows) {
        if (err) {
            return callback(err);
        } else if (_.isEmpty(rows)) {
            return callback({'code': 404, 'msg': 'No user could be found with the provided login id'});
        }

        var result = Cassandra.rowToHash(rows[0]);
        return callback(null, result.userId);
    });
};

/**
 * Flatten a LoginId object into a string representation that can be used for a storage key. This is in the following format:
 *
 * `<tenantAlias>:<authentication provider>:<external id>`
 *
 * @param  {LoginId}   loginId     The login id to flatten
 * @return {String}                The flattened string key representation of the login id
 * @api private
 */
var _flattenLoginId = function(loginId) {
    if (!loginId || !loginId.tenantAlias || !loginId.provider || !loginId.externalId) {
        return null;
    }
    return loginId.tenantAlias + ':' + loginId.provider + ':' + loginId.externalId;
};

/**
 * Expand a flattened key representation of a login id into a LoginId object. This is the opposite of #_flattenLoginId.
 *
 * @param  {String}    loginIdStr  The flat string key representation of the login id
 * @return {LoginId}               The LoginId object that is represented by the flat string
 * @api private
 */
var _expandLoginId = function(loginIdStr) {
    if (!loginIdStr) {
        return null;
    }

    var loginIdSplit = loginIdStr.split(':');
    if (loginIdSplit.length < 3) {
        return null;
    }

    // the externalId can contain *anything*, including colons. keep that in-tact with a slice-and-join.
    return new LoginId(loginIdSplit[0], loginIdSplit[1], loginIdSplit.slice(2).join(':'));
};

/**
 * Verify that the given login ID is suitable to be used to look up a user id mapping.
 *
 * @param  {Validator}       validator   The validator to use to validate the loginId
 * @param  {LoginId}         loginId     The login id to validate
 * @api private
 */
var _validateLoginIdForLookup = function(validator, loginId) {
    var numErrors = validator.getErrorCount();
    validator.check(null, {'code': 400, 'msg': 'Must specify a login id'}).isObject(loginId);
    if (validator.getErrorCount() === numErrors) {
        // only validate these if loginId is a valid object
        validator.check(loginId.tenantAlias, {'code': 400, 'msg': 'Must specify a tenant id on the login id'}).notEmpty();
        validator.check(loginId.provider, {'code': 400, 'msg': 'Must specify an authentication provider on the login id'}).notEmpty();
        validator.check(loginId.externalId, {'code': 400, 'msg': 'Must specify an external id on the login id'}).notEmpty();
    }
};

/**
 * Verify that the given login ID is suitable to be persisted to storage.
 *
 * @param  {Validator}       validator   The validator to use to validate the loginId
 * @param  {LoginId}         loginId     The login id to validate
 * @api private
 */
var _validateLoginIdForPersistence = function(validator, loginId) {
    var numErrors = validator.getErrorCount();
    _validateLoginIdForLookup(validator, loginId);

    // only continue validating if the login id is valid so far
    if (validator.getErrorCount() === numErrors) {
        loginId.properties = loginId.properties || {};

        // custom handling for local authentication (i.e., username and password)
        if (loginId.provider === AuthenticationConstants.providers.LOCAL) {
            validator.check(loginId.properties.password, {'code': 400, 'msg': 'Must specify a password at least 6 characters long'}).len(6);
        }
    }
};



///////////////////////////////
///////////////////////////////
// AUTHENTICATION STRATEGIES //
///////////////////////////////
///////////////////////////////

/**
 * Register an authentication strategy. A strategy needs to be registered during the start-up phase and will then
 * be made active when the server has fully started up.
 *
 * @param  {String}     strategyName    The name under which this strategy should be registered. This string will be used in the Passport registry mechanism
 * @param  {Strategy}   strategy        The OAE strategy that needs to be registered
 * @throws {Error}                      An error is thrown if another strategy was already registered with the provided strategy name
 */
var registerStrategy = module.exports.registerStrategy = function(strategyName, strategy) {
    if (strategies[strategyName]) {
        throw new Error('Attempted to register duplicate authentication strategy');
    }

    strategies[strategyName] = strategy;
    log().info('Registered authentication strategy "%s"', strategyName);
};

/**
 * Refresh the known passport login strategies for a given tenant. This will be called for all registered tenants upon start-up
 * and when new tenants are being started on the fly.
 *
 * @param  {Tenant} tenant  The tenant for which we want to refresh the authentication capabilities
 */
var refreshStrategies = module.exports.refreshStrategies = function(tenant) {
    _.each(strategies, function(strategy, strategyName) {
        // Get the name we used to register this strategy with passport. This is a combination of the tenant and strategy name
        var passportStrategyName = AuthenticationUtil.getStrategyId(tenant, strategyName);

        // Disable the passport strategy if we registered it previously.
        if (passport._strategy(passportStrategyName)) {
            passport.unuse(passportStrategyName);
        }

        // If the tenant wants the strategy enabled, we enable it. We also create a new instance of the passport strategy so that
        // configuration updates to the strategy are taken into account
        if (strategy.shouldBeEnabled(tenant.alias)) {
            passport.use(passportStrategyName, strategy.getPassportStrategy(tenant));
            log().debug({'tenant': tenant.alias, 'strategy': strategyName, 'passportStrategyName': passportStrategyName}, 'Enabling strategy');
        }
    });

    AuthenticationAPI.emit(AuthenticationConstants.events.REFRESHED_STRATEGIES, tenant);

    log().debug({'tenant': tenant}, 'Refreshed authentication strategies for tenant');
};

/**
 * Refreshes all the authentication strategies on all the tenants.
 *
 * @api private
 */
var _refreshAllTenantStrategies = function() {
    var tenants = TenantsAPI.getTenants();

    // Refresh all the tenant auth strategies
    _.each(_.values(tenants), refreshStrategies);
};


////////////////////////
////////////////////////
// SESSION MANAGEMENT //
////////////////////////
////////////////////////

/**
 * Log a user out from a session. This method will take care of committing the response object.
 *
 * @param  {Request}    req     The ExpressJS request object
 * @param  {Response}   res     The ExpressJS response object
 */
var logout = module.exports.logout = function(req, res) {
    if (!req.ctx.user()) {
        return res.send(400, 'You need to be logged in, in order to log out');
    }

    // We need to grab the authentication info before we call `logOut()`
    // as the property would otherwise be removed
    var authInfo = req.oaeAuthInfo;

    // In all cases, we destroy the session within OAE
    req.logout();

    // Emit an event that the user logged out
    AuthenticationAPI.emit(AuthenticationConstants.events.USER_LOGGED_OUT, req.ctx);

    // If the full unique strategy was not made available on the request, there is nothing we can do any further
    if (!authInfo || !authInfo.strategyId) {
        return res.redirect('/');
    }

    // If no strategy name was set on the request we're done
    var passportStrategyName = AuthenticationUtil.parseStrategyId(authInfo.strategyId).strategyName;
    if (!passportStrategyName) {
        return res.redirect('/');
    }

    // If the strategy didn't implement a logout function we're done
    var strategy = strategies[passportStrategyName];
    if (!strategy || !strategy.logout) {
        return res.redirect('/');
    }

    // If the strategy implemented a logout function, they can take care of the further request cycle
    return strategy.logout(req, res);
};
