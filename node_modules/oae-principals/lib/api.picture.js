/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var fs = require('fs');

var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var ContentAPI = require('oae-content');
var ImageUtil = require('oae-util/lib/image');
var log = require('oae-logger').logger('oae-principals-shared');
var Validator = require('oae-util/lib/validator').Validator;

var GroupAPI = require('./api.group');
var PrincipalsConstants = require('./constants').PrincipalsConstants;
var PrincipalsDAO = require('./internal/dao');
var PrincipalsEmitter = require('./internal/emitter');
var PrincipalsUtil = require('./util');


/**
 * Store a picture for a principal that can be re-used later on.
 *
 * @param {Context}     ctx             Context that holds the current user and tenant.
 * @param {String}      principalId     The ID of the principal you wish to store a picture for.
 * @param {File}        file            The picture
 * @param {String}      file.name       The name of the file you wish to store.
 * @param {String}      file.type       The mimetype of the file. Only the following mimetypes can be stored: 'image/jpg', 'image/jpeg', 'image/png', 'image/gif' or 'image/bmp'
 * @param {String}      file.path       The path on disk where the file is stored.
 * @param {Number}      file.size       The filesize. A maximum of 5MB is imposed.
 * @param {Function}    callback        Standard callback method.
 * @param {Object}      callback.err    Standard error object (if any.)
 */
var storePicture = module.exports.storePicture = function(ctx, principalId, file, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Unable to store picture %s for %s', file.path, principalId);
        }
    };
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a picture'}).isLoggedInUser(ctx);
    validator.check(principalId, {'code': 400, 'msg': 'A principal ID must be provided'}).isPrincipalId();
    validator.check(file, {'code': 400, 'msg': 'A file must be provided'}).notNull();
    if (file) {
        validator.check(file.type, {'code': 400, 'msg': 'Missing mimetype on the file object.'}).notEmpty();
        validator.check(file.type, {'code': 400, 'msg': 'Only images are accepted files.'}).isIn(['image/jpg', 'image/jpeg', 'image/png', 'image/gif', 'image/bmp']);
        validator.check(file.size, {'code': 400, 'msg': 'Missing size on the file object.'}).notEmpty();
        validator.check(file.size, {'code': 400, 'msg': 'The size of a picture has an upper limit of 5MB.'}).max(5242880);
        validator.check(file.name, {'code': 400, 'msg': 'Missing name on the file object.'}).notEmpty();
    }
    if (validator.hasErrors()) {
        return cleanupOnError(validator.getFirstError(), file, callback);
    }

    // Check if we can edit this principal.
    _canManagePrincipal(ctx, principalId, function(err, principal) {
        if (err) {
            return cleanupOnError(err, file, callback);
        }

        // We can edit the principal.
        // First remove the previous pictures, including the large picture.
        _removePictures(ctx, principal, true, function(err) {
            if (err) {
                return cleanupOnError(err, file, callback);       
            }

            // Now store and attach the new one.
            _storePicture(ctx, principal, file, function(err, principal) {
                if (err) {
                    return cleanupOnError(err, file, callback);
                }
                callback(null, principal);
            });
        });
        
    });
};

/**
 * Removes pictures that are attached to a principal, both in Cassandra as on the storage backend.
 * It will always remove the small and medium picture,  if the `removeLarge` flag is set to true it
 * will also remove the large picture. The method will check if there are any pictures associated
 * to the principal and won't execute a query if the principal has none.
 *
 * @param {Context}     ctx             Context that holds the current user and tenant.
 * @param {Group|User}  principal       The principal for which the pictures should be removed.
 * @param {Boolean}     removeLarge     Whether or not the remove the large picture.
 * @param {Function}    callback        Standard execution method.
 * @param {Object}      callback.err    Error object (if any.)
 */
var _removePictures = function(ctx, principal, removeLarge, callback) {
    var toRemove = [ principal.smallPictureUri, principal.mediumPictureUri ];
    if (removeLarge) {
        toRemove.push(principal.largePictureUri);
    }

    // Remove all the undefined, null, .. vars.
    toRemove = _.compact(toRemove);

    if (toRemove.length === 0) {
        // No URIs specified, early return.
        return callback(null);
    }

    var removed = 0;
    var called = false;
    toRemove.forEach(function(uri) {
        // remove the picture.
        ContentAPI.getStorageBackend(ctx).remove(ctx, uri, function(err) {
            removed++;
            if (err && !called) {
                // Make sure we only call the callback function once.
                called = true;
                return callback(err);
            }

            // When all the files are removed,
            // update the principal object in Cassandra.
            if (removed === toRemove.length && !called) {
                called = true;
                var columns = 'smallPictureUri, mediumPictureUri';
                if (removeLarge) {
                    columns += ', largePictureUri';
                }
                var cql = 'DELETE ' + columns + ' FROM Principals WHERE principalId = ?';
                Cassandra.runQuery(cql, [ principal.id ], callback);
            }
        });
    });
};

/**
 * Stores a large picture for a principal and attaches it too the User or Group object in Cassandra.
 *
 * @param {Context}     ctx             Context that holds the current user and tenant.
 * @param {Group|User}  principal           The principal for which we should store a file.
 * @param {File}        file                The file to store.
 * @param {Function}    callback            Standard callback method.
 * @param {Object}      callback.err        Standard error object (if any)
 * @param {Group|User}  callback.principal  The updated principal object.
 */
var _storePicture = function(ctx, principal, file, callback) {
    ContentAPI.getStorageBackend(ctx).store(ctx, file, function(err, largePictureUri) {
        if (err) {
            return cleanupOnError(err, file, callback);
            // By this point the temp file has been removed, no need to clean up in error cases below.
        }

        // Save in Cassandra.
        var values = {
            'largePictureUri': largePictureUri
        };
        var q = Cassandra.constructUpsertCQL('Principals', 'principalId', principal.id, values, 'QUORUM');
        if (!q) {
            return callback({'code': 500, 'msg': 'Unable to store large picture uri'});
        }
        Cassandra.runQuery(q.query, q.parameters, function(err) {
            if (err) {
                return callback(err);
            }

            PrincipalsDAO.setPictureOnPrincipalObject(principal, 'large', largePictureUri);

            if (PrincipalsUtil.isUser(principal.id)) {
                PrincipalsDAO.invalidateCachedUser(principal.id, function(err) {
                    if (err) {
                        log().warn({'err': err}, 'Could not invalidate the user when storing a large picture.');
                    }

                    callback(null, principal);
                });
            } else {
                // Groups don't need cache invalidation.
                callback(null, principal);
            }
        });
    });
};

/**
 * Crops a square out of the large picture attached to a principal and generates
 * a small and medium sized version of that square.
 *
 * @param {Context}     ctx                 Context that holds the current user and tenant.
 * @param {String}      principalId         The ID of the principal to crop the large picture for.
 * @param {Number}      x                   The x coordinate of the topleft corner to start cropping
 * @param {Number}      y                   The y coordinate of the topleft corner to start cropping
 * @param {Number}      width               The width of the square that needs to be cropped out.
 * @param {Function}    callback            Standard callback method.
 * @param {Object}      callback.err        An error object (if any.)
 * @param {Group|User}  callback.principal  The updated principal object.
 */
var generateSizes = module.exports.generateSizes = function(ctx, principalId, x, y, width, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Unable to crop picture %s for %s', fileUri, principalId);
        }
    };

    // Parameter validation
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a picture'}).isLoggedInUser(ctx);
    validator.check(principalId, {'code': 400, 'msg': 'A principal id must be provided'}).isPrincipalId();
    validator.check(x, {'code': 400, 'msg': 'The x value must be a positive integer'}).isInt();
    validator.check(x, {'code': 400, 'msg': 'The x value must be a positive integer'}).min(0);
    validator.check(y, {'code': 400, 'msg': 'The y value must be a positive integer'}).isInt();
    validator.check(y, {'code': 400, 'msg': 'The y value must be a positive integer'}).min(0);
    validator.check(width, {'code': 400, 'msg': 'The width value must be a positive integer'}).isInt();
    validator.check(width, {'code': 400, 'msg': 'The width value must be a positive integer'}).min(10);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Make sure we can edit this principal.
    _canManagePrincipal(ctx, principalId, function(err, principal) {
        if (err) {
            return callback(err);
        } else if (!principal.largePictureUri) {
            return callback({'code': 400, 'msg': 'This principal has no large picture associated with it.'});
        }

        // Remove the old small and medium sized picture.
        _removePictures(ctx, principal, false, function(err) {
            if (err) {
                return callback(err);
            }
            _generateSizes(ctx, principal, x, y, width, callback);
        });
    });
};

/**
 * Internal method that retrieves the large picture attached to this principal, crops out the desired square
 * and scales that square to a small and medium sized verison.
 *
 * @param {Context}     ctx                 Context that holds the current user and tenant.
 * @param {Group|User}  principal           The principal to crop the large picture for.
 * @param {Number}      x                   The x coordinate of the topleft corner to start cropping
 * @param {Number}      y                   The y coordinate of the topleft corner to start cropping
 * @param {Number}      width               The width of the square that needs to be cropped out.
 * @param {Function}    callback            Standard callback method.
 * @param {Object}      callback.err        An error object (if any.)
 * @param {Group|User}  callback.principal  The updated principal object.
 * @api private
 */
var _generateSizes = function(ctx, principal, x, y, width, callback) {
    // Retrieve the raw image.
    ContentAPI.getStorageBackend(ctx, principal.largePictureUri).get(ctx, principal.largePictureUri, function(err, file) {
        if (err) {
            return callback(err);
        }

        // Get the resized images.
        var selectedArea = {
            'x': parseInt(x, 10),
            'y': parseInt(y, 10),
            'width': parseInt(width, 10)
        };
        var sizes = [PrincipalsConstants.picture.size.SMALL, PrincipalsConstants.picture.size.MEDIUM];
        ImageUtil.cropAndResize(file.path, selectedArea, sizes, function(err, files) {
            // Remove the temp file first.
            file.remove(function(removalError) {
                if (err) {
                    return callback(err);
                } else if (removalError) {
                    return callback(removalError);
                }

                // File removed, store and save the cropped and resized images.
                _storeAndSave(ctx, principal, files, callback);
            });
        });
    });
};

/**
 * Store the resized files and save their URIs on the principal object.
 *
 * @param {Context}     ctx                 Context that holds the current user and tenant.
 * @param {Context}     ctx                 Context that holds the current user and tenant.
 * @param {Group|User}  principal           The principal to crop the large picture for.
 * @param {Object}      files               An object with file objects.
 * @param {Function}    callback            Standard callback method.
 * @param {Object}      callback.err        An error object (if any.)
 * @param {Group|User}  callback.principal  The updated principal object.
 */
var _storeAndSave = function(ctx, principal, files, callback) {
    // Store the resized files.
    var backend = ContentAPI.getStorageBackend(ctx);
    backend.store(ctx, files[PrincipalsConstants.picture.size.SMALL], function(err, smallPictureUri) {
        if (err) {
            return callback(err);
        }

        backend.store(ctx, files[PrincipalsConstants.picture.size.MEDIUM], function(err, mediumPictureUri) {
            if (err) {
                return callback(err);
            }

            // Files stored, save them to the DB.
            _saveUrisToCassandra(ctx, principal, smallPictureUri, mediumPictureUri, callback);
        });
    });
};

/**
 * Saves the small and medium uris to cassandra and sticks them on the Principal Object.
 * If the principal is a user, the cache gets invalidated.
 *
 * @param {Context}     ctx                 Context that holds the current user and tenant.
 * @param {Group|User}  principal           The principal object to update.
 * @param {String}      smallPictureUri     The URI for the small image.
 * @param {String}      mediumPictureUri    The URI for the large image.
 * @param {Object}      callback.err        An error object (if any.)
 * @param {Group|User}  callback.principal  The updated principal object.
 * @api private
 */
var _saveUrisToCassandra = function(ctx, principal, smallPictureUri, mediumPictureUri, callback) {
    var values = {
        'smallPictureUri': smallPictureUri,
        'mediumPictureUri': mediumPictureUri
    };
    var q = Cassandra.constructUpsertCQL('Principals', 'principalId', principal.id, values, 'QUORUM');
    if (!q) {
        return callback({'code': 500, 'msg': 'Unable to store cropped picture URIs'});
    }
    Cassandra.runQuery(q.query, q.parameters, function(err) {
        if (err) {
            return callback(err);
        }

        PrincipalsDAO.setPictureOnPrincipalObject(principal, 'small', smallPictureUri);
        PrincipalsDAO.setPictureOnPrincipalObject(principal, 'medium', mediumPictureUri);

        if (PrincipalsUtil.isUser(principal.id)) {
            PrincipalsDAO.invalidateCachedUser(principal.id, function(err) {
                if (err) {
                    log().error({'err': err}, 'Could not invalidate the user after cropping the large picture, the cache now contains stale data.');
                    return callback(err);
                }
                PrincipalsEmitter.emit(PrincipalsConstants.events.UPDATED_USER, ctx, principal.id);
                callback(null, principal);
            });
        }
        else {
            PrincipalsEmitter.emit(PrincipalsConstants.events.UPDATED_GROUP, ctx, principal.id);
            callback(null, principal);
        }
    });
};

/**
 * Checks if the current user can edit the principal.
 * If he or she cannot edit the principal, a 401 error object will be passed back.
 *
 * @param {Context}     ctx                 Context that holds the current user and tenant.
 * @param {String}      principalId         The ID of the principal to check.
 * @param {Function}    callback            Standard callback method.
 * @param {Object}      callback.err        Standard error object.
 * @param {Group|User}  callback.principal  The group or user object if the user can manage it.
 * @api private
 */
var _canManagePrincipal = function(ctx, principalId, callback) {
    // Only the current user or an admin can update a user.
    var principalResource = AuthzUtil.getResourceFromId(principalId);
    if ((PrincipalsUtil.isUser(principalId) && ctx.user().id === principalId) || ctx.user().isAdmin(principalResource.tenantAlias)) {
        // Get the user's information.
        PrincipalsUtil.getPrincipal(ctx, principalId, callback);

    // We'll need to check a group explicitly.
    } else if (PrincipalsUtil.isGroup(principalId)) {
        GroupAPI.canManage(ctx, principalId, function(err, canManage, group) {
            if (err) {
                return callback(err);
            } else if (!canManage) {
                return callback({'code': 401, 'msg': 'You cannot update the picture of this group.'});
            }
            callback(null, group);
        });
    } else {
        callback({'code': 401, 'msg': 'You cannot update the picture of this principal.'});
    }
};

/**
 * Removes temp file and logs an error statement.
 *
 * @param {Object}      error           The error
 * @param {TempFile}    file            The file that needs to be removed.
 * @param {Function}    callback        Standard callback method.
 * @param {Object}      callback.err    The passed in `error` object.
 */
var cleanupOnError = function(error, file, callback) {
    // If it's a TempFile who has a remove method.
    if (file && file.remove) {
        file.remove(function(err) {
            if (err) {
                log().warn({'err': err}, 'Unable to remove an uploaded image.');
            }
            callback(error);
        });
    // If it's an express file.
    } else if (file && file.path) {
        fs.unlink(file.path, function(err) {
            if (err) {
                log().warn({'err': err}, 'Unable to remove an uploaded image.');
            }
            callback(error);
        });
    } else {
        callback(error);
    }
};
