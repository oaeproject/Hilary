/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var express = require('express');

var OAE = require('oae-util/lib/oae');
var IO = require('oae-util/lib/io');
var Cassandra = require('oae-util/lib/cassandra');

var model = require('./model');

/**
 * Start a new tenant
 * @param {Tenant}          tenant          The tenant object representing the tenant to be started
 * @param {Function(err)}   callback        Standard callback function execute when the tenant is fully started up
 * @param {Object}          callback.err    Error object containing error message
 */
var startTenant = module.exports.startTenant = function(tenant, callback) {
    callback = callback || function() {};
    if (tenant && tenant.port) {
        tenant.server = express();
        tenant.server.listen(tenant.port);
        tenant.server.use(function(req, res, next){
            req.tenant = tenant;
            req.user = null;
            next();
        });
        tenant.passport = require('passport');
        registerAPI(tenant, callback);
        console.log('Start tenant "' + tenant.name + '" on port ' + tenant.port);
    } else {
        callback({'code': 500, 'msg': 'The tenant could not be started as it is invalid'});
    }
};

/**
 * Put a tenant in maintenance mode or take it out of it.
 * @param {Tenant}   tenant              The tenant object representing the tenant to be stopped
 * @param {Boolean}  needsMaintenance    True if the tenant needs to go into maintenance mode
 * @param {Function} callback            Callback function executed when request is completed.
 */
var putTenantsInMaintenanceMode = module.exports.putTenantsInMaintenanceMode = function(tenants, needsMaintenance, callback) {
    callback = callback || function() {};
    var queries = []
    for (var i in tenants) {
        queries.push({
            'query': 'UPDATE Tenant SET active = ? WHERE port = ?',
            'parameters': [!needsMaintenance, tenants[i].port]
        });
    }
    Cassandra.runBatchQuery(queries, callback);
};

/**
 * Put a tenant in maintenance mode or take it out of it.
 * @param {Tenant}   tenant              The tenant object representing the tenant to be stopped
 * @param {Function} callback            Callback function executed when request is completed.
 */
var deleteTenants = module.exports.deleteTenants = function(tenants, callback) {
    callback = callback || function() {};
    var queries = []
    for (var i in tenants) {
        queries.push({
            'query': 'UPDATE Tenant SET active = ?, deleted = ? WHERE port = ?',
            'parameters': [false, true, tenants[i].port]
        });
    }
    Cassandra.runBatchQuery(queries, callback);
};

/**
 * Get all the tenants in the datastore.
 * @param {Function(err, tenants)}  callback            Standard callback function
 * @param {Object}                  callback.err        Error object containing the error message
 * @param {Array<Tenant>}           callback.tenants    Array of all the existing tenants
 */ 
var getAllTenants = module.exports.getAllTenants = function(callback) {
    Cassandra.runQuery('SELECT * FROM Tenant', false, function(err, rows) {
        if (!err) {
            var tenants = [];
            if (hasTenant(rows)) {
                rows.forEach(function(row) {
                    var t = mapToTenant(row, false);
                    t ? tenants.push(t) : '';
                });
            }
            callback(null, tenants);
        } else {
            callback(err);
        }
    });
};

/**
 * Get the unique tenant by their mapped port.
 * 
 * @param {Number}   port The port number on which the tenant listens
 * @param {Function} callback A function(err, tenant) specifying the tenant requested
 */
var getTenantByPort = module.exports.getTenantByPort = function(port, callback) {
    Cassandra.runQuery('SELECT * FROM Tenant WHERE port = ?', [ port ], function(err, rows) {
        if (!err) {
            if (hasTenant(rows)) {
                var tenant = mapToTenant(rows[0]);
                callback(null, tenant);
            } else {
                callback({'code': 404, 'msg': 'There is no tenant listening on port ' + port});
            }
        } else {
            callback(err);
        }
    });
};

/**
 * Get the unique tenant by their alias.
 * 
 * @param {String}   alias The alias assigned to the tenant
 * @param {Function} callback A function(err, tenant) specifying the tenant requested
 */
var getTenantByAlias = module.exports.getTenantByAlias = function(alias, callback) {
    getAllTenants(function(err, tenants) {
        if (!err) {
            var tenant = null;
            if (tenants !== null) {
                for (var i = 0; i < tenants.length; i++) {
                    if (tenants[i].alias === alias) {
                        tenant = tenants[i];
                        break;
                    }
                }
            }
            callback(null, tenant);
        } else {
            callback(err);
        }
    });
};

/**
 * Create a tenant using the provided information.
 * 
 * @param {String}   alias The unique alias assigned to the tenant
 * @param {String}   name A descriptive short name for the tenant
 * @param {String}   description A long description of the tenant
 * @param {Number}   port The port on which the tenant should listen
 * @param {String}   baseUrl The baseUrl on which this tenant is proxying (ie: oae.cam.ac.uk or oae.gatech.edu)
 * @param {Function} callback A function(err, tenant) specifying the tenant information that was persisted.
 */
var createTenant = module.exports.createTenant = function(alias, name, description, port, baseUrl, callback) {
    callback = callback || function() {};
    getTenantByPort(port, function(err, tenant) {
        if (!tenant) {
            getTenantByAlias(alias, function(err, tenant) {
                if (!tenant) {
                    baseUrl = baseUrl || "localhost:" + port;
                    description = description || "";
                    tenant = new model.Tenant(alias, name, description, port, baseUrl);
                    // no tenant by this alias or port exist, create one
                    Cassandra.runQuery('UPDATE Tenant SET alias = ?, name = ?, description = ?, baseUrl = ? where port = ?',
                        [tenant.alias, tenant.name, tenant.description || "", baseUrl, tenant.port], function(err) {
                        if (!err) {
                            startTenant(tenant, function() {
                                callback(null, tenant);
                            });
                        } else {
                            callback(err);
                        }
                    });
                } else {
                    callback({'code': 400, 'msg': 'A tenant with the alias ' + alias + ' already exists'});
                }
            });
        } else {
            callback({'code': 400, 'msg': 'A tenant is already running on port ' + port});
        }
    });
};

/**
 * Register all of the REST end points from all modules against a tenant
 * @param {Tenant}      tenant      The tenant object representing the tenant for which the REST
 *                                  endpoints need to be registered
 * @param {Function}    callback    Standard callback function execute when all of the REST endpoints
 *                                  have finished registering
 */
var registerAPI = function(tenant, callback) {
    OAE.getAvailableModules(function(modules) {
        var modulesLoaded = 0;
        for (var m = 0; m < modules.length; m++) {
            (function(m) {
                var path = "node_modules/" + modules[m] + "/lib/rest.js";
                IO.pathExists(path, function(exists) {
                    if (exists) {
                        require(modules[m] + "/lib/rest")(tenant);
                    }
                    modulesLoaded++;
                    if (modulesLoaded === modules.length) {
                        callback();
                    }
                });
            }(m));
        }
    });
};

/**
 * Determines whether or not this set of rows represents a result set with a tenant.
 */
var hasTenant = function(rows) {
    return (rows[0] && rows[0].count > 1);
};

/**
 * Map a cassandra row element to a tenant object.
 */
var mapToTenant = function(row, returnDeleted) {
    var hash = Cassandra.rowToHash(row);
    if (returnDeleted) {
        return new model.Tenant(hash.alias, hash.name, hash.description, hash.port, hash.baseUrl, hash.active, hash.deleted);
    } else if (!hash.deleted) {
        return new model.Tenant(hash.alias, hash.name, hash.description, hash.port, hash.baseUrl, hash.active, hash.deleted);
    }
    return false;
};
