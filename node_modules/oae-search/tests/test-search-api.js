/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');

var AuthzUtil = require('oae-authz/lib/util');
var MQTestsUtil = require('oae-util/lib/test/mq-util');
var RestAPI = require('oae-rest');
var SearchAPI = require('oae-search');
var SearchConstants = require('oae-search/lib/constants').SearchConstants;
var TaskQueue = require('oae-util/lib/taskqueue');
var TestsUtil = require('oae-tests/lib/util');

describe('Search API', function() {
  // REST Contexts we will use to execute requests
  var anonymousRestContext = null;
  var globalAdminRestContext = null;
  var camAdminRestContext = null;

  before(function(callback) {
    anonymousRestContext = TestsUtil.createTenantRestContext(
      global.oaeTests.tenants.cam.host,
    );
    globalAdminRestContext = TestsUtil.createGlobalAdminRestContext();
    camAdminRestContext = TestsUtil.createTenantAdminRestContext(
      global.oaeTests.tenants.cam.host,
    );

    // Unbind the current handler, if any
    TaskQueue.unbind(SearchConstants.mq.TASK_REINDEX_ALL, function(err) {
      assert.ok(!err);

      /*!
             * Task handler that will just drain the queue.
             *
             * @see TaskQueue#bind
             */
      var _handleTaskDrain = function(data, mqCallback) {
        // Simply callback, which acknowledges messages without doing anything.
        mqCallback();
      };

      // Drain the queue
      TaskQueue.bind(
        SearchConstants.mq.TASK_REINDEX_ALL,
        _handleTaskDrain,
        null,
        function(err) {
          assert.ok(!err);
          callback();
        },
      );
    });
  });

  /**
   * Test that verifies an error is thrown when registering a document transformer that already exists.
   */
  it('verify cannot register non-unique search document transformers', function(callback) {
    SearchAPI.registerSearchDocumentTransformer(
      'test-registerSearchDocumentTransformer',
      function() {},
    );

    // Try and register a second transformer of the same type, log the error and verify it happened.
    assert.throws(function() {
      SearchAPI.registerSearchDocumentTransformer(
        'test-registerSearchDocumentTransformer',
        function() {},
      );
    }, Error);

    return callback();
  });

  /**
   * Test that verifies an error is thrown when registering a document producer that already exists.
   */
  it('verify cannot register non-unique search document producers', function(callback) {
    SearchAPI.registerSearchDocumentProducer(
      'test-registerSearchDocumentProducer',
      function() {},
    );

    // Try and register a second producer of the same type
    assert.throws(function() {
      SearchAPI.registerSearchDocumentProducer(
        'test-registerSearchDocumentProducer',
        function() {},
      );
    }, Error);

    return callback();
  });

  /**
   * Test that verifies an error is thrown when registering a search type that already exists.
   */
  it('verify cannot register a non-unique search type', function(callback) {
    SearchAPI.registerSearch('test-registerSearch', function() {});

    // Try and register a second search of the same id, log the error and verify it happened.
    assert.throws(function() {
      SearchAPI.registerSearch('test-registerSearch', function() {});
    }, Error);

    return callback();
  });

  /**
   * Test that verifies an error is thrown when registering a reindex all handler that already exists
   */
  it('verify cannot register non-unique search reindex all handler', function(callback) {
    SearchAPI.registerReindexAllHandler(
      'test-registerReindexAllHandler',
      function() {},
    );

    // Try and register a second handler of the same id, log the error and verify it happened.
    assert.throws(function() {
      SearchAPI.registerReindexAllHandler(
        'test-registerReindexAllHandler',
        function() {},
      );
    }, Error);

    return callback();
  });

  /**
   * Test that verifies an error is thrown when registering a reindex all handler that already exists
   */
  it('verify cannot register non-unique child search document type', function(callback) {
    var options = {
      schema: {
        test_field_name: {
          type: 'string',
          store: 'no',
          index: 'not_analyzed',
        },
      },
      producer: function(resources, callback) {
        return callback(null, []);
      },
    };

    SearchAPI.registerChildSearchDocument(
      'test-registerChildSearchDocument',
      options,
      function(err) {
        assert.ok(!err);

        // Try and register a second handler of the same id, log the error and verify it happened.
        SearchAPI.registerChildSearchDocument(
          'test-registerChildSearchDocument',
          options,
          function(err) {
            assert.ok(err);
            assert.equal(err.code, 400);
            return callback();
          },
        );
      },
    );
  });

  /**
   * Test that verifies an error occurrs when trying to invoke an invalid search type.
   */
  it('verify cannot search invalid type', function(callback) {
    SearchAPI.search({}, 'not-a-search-type', {}, function(err, docs) {
      assert.ok(err);
      assert.equal(err.code, 400);
      callback();
    });
  });

  /**
   * Test that verifies when reindex all is triggered through the REST endpoint, a task is triggered.
   */
  it('verify reindex all triggers an mq task', function(callback) {
    // Unbind the current handler, if any
    TaskQueue.unbind(SearchConstants.mq.TASK_REINDEX_ALL, function(err) {
      assert.ok(!err);

      /*!
             * Simply call the test callback to continue tests. If this is not invoked, the test will timeout
             * and fail.
             *
             * @see TaskQueue#bind
             */
      var _handleTask = function(data, mqCallback) {
        mqCallback();
        callback();
      };

      // Bind the handler to invoke the callback when the test passes
      TaskQueue.bind(
        SearchConstants.mq.TASK_REINDEX_ALL,
        _handleTask,
        null,
        function(err) {
          assert.ok(!err);

          // Reprocess previews
          RestAPI.Search.reindexAll(globalAdminRestContext, function(err) {
            assert.ok(!err);
          });
        },
      );
    });
  });

  /**
   * Test that verifies when previews are reprocessed through the REST endpoint, a task is triggered.
   */
  it('verify non-global admin users cannot trigger reindex all', function(callback) {
    // Unbind the current handler, if any
    TaskQueue.unbind(SearchConstants.mq.TASK_REINDEX_ALL, function(err) {
      assert.ok(!err);

      /*!
             * Task handler that will fail the test if invoked.
             *
             * @see TaskQueue#bind
             */
      var _handleTaskFail = function(data, mqCallback) {
        mqCallback();
        assert.fail('Did not expect the task to be invoked.');
      };

      // Bind a handler to handle the task that invokes an assertion failure, as no task should be triggered from this test
      TaskQueue.bind(
        SearchConstants.mq.TASK_REINDEX_ALL,
        _handleTaskFail,
        null,
        function(err) {
          assert.ok(!err);

          // Generate a normal user with which to try and reprocess previews
          TestsUtil.generateTestUsers(camAdminRestContext, 1, function(
            err,
            users,
          ) {
            assert.ok(!err);

            var userRestCtx = users[_.keys(users)[0]].restContext;

            // Verify that an anonymous user-tenant user cannot reprocess previews
            RestAPI.Search.reindexAll(anonymousRestContext, function(err) {
              assert.ok(err);

              // The user-tenant currently doesn't have this end-point. This assertion simply ensures
              // that no regression comes in here if it is introduced as an endpoint
              assert.equal(err.code, 404);

              // Verify that an anonymous global-tenant user cannot reprocess previews
              RestAPI.Search.reindexAll(
                TestsUtil.createGlobalRestContext(),
                function(err) {
                  assert.ok(err);
                  assert.equal(err.code, 401);

                  // Verify that a regular user cannot generate a task
                  RestAPI.Search.reindexAll(userRestCtx, function(err) {
                    assert.ok(err);

                    // The user-tenant currently doesn't have this end-point. This assertion simply ensures
                    // that no regression comes in here if it is introduced as an endpoint
                    assert.equal(err.code, 404);

                    // Verify that a tenant admin cannot generate a task
                    RestAPI.Search.reindexAll(camAdminRestContext, function(
                      err,
                    ) {
                      assert.ok(err);

                      // The user-tenant currently doesn't have this end-point. This assertion simply ensures
                      // that no regression comes in here if it is introduced as an endpoint
                      assert.equal(err.code, 404);

                      return callback();
                    });
                  });
                },
              );
            });
          });
        },
      );
    });
  });

  /**
   * Test that verifies resourceTypes array filters resource types
   */
  it('verify specifying child document resource types filters the resource types', function(callback) {
    var invoked = 0;

    SearchAPI.registerChildSearchDocument(
      'test_filter_types',
      {
        resourceTypes: ['test_resource_type'],
        schema: {
          test_field_name: {
            type: 'string',
            store: 'no',
            index: 'not_analyzed',
          },
        },
        producer: function(resources, callback) {
          invoked++;

          callback(null, []);

          _.each(resources, function(resource) {
            // Make sure we only ever get content items
            assert.equal(
              AuthzUtil.getResourceFromId(resource.id).resourceType,
              't',
            );
          });
        },
      },
      function(err) {
        assert.ok(!err);

        // Send an index task of a document of the proper resource type
        SearchAPI.postIndexTask(
          'test_resource_type',
          [{ id: 't:cam:test' }],
          { children: true },
          function(err) {
            assert.ok(!err);

            // Send an index task of a document of not the proper resource type
            SearchAPI.postIndexTask(
              'not_test_resource_type',
              [{ id: 'n:cam:test' }],
              { children: true },
              function(err) {
                // Wait for the producers to be invoked
                MQTestsUtil.whenTasksEmpty(
                  SearchConstants.mq.TASK_INDEX_DOCUMENT,
                  function() {
                    // Ensure only the proper resource type invoked the producer
                    assert.equal(invoked, 1);
                    return callback();
                  },
                );
              },
            );
          },
        );
      },
    );
  });

  /**
   * Test that verifies an unspecified resource type array results in all documents sent to a child document producer
   */
  it('verify unspecifyied child document resource type accepts all resource types', function(callback) {
    var invoked = 0;

    SearchAPI.registerChildSearchDocument(
      'test_filter_no_types',
      {
        schema: {
          test_field_name: {
            type: 'string',
            store: 'no',
            index: 'not_analyzed',
          },
        },
        producer: function(resources, callback) {
          invoked++;
          return callback(null, []);
        },
      },
      function(err) {
        assert.ok(!err);

        // Send an index task of a document of the proper resource type
        SearchAPI.postIndexTask(
          'test_resource_type',
          [{ id: 't:cam:test' }],
          { children: true },
          function(err) {
            assert.ok(!err);

            // Send an index task of a document of not the proper resource type
            SearchAPI.postIndexTask(
              'another_test_resource_type',
              [{ id: 'n:cam:test' }],
              { children: true },
              function(err) {
                // Wait for the producers to be invoked
                MQTestsUtil.whenTasksEmpty(
                  SearchConstants.mq.TASK_INDEX_DOCUMENT,
                  function() {
                    // Ensure only the proper resource type invoked the producer
                    assert.equal(invoked, 2);
                    return callback();
                  },
                );
              },
            );
          },
        );
      },
    );
  });
});
