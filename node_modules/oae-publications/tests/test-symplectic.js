/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');
var Cassandra = require('oae-util/lib/cassandra');
var util = require('util');

var AuthenticationConstants = require('oae-authentication/lib/constants').AuthenticationConstants;
var AuthenticationDAO = require('oae-authentication/lib/internal/dao');
var ConfigTestUtil = require('oae-config/lib/test/util');
var LoginId = require('oae-authentication/lib/model').LoginId;
var RestAPI = require('oae-rest');
var TestsUtil = require('oae-tests/lib/util');

var PublicationsAPI = require('oae-publications');
var PublicationsTestUtil = require('oae-publications/lib/test/util');
var SymplecticIngester = require('oae-publications/lib/ingesters/symplectic/ingester');
var SymplecticDAO = require('oae-publications/lib/ingesters/symplectic/dao');


describe('Publications - Symplectic', function() {

    // Variables related to the mocked Symplectic API
    var app = null;
    var server = null;
    var port = null;
    // Can be set to a function that receives a request and response parameter and manipulate the response. You should return `true` if you send a response
    var userPublicationRESTResponse = null;

    var users = {};

    var camAnonymousRestCtx = null;
    var camAdminRestCtx = null;
    var globalAdminRestContext = null;

    /*!
     * Set up a web server that mocks Symplectic responses, cleans out the publications and creates users that can be used
     * to ingest data for.
     */
    beforeEach(function(callback) {
        camAnonymousRestCtx = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host);
        camAdminRestCtx = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.cam.host);
        globalAdminRestContext = TestsUtil.createGlobalAdminRestContext();
        userPublicationRESTResponse = null;

        // 1. Mock the Symplectic API
        TestsUtil.createTestServer(function(_app, _server, _port) {

            app = _app;
            server = _server;
            port = _port;

            // All the users in the system
            app.get('/publications-api/v3.7.16/users', function(req, res) {
                var modifiedSince = req.param('modified-since');

                var path = util.format('%s/data/symplectic/users.xml', __dirname);
                if (modifiedSince) {
                    path = util.format('%s/data/symplectic/usersModifiedSince.xml', __dirname);
                }
                res.sendfile(path);
            });

            // Publications for a specific user (with paging)
            app.get('/publications-api/v3.7.16/users/:user/publications', function(req, res) {
                if (userPublicationRESTResponse && userPublicationRESTResponse(req, res)) {
                    // This request has already been dealt with
                    return;
                }

                // Do the default good thing and ship back the publications for this user
                var user = req.params.user;
                var page = parseInt(req.query.page, 10) || 1;
                var path = util.format('%s/data/symplectic/users/%s/publications/page%d.xml', __dirname, user, page);
                res.sendfile(path);
            });

            var baseUrl = util.format('http://localhost:%d/publications-api/v3.7.16', port);

            // 2. Setup the symplectic integration on the cam tenant
            var config = {
                'oae-publications/symplectic/enabled': true,
                'oae-publications/symplectic/baseUrl': baseUrl,
                'oae-publications/symplectic/authenticationStrategy': 'cas'
            };
            ConfigTestUtil.updateConfigAndWait(globalAdminRestContext, global.oaeTests.tenants.cam.alias, config, function(err) {
                assert.ok(!err);

                // 3. Clean the various publications CFs
                Cassandra.runQuery('TRUNCATE Publications', [], function(err) {
                    assert.ok(!err);
                    Cassandra.runQuery('TRUNCATE PublicationsBySource', [], function(err) {
                        assert.ok(!err);
                        Cassandra.runQuery('TRUNCATE PublicationsByUser', [], function(err) {
                            assert.ok(!err);
                            Cassandra.runQuery('TRUNCATE PublicationsAuthors', [], function(err) {
                                assert.ok(!err);
                                Cassandra.runQuery('TRUNCATE Symplectic', [], function(err) {
                                    assert.ok(!err);

                                    // 4. Set up a couple of users that are in the Symplectic data set
                                    TestsUtil.generateTestUsers(camAdminRestCtx, 3, function(err, _users, alanblackwell, cecilymorrison, georgecoulouris) {
                                        assert.ok(!err);
                                        // Associate these userIds with a proper login ID
                                        var tenantAlias = global.oaeTests.tenants.cam.alias;
                                        AuthenticationDAO.associateLoginId(new LoginId(tenantAlias, AuthenticationConstants.providers.CAS, 'afb21'), alanblackwell.user.id, function(err) {
                                            assert.ok(!err);
                                            AuthenticationDAO.associateLoginId(new LoginId(tenantAlias, AuthenticationConstants.providers.CAS, 'cpm38'), cecilymorrison.user.id, function(err) {
                                                assert.ok(!err);
                                                AuthenticationDAO.associateLoginId(new LoginId(tenantAlias, AuthenticationConstants.providers.CAS, 'gfc22'), georgecoulouris.user.id, function(err) {
                                                    assert.ok(!err);

                                                    users.alanblackwell = alanblackwell;
                                                    users.cecilymorrison = cecilymorrison;
                                                    users.georgecoulouris = georgecoulouris;

                                                    // Truncate this table *after* we've created the users
                                                    Cassandra.runQuery('TRUNCATE SymplecticUsers', [], function(err) {
                                                        assert.ok(!err);

                                                        return callback();
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    /*!
     * Shut down the mock web server after each test
     */
    afterEach(function(callback) {
        server.close(callback);
    });

    /**
     * Test that verifies publications can be ingested and linked to a user
     */
    it('verify basic ingesting', function(callback) {
        // Start the ingesting process for all tenants, this should only ingest publications for the cambridge tenant as it's the only one who has it enabled
        SymplecticIngester.startIngesting(function() {

            // Get all of Alan Blackwell's ingested publications
            PublicationsTestUtil.getAllPublicationsForUser(users.alanblackwell.restContext, users.alanblackwell.user.id, function(err, allPublications) {
                assert.ok(!err);

                // According to symplectic, Alan Blackwell should have 91 publications
                assert.equal(allPublications.length, 91);

                // Do a couple of spot checks
                var dasherPublication = _.find(allPublications, function(publication) { return publication.displayName === 'Dasher: A gesture-driven data entry interface for mobile computing'; });
                assert.ok(dasherPublication);
                assert.equal(dasherPublication.publicationType, 'journal article');
                assert.equal(dasherPublication.publisher, 'HUM-COMPUT INTERACT');
                assert.equal(dasherPublication.authors.length, 3);
                assert.ok(_.contains(dasherPublication.authors, 'MacKay DJC'));
                assert.ok(_.contains(dasherPublication.authors, 'Ward DJ'));
                assert.ok(!_.contains(dasherPublication.authors, 'Blackwell AF'));
                var alanProfile = _.find(dasherPublication.authors, function(author) { return author.id && author.id === users.alanblackwell.user.id; });
                assert.ok(alanProfile);

                // Cecily should have 1
                RestAPI.Publications.getPublications(users.cecilymorrison.restContext, users.cecilymorrison.user.id, null, 25, function(err, data) {
                    assert.ok(!err);
                    assert.equal(data.results.length, 1);

                    var publication = data.results[0];
                    assert.equal(publication.displayName, 'Practitioner-customizable clinical information systems: a case study to ground further research and development opportunities');
                    assert.equal(publication.publicationType, 'journal article');
                    assert.equal(publication.publisher, 'Journal of Healthcare Engineering');

                    return callback();
                });
            });
        });
    });

    /**
     * Test that verifies that a publication can be linked to multiple users
     */
    it('verify a publication can be linked to multiple users', function(callback) {
        // Ingest everything for the cam tenant
        SymplecticIngester.ingestPublicationsForTenant(global.oaeTests.tenants.cam.alias, true, null, function(err) {
            assert.ok(!err);

            RestAPI.Publications.getPublications(users.cecilymorrison.restContext, users.cecilymorrison.user.id, null, 25, function(err, data) {
                assert.ok(!err);

                // Cecily only has 1 publication in Symplectic
                assert.equal(data.results.length, 1);

                // Assert its the correct publication
                var publication = data.results[0];
                assert.equal(publication.displayName, 'Practitioner-customizable clinical information systems: a case study to ground further research and development opportunities');
                assert.equal(publication.publicationType, 'journal article');
                assert.equal(publication.publisher, 'Journal of Healthcare Engineering');

                // There are  3 authors available for this publication: our Cecily and Alan users, and a third unknown author 'Vuylsteke A'. Both Cecily and Alan should have their full OAE profile in there
                assert.equal(publication.authors.length, 3);
                var alan = _.find(publication.authors, function(author) { return author.id && author.id === users.alanblackwell.user.id; });
                assert.ok(alan);
                assert.ok(_.isObject(alan));
                var cecily = _.find(publication.authors, function(author) { return author.id && author.id === users.cecilymorrison.user.id; });
                assert.ok(cecily);
                assert.ok(_.isObject(cecily));
                return callback();
            });
        });
    });

    /**
     * Test that verifies that if a request fails the first time, we will retry it
     */
    it('verify request retry logic', function(callback) {
        var failsSent = 0;
        // Mock a server failure on Symplectic their end for 'Alan Blackwell'
        userPublicationRESTResponse = function(req, res) {
            if (req.param('user') === 'username-AFB21' && failsSent < 2) {
                failsSent++;
                res.send(500);
                return true;
            } else {
                return false;
            }
        };
        SymplecticIngester.ingestPublicationsForTenant(global.oaeTests.tenants.cam.alias, true, null, function(err) {
            assert.ok(!err);

            // Ensure that we've sent our 500's or we're not verifying anything
            assert.equal(failsSent, 2);

            // Even though Symplectic sent a couple of 500's we should still get all the data
            PublicationsTestUtil.getAllPublicationsForUser(users.alanblackwell.restContext, users.alanblackwell.user.id, function(err, publications) {
                assert.ok(!err);
                assert.ok(publications.length > 0);

                // Sanity check all the other users
                RestAPI.Publications.getPublications(users.cecilymorrison.restContext, users.cecilymorrison.user.id, null, 10, function(err, data) {
                    assert.ok(!err);
                    assert.ok(publications.length > 0);
                    RestAPI.Publications.getPublications(users.cecilymorrison.restContext, users.cecilymorrison.user.id, null, 10, function(err, data) {
                        assert.ok(!err);
                        assert.ok(publications.length > 0);

                        return callback();
                    });
                });
            });
        });
    });

    /**
     * Test that verifies users get retried if for some reason we failed to ingest them
     */
    it('verify user retry logic', function(callback) {
        // If we're sending back faulty XML that would indicate a failed user
        userPublicationRESTResponse = function(req, res) {
            if (req.param('user') === 'username-AFB21') {
                res.send(200, 'totally not XML');
                return true;
            } else {
                return false;
            }
        };

        // Do an initial ingest
        SymplecticIngester.startIngesting(function() {

            // Alan should have no publications
            RestAPI.Publications.getPublications(users.alanblackwell.restContext, users.alanblackwell.user.id, null, 10, function(err, data) {
                assert.ok(!err);
                assert.equal(data.results.length, 0);

                // But the other users should have some
                RestAPI.Publications.getPublications(users.cecilymorrison.restContext, users.cecilymorrison.user.id, null, 10, function(err, data) {
                    assert.ok(!err);
                    assert.ok(data.results.length > 0);
                    RestAPI.Publications.getPublications(users.cecilymorrison.restContext, users.cecilymorrison.user.id, null, 10, function(err, data) {
                        assert.ok(!err);
                        assert.ok(data.results.length > 0);

                        // Assert that alan is in the retry list
                        SymplecticDAO.getUsersFromRetryList(global.oaeTests.tenants.cam.alias, null, 10, function(err, retryUsers) {
                            assert.ok(!err);
                            assert.equal(retryUsers.length, 1);
                            assert.equal(retryUsers[0].oaeUserId, users.alanblackwell.user.id);
                            assert.equal(retryUsers[0].externalUserId, 'AFB21');

                            // Symplectic has "fixed" their problem for that particular user
                            userPublicationRESTResponse = null;

                            // Trigger an incremental synchronization. Our mocked server will return no users, but because Alan Blackwell is in the retry CF, his data will be fetched
                            var preRun = Date.now();
                            SymplecticIngester.startIngesting(function() {

                                // Assert we did an incremental update
                                SymplecticDAO.getLastRunTimes(global.oaeTests.tenants.cam.alias, function(err, lastFullRun, lastIncrementalRun) {
                                    assert.ok(!err);

                                    assert.ok(lastIncrementalRun > lastFullRun);
                                    assert.ok(lastIncrementalRun >= preRun);

                                    // Alan should now have all his publications
                                    RestAPI.Publications.getPublications(users.alanblackwell.restContext, users.alanblackwell.user.id, null, 10, function(err, data) {
                                        assert.ok(!err);
                                        assert.equal(data.results.length, 10);

                                        // Assert that the retry list is empty
                                        SymplecticDAO.getUsersFromRetryList(global.oaeTests.tenants.cam.alias, null, 10, function(err, retryUsers) {
                                            assert.ok(!err);
                                            assert.equal(retryUsers.length, 0);

                                            return callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    /**
     * Test that verifies that new OAE users are included in the next incremental synchronization
     */
    it('verify new users get ingested on incremental synchronizations', function(callback) {
        // Do an initial ingest
        SymplecticIngester.startIngesting(function() {

            // Create a user whose data is also in Symplectic
            TestsUtil.generateTestUsers(camAdminRestCtx, 1, function(err, _users, simong) {
                assert.ok(!err);
                AuthenticationDAO.associateLoginId(new LoginId(global.oaeTests.tenants.cam.alias, AuthenticationConstants.providers.CAS, 'sg555'), simong.user.id, function(err) {
                    assert.ok(!err);

                    // Do an incremental synchronization
                    SymplecticIngester.startIngesting(function() {

                        // Get all of Simon's publications
                        PublicationsTestUtil.getAllPublicationsForUser(simong.restContext, simong.user.id, function(err, publications) {
                            assert.ok(!err);
                            assert.equal(publications.length, 1);
                            assert.equal(publications[0].displayName, 'Messing About');
                            assert.equal(publications[0].publicationType, 'journal article');
                            assert.equal(publications[0].publisher, 'Jiggery and Pokery Press');
                            assert.equal(publications[0].authors.length, 2);
                            assert.equal(_.find(publications[0].authors, function(author) { return (typeof author === 'string'); }), 'Visser B');
                            assert.equal(_.find(publications[0].authors, function(author) { return (typeof author === 'object'); }).id, simong.user.id);

                            return callback();
                        });
                    });
                });
            });
        });
    });

    /**
     * Test that verifies that publications that are marked as invisible are not ingested
     */
    it('verify the is-visible attribute is respected', function(callback) {
        // Create a user whose data is also in Symplectic
        TestsUtil.generateTestUsers(camAdminRestCtx, 1, function(err, _users, simong) {
            assert.ok(!err);
            AuthenticationDAO.associateLoginId(new LoginId(global.oaeTests.tenants.cam.alias, AuthenticationConstants.providers.CAS, 'sg555'), simong.user.id, function(err) {
                assert.ok(!err);

                // Do a full ingest
                SymplecticIngester.startIngesting(function() {

                    // Do an incremental ingest so our sg555 user gets picked up
                    SymplecticIngester.startIngesting(function() {

                         // Get all of Simon's publications
                        PublicationsTestUtil.getAllPublicationsForUser(simong.restContext, simong.user.id, function(err, publications) {
                            assert.ok(!err);

                            // Only the "messing about" publication should be ingested as the other one has been marked as invisible in Symplectic
                            assert.equal(publications.length, 1);
                            assert.equal(publications[0].displayName, 'Messing About');
                            assert.equal(publications[0].publicationType, 'journal article');
                            assert.equal(publications[0].publisher, 'Jiggery and Pokery Press');
                            assert.equal(publications[0].authors.length, 2);
                            assert.equal(_.find(publications[0].authors, function(author) { return (typeof author === 'string'); }), 'Visser B');
                            assert.equal(_.find(publications[0].authors, function(author) { return (typeof author === 'object'); }).id, simong.user.id);

                            return callback();
                        });
                    });
                });
            });
        });
    });
});
