/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var OAE = require('oae-util/lib/oae');
var IO = require('oae-util/lib/io');
var fs = require('fs');
var Cassandra = require('oae-util/lib/cassandra');
var _ = require('underscore');

// Keeps track of the configurableModules
var configurableModules = [];

/**
 * Constructs an UPDATE CQL query with a variable amount of values to set
 * @param {Object} configValues configuration values to set
 */
var constructUpdateCQLQuery = function(configValues) {
    var q = {
        'query': '',
        'params': []
    }
    var tempQuery = [];
    for (var i in configValues) {
        tempQuery.push('? = ?');
        q.params.push(i, configValues[i].value);
        tenantid = configValues[i].tenantid;
    }
    q.query = 'UPDATE Config SET ' + tempQuery.join(', ') + ' WHERE tenantid = ?';
    q.params.push(tenantid);
    return q;
};

/**
 * Writes configuration to Cassandra
 * @param {Object} configValues The configuration to store
 * @param {Function} callback Function executed when storing the configuration completes
 */
var writeConfig = module.exports.writeConfig = function(configValues, callback) {
    callback = callback || function() {};
    var q = constructUpdateCQLQuery(configValues);
    Cassandra.runQuery(q.query, q.params, function(err) {
        if (!err) {
            callback();
        } else {
            callback(err);
        }
    });
};

/**
 * Casts a stringified Boolean back to proper Boolean type
 * @param {String} value Stringified Boolean (only "true" or "false" accepted) to cast back to Boolean
 */
var castToBoolean = function(value) {
    if (value === "true") {
        return true;
    } else if (value === "false") {
        return false;
    }
};

/**
 * Merges the different configurations into one. config.json < global config < tenant config
 * @param {Object} config Contains configuration values
 * @param {Object} modules Contains the modules available for configuration
 * @param {Function} callback Function executed when config has been fully merged
 */
var mergeConfigIntoOriginal = module.exports.mergeConfigIntoOriginal = function(config, modules, callback) {
    callback = callback || function() {};

    // Loop over the stored config (this will always be shorter than looping over the config files first)
    for (var i = 0, l = config.count; i < l; i++) {
        // Split the colHash to match to the element IDs
        var colHash = config[i].name.split('/');
        // Loop over the config.json files
        for (var ii = 0, ll = modules.length; ii < ll; ii++) {
            // Only continue if the module ID matches the stored config
            if (modules[ii].id === colHash[0]) {
                // Loop over the elements in the module config
                for (var iii = 0, lll = modules[ii].config.options.length; iii < lll; iii++) {
                    // Only continue if the option ID matches the stored config
                    if (modules[ii].config.options[iii].id === colHash[1]) {
                        // Loop over the elements in the option
                        for (var iiii = 0, llll = modules[ii].config.options[iii].elements.length; iiii < llll; iiii++) {
                            // Only continue if the element ID matches the stored config
                            if (modules[ii].config.options[iii].elements[iiii].id === colHash[2]) {
                                // Overwrite the config.json files with the stored value
                                var value = config[i].value;
                                if (config[i].type === "Boolean") {
                                    value = castToBoolean(value);
                                }
                                modules[ii].config.options[iii].elements[iiii].value = value;
                            }
                        }
                    }
                }
            }
        }
    }
    callback(modules);
};

/**
 * Reads the configuration values
 * @param {String} tenantid The ID of the tenant to get configuration for
 * @param {Function} callback Function executed after config has been read
 */
var readConfig = module.exports.readConfig = function(tenantid, callback) {
    callback = callback || function() {};
    Cassandra.runQuery('SELECT * FROM Config WHERE tenantid = ?', ['global'], function(err, globalRows) {
        if (!err) {
            getModules(function(modules) {
                // Merge the stored config files into the fetched modules data
                // config.json < global config < tenant config
                mergeConfigIntoOriginal(globalRows[0], modules, function(config) {
                    if (!err) {
                        Cassandra.runQuery('SELECT * FROM Config WHERE tenantid = ?', [tenantid], function(err, tenantRows) {
                            mergeConfigIntoOriginal(tenantRows[0], config, function(config) {
                                if (!err) {
                                    callback(false, config);
                                } else {
                                    callback(err);
                                }
                            });
                        });
                    } else {
                        callback(err);
                    }
                });
            });
        } else {
            callback(err);
        }
    });
};

 /**
 * Filters out modules that don't have a configuration file in the config directory and fills an Array of modules with configuration.
 * @param {Array} modules Array of strings containing directory names for oae- modules.
 * @param {Function} callback Callback function executed when filtering is complete. Passes through the filtered Array of config objects.
 */
var filterModulesByConfig = function(modules, callback) {

    /**
     * Filters out modules that don't have a configuration file in the config directory
     * @param {Number} i index of the module to filter next
     */
    var doFilter = function(i) {
        if (modules[i]) {
            fs.exists('node_modules/' + modules[i] + '/config/config.json', function(exists) {
                if (exists) {
                    IO.loadJSONConfig('node_modules/' + modules[i] + '/config/config.json', function(configFile) {
                        var configObj = {
                            'id': modules[i],
                            'config': JSON.parse(configFile)
                        }
                        configurableModules.push(configObj);
                        if (modules[i+1]) {
                            doFilter(i += 1);
                        } else {
                            callback(configurableModules);
                        }
                    });
                } else {
                    if (modules[i+1]) {
                        doFilter(i += 1);
                    } else {
                        callback(configurableModules);
                    }
                }
            });
        } else {
            callback(configurableModules);
        }
    };

    doFilter(0);
};

/**
 * Gets the available modules
 * @param {Function} callback Function executed when availables modules are retrieved
 */
var getModules = module.exports.getModules = function(callback) {
    callback = callback || function(){};

    // Read directories starting with oae- and get their configuration files.
    // If there's no configuration file the directory is skipped.
    OAE.getAvailableModules(function(finalModules) {
        configurableModules = [];
        filterModulesByConfig(finalModules, callback);
    });
};