/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var dox = require('dox');
var fs = require('fs');
var path = require('path');

var IO = require('oae-util/lib/io');
var Modules = require('oae-util/lib/modules');
var Validator = require('oae-util/lib/validator').Validator;
var UIAPI = require('oae-ui');
var log = require('oae-logger').logger('oae-doc');

// Variable that will be used to cache the back-end and front-end documentation
var cachedDocs = {
    'backend': {},
    'frontend': {}
};

/**
 * Initializes the docs by fetching all the back-end modules and front-end APIs, parsing
 * their documentation and caching it.
 *
 * @param  {Object}     uiPath           The path to the UI directory
 * @param  {Function}   callback         Standard callback function
 */
var initializeDocs = module.exports.initializeDocs = function(uiPath, callback) {
    // Initialize the front-end documentation
    initializeFrontendDocs(uiPath, callback);
};

/**
 * Initialize the front-end docs by fetching the list of available API files, parsing
 * their documentation and caching it.
 *
 * @param  {Object}     uiPath           The path to the base UI directory
 * @param  {Function}   callback         Standard callback function
 * @api private
 */
var initializeFrontendDocs = function(uiPath, callback) {
    // Only parse the API files. We don't parse any other UI files yet.
    var dir = '/shared/oae/api';

    // Get all of the available files in this folder
    IO.getFileListForFolder(uiPath + dir, function(err, fileNames) {
        if (err) {
            return log().warn({'err': err, 'dir': dir}, 'Failed getting file list of UI API files.');
        }

        // Convert the array of available file names to an object where the keys are the filenames
        // and the values are the paths to these filenames
        var files = mapHashedFiles(fileNames, dir);

        // Prepend the base UI path to all of the generated paths, as the current paths
        // will be relative to the UI folder
        _.each(files, function(path, fileName) {
            files[fileName] = uiPath + path;
        });

        // Filter out folders and non-javascript files, as well as a list of files
        // for which we don't want to generate documentation
        files = filterFiles(files, ['oae.api.js', 'oae.bootstrap.js', 'oae.core.js']);

        parseDocs(files, function(err, docs) {
            cachedDocs.frontend = docs;
            // Initialize the back-end documentation
            initializeBackendDocs(callback);
        });
    });
};

/**
 * Utility function that will try to map a list of files inside of a folder to the original unhashed version.
 * The unhashed version can then be used for generating more user-readable names and filtering based on filenames.
 *
 * @param  {String[]}   fileNames           The unfiltered array of filenames that needs to be mapped
 * @param  {String}     dir                 The base path to the folder containing the provided filenames
 * @return {Object}                         JSON object where the keys are the user-friendly filenames and the values are the actual paths to these file. These paths will be hasehd when working with a production build.
 * @api private
 */
var mapHashedFiles = function(fileNames, dir) {
    var mappedFiles = {};
    _.each(fileNames, function(fileName) {
        var path = dir + '/' + fileName;
        // Try to find the original path based on the hashed path. If the path cannot be mapped via the
        // hashed file, we assume that we are not working with a production build and use the path as is
        var mappedPath = UIAPI.getOriginalResource(path) || path;
        mappedFiles[mappedPath.split('/').pop()] = path;
    });
    return mappedFiles;
};

/**
 * Initialize the back-end docs by fetching the list of available modules, parsing
 * the documentation of the files in `/lib` and caching it.
 *
 * @param  {Function}   callback         Standard callback function
 * @api private
 */
var initializeBackendDocs = function(callback) {
    var modules = Modules.getAvailableModules();
    var done = 0;

    _.each(modules, function(module) {
        // Parse the JS files in /lib for each module
        var dir = 'node_modules/' + module + '/lib';

        // Get all of the available files in this folder
        IO.getFileListForFolder(dir, function(err, fileNames) {
            if (err) {
                return log().warn({'err': err, 'dir': dir}, 'Failed getting file list to parse dox documentation for %s.', module);
            }

            // Convert the array of available file names to an object where the keys are the filenames
            // and the values are the full paths to these filenames
            var files = {};
            _.each(fileNames, function(fileName) {
                files[fileName] = dir + '/' + fileName;
            });

            // Filter out folders and non-javascript files
            files = filterFiles(files);

            // Parse the documentation for these files
            parseDocs(files, function(err, docs) {
                done++;
                cachedDocs.backend[module] = docs;
                if (done === modules.length) {
                    callback();
                }
            });
        });
    });
};

/**
 * Parse the JSDocs of all of the provided JavaScript files using Dox (https://github.com/visionmedia/dox).
 *
 * @param  {Object}     files           JSON object where the keys are the user-friendly filenames and the values are the actual paths to these file. These paths will be hasehd when working with a production build.
 * @param  {Function}   [callback]      Standard callback function
 * @param  {Object}     [callback.err]  Error object containing error code and error message 
 * @param  {Object}     [callback.docs] JSON Object where the keys are the file names and the values are the parsed JSDocs
 * @api private
 */
var parseDocs = function(files, callback) {
    var done = 0;
    var todo = _.keys(files).length;
    var doc = {};

    _.each(files, function(path, fileName) {
        (function(path, fileName) {
            // Read each of the files in the provided directory
            IO.readFile(path, function(err, data) {
                done++;
                if (!err) {
                    // Parse the JSDocs using Dox
                    try {
                        doc[fileName] = dox.parseComments(data);
                    } catch (ex) {
                        log().warn({
                            err: ex,
                            data: data
                        }, 'Failed parsing comment data with dox for file %s. Ignoring.', path);
                    }
                } else {
                    log().error('Failed reading %s', path);
                }

                if (done === todo) {
                    return callback(err, doc);
                }
            });
        })(path, fileName);
    });

    if (todo === 0) {
        callback(doc);
    }
};

/**
 * Utility function that filters out all non-javascript files and folder as we don't want to generate
 * documentation for these.
 *
 * @param  {Object}     files               JSON object where the keys are the user-friendly filenames and the values are the actual paths to these file. These paths will be hasehd when working with a production build.
 * @param  {String[]}   [exclude]           Array of filenames that should be filtered out. Matches will be determined on the keys of the files object
 * @return {Object}                         Files object from which the non-javascript files and folders are stripped
 * @api private
 */
var filterFiles = function(files, exclude) {
    _.each(files, function(path, fileName) {
        if (fileName.indexOf('.js') === -1 || _.indexOf(exclude, fileName) !== -1) {
            delete files[fileName];
        }
    });
    return files;
};

/**
 * Retrieve the list of available modules
 *
 * @param  {String}     type                The module type to get the listing for. Accepted values are `backend` and `frontend`
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containing the error code and message
 * @param  {String[]}   callback.modules    The list of available modules for the provided type
 */
var getModules = module.exports.getModules = function(type, callback) {
    if (!cachedDocs[type]) {
        return callback({'code': 400, 'msg': 'Invalid module type. Accepted values are "backend" and "frontend"'});
    }

    callback(null, _.keys(cachedDocs[type]));
}

/**
 * Retrieve the documentation for a particular module
 * 
 * @param  {String}     moduleId        The module to get the documentation for
 * @param  {String}     type            The type of the module to get the documentation for. Accepted values are `backend` and `frontend`
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    Error object containing the error code and message
 * @param  {Object}     callback.doc    The parsed documentation for the requested module
 */
var getModuleDocumentation = module.exports.getModuleDocumentation = function(moduleId, type, callback) {
    var validator = new Validator();
    validator.check(moduleId, {'code': 400, 'msg': 'Missing module id'}).notEmpty();
    validator.check(type, {'code': 400, 'msg': 'Missing module type'}).notEmpty();
    validator.check(type, {'code': 400, 'msg': 'Invalid module type. Accepted values are "backend" and "frontend"'}).isIn(['backend', 'frontend']);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Return the parsed docs from cache
    if (cachedDocs[type] && cachedDocs[type][moduleId]) {
        return callback(null, cachedDocs[type][moduleId]);
    } else {
        return callback({'code': 404, 'msg': 'No documentation for this module was found'});
    }
};

