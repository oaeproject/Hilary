/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var fs = require('fs');

var Cassandra = require('oae-util/lib/cassandra');
var Util = require('oae-util/lib/util');
var IO = require('oae-util/lib/io');
var OAE = require('oae-util/lib/oae');
var Pubsub = require('oae-util/lib/pubsub');
var Validator = require('oae-util/lib/validator').Validator;

var Fields = require('./fields');

var cachedConfiguration = {};


Pubsub.on('oae-config', function(receivedMessage) {
    // Messages are of the form:
    //      cam config updated
    //      gt config updated
    var tenantId = receivedMessage.split(' ')[0];
    getConfigFromCassandra(tenantId, function() {});
});

/**
 * Writes configuration to Cassandra
 * @param  {String}   tenantId      The id of the tenant to store config for
 * @param  {Object}   configValues  The configuration to store
 * @param  {Function} callback      Function executed when storing the configuration completes
 * @param  {Object}   callback.err  An error object is passed as an argument if an error occurs
 */
var writeConfig = module.exports.writeConfig = function(tenantId, configValues, callback) {
    var validator = new Validator();
    validator.check(tenantId, {'code': 400, 'msg': 'Missing tenantid'}).notEmpty();
    validator.check(_.keys(configValues).length, {'code': 400, 'msg': 'Missing configuration. Example configuration: {"oae-authentication/google-authentication/google-authentication-enabled": {"tenantid": "global","value": false}}'}).min(1);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var q = Cassandra.constructUpsertCQL('Config', 'tenantId', tenantId, configValues, 'QUORUM');
    Cassandra.runQuery(q.query, q.parameters, function(err, config) {
        if (!err) {
            Pubsub.publish('oae-config', tenantId + ' config updated');
        }
        callback(err, config);
    });
};

/**
 * Reads the configuration values from cache or calls retrieveConfigFromCassandra and returns the configuration
 * @param  {String}    tenantId      The ID of the tenant to get configuration for
 * @param  {Function}  callback      Function executed after config has been read
 * @param  {Object}    callback.err  An error object is passed as an argument if an error occurs
 */
var getConfig = module.exports.getConfig = function(tenantId, callback) {
    var validator = new Validator();
    validator.check(tenantId, {'code': 400, 'msg': 'Missing tenantid'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // If the tenant configuration is cached return it instead of querying the database
    if (cachedConfiguration[tenantId]) {
        return callback(false, cachedConfiguration[tenantId]);
    } else {
        getConfigFromCassandra(tenantId, callback);
    }
};

/**
 * Reads the configuration values from Cassandra
 * @param  {String}    tenantId   The ID of the tenant to get configuration for
 * @param  {Function}  callback   Function executed after config has been read
 */
var getConfigFromCassandra = function(tenantId, callback) {
    var cqlParams = [OAE.serverTenant.alias];
    if (tenantId !== OAE.serverTenant.alias) {
        cqlParams.push(tenantId);
    }

    Cassandra.runQuery('SELECT * FROM Config USING CONSISTENCY QUORUM WHERE tenantId IN (?)', [cqlParams], function(err, rows) {
        if (err) {
            return callback(err);
        }

        getDefaultConfiguration(function(defaultConfig) {
            callback(false, mergeStoredConfigIntoOriginal(rows, defaultConfig));
        });
    });
};

/**
 * Merges the different configurations into one. config.json < global config < tenant config
 *
 * @param  {Object}      cassandraConfig     Helenus object that contains configuration values stored in Cassandra. There will be one row for the global tenant, and also one row for the current tenant if the current tenant is not the global tenant
 * @param  {Object}      moduleConfig        Contains the aggregated configurations for all of the available modules
 * @return {Object}                          All of the configuration values for all available modules, with values overriden if the current tenant has modifications to that config variable
 */
var mergeStoredConfigIntoOriginal = function(cassandraConfig, moduleConfig) {
    // Loop over this as the config
    for (var r = 0; r < cassandraConfig.length; r++) {
        // Loop over all of the configured fields for the current tenant
        for (var c = 0; c < cassandraConfig[r].count; c++) {
            if (cassandraConfig[r][c].name !== 'tenantId') {
                // colHash looks like: ['moduleid', 'optionid', 'elementid']. e.g. ['oae-authentication', 'twitter', 'enabled']
                var colHash = cassandraConfig[r][c].name.split('/');
                if (moduleConfig[colHash[0]] && moduleConfig[colHash[0]][colHash[1]] && moduleConfig[colHash[0]][colHash[1]].elements[colHash[2]]) {
                    moduleConfig[colHash[0]][colHash[1]].elements[colHash[2]].defaultValue = Util.castToBoolean(cassandraConfig[r][c].value);
                }
            }
        }
        cachedConfiguration[cassandraConfig[r].get("tenantId").value] = moduleConfig;
    }
    return moduleConfig;
};

 /**
 * Retrieve all of the available modules and Filters out modules that don't have a configuration file in the config directory and fills an 
 * Array of modules with configuration. Every file in the /config directory of a module is read. It's assumed that the files contains valid JSON.
 * If multiple configuration files exist in one module they will be merged together.
 *
 * @param  {Function}  callback                  Callback function executed when filtering is complete. Passes through the filtered Array of config objects.
 * @param  {Object}    callback.defaultConfig    Object containing the default configuration for all of the configurable modules
 */
var getDefaultConfiguration = function(callback) {

    // Get the available module
    var modules = OAE.getAvailableModules();
    var configurableModules = {};
    var toDo = modules.length;
    var done = 0;

    /**
     * Gets the configuration files for a given module
     *
     * @param  {String}  dir       The URL to a module's configuration directory. e.g. '/node_modules/oae-principals/config/'
     * @param  {String}  module    The module we're getting the configuration for. e.g. 'oae-principals'
     */
    var getConfigContent = function(dir, module) {
        IO.getFileListForFolder(dir, function(files) {
            for (var ii = 0; ii < files.length; ii++) {
                var content = require(module + '/config/' + files[ii]);
                configurableModules[module] = _.extend(configurableModules[module] || {}, content[module]);
            }
            done++;
            if (done === toDo) {
                callback(configurableModules);
            }
        });
    };

    for (var i = 0; i < modules.length; i++) {
        var dir = 'node_modules/' + modules[i] + '/config/';
        getConfigContent(dir, modules[i]);
    }
};
