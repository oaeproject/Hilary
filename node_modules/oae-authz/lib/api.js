/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var _ = require('underscore');
var Cassandra = require('oae-util/lib/cassandra');
var Validator = require('oae-authz/lib/validator').Validator;
var AuthzUtil = require('oae-authz/lib/util');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;


///////////
// ROLES //
///////////

/**
 * Determine the role assigned to the principal directly on the specified resource instance.
 * 
 * @param {String} principalUuid the UUID of the principal
 * @param {String} The UUID of the resource
 * @param {Function(err, role)} callback A function specifying the role of the principal. If the principal
 * has no role or there is an error performing the check, role will be null
 **/
var getRole = module.exports.getRole = function(principalUuid, resourceUuid, callback) {
    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided.'}).isPrincipal();
    validator.check(resourceUuid, {code: 400, msg: 'Invalid resource UUID provided.'}).isValidUuid();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getRole(principalUuid, resourceUuid, callback);
}

/**
 * Determines whether or not the principal has the specified role directly on the given resource.
 * 
 * @param {String} principalUuid The UUID of the princpals
 * @param {String} resourceUuid The UUID of the resource
 * @param {String} role The role to check
 * @param {Function(err, hasRole)} callback A function specifying whether or not the user has the role on the resource
 */
var hasRole = module.exports.hasRole = function(principalUuid, resourceUuid, role, callback) {
    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided.'}).isPrincipal();
    validator.check(resourceUuid, {code: 400, msg: 'Invalid resource UUID provided.'}).isValidUuid();
    validator.check(role, {code: 400, msg: 'Invalid role provided.'}).isValidRole();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _hasRole(principalUuid, resourceUuid, role, callback);
}

/**
 * Given a resourceType (as determined by Resource.resourceType), return all {resource uuid} => {role} entries that are
 * associated to the principal. The structure of the entries result looks like the following:
 * 
 * [
 *   {
 *      "uuid": "<resource uuid 1>",
 *      "role": "<role 1>"
 *    },
 *    {
 *      "uuid": "<resource uuid 2>"
 *      "role": "<role 2>"
 *    }
 * ]
 * 
 * @param {String} principalUuid The UUID of the principal
 * @param {String} resourceType The resource type to search, as determined by Resource.resourceType
 * @param {String} start The starting entry on which to begin returning results (used for paging). **This is not a number**. If null, then the results will simply begin from the start. If the resource uuid is provided, then results will begin from that resource's location, exclusively.
 * @param {Number} limit The maximum number of entries to return (used for paging; default: 10)
 * @param {Function(err, entries)} callback A function, providing the list of role entries that match the search
 */
var getRolesForResourceType = module.exports.getRolesForResourceType = function(principalUuid, resourceType, start, limit, callback) {
    limit = limit || 10;

    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided.'}).isPrincipal();
    validator.check(limit, {code: 400, msg: '"limit" parameter must be a number when searching for active roles'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var firstColumnIndex = 0;
    var columnPrefix = resourceType+':';

    if (start === null) {
        start = columnPrefix;    
    } else {
        // increment the limit if the user specified the start point, because we skip the first entry to get the EXCLUSIVE
        // page range
        limit++;
        firstColumnIndex = 1;
    }

    var cql = 'SELECT FIRST ' + limit + ' ? .. \'\' FROM AuthzRoles WHERE principalId = ?';
    Cassandra.runQuery(cql, [start, principalUuid], function(err, rows) {
        if (!err) {
            var entries = [];

            for (var i = firstColumnIndex, j = rows[0].count; i < j; i++) {
                var col = rows[0][i];
                // we need to stop when we've surpassed the last of the specified resource type
                if (col.name.indexOf(columnPrefix) !== 0) {
                    break;
                }
                entries.push({ 'uuid': col.name, 'role': col.value });
            }
            return callback(null, entries);
        } else {
            return callback({code: 500, msg: err});
        }
    });
}


/**
 * Assign the given principal a role on a resource instance. If the user already has a role, it will simply be updated.
 * 
 * @param {String} principalUuid The UUID of the principal
 * @param {String} resourceUuid the UUID of the resource
 * @param {String} role The role to assign to the principal
 * @param {Function(err)} callback A function specifying whether or not the operation was successful
 */
var setRole = module.exports.setRole = function(principalUuid, resourceUuid, role, callback) {
    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided.'}).isPrincipal();
    validator.check(resourceUuid, {code: 400, msg: 'Invalid resource UUID provided.'}).isValidUuid();
    validator.check(resourceUuid, {code: 400, msg: 'Cannot assign a role for a principal on a group resource.'}).isNotGroupResource();
    validator.check(role, {code: 400, msg: 'Invalid role provided.'}).isValidRole();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var changes = {};
    changes[principalUuid] = role;
    _applyRoleChanges(resourceUuid, changes, callback);
}

/**
 * Remove the role assignment of the given principal on an resource instance. If the user did not have a role, this will
 * have no effect.
 * 
 * @param {String} principalUuid The UUID of the principal
 * @param {String} resourceUuid The UUID of the resource
 * @param {Function(err)} callback A function specifying whether or not the operation was successful
 */
var removeRole = module.exports.removeRole = function(principalUuid, resourceUuid, callback) {
    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided.'}).isPrincipal();
    validator.check(resourceUuid, {code: 400, msg: 'Invalid resource UUID provided.'}).isValidUuid();
    validator.check(resourceUuid, {code: 400, msg: 'Cannot assign a role for a principal on a group resource.'}).isNotGroupResource();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    
    var changes = {};
    changes[principalUuid] = false;
    _applyRoleChanges(resourceUuid, changes, callback);
}

/**
 * Assign multiple principals a role on a resource instance. If the user already has a role, it will simply be updated. When
 * false is passed in as a role, the role for that principal will be removed.
 *
 * @param {String}          resourceUuid    the UUID of the resource
 * @param {Object}          changes         JSON object where the keys are principal ids and the values are role values
 * @param {Function(err)}   callback        Standard callback function
 * @param {Object}          callback.err    Error object, containing the error message
 */
var applyRoleChanges = module.exports.applyRoleChanges = function(resourceUuid, changes, callback) {
    var validator = new Validator();
    validator.check(resourceUuid, {code: 400, msg: 'Invalid resource UUID provided.'}).isValidUuid();
    validator.check(resourceUuid, {code: 400, msg: 'Cannot assign a role for a principal on a group resource.'}).isNotGroupResource();
    _.keys(changes).forEach(function(principalUuid) {
        validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID specified: '+principalUuid}).isValidUuid();
        validator.check(changes[principalUuid], {code: 400, msg: 'Invalid role provided.'}).isValidRoleChange();

    });
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _applyRoleChanges(resourceUuid, changes, callback);
};

/**
 * Get all principal roles associated to the resourceType for all the principals in the array of principalUuids. This is similar
 * to getRolesForResourceType, except it can be performed on multiple principals at once.
 * 
 * The structure of the resulting entries is structured a hash, indicating all resourceUuids that were returned and what the
 * roles associated to those resources were. For example:
 *
 * {
 *      'u:cam:simong': { 'member': true },
 *      'g:cam:group-b': { 'member': true }
 * }
 *
 * or:
 *
 * {
 *      'c:gat:Foo.docx': { 'viewer': true, 'manager': true},
 *      'c:cam:Bar.pdf':  { 'viewer': true }
 * }
 *
 * In the latter case, 'c:gat:Foo.docx' has both 'viewer' and 'manager' role associated to it. This indicates that some principal
 * had a role of 'viewer' on the resource, while some other principal had the 'manager' role.
 *
 * @param {Array}                       principalUuids      The array of principalUuds to query for
 * @param {String}                      resourceType        The resource type of the resources to search for, as determined by Resource.resourceType
 * @param {Number}                      limit               The maximum number of resources to return per user
 * @param {Function(err, entries)}      callback            A function providing all the {resource uuid} -> {roles} mappings aggregated
 *                                                          for all the provided principals queried
 * @param {Object}                      callback.err        An error that occurred, if any
 * @param {Object}                      callback.entries    A JSON Object representing the roles associated to the users
 *
 * @see getRolesForResourceType
 */
var getRolesForPrincipalsAndResourceType = module.exports.getRolesForPrincipalsAndResourceType = function(principalUuids, resourceType, limit, callback) {
    limit = limit || 1000;

    var validator = new Validator();
    validator.check(limit, {code: 400, msg: '"limit" parameter must be a number when searching for active roles'});
    principalUuids.forEach(function(principalUuid) {
        validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID specified: '+principalUuid}).isPrincipal();
    });
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // we append a '|' to the "end" range, as | has a high ASCII alphabetical ordering. This may not suffice if resourceIds have
    // multi-byte characters, which is technically possible. Unfortunately, I don't think there is a better way to do this with
    // CQL.
    var columnPrefix = resourceType+':';
    var start = columnPrefix;
    var end = start+'|';

    var cql = 'SELECT FIRST ' + limit + ' ? .. ? FROM AuthzRoles WHERE principalId IN (?)';
    Cassandra.runQuery(cql, [start, end, principalUuids], function(err, rows) {
        if (!err) {
            var entries = {};

            // aggregate all resources from all the rows (principals) into the entries hash
            rows.forEach(function(row) {
                row.forEach(function(name, value) {
                    if (!entries[name]) {
                        entries[name] = {};
                    }
                    entries[name][value] = true;
                });
            });
            
            return callback(null, entries);
        } else {
            return callback(err);
        }
    });
};


/**
 * Determine the role assigned to the principal directly on the specified resource instance.
 * 
 * @param {String} principalUuid the UUID of the principal
 * @param {String} The UUID of the resource
 * @param {Function(err, role)} callback A function specifying the role of the principal. If the principal
 * has no role or there is an error performing the check, role will be null
 **/
var _getRole = function(principalUuid, resourceUuid, callback) {
    Cassandra.runQuery('SELECT ? FROM AuthzRoles WHERE principalId = ?', [resourceUuid, principalUuid], function(err, rows) {
        if (!err) {
            var col = rows[0].get(resourceUuid);
            if (col) {
                return callback(null, col.value);
            } else {
                return callback(null, null);
            }
        } else {
            return callback(err);
        }
    });
}

/**
 * Determines whether or not the principal has the specified role directly on the given resource.
 * 
 * @param {String} principalUuid The UUID of the princpals
 * @param {String} resourceUuid The UUID of the resource
 * @param {String} role The role to check
 * @param {Function(err, hasRole)} callback A function specifying whether or not the user has the role on the resource
 */
var _hasRole = function(principalUuid, resourceUuid, role, callback) {
    _getRole(principalUuid, resourceUuid, function(err, actualRole) {
        if (!err) {
            return callback(null, role === actualRole);
        } else {
            return callback(err);
        }
    });
}

/**
 * Assign multiple principals a role on a resource instance. If the user already has a role, it will simply be updated. When
 * false is passed in as a role, the role for that principal will be removed.
 *
 * @param {String}          resourceUuid    the UUID of the resource
 * @param {Object}          changes         JSON object where the keys are principal ids and the values are role values
 * @param {Function(err)}   callback        Standard callback function
 * @param {Object}          callback.err    Error object, containing the error message
 */
var _applyRoleChanges = function(resourceUuid, changes, callback) {
    var queries = [];
    var errors = [];

    // Variables for cache invalidation tracking:
    //  1.  If a user's role is removed or updated on a resource, its permission cache for that resource must be invalidated
    //  2.  If a group's role is removed or updated on resource, its permission cache as well as all its member descendants' permissions caches for that resource
    //      must be invalidated
    var principalsToInvalidate = {};
    var groupsToInvalidate = {};

    _.keys(changes).forEach(function(principalUuid) {
        if (changes[principalUuid]) {
            queries.push({
                'query': 'UPDATE AuthzRoles SET ? = ? WHERE principalId = ?',
                'parameters': [resourceUuid, changes[principalUuid], principalUuid]
            });
        } else if (changes[principalUuid] === false) {
            queries.push({
                'query': 'DELETE ? FROM AuthzRoles WHERE principalId = ?',
                'parameters': [resourceUuid, principalUuid]
            });
        } else {
            errors.push({'code': 400, 'msg': 'An invalid role has been passed in (undefined)'});
        }

        // invalidate this principal on this resource.
        principalsToInvalidate[principalUuid] = true;
        if (AuthzUtil.isGroupPrincipal(principalUuid)) {
            groupsToInvalidate[principalUuid] = true;
        }
    });

    if (errors.length > 0) {
        return callback(errors[0]);
    }

    _getAllGroupMemberDescendants(_.keys(groupsToInvalidate), function(err, memberUuids) {
        if (err) {
            return callback(err);
        }

        memberUuids.forEach(function(memberUuid) {
            principalsToInvalidate[memberUuid] = true;
        });

        // apply the changes
        Cassandra.runBatchQuery(queries, function(err) {
            var errors = [];
            if (err) {
                errors.push(err);
            }

            // invalidate regardless of the result of the batch query. If it partially applied, we still don't want stale cache entries
            _cacheInvalidateResourceForPrincipals(_.keys(principalsToInvalidate), resourceUuid, function(err) {
                if (err) {
                    errors.push(err);
                }

                if (errors.length === 0) {
                    return callback();    
                } else {
                    return callback({ code: 500, msg: errors });
                }
                
            });
        });
    });
}



//////////////////////
// GROUP MEMBERSHIP //
//////////////////////

/**
 * Add the given principal to a group with the specified role.
 *
 * @param {String}          groupUuid       The group to which to add the principal
 * @param {String}          principalUuid   The principal to add to the group
 * @param {String}          role            The role to assign the user in the group
 * @param {Function(err)}   callback        Standard callback, invoked when the process completes
 * @param {Object}          callback.err    An error that occurred, if any
 */
var addGroupMember = module.exports.addGroupMember = function(groupUuid, principalUuid, role, callback) {
    var validator = new Validator();
    validator.check(groupUuid, {code: 400, msg: 'Invalid group UUID provided.'}).isGroupPrincipal();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided.'}).isPrincipal();
    validator.check(role, {code: 400, msg: 'Invalid role provided.'}).isValidRole();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var changes = {};
    changes[principalUuid] = role;
    _applyGroupMembershipChanges(groupUuid, changes, callback);
}

/**
 * Remove the given principal from a group.
 *
 * @param {String}          groupUuid       The group from which to remove the principal
 * @param {String}          principalUuid   The principal to remove from the group
 * @param {Function(err)}   callback        Standard callback, invoked when the process completes
 * @param {Object}          callback.err    An error that occurred, if any
 */
var removeGroupMember = module.exports.removeGroupMember = function(groupUuid, principalUuid, callback) {
    var validator = new Validator();
    validator.check(groupUuid, {code: 400, msg: 'Invalid group UUID provided.'}).isGroupPrincipal();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided.'}).isPrincipal();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var changes = {};
    changes[principalUuid] = false;
    _applyGroupMembershipChanges(groupUuid, changes, callback);
}

/**
 * Apply a bulk set of group memberships changes, as specified by the 'changes' parameter. The changes should
 * be a JSON Object keyed by the principal UUID, with value being the role to assign in the group. If the value
 * is 'false', then the principal should be removed from the group.
 * 
 * @param {String}          groupUuid       The group to which the changes should be applied
 * @param {Object}          changes         A JSON Object representing the changes to be applied. See method summary for more information.
 * @param {Function(err)}   callback        Standard callback, invoked when the process completes
 * @param {Object}          callback.err    An error that occurred, if any
 */
var applyGroupMembershipChanges = module.exports.applyGroupMembershipChanges = function(groupUuid, changes, callback) {
    var validator = new Validator();
    validator.check(groupUuid, {code: 400, msg: 'Invalid group UUID provided.'}).isGroupPrincipal();
    _.keys(changes).forEach(function(memberUuid) {
        validator.check(memberUuid, {code: 400, msg: 'Invalid principal UUID provided: '+memberUuid}).isPrincipal();
        validator.check(changes[memberUuid], {code: 400, msg: 'Invalid role provided.'}).isValidRoleChange();
    });
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _applyGroupMembershipChanges(groupUuid, changes, callback);
}

/**
 * Get all the members of a group.
 *
 * @param  {String}                 groupUuid               An unique identifier for a group. ex: g:cam-oae-team
 * @param  {String}                 start                   The principal_id that comes just before the first principal you wish to have in your results.
 * @param  {Number}                 limit                   The number of members you wish to retrieve.
 * @param  {Function(err, members)} callback                Standard callback method that has an array of the direct members of a group.
 * @param  {Object}                 callback.err            An error that occurred, if any
 * @param  {Array<String>}          callback.members        The principal UUIDs for all members of the group
 */
var getGroupMembers = module.exports.getGroupMembers = function(groupUuid, start, limit, callback) {
    limit = limit || 100;
    callback = callback || function(err, members) {};

    var validator = new Validator();
    validator.check(groupUuid, {code: 400, msg: 'Invalid group UUID provided'}).isGroupPrincipal();
    validator.check(limit, {code: 400, msg: 'The limit parameter needs to be a number'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Page the query.
    var paging = Cassandra.getPagingParameters(start, limit);
    Cassandra.runQuery("SELECT FIRST " + paging.limit + " ?..\'\' FROM AuthzGroupMembers WHERE groupId = ?", [paging.start, groupUuid], function (err, rows) {
        if (err) {
            return callback({'code': 500, 'msg': err});
        }

        var members = [];
        var row = rows[0];
        for (var i = paging.startIndex, j = row.count; i < j; i++) {
            var name = row[i].name;
            if (name !== "groupId") {
                members.push(name);
            }
        }

        return callback(false, members);
    });
};

/**
 * Gets all the groups of which a principal (either user or group) is a member. This includes all group ancestors to which the user is indirectly
 * a member.
 *
 * @param {String}                  principalUuid           The principal for which to retrieve all the groups
 * @param {Function(err, groups)}   callback                Standard callback method invoked when the process completes
 * @param {Object}                  callback.err            An error that occured, if any
 * @Param {Array<String>}           callback.groups         An (inconsistently ordered) array of groups to which the user belongs, either directly or indirectly
 */
var getMemberOf = module.exports.getMemberOf = function(principalUuid, callback) {
    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided'}).isPrincipal();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getGroupMembershipAncestry(principalUuid, function(err, groups) {
        if (!err) {
            return callback(null, _.keys(groups));
        } else {
            return callback(err);
        }
    });
};

/**
 * Determines whether or not the principal (either user or group) is a member (either directly or indirectly) of the specified group.
 *
 * @param {String}                      principalUuid               The principal to check
 * @param {String}                      groupUuid                   The group to check
 * @param {Function(err, isMemberOf)}   callback                    Standard callback function, invoked when the process completes
 * @param {Object}                      callback.err                An error that occurred, if any
 * @param {Boolean}                     callback.isMemberOf         Specifies whether or not the principal is a member of the specified group
 */
var isMemberOf = module.exports.isMemberOf = function(principalUuid, groupUuid, callback) {
    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided'}).isPrincipal();
    validator.check(groupUuid, {code: 400, msg: 'Invalid group UUID provided'}).isGroupPrincipal();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    isAllowedAny(principalUuid, groupUuid, callback);
}

/**
 * Given an array of groups, recursively get all of its children and grandchildren members.
 *
 * @param {Array<String>}               groupUuids          An array of the UUIDs of the groups to search
 * @param {Function(err, memberUuids)}  callback            Standard callback to be invoked when the process completes
 * @param {Object}                      callback.err        An error that occurred, if any
 * @param {Array<String>}               callback.memberuids All children and grandchildren group members of the provided group
 */
var _getAllGroupMemberDescendants = function(groupUuids, callback) {
    var result = {};

    var _multiGetAllGroupMemberDescendants = function(groupUuids) {
        _getGroupMembersForGroups(groupUuids, function(err, memberUuids) {
            if (err) {
                return callback(err);
            }

            var nextGroupUuidBatch = [];
            memberUuids.forEach(function(memberUuid) {
                if (!result[memberUuid] && AuthzUtil.isGroupPrincipal(memberUuid)) {
                    // first time seeing this member, we need to recurse if it is a group
                    nextGroupUuidBatch.push(memberUuid);
                }
                result[memberUuid] = true;
            });

            // if we have more groups to recurse, do it
            if (nextGroupUuidBatch.length > 0) {
                return _multiGetAllGroupMemberDescendants(nextGroupUuidBatch);
            } else {
                // nothing left to do, we're done
                return callback(null, _.keys(result));
            }
        });
    }

    _multiGetAllGroupMemberDescendants(groupUuids.slice(0));
}

/**
 * Apply a series of group membership changes. Note this internal function does no validation on the data. Please do
 * validation prior to send batches of changes to this method.
 * 
 * @param {String}                  groupUuid       The UUID of the group to which the members should be added
 * @param {Array<Object>}           changes         A JSON object keyed by a principalUuid, with value either the role to apply, or 'false' to indicate removal from the group.
 * @param {String}                  role            The role to assign to all the members
 * @param {Function(err, added)}    callback        The Function called when the process is finished
 * @param {Object}                  callback.err    An error that occurred, if any
 */
var _applyGroupMembershipChanges = function(groupUuid, changes, callback) {
    var queries = [];

    // variables for cache invalidation.
    //  1.  If a user is removed from a group, their permissions cache must be completely invalidated.
    //  2.  If a group is removed from a group, its permissions cache and all it's grandchild members' permission caches must be completely
    //      invalidated.
    //  3.  If a user's role is set/updated in a group, any existing cache entry for their role on that group resource must be invalidated
    //  4.  If a group's role is set/updated in a group, its cache entry for the parent group must be invalidated, as well as that of all
    //      of the group member descendants.
    var groupsToInvalidate = {};
    var principalsToInvalidate = {};
    var groupsToInvalidateForResource = {};
    var principalsToInvalidateForResource = {};

    _.keys(changes).forEach(function(memberUuid) {
        var role = changes[memberUuid];

        if (role === false) {

            // first, delete from AuthzGroupMembers
            queries.push({
                query: 'DELETE ? FROM AuthzGroupMembers WHERE groupId = ?',
                parameters: [memberUuid, groupUuid]
            });

            // second, delete from the AuthzRoles 
            queries.push({
                query: 'DELETE ? FROM AuthzRoles WHERE principalId = ?',
                parameters: [groupUuid, memberUuid]
            });

            principalsToInvalidate[memberUuid] = true;
            if (AuthzUtil.isGroupPrincipal(memberUuid)) {
                groupsToInvalidate[memberUuid] = true;
            }

        } else if (role) {
            // We could fill up some cache entries as a result of this, but is it worth it?

            // first, add to AuthzGroupMembers
            queries.push({
                query: 'UPDATE AuthzGroupMembers SET ? = ? WHERE groupId = ?',
                parameters: [memberUuid, role, groupUuid]
            });

            // second, add to roles
            queries.push({
                query: 'UPDATE AuthzRoles SET ? = ? WHERE principalId = ?',
                parameters: [groupUuid, role, memberUuid]
            });

            principalsToInvalidateForResource[memberUuid] = true;
            if (AuthzUtil.isGroupPrincipal(memberUuid)) {
                groupsToInvalidateForResource[memberUuid] = true;
            }
        }
    });

    // now that we've analyzed the operations in the batch, we need to aggregate a bunch of invalidations to group member descendants
    _getAllGroupMemberDescendants(_.keys(groupsToInvalidate), function(err, descendantUuids) {
        if (err) {
            return callback(err);
        }

        // aggregate cache invalidations for each descendant
        descendantUuids.forEach(function(descendantUuid) {
            principalsToInvalidate[descendantUuid] = true; 
        });

        _getAllGroupMemberDescendants(_.keys(groupsToInvalidateForResource), function(err, descendantUuids) {
            // aggregate group resource cache invalidations for each descendant
            descendantUuids.forEach(function(descendantUuid) {
                principalsToInvalidateForResource[descendantUuid] = true; 
            });

            // apply the changes
            Cassandra.runBatchQuery(queries, function(err) {
                var errors = [];
                if (err) {
                    errors.push(err);
                }

                // invalidate regardless of the result of the batch query. If it partially applied, we still don't want stale cache entries
                _cacheInvalidateForPrincipals(_.keys(principalsToInvalidate), function(err) {
                    if (err) {
                        errors.push(err);
                    }
                    _cacheInvalidateResourceForPrincipals(_.keys(principalsToInvalidateForResource), groupUuid, function(err) {
                        if (err) {
                            errors.push(err);
                        }

                        if (errors.length === 0) {
                            return callback();
                        } else {
                            return callback({ code: 500, msg: errors });
                        }
                    });
                });
            });
        });
    });
}

/**
 * Given some principal, get their entire group membership ancestry. In other words, get all the groups to which they belong,
 * and the groups to all those groups belong, and so on.
 *
 * @param {String}                  principalUuid       The UUID of the principal
 * @param {Function(err, ancestry)} callback            A callback function specifying the entire group ancestry of the given principal
 * @param {Object}                  callback.err        The err that occured, if any
 * @param {Object}                  callback.ancestry   A hash keyed by the group UUID of each group of which the user is indirectly a member. The value of each entry is 'true'.
 */
var _getGroupMembershipAncestry = function(principalUuid, callback) {
    var results = {};

    var _multiGetGroupMembershipAncestry = function(principalUuids) {
        getRolesForPrincipalsAndResourceType(principalUuids, AuthzConstants.resourceTypes.GROUP, 10000, function(err, entries) {
            var nextPrincipalBatch = [];
            if (!err) {
                var ancestors = Object.keys(entries);
                // for each group parent, determine if we've already recorded their membership. if not, we record it, and search it's parents
                for (var i = 0; i < ancestors.length; i++) {
                    var ancestorUuid = ancestors[i];
                    if (!results[ancestorUuid]) {
                        results[ancestorUuid] = true;
                        nextPrincipalBatch.push(ancestorUuid);
                    }
                }

                // if we found new ancestors, we need to recurse to find their ancestors. Otherwise we're done.
                if (nextPrincipalBatch.length > 0) {
                    return _multiGetGroupMembershipAncestry(nextPrincipalBatch, results);
                } else {
                    return callback(false, results);
                }
            } else {
                return callback(err);
            }
        });
    }

    _multiGetGroupMembershipAncestry([principalUuid]);
};

/**
 * Get all the group members for all groups in the given list of groupUuids.
 * 
 * @param {Array<String>}               groupUuids              An array of groupUuids that specify the groups to search
 * @param {Function(err, memberUuids)}  callback                Standard callback function, invoked when the process completes
 * @param {Object}                      callback.err            An error that occurred, if any
 * @param {Array<String>}               callback.memberUuids    An aggregated array of principal UUIDs that are members of the provided groups
 */
var _getGroupMembersForGroups = function(groupUuids, callback) {
    if (!groupUuids || groupUuids.length === 0) {
        return callback(null, []);
    }

    Cassandra.runQuery('SELECT * FROM AuthzGroupMembers WHERE groupId IN (?)', [groupUuids], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var memberUuids = {};
        rows.forEach(function(row) {
            row.forEach(function(name, value) {
                // weed out the key name
                if (name !== 'groupId') {
                    memberUuids[name] = true;
                }
            });
        });

        return callback(null, _.keys(memberUuids));
    });
}


/////////////////
// PERMISSIONS //
/////////////////

/**
 * Determine whether or not the principal specified by principalUuid can perform the action on the given resourceUuid
 * 
 * @param {String}                   principalUuid      The principal to check
 * @param {String}                   action             The action to check
 * @param {String}                   resourceUuid       The resource to check
 * @param {Function(err, isAllowed)} callback           A function specifying whether or not the user can perform the operation
 * @param {Object}                   callback.err       An error that occured, if any
 * @param {Boolean}                  callback.isAllowed Whether or not the principal can perform the operation on the resource
 */
var isAllowed = module.exports.isAllowed = function(principalUuid, action, resourceUuid, callback) {
    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided.'}).isPrincipal();
    validator.check(resourceUuid, {code: 400, msg: 'Invalid resource UUID provided.'}).isValidUuid();
    validator.check(action, {code: 400, msg: 'Invalid action provided.'}).isValidRole();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _isAllowed(principalUuid, action, resourceUuid, callback);
}

/**
 * Determine whether or not the principal specified by principalUuid can perform at least one action on the given resourceUuid
 *
 * @param {String}                   principalUuid      The principal to check
 * @param {String}                   resourceUuid       The resourceUuid to check
 * @param {Function(err, isAllowed)} callback           A function specifying whether or not the user can perform any operation
 * @param {Object}                   callback.err       An error that occured, if any
 * @param {Boolean}                  callback.isAllowed Whether or not the principal is authorized to perform any action on the resource
 */
var isAllowedAny = module.exports.isAllowedAny = function(principalUuid, resourceUuid, callback) {
    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided.'}).isPrincipal();
    validator.check(resourceUuid, {code: 400, msg: 'Invalid resource UUID provided.'}).isValidUuid();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _isAllowed(principalUuid, null, resourceUuid, callback);
}

/**
 * Determine whether or not one of the principals in the array of principalUuids is able to perform the action on the
 * resource specified. If the action is null, then we will determine if the user can perform *any* action on the
 * resource specified.
 *
 * @param {Array<String>}            principalUuids     The array of principals to check
 * @param {String}                   action             The action to check. If null, check for any action.
 * @param {String}                   resourceUuid       The resource to check
 * @param {Function(err, isAllowed)} callback           A function invoked when the process is complete.
 * @param {Object}                   callback.err       An error that occured, if any
 * @param {Boolean}                  callback.isAllowed Whether or not one of the principals is authorized to perform the action
 */
var _isAllowed = function(principalUuid, action, resourceUuid, callback) {

    // first do a single cache check on the root principal.
    _cacheGetPermissionCheck([principalUuid], action, resourceUuid, function(err, result) {
        if (!err && result === true) {
            return callback(null, true);
        }

        if (action === null) {
            // check to see if the principal has *any* permission on the resource
            _getRole(principalUuid, resourceUuid, function(err, role) {
                if (err) {
                    return callback(err);
                }

                if (role) {
                    // they do, cache it and call back
                    _cacheSetPermissionCheck(principalUuid, resourceUuid, role);
                    return callback(null, true);
                }

                // they don't, delegate to ancestry
                return _ancestryIsAllowed();
            });
        } else {
            // check to see if the principal has the specified permission on the resource
            _hasRole(principalUuid, resourceUuid, action, function(err, hasRole) {
                if (err) {
                    return callback(err);
                }

                if (hasRole) {
                    // they do, cache it and call back
                    _cacheSetPermissionCheck(principalUuid, resourceUuid, action);
                    return callback(null, true);
                }

                // they don't, delegate to ancestry
                return _ancestryIsAllowed();
            });
        }

    });

    /**
     * Check the entire group membership ancestry of the principal in context to determine if any has
     * the request access. If a positive check is found, the callback will be executed appropriately.
     */
    var _ancestryIsAllowed = function() {
        getMemberOf(principalUuid, function(err, principalUuids) {
            if (err) {
                return callback(err);
            }

            // short circuit if there is no ancestry
            if (principalUuids.length === 0) {
                return callback(null, false);
            }

            _cacheGetPermissionCheck(principalUuids, action, resourceUuid, function(err, result) {
                // if the cache check was successful and positive, we can return that result
                // if the cache check rendered an error, don't thwart the processing of the actual request
                if (!err && result === true) {
                    return callback(null, true);
                }

                // variables for monitoring the progress of permissions checks
                var index = 0;
                var isAllowedResult = false;
                var errResult = false;

                // this function monitors the progress of asynchronous permissions checks, calling back to the caller when appropriate
                var checkStatus = function(err, isAllowed) {
                    if (errResult || isAllowedResult) {
                        // do nothing, because we've already finished executing and called the callback
                    } else if (err) {
                        // we got an error while executing, call back with the error
                        errResult = err;
                        return callback(errResult);
                    } else if (isAllowed) {
                        // one of the principals is allowed to perform the action, short circuit
                        isAllowedResult = isAllowed;

                        // if 'action' was null, 'isAllowed' will actually be the role name that was detected
                        // if 'action' was not null, then 'isAllowed' is just a boolean, and 'role' is the role name
                        var roleToCache = (action === null) ? isAllowed : action;
                        // we can perform the cache update asynchronously
                        _cacheSetPermissionCheck(principalUuid, resourceUuid, roleToCache);

                        return callback(null, isAllowedResult);
                    } else {
                        index++;
                        if (index >= principalUuids.length) {
                            // we've reached the end of the check and none are allowed, return false
                            return callback(null, false);
                        }
                    }
                }

                // invoke the entire ancestry asynchronously. checkStatus will determine the result and when it is possible to call back.
                principalUuids.forEach(function(principalUuid) {
                    if (action !== null) {
                        hasRole(principalUuid, resourceUuid, action, checkStatus);
                    } else {
                        // we pass checkStatus directly here on the basis that the 'isAllowed' parameter is a duck-check and not strictly typed.
                        getRole(principalUuid, resourceUuid, checkStatus);
                    }
                });
            });
        });
    }
}


/////////////////////////
// PERMISSIONS CACHING //
/////////////////////////

/**
 * Define the representative meanings of the permissions cache values. Any value read from the cache that is not in this hash is interpreted
 * as "No value".
 */
var _CachePermissionsValue = {
    TRUE: '1'
}

/**
 * Search the permissions cache to determine if the given principals can perform the action on the specified resource.
 *
 * @param {Array<String>}           principalUuids  The principal for which to perform the permission check
 * @param {String}                  action          The permission action to verify. If null, it will check if there is *any* access rights cached
 *                                                  for the resource
 * @param {String}                  resourceUuid    The resource on which to verify the principal has access to perform the action
 * @param {Function(err, result)}   callback        Standard callback function, invoked when the process completes
 * @param {Object}                  callback.err    An error that occurred, if any
 * @param {Boolean}                 callback.result The result of the check. If true, it means that the user has the permission. If anything but
 *                                                  true (i.e., result !== true), then the cache does not have sufficient information to check that
 *                                                  the principal can perform the action. In this case, you must perform a full permission check to
 *                                                  determine the actual result.
 */
var _cacheGetPermissionCheck = function(principalUuids, action, resourceUuid, callback) {
    if (!principalUuids || principalUuids.length === 0) {
        return callback(null, null);
    }

    var permissionCheckKey = resourceUuid+':'+action;

    if (action !== null) {
        Cassandra.runQuery('SELECT ? FROM AuthzPermissionCache WHERE principalId IN (?)', [permissionCheckKey, principalUuids], function(err, rows) {
            if (err) {
                return callback(err);
            }

            for (var i = 0, j = rows.length; i < j; i++) {
                var col = rows[i][0];
                if (col && col.name === permissionCheckKey) {
                    return callback(null, col.value === _CachePermissionsValue.TRUE);
                }
            }

            // if we got here, we have no positive match
            return callback(null, null);
        });
    } else {
        // if action is null, then we're checking if any of the principals have *any* access on the resource
        var start = resourceUuid + ':';
        var end = start + '|';
        Cassandra.runQuery('SELECT ? .. ? FROM AuthzPermissionCache WHERE principalId IN (?)', [start, end, principalUuids], function(err, rows) {
            if (err) {
                return callback(err);
            }

            var numRows = rows.length;
            for (var i = 0; i < numRows; i++) {
                var row = rows[i];
                var numCols = row.count;
                for (var j = 0; j < numCols; j++) {
                    var col = row[j];
                    if (col.value === _CachePermissionsValue.TRUE) {
                        return callback(null, true);
                    }
                }
            }

            // if we got here, we have no positive match
            return callback(null, null);
        });
    }
}

/**
 * Invalidate (i.e., delete) all cache records for the given principals.
 *
 * @param {Array<String>}   principalUuids  The UUIDs of the principals to invalidate
 * @param {Function(err)}   callback        Standard callback function, invoked when the process completes
 * @param {Object}          callback.err    An error that occurred, if any
 */
var _cacheInvalidateForPrincipals = function(principalUuids, callback) {
    if (!principalUuids || principalUuids.length === 0) {
        return callback();
    }
    Cassandra.runQuery('DELETE FROM AuthzPermissionCache WHERE principalId IN (?)', [principalUuids], callback);
}

/**
 * Invalidate (i.e., delete) all cache records for the given principals on the specified resource.
 *
 * @param {Array<String>}   principalUuids  The UUIDs of the principals to invalidate
 * @param {String}          resourceUuid    The UUID of the resource to invalidate
 * @param {Function(err)}   callback        Standard callback function, invoked when the process completes
 * @param {Object}          callback.err    An error that occurred, if any
 */
var _cacheInvalidateResourceForPrincipals = function(principalUuids, resourceUuid, callback) {
    if (!principalUuids || principalUuids.length === 0) {
        return callback();
    }

    var queries = [];
    var start = resourceUuid+':';
    var end = start + '|';

    // determine all the resource-role keys that will need to be deleted from the principals.
    // in practice the number should be small, 1 to 4 total or something (e.g., one for 'manager', one for 'viewer')
    Cassandra.runQuery('SELECT ?..? FROM AuthzPermissionCache WHERE principalId IN (?)', [start, end, principalUuids], function(err, rows) {
        if (err) {
            return callback(err);
        }

        // aggregate all known resource role keys (e.g., 'c:cam:Foo.docx:manager')
        var resourceActionKeys = {};
        rows.forEach(function(row) {
            row.forEach(function(name) {
                resourceActionKeys[name] = true;
            });
        });

        // build and execute the delete query
        var params = [];
        var placeholders = [];
        _.keys(resourceActionKeys).forEach(function(resourceActionKey) {
            placeholders.push('?');
            params.push(resourceActionKey);
        });
        params.push(principalUuids);

        if (placeholders.length > 0) {
            Cassandra.runQuery('DELETE ' + placeholders.join(',') + ' FROM AuthzPermissionCache WHERE principalId IN (?)', params, callback);
        } else {
            // no one had any cached permissions on the resource.
            return callback();
        }
    });
}

/**
 * Set the value of a permission check for a given principal on a resource. After this has been performed, subsequent checks to the cache for this principal, resource, and
 * action will be true. If the cache is invalidated for the principal on the resource, or for the principal entirely, this cache entry will be deleted.
 *
 * @param {Array<String>}   principalUuids  The principal whose permission to set
 * @param {String}          resourceUuid    The the resource on which to set the permission
 * @param {String}          action          The permission to set
 * @param {Function(err)}   callback        Standard callback function, invoked when the process completes
 * @param {Object}          callback.err    An error that occurred, if any
 */
var _cacheSetPermissionCheck = function(principalUuid, resourceUuid, action, callback) {
    callback = callback || function() {};
    var resourceActionKey = resourceUuid + ':' + action;
    Cassandra.runQuery('UPDATE AuthzPermissionCache SET ? = ? WHERE principalId = ?', [resourceActionKey, _CachePermissionsValue.TRUE,
        principalUuid], callback);
}
