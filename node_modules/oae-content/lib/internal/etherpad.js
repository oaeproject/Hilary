/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var Etherpad = require('etherpad-lite-client');
var Url = require('url');

var log = require('oae-logger').logger('etherpad');
var Signature = require('oae-util/lib/signature');
var Validator = require('oae-util/lib/validator').Validator;

var etherpadServers = [];
var etherpadConfig = null;

/**
 * Refresh the runtime etherpad configuration (host list, api key, etc...) with the one provided. More
 * documentation about the etherpad configuration may be found in the `config.etherpad` key of the
 * default config.js file.
 *
 * @param  {Object}   etherpadConfig    The etherpad config from config.js
 */
var refreshConfiguration = module.exports.refreshConfiguration = function(_etherpadConfig) {
    // Remember this config.
    etherpadConfig = _etherpadConfig;

    // Rebuild the servers list and recreate from the configuration
    etherpadServers = [];
    _.each(etherpadConfig.hosts, function(host, index) {
        // Create the etherpad client with its sharding index
        var etherpad = {
            'index': index,
            'client': Etherpad.connect({
                'apikey': _etherpadConfig.apikey,
                'host': host.host,
                'port': host.port
            })
        };
        etherpadServers.push(etherpad);
    });
};

/**
 * Get the etherpad configuration.
 *
 * @return {Object} The etherpad configuration.
 */
var getConfig = module.exports.getConfig = function() {
    return etherpadConfig;
};

/**
 * Creates a pad via the etherpad API.
 *
 * @param  {String}     contentId                       The ID of the collaborative document for which an etherpad pad should be created.
 * @param  {Function}   callback                        Standard callback method.
 * @param  {Object}     callback.err                    Standard error object (if any).
 * @param  {Object}     callback.ids                    An object containing the etherpad IDs for this collaborative document.
 * @param  {String}     callback.ids.etherpadGroupId    The etherpad identifier for the group that was created.
 * @param  {String}     callback.ids.etherpadPadId      The etherpad identifier for the pad that was created.
 */
var createPad = module.exports.createPad = function(contentId, callback) {
    // Because etherpad has a slightly weird system of authenticating users
    // we need to create a group *PER* content item and then create a group pad in this group.

    // Get the client that points to the correct etherpad instance.
    var client = getClient(contentId);

    // Create the group.
    var args = {
        'groupMapper': contentId
    };
    log().trace({'contentId': contentId}, 'Creating etherpad group.');
    client.createGroupIfNotExistsFor(args, function(err, groupData) {
        if (err) {
            log().error({'err': err, 'contentId': contentId}, 'Could not create an etherpad group.');
            return callback({'code': 500, 'msg': err.message});
        }

        // Create the group pad.
        var groupPad = {
            'groupID': groupData.groupID,
            'padName': contentId
        };
        log().trace({'contentId': contentId, 'groupID': groupData.groupID}, 'Creating etherpad group pad.');
        client.createGroupPad(groupPad, function(err, padData) {
            if (err) {
                log().error({'err': err, 'contentId': contentId}, 'Could not create an etherpad group pad.');
                return callback({'code': 500, 'msg': err.message});
            }

            // Store these IDs in the database.
            var ids = {
                'etherpadGroupId': groupData.groupID,
                'etherpadPadId': padData.padID
            };
            log().info({'contentId': contentId, 'groupID': groupData.groupID, 'padID': padData.padID}, 'Created an etherpad group and pad.');
            callback(null, ids);
        });
    });
};

/**
 * Get the HTML for a pad.
 *
 * @param  {String}     contentId       The content id for which the HTML should be retrieved from etherpad.
 * @param  {String}     padId           The ID of the pad for which to retrieve the HTML.
 * @param  {Function}   callback        Standard callback method.
 * @param  {Object}     callback.err    Standard error object (if any.)
 * @param  {String}     callback.html   The HTML fragment for this pad.
 */
var getHTML = module.exports.getHTML = function(contentId, padId, callback) {
    log().trace({'contentId': contentId}, 'Getting etherpad HTML');
    getClient(contentId).getHTML({'padID': padId}, function(err, data) {
        if (err) {
            log().error({'err': err, 'padID': padId, 'contentId': contentId}, 'Could not grab the HTML from etherpad.');
            return callback({'code': 500, 'msg': 'Could not grab the HTML from etherpad.'});
        }

        callback(null, data.html);
    });
};

/**
 * Set the html for a pad.
 *
 * @param  {String}     contentId       The content id for which the HTML should be set in etherpad.
 * @param  {String}     padId           The ID of the pad for which to set the HTML.
 * @param  {String}     html            The HTML fragment to store in etherpad.
 * @param  {Function}   callback        Standard callback method.
 * @param  {Object}     callback.err    Standard error object (if any.)
 */
var setHTML = module.exports.setHTML = function(contentId, padId, html, callback) {
    log().trace({'contentId': contentId, 'html': html}, 'Setting etherpad html');

    // Although Etherpad exposes an API to set the HTML of a pad, it doesn't accept any HTML fragments.
    // We encapsulate the HTML fragment into a simple page and submit that instead.
    var toSend = '<!doctype html><html lang="en"><head><title></title><meta charset="utf-8"></head><body>' + html + '</body></html>';
    getClient(contentId).setHTML({'padID': padId, 'html': toSend}, function(err, data) {
        if (err) {
            log().error({'err': err, 'padID': padId, 'contentId': contentId, 'html': html}, 'Could not set the html on the etherpad instance.');
            return callback({'code': 500, 'msg': 'Could not set the html on the etherpad instance.'});
        }

        callback(null);
    });
};

/**
 * Joins the current user in an etherpad.
 * This assumes that the current user has access to the collaborative document.
 *
 * @param  {Context}    ctx             The current context
 * @param  {String}     contentId       The content id of the apd that should be joined..
 * @param  {String}     padId           The ID of the pad that should be joined.
 * @param  {String}     groupId         The ID of the group that is associated to this pad.
 * @param  {Function}   callback        Standard callback method.
 * @param  {String}     callback.url    The public URL that the UI can use to embed the pad.
 */
var joinPad = module.exports.joinPad = function(ctx, contentId, padId, groupId, callback) {
    if (!ctx.user()) {
        return callback({'code': 401, 'msg': 'Anonymous users are not allowed to join collaborative documents.'});
    }

    // Get the etherpad client that will handle this contentId.
    var client = getClient(contentId);

    /*
     *   Joining a pad consists out of three things:
     *    1/ Mapping the OAE user to an etherpad author.
     *    2/ Creating a session for the etherpad author
     *    3/ Returning a url to the UI. It should contain
     *       * The server etherpad is running on (ex: http://7.etherpad.oae.com/)
     *       * The pad URI (ex: /oae/c_cam_abc123)
     *       * The session ID (ex: ?sessionID=s.32b01f91d0e2c9a344)
     */
    var args = {
        'authorMapper': ctx.user().id,
        'name': ctx.user().displayName
    };
    client.createAuthorIfNotExistsFor(args, function(err, author) {
        if (err) {
            log().error({'err': err, 'contentId': contentId, 'principalId': ctx.user().id}, 'Could not create an etherpad author.');
            return callback({'code': 500, 'msg': 'Could not create an author in the etherpad system.'});
        }

        var session = {
            'groupID': groupId,
            'authorID': author.authorID,
            'validUntil': Math.round(Date.now()/1000) + 60*60*24
        };
        log().trace(session, 'Creating a session');
        client.createSession(session, function(err, data) {
            if (err) {
                log().error({'err': err, 'contentId': contentId, 'principalId': ctx.user().id}, 'Could not create an etherpad session.');
                return callback({'code': 500, 'msg': 'Could not create an etherpad session for this user.'});
            }

            // Get the language for the current user.
            var language = 'en';
            var locale = ctx.user().locale;
            if (locale) {
                language = locale.split('_')[0];
            }

            // Construct the URL.
            var url = getPadUrl(contentId, padId, data.sessionID, language);
            return callback(null, {'url': url});
        });
    });
};

/**
 * Get the URL where users can view the etherpad pad.
 * This can be used to embed in the page via an iframe.
 * The URL will be of the form:
 *     /etherpad/0/oae/<pad ID>?sessionID=<session ID>&pathPrefix=/etherpad/0&language=en
 *
 * A couple of notes:
 *     *   The URL that will be embedded should be on the same domain as the current tenant.
 *         This is because Safari will not set cookies that are coming from another domain inside an iframe.
 *     *   We try to shard based on the content ID so that the load is spread across the etherpad cluster.
 *         Note that this is *NOT* sharding based on load, as some documents may be more popular than others.
 *     *   The `/etherpad/0` will have to be stripped off by nginx.
 *     *   We point to `/oae/<pad ID>` which is an endpoint exposed by the `ep_oae` plugin.
 *         That endpoint will take care of sending the session cookie.
 *     *   We need to send a pathPrefix so the `ep_oae` endpoint can construct the
 *         /etherpad/0/p/<pad ID> URL. Etherpad can take it from there.
 *
 * @param  {String}     contentId   The ID of the piece of content.
 * @param  {String}     padId       The ID of the pad in etherpad.
 * @param  {String}     sessionId   The ID of the session that should be included in the query string.
 * @param  {String}     language    The 2 character string that identifies the user's prefered language.
 * @return {String}                 The URL to the pad that can be used to embed in a page.
 */
var getPadUrl = module.exports.getPadUrl = function(contentId, padId, sessionId, language) {
    var serverIndex = _getServer(contentId).index;
    return Url.format({
        'pathname': '/etherpad/' + serverIndex + '/oae/' + padId,
        'query': {
            'sessionID': sessionId,
            'language': language,
            'pathPrefix': '/etherpad/' + serverIndex
        }
    });
};

/**
 * Get an etherpad client that can talk to an etherpad API.
 *
 * @param  {String}     contentId   The ID of the piece of content for which we need to retrieve an etherpad client.
 * @return {Client}                 The request etherpad client.
 */
var getClient = module.exports.getClient = function(contentId) {
    return _getServer(contentId).client;
};

/**
 * Get the server that is tied to a content ID.
 *
 * @param  {String}     contentId   The content ID for which the server should be retrieved.
 * @return {Object}                 The server tied to a collabration document.
 * @api private
 */
var _getServer = function(contentId) {
    var index = _hash(contentId, etherpadServers.length);
    return etherpadServers[index];
};

/**
 * Hashes a string and returns the index.
 *
 * @param  {String}     str     The string to hash.
 * @param  {String}     nr      The upper bound (exclusive) for the index.
 * @return {Number}             The index.
 * @api private
 */
var _hash = function(str, nr) {
    var code = 0;
    for (var i = 0; i < str.length; i++) {
        code += str.charCodeAt(i);
    }
    return code % nr;
};
