/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var _ = require('underscore');
var Cassandra = require('oae-util/lib/cassandra');
var Validator = require('oae-authz/lib/validator').Validator;
var AuthzUtil = require('oae-authz/lib/util');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;



///////////
// ROLES //
///////////

/**
 * Determine the role assigned to the principal directly on the specified resource instance.
 * 
 * @param {String} principalUuid the UUID of the principal
 * @param {String} The UUID of the resource
 * @param {Function(err, role)} callback A function specifying the role of the principal. If the principal
 * has no role or there is an error performing the check, role will be null
 **/
var getRole = module.exports.getRole = function(principalUuid, resourceUuid, callback) {

    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided.'}).isPrincipal();
    validator.check(resourceUuid, {code: 400, msg: 'Invalid resource UUID provided.'}).isValidUuid();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getRole(principalUuid, resourceUuid, callback);
}

/**
 * Determines whether or not the principal has the specified role directly on the given resource.
 * 
 * @param {String} principalUuid The UUID of the princpals
 * @param {String} resourceUuid The UUID of the resource
 * @param {String} role The role to check
 * @param {Function(err, hasRole)} callback A function specifying whether or not the user has the role on the resource
 */
var hasRole = module.exports.hasRole = function(principalUuid, resourceUuid, role, callback) {
    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided.'}).isPrincipal();
    validator.check(resourceUuid, {code: 400, msg: 'Invalid resource UUID provided.'}).isValidUuid();
    validator.check(role, {code: 400, msg: 'Invalid role provided.'}).isValidRole();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _hasRole(principalUuid, resourceUuid, role, callback);
}

/**
 * Given a resourceType (as determined by Resource.resourceType), return all {resource uuid} => {role} entries that are
 * associated to the principal. The structure of the entries result looks like the following:
 * 
 * [
 *   {
 *      "uuid": "<resource uuid 1>",
 *      "role": "<role 1>"
 *    },
 *    {
 *      "uuid": "<resource uuid 2>"
 *      "role": "<role 2>"
 *    }
 * ]
 * 
 * @param {String} principalUuid The UUID of the principal
 * @param {String} resourceType The resource type to search, as determined by Resource.resourceType
 * @param {String} start The starting entry on which to begin returning results (used for paging). **This is not a number**. If null, then the results will simply begin from the start. If the resource uuid is provided, then results will begin from that resource's location, exclusively.
 * @param {Number} limit The maximum number of entries to return (used for paging; default: 10)
 * @param {Function(err, entries)} callback A function, providing the list of role entries that match the search
 */
var getRolesForResourceType = module.exports.getRolesForResourceType = function(principalUuid, resourceType, start, limit, callback) {
    limit = limit || 10;

    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided.'}).isPrincipal();
    validator.check(limit, {code: 400, msg: '"limit" parameter must be a number when searching for active roles'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var firstColumnIndex = 0;
    var columnPrefix = resourceType+':';

    if (start === null) {
        start = columnPrefix;    
    } else {
        // increment the limit if the user specified the start point, because we skip the first entry to get the EXCLUSIVE
        // page range
        limit++;
        firstColumnIndex = 1;
    }

    var cql = 'SELECT FIRST ' + limit + ' ? .. \'\' FROM AuthzRoles WHERE principalId = ?';
    Cassandra.runQuery(cql, [start, principalUuid], function(err, rows) {
        if (!err) {
            var entries = [];

            for (var i = firstColumnIndex, j = rows[0].count; i < j; i++) {
                var col = rows[0][i];
                // we need to stop when we've surpassed the last of the specified resource type
                if (col.name.indexOf(columnPrefix) !== 0) {
                    break;
                }
                entries.push({ 'uuid': col.name, 'role': col.value });
            }
            callback(null, entries);
        } else {
            callback({code: 500, msg: err});
        }
    });
}


/**
 * Assign the given principal a role on a resource instance. If the user already has a role, it will simply be updated.
 * 
 * @param {String} principalUuid The UUID of the principal
 * @param {String} resourceUuid the UUID of the resource
 * @param {String} role The role to assign to the principal
 * @param {Function(err)} callback A function specifying whether or not the operation was successful
 */
var setRole = module.exports.setRole = function(principalUuid, resourceUuid, role, callback) {

    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided.'}).isPrincipal();
    validator.check(resourceUuid, {code: 400, msg: 'Invalid resource UUID provided.'}).isValidUuid();
    validator.check(resourceUuid, {code: 400, msg: 'Cannot assign a role for a principal on a group resource.'}).isNotGroupResource();
    validator.check(role, {code: 400, msg: 'Invalid role provided.'}).isValidRole();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _setRole(principalUuid, resourceUuid, role, callback);
}

/**
 * Remove the role assignment of the given principal on an resource instance. If the user did not have a role, this will
 * have no effect.
 * 
 * @param {String} principalUuid The UUID of the principal
 * @param {String} resourceUuid The UUID of the resource
 * @param {Function(err)} callback A function specifying whether or not the operation was successful
 */
var removeRole = module.exports.removeRole = function(principalUuid, resourceUuid, callback) {

    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided.'}).isPrincipal();
    validator.check(resourceUuid, {code: 400, msg: 'Invalid resource UUID provided.'}).isValidUuid();
    validator.check(resourceUuid, {code: 400, msg: 'Cannot assign a role for a principal on a group resource.'}).isNotGroupResource();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _removeRole(principalUuid, resourceUuid, callback);
}

/**
 * Assign multiple principals a role on a resource instance. If the user already has a role, it will simply be updated. When
 * false is passed in as a role, the role for that principal will be removed.
 *
 * @param {String}          resourceUuid    the UUID of the resource
 * @param {Object}          changes         JSON object where the keys are principal ids and the values are role values
 * @param {Function(err)}   callback        Standard callback function
 * @param {Object}          callback.err    Error object, containing the error message
 */
var applyRoleChanges = module.exports.applyRoleChanges = function(resourceUuid, changes, callback) {

    var validator = new Validator();
    validator.check(resourceUuid, {code: 400, msg: 'Invalid resource UUID provided.'}).isValidUuid();
    validator.check(resourceUuid, {code: 400, msg: 'Cannot assign a role for a principal on a group resource.'}).isNotGroupResource();
    _.keys(changes).forEach(function(principalUuid) {
        validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID specified: '+principalUuid}).isValidUuid();
        validator.check(changes[principalUuid], {code: 400, msg: 'Invalid role provided.'}).isValidRoleChange();

    });
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _applyRoleChanges(resourceUuid, changes, callback);
};

/**
 * Get all principal roles associated to the resourceType for all the principals in the array of principalUuids. This is similar
 * to getRolesForResourceType, except it can be performed on multiple principals at once.
 * 
 * The structure of the resulting entries is structured a hash, indicating all resourceUuids that were returned and what the
 * roles associated to those resources were. For example:
 *
 * {
 *      'u:cam:simong': { 'member': true },
 *      'g:cam:group-b': { 'member': true }
 * }
 *
 * or:
 *
 * {
 *      'c:gat:Foo.docx': { 'viewer': true, 'manager': true},
 *      'c:cam:Bar.pdf':  { 'viewer': true }
 * }
 *
 * In the latter case, 'c:gat:Foo.docx' has both 'viewer' and 'manager' role associated to it. This indicates that some principal
 * had a role of 'viewer' on the resource, while some other principal had the 'manager' role.
 *
 * @param {Array}                       principalUuids      The array of principalUuds to query for
 * @param {String}                      resourceType        The resource type of the resources to search for, as determined by Resource.resourceType
 * @param {Number}                      limit               The maximum number of resources to return per user
 * @param {Function(err, entries)}      callback            A function providing all the {resource uuid} -> {roles} mappings aggregated
 *                                                          for all the provided principals queried
 * @param {Object}                      callback.err        An error that occurred, if any
 * @param {Object}                      callback.entries    A JSON Object representing the roles associated to the users
 *
 * @see getRolesForResourceType
 */
var getRolesForPrincipalsAndResourceType = module.exports.getRolesForPrincipalsAndResourceType = function(principalUuids, resourceType, limit, callback) {
    limit = limit || 1000;

    var validator = new Validator();
    validator.check(limit, {code: 400, msg: '"limit" parameter must be a number when searching for active roles'});
    principalUuids.forEach(function(principalUuid) {
        validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID specified: '+principalUuid}).isPrincipal();
    });
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // we append a '|' to the "end" range, as | has a high ASCII alphabetical ordering. This may not suffice if resourceIds have
    // multi-byte characters, which is technically possible. Unfortunately, I don't think there is a better way to do this with
    // CQL.
    var columnPrefix = resourceType+':';
    var start = columnPrefix;
    var end = start+'|';

    var cql = 'SELECT FIRST ' + limit + ' ? .. ? FROM AuthzRoles WHERE principalId IN (?)';
    Cassandra.runQuery(cql, [start, end, principalUuids], function(err, rows) {
        if (!err) {
            var entries = {};

            // aggregate all resources from all the rows (principals) into the entries hash
            rows.forEach(function(row) {
                row.forEach(function(name, value) {
                    if (!entries[name]) {
                        entries[name] = {};
                    }
                    entries[name][value] = true;
                });
            });
            
            callback(null, entries);
        } else {
            callback(err);
        }
    });
};


/**
 * Determine the role assigned to the principal directly on the specified resource instance.
 * 
 * @param {String} principalUuid the UUID of the principal
 * @param {String} The UUID of the resource
 * @param {Function(err, role)} callback A function specifying the role of the principal. If the principal
 * has no role or there is an error performing the check, role will be null
 **/
var _getRole = function(principalUuid, resourceUuid, callback) {
    Cassandra.runQuery('SELECT ? FROM AuthzRoles WHERE principalId = ?', [resourceUuid, principalUuid], function(err, rows) {
        if (!err) {
            var col = rows[0].get(resourceUuid);
            if (col) {
                callback(null, col.value);
            } else {
                callback(null, null);
            }
        } else {
            callback(err);
        }
    });
}

/**
 * Determines whether or not the principal has the specified role directly on the given resource.
 * 
 * @param {String} principalUuid The UUID of the princpals
 * @param {String} resourceUuid The UUID of the resource
 * @param {String} role The role to check
 * @param {Function(err, hasRole)} callback A function specifying whether or not the user has the role on the resource
 */
var _hasRole = function(principalUuid, resourceUuid, role, callback) {
    _getRole(principalUuid, resourceUuid, function(err, actualRole) {
        if (!err) {
            callback(null, role === actualRole);
        } else {
            callback(err);
        }
    });
}


/**
 * Assign the given principal a role on a resource instance. If the user already has a role, it will simply be updated.
 * 
 * @param {String} principalUuid The UUID of the principal
 * @param {String} resourceUuid the UUID of the resource
 * @param {String} role The role to assign to the principal
 * @param {Function(err)} callback A function specifying whether or not the operation was successful
 */
var _setRole = function(principalUuid, resourceUuid, role, callback) {
    Cassandra.runQuery('UPDATE AuthzRoles SET ? = ? WHERE principalId = ?', [resourceUuid, role, principalUuid], callback);
}

/**
 * Assign multiple principals a role on a resource instance. If the user already has a role, it will simply be updated. When
 * false is passed in as a role, the role for that principal will be removed.
 *
 * @param {String}          resourceUuid    the UUID of the resource
 * @param {Object}          changes         JSON object where the keys are principal ids and the values are role values
 * @param {Function(err)}   callback        Standard callback function
 * @param {Object}          callback.err    Error object, containing the error message
 */
var _applyRoleChanges = function(resourceUuid, changes, callback) {
    var queries = [];
    _.keys(changes).forEach(function(principalUuid) {
        if (changes[principalUuid]) {
            queries.push({
                'query': 'UPDATE AuthzRoles SET ? = ? where principalId = ?',
                'parameters': [resourceUuid, changes[principalUuid], principalUuid]
            });
        } else if (changes[principalUuid] === false) {
            queries.push({
                'query': 'DELETE ? FROM AuthzRoles WHERE principalId = ?',
                'parameters': [resourceUuid, principalUuid]
            });
        } else {
            return callback({'code': 400, 'msg': 'An invalid role has been passed in (undefined)'});
        }
    });
    Cassandra.runBatchQuery(queries, callback);
}

/**
 * Remove the role assignment of the given principal on an resource instance. If the user did not have a role, this will
 * have no effect.
 * 
 * @param {String} principalUuid The UUID of the principal
 * @param {String} resourceUuid The UUID of the resource
 * @param {Function(err)} callback A function specifying whether or not the operation was successful
 */
var _removeRole = function(principalUuid, resourceUuid, callback) {
    Cassandra.runQuery('DELETE ? FROM AuthzRoles WHERE principalId = ?', [resourceUuid, principalUuid], callback);
}




//////////////////////
// GROUP MEMBERSHIP //
//////////////////////

/**
 * Add the given principal to a group with the specified role.
 *
 * @param {String}          groupUuid       The group to which to add the principal
 * @param {String}          principalUuid   The principal to add to the group
 * @param {String}          role            The role to assign the user in the group
 * @param {Function(err)}   callback        Standard callback, invoked when the process completes
 * @param {Object}          callback.err    An error that occurred, if any
 */
var addGroupMember = module.exports.addGroupMember = function(groupUuid, principalUuid, role, callback) {
    var validator = new Validator();
    validator.check(groupUuid, {code: 400, msg: 'Invalid group UUID provided.'}).isGroupPrincipal();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided.'}).isPrincipal();
    validator.check(role, {code: 400, msg: 'Invalid role provided.'}).isValidRole();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var changes = {};
    changes[principalUuid] = role;
    _applyGroupMembershipChanges(groupUuid, changes, callback);
}

/**
 * Remove the given principal from a group.
 *
 * @param {String}          groupUuid       The group from which to remove the principal
 * @param {String}          principalUuid   The principal to remove from the group
 * @param {Function(err)}   callback        Standard callback, invoked when the process completes
 * @param {Object}          callback.err    An error that occurred, if any
 */
var removeGroupMember = module.exports.removeGroupMember = function(groupUuid, principalUuid, callback) {
    var validator = new Validator();
    validator.check(groupUuid, {code: 400, msg: 'Invalid group UUID provided.'}).isGroupPrincipal();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided.'}).isPrincipal();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var changes = {};
    changes[principalUuid] = false;
    _applyGroupMembershipChanges(groupUuid, changes, callback);
}

/**
 * Apply a bulk set of group memberships changes, as specified by the 'changes' parameter. The changes should
 * be a JSON Object keyed by the principal UUID, with value being the role to assign in the group. If the value
 * is 'false', then the principal should be removed from the group.
 * 
 * @param {String}          groupUuid       The group to which the changes should be applied
 * @param {Object}          changes         A JSON Object representing the changes to be applied. See method summary for more information.
 * @param {Function(err)}   callback        Standard callback, invoked when the process completes
 * @param {Object}          callback.err    An error that occurred, if any
 */
var applyGroupMembershipChanges = module.exports.applyGroupMembershipChanges = function(groupUuid, changes, callback) {
    var validator = new Validator();
    validator.check(groupUuid, {code: 400, msg: 'Invalid group UUID provided.'}).isGroupPrincipal();
    _.keys(changes).forEach(function(memberUuid) {
        validator.check(memberUuid, {code: 400, msg: 'Invalid principal UUID provided: '+memberUuid}).isPrincipal();
        validator.check(changes[memberUuid], {code: 400, msg: 'Invalid role provided.'}).isValidRoleChange();
    });
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _applyGroupMembershipChanges(groupUuid, changes, callback);
}

/**
 * Get all the members of a group.
 *
 * @param  {String}                 groupUuid               An unique identifier for a group. ex: g:cam-oae-team
 * @param  {String}                 start                   The principal_id that comes just before the first principal you wish to have in your results.
 * @param  {Number}                 limit                   The number of members you wish to retrieve.
 * @param  {Function(err, members)} callback                Standard callback method that has an array of the direct members of a group.
 * @param  {Object}                 callback.err            An error that occurred, if any
 * @param  {Array<String>}          callback.members        The principal UUIDs for all members of the group
 */
var getGroupMembers = module.exports.getGroupMembers = function(groupUuid, start, limit, callback) {
    limit = limit || 100;
    callback = callback || function(err, members) {};

    var validator = new Validator();
    validator.check(groupUuid, {code: 400, msg: 'Invalid group UUID provided'}).isGroupPrincipal();
    validator.check(limit, {code: 400, msg: 'The limit parameter needs to be a number'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Page the query.
    var paging = Cassandra.getPagingParameters(start, limit);

    Cassandra.runQuery("SELECT FIRST " + paging.limit + " ?..\'\' FROM AuthzGroupMembers WHERE groupId = ?", [paging.start, groupUuid], function (err, rows) {
        if (err) {
            return callback({'code': 500, 'msg': err});
        }

        var members = [];
        var row = rows[0];
        for (var i = paging.startIndex, j = row.count; i < j; i++) {
            var name = row[i].name;
            if (name !== "groupId") {
                members.push(name);
            }
        }

        return callback(false, members);
    });
};

/**
 * Gets all the groups of which a principal (either user or group) is a member. This includes all group ancestors to which the user is indirectly
 * a member.
 *
 * @param {String}                  principalUuid           The principal for which to retrieve all the groups
 * @param {Function(err, groups)}   callback                Standard callback method invoked when the process completes
 * @param {Object}                  callback.err            An error that occured, if any
 * @Param {Array<String>}           callback.groups         An (inconsistently ordered) array of groups to which the user belongs, either directly or indirectly
 */
var getMemberOf = module.exports.getMemberOf = function(principalUuid, callback) {
    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided'}).isPrincipal();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getGroupMembershipAncestry(principalUuid, function(err, groups) {
        if (!err) {
            return callback(null, _.keys(groups));
        } else {
            return callback(err);
        }
    });
};

/**
 * Determines whether or not the principal (either user or group) is a member (either directly or indirectly) of the specified group.
 *
 * @param {String}                      principalUuid               The principal to check
 * @param {String}                      groupUuid                   The group to check
 * @param {Function(err, isMemberOf)}   callback                    Standard callback function, invoked when the process completes
 * @param {Object}                      callback.err                An error that occurred, if any
 * @param {Boolean}                     callback.isMemberOf         Specifies whether or not the principal is a member of the specified group
 */
var isMemberOf = module.exports.isMemberOf = function(principalUuid, groupUuid, callback) {
    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided'}).isPrincipal();
    validator.check(groupUuid, {code: 400, msg: 'Invalid group UUID provided'}).isGroupPrincipal();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    isAllowedAny(principalUuid, groupUuid, callback);
}

/**
 * Apply a series of group membership changes. Note this internal function does no validation on the data. Please do
 * validation prior to send batches of changes to this method.
 * 
 * @param {String}                  groupUuid       The UUID of the group to which the members should be added
 * @param {Array<Object>}           changes         A JSON object keyed by a principalUuid, with value either the role to apply, or 'false' to indicate removal from the group.
 * @param {String}                  role            The role to assign to all the members
 * @param {Function(err, added)}    callback        The Function called when the process is finished
 * @param {Object}                  callback.err    An error that occurred, if any
 * @param {Object}                  callback.added  A list of the memberUuids that were successfully added
 */
var _applyGroupMembershipChanges = function(groupUuid, changes, callback) {
    var queries = [];
    var memberUuids = _.keys(changes);

    memberUuids.forEach(function(memberUuid) {
        var role = changes[memberUuid];

        if (role === false) {

            // first, delete from AuthzGroupMembers
            queries.push({
                query: 'DELETE ? FROM AuthzGroupMembers WHERE groupId = ?',
                parameters: [memberUuid, groupUuid]
            });

            // second, delete from the AuthzRoles 
            queries.push({
                query: 'DELETE ? FROM AuthzRoles WHERE principalId = ?',
                parameters: [groupUuid, memberUuid]
            });

        } else if (role) {

            // first, add to AuthzGroupMembers
            queries.push({
                query: 'UPDATE AuthzGroupMembers SET ? = ? WHERE groupId = ?',
                parameters: [memberUuid, role, groupUuid]
            });

            // second, add to roles
            queries.push({
                query: 'UPDATE AuthzRoles SET ? = ? WHERE principalId = ?',
                parameters: [groupUuid, role, memberUuid]
            });

        }
    });

    Cassandra.runBatchQuery(queries, function(err) {
        if (!err) {
            callback(null, memberUuids);
        } else {
            callback(err);
        }
    });
}

/**
 * Given some principal, get their entire group membership ancestry. In other words, get all the groups to which they belong,
 * and the groups to all those groups belong, and so on.
 *
 * @param {String}                  principalUuid       The UUID of the principal
 * @param {Function(err, ancestry)} callback            A callback function specifying the entire group ancestry of the given principal
 * @param {Object}                  callback.err        The err that occured, if any
 * @param {Object}                  callback.ancestry   A hash keyed by the group UUID of each group of which the user is indirectly a member. The value of each entry is 'true'.
 */
var _getGroupMembershipAncestry = function(principalUuid, callback) {
    var results = {};

    var _multiGetGroupMembershipAncestry = function(principalUuids, results) {
        getRolesForPrincipalsAndResourceType(principalUuids, AuthzConstants.resourceTypes.GROUP, 10000, function(err, entries) {
            var nextPrincipalBatch = [];
            if (!err) {
                var ancestors = Object.keys(entries);
                // for each group parent, determine if we've already recorded their membership. if not, we record it, and search it's parents
                for (var i = 0; i < ancestors.length; i++) {
                    var ancestorUuid = ancestors[i];
                    if (!results[ancestorUuid]) {
                        results[ancestorUuid] = true;
                        nextPrincipalBatch.push(ancestorUuid);
                    }
                }

                // if we found new ancestors, we need to recurse to find their ancestors. Otherwise we're done.
                if (nextPrincipalBatch.length > 0) {
                    return _multiGetGroupMembershipAncestry(nextPrincipalBatch, results);
                } else {
                    return callback(false, results);
                }
            } else {
                return callback(err);
            }
        });
    }

    _multiGetGroupMembershipAncestry([principalUuid], results, callback);
};



/////////////////
// PERMISSIONS //
/////////////////

/**
 * Determine whether or not the principal specified by principalUuid can perform the action on the given resourceUuid
 * 
 * @param {String}                   principalUuid      The principal to check
 * @param {String}                   action             The action to check
 * @param {String}                   resourceUuid       The resource to check
 * @param {Function(err, isAllowed)} callback           A function specifying whether or not the user can perform the operation
 * @param {Object}                   callback.err       An error that occured, if any
 * @param {Boolean}                  callback.isAllowed Whether or not the principal can perform the operation on the resource
 */
var isAllowed = module.exports.isAllowed = function(principalUuid, action, resourceUuid, callback) {
    // first check this principal directly
    hasRole(principalUuid, resourceUuid, action, function(err, hasRole) {
        if (!err) {
            if (hasRole) {
                return callback(null, true);
            } else {
                // get the entire (indirect as well) group ancestry of the principal and check if they have the access

                // TODO: There is a potential optimization here to not aggressively get all ancestors, but rather check one level at a time
                // We can do the above optimization assuming we can short-circuit the checks when we get one positive check.
                getMemberOf(principalUuid, function(err, groupUuids) {
                    if (!err) {
                        return _isAllowed(groupUuids, action, resourceUuid, callback);
                    } else {
                        return callback(err);
                    }
                });
            }
        } else {
            return callback(err);
        }
    });
}

/**
 * Determine whether or not the principal specified by principalUuid can perform at least one action on the given resourceUuid
 *
 * @param {String}                   principalUuid      The principal to check
 * @param {String}                   resourceUuid       The resourceUuid to check
 * @param {Function(err, isAllowed)} callback           A function specifying whether or not the user can perform any operation
 * @param {Object}                   callback.err       An error that occured, if any
 * @param {Boolean}                  callback.isAllowed Whether or not the principal is authorized to perform any action on the resource
 */
var isAllowedAny = module.exports.isAllowedAny = function(principalUuid, resourceUuid, callback) {
    // first check the principal directly
    getRole(principalUuid, resourceUuid, function(err, role) {
        if (!err) {
            if (role) {
                // there was a role, short-circuit and indicate that the user has some role on the resource
                return callback(null, true);
            } else {
                getMemberOf(principalUuid, function(err, groupUuids) {
                    if (!err) {
                        return _isAllowed(groupUuids, null, resourceUuid, callback);
                    } else {
                        return callback(err);
                    }
                });
            }
        } else {
            return callback(err);
        }
    });
}

/**
 * Determine whether or not one of the principals in the array of principalUuids is able to perform the action on the
 * resource specified. If the action is null, then we will determine if the user can perform *any* action on the
 * resource specified.
 *
 * @param {Array<String>}            principalUuids     The array of principals to check
 * @param {String}                   action             The action to check. If null, check for any action.
 * @param {String}                   resourceUuid       The resource to check
 * @param {Function(err, isAllowed)} callback           A function invoked when the process is complete.
 * @param {Object}                   callback.err       An error that occured, if any
 * @param {Boolean}                  callback.isAllowed Whether or not one of the principals is authorized to perform the action
 */
var _isAllowed = function(principalUuids, action, resourceUuid, callback) {

    // short circuit if there is no ancestry
    if (!(principalUuids.length > 0)) {
        return callback(null, false);
    }

    // variables for monitoring the progress of permissions checks
    var index = 0;
    var isAllowedResult = false;
    var errResult = false;

    // this function monitors the progress of asynchronous permissions checks, calling back to the caller when appropriate
    var checkStatus = function(err, isAllowed) {
        if (errResult || isAllowedResult) {
            // do nothing, because we've already finished executing and called the callback
        } else if (err) {
            // we got an error while executing, call back with the error
            errResult = err;
            return callback(errResult);
        } else if (isAllowed) {
            // one of the principals is allowed to perform the action, short circuit
            isAllowedResult = isAllowed;
            return callback(null, isAllowedResult);
        } else {
            index++;
            if (index >= principalUuids.length) {
                // we've reached the end of the check and none are allowed, return false
                return callback(null, false);
            }
        }
    }

    // invoke the entire ancestry asynchronously. checkStatus will determine the result and when it is possible to call back.
    principalUuids.forEach(function(principalUuid) {
        if (action !== null) {
            hasRole(principalUuid, resourceUuid, action, checkStatus);
        } else {
            // we pass checkStatus directly here on the basis that the 'isAllowed' parameter is a duck-check and not strictly typed.
            getRole(principalUuid, resourceUuid, checkStatus);
        }
    });
}
