/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var _ = require('underscore');
var events = require('events');

var Cassandra = require('oae-util/lib/cassandra');
var Util = require('oae-util/lib/util');
var IO = require('oae-util/lib/io');
var Modules = require('oae-util/lib/modules');
var Pubsub = require('oae-util/lib/pubsub');
var TenantsAPI = require('oae-tenants');
var Validator = require('oae-util/lib/validator').Validator;
var log = require('oae-logger').logger('oae-config');

// Will be used to cache the global OAE config
var config = null;

// Cached config schema
var cachedSchema = {};
// Cached config values for admin users
var cachedConfig = {};
// Cached config values for non-admin users
var cachedConfigSuppressed = {};

/**
 * The Configuration API.
 *
 * ## Events
 *
 * * `update([tenantAlias])` - Invoked when the configuration has been updated on the application node. `tenantAlias` is the tenant whose configuration was updated. If not specified, then it was the global tenant whose configuration was updated.
 */
var ConfigAPI = module.exports = new events.EventEmitter();
var emitter = ConfigAPI;

//////////////////////////
// Pubsub notifications //
//////////////////////////

/*!
 * Catches a published Redis PubSub message from the oae-config module and refreshes the cached configuration for the tenant (in case
 * only a tenant config value was updated) or for all tenants (in case the global admin configuration has been updated)
 *
 * @param  {String}  tenantAlias  The message sent out to the cluster, provides the alias of the tenant for which a config value changed (e.g. `cam`)
 */
Pubsub.on('oae-config', function(tenantAlias) {

    /*!
     * Handles the callback for when the cached configuration is updated.
     *
     * @param  {Object} err     An error that occurred, if any
     */
    var _handleCachedConfig = function(err) {
        if (err) {
            log().error({'err': err, 'tenantAlias': tenantAlias}, 'Error refreshing cached configuration after update.');
        } else {
            emitter.emit('update', tenantAlias);
        }
    };

    // If the global tenant has been updated all tenants need an update
    if (tenantAlias === config.servers.globalAdminAlias) {
        cacheAllTenantConfigs(_handleCachedConfig);
    } else {
        cacheTenantConfig(tenantAlias, _handleCachedConfig);
    }
});


//////////////////////
// Get config value //
//////////////////////

/**
 * Get a function that allows retrieving of config values for a given module.
 * 
 * @param  {String}    moduleId     The ID of the module to get the configuration for
 * @return {Function}  getValue     Function that returns the cached a cached config value from the provided module
 * @throws {Error}                  Error thrown when no module id has been provided
 */
module.exports.config = function(moduleId) {
    // Parameter validation
    if (!moduleId) {
        throw new Error('A module id must be provided');
    }

    return {
        /**
         * Get a configuration value for the current module. This will return a cached value. This internal function will
         * also return suppressed values, as they will be necessary for usage inside of the internal APIs.
         * 
         * @param   {String}                          tenantAlias           The alias of the tenant for which to get the config value
         * @param   {String}                          feature               The feature to get the element's value for. e.g. `twitter`
         * @param   {String}                          element               The element to get the config value for. e.g. `enabled`
         * @return  {Boolean|String|Number|Object}    cachedConfiguration   The requested config value e.g. `true`. This will be null if the config element cannot be found.
         */
        getValue: function(tenantAlias, feature, element) {
            // Parameter validation
            if (!tenantAlias || !feature || !element) {
                return null;
            }

            // Validate the existence of the config value
            if (!cachedConfig[tenantAlias] || !cachedConfig[tenantAlias][moduleId] ||
                !cachedConfig[tenantAlias][moduleId][feature] || cachedConfig[tenantAlias][moduleId][feature][element] === undefined) {
                return null;
            }
            
            return cachedConfig[tenantAlias][moduleId][feature][element];
        }
    };
};

/**
 * Get the full cached config schema. This can only be retrieved by either global or tenant
 * admins, as it might contain sensitive data.
 * 
 * @param  {Context}      ctx               Standard context object, representing the currently logged in user and its tenant
 * @param  {Function}     callback          Standard callback function
 * @param  {Object}       callback.err      Error object containing error code and message
 * @param  {Object}       callback.schema   The config schema.
 */
var getSchema = module.exports.getSchema = function(ctx, callback) {
    if (!ctx.user() || !ctx.user().isAdmin(ctx.tenant().alias)) {
        return callback({'code': 401, 'msg': 'Only global and tenant admin can get the config schema'});
    }

    callback(null, cachedSchema);
};

/**
 * Get the full config feed for a tenant from cache, containing all the config values for that tenant. Admin users will receive
 * all config values, including those for suppressed fields. Non-admin users will receive all of the non-suppressed config values.
 * 
 * @param  {Context}      ctx               Standard context object, representing the currently logged in user and its tenant
 * @param  {String}       tenantAlias       Id of the tenant for which we want to get the cached config
 * @param  {Function}     callback          Standard callback function
 * @param  {Object}       callback.err      Error object containing error code and message
 * @param  {Object}       callback.config   JSON object representing the full cached tenant config
 */
var getTenantConfig = module.exports.getTenantConfig = function(ctx, tenantAlias, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(tenantAlias, {'code': 400, 'msg': 'Missing tenant parameter'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the current user is an admin user. If so, we return all config values, otherwise we return
    // the values that aren't suppressed
    if (ctx.user() && ctx.user().isAdmin(tenantAlias)) {
        return callback(null, cachedConfig[tenantAlias]);
    }

    callback(null, cachedConfigSuppressed[tenantAlias]);
};


////////////////////
// Initialization //
////////////////////

/**
 * Initializes and caches the configuration schema, as well as the list of config values for all tenants
 * 
 * @param  {Object}    _config          JSON object containing configuration values for Cassandra, Redis, logging and telemetry
 * @param  {Function}  callback         Standard callback function
 * @param  {Object}    callback.err     An error object is passed as an argument if an error occurs
 */
var initConfig = module.exports.initConfig = function(_config, callback) {
    // Default callback
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'An error occured whilst initializing the configuration');
        }
    };

    config = _config;

    // Cache the config schema
    cacheSchema(function() {
        cacheAllTenantConfigs(callback);
    });
};

/**
 * Cache all of the module config descriptors. First of all, all of the available modules are retrieved and modules that don't have a configuration file in the config directory 
 * are filtered out. Every file in the /config directory of a module is read and will be added to the globally cached schema object.It's assumed that the files contains valid JSON.
 * If multiple configuration files exist in one module they will be merged together.
 *
 * @param  {Function}  callback         Standard Callback function executed the schema has been cached
 * @api private
 */
var cacheSchema = function(callback) {
    // Get the available module
    var modules = Modules.getAvailableModules();
    var toDo = modules.length;
    var done = 0;

    /*!
     * Gets the configuration files for a given module
     *
     * @param  {String}  module    The module we're getting the configuration for. e.g. 'oae-principals'
     */
    var getModuleSchema = function(module) {
        var dir = 'node_modules/' + module + '/config/';
        // Get a list of the available config files
        IO.getFileListForFolder(dir, function(configFiles) {
            // Require all of them
            for (var c = 0; c < configFiles.length; c++) {
                var configFile = require(module + '/config/' + configFiles[c]);
                cachedSchema[module] = _.extend(cachedSchema[module] || {}, configFile);
            }
            done++;
            if (done === toDo) {
                callback();
            }
        });
    };

    for (var m = 0; m < modules.length; m++) {
        getModuleSchema(modules[m]);
    }
};

/**
 * Cache the config values for the global admin and all of the available tenants. For each of them, this will take the
 * config schema and its default values, overlay it with the value set on the global admin and then overlay it with the
 * value set for that tenant.
 * 
 * @param  {Function}       [callback]        Standard callback function
 * @param  {Object}         [callback.err]    Error object containing the error code and message
 * @api private
 */
var cacheAllTenantConfigs = function(callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'An error occured whilst caching all tenant configs');
        }
    };

    // Cache the config values for the global admin server
    var tenantsToCache = [config.servers.globalAdminAlias];
    // Cache the config for each of the tenants
    TenantsAPI.getAllTenants(function(err, tenants) {
        tenantsToCache = tenantsToCache.concat(_.keys(tenants));

        // Go through them one by one
        var cacheNextTenantConfig = function() {
            var tenant = tenantsToCache.shift();
            cacheTenantConfig(tenant, function(err) {
                if (err) {
                    return callback(err);
                }
                
                if (tenantsToCache.length > 0) {
                    cacheNextTenantConfig();
                } else {
                    callback();
                }
            });
        };
        cacheNextTenantConfig();
    });
};

/**
 * Get a list of all of the config values that have been set for a tenant, use the global admin defaults for the values for which
 * no tenant values are saved yet and cache them.
 * 
 * @param  {String}    tenantAlias       The ID of the tenant to get the configuration for
 * @param  {Function}  [callback]        Standard callback function
 * @param  {Object}    [callback.err]    Error object containing the error code and message
 * @api private
 */
var cacheTenantConfig = function(tenantAlias, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'An error occured whilst constructing the config for ' + tenantAlias);
        }
    };

    Cassandra.runQuery('SELECT * FROM Config USING CONSISTENCY QUORUM WHERE tenantAlias = ?', [tenantAlias], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var tenantConfig = Cassandra.rowToHash(rows[0]);
        cachedConfig[tenantAlias] = {};
        cachedConfigSuppressed[tenantAlias] = {};
        
        // Get all of the modules in the schema
        var moduleKeys = _.keys(cachedSchema);
        for (var m = 0; m < moduleKeys.length; m++) {
            var module = moduleKeys[m];
            cachedConfig[tenantAlias][module] = {};
            cachedConfigSuppressed[tenantAlias][module] = {};
            // Get all of the top level properties of the modules. Only the ones that are object are configuration properties
            var featureKeys = _.keys(cachedSchema[module]);
            for (var f = 0; f < featureKeys.length; f++) {
                var feature = featureKeys[f];
                if (_.isObject(cachedSchema[module][feature])) {
                    cachedConfig[tenantAlias][module][feature] = {};
                    cachedConfigSuppressed[tenantAlias][module][feature] = {};
                    // Run through all of the elements of that feature
                    var elementKeys = _.keys(cachedSchema[module][feature].elements);
                    for (var e = 0; e < elementKeys.length; e++) {
                        var element = elementKeys[e];
                        // If the current tenant is the global admin, we set the default to the one from the schema
                        if (tenantAlias === config.servers.globalAdminAlias) {
                            cachedConfig[tenantAlias][module][feature][element] = cachedSchema[module][feature].elements[element].defaultValue;
                        // If the current tenant is a regular tenant, we can take the global admin default as the default value
                        } else {
                            cachedConfig[tenantAlias][module][feature][element] = cachedConfig[config.servers.globalAdminAlias][module][feature][element];
                        }
                        // Check if the value has been overridden
                        var key = module + '/' + feature + '/' + element;
                        if (tenantConfig[key]) {
                            cachedConfig[tenantAlias][module][feature][element] = Util.castToBoolean(tenantConfig[key]);
                        }

                        // If the value is not suppressed, we add it to the cached suppressed config object
                        if (!cachedSchema[module][feature].elements[element].suppress) {
                            cachedConfigSuppressed[tenantAlias][module][feature][element] = cachedConfig[tenantAlias][module][feature][element];
                        }
                    }
                }
            }
        }

        callback();
    });
};

/////////////////////////
// Update config value //
/////////////////////////

/**
 * Update a configuration value for a particular tenant
 * 
 * @param  {Context}    ctx                The current context.
 * @param  {String}     tenantAlias        The alias of the tenant to store config for
 * @param  {Object}     configValues       The configuration to store. The keys represent the 'module/feature/element' combination and the values represent their new config value
 * @param  {Function}   callback           Standard callback function
 * @param  {Object}     callback.err       Error object containing error code and message
 */
var updateConfig = module.exports.updateConfig = function(ctx, tenantAlias, configValues, callback) {
    if (!ctx.user() || !ctx.user().isAdmin(tenantAlias)) {
        return callback({'code': 401, 'msg': 'Only authorized tenant admins can change config values'});
    }

    var validator = new Validator();
    var configFields = _.keys(configValues);
    validator.check(tenantAlias, {'code': 400, 'msg': 'Missing tenantid'}).notEmpty();
    validator.check(configFields.length, {'code': 400, 'msg': 'Missing configuration. Example configuration: {"oae-authentication/twitter/enabled": false}'}).min(1);
    for (var i = 0; i < configFields.length; i++) {
        validator.check(configFields[i], {'code': 400, 'msg': 'The configuration field cannot be null'}).not('null');
        validator.check(configValues[configFields[i]], {'code': 400, 'msg': 'The configuration value cannot be null'}).notNull();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var q = Cassandra.constructUpsertCQL('Config', 'tenantAlias', tenantAlias, configValues, 'QUORUM');
    Cassandra.runQuery(q.query, q.parameters, function(err) {
        if (err) {
            return callback(err);
        }

        Pubsub.publish('oae-config', tenantAlias);
        callback();
    });
};
