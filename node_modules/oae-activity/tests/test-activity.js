/*
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');
var util = require('util');

var ConfigTestsUtil = require('oae-config/lib/test/util');
var Context = require('oae-context/lib/api').Context;
var FollowingTestsUtil = require('oae-following/lib/test/util');
var log = require('oae-logger').logger('test-activity');
var RestAPI = require('oae-rest');
var RestContext = require('oae-rest/lib/model').RestContext;
var TestsUtil = require('oae-tests');

var ActivityAggregator = require('oae-activity/lib/internal/aggregator');
var ActivityAPI = require('oae-activity');
var ActivityDAO = require('oae-activity/lib/internal/dao');
var ActivityRegistry = require('oae-activity/lib/internal/registry');
var ActivitySeed = require('oae-activity/lib/model').ActivitySeed;
var ActivitySeedResource = require('oae-activity/lib/model').ActivitySeedResource;
var ActivityTestUtil = require('oae-activity/lib/test/util');
var ActivityUtil = require('oae-activity/lib/util');
var AssociationsSession = require('oae-activity/lib/model').AssociationsSession;


describe('Activity', function() {

    // Rest context that can be used every time we need to make a request as an anonymous user
    var anonymousCamRestContext = null;

    // Rest context that can be used every time we need to make a request as a tenant admin
    var camAdminRestContext = null;

    // Rest context that can be used every time we need to make a request as a global admin
    var globalAdminRestContext = null;

    // API context that can be used to execute anonymous API calls on the cambridge tenant
    var anonymousCamApiContext = null;

    /**
     * Function that will fill up the tenant admin and anymous rest context
     */
    before(function(callback) {
        anonymousCamRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host);
        camAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.cam.host);
        globalAdminRestContext = TestsUtil.createGlobalAdminRestContext();
        anonymousCamApiContext = new Context(global.oaeTests.tenants.cam);
        return callback();
    });

    afterEach(function(callback) {
        // Ensure activities are set back to enabled in case of test failures
        ConfigTestsUtil.updateConfigAndWait(globalAdminRestContext, null, {'oae-activity/activity/enabled': true}, function(err) {
            assert.ok(!err);

            ActivityTestUtil.refreshConfiguration(null, function(err) {
                assert.ok(!err);
                return callback();
            });
        });
    });

    describe('Activity API', function() {

        describe('#refreshConfiguration()', function() {

            /**
             * Test that verifies that refreshing configuration to disable activities works properly. This test assumes that an activity is
             * generated when a content item is created.
             */
            it('verify disabling and enabling activity worker', function(callback) {

                // First disable the activity worker and ensure no activities are processed
                ActivityTestUtil.refreshConfiguration({'processActivityJobs': false}, function(err) {
                    assert.ok(!err);

                    // Create the user we will use as the activity stream
                    var jackUsername = TestsUtil.generateTestUserId('jack');
                    RestAPI.User.createUser(camAdminRestContext, jackUsername, 'password', 'Jack McJackerson', null, function(err, jack) {
                        assert.ok(!err);
                        var jackCtx = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, jackUsername, 'password');

                        // Try to generate an activity for Jack's feed
                        RestAPI.Content.createLink(jackCtx, 'Google', 'Google', 'public', 'http://www.google.ca', [], [], [], function(err, link) {
                            assert.ok(!err);

                            // Verify no activity is generated, because we don't have any bound workers
                            ActivityTestUtil.collectAndGetActivityStream(jackCtx, null, null, function(err, activityStream) {
                                assert.ok(!err);
                                assert.ok(activityStream);
                                assert.ok(activityStream.items);
                                assert.equal(activityStream.items.length, 0);

                                // Re-enable the worker
                                ActivityTestUtil.refreshConfiguration(null, function(err) {
                                    assert.ok(!err);

                                    // Generate a 2nd activity for Jack's feed
                                    RestAPI.Content.createLink(jackCtx, 'Google', 'Google', 'public', 'http://www.google.ca', [], [], [], function(err, link) {
                                        assert.ok(!err);

                                        // Verify both the first activity and the 2nd are collected into the stream, as the first one should have been queued until
                                        // we were finally enabled.
                                        ActivityTestUtil.collectAndGetActivityStream(jackCtx, null, null, function(err, activityStream) {
                                            assert.ok(!err);
                                            assert.ok(activityStream);
                                            assert.ok(activityStream.items);
                                            assert.equal(activityStream.items.length, 1);
                                            assert.equal(activityStream.items[0].object['oae:collection'].length, 2);

                                            // Re-enable the worker (again) and verify activities are still being routed
                                            ActivityTestUtil.refreshConfiguration(null, function(err) {
                                                assert.ok(!err);

                                                // Create a 3rd activity to verify routing
                                                RestAPI.Content.createLink(jackCtx, 'Google', 'Google', 'public', 'http://www.google.ca', [], [], [], function(err, link) {
                                                    assert.ok(!err);

                                                    // Verify it was routed: now we should have 3 activities aggregated
                                                    ActivityTestUtil.collectAndGetActivityStream(jackCtx, null, null, function(err, activityStream) {
                                                        assert.ok(!err);
                                                        assert.ok(activityStream);
                                                        assert.ok(activityStream.items);
                                                        assert.equal(activityStream.items.length, 1);
                                                        assert.equal(activityStream.items[0].object['oae:collection'].length, 3);
                                                        callback();
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });

            /**
             * Test that verifies that activities delivered to activity feeds disappear after the configured `activityTtl` time has
             * expired.
             */
            it('verify activity ttl deletes an activity after the expiry time', function(callback) {
                // Set expiry to the smallest possible, 1 second
                ActivityTestUtil.refreshConfiguration({'activityTtl': 2}, function(err) {
                    assert.ok(!err);

                    var jackUsername = TestsUtil.generateTestUserId('jack');
                    RestAPI.User.createUser(camAdminRestContext, jackUsername, 'password', 'Jack McJackerson', null, function(err, jack) {
                        assert.ok(!err);
                        var jackCtx = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, jackUsername, 'password');

                        // Try to generate an activity for Jack's feed
                        RestAPI.Content.createLink(jackCtx, 'Google', 'Google', 'public', 'http://www.google.ca', [], [], [], function(err, link) {
                            assert.ok(!err);

                            // Verify the activity is generated immediately
                            ActivityTestUtil.collectAndGetActivityStream(jackCtx, null, null, function(err, activityStream) {
                                assert.ok(!err);
                                assert.ok(activityStream);
                                assert.ok(activityStream.items);
                                assert.equal(activityStream.items.length, 1);

                                // Now wait for the expiry and verify it has disappeared
                                setTimeout(ActivityTestUtil.collectAndGetActivityStream, 2100, jackCtx, null, null, function(err, activityStream) {
                                    assert.ok(!err);
                                    assert.ok(activityStream);
                                    assert.ok(activityStream.items);
                                    assert.equal(activityStream.items.length, 0);
                                    return callback();
                                });
                            });
                        });
                    });
                });
            });
        });

        describe('#registerActivityEntityType()', function() {

            /**
             * Test that verifies you cannot register duplicate activity object producers
             */
            it('verify registering duplicate activity entity types results in an error', function(callback) {
                var testId = TestsUtil.generateTestUserId();
                ActivityAPI.registerActivityEntityType(testId, {});
                assert.throws(function() {
                    ActivityAPI.registerActivityEntityType(testId, {});
                });
                return callback();
            });

            /**
             * Test that verifies that when an seed resource with no associated producer is posted, the resourceData is used as the
             * persistent entity.
             */
            it('verify default producer persists just the activity seed resource data', function(callback) {
                var testActivityType = TestsUtil.generateTestUserId();
                var testResourceType = TestsUtil.generateTestUserId();
                var testResourceId = TestsUtil.generateTestUserId();
                var testResourceId2 = TestsUtil.generateTestUserId();
                var testResourceId3 = TestsUtil.generateTestUserId();

                var routerExecuted = false;
                var hadActor = false;
                var hadObject = false;
                var hadTarget = false;

                // Actor and target resource should not have any data. Will verify that no resourceData does not through a wrench into routing
                var actorResource = new ActivitySeedResource(testResourceType, testResourceId);
                var objectResource = new ActivitySeedResource(testResourceType, testResourceId2, {'testData': 'Testing'});
                var targetResource = new ActivitySeedResource(testResourceType, testResourceId3);
                var seed = new ActivitySeed(testActivityType, Date.now(), 'whistle', actorResource, objectResource, targetResource);

                var continued = false;

                // We need to register a stream that will result in routes for this activity type
                // as the router would otherwise short-circuit the routing and the propagation logic
                // would not be executed
                ActivityAPI.registerActivityType(testActivityType, {
                    'streams': {
                        'activity': {
                            'router': {
                                'actor': ['self'],
                                'object': ['self'],
                                'target': ['self']
                            }
                        }
                    }
                });

                // Register a propagation for our unknown type. The persistent entity is given to the propagator, so we can verify it there
                ActivityAPI.registerActivityEntityType(testResourceType, {'propagation': function(associationsCtx, persistentEntity, propagationCallback) {
                    assert.ok(persistentEntity);

                    // Verify the resourceId and resourceType have been stripped away as they are specific to the seed
                    assert.ok(!persistentEntity.resourceId);
                    assert.ok(!persistentEntity.resourceType);

                    // Verify the oae:id and objectType have been added in their place
                    var persistentEntityId = persistentEntity['oae:id'];
                    assert.equal(persistentEntity.objectType, testResourceType);

                    if (persistentEntityId === testResourceId) {
                        hadActor = true;
                        assert.equal(persistentEntity['oae:id'], testResourceId);
                        assert.equal(_.keys(persistentEntity).length, 2);
                    } else if (persistentEntityId === testResourceId2) {
                        hadObject = true;
                        assert.equal(persistentEntity['oae:id'], testResourceId2);
                        assert.equal(_.keys(persistentEntity).length, 3);
                        assert.equal(persistentEntity.testData, 'Testing');
                    } else if (persistentEntityId === testResourceId3) {
                        hadTarget = true;
                        assert.equal(persistentEntity['oae:id'], testResourceId3);
                        assert.equal(_.keys(persistentEntity).length, 2);
                    }

                    propagationCallback(null, [{'type': 'all'}]);

                    if (!continued && hadActor && hadObject && hadTarget) {
                        continued = true;
                        return callback();
                    }
                }});

                // Simply trigger the activity
                ActivityAPI.postActivity(anonymousCamApiContext, seed);
            });

            /**
             * Test that verifies that the default activity transformer will return just the oae:id, oae:tenant and objectType of an entity
             */
            it('verify default activity transformer returns objectType, oae:tenant and oae:id', function(callback) {
                var username = TestsUtil.generateTestUserId('jack');
                var testActivityType = TestsUtil.generateTestUserId();
                var testResourceType = TestsUtil.generateTestUserId();
                var testResourceId = 'foo:camtest:' + TestsUtil.generateTestUserId();

                var jackUsername = TestsUtil.generateTestUserId('jack');
                RestAPI.User.createUser(camAdminRestContext, jackUsername, 'password', 'Jack McJackerson', null, function(err, jack) {
                    assert.ok(!err);
                    var jackCtx = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, jackUsername, 'password');

                    var actorResource = new ActivitySeedResource('user', jack.id);
                    var objectResource = new ActivitySeedResource(testResourceType, testResourceId, {'secret': 'My secret data!'});
                    var seed = new ActivitySeed(testActivityType, Date.now(), 'whistle', actorResource, objectResource);

                    // Register the activity such that the actor will receive it in their feed
                    ActivityAPI.registerActivityType(testActivityType, {
                        'streams': {
                            'activity': {
                                'router': {
                                    'actor': ['self']
                                }
                            }
                        }
                    });

                    // Post the activity and handle the result through the router.
                    ActivityAPI.postActivity(anonymousCamApiContext, seed);

                    ActivityAPI.registerActivityEntityType(testResourceType, {'propagation': function(associationsCtx, persistentEntity, propagationCallback) {

                        // Sanity check the post to ensure that we received the secret parameter to be persisted
                        assert.ok(persistentEntity);
                        assert.equal(persistentEntity['oae:id'], testResourceId);
                        assert.equal(persistentEntity.secret, 'My secret data!');

                        // Continue the activity posting process now. We ensure we can route to jack by specifying propagation of 'all'
                        propagationCallback(null, [{'type': 'all'}]);

                        // Collect the persisted activity, and make sure its transformation contains the id and type, but not the secret
                        ActivityTestUtil.collectAndGetActivityStream(jackCtx, jack.id, null, function(err, activityStream) {
                            assert.ok(!err);
                            assert.equal(activityStream.items.length, 1);
                            assert.ok(activityStream.items[0].object);
                            assert.equal(activityStream.items[0].object.objectType, testResourceType);
                            assert.equal(activityStream.items[0].object['oae:id'], testResourceId);
                            assert.ok(activityStream.items[0].object['oae:tenant']);
                            assert.equal(activityStream.items[0].object['oae:tenant'].alias, global.oaeTests.tenants.cam.alias);
                            assert.equal(activityStream.items[0].object['oae:tenant'].displayName, global.oaeTests.tenants.cam.displayName);

                            return callback();
                        });
                    }});
                });
            });
        });

        describe('#registerActivityStreamType()', function() {

            /**
             * Test that verifies you cannot register duplicate activity stream types
             */
            it('verify registering duplicate activity types results in an error', function(callback) {
                var streamType = TestsUtil.generateTestUserId();
                ActivityAPI.registerActivityStreamType(streamType, {
                    'transient': false,
                    'authorizationHandler': function(ctx, resourceId, token, callback) { return callback(); }
                });
                assert.throws(function() {
                    ActivityAPI.registerActivityStreamType(streamType, {
                        'transient': false,
                        'authorizationHandler': function(ctx, resourceId, token, callback) { return callback(); }
                    });
                });

                return callback();
            });
        });

        describe('#registerActivityType()', function() {

            /**
             * Test that verifies you cannot register duplicate activity types
             */
            it('verify registering duplicate activity types results in an error', function(callback) {
                var testId = TestsUtil.generateTestUserId();
                ActivityAPI.registerActivityType(testId, {'streams': {'activity': {'router': {'actor': ['self']}}}});
                assert.throws(function() {
                    ActivityAPI.registerActivityType(testId, {'streams': {'activity': {'router': {'actor': ['self']}}}});
                });

                return callback();
            });

            /**
             * Test that verifies you cannot register an activity type without specifying at least 1 stream
             */
            it('verify registering activity types without specifying a stream results in an error', function(callback) {
                var testId = TestsUtil.generateTestUserId();
                assert.throws(function() {
                    ActivityAPI.registerActivityType(testId, {});
                });

                assert.throws(function() {
                    ActivityAPI.registerActivityType(testId, {
                        'streams': undefined
                    });
                });

                assert.throws(function() {
                    ActivityAPI.registerActivityType(testId, {
                        'streams': {}
                    });
                });

                assert.throws(function() {
                    ActivityAPI.registerActivityType(testId, {
                        'streams': []
                    });
                });

                return callback();
            });

            /**
             * Test that verifies you cannot register an activity type without specifying at least 1 proper router per straem
             */
            it('verify registering activity types without specifying routers for a stream results in an error', function(callback) {
                var testId = TestsUtil.generateTestUserId();
                assert.throws(function() {
                    ActivityAPI.registerActivityType(testId, {
                        'streams': {
                            'activity': {}
                        }
                    });
                });
                assert.throws(function() {
                    ActivityAPI.registerActivityType(testId, {
                        'streams': {
                            'activity': {
                                'router': undefined
                            }
                        }
                    });
                });
                assert.throws(function() {
                    ActivityAPI.registerActivityType(testId, {
                        'streams': {
                            'activity': {
                                'router': {}
                            }
                        }
                    });
                });
                assert.throws(function() {
                    ActivityAPI.registerActivityType(testId, {
                        'streams': {
                            'activity': {
                                'router': {
                                    'actor': undefined
                                }
                            }
                        }
                    });
                });
                assert.throws(function() {
                    ActivityAPI.registerActivityType(testId, {
                        'streams': {
                            'activity': {
                                'router': {
                                    'actor': []
                                }
                            }
                        }
                    });
                });
                assert.throws(function() {
                    ActivityAPI.registerActivityType(testId, {
                        'streams': {
                            'activity': {
                                'router': {
                                    'actor': ['self']
                                }
                            },
                            'notification': {
                                'router': {
                                    'actor': []
                                }
                            }
                        }
                    });
                });

                return callback();
            });
        });

        describe('#registerActivityEntityAssociation()', function() {

            /**
             * Test that verifies you cannot register duplicate activity entity associations
             */
            it('verify registering duplicate activity entity association results in an error', function(callback) {
                var testId = TestsUtil.generateTestUserId();
                ActivityAPI.registerActivityEntityAssociation(testId, testId, function() {});
                assert.throws(function() {
                    ActivityAPI.registerActivityEntityAssociation(testId, testId, function() {});
                });

                return callback();
            });
        });

        describe('#postActivity()', function() {

            /**
             * Test that postActivity validates input properly
             */
            it('verify postActivity validation', function(callback) {
                var jackUsername = TestsUtil.generateTestUserId('jack');
                RestAPI.User.createUser(camAdminRestContext, jackUsername, 'password', 'Jack McJackerson', null, function(err, jack) {
                    assert.ok(!err);
                    var jackCtx = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, jackUsername, 'password');

                    // Generate an activity for Jack's feed
                    RestAPI.Content.createLink(jackCtx, 'Google', 'Google', 'public', 'http://www.google.ca', [], [], [], function(err, link) {
                        assert.ok(!err);

                        /*!
                         * @return a valid activity seed that can be overlayed with invalid values for testing.
                         */
                        var _createActivitySeed = function(seedOverlay, actorOverlay, objectOverlay, targetOverlay) {
                            if (!seedOverlay) {
                                return null;
                            }

                            var seed = {
                                'activityType': 'content-share',
                                'verb': 'share',
                                'published': Date.now()
                            };
                            var actor = {'resourceType': 'user', 'resourceId': jack.id};
                            var object = {'resourceType': 'content', 'resourceId': link.id};
                            var target = {'resourceType': 'user', 'resourceId': jack.id};

                            seed = _.extend(seed, seedOverlay);

                            if (actorOverlay) {
                                seed.actorResource = _.extend(actor, actorOverlay);
                            }

                            if (objectOverlay) {
                                seed.objectResource = _.extend(object, objectOverlay);
                            }

                            if (targetOverlay) {
                                seed.targetResource = _.extend(target, targetOverlay);
                            }

                            return seed;
                        };

                        // Verify no seed
                        ActivityAPI.postActivity(anonymousCamApiContext, _createActivitySeed(), function(err) {
                            assert.ok(err);
                            assert.equal(err.code, 400);

                            // Verify no activity type
                            ActivityAPI.postActivity(anonymousCamApiContext, _createActivitySeed({'activityType': ''}), function(err) {
                                assert.ok(err);
                                assert.equal(err.code, 400);

                                // Verify no verb
                                ActivityAPI.postActivity(anonymousCamApiContext, _createActivitySeed({'verb': ''}), function(err) {
                                    assert.ok(err);
                                    assert.equal(err.code, 400);

                                    // Verify no publish date
                                    ActivityAPI.postActivity(anonymousCamApiContext, _createActivitySeed({'published': ''}), function(err) {
                                        assert.ok(err);
                                        assert.equal(err.code, 400);

                                        // Verify no actor
                                        ActivityAPI.postActivity(anonymousCamApiContext, _createActivitySeed({}), function(err) {
                                            assert.ok(err);
                                            assert.equal(err.code, 400);

                                            // Verify no actor resource type
                                            ActivityAPI.postActivity(anonymousCamApiContext, _createActivitySeed({}, {'resourceType': ''}), function(err) {
                                                assert.ok(err);
                                                assert.equal(err.code, 400);

                                                // Verify no actor resource id
                                                ActivityAPI.postActivity(anonymousCamApiContext, _createActivitySeed({}, {'resourceId': ''}), function(err) {
                                                    assert.ok(err);
                                                    assert.equal(err.code, 400);

                                                    // Verify object with no resource type
                                                    ActivityAPI.postActivity(anonymousCamApiContext, _createActivitySeed({}, {}, {'resourceType': ''}), function(err) {
                                                        assert.ok(err);
                                                        assert.equal(err.code, 400);

                                                        // Verify object with no resource id
                                                        ActivityAPI.postActivity(anonymousCamApiContext, _createActivitySeed({}, {}, {'resourceId': ''}), function(err) {
                                                            assert.ok(err);
                                                            assert.equal(err.code, 400);

                                                            // Verify target with no resource type
                                                            ActivityAPI.postActivity(anonymousCamApiContext, _createActivitySeed({}, {}, {}, {'resourceType': ''}), function(err) {
                                                                assert.ok(err);
                                                                assert.equal(err.code, 400);

                                                                // Verify target with no resource id
                                                                ActivityAPI.postActivity(anonymousCamApiContext, _createActivitySeed({}, {}, {}, {'resourceId': ''}), function(err) {
                                                                    assert.ok(err);
                                                                    assert.equal(err.code, 400);

                                                                    // Sanity check successfull post
                                                                    ActivityAPI.postActivity(anonymousCamApiContext, _createActivitySeed({}, {}, {}, {}), function(err) {
                                                                        assert.ok(!err);
                                                                        callback();
                                                                    });
                                                                });
                                                            });
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });

            /**
             * Test that verifies activities stop being posted when it is disabled in the admin console.
             */
            it('verifies disabling activity posting', function(callback) {
                var jackUsername = TestsUtil.generateTestUserId('jack');
                RestAPI.User.createUser(camAdminRestContext, jackUsername, 'password', 'Jack McJackerson', null, function(err, jack) {
                    assert.ok(!err);
                    var jackCtx = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, jackUsername, 'password');

                    // Generate an activity for Jack's feed
                    RestAPI.Content.createLink(jackCtx, 'Google', 'Google', 'public', 'http://www.google.ca', [], [], [], function(err, link) {
                        assert.ok(!err);

                        // Disable activity posting
                        ConfigTestsUtil.updateConfigAndWait(globalAdminRestContext, null, {'oae-activity/activity/enabled': false}, function(err) {
                            assert.ok(!err);

                            // Try and generate an activity, but this should actually not be posted
                            RestAPI.Content.createLink(jackCtx, 'Yahoo', 'Yahoo', 'public', 'http://www.yahoo.ca', [], [], [], function(err, link2) {
                                assert.ok(!err);

                                ConfigTestsUtil.updateConfigAndWait(globalAdminRestContext, null, {'oae-activity/activity/enabled': true}, function(err) {
                                    assert.ok(!err);

                                    ActivityTestUtil.collectAndGetActivityStream(jackCtx, null, null, function(err, activityStream) {
                                        assert.ok(!err);

                                        // Verify only one activity and it is not an aggregation
                                        assert.equal(activityStream.items.length, 1);
                                        assert.equal(activityStream.items[0].object['objectType'], 'content');
                                        assert.equal(activityStream.items[0].object['oae:id'], link.id);
                                        callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    describe('Activity Routing', function() {

        /**
         * Test that verifies activity associations are cached
         */
        it('verify activity association caching', function(callback) {
            // Create a content item whose associations we can test for caching
            RestAPI.Content.createLink(camAdminRestContext, 'Google', 'Google', 'public', 'http://www.google.ca', [], [], [], function(err, link) {
                assert.ok(!err);

                var activityResource = {'content': link};
                activityResource.objectType = 'content';
                activityResource['oae:id'] = link.id;

                var associationsSession = new AssociationsSession(ActivityRegistry.getRegisteredActivityEntityAssociations(), activityResource);
                var associationsCtx = associationsSession.createAssociationsContext('content', link.id);

                // Get the associations while determining if it happened in the same process tick. If it happens in the same process tick, it is
                // fetched directly from cache without IO, in which case it is synchronous. To determine asynchrony, we have the statement
                // `firstWasAsynchronous = true;` after the get method. If `firstWasAsynchronous = true` is invoked first, then the method was
                // in a new process tick. If it is still false, then we fetched directly from a cache.
                var firstWasAsynchronous = false;
                associationsCtx.get('members', function(err, members) {
                    assert.ok(!err);
                    assert.ok(members);
                    assert.strictEqual(members.length, 1);
                    assert.ok(firstWasAsynchronous);

                    var firstUserId = members[0];

                    // Now the next access should be synchronous
                    var secondWasAsynchronous = false;
                    associationsCtx.get('members', function(err, members) {
                        assert.ok(!err);
                        assert.ok(members);
                        assert.strictEqual(members.length, 1);
                        assert.ok(!secondWasAsynchronous);
                        assert.equal(firstUserId, members[0]);
                        return callback();
                    });
                    secondWasAsynchronous = true;
                });
                firstWasAsynchronous = true;
            });
        });

        /**
         * Test that verifies activity associations cache is cloned and cannot be modified in-memory
         */
        it('verify activity association cache entries cannot be updated in-memory', function(callback) {
            // Create a content item whose associations we can test for caching
            RestAPI.Content.createLink(camAdminRestContext, 'Google', 'Google', 'public', 'http://www.google.ca', [], [], [], function(err, link) {
                assert.ok(!err);

                var activityResource = {'content': link};
                activityResource.objectType = 'content';
                activityResource['oae:id'] = link.id;

                var associationsSession = new AssociationsSession(ActivityRegistry.getRegisteredActivityEntityAssociations(), activityResource);
                var associationsCtx = associationsSession.createAssociationsContext('content', link.id);

                associationsCtx.get('members', function(err, members) {
                    assert.ok(!err);
                    assert.ok(members);
                    assert.strictEqual(members.length, 1);

                    // Shift a user off the array
                    members.shift();

                    associationsCtx.get('members', function(err, members) {
                        assert.ok(!err);
                        assert.ok(members);

                        // Ensure the user is still there in the next cached version
                        assert.strictEqual(members.length, 1);

                        // Shift once more to test that the cached version is cloned as well
                        members.shift();

                        associationsCtx.get('members', function(err, members) {
                            assert.ok(!err);
                            assert.ok(members);
                            assert.strictEqual(members.length, 1);
                            return callback();
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies the standard resource propagation when a joinable resource is passed in
         */
        it('verify standard resource propagation for joinable resources', function(callback) {
            // Mock a resource type that can be joinable to verify its routing behaviour
            var testEntityType = TestsUtil.generateTestUserId();
            ActivityAPI.registerActivityEntityType(testEntityType, {'propagation': function(associationsCtx, persistentEntity, propagationCallback) {
                // Defer to the standard resource propagation. This is what we're testing
                ActivityUtil.getStandardResourcePropagation(persistentEntity.visibility, persistentEntity.joinable, propagationCallback);
            }});

            TestsUtil.setupMultiTenantPrivacyEntities(function(publicTenant0, publicTenant1, privateTenant0, privateTenant1) {
                // Make privateTenant1 public for now so we can get a follower going
                ConfigTestsUtil.updateConfigAndWait(TestsUtil.createGlobalAdminRestContext(), privateTenant1.tenant.alias, {'oae-tenants/tenantprivacy/tenantprivate': false}, function(err) {
                    // Follow the publicTenant0.publicUser with the others
                    var followers = [
                        publicTenant0.loggedinUser,
                        publicTenant0.privateUser,
                        publicTenant1.publicUser,
                        publicTenant1.loggedinUser,
                        publicTenant1.privateUser,
                        privateTenant1.publicUser
                    ];

                    // Follow the public tenant0 user with all the users
                    FollowingTestsUtil.followByAll(publicTenant0.publicUser.user.id, followers, function(err) {
                        assert.ok(!err);

                        // Make privateTenant1 private now that the association has been made. This sets up a tenant that is non-interactable which will
                        // let us verify the "interacting tenants" propagation later
                        ConfigTestsUtil.updateConfigAndWait(TestsUtil.createGlobalAdminRestContext(), privateTenant1.tenant.alias, {'oae-tenants/tenantprivacy/tenantprivate': true}, function(err) {
                            assert.ok(!err);

                            // This is an id for the mocked resource type we created at the start of this test. We will simply give it a resource id prefix
                            // of "a", but it is really quite arbitrary
                            var testId = util.format('a:%s:%s', publicTenant0.tenant.alias, TestsUtil.generateTestUserId());

                            // Fabricate an activity with a resource that will invoke the "interacting_tenants" propagation. To do this, we will use a
                            // content create activity with our mocked resource that is "joinable". The propagation on the `testEntityType` resource
                            // will then indicate that only "interacting tenants" (and "member" association) can see it. Since we have setup the
                            // followers of `publicTenant0.publicUser` to be some that do not belong to interacting tenants, we can ensure VIA the
                            // followers routes that those users do not receive this activity
                            var actorResource = new ActivitySeedResource('user', publicTenant0.publicUser.user.id);
                            var objectResource = new ActivitySeedResource(testEntityType, testId, {'visibility': 'private', 'joinable': 'yes'});
                            var activitySeed = new ActivitySeed('content-create', Date.now(), 'create', actorResource, objectResource);
                            ActivityAPI.postActivity(new Context(publicTenant0.tenant), activitySeed);

                            // Ensure the user themself got it
                            ActivityTestUtil.collectAndGetActivityStream(publicTenant0.publicUser.restContext, null, null, function(err, response) {
                                assert.ok(!err);
                                ActivityTestUtil.assertActivity(response.items[0], 'content-create', 'create', publicTenant0.publicUser.user.id, testId);

                                // Ensure a user from the same tenant who isn't a member got it
                                ActivityTestUtil.collectAndGetActivityStream(publicTenant0.privateUser.restContext, null, null, function(err, response) {
                                    assert.ok(!err);
                                    ActivityTestUtil.assertActivity(response.items[0], 'content-create', 'create', publicTenant0.publicUser.user.id, testId);

                                    // Ensure a user from another public tenant did not get it since they don't have access to the private object
                                    ActivityTestUtil.collectAndGetActivityStream(publicTenant1.privateUser.restContext, null, null, function(err, response) {
                                        assert.ok(!err);

                                        // The last activity in their feed should be the follow activity from when they followed the publicTenant0 public user
                                        ActivityTestUtil.assertActivity(response.items[0], 'following-follow', 'follow', publicTenant1.privateUser.user.id, publicTenant0.publicUser.user.id);

                                        // Ensure the user from the private tenant did not get it either
                                        ActivityTestUtil.collectAndGetActivityStream(privateTenant1.publicUser.restContext, null, null, function(err, response) {
                                            assert.ok(!err);

                                            // The last activity in their feed should be the follow activity from when they followed the publicTenant0 public user
                                            ActivityTestUtil.assertActivity(response.items[0], 'following-follow', 'follow', privateTenant1.publicUser.user.id, publicTenant0.publicUser.user.id);
                                            return callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies the "routes" propagation, and that it is chosen by default if there is no entity registration
         */
        it('verify default resource propagation of "routes"', function(callback) {
            TestsUtil.setupMultiTenantPrivacyEntities(function(publicTenant0, publicTenant1, privateTenant0, privateTenant1) {
                var testEntityType = TestsUtil.generateTestUserId();

                // Mock an association for this entity type that will provide "members", which can drive the routes for our fake content-create activity
                ActivityAPI.registerActivityEntityAssociation(testEntityType, 'members', function(associationsCtx, entity, associationsCallback) {
                    // Hardcode the public member as an association. This means that the default propagation will only recognize that member as a
                    // recipient that has access, therefore the content-create activity invoked with an entity of this type should go to only them
                    return associationsCallback(null, [publicTenant0.publicUser.user.id]);
                });

                var followers = [publicTenant0.privateUser, publicTenant1.publicUser];

                // Follow the public tenant0 user with all the users
                FollowingTestsUtil.followByAll(publicTenant0.publicUser.user.id, followers, function(err) {
                    assert.ok(!err);

                    var testId = util.format('a:%s:%s', publicTenant0.tenant.alias, TestsUtil.generateTestUserId());

                    // Fabricate an activity with a resource that will invoke the default "routes" propagation. To do this, we will use a content
                    // create activity. The propagation on the `testEntityType` resource will indicate that only routes ('member' association) can
                    // see it, whereas the routing for the actor will attempt to route to all followers
                    var actorResource = new ActivitySeedResource('user', publicTenant0.publicUser.user.id);
                    var objectResource = new ActivitySeedResource(testEntityType, testId);
                    var activitySeed = new ActivitySeed('content-create', Date.now(), 'create', actorResource, objectResource);
                    ActivityAPI.postActivity(new Context(publicTenant0.tenant), activitySeed);

                    // Ensure that the publicTenant0 public user got it. The propagation of the test entity is the "routes", which we hard-coded to include
                    // this user, therefore this user is allowed to receive this activity in their feed
                    ActivityTestUtil.collectAndGetActivityStream(publicTenant0.publicUser.restContext, null, null, function(err, response) {
                        assert.ok(!err);
                        ActivityTestUtil.assertActivity(response.items[0], 'content-create', 'create', publicTenant0.publicUser.user.id, testId);

                        // Ensure the `publicTenant0.privateUser` *does not* receive the activity. The routing will attempt to route `publicTenant0.privateUser`
                        // this activity because they are a follower of `publicTenant0.publicUser` and the content-create activity will route to the followers of
                        // the actor. However, propagation will reject the activity from the user's feed because the test entity type only allows propagation to
                        // its routes, and this user is not part of its routes, as hard-coded in the association registration at the start of the test
                        ActivityTestUtil.collectAndGetActivityStream(publicTenant0.privateUser.restContext, null, null, function(err, response) {
                            assert.ok(!err);
                            ActivityTestUtil.assertActivity(response.items[0], 'following-follow', 'follow', publicTenant0.privateUser.user.id, publicTenant0.publicUser.user.id);
                            return callback();
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that activity associations can be specified that exclude routes
         */
        it('verify activity association exclusion', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 3, function(err, users, nico, branden, simon) {
                assert.ok(!err);

                // Register a couple of associations for a fake entity type that produces simple routes
                var testEntityType = TestsUtil.generateTestUserId();
                ActivityAPI.registerActivityEntityAssociation(testEntityType, 'all', function(associationsCtx, entity, callback) {
                    return callback(null, [nico.user.id, branden.user.id, simon.user.id]);
                });
                ActivityAPI.registerActivityEntityAssociation(testEntityType, 'branden', function(associationsCtx, entity, callback) {
                    return callback(null, [branden.user.id]);
                });
                ActivityAPI.registerActivityEntityAssociation(testEntityType, 'simon', function(associationsCtx, entity, callback) {
                    return callback(null, [simon.user.id]);
                });

                // Register a fake activity that should route to all users except for Branden
                // `^simon` has been added first in the set of associations to assert that exclusions are processed
                // in left-to-right order. As there is no set to exclude him, before that association, he will not be dropped
                var testActivityType = TestsUtil.generateTestUserId();
                ActivityAPI.registerActivityType(testActivityType, {
                    'streams': {
                        'activity': {
                            'router': {
                                'object': ['^simon', 'all', '^branden']
                            }
                        }
                    }
                });

                // Fabricate an activity with a resource that will route the activity to all users except for branden
                var testId = TestsUtil.generateTestUserId();
                var actorResource = new ActivitySeedResource('user', nico.user.id);
                var objectResource = new ActivitySeedResource(testEntityType, testId);
                var activitySeed = new ActivitySeed(testActivityType, Date.now(), 'create', actorResource, objectResource);
                ActivityAPI.postActivity(new Context(nico.user.tenant), activitySeed);

                // Assert Branden didn't get the activity
                ActivityTestUtil.collectAndGetActivityStream(branden.restContext, null, null, function(err, activityStream) {
                    assert.ok(!err);
                    assert.strictEqual(activityStream.items.length, 0);

                    // Assert Nico got the activity
                    ActivityTestUtil.collectAndGetActivityStream(nico.restContext, null, null, function(err, activityStream) {
                        assert.ok(!err);
                        assert.strictEqual(activityStream.items.length, 1);
                        assert.strictEqual(activityStream.items[0].object['oae:id'], testId);

                        // Because Simon is excluded from the *empty set* (and NOT from the `all` set) he should have received an activity as well
                        ActivityTestUtil.collectAndGetActivityStream(simon.restContext, null, null, function(err, activityStream) {
                            assert.ok(!err);
                            assert.strictEqual(activityStream.items.length, 1);
                            assert.strictEqual(activityStream.items[0].object['oae:id'], testId);

                            return callback();
                        });
                    });
                });
            });
        });
    });

    describe('Activity Stream Permissions and Validation', function() {

        /**
         * Test that verifies getting an activity stream is validated properly.
         */
        it('verify getActivityStream validation', function(callback) {
            var jackUsername = TestsUtil.generateTestUserId('jack');
            RestAPI.User.createUser(camAdminRestContext, jackUsername, 'password', 'Jack McJackerson', null, function(err, jack) {
                assert.ok(!err);
                var jackCtx = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, jackUsername, 'password');

                // Try anonymous user
                ActivityTestUtil.collectAndGetActivityStream(anonymousCamRestContext, jack.id, null, function(err, activityStream) {
                    assert.ok(err);
                    assert.equal(err.code, 401);
                    assert.ok(!activityStream);

                    // Try empty id
                    ActivityTestUtil.collectAndGetActivityStream(jackCtx, '  ', null, function(err, activityStream) {
                        assert.ok(err);
                        assert.equal(err.code, 400);
                        assert.ok(!activityStream);

                        // Try invalid principal id
                        ActivityTestUtil.collectAndGetActivityStream(jackCtx, 'c:cam:someContent', null, function(err, activityStream) {
                            assert.ok(err);
                            assert.equal(err.code, 400);
                            assert.ok(!activityStream);

                            // Try an invalid activity transformer
                            ActivityTestUtil.collectAndGetActivityStream(jackCtx, 'c:cam:someContent', {'format': 'non-existing'}, function(err, activityStream) {
                                assert.ok(err);
                                assert.equal(err.code, 400);
                                assert.ok(!activityStream);

                                // Sanity-check valid query
                                ActivityTestUtil.collectAndGetActivityStream(jackCtx, jack.id, null, function(err, activityStream) {
                                    assert.ok(!err);
                                    callback();
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies you cannot view another user's activity stream
         */
        it('verify a user activity stream can only be seen by the user themselves', function(callback) {
            var jackUsername = TestsUtil.generateTestUserId('jack');
            var janeUsername = TestsUtil.generateTestUserId('jane');

            RestAPI.User.createUser(camAdminRestContext, jackUsername, 'password', 'Jack McJackerson', null, function(err, jack) {
                assert.ok(!err);
                var jackCtx = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, jackUsername, 'password');

                // Generate an activity for Jack's feed
                RestAPI.Content.createLink(jackCtx, 'Google', 'Google', 'public', 'http://www.google.ca', [], [], [], function(err, link) {
                    assert.ok(!err);

                    // Sanity check that Jack can view his own feed
                    ActivityTestUtil.collectAndGetActivityStream(jackCtx, null, null, function(err, activityStream) {
                        assert.ok(!err);
                        assert.ok(activityStream);
                        assert.ok(activityStream.items);
                        assert.equal(activityStream.items.length, 1);

                        // Create Jane and make sure she cannot see Jack's feed
                        RestAPI.User.createUser(camAdminRestContext, janeUsername, 'password', 'Jane', null, function(err, jane) {
                            assert.ok(!err);
                            var janeCtx = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, janeUsername, 'password');

                            ActivityTestUtil.collectAndGetActivityStream(janeCtx, jack.id, null, function(err, activityStream) {
                                assert.ok(err);
                                assert.equal(err.code, 401);
                                assert.ok(!activityStream);
                                callback();
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies only members of a group can see the group's activity feed
         */
        it('verify a group activity stream can only be seen by its members', function(callback) {
            var jackUsername = TestsUtil.generateTestUserId('jack');
            var janeUsername = TestsUtil.generateTestUserId('jane');

            RestAPI.User.createUser(camAdminRestContext, jackUsername, 'password', 'Jack McJackerson', null, function(err, jack) {
                assert.ok(!err);
                var jackCtx = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, jackUsername, 'password');

                // Create Jane, she should not be able to see the group's feed as she will not be a member of the group
                RestAPI.User.createUser(camAdminRestContext, janeUsername, 'password', 'Jane', null, function(err, jane) {
                    assert.ok(!err);
                    var janeCtx = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, janeUsername, 'password');

                    // Create a group with which to share content
                    RestAPI.Group.createGroup(jackCtx, TestsUtil.generateTestUserId('group'), TestsUtil.generateTestUserId('group'), 'public', 'no', [], [], function(err, group) {
                        assert.ok(!err);

                        // Create a content item in the group library, this should route a "content created" activity to the group's activity feed
                        RestAPI.Content.createLink(jackCtx, 'Google', 'Google', 'public', 'http://www.google.ca', [], [group.id], [], function(err, link) {
                            assert.ok(!err);

                            // Verify Jack can see the activity in the group feed
                            ActivityTestUtil.collectAndGetActivityStream(jackCtx, group.id, null, function(err, activityStream) {
                                assert.ok(!err);
                                assert.ok(activityStream);
                                assert.equal(activityStream.items.length, 2);

                                ActivityTestUtil.collectAndGetActivityStream(janeCtx, group.id, null, function(err, activityStream) {
                                    assert.ok(err);
                                    assert.equal(err.code, 401);
                                    assert.ok(!activityStream);
                                    callback();
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    describe('Getting Activity Stream', function() {

        /**
         * Test that verifies the tenant information gets associated with each activity entity.
         */
        it('verify activities have tenant information', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users) {
                assert.ok(!err);

                var jack = _.values(users)[0].user;
                var jackCtx = _.values(users)[0].restContext;
                var jane = _.values(users)[1].user;

                // Jack creates a link and shares it with Jane.
                RestAPI.Content.createLink(jackCtx, 'Google', 'Google', 'public', 'http://www.google.com', [], [], [], function(err, link) {
                    assert.ok(!err);
                    RestAPI.Content.shareContent(jackCtx, link.id, [jane.id], function(err) {
                        assert.ok(!err);

                        ActivityTestUtil.collectAndGetActivityStream(jackCtx, null, null, function(err, activityStream) {
                            assert.ok(!err);
                            assert.ok(activityStream.items.length > 0);

                            /**
                             * Verifies that the oae:tenant object is present on the activity entity.
                             *
                             * @param  {ActivityEntity} entity The activity entity
                             */
                            var assertActivityEntity = function(entity) {
                                assert.ok(entity['oae:tenant']);
                                assert.equal(entity['oae:tenant'].alias, global.oaeTests.tenants.cam.alias);
                                assert.equal(entity['oae:tenant'].displayName, global.oaeTests.tenants.cam.displayName);
                            };

                            // Make sure that both the actor, object and target (if one is available) have an oae:tenant object.
                            _.each(activityStream.items, function(activity) {
                                assertActivityEntity(activity.actor);
                                assertActivityEntity(activity.object);
                                if (activity['oae:activityType'] === 'content-share') {
                                    assertActivityEntity(activity.target);
                                }
                            });
                            callback();
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies the tenant information gets associated with each activity entity when they appear in collections.
         */
        it('verify activities with collections have tenant information', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 3, function(err, users) {
                var jack = _.values(users)[0].user;
                var jackCtx = _.values(users)[0].restContext;
                var jane = _.values(users)[1].user;
                var jill = _.values(users)[2].user;

                // Jack creates a link and shares it with Jane and Jill.
                RestAPI.Content.createLink(jackCtx, 'Google', 'Google', 'public', 'http://www.google.com', [], [], [], function(err, link) {
                    assert.ok(!err);
                    RestAPI.Content.shareContent(jackCtx, link.id, [jane.id, jill.id], function(err) {
                        assert.ok(!err);

                        ActivityTestUtil.collectAndGetActivityStream(jackCtx, null, null, function(err, activityStream) {
                            assert.ok(!err);
                            assert.ok(activityStream.items.length > 0);

                            /**
                             * Verifies that the oae:tenant object is present on the activity entity.
                             *
                             * @param  {ActivityEntity} entity The activity entity
                             */
                            var assertActivityEntity = function(entity) {
                                assert.ok(entity['oae:tenant']);
                                assert.equal(entity['oae:tenant'].alias, global.oaeTests.tenants.cam.alias);
                                assert.equal(entity['oae:tenant'].displayName, global.oaeTests.tenants.cam.displayName);
                            };

                            // Make sure that both the actor, object and target (if one is available) have an oae:tenant object.
                            _.each(activityStream.items, function(activity) {
                                assertActivityEntity(activity.actor);
                                assertActivityEntity(activity.object);
                                if (activity['oae:activityType'] === 'content-share') {
                                    _.each(activity.target['oae:collection'], function(entity) {
                                        assertActivityEntity(entity);
                                    });
                                }
                            });
                            callback();
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies paging of activity feeds
         */
        it('verify paging of activity feeds', function(callback) {
            var jackUsername = TestsUtil.generateTestUserId('jack');
            var janeUsername = TestsUtil.generateTestUserId('jane');

            RestAPI.User.createUser(camAdminRestContext, jackUsername, 'password', 'Jack McJackerson', null, function(err, jack) {
                assert.ok(!err);
                var jackCtx = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, jackUsername, 'password');

                RestAPI.User.createUser(camAdminRestContext, janeUsername, 'password', 'Jane', null, function(err, jane) {
                    assert.ok(!err);
                    var janeCtx = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, janeUsername, 'password');

                    // Generate 2 activities for jack's feed
                    RestAPI.Content.createLink(jackCtx, 'A', 'A', 'public', 'http://www.google.ca', [], [], [], function(err, link) {
                        assert.ok(!err);

                        RestAPI.Content.shareContent(jackCtx, link.id, [jane.id], function(err) {
                            assert.ok(!err);

                            // Get the items, ensure there are 2
                            ActivityTestUtil.collectAndGetActivityStream(jackCtx, null, null, function(err, activityStream) {
                                assert.ok(!err);
                                assert.equal(activityStream.items.length, 2);

                                var firstId = activityStream.items[0]['oae:activityId'];
                                var secondId = activityStream.items[1]['oae:activityId'];

                                // Verify when you query with limit=1, you get the first and only the first activity
                                ActivityTestUtil.collectAndGetActivityStream(jackCtx, null, {'limit': 1}, function(err, activityStream) {
                                    assert.ok(!err);
                                    assert.equal(activityStream.items.length, 1);
                                    assert.equal(activityStream.items[0]['oae:activityId'], firstId);
                                    assert.equal(activityStream.nextToken, firstId);

                                    // Verify when you query with the firstId as the start point, you get just the second activity
                                    ActivityTestUtil.collectAndGetActivityStream(jackCtx, null, {'start': firstId}, function(err, activityStream) {
                                        assert.ok(!err);
                                        assert.equal(activityStream.items.length, 1);
                                        assert.equal(activityStream.items[0]['oae:activityId'], secondId);
                                        assert.ok(!activityStream.nextToken);
                                        callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Verify the activity transformer can be specified when requesting the activities from the REST API
         */
        it('verify the transformer can be specified', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, jack) {
                assert.ok(!err);

                RestAPI.Content.createLink(jack.restContext, 'A', 'A', 'public', 'http://www.google.ca', [], [], [], function(err, link) {
                    assert.ok(!err);

                    // Assert that it defaults to the activitystrea.ms spec
                    ActivityTestUtil.collectAndGetActivityStream(jack.restContext, null, null, function(err, activityStream) {
                        assert.ok(!err);

                        // The activity entities will have extra properties and will be formatted slightly differently
                        var activity = activityStream.items[0];
                        assert.ok(activity);

                        assert.ok(activity.actor);
                        assert.equal(activity.actor['oae:id'], jack.user.id);
                        assert.equal(activity.actor['oae:visibility'], jack.user.visibility);
                        assert.equal(activity.actor['oae:profilePath'], jack.user.profilePath);
                        assert.equal(activity.actor['displayName'], jack.user.displayName);
                        assert.equal(activity.actor['url'], 'http://' + global.oaeTests.tenants.cam.host + '/user/camtest/' + jack.user.id.split(':')[2]);
                        assert.equal(activity.actor['objectType'], 'user');
                        assert.equal(activity.actor['id'], 'http://' + global.oaeTests.tenants.cam.host + '/api/user/' + jack.user.id);
                        assert.ok(_.isObject(activity.actor['oae:tenant']));

                        var allowedActorProperties = ['oae:id', 'oae:visibility', 'oae:profilePath', 'displayName', 'url', 'objectType', 'id', 'oae:tenant'];
                        _.each(activity.actor, function(value, key) {
                            assert.ok(_.contains(allowedActorProperties, key) , key + ' is not allowed on an ActivityStrea.ms compliant formatted activity entity');
                        });

                        assert.ok(activity.object);
                        assert.equal(activity.object['oae:id'], link.id);
                        assert.equal(activity.object['oae:visibility'], link.visibility);
                        assert.equal(activity.object['oae:profilePath'], link.profilePath);
                        assert.equal(activity.object['oae:resourceSubType'], link.resourceSubType);
                        assert.equal(activity.object['oae:revisionId'], link.latestRevisionId);
                        assert.equal(activity.object['displayName'], link.displayName);
                        assert.equal(activity.object['url'], 'http://' + global.oaeTests.tenants.cam.host + '/content/camtest/' + link.id.split(':')[2]);
                        assert.equal(activity.object['objectType'], 'content');
                        assert.equal(activity.object['id'], 'http://' + global.oaeTests.tenants.cam.host + '/api/content/' + link.id);
                        assert.ok(_.isObject(activity.object['oae:tenant']));

                        var allowedObjectProperties = [ 'oae:id', 'oae:visibility', 'oae:profilePath', 'oae:resourceSubType', 'oae:revisionId', 'displayName', 'url', 'objectType', 'id', 'oae:tenant' ];
                        _.each(activity.object, function(value, key) {
                            assert.ok(_.contains(allowedObjectProperties, key) , key + ' is not allowed on an ActivityStrea.ms compliant formatted activity entity');
                        });

                        // Assert that the format can be specified
                        RestAPI.Activity.getActivityStream(jack.restContext, jack.user.id, {'format': 'internal'}, function(err, activityStream) {
                            assert.ok(!err);

                            activity = activityStream.items[0];
                            assert.ok(activity);

                            // Assert that the actor entity is a user object augmented with an oae:id and objectType
                            assert.ok(activity.actor);
                            assert.equal(activity.actor['oae:id'], jack.user.id);
                            assert.equal(activity.actor['id'], jack.user.id);
                            assert.equal(activity.actor['displayName'], jack.user.displayName);
                            assert.equal(activity.actor['visibility'], jack.user.visibility);
                            assert.equal(activity.actor['locale'], 'en_GB');
                            assert.equal(activity.actor['publicAlias'], jack.user.publicAlias);
                            assert.ok(_.isObject(activity.actor['picture']));
                            assert.equal(activity.actor['profilePath'], jack.user.profilePath);
                            assert.equal(activity.actor['resourceType'], 'user');
                            assert.equal(activity.actor['acceptedTC'], 0);
                            assert.equal(activity.actor['objectType'], 'user');
                            assert.ok(_.isObject(activity.actor['tenant']));

                            // Ensure only these properties are present
                            allowedActorProperties = ['oae:id', 'id', 'displayName', 'visibility', 'locale', 'publicAlias', 'picture', 'profilePath', 'resourceType', 'acceptedTC', 'objectType', 'tenant', 'email', 'emailPreference'];
                            _.each(activity.actor, function(value, key) {
                                assert.ok(_.contains(allowedActorProperties, key) , key + ' is not allowed on an internally formatted activity entity');
                            });


                            // Assert that the object entity is a content object augmented with an oae:id and objectType
                            assert.ok(activity.object);
                            assert.equal(activity.object['oae:id'], link.id);
                            assert.equal(activity.object['id'], link.id);
                            assert.equal(activity.object['visibility'], link.visibility);
                            assert.equal(activity.object['displayName'], link.displayName);
                            assert.equal(activity.object['description'], link.description);
                            assert.equal(activity.object['resourceSubType'], link.resourceSubType);
                            assert.equal(activity.object['createdBy'], link.createdBy);
                            assert.equal(activity.object['created'], link.created);
                            assert.equal(activity.object['lastModified'], link.lastModified);
                            assert.equal(activity.object['profilePath'], link.profilePath);
                            assert.equal(activity.object['resourceType'], link.resourceType);
                            assert.equal(activity.object['latestRevisionId'], link.latestRevisionId);
                            assert.ok(_.isObject(activity.object['previews']));
                            assert.ok(_.isObject(activity.object['signature']));
                            assert.equal(activity.object['objectType'], 'content');
                            assert.ok(_.isObject(activity.object['tenant']));

                            // Ensure only these properties are present
                            allowedObjectProperties = [ 'tenant', 'id', 'visibility', 'displayName', 'description', 'resourceSubType', 'createdBy', 'created', 'lastModified', 'profilePath', 'resourceType', 'latestRevisionId', 'previews', 'signature', 'objectType', 'oae:id' ];
                            _.each(activity.object, function(value, key) {
                                assert.ok(_.contains(allowedObjectProperties, key) , key + ' is not allowed on an internally formatted activity entity');
                            });

                            return callback();
                        });
                    });
                });
            });
        });
    });

    describe('Activity Stream Aggregation', function() {

        /**
         * Test that verifies when the aggregation expiry time has exceeded, a new activity will be created when it matches a pivot
         * rather than continuing to aggregate in the previous activity.
         */
        it('verify aggregation idle expiry time', function(callback) {
            var jackUsername = TestsUtil.generateTestUserId('jack');

            // Set the aggregate expiry time to 1 second. This should give us enough time to aggregate 2 activities, wait for expiry, then create a 3rd to verify it does not aggregate.
            ActivityTestUtil.refreshConfiguration({'aggregateIdleExpiry': 1}, function(err) {
                assert.ok(!err);

                RestAPI.User.createUser(camAdminRestContext, jackUsername, 'password', 'Jack McJackerson', null, function(err, jack) {
                    assert.ok(!err);
                    var jackCtx = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, jackUsername, 'password');

                    RestAPI.Content.createLink(jackCtx, 'A', 'A', 'public', 'http://www.google.ca', [], [], [], function(err, linkA) {
                        assert.ok(!err);

                        RestAPI.Content.createLink(jackCtx, 'B', 'B', 'public', 'http://www.google.ca', [], [], [], function(err, linkB) {
                            assert.ok(!err);

                            ActivityTestUtil.collectAndGetActivityStream(jackCtx, null, null, function(err, activityStream) {
                                assert.ok(!err);

                                // Verify both creates are aggregated into 1 activity
                                assert.equal(activityStream.items.length, 1);

                                var hasA = false;
                                var hasB = false;

                                var entity = activityStream.items[0].object;
                                assert.ok(entity['oae:collection']);
                                _.each(entity['oae:collection'], function(collectedEntity) {
                                    if (collectedEntity['oae:id'] === linkA.id) {
                                        hasA = true;
                                    } else if (collectedEntity['oae:id'] === linkB.id) {
                                        hasB = true;
                                    }
                                });

                                assert.ok(hasA);
                                assert.ok(hasB);

                                // Let the aggregation timeout expire and create a new link
                                setTimeout(RestAPI.Content.createLink, 1100, jackCtx, 'C', 'C', 'public', 'http://www.google.ca', [], [], [], function(err, linkC) {
                                    assert.ok(!err);

                                    // Re-collect and verify that the aggregate expired, thus making the link a new activity, not an aggregate
                                    ActivityTestUtil.collectAndGetActivityStream(jackCtx, null, null, function(err, activityStream) {
                                        assert.ok(!err);

                                        // Now validate the activity stream contents
                                        assert.equal(activityStream.items.length, 2);

                                        entity = activityStream.items[0].object;
                                        assert.equal(entity['oae:id'], linkC.id);

                                        hasA = false;
                                        hasB = false;

                                        entity = activityStream.items[1].object;
                                        assert.ok(entity['oae:collection']);
                                        _.each(entity['oae:collection'], function(collectedEntity) {
                                            if (collectedEntity['oae:id'] === linkA.id) {
                                                hasA = true;
                                            } else if (collectedEntity['oae:id'] === linkB.id) {
                                                hasB = true;
                                            }
                                        });

                                        assert.ok(hasA);
                                        assert.ok(hasB);

                                        return callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that the maximum aggregate expiry time will cause a new aggregate to be created even if the aggregate
         * does not fall idle.
         */
        it('verify aggregation max expiry time', function(callback) {
            var jackUsername = TestsUtil.generateTestUserId('jack');

            // Set the aggregate max time to 1s and the idle time higher to 5s, this is to rule out the possibility of idle expiry messing up this test
            ActivityTestUtil.refreshConfiguration({'aggregateIdleExpiry': 5, 'aggregateMaxExpiry': 1}, function(err) {
                assert.ok(!err);

                RestAPI.User.createUser(camAdminRestContext, jackUsername, 'password', 'Jack McJackerson', null, function(err, jack) {
                    assert.ok(!err);
                    var jackCtx = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, jackUsername, 'password');

                    // This is when the createLink aggregate is born
                    RestAPI.Content.createLink(jackCtx, 'A', 'A', 'public', 'http://www.google.ca', [], [], [], function(err, linkA) {
                        assert.ok(!err);

                        // Drop an aggregate in. The when collected the aggregate is 600ms old
                        setTimeout(RestAPI.Content.createLink, 600, jackCtx, 'B', 'B', 'public', 'http://www.google.ca', [], [], [], function(err, linkB) {
                            assert.ok(!err);

                            // Collect, then wait for expiry
                            ActivityTestUtil.collectAndGetActivityStream(jackCtx, null, null, function(err, activityStream) {
                                assert.ok(!err);

                                // When this content item is created, it should have crossed max expiry, causing this content create activity to be delivered individually
                                setTimeout(RestAPI.Content.createLink, 1500, jackCtx, 'C', 'C', 'public', 'http://www.google.ca', [], [], [], function(err, linkC) {
                                    assert.ok(!err);

                                    ActivityTestUtil.collectAndGetActivityStream(jackCtx, null, null, function(err, activityStream) {
                                        assert.ok(!err);

                                        // Now validate the activity stream contents
                                        assert.equal(activityStream.items.length, 2);

                                        // The most recent is the individual content-create entity activity
                                        var entity = activityStream.items[0].object;
                                        assert.equal(entity['oae:id'], linkC.id);

                                        // The next oldest is the aggregated with a and b in it
                                        var hasA = false;
                                        var hasB = false;
                                        entity = activityStream.items[1].object;
                                        assert.ok(entity['oae:collection']);
                                        entity['oae:collection'].forEach(function(collectedEntity) {
                                            if (collectedEntity['oae:id'] === linkA.id) {
                                                hasA = true;
                                            } else if (collectedEntity['oae:id'] === linkB.id) {
                                                hasB = true;
                                            }
                                        });

                                        assert.ok(hasA);
                                        assert.ok(hasB);

                                        return callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });


        /**
         * Test that verifies that when the aggregateIdleExpiry expires, the aggregate data disappears from storage.
         */
        it('verify aggregated data is automatically deleted after the idle expiry time', function(callback) {
            var jackUsername = TestsUtil.generateTestUserId('jack');

            // Set the aggregate max time to 1s, if we add aggregate data then wait this period of time, queries to the DAO should show that this data has
            // been automatically cleaned out
            ActivityTestUtil.refreshConfiguration({'aggregateIdleExpiry': 1, 'aggregateMaxExpiry': 5}, function(err) {
                assert.ok(!err);

                RestAPI.User.createUser(camAdminRestContext, jackUsername, 'password', 'Jack McJackerson', null, function(err, jack) {
                    assert.ok(!err);
                    var jackCtx = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, jackUsername, 'password');

                    // Create a link then collect, which creates the aggregates
                    RestAPI.Content.createLink(jackCtx, 'A', 'A', 'public', 'http://www.google.ca', [], [], [], function(err, link) {
                        assert.ok(!err);

                        // Drop an aggregate in. This is when the aggregate should be initially persisted, so should expire 1s from this time
                        ActivityTestUtil.collectAndGetActivityStream(jackCtx, null, null, function(err, activityStream) {
                            assert.ok(!err);

                            // Verify that the DAO reports the aggregate status is indeed there.
                            var aggregateKey = util.format('content-create#%s#activity#user:%s##', jack.id, jack.id);

                            ActivityDAO.getAggregateStatus([aggregateKey], function(err, aggregateStatus) {
                                assert.ok(!err);
                                assert.ok(aggregateStatus[aggregateKey]);
                                assert.ok(aggregateStatus[aggregateKey].lastActivity);

                                // Verify that the DAO reports the aggregated entity is indeed there at this time
                                ActivityDAO.getAggregatedEntities([aggregateKey], function(err, aggregatedEntities) {
                                    assert.ok(!err);
                                    assert.ok(aggregatedEntities[aggregateKey]);
                                    assert.ok(aggregatedEntities[aggregateKey]['actors']['user:' + jack.id]);
                                    assert.ok(aggregatedEntities[aggregateKey]['objects']['content:' + link.id]);

                                    // Wait the max expiry (1s) to let them disappear and verify there is no status
                                    setTimeout(ActivityDAO.getAggregateStatus, 1100, [aggregateKey], function(err, aggregateStatus) {
                                        assert.ok(!err);
                                        assert.ok(_.isEmpty(aggregateStatus));

                                        // Verify the entities disappeared
                                        ActivityDAO.getAggregatedEntities([aggregateKey], function(err, aggregatedEntities) {
                                            assert.ok(!err);
                                            assert.ok(_.isEmpty(aggregatedEntities['actors']));
                                            assert.ok(_.isEmpty(aggregatedEntities['objects']));
                                            assert.ok(_.isEmpty(aggregatedEntities['targets']));

                                            return callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that activity aggregation can be reset
         */
        it('verify aggregation can be reset', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, simong, mrvisser) {
                assert.ok(!err);

                // Create a file as simong and share it with mrvisser. mrvisser should get an activity
                RestAPI.Content.createLink(simong.restContext, 'First item', 'A', 'public', 'http://www.google.be', [], [mrvisser.user.id], [], function(err, firstContentObj) {
                    assert.ok(!err);
                    ActivityTestUtil.collectAndGetActivityStream(mrvisser.restContext, null, null, function(err, activityStream) {
                        assert.ok(!err);
                        // Sanity check that the create content activity is in mrvisser's activity stream
                        ActivityTestUtil.assertActivity(activityStream.items[0], 'content-create', 'create', simong.user.id, firstContentObj.id);

                        // Reset the aggregator for mrvisser his activity stream
                        // The next content-create activity should *NOT* aggregate with the previous one
                        ActivityAggregator.resetAggregationForActivityStreams([mrvisser.user.id + '#activity'], function(err) {
                            assert.ok(!err);
                            RestAPI.Content.createLink(simong.restContext, 'Second item', 'A', 'public', 'http://www.google.be', [], [mrvisser.user.id], [], function(err, secondContentObj) {
                                assert.ok(!err);
                                ActivityTestUtil.collectAndGetActivityStream(mrvisser.restContext, null, null, function(err, activityStream) {
                                    assert.ok(!err);

                                    // As we have reset aggregation for mrvisser's activity stream, we should have 2 distinct activities for the same activity type
                                    assert.equal(activityStream.items.length, 2);
                                    ActivityTestUtil.assertActivity(activityStream.items[0], 'content-create', 'create', simong.user.id, secondContentObj.id);
                                    ActivityTestUtil.assertActivity(activityStream.items[1], 'content-create', 'create', simong.user.id, firstContentObj.id);

                                    // Sanity check that creating another piece of content does aggregate with the latest activity
                                    RestAPI.Content.createLink(simong.restContext, 'Third item', 'A', 'public', 'http://www.google.be', [], [mrvisser.user.id], [], function(err, thirdContentObj) {
                                        assert.ok(!err);
                                        ActivityTestUtil.collectAndGetActivityStream(mrvisser.restContext, null, null, function(err, activityStream) {
                                            assert.ok(!err);
                                            assert.equal(activityStream.items.length, 2);
                                            ActivityTestUtil.assertActivity(activityStream.items[0], 'content-create', 'create', simong.user.id, [secondContentObj.id, thirdContentObj.id]);
                                            ActivityTestUtil.assertActivity(activityStream.items[1], 'content-create', 'create', simong.user.id, firstContentObj.id);

                                            // Assert that the notification stream was not impacted and that all three activities aggregated
                                            ActivityTestUtil.collectAndGetNotificationStream(mrvisser.restContext, null, function(err, notificationStream) {
                                                assert.ok(!err);
                                                assert.equal(notificationStream.items.length, 1);
                                                ActivityTestUtil.assertActivity(notificationStream.items[0], 'content-create', 'create', simong.user.id, [firstContentObj.id, secondContentObj.id, thirdContentObj.id]);

                                                // Reset mrvisser's "notification" activity stream and generate another notification
                                                // That way we can verify that resetting aggregation for a stream that contains previously aggregates activities works correctly
                                                ActivityAggregator.resetAggregationForActivityStreams([mrvisser.user.id + '#notification'], function(err) {
                                                    assert.ok(!err);
                                                    RestAPI.Content.createLink(simong.restContext, 'Fourth item', 'A', 'public', 'http://www.google.be', [], [mrvisser.user.id], [], function(err, fourthContentObj) {
                                                        assert.ok(!err);
                                                        ActivityTestUtil.collectAndGetNotificationStream(mrvisser.restContext, null, function(err, notificationStream) {
                                                            assert.ok(!err);
                                                            assert.equal(notificationStream.items.length, 2);
                                                            ActivityTestUtil.assertActivity(notificationStream.items[0], 'content-create', 'create', simong.user.id, fourthContentObj.id);
                                                            ActivityTestUtil.assertActivity(notificationStream.items[1], 'content-create', 'create', simong.user.id, [firstContentObj.id, secondContentObj.id, thirdContentObj.id]);
                                                            return callback();
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that when you reset aggregation for a stream, the active aggregate keys are removed
         */
        it('verify resetting aggregation for a stream removes the correct active aggregate keys', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, simong, mrvisser) {
                assert.ok(!err);

                // Generate an activity that ends up in two activity streams for Simon
                // That way we can verify that resetting aggregation for a specific stream doesn't impact another
                RestAPI.Content.createLink(mrvisser.restContext, 'A', 'A', 'public', 'http://www.google.be', [], [simong.user.id], [], function(err, contentObj) {
                    assert.ok(!err);
                    ActivityTestUtil.collectAndGetActivityStream(simong.restContext, null, null, function(err, activityStream) {
                        assert.ok(!err);

                        // Since we've performed and collected activities, there should be a key in the set of active aggregate keys
                        ActivityDAO.getActiveAggregateKeysForActivityStreams([simong.user.id + '#activity'], function(err, activeAggregateKeysForActivityStream) {
                            assert.ok(!err);
                            assert.equal(activeAggregateKeysForActivityStream.length, 1);
                            assert.ok(!_.isEmpty(activeAggregateKeysForActivityStream[0]));

                            // Verify that the notification stream has a set of keys as well
                            ActivityDAO.getActiveAggregateKeysForActivityStreams([simong.user.id + '#notification'], function(err, activeAggregateKeysForNotificationStream) {
                                assert.ok(!err);
                                assert.equal(activeAggregateKeysForNotificationStream.length, 1);
                                assert.ok(!_.isEmpty(activeAggregateKeysForNotificationStream[0]));

                                // Assert that the aggregate keys for a notification stream are different than those of an activity stream
                                var allActivityKeys = _.flatten(activeAggregateKeysForActivityStream);
                                var allNotificationKeys = _.flatten(activeAggregateKeysForNotificationStream);
                                assert.ok(_.isEmpty(_.intersection(allActivityKeys, allNotificationKeys)));

                                // Reset simon's "activity" activity stream
                                ActivityAggregator.resetAggregationForActivityStreams([simong.user.id + '#activity'], function(err) {
                                    assert.ok(!err);

                                    // Since we've reset the aggregation process for simon's stream, he should no longer have any active aggregate keys
                                    ActivityDAO.getActiveAggregateKeysForActivityStreams([simong.user.id + '#activity'], function(err, activeAggregateKeysForActivityStream) {
                                        assert.ok(!err);
                                        assert.equal(activeAggregateKeysForActivityStream.length, 1);
                                        assert.ok(_.isEmpty(activeAggregateKeysForActivityStream[0]));

                                        // Assert that we did not impact the "notification" activity stream
                                        ActivityDAO.getActiveAggregateKeysForActivityStreams([simong.user.id + '#notification'], function(err, activeAggregateKeysForNotificationStream) {
                                            assert.ok(!err);
                                            assert.equal(activeAggregateKeysForNotificationStream.length, 1);
                                            assert.ok(!_.isEmpty(activeAggregateKeysForNotificationStream[0]));
                                            return callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    describe('Activity Stream Transience', function(callback) {

        /**
         * Test that verifies that transient streams are not persisted
         */
        it('verify transient streams are not persisted', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, simong) {
                assert.ok(!err);

                RestAPI.Content.createLink(simong.restContext, 'A', 'A', 'public', 'http://www.google.ca', [], [], [], function(err, contentObj) {
                    assert.ok(!err);

                    RestAPI.Content.createComment(simong.restContext, contentObj.id, 'Comment Comment', null, function(err, comment) {
                        assert.ok(!err);

                        ActivityTestUtil.collectAndGetActivityStream(simong.restContext, null, null, function(err, activityStream) {
                            assert.ok(!err);

                            // Sanity check that the comment is in our activity stream
                            ActivityTestUtil.assertActivity(activityStream.items[0], 'content-comment', 'post', simong.user.id, comment.id, contentObj.id);

                            // The `message` stream is transient and should NOT result in any persisted activities
                            ActivityDAO.getActivities(contentObj.id + '#message', null, 20, function(err, activities) {
                                assert.ok(!err);
                                assert.equal(activities.length, 0);
                                return callback();
                            });
                        });
                    });
                });
            });
        });
    });
});
