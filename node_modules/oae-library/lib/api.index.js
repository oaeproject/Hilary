/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var util = require('util');

var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var Counter = require('oae-util/lib/counter');
var log = require('oae-logger').logger('library-index');
var OaeUtil = require('oae-util/lib/util');

var LibraryAuthz = require('./api.authz');
var LibraryRegistry = require('./internal/registry');

// We need a slug column name to denote a fresh library index at both the lower
// bound and upper bound to determine if an index is fresh or invalidated
var SLUG_LOW = '#';
var SLUG_HIGH = '|';

var DEFAULT_VALUE = 1;

/*!
 * The visibility masks define the visibility groups that each visibility bucket contains. The
 * key is the name of the bucket, and the array of values are the visibilities of resources that
 * belong in that bucket.
 */
var visibilityMasks = {
    'private': [AuthzConstants.visibility.PUBLIC, AuthzConstants.visibility.LOGGEDIN, AuthzConstants.visibility.PRIVATE],
    'loggedin': [AuthzConstants.visibility.PUBLIC, AuthzConstants.visibility.LOGGEDIN],
    'public': [AuthzConstants.visibility.PUBLIC]
};

var updateCounter = new Counter();

/**
 * The `LibraryIndexer` index is built to manage "ranked" libraries of items that are grouped according to a
 * "visibility mask". It should be used in the following way:
 *
 *  *   Multiple different modules may have multiple different types of libraries. It is expected that
 *      `indexName` namespaces the library across the whole application, and also namespaces this particular
 *      type of library within the module (e.g., For oae-principals, you may have: "Group Members" library and
 *      "Group Memberships" library)
 *  *   For a library index, there is a group of ordered lists for each visibility. When `insert`ing a public resource
 *      for a user's content library, you would specify the pair {"<principalId>": "public"} as an item in the
 *      `keyVisibilities` hash. This item would then be available in the private, loggedin and public lists
 *      for the principal's library, as specified by the `visibilityMasks`
 *  *   The libraries order the resources (largest to smallest) by a `rank`. When inserting or updating a resource
 *      in the libraries, the index needs to know the `rank` of the item to insert, and if it is an update, it
 *      needs to know the previous rank to remove the old version
 *  *   There is potential for race-conditions in the index, most of which would result in duplicate items. Since
 *      these cases will result in items being closely ranked in the index, the index detects duplicates while
 *      paging and automatically repairs them. As a result, it is possible if you `list` 25 items from the index, you
 *      may receive 24 (or less). Therefore, pay close attention to the `nextToken` variable to determine if the
 *      index has more items, **don't** determine if the list is empty by checking if the number of items received is
 *      less than the requested number of items!
 *  *   Untimely losses of servers may result in inserts to work and deletes to fail when replacing items. This may
 *      result in duplicates that are not very close in rank, and therefore may never be automatically repaired. Either
 *      these items would have to be manually removed from the database, a sufficiently large `list` request to the
 *      library would trigger the indexer to auto-repair it, or the library can be deleted and it will be rebuilt
 *      on the next request for the library
 */
var LibraryIndex = module.exports;

/**
 * Register a library index with the library module. This provides custom pluggable functionality for different
 * library indexes.
 *
 * ## options.pageResources
 *
 * When rebuilding a library from scratch, it is necessary for the library index to request all the resources
 * that should exist in a library. This pageResources option is the functionality required by all library
 * indexes in order to have its items rebuilt.
 *
 * @param  {String}     name                                                            The name of the library index. Should be the same unique name used to reference the index in the insert, update and remove functions of the module
 * @param  {Object}     options                                                         The options specifying the library index behaviour
 * @param  {Function}   options.pageResources                                           A function that can iterate over all the expected resources that belong to a particular library index of this type
 * @param  {String}     options.pageResources.libraryId                                 The id of the library that is being paged through
 * @param  {String}     options.pageResources.start                                     The starting point of the requested page of resources
 * @param  {String}     options.pageResources.limit                                     The maximum number of items to return
 * @param  {Function}   options.pageResources.callback                                  Standard callback function that should be invoked when the page of resources has been fetched
 * @param  {Object}     options.pageResources.callback.err                              An error that occurred while fetching the page of resources, if any
 * @param  {Object[]}   options.pageResources.callback.entries[i]                       The library insert entries to use to populate the index
 * @param  {String}     options.pageResources.callback.entries[i].rank                  The relative rank for this entry in the library index
 * @param  {Object}     options.pageResources.callback.entries[i].resource              The resource object from which to find the resource id, tenant and visibility
 * @param  {String}     options.pageResources.callback.entries[i].resource.id           The id of the resource to insert
 * @param  {Tenant}     options.pageResources.callback.entries[i].resource.tenant       The tenant of the resource to insert
 * @param  {String}     options.pageResources.callback.entries[i].resource.visibility   The visibility of the resource to insert
 * @param  {String}     [options.pageResources.callback.nextToken]                      The value to use as the `start` parameter in the next invokation to get the next page of items. If unspecified, it indicates there are no more pages of resources
 */
var registerLibraryIndex = module.exports.registerLibraryIndex = function(name, options) {
    LibraryRegistry.registerLibraryIndex(name, options);
};

/**
 * Insert a resource into a library. This is different than `update` in that it makes no attempt
 * to delete a previously-ranked item from the index
 *
 * @param  {String}         indexName                       The name of the index to insert into. Should be namespaced to the module using it.
 * @param  {Object[]}       entries                         The library entries to insert into the specified library index
 * @param  {String}         entries[i].id                   The id of the resource that "owns" the library to insert this entry
 * @param  {Object}         entries[i].resource             The resource being inserted
 * @param  {String}         entries[i].resource.id          The id of the resource being inserted
 * @param  {String}         entries[i].resource.visibility  The visibility of the resource being inserted
 * @param  {Object}         [entries[i].value]              The value of the entry. This will be returned when items are listed
 * @param  {String}         [entries[i].rank]               The **string-ordered** rank of the resource to insert. Since this is string ordered, a rank of 11 for example is LOWER than 2. If not specified, defaults to 0
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 */
var insert = module.exports.insert = function(indexName, entries, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({
                'err': err,
                'indexName': indexName,
                'entries': entries
            }, 'Error inserting resource into libraries');
        }
    };

    updateCounter.incr();

    var indexEntries = _.map(entries, function(entry) {
        return {
            'libraryId': entry.id,
            'rank': entry.rank,
            'resourceId': entry.resource.id,
            'value': entry.value,
            'visibility': LibraryAuthz.resolveLibraryBucketVisibility(entry.id, entry.resource),
        };
    });

    _insert(indexName, indexEntries, function(err) {
        updateCounter.decr();
        return callback(err);
    });
};

/**
 * Update a resource in a library index. This will attempt to delete an old item according to an `oldRank`, and insert a
 * new item according to the `newRank`. Items will be aggressively deleted from all visibility buckets, so only the current
 * visibility is needed to determine the buckets of the insert.
 *
 * @param  {String}         indexName                       The name of the index to update item in. Should be namespaced to the module using it.
 * @param  {Object[]}       entries                         The library entries to update in the specified library index
 * @param  {String}         entries[i].id                   The id of the resource that "owns" the library to update this entry
 * @param  {Object}         entries[i].resource             The resource being updated
 * @param  {String}         entries[i].resource.id          The id of the resource being updated
 * @param  {String}         entries[i].resource.visibility  The visibility of the resource being updated
 * @param  {String}         [entries[i].oldRank]            The old **string-ordered** rank of the resource to update. Since this is string ordered, a rank of 11 for example is LOWER than 2. If not specified, defaults to 0
 * @param  {String}         [entries[i].newRank]            The new **string-ordered** rank of the resource to update. Since this is string ordered, a rank of 11 for example is LOWER than 2. If not specified, defaults to 0
 * @param  {Object}         [entries[i].newValue]           The new value to apply for the updated entry. If omitted, the new entry will not have a value
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 */
var update = module.exports.update = function(indexName, entries, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({
                'err': err,
                'indexName': indexName,
                'entries': entries
            }, 'Error updating resources in libraries');
        }
    };

    log().trace({
        'indexName': indexName,
        'entries': entries
    }, 'Updating resources in library buckets');

    updateCounter.incr();

    // All queries to perform the operation will be aggregated into a single query array to invoke
    // when ready
    var queries = [];

    _.each(entries, function(entry) {
        // What we will remove and insert into the library index
        var oldRankedResourceId = _createRankedResourceId(entry.resource.id, entry.oldRank);
        var newRankedResourceId = _createRankedResourceId(entry.resource.id, entry.newRank);
        var value = entry.newValue || DEFAULT_VALUE;

        // Ensure all values are stringified to JSON so they can be safely parsed on read
        value = JSON.stringify(value);

        // First delete the old version of this resource for all buckets
        _.each(visibilityMasks, function(mask, bucketName) {
            queries.push({
                'query': 'DELETE FROM "LibraryIndex" WHERE "bucketKey" = ? AND "rankedResourceId" = ?',
                'parameters': [_createBucketKey(indexName, entry.id, bucketName), oldRankedResourceId]
            });

            // Insert this resource into buckets that are relevant to its relative visibility
            if (_.contains(mask, entry.resource.visibility)) {
                queries.push({
                    'query': 'UPDATE "LibraryIndex" SET "value" = ? WHERE "bucketKey" = ? AND "rankedResourceId" = ?',
                    'parameters': [value, _createBucketKey(indexName, entry.id, bucketName), newRankedResourceId]
                });
            }
        });
    });

    Cassandra.runBatchQuery(queries, function(err) {
        updateCounter.decr();
        return callback(err);
    });
};

/**
 * Remove a resource from the library index. Note that the visibility of the resource is not
 * required for this operation as we simply delete from all potential visibility buckets
 *
 * @param  {String}         indexName               The name of the index to remove from. Should be namespaced to the module using it.
 * @param  {Object[]}       entries                 The library entries to remove from the specified library index
 * @param  {String}         entries[i].id           The id of the resource that "owns" the library from which to remove this entry
 * @param  {Object}         entries[i].resource     The resource being removed
 * @param  {String}         entries[i].resource.id  The id of the resource being removed
 * @param  {String}         [entries[i].rank]       The **string-ordered** rank of the resource to remove. Since this is string ordered, a rank of 11 for example is LOWER than 2. If not specified, defaults to 0
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 */
var remove = module.exports.remove = function(indexName, entries, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({
                'err': err,
                'indexName': indexName,
                'entries': entries
            }, 'Error removing resource from library');
        }
    };

    log().trace({
        'indexName': indexName,
        'entries': entries
    }, 'Removing resource for library indexes');

    updateCounter.incr();

    // For each entry deletion, aggregate the query necessary to delete it from each visibility
    // bucket in the library index
    var queries = [];
    _.each(entries, function(entry) {
        var rankedResourceId = _createRankedResourceId(entry.resource.id, entry.rank);
        _.each(visibilityMasks, function(mask, bucketName) {
            queries.push({
                'query': 'DELETE FROM "LibraryIndex" WHERE "bucketKey" = ? AND "rankedResourceId" = ?',
                'parameters': [_createBucketKey(indexName, entry.id, bucketName), rankedResourceId]
            });
        });
    });

    Cassandra.runBatchQuery(queries, function(err) {
        updateCounter.decr();
        return callback(err);
    });
};

/**
 * Fires a handler when all in-progress index updates (inserts, updates and removals) have been
 * completed. This is useful in tests to synchronize with library index updates that are otherwise
 * asynchronous, so library indexes know when to check the impact of updates in the library
 *
 * @param  {Function}   callback    Invoked when all updates are complete
 */
var whenUpdatesComplete = module.exports.whenUpdatesComplete = function(callback) {
    updateCounter.whenZero(callback);
};

/**
 * Retrieve an ordered list of items from the index
 *
 * @param  {String}     indexName                       The name of the index to list. Should be namespaced to the module using it
 * @param  {String}     libraryId                       An id that identifies the bucket group that should be listed
 * @param  {String}     visibility                      The visibility of the bucket that should be listed
 * @param  {Object}     [opts]                          Optional parameters
 * @param  {String}     [opts.start]                    Determines the rank at which items are returned for paging purposed. If not provided, will start from the highest ranked item
 * @param  {Number}     [opts.limit]                    Number of items to return. Default: 10
 * @param  {Function}   callback                        Standard callback function
 * @param  {Object}     callback.err                    An error that occurred, if any
 * @param  {Object[]}   callback.entries                The entries in the index, containing both the resource id and stored value if any
 * @param  {String}     callback.entries[i].resourceId  The id of the resource representing this entry
 * @param  {Object}     callback.entries[i].value       The value stored for this resource entry
 * @param  {String}     callback.nextToken              The value to use for the `opts.start` parameter to get the next set of results
 */
var list = module.exports.list = function(indexName, libraryId, visibility, opts, callback) {
    opts = opts || {};
    opts.limit = OaeUtil.getNumberParam(opts.limit, 10, 1);
    opts.start = opts.start || '';

    // Query the library index, and lazily build it if it is not seeded, or if it has been purged for maintenance
    _query(indexName, libraryId, visibility, {'start': opts.start, 'limit': opts.limit, 'rebuildIfNecessary': true}, function(err, rows, nextToken) {
        if (err) {
            return callback(err);
        }

        var numResults = 0;

        // For repair-on-read, we will keep track of duplicate resourceIds and delete duplicates after
        var rankedResourceIdsToDelete = [];

        // Because of the repair-on-read the nextToken might now be invalid so we need to recalculate it
        var newNextToken = null;

        var resourceIds = {};
        var entries = [];
        _.each(rows, function(rawEntry) {
            numResults++;
            _splitRankedResourceId(rawEntry.rankedResourceId, function(resourceId, rank) {
                if (!resourceIds[resourceId]) {
                    resourceIds[resourceId] = true;
                    entries.push({'resourceId': resourceId, 'value': rawEntry.value});
                    newNextToken = rawEntry.rankedResourceId;
                } else {
                    rankedResourceIdsToDelete.push(rawEntry.rankedResourceId);
                }
            });
        });

        // If the runPagedColumnQuery method didn't return a next token, it means there are no more items to retrieve
        if (!nextToken) {
            newNextToken = null;
        }

        if (!_.isEmpty(rankedResourceIdsToDelete)) {
            // There were duplicates, delete them asynchronously
            var bucketKey = _createBucketKey(indexName, libraryId, visibility);
            var deleteQueries = _.map(rankedResourceIdsToDelete, function(rankedResourceId) {
                return {
                    'query': 'DELETE FROM "LibraryIndex" WHERE "bucketKey" = ? AND "rankedResourceId" = ?',
                    'parameters': [bucketKey, rankedResourceId]
                };
            });

            log().warn({
                'indexName': indexName,
                'libraryId': libraryId,
                'visibility': visibility,
                'duplicateKeys': rankedResourceIdsToDelete
            }, 'Removing duplicate keys from a library index');

            Cassandra.runBatchQuery(deleteQueries);
        }

        return callback(null, entries, newNextToken);
    });
};

/**
 * Purge all the items out of a given library index. This will force the library index to be rebuilt the next time the library is queried
 *
 * @param  {String}     indexName       The name of the library index to purge
 * @param  {String}     libraryId       The id of the library of this type to purge
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var purge = module.exports.purge = function(indexName, libraryId, callback) {
    // Build the queries that will purge all the index buckets to start fresh
    var purgeIndexQueries = _.map(visibilityMasks, function(mask, visibility) {
        return {
            'query': 'DELETE FROM "LibraryIndex" WHERE "bucketKey" = ?',
            'parameters': [_createBucketKey(indexName, libraryId, visibility)]
        };
    });

    log().trace({'indexName': indexName, 'libraryId': libraryId}, 'Purging library index');

    Cassandra.runBatchQuery(purgeIndexQueries, callback);
};

/**
 * Determine if the given library index is stale, in other words it has not been built since the last time it was purged
 *
 * @param  {String}     indexName           The name of the library index to check
 * @param  {String}     libraryId           The id of the library of this type to check
 * @param  {String}     visibility          The visibility of the library bucket to check
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.isStale    Whether or not the specified library index is currently stale
 */
var isStale = module.exports.isStale = function(indexName, libraryId, visibility, callback) {
    // Select both the high and low slug column from the library
    var cql = 'SELECT "value" FROM "LibraryIndex" WHERE "bucketKey" = ? AND "rankedResourceId" IN ?';
    Cassandra.runQuery(cql, [_createBucketKey(indexName, libraryId, visibility), [SLUG_HIGH, SLUG_LOW]], function(err, rows) {
        if (err) {
            return callback(err);
        }

        // If we got exactly 2 rows, it means that both the high and low slug were there, so the
        // library index is recent
        return callback(null, (rows.length !== 2));
    });
};

/**
 * List items from a library index
 *
 * @param  {String}     indexName                   The name of the index whose items to fetch
 * @param  {String}     libraryId                   The id of the library whose items to fetch for this index type
 * @param  {String}     visibility                  The visibility of the library to fetch
 * @param  {Object}     opts                        Additional parameters for the query
 * @param  {String}     opts.start                  The starting point from which to start fetching library items. To start from the highest-ranked item, this should be the empty string
 * @param  {Number}     opts.limit                  The maximum number of library items to return
 * @param  {Boolean}    [opts.rebuildIfNecessary]   Whether or not to rebuild the library index if it is detected that it is not "fresh" (i.e., it has not been rebuilt since the last purge). Default: `false`
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error that occurred, if any
 * @param  {Object[]}   callback.entries            The library value keys that were found in this query
 * @param  {String}     callback.nextToken          The value that can be used as the `opts.start` parameter for the next query to get the next page of items
 * @api private
 */
var _query = function(indexName, libraryId, visibility, opts, callback) {
    // Select one additional entry to account for the slug that we will select if we have not specified a start parameter
    var internalLimit = opts.limit;
    if (!opts.start) {
        internalLimit++;
    }

    // Query the items from cassandra
    var bucketKey = _createBucketKey(indexName, libraryId, visibility);
    Cassandra.runPagedQuery('LibraryIndex', 'bucketKey', bucketKey, 'rankedResourceId', opts.start, internalLimit, {'reversed': true}, function(err, rows, nextToken) {
        if (err) {
            return callback(err);
        } else if (_isStaleLibraryIndex(opts.start, internalLimit, rows)) {
            if (opts.rebuildIfNecessary) {
                // If we've specified to rebuild a stale index, rebuild it and try to query again
                return _rebuildAndQuery(indexName, libraryId, visibility, opts, callback);
            } else {
                // If we have not specified to rebuild and this index is stale, then warn that something funny is going on
                log().warn({
                    'indexName': indexName,
                    'libraryId': libraryId,
                    'visibility': visibility,
                    'opts': opts,
                    'entries': rows
                }, 'Attempted to query a stale library without trying to rebuild the index');
            }
        }

        var result = null;
        try {
            result = _adjustColumnsForSlugs(indexName, libraryId, opts.start, opts.limit, rows, nextToken);
        } catch (ex) {
            // There was an issue parsing the data, result with an error
            return callback({'err': 500, 'msg': 'An unexpected error occurred parsing library data'});
        }

        log().trace({
            'query': {
                'indexName': indexName,
                'libraryId': libraryId,
                'visibility': visibility,
                'opts': opts
            },
            'result': result
        }, 'Queried library index');

        return callback(null, result.entries, result.nextToken);
    });
};

/**
 * Purge, build, and query the specified library
 *
 * @param  {String}     indexName               The name of the index whose items to fetch
 * @param  {String}     libraryId               The id of the library whose items to fetch for this index type
 * @param  {String}     visibility              The visibility of the library to fetch
 * @param  {Object}     opts                    Additional parameters for the query
 * @param  {String}     opts.start              The starting point from which to start fetching library items. To start from the highest-ranked item, this should be the empty string
 * @param  {Number}     opts.limit              The maximum number of library items to return
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {String[]}   callback.keys           The library value keys that were found in this query
 * @param  {String}     callback.nextToken      The value that can be used as the `opts.start` parameter for the next query to get the next page of items
 * @api private
 */
var _rebuildAndQuery = function(indexName, libraryId, visibility, opts, callback) {
    // Completely delete and rebuild the library index
    _rebuild(indexName, libraryId, function(err) {
        if (err) {
            return callback(err);
        }

        // We've just rebuilt. Query, but *do not* rebuild again if it still looks like we aren't
        // rebuilt -- this would probably be a bug. We don't want any potential bugs to result in an
        // infinite loop of rebuilding and querying. Ouch!
        _query(indexName, libraryId, visibility, {'start': opts.start, 'limit': opts.limit}, callback);
    });
};

/**
 * Purge and build the specified library
 *
 * @param  {String}     indexName       The name of the index whose items to rebuild
 * @param  {String}     libraryId       The id of the library whose items to rebuild
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 * @api private
 */
var _rebuild = function(indexName, libraryId, callback) {
    purge(indexName, libraryId, function(err) {
        if (err) {
            return callback(err);
        }

        // Build the queries to seed all of the visibility buckets with the low and high slugs
        var seedLibraryQueries = [];
        _.each(AuthzConstants.visibility.ALL_PRIORITY, function(visibility) {
            var bucketKey = _createBucketKey(indexName, libraryId, visibility);
            seedLibraryQueries.push(
                {
                    'query': 'INSERT INTO "LibraryIndex" ("bucketKey", "rankedResourceId", "value") VALUES (?, ?, ?)',
                    'parameters': [bucketKey, SLUG_HIGH, JSON.stringify(DEFAULT_VALUE)]
                },
                {
                    'query': 'INSERT INTO "LibraryIndex" ("bucketKey", "rankedResourceId", "value") VALUES (?, ?, ?)',
                    'parameters': [bucketKey, SLUG_LOW, JSON.stringify(DEFAULT_VALUE)]
                }
            );
        });

        // Add the slugs into the library index so we don't thrash it with rebuilds. The index will temporarily be empty
        // or incomplete while the rebuild process takes place
        Cassandra.runBatchQuery(seedLibraryQueries, function(err) {
            if (err) {
                return callback(err);
            }

            // Build the index after it has been destroyed and seeded
            return _build(indexName, libraryId, callback);
        });
    });
};

/**
 * Build the specified library using the pageResources method of the registered index
 *
 * @param  {String}     indexName       The name of the index whose items to build
 * @param  {String}     libraryId       The id of the library whose items to build
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 * @api private
 */
var _build = function(indexName, libraryId, callback, _nextToken) {
    if (_nextToken === null) {
        return callback();
    }

    var registeredIndex = LibraryRegistry.getRegisteredLibraryIndex(indexName);
    if (!registeredIndex) {
        return callback();
    }

    registeredIndex.pageResources(libraryId, _nextToken, 100, function(err, entries, nextToken) {
        if (err) {
            return callback(err);
        }

        nextToken = nextToken || null;

        var indexEntries = _.map(entries, function(entry) {
            return {
                'libraryId': libraryId,
                'rank': entry.rank,
                'resourceId': entry.resource.id,
                'value': entry.value,
                'visibility': LibraryAuthz.resolveLibraryBucketVisibility(libraryId, entry.resource)
            };
        });

        // Insert all the index entries
        _insert(indexName, indexEntries, function(err) {
            if (err) {
                log().warn({
                    'err': err,
                    'indexName': indexName,
                    'libraryId': libraryId
                }, 'Error trying to index a batch of resources');
            }

            // Recursively repeat with the nextToken to get the next batch
            return _build(indexName, libraryId, callback, nextToken);
        });
    });
};

/**
 * Insert a list of index entries into a library index
 *
 * @param  {String}     indexName                   The name of the index into which to insert the entries
 * @param  {Object[]}   indexEntries                The entries to insert into the index
 * @param  {String}     indexEntries[i].libraryId   The id the library in which to insert this item
 * @param  {String}     indexEntries[i].resourceId  The id of the resource to insert into the library with the specified id
 * @param  {String}     indexEntries[i].rank        The rank of the resource in the specified library
 * @param  {Object}     indexEntries[i].value       The value of the index entry for the resource in the specified library
 * @param  {String}     indexEntries[i].visibility  The visibility bucket in which to insert the item into the library (i.e., **not** the resource visibility, the **target bucket**, which is not always the same)
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error that occurred, if any
 * @api private
 */
var _insert = function(indexName, indexEntries, callback) {
    var queries = [];
    _.each(indexEntries, function(indexEntry) {
        // Get the index entry key (rankedResourceId) and the index entry value (JSON stringified value)
        var rankedResourceId = _createRankedResourceId(indexEntry.resourceId, indexEntry.rank);
        var value = (_.isNull(indexEntry.value) || _.isUndefined(indexEntry.value)) ? DEFAULT_VALUE : indexEntry.value;

        // Stringify every value so that it can be safely parsed on the way back out
        value = JSON.stringify(value);

        // If the item's target index is private, we only put it into the private visibility bucket.
        // If it is loggedin, we put it into private and loggedin. If it is public, we put it into
        // all 3. This works out to slicing the visibility priorities from the target visibility
        // bucket and upward, inclusive
        var visibilityIndex = AuthzConstants.visibility.ALL_PRIORITY.indexOf(indexEntry.visibility);
        var visibilitiesToInsert = AuthzConstants.visibility.ALL_PRIORITY.slice(visibilityIndex);

        // Add each visibility bucket insert into the aggregated list of queries
        _.each(visibilitiesToInsert, function(visibility) {
            queries.push({
                'query': 'INSERT INTO "LibraryIndex" ("bucketKey", "rankedResourceId", "value") VALUES (?, ?, ?)',
                'parameters': [_createBucketKey(indexName, indexEntry.libraryId, visibility), rankedResourceId, value]
            });
        });
    });

    log().trace({
        'indexName': indexName,
        'indexEntries': indexEntries
    }, 'Inserting index entries into library index');

    Cassandra.runBatchQuery(queries, callback);
};

/**
 * Determine if the library query (provided by the cassandra `columns`) is deemed to be stale.
 *
 * @param  {String}     start       The start parameter that was specified to result in this `rows` result
 * @param  {Number}     limit       The limit that was used for this `rows` result
 * @param  {Row[]}      rows        The cassandra rows that represents the result of the library index query
 * @return {Boolean}                `true` if the rows indicate that the library index is stale, `false` otherwise
 * @api private
 */
var _isStaleLibraryIndex = function(start, limit, rows) {
    var slugHighColumn = _.find(rows, function(row) {
        return (row.get('rankedResourceId') === SLUG_HIGH);
    });

    var slugLowColumn = _.find(rows, function(row) {
        return (row.get('rankedResourceId') === SLUG_LOW);
    });

    if (!start && !slugHighColumn) {
        // If we didn't supply a start parameter and did not get the upper bound limiter, we need to
        // refresh the index because it indicates this index has been purged and not yet rebuilt
        return true;
    } else if (rows.length < limit && !slugLowColumn) {
        // If we exhausted the entries and the last entry wasn't the low-bound slug, then we have a
        // purged index and need to rebuild it
        return true;
    }

    // Otherwise, this library index is deemed to be fresh
    return false;
};

/**
 * Given a list of rows that were queried from a library index, adjust it for the fact that:
 *
 *  * The query had slugs (i.e., SLUG_HIGH, SLUG_LOW) to determine the "freshness" of the library; and
 *  * The query incremented the limit by 1 to account for potentially selecting the SLUG_HIGH value; and
 *  * The last item may be a SLUG_LOW, in which case we've exhausted the items in the library
 *
 * The result is an object with keys:
 *
 *  * `entries`:    The entries that were selected in the row
 *  * `nextToken`:  The value to use as the `start` parameter for the next query to get the next set of entries from this library
 *
 * @param  {String}     indexName   The name of the index whose data is being fetched
 * @param  {String}     libraryId   The id of the library whose data is being fetched
 * @param  {String}     start       The value that was used as the `start` when querying the library that produced this row
 * @param  {Number}     limit       The **actual** limit that we wanted, not the potentially incremented limit to account for slugs
 * @param  {Row[]}      rows        The list of cassandra rows that were returned from the query
 * @param  {String}     nextToken   The nextToken that was returned by the cassandra query
 * @return {Object}                 An object holding the selected entries and the real nextToken. See method summary for more information
 * @throws {Error}                  Logs and throws an exception if any of the rows contained values that were not parse-able to JSON
 * @api private
 */
var _adjustColumnsForSlugs = function(indexName, libraryId, start, limit, rows, nextToken) {
    var result = {
        'entries': [],
        'nextToken': nextToken
    };

    _.each(rows, function(row) {
        var rankedResourceId = row.get('rankedResourceId');
        var value = null;

        // Parse the assigned the value, logging and exception if it fails
        try {
            value = JSON.parse(row.get('value'));
        } catch (err) {
            log().error({
                'err': err,
                'indexName': indexName,
                'libraryId': libraryId,
                'rankedResourceId': rankedResourceId,
                'value': value
            }, 'An error occurred trying to parse a library value into JSON');
            throw err;
        }

        if (rankedResourceId === SLUG_LOW) {
            // If we hit the low slug, it means we actually exhausted our list. Simply ignore this
            // entry, but we can set nextToken to `null` to indicate we have exhausted the entries
            result.nextToken = null;
        } else if (rankedResourceId !== SLUG_HIGH) {
            // We have found an actual entry, push it into the results
            result.entries.push({
                'rankedResourceId': rankedResourceId,
                'value': value
            });
        }
    });

    // If there were additional items selected, knock them off the end according to the limit
    if (result.entries.length > limit) {
        result.entries = result.entries.slice(0, limit);
        if (result.nextToken) {
            // If the nextToken was previously specified, adjust it to the new nextToken as a result of this slice
            result.nextToken = _.last(result.entries).rankedResourceId;
        }
    }

    return result;
};

/**
 * Create the storage key that tracks the items in the index with key `indexKey` and name `bucketName`
 *
 * It is of the format: <indexKey>#<bucketName>
 *
 * @param  {String}     indexName   The name of the index
 * @param  {String}     indexKey    The key of the index under this name
 * @param  {String}     bucketName  The name of the bucket in the bucket key
 * @return {String}                 The bucket key
 * @api private
 */
var _createBucketKey = function(indexName, indexKey, bucketName) {
    return util.format('%s#%s#%s', indexName, indexKey, bucketName);
};

/**
 * Create the value key (i.e., key of column name which stores the index value) for the given
 * resource and rank.
 *
 * @param  {String}         resourceId  The id of the resource
 * @param  {String|Number}  [rank]      The rank of the resource in the library. If unspecified, will default to 0
 * @return {String}                     The key to use as the column name in the index
 * @api private
 */
var _createRankedResourceId = function(resourceId, rank) {
    rank = rank || 0;
    return util.format('%s#%s', rank, resourceId);
};

/**
 * Given a value key (as created from `_createRankedResourceId`) into its rank and resourceId.
 *
 * @param  {String}     rankedResourceId        The rankedResourceId to split
 * @param  {Function}   callback                Standard callback function
 * @param  {String}     callback.resourceId     The id of the resource in the rankedResourceId
 * @param  {String}     callback.rank           The rank (string representation of the number if it was a number) of the resourceKey in the index
 * @api private
 */
var _splitRankedResourceId = function(rankedResourceId, callback) {
    var parts = rankedResourceId.split('#');
    return callback(parts.slice(1).join('#'), parts[0]);
};
