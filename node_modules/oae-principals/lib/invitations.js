/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var util = require('util');

var AuthzUtil = require('oae-authz/lib/util');
var Context = require('oae-context').Context;
var Invitation = require('oae-authz/lib/invitations/model').Invitation;
var ResourceActions = require('oae-resource/lib/actions');
var ResourceConstants = require('oae-resource/lib/constants').ResourceConstants;

var PrincipalsConstants = require('oae-principals/lib/constants').PrincipalsConstants;
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var PrincipalsEmitter = require('oae-principals/lib/internal/emitter');
var PrincipalsUtil = require('oae-principals/lib/util');

var log = require('oae-logger').logger('oae-principals-invitations');

/*!
 * When an invitation is accepted, pass on the events to update group members and then feed back the
 * group resources into the event emitter
 */
ResourceActions.when(ResourceConstants.events.ACCEPTED_INVITATION, function(ctx, invitationHashes, memberChangeInfosByResourceId, inviterUsersById, callback) {
    // Filter the invitations and changes down to only group invitations
    var groupIds = _.chain(memberChangeInfosByResourceId)
        .keys()
        .filter(AuthzUtil.isGroupId)
        .value();
    if (_.isEmpty(groupIds)) {
        return callback();
    }

    // Note that some of these group ids could be folder authz ids. Therefore we need to limit to
    // only actual group resources that come from this query
    PrincipalsDAO.getPrincipals(groupIds, null, function(err, groupsById) {
        if (err) {
            log().warn({
                'err': err,
                'groupIds': groupIds
            }, 'An error occurred while getting groups to update group libraries after an invitation was accepted');
            return callback();
        }

        // Filter out soft-deleted groups
        var groups = _.chain(groupsById)
            .values()
            .filter(function(group) {
                return (!group.deleted);
            })
            .value();
        if (_.isEmpty(groups)) {
            return callback();
        }

        groupIds = _.pluck(groups, 'id');

        // Touch all the group last modified timestamps who are having an invitation accepted
        // for them
        _touchAllGroups(groups, function(updatedGroupsById) {

            // Invoke the "accept invitation" handler with the resources when we have them. We
            // invoke this after the get principals call for test synchronization
            callback(null, _.values(updatedGroupsById));

            // Fire members update tasks for each group
            _.each(groups, function(group) {
                var updatedGroup = updatedGroupsById[group.id];
                if (!updatedGroup) {
                    return;
                }

                var invitationHash = _.findWhere(invitationHashes, {'resourceId': group.id});
                var inviterUser = inviterUsersById[invitationHash.inviterUserId];

                var invitationCtx = Context.fromUser(inviterUser);
                var invitation = Invitation.fromHash(invitationHash, updatedGroup, inviterUser);
                var memberChangeInfo = memberChangeInfosByResourceId[group.id];

                return PrincipalsEmitter.emit(PrincipalsConstants.events.UPDATED_GROUP_MEMBERS, invitationCtx, updatedGroup, group, memberChangeInfo, {'invitation': invitation});
            });
        });
    });
});

/**
 * Update the last modified timestamp of all the specified groups
 *
 * @param  {Group[]}    groups                          The groups whose last modified timestamps to touch
 * @param  {Function}   callback                        Standard callback function
 * @param  {Object}     callback.err                    An error that occurred, if any
 * @param  {Object}     callback.updatedGroupsById      The updated group profiles, keyed by group id
 * @api private
 */
var _touchAllGroups = function(groups, callback) {
    var updatedGroupsById = {};
    var _done = _.chain(groups)
        .size()
        .after(function() {
            return callback(updatedGroupsById);
        })
        .value();

    _.each(groups, function(group) {
        PrincipalsUtil.touchLastModified(group, function(err, updatedGroup) {
            if (err) {
                log().warn({
                    'err': err,
                    'groupId': group.id
                }, 'An error occurred while updating group libraries after invitation was accepted');
            }

            updatedGroupsById[group.id] = updatedGroup;
            return _done();
        });
    });
};
