/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var events = require('events');
var util = require('util');

var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzAPI = require('oae-authz');
var ContentAPI = require('oae-content');
var ContentConstants = require('oae-content/lib/constants').ContentConstants;
var ContentDAO = require('oae-content/lib/internal/dao');
var LibraryAPI = require('oae-library');
var log = require('oae-logger').logger('oae-folders-api');
var OaeUtil = require('oae-util/lib/util');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var PrincipalsUtil = require('oae-principals/lib/util');
var Validator = require('oae-util/lib/validator').Validator;

var FoldersAuthz = require('./authz');
var FoldersFoldersLibrary = require('./internal/foldersLibrary');
var FoldersConfig = require('oae-config').config('oae-folders');
var FoldersConstants = require('./constants').FoldersConstants;
var FoldersContentLibrary = require('./internal/contentLibrary');
var FoldersDAO = require('./internal/dao');

// When updating folders in a principal folders library, update at most once every hour to
// avoid thrashing the libraries with updates and causing duplicates
var LIBRARY_UPDATE_THRESHOLD_SECONDS = 3600;

// TODO: Search
// TODO: Implement / test library search
// TODO: Activity
// TODO: Implement removing folder from library
// TODO: Implement gathering stats for content item visibility when folder visibility is changed from open to less open

/*!
 * ### Events
 *
 * * `createdFolder(ctx, folder, members)`: A new folder was created
 * * `updatedFolder(ctx, oldFolder, newFolder)`: A folder was updated
 * * `updatedFolderMembers(ctx, folder, memberUpdates, newMemberIds, updatedMemberIds, removedMemberIds)`: The members of a folder have been updated
 * * `addedContentItems(ctx, folder, contentItems)`: One or more content item was added to a folder
 */
var FoldersAPI = module.exports = new events.EventEmitter();

/**
 * Create a folder
 *
 * @param  {Context}        ctx                     The context of the current request
 * @param  {String}         displayName             The display name of the folder
 * @param  {String}         [description]           The description of the folder. By default, a folder will have no description
 * @param  {String}         [visibility]            The visibility of the folder. One of `AuthzConstants.visibility`. This will default to a value configured for the tenant
 * @param  {Object}         [members]               An object whose keys are principal ids and values are the role they should have on the folder. By default only the creator of the folder will be a manager
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Folder}         callback.folder         The folder that was created
 */
var createFolder = module.exports.createFolder = function(ctx, displayName, description, visibility, members, callback) {
    visibility = visibility || FoldersConfig.getValue(ctx.tenant().alias, 'visibility', 'folder');
    members = members || {};

    var allVisibilities = _.values(AuthzConstants.visibility);

    // Verify basic properties
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Anonymous users cannot create a folder'}).isLoggedInUser(ctx);
    validator.check(displayName, {'code': 400, 'msg': 'Must provide a display name for the folder'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'A display name can be at most 1000 characters long'}).isShortString();
    if (description) {
        validator.check(description, {'code': 400, 'msg': 'A description can be at most 10000 characters long'}).isMediumString();
    }
    validator.check(visibility, {'code': 400, 'msg': 'An invalid folder visibility option has been provided. Must be one of: ' + allVisibilities.join(', ')}).isIn(allVisibilities);

    // Verify each memberId and role is valid
    _.each(members, function(role, memberId) {
        validator.check(memberId, {'code': 400, 'msg': util.format('The memberId "%s" is not a valid member id', memberId)}).isPrincipalId();
        validator.check(role, {'code': 400, 'msg': util.format('The role "%s" is not a valid member role for a folder', role)}).isIn(FoldersConstants.roles.ALL_PRIORITY);
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Reject the operation if it will violate tenant privacy boundaries
    var principalIds = _.keys(members);
    PrincipalsDAO.getPrincipals(principalIds, null, function(err, principals) {
        if (err) {
            return callback(err);
        } else if (_.keys(principals).length !== principalIds.length) {
            return callback({'code': 400, 'msg': 'One or more target members being granted access do not exist'});
        }

        principals = _.values(principals);
        AuthzAPI.canInteract(ctx, ctx.tenant().alias, principals, function(err, canInteract, illegalPrincipalIds) {
            if (err) {
                return callback(err);
            } else if (!_.isEmpty(illegalPrincipalIds)) {
                return callback({'code': 400, 'msg': 'One or more target members being granted access are not authorized to become members on this folder'});
            }

            // Persist the folder
            FoldersDAO.createFolder(ctx.user().id, displayName, description, visibility, function(err, folder) {
                if (err) {
                    return callback(err);
                }

                // Set the current user as a manager and apply the folder roles
                members[ctx.user().id] = FoldersConstants.roles.MANAGER;
                AuthzAPI.updateRoles(folder.groupId, members, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Insert the folder into the folders library of all the members
                    var principalIds = _.keys(members);
                    FoldersFoldersLibrary.insert(principalIds, folder, function(err) {
                        if (err) {
                            log(ctx).warn({
                                'err': err,
                                'principalIds': principalIds,
                                'folder': folder
                            }, 'An error occurred while inserting a created folder into member libraries');
                        }

                        FoldersAPI.emit(FoldersConstants.events.CREATED_FOLDER, ctx, folder, members);
                        return callback(null, folder);
                    });
                });
            });
        });
    });
};

/**
 * Get a folder by its id
 *
 * @param  {Context}        ctx                 The context of the current request
 * @param  {String}         folderId            The id of the folder to get
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Folder}         callback.folder     The folder identified by the given id
 */
var getFolder = module.exports.getFolder = function(ctx, folderId, callback) {
    var validator = new Validator();
    validator.check(folderId, {'code': 400, 'msg': util.format('The folder id "%s" is not a valid resource id', folderId)}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the folder from storage to use for permission checks
    _getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Ensure the current user can view the folder
        FoldersAuthz.canViewFolderProfile(ctx, folder, function(err, canView) {
            if (err) {
                return callback(err);
            } else if (!canView) {
                return callback({'code': 401, 'msg': 'You are not authorized to view this folder'});
            }

            // Return the folder to the user
            return callback(null, folder);
        });
    });
};

/**
 * Get the full folder profile, which includes additional information about the relation of the
 * current user to the folder
 *
 * @param  {Context}        ctx                             The context of the current request
 * @param  {String}         folderId                        The id of the folder whose full profile to get
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Folder}         callback.folder                 The basic profile of the folder, with some additional information provided
 * @param  {Boolean}        callback.folder.canManage       Whether or not the current user can manage the folder
 * @param  {Boolean}        callback.folder.canShare        Whether or not the current user can share the folder
 * @param  {Boolean}        callback.folder.canAddItem      Whether or not the current user can add a content item to the folder
 * @param  {User}           callback.folder.createdBy       The basic profile of the user who created the folder
 */
var getFullFolderProfile = module.exports.getFullFolderProfile = function(ctx, folderId, callback) {
    var validator = new Validator();
    validator.check(folderId, {'code': 400, 'msg': util.format('The folder id "%s" is not a valid resource id', folderId)}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the folder from storage to use for permissions checks
    _getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        FoldersAuthz.resolveEffectiveFolderAccess(ctx, folder, function(err, canView, canManage, canShare, canAddItem) {
            if (err) {
                return callback(err);
            } else if (!canView) {
                return callback({'code': 401, 'msg': 'You are not authorized to view this folder'});
            }

            folder.canManage = canManage;
            folder.canShare = canShare;
            folder.canAddItem = canAddItem;

            // Populate the creator of the folder
            PrincipalsUtil.getPrincipal(ctx, folder.createdBy, function(err, creator) {
                if (err) {
                    log(ctx).warn({
                        'err': err,
                        'userId': folder.createdBy,
                        'folderId': folder.id
                    }, 'An error occurred getting the creator of a folder. Proceeding with empty user for full profile');
                }

                if (creator) {
                    folder.createdBy = creator;
                }

                return callback(null, folder);
            });
        });
    });
};

/**
 * List the members of a folder
 *
 * @param  {Context}        ctx                             The context of the current request
 * @param  {String}         folderId                        The id of the folder whose members to get
 * @param  {String}         [start]                         A token that indicates where in the list to start returning members. Use the `nextToken` result from this method to determine where to start the next page of members
 * @param  {Number}         [limit]                         The maximum number of members to return
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Object[]}       callback.results                An array of objects indicating the members of the folder and their roles
 * @param  {User|Group}     callback.results[i].profile     The basic profile of the user or group who is a member of the folder
 * @param  {String}         callback.results[i].role        The role of the user or group on the folder
 * @param  {String}         callback.nextToken              The token to use for the next `start` value in order to get the next page of members. If this value is `null`, it indicates that there are no more members to page
 */
var getFolderMembers = module.exports.getFolderMembers = function(ctx, folderId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(folderId, {'code': 400, 'msg': 'A folder id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getFolder(ctx, folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Get the discussion members
        AuthzAPI.getAuthzMembers(folder.groupId, start, limit, function(err, memberRoles, nextToken) {
            if (err) {
                return callback(err);
            }

            // Get the basic profiles for all of these principals
            PrincipalsUtil.getPrincipals(ctx, _.pluck(memberRoles, 'id'), function(err, memberProfiles) {
                if (err) {
                    return callback(err);
                }

                // Merge the member profiles and roles into a single object
                var memberList = _.map(memberRoles, function(memberRole) {
                    return {
                        'profile': memberProfiles[memberRole.id],
                        'role': memberRole.role
                    };
                });

                return callback(null, memberList, nextToken);
            });
        });
    });
};

/**
 * Share a folder with a set of users and groups. All users and groups who are shared the
 * folder will be given the `member` role. However, if they already have a different role, the
 * existing role will not be changed
 *
 * @param  {Context}    ctx             The context of the current request
 * @param  {String}     folderId        The id of the folder to share
 * @param  {String[]}   principalIds    The ids of the users and groups with whom to share the folder
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var shareFolder = module.exports.shareFolder = function(ctx, folderId, principalIds, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to share a folder'}).isLoggedInUser(ctx);
    validator.check(folderId, {'code': 400, 'msg': 'A valid folder id must be provided'}).isResourceId();
    validator.check(principalIds.length, {'code': 400, 'msg': 'The folder must at least be shared with 1 user or group'}).min(1);
    _.each(principalIds, function(principalId) {
        validator.check(principalId, {'code': 400, 'msg': 'The member id: ' + principalId + ' is not a valid member id'}).isPrincipalId();
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure the folder exists
    _getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Build what the membership updates would be
        var roleChanges = {};
        _.each(principalIds, function(principalId) {
            roleChanges[principalId] = FoldersConstants.roles.VIEWER;
        });

        // Determine which members are actually newly added to this folder. We can only add those
        AuthzAPI.computeMemberRolesAfterChanges(folder.groupId, roleChanges, function(err, membershipAfterChanges, newMemberIds) {
            if (err) {
                return callback(err);
            } else if (_.isEmpty(newMemberIds)) {
                // If there are no new members being added from this share, we can just
                // short-circuit the process
                return callback();
            }

            // Validate role and tenant boundary permissions for the current user to share the folder with the target users
            var allMemberIdsBeforeShare = _.chain(membershipAfterChanges).keys().difference(newMemberIds).value();
            FoldersAuthz.canShareFolder(ctx, folder, newMemberIds, function(err, canShare, illegalPrincipalIds) {
                if (err) {
                    return callback(err);
                } else if (!_.isEmpty(illegalPrincipalIds)) {
                    return callback({'code': 400, 'msg': 'One or more target members are not authorized to become members on this folder'});
                } else if (!canShare) {
                    return callback({'code': 401, 'msg': 'You are not authorized to share this folder'});
                }

                // Apply the permissions update
                AuthzAPI.updateRoles(folder.groupId, roleChanges, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Update the libraries that contain this folder, but only if we have not already updated it within the threshold. We provide `null` as the old last modified
                    // timestamp to trigger the update function to update the folder timestamp for us
                    OaeUtil.invokeIfNecessary(_testLibraryUpdateThreshold(folder), FoldersFoldersLibrary.update, allMemberIdsBeforeShare, folder, null, function(err, updatedFolder) {
                        if (err) {
                            log(ctx).warn({
                                'err': err,
                                'folderId': folder.id,
                                'numberOfPrincipalIds': allMemberIdsBeforeShare.length
                            }, 'An error occurred while updating folder in member folder libraries after being shared');
                        }

                        // If the folder was updated for user libraries
                        folder = updatedFolder || folder;

                        // Insert the folder into the user libraries that we just shared with
                        FoldersFoldersLibrary.insert(newMemberIds, folder, function(err) {
                            if (err) {
                                log(ctx).warn({
                                    'err': err,
                                    'folderId': folder.id,
                                    'principalIds': newMemberIds
                                }, 'An error occurred while inserting a folder to in member folder libraries after being shared');
                            }

                            FoldersAPI.emit(FoldersConstants.events.UPDATED_FOLDER_MEMBERS, ctx, folder, roleChanges, newMemberIds);
                            return callback();
                        });
                    });
                });
            });
        });
    });
};

/**
 * Set permissions to the folder. This is similar to sharing a folder, however rather than
 * only giving users and groups the `member` role, other roles can be applied and also users and
 * groups can be removed from the folder membership
 *
 * @param  {Context}    ctx                 The context of the current request
 * @param  {String}     folderId            The id of the folder whose permissions to set
 * @param  {Object}     permissionChanges   An object whose key is the user or group id to set on the folder, and the value is the role you wish them to have. If the role of a user is set to `false`, then it indicates to remove the user from the folder
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 */
var setFolderPermissions = module.exports.setFolderPermissions = function(ctx, folderId, permissionChanges, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to change folder permissions'}).isLoggedInUser(ctx);
    validator.check(folderId, {'code': 400, 'msg': 'A valid folder id must be provided'}).isResourceId();
    validator.check(null, {'code': 400, 'msg': 'Must specify at least one permission change to apply'}).isObject(permissionChanges);
    validator.check(_.keys(permissionChanges).length, {'code': 400, 'msg': 'You must specify at least one permission change'}).min(1);
    _.each(permissionChanges, function(role, principalId) {
        validator.check(principalId, {'code': 400, 'msg': 'The member id: ' + principalId + ' is not a valid member id'}).isPrincipalId();
        validator.check(role, {'code': 400, 'msg': 'The role change: ' + role + ' is not a valid value. Must either be a string, or false'}).isValidRoleChange();
        if (role) {
            validator.check(role, {'code': 400, 'msg': 'The role :' + role + ' is not a valid value. Must be one of: ' + FoldersConstants.roles.ALL_PRIORITY.join(', ') + '; or false'}).isIn(FoldersConstants.roles.ALL_PRIORITY);
        }
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the folder object, throwing an error if it doesn't exist, but not applying permissions checks
    _getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Ensure we are allowed to add the new members
        AuthzAPI.computeMemberRolesAfterChanges(folder.groupId, permissionChanges, function(err, membershipAfterChanges, newMemberIds, updatedMemberIds, removedMemberIds) {
            if (err) {
                return callback(err);
            }

            // Ensure the user is allowed to set the folder permissions
            FoldersAuthz.canSetFolderPermissions(ctx, folder, newMemberIds, function(err, canSetPermissions, illegalMemberIds) {
                if (err && err.code === 404) {
                    return callback({'code': 400, 'msg': 'One or more target members being granted access do not exist'});
                } else if (err) {
                    return callback(err);
                } else if (illegalMemberIds) {
                    // Ensures we don't violate tenant privacy boundaries
                    return callback({'code': 400, 'msg': 'One or more target members being granted access are not authorized to become members on this folder'});
                } else if (!canSetPermissions) {
                    // Ensures we have access to the folder
                    return callback({'code': 401, 'msg': 'You are not authorized to update the permissions of this folder'});
                } else if (!_.contains(_.values(membershipAfterChanges), FoldersConstants.roles.MANAGER)) {
                    // If the anticipated membership after these changes has no manager, bail out
                    return callback({'code': 400, 'msg': 'The requested change results in a folder with no managers'});
                }

                // All validation checks have passed, finally persist the role change and update the user libraries
                AuthzAPI.updateRoles(folder.groupId, permissionChanges, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Insert the folder into the libraries of new members
                    FoldersFoldersLibrary.insert(newMemberIds, folder, function(err) {
                        if (err) {
                            log(ctx).warn({
                                'err': err,
                                'folderId': folder.id,
                                'principalIds': newMemberIds
                            }, 'An error occurred while adding folder to member libraries after role assignment');
                        }

                        // Remove the folder from the libraries of removed members
                        FoldersFoldersLibrary.remove(removedMemberIds, folder, function(err) {
                            if (err) {
                                log(ctx).warn({
                                    'err': err,
                                    'folderId': folder.id,
                                    'principalIds': removedMemberIds
                                }, 'An error occurred while removing folder from member libraries after role removal');
                            }

                            // TODO: Test timestamp doesn't update with subsequent set-permissions
                            // For all current members, update the folder in their libraries. This includes
                            // members that were just added which is a bit of a waste, but easier to code
                            var updateMemberIds = _.keys(membershipAfterChanges);
                            OaeUtil.invokeIfNecessary(_testLibraryUpdateThreshold(folder), FoldersFoldersLibrary.update, updateMemberIds, folder, null, function(err) {
                                if (err) {
                                    log(ctx).warn({
                                        'err': err,
                                        'folderId': folder.id,
                                        'principalIds': updateMemberIds
                                    }, 'An error occurred while updating folder in member libraries after having permissions updated');
                                }

                                FoldersAPI.emit(FoldersConstants.events.UPDATED_FOLDER_MEMBERS, ctx, folder, _.pick(permissionChanges, updatedMemberIds), newMemberIds, updatedMemberIds, removedMemberIds);
                                return callback();
                            });
                        });
                    });
                });
            });
        });
    });
};

/**
 * Add a set of content items to a folder
 *
 * @param  {Context}    ctx             The context of the current request
 * @param  {String}     folderId        The id of the folder to which to add the content items
 * @param  {String[]}   contentIds      The ids of the content items to add to the folder
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var addContentItemsToFolder = module.exports.addContentItemsToFolder = function(ctx, folderId, contentIds, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be authenticated to be able to add an item to a folder'}).isLoggedInUser(ctx);
    validator.check(folderId, {'code': 400, 'msg': 'A valid folder id must be provided'}).isResourceId();
    validator.check(null, {'code': 400, 'msg': 'Must specify at least one content item to add'}).isArray(contentIds);
    validator.check(_.values(contentIds).length, {'code': 400, 'msg': 'You must specify at least one content item to add'}).min(1);

    // Ensure each content id is valid
    _.each(contentIds, function(contentId) {
        validator.check(contentId, {'code': 400, 'msg': util.format('The id "%s" is not a valid content id', contentId)}).isResourceId();
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the folder to which we're trying to add the content items
    _getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Get the content profiles of all items being added for permission checks
        ContentDAO.Content.getMultipleContentItems(contentIds, null, function(err, contentItems) {
            if (err) {
                return callback(err);
            }

            // Determine if the content items can be added to the folder
            FoldersAuthz.canAddItemsToFolder(ctx, folder, contentItems, function(err, canAddItem, illegalContentIds) {
                if (err) {
                    return callback(err);
                } else if (!canAddItem && illegalContentIds) {
                    return callback({'code': 400, 'msg': util.format('You are not authorized to add the following items to the folder: %s', illegalContentIds.join(', '))});
                } else if (!canAddItem) {
                    return callback({'code': 401, 'msg': 'You are not authorized to add items to this folder'});
                }

                // Add all the items to the folder
                _addContentItemsToFolder(folder, contentItems.slice(), function(err) {
                    if (err) {
                        return callback(err);
                    }

                    FoldersContentLibrary.insert(folder, contentItems, function(err) {
                        if (err) {
                            log(ctx).warn({
                                'err': err,
                                'folderId': folder.id,
                                'contentIds': _.pluck(contentItems, 'id')
                            }, 'An error occurred while inserting content items into a folder library');
                        }

                        FoldersAPI.emit(FoldersConstants.events.ADDED_CONTENT_ITEMS, ctx, folder, contentItems);
                        return callback();
                    });
                });
            });
        });
    });
};

/**
 * List a user or group library of folders
 *
 * @param  {Context}        ctx                     The context of the current request
 * @param  {String}         principalId             The id of the user or group whose library of folders to list
 * @param  {String}         [start]                 A token that indicates where in the list to start returning folders. Use the `nextToken` result from this method to determine where to start the next page of folders
 * @param  {Number}         [limit]                 The maximum number of folders to return
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Folder[]}       callback.folders        The list of folders
 * @param  {String}         callback.nextToken      The token to use for the next `start` value in order to get the next page of folders. If this value is `null`, it indicates that there are no more folders to page
 */
var getFoldersLibrary = module.exports.getFoldersLibrary = function(ctx, principalId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'A user or group id must be provided'}).isPrincipalId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the principal
    PrincipalsDAO.getPrincipal(principalId, function(err, principal) {
        if (err) {
            return callback(err);
        }

        // Determine which library visibility the current user should receive
        LibraryAPI.Authz.resolveTargetLibraryAccess(ctx, principal.id, principal.visibility, function(err, hasAccess, visibility) {
            if (err) {
                return callback(err);
            } else if (!hasAccess) {
                return callback({'code': 401, 'msg': 'You do not have have access to this library'});
            }

            // Get the folder ids from the library index
            FoldersFoldersLibrary.list(principal, visibility, {'start': start, 'limit': limit}, function(err, folderIds, nextToken) {
                if (err) {
                    return callback(err);
                }

                // Get the folder objects from the folderIds
                FoldersDAO.getFoldersByIds(folderIds, function(err, folders) {
                    if (err) {
                        return callback(err);
                    }

                    return callback(null, folders, nextToken);
                });
            });
        });
    });
};

/**
 * List the library of content items that have been added to a folder
 *
 * @param  {Context}        ctx                     The context of the current request
 * @param  {String}         folderId                The id of the folder whose content library to list
 * @param  {String}         [start]                 A token that indicates where in the list to start returning content items. Use the `nextToken` result from this method to determine where to start the next page of content items
 * @param  {Number}         [limit]                 The maximum number of content items to return
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Folder[]}       callback.contentItems   The list of content items in the folder library
 * @param  {String}         callback.nextToken      The token to use for the next `start` value in order to get the next page of content items. If this value is `null`, it indicates that there are no more content items to page
 */
var getFolderContentLibrary = module.exports.getFolderContentLibrary = function(ctx, folderId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(folderId, {'code': 400, 'msg': 'A folder id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the folder
    _getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Determine which library visibility the current user should receive
        LibraryAPI.Authz.resolveTargetLibraryAccess(ctx, folder.groupId, folder.visibility, function(err, hasAccess, visibility) {
            if (err) {
                return callback(err);
            } else if (!hasAccess) {
                return callback({'code': 401, 'msg': 'You do not have access to this folder'});
            }

            FoldersContentLibrary.list(folder, visibility, {'start': start, 'limit': limit}, function(err, contentIds, nextToken) {
                if (err) {
                    return callback(err);
                }

                ContentDAO.Content.getMultipleContentItems(contentIds, null, function(err, contentItems) {
                    if (err) {
                        return callback(err);
                    }

                    return callback(null, contentItems, nextToken);
                });
            });
        });
    });
};

/**
 * Recursively add the given list of content items to the given folder. This method is
 * destructive to the `contentItems` parameter as it iterates
 *
 * @param  {Folder}         folder          The folder to which to add the content items
 * @param  {Content[]}      contentItems    The content items to add to the folder
 * @param  {Function}       callback        Standard callback function
 * @param  {Object}         callback.err    An error that occurred, if any
 * @api private
 */
var _addContentItemsToFolder = function(folder, contentItems, callback) {
    if (_.isEmpty(contentItems)) {
        return callback();
    }

    var roleChange = {};
    roleChange[folder.groupId] = ContentConstants.roles.VIEWER;

    var contentItem = contentItems.pop();
    AuthzAPI.updateRoles(contentItem.id, roleChange, function(err) {
        if (err) {
            return callback(err);
        }

        return _addContentItemsToFolder(folder, contentItems, callback);
    });
};

/**
 * Get a folder from storage by its id
 *
 * @param  {String}     folderId        The id of the folder to get
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 * @api private
 */
var _getFolder = function(folderId, callback) {
    FoldersDAO.getFoldersByIds([folderId], function(err, folders) {
        if (err) {
            return callback(err);
        } else if (_.isEmpty(folders)) {
            return callback({'code': 404, 'msg': util.format('A folder with the id "%s" could not be found', folderId)});
        }

        return callback(null, folders[0]);
    });
};

/**
 * Given a folder, determine if sufficient time has passed since it's last update to re-order it
 * once again in user and group principal libraries
 *
 * @param  {Folder}     folder      The folder whose last modified date to test
 * @return {Boolean}                `true` if the folder can be updated in user and group libraries
 * @api private
 */
var _testLibraryUpdateThreshold = function(folder) {
    return (!folder.lastModified || (Date.now() - folder.lastModified) > (LIBRARY_UPDATE_THRESHOLD_SECONDS * 1000));
};
