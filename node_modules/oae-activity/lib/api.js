/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var AuthzAPI = require('oae-authz');
var AuthzUtil = require('oae-authz/lib/util');
var log = require('oae-logger').logger('oae-activity-api');
var MQ = require('oae-util/lib/mq');
var OAE = require('oae-util/lib/oae');
var OaeUtil = require('oae-util/lib/util');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var Redis = require('oae-util/lib/redis');
var TenantsAPI = require('oae-tenants');
var Validator = require('oae-authz/lib/validator').Validator;

var ActivityAggregator = require('./internal/aggregator');
var ActivityConfig = require('oae-config').config('oae-activity');
var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;
var ActivityDAO = require('./internal/dao');
var ActivityEmitter = require('./internal/emitter');
var ActivityNotifications = require('./internal/notifications');
var ActivityRegistry = require('./internal/registry');
var ActivityRouter = require('./internal/router');
var ActivityStream = require('oae-activity/lib/model').ActivityStream;
var ActivitySystemConfig = require('./internal/config');
var ActivityTransformer = require('./internal/transformer');

// Keeps track of whether or not the activity processing handler has been bound to the task queue
var boundWorker = false;

// Keeps track of the collection polling timer so that it may be cleared if activity processing is disabled
var collectionPollingTimer = null;

/**
 * ## ActivityAPI
 *
 * ### Events
 *
 *  * `deliveredActivities(routedActivities)` - Indicates activities have just been aggregated and delivered to an activity stream. The individual (unaggregated) persistent activities are provided.
 *  * `deliveredNotitifications(routedActivities)` - Indicates activities have just been aggregated and delivered to a notification stream. The individual (unaggregated) persistent activities are provided.
 */
var ActivityAPI = module.exports = ActivityEmitter;

/**
 * Refresh the activities configuration.
 *
 * @param  {Object}        [config]                            The object containing the configuration properties. See the `config.activity` object in the base `./config.js` for more information
 * @param  {Function}      [callback]                          Invoked when the configuration has been refreshed
 * @param  {Object}        [callback.err]                      An error that occurred, if any
 */
var refreshConfiguration = module.exports.refreshConfiguration = function(config, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Error refreshing activities configuration.');
        }
    };

    config = ActivitySystemConfig.refreshConfiguration(config);

    log().info({'config': config}, 'Refreshing activity configuration.');

    // Configure redis. Either uses the main connection pool, or a dedicated one if config.activity.redis was configured
    var redisClient = Redis.getClient();
    if (config.redis) {
        redisClient = Redis.createClientFromConfig(config.redis);
    }

    ActivityDAO.init(redisClient);

    // Reset the collection polling interval
    clearInterval(collectionPollingTimer);
    if (config.processActivityJobs && config.collectionPollingFrequency > 0) {
        var collectionPollingFrequencyInMs = config.collectionPollingFrequency * 1000;
        // Delegate to the aggregator to collect/aggregate all buckets
        collectionPollingTimer = setInterval(ActivityAggregator.collectAllBuckets, collectionPollingFrequencyInMs);
    }

    // Enable / Disable the worker binding, if necessary
    if (config.processActivityJobs && !boundWorker) {
        boundWorker = true;
        // Bind directly to the `routeActivity` router method
        return MQ.bind(ActivityConstants.mq.TASK_ACTIVITY, ActivityRouter.routeActivity, {'subscribe': {'prefetchCount': config.maxConcurrentRouters}}, callback);
    } else if (!config.processActivityJobs && boundWorker) {
        boundWorker = false;
        return MQ.unbind(ActivityConstants.mq.TASK_ACTIVITY, callback);
    } else {
        return callback();
    }
};

/*!
 * When the system starts shutting down, we want to stop the collecting polling timer so that no new collections
 * begin during the grace-time for active work to complete.
 */
OAE.registerPreShutdownHandler('oae-activity', null, function(callback) {
    log().info('Clearing the activity collection poller.');
    clearInterval(collectionPollingTimer);
    return callback();
});

/**
 * Registers an activity type with the application. While not all activities that are posted are required to be registered here,
 * this is how special activity behaviour, such as aggregation pivot points, may be specified.
 *
 * # `options.groupBy`
 *
 * The groupBy option allows the ability control how an activity is aggregated in an activity feed. It takes an array of objects
 * that specify all the "pivot points" on which activity entities will be collected. If an activity has no pivot points configured
 * for it with this option, then the activity will never aggregate and collect. However it will still be protected from duplicates
 * that occur within the aggregation window, by updating the existing activity and moving it to the top of the feed as the most
 * recent activity. Following are some configuration examples.
 *
 * ## Example 1
 *
 * ```javascript
 *  options.groupBy = [
 *      {
 *          'actor': true,
 *          'object': true
 *      }
 *  ];
 * ```
 *
 * This option specifies that if multiple activities of this type are delivered to a route that share the same "actor" and "object"
 * entity, they will be rolled up into one activity, where the "target" is a collection of the different targets involves in the
 * two activities. For example:
 *
 * Activity #1: Branden shared Syllabus with GroupA
 * Activity #2: Branden shared Syllabus with UserB
 *
 * If those activities are delivered to the same route within a configurable window of time, they will be grouped together as
 * something like "Branden shared syllabus with 2 users and groups".
 *
 * ## Example 2
 *
 * ```javascript
 *  options.groupBy = [
 *      {
 *          'actor': true,
 *          'object': true
 *      },
 *      {
 *          'actor': true,
 *          'target': true
 *      }
 *  ];
 * ```
 *
 * In this scenario, an activity will be pivoted on TWO different combinations of entities: actor+object and actor+target. This
 * enables the ability to maintain 2 separate aggregation branches for the activity. For example:
 *
 * Activity #1: Branden shared Syllabus with GroupA
 * Activity #2: Branden shared Syllabus with GroupB
 * Activity #3: Branden shared Introduction with Group A
 *
 * If those activities are delivered to the same route within a configurable window of time, they will be grouped together and
 * delivered as 2 separate aggregate activities (instead of the 3 activities):
 *
 * Aggregate #1: Branden shared 2 items with Group A
 * Aggregate #2: Branden shared Syllabus with 2 users and groups
 *
 * @param  {String}            activityType                                The type of activity to register
 * @param  {Object}            [options]                                   The options which specify how the activities of this type behave
 * @param  {Object[]}          [options.groupBy]                           An array of objects which specify on which entities to pivot to activate activity aggregates. If not specified, the activity will not aggregate
 * @param  {Boolean|Object}    [options.notifications]                     Configuration about how this activity should notify users that they happened
 * @param  {Boolean}           [options.notifications.email]               Whether or not a notification for this activity should send an email
 * @param  {String}            [options.notifications.emailTemplateModule] If sending an email, the module where the email template for this notification resides
 * @param  {String}            [options.notifications.emailTemplateId]     If sending an email, the id for the email template
 */
var registerActivityType = module.exports.registerActivityType = function(activityType, options) {
    ActivityRegistry.registerActivityType(activityType, options);
};

/**
 * Register an activity router. The activity router is responsible for determining where an activity should be routed based
 * on an entity that was involved in the activity. Additionally, it specifies how the the entity data can be propagated to
 * other routes to which the activity is delivered.
 *
 * The `propagation` rule specifies how the activity entity information should be propagated across the different activity
 * routes. The propagation `type` values signify the following:
 *
 * * `ActivityConstants.entityPropagation.ALL`: The data in the activity entity will be propagated to *all* routes that are generated for the activity, including all other entity routes that are part of the activity. This is suitable for public entities.
 * * `ActivityConstants.entityPropagation.ROUTES`: The data in the activity entity will be propagated to only the routes that are produced for the entity. This is the default propagation if no propagation is specified by the router.
 * * `ActivityConstants.entityPropagation.SPECIFY`: The data in the activity entity will be propgated to only the feeds that are specified by the additional `specify` parameter. This differs from `ROUTES` in that it provides the ability to propagate to feeds that are not in the entities direct set of routes.
 *
 * @param  {String}         resourceType                            The type of resource this router is meant to route (e.g., content, comment, user...)
 * @param  {Function}       router                                  The function that determines the routes and propagation of the entity
 * @param  {String}         router.activityType                     The type of activity being routed
 * @param  {String}         router.entityType                       The entity type for which this object is being routed. One of actor, object or target
 * @param  {ActivityEntity} router.persistentEntity                 The activity entity data that was produced for the resource
 * @param  {Function}       router.callback                         The function to invoke when the object has been produced
 * @param  {Object}         router.callback.err                     An error that occurred, if any
 * @param  {Object}         router.callback.routes                  The routes to which the activity should be delivered.
 * @param  {String[]}       [router.callback.routes.stream]         The activity streams to which this activity will be routed. This would typically be the principal ids for the user and group feeds that should be populated.
 * @param  {String[]}       [router.callback.routes.notification]   The routes who will be notified. This would typically be the user ids of the users who should be notified of this activity.
 * @param  {Object}         [router.callback.propagation]           How the entity data should be propagated among activity routes
 * @param  {String}         [router.callback.propagation.type]      The propagation behaviour, as enumerated by `ActivityConstants.entityPropagation`. Defaults to `ROUTES`.
 * @param  {String[]}       [router.callback.propagation.specify]   The routes to which to propagate if the propagation `type` is `SPECIFY`.
 */
var registerActivityRouter = module.exports.registerActivityRouter = function(resourceType, router) {
    ActivityRegistry.registerActivityRouter(resourceType, router);
};

/**
 * Register an activity producer for a type of resource. The activity entity producer is responsible for gathering the data that
 * will be necessary to transform it into an ActivityEntity when an activity feed is requested. This model is persisted into the
 * stream, and the `entityTransformer` will be responsible for taking this data and converting it into the ActivityEntity object
 * that is suitable to be displayed in the activity stream.
 *
 * For example, when someone posts a comment on a content item, an activity (content-comment) is generated. When displaying the
 * activity in the stream, it is useful to have additional context associated with the comment, such as its parent, if any. The
 * producer becomes useful because it can fetch the comment that was posted as well as its parent to be persisted directly into
 * the activity feed (denormalization). So when the activity stream is requested, multiple queries are not required to fetch
 * this information about the activity each time. The activity entity "transformer" is then provided this data to generate the
 * appropriate ActivityStrea.ms model when requested by a client.
 *
 * @param  {String}        resourceType                        The type of resource this producer is meant to produce activity objects for (e.g., content, comment, user...)
 * @param  {Function}      producer                            The function that will convert the resource object into entity data
 * @param  {String}        producer.activityType               The type of activity being generated
 * @param  {String}        producer.entityType                 The entity type for which this entity is being produced. One of actor, object or target
 * @param  {String}        producer.resource                   The resource seed object that describes the resource to use to generate the entity data
 * @param  {Function}      producer.callback                   Invoked when the process has completed
 * @param  {Object}        producer.callback.err               An error that occurred, if any
 * @param  {Object}        producer.callback.persistentEntity  The activity entity data that was produced
 */
var registerActivityEntityProducer = module.exports.registerActivityEntityProducer = function(resourceType, producer) {
    ActivityRegistry.registerActivityEntityProducer(resourceType, producer);
};

/**
 * Register an activity entity transformer for a type of resource. The entity transformer is responsible for taking the entity
 * data that was produced by the activity entity producer, and generating the ActivityEntity for the current request. Since this
 * transformer is invoked for every entity for every activity stream request, it is important to do as little heavy-lifting
 * here as possible, and rather defer as much work to the producer as possible, as the data is only produced once per activity.
 *
 * The `activityEntities` parameter is a breakdown of all the entities of the appropriate `resourceType` in the current set of
 * activities being transformed. This object is structured like so:
 *
 * ```javascript
 * {
 *      'activityId0': {
 *          'resourceId0': { <Produced Entity Data> },
 *          'resourceId1': { <Produced Entity Data> }
 *      },
 *      'activityId1': {
 *          'resourceId0': { <Produced Entity Data> },
 *          'resourceId2': { <Produced Entity Data> },
 *          'resourceId3': { <Produced Entity Data> }
 *      }
 * }
 * ```
 *
 * Similarly, the `transformedActivityEntities` that are returned by the transformer are in the same format, except the
 * <Produced Entity Data> would be replaced with the <Transformed Entity>.
 *
 * Why is the entity data discriminated by activity id *and* resource id? It is technically possible for an entity in one activity
 * to have data that is different than an entity in another entity, even if it has the same id. Some reasons for this:
 *
 *  *   The producer produces data based on a particular activityType and entityType (actor, object, target), therefore it may have
 *      chosen to include different data based on what is relevant for that particular context
 *  *   Since entities are stored in a denormalized way in the activity, they are not updated when the entity data changes over
 *      time. Therefore, a newer activity may have a more recent version of the entity.
 *
 * So, if we don't keep transformed entities keyed by the activity to which they belong, we can end up overwriting entity data in
 * other activities.
 *
 * The `<Transformed Entity>` should be a JavaScript object complient with the activitystrea.ms model: http://activitystrea.ms/. In
 * addition to the core properties there, there are some agreed-upon extension properties which can be found in
 * `ActivityConstants.properties`. You are free to create your own extension properties as well as needed, but please prefix them
 * with "oae:". Here is an example of a transformed group:
 *
 * ```javascript
 *  {
 *      "oae:id": "g:camtest:group-PTqTgCydcBf",
 *      "oae:thumbnail": {
 *          "url": "/path/to/thumbnail.png",
 *          "width": 32,
 *          "height": 32
 *      },
 *      "oae:visibility": "public",
 *      "oae:joinable": "no",
 *      "displayName": "group-PTqTgCydcBf",
 *      "url": "http://tenant.host.com/group/g:camtest:group-PTqTgCydcBf",
 *      "image": {
 *          "url": "/path/to/image.png",
 *          "width": 162,
 *          "height": 162
 *      },
 *      "objectType": "group",
 *      "id": "http://tenant.host.com/api/group/g:camtest:group-PTqTgCydcBf"
 *  }
 * ```
 *
 * @param  {String}        resourceType                                     The type of resource this transformer is transforming for the UI
 * @param  {Function}      transformer                                      The function that will transform the entity data to an `ActivityEntity` for the UI
 * @param  {Context}       transformer.ctx                                  The context of the request that is accessing the activity feed
 * @param  {Object}        transformer.activityEntities                     An object representing the activity entity data that should be transformed. See summary for more information
 * @param  {Function}      transformer.callback                             Invoked when the process completes
 * @param  {Object}        transformer.callback.err                         An error that occurred, if any
 * @param  {Object}        transformer.callback.transformedActivityEntities The transformed activity entities, suitable to be delivered to the user in the activity stream. See summary for more information
 */
var registerActivityEntityTransformer = module.exports.registerActivityEntityTransformer = function(resourceType, transformer) {
    ActivityRegistry.registerActivityEntityTransformer(resourceType, transformer);
};

/**
 * Get the activity stream by the specified id.
 *
 * @param  {Context}           ctx                 The context of the current session
 * @param  {String}            [start]             Number of millis since the epoc (or, last activity id) from which to start returning activities. Only activities older than this value will be returned. By default, will start from the newest.
 * @param  {Number}            [limit]             The number of activities to return. Default: 25
 * @param  {Function}          callback            Invoked when the process completes
 * @param  {Object}            callback.err        An error that occurred, if any
 * @param  {ActivityStream}    callback.activities The activity stream containing the requested set of activities
 */
var getActivityStream = module.exports.getActivityStream = function(ctx, activityStreamId, start, limit, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Must be logged in to see an activity stream'}).isLoggedInUser(ctx);
    validator.check(activityStreamId, {'code': 400, 'msg': 'Must specify an activity stream'}).notEmpty();
    validator.check(activityStreamId, {'code': 400, 'msg': 'You can only view activity streams for a principal'}).isPrincipalId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    limit = OaeUtil.getNumberParam(limit, 25, 1);

    var userId = ctx.user().id;
    var targetAuthzPrincipal = AuthzUtil.getPrincipalFromId(activityStreamId);
    if (ctx.user().isAdmin(targetAuthzPrincipal.tenantAlias)) {
        // Admin of the target tenant can always see the stream
        return _getActivityStream(ctx, activityStreamId, start, limit, callback);
    } else if (AuthzUtil.isGroupId(activityStreamId)) {
        // You can only view a group's activity stream if you are a member of that group
        return AuthzAPI.hasAnyRole(userId, activityStreamId, function(err, hasAnyRole) {
            if (err) {
                return callback(err);
            } else if (!hasAnyRole) {
                return callback({'code': 401, 'msg': 'Must be a member of a group to see its activity stream'});
            }

            return _getActivityStream(ctx, activityStreamId, start, limit, callback);
        });
    } else if (activityStreamId === userId) {
        // You can only view a user's activity stream if it is yourself. No peeking at other user streams.
        return _getActivityStream(ctx, activityStreamId, start, limit, callback);
    }

    // If we're here, we were trying to view another user's activity stream, not allowed!
    return callback({'code': 401, 'msg': 'You are not authorized to see this user\'s activity stream'});
};

/**
 * Get the notifications for the user authenticated to the given context.
 *
 * @param  {Context}            ctx                     The context of the current session
 * @param  {String}             [start]                 Number of millis since the epoc (or, last notification id) from which to start returning notifications. Only notifications older than this value will be returned. By default, starts from the newest
 * @param  {Number}             [limit]                 The maximum number of notifications to return. Default: 25
 * @param  {Function}           callback                Invoked when the process completes
 * @param  {Object}             callback.err            An error that occurred, if any
 * @param  {ActivityStream}     callback.notifications  The requested notifications, represented as an activity stream
 */
var getNotificationStream = module.exports.getNotificationStream = function(ctx, start, limit, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You must be logged in to see notifications'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Append #notification to the end of the user id. This is basically the only thing that is being abstracted out of activity streams in `getActivityStream`
    var streamId = ctx.user().id + '#notification';
    _getActivityStream(ctx, streamId, start, limit, callback);
};

/**
 * Mark all the notifications as read for the user authenticated ot the given context.
 *
 * @param  {Context}    ctx             The context of the current session
 * @param  {Function}   callback        Invoked when the process completes
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var markNotificationsRead = module.exports.markNotificationsRead = function(ctx, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You must be logged in to mark notifications read'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    ActivityNotifications.markNotificationsRead(ctx.user().id, callback);
};

/**
 * Post an activity in the system to be routed.
 *
 * @param  {Context}       ctx                 The execution context of the current request
 * @param  {ActivitySeed}  activitySeed        The activity "seed" object, which represents the smallest amount of information necessary to generate an activity
 * @param  {Function}      callback            Invoked when the activity has been posted (but has not been routed yet)
 * @param  {Object}        callback.err        An error that occurred, if any
 */
var postActivity = module.exports.postActivity = function(ctx, activitySeed, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'activitySeed': activitySeed}, 'Error posting activity.');
        }
    };

    // Short-circuit if we find that activities are disabled for this tenant
    var activitiesEnabled = ActivityConfig.getValue(ctx.tenant().alias, 'activity', 'enabled');
    if (!activitiesEnabled) {
        return callback();
    }

    // Validate the activity seed
    var validator = new Validator();
    validator.check(null, {'code': 400, 'msg': 'No activity seed provided.'}).isObject(activitySeed);
    if (activitySeed) {
        validator.check(activitySeed.activityType, {'code': 400, 'msg': 'Activity seed did not have an activity type.'}).notEmpty();
        validator.check(activitySeed.verb, {'code': 400, 'msg': 'Activity seed did not have a verb.'}).notEmpty();
        validator.check(activitySeed.published, {'code': 400, 'msg': 'Activity seed did not have a valid publish date.'}).isNumeric();

        // Validate the actor resource
        validator.check(null, {'code': 400, 'msg': 'Activity seed did not have an actor resource'}).isObject(activitySeed.actorResource);
        if (activitySeed.actorResource) {
            validator.check(activitySeed.actorResource.resourceId, {'code': 400, 'msg': 'Actor of activity seed did not have a resourceId'}).notEmpty();
            validator.check(activitySeed.actorResource.resourceType, {'code': 400, 'msg': 'Actor of activity seed did not have a resourceType'}).notEmpty();
        }

        // Validate the object resource
        if (activitySeed.objectResource) {
            validator.check(activitySeed.objectResource.resourceId, {'code': 400, 'msg': 'Object of activity seed was specified and did not have a resourceId'}).notEmpty();
            validator.check(activitySeed.objectResource.resourceType, {'code': 400, 'msg': 'Object of activity seed was specified and did not have a resourceType'}).notEmpty();
        }

        // Validate the target resource
        if (activitySeed.targetResource) {
            validator.check(activitySeed.targetResource.resourceId, {'code': 400, 'msg': 'Target of activity seed was specified and did not have a resourceId'}).notEmpty();
            validator.check(activitySeed.targetResource.resourceType, {'code': 400, 'msg': 'Target of activity seed was specified and did not have a resourceType'}).notEmpty();
        }
    }

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    MQ.submit(ActivityConstants.mq.TASK_ACTIVITY, activitySeed, callback);
};

/**
 * Internal function to get an activity stream by its ID. This bypasses permission checks.
 *
 * @param  {Context}           ctx                     The context of the current request
 * @param  {String}            activityStreamId        The ID of the activity stream to fetch
 * @param  {Number}            start                   The starting timestamp of the activities to fetch
 * @param  {Number}            limit                   The number of activities to fetch
 * @param  {Function}          callback                Invoked when the process completes
 * @param  {Object}            callback.err            An error that occurred, if any
 * @param  {ActivityStream}    callback.activityStream The activity stream
 * @api private
 */
var _getActivityStream = function(ctx, activityStreamId, start, limit, callback) {
    ActivityDAO.getActivities(activityStreamId, start, limit, function(err, activities) {
        if (err) {
            return callback(err);
        }

        ActivityTransformer.transformActivities(ctx, activities, function(err) {
            if (err) {
                return callback(err);
            }

            // Add the tenant information to activities that have an oae:id in their external info.
            _.each(activities, function(activity) {
                _addTenantInformationToActivityEntity(activity.actor);
                _addTenantInformationToActivityEntity(activity.object);
                _addTenantInformationToActivityEntity(activity.target);
            });

            // Wrap the transformed activities in a stream
            return callback(null, new ActivityStream(activities));
        });
    });
};

/**
 * Adds the compact tenant information to those activity entities that are OAE entities.
 * The tenant information will be placed in an 'oae:tenant' key.
 *
 * @param  {ActivityEntity}  [entity]  The entity or the collection of entities to add the tenant information to.
 * @api private
 */
var _addTenantInformationToActivityEntity = function(entity) {
    if (entity) {
        if (entity['oae:id']) {
            var tenantAlias = AuthzUtil.getResourceFromId(entity['oae:id']).tenantAlias;
            var tenant = TenantsAPI.getCachedTenantByAlias(tenantAlias);
            if (tenant) {
                entity[ActivityConstants.properties.OAE_TENANT] = tenant.compact();
            }
        } else if (entity['oae:collection']) {
            _.each(entity['oae:collection'], _addTenantInformationToActivityEntity);
        }
    }
};
