/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var shell = require('shelljs');

var ContentConstants = require('oae-content/lib/constants').ContentConstants;
var log = require('oae-logger').logger('oae-preview-processor');
var MQ = require('oae-util/lib/mq');
var RestAPI = require('oae-rest');
var Validator = require('oae-util/lib/validator').Validator;

var PreviewConstants = require('./constants');
var PreviewContext = require('./model').PreviewContext;
var PreviewImages = require('./api.images');
var PreviewOffice = require('./api.office');
var PreviewPDF = require('./api.pdf');

var _config = null;

// A hash of registered processors.
// The first level is the content type, the second level is the mimetype for which the processor should run.
// If the content type has no mimetype, the default `application/octet-stream` will be used.
// The value for the second level is an array of processor objects sorted on their ranking.
var _processors = {};

/**
 * Registers the default processors and starts listening for preview tasks.
 *
 * @param {Function}    [callback]      Standard callback method.
 * @param {Object}      [callback.err]  Standard error object (if any.)
 */
var enable = module.exports.enable = function(callback) {
    callback = callback || function(err) { /* error is logged within the implementation */ };
    registerProcessor('oae-image-processor', 'file', PreviewConstants.TYPES.IMAGE, 10, PreviewImages.generatePreviews);
    registerProcessor('oae-office-processor', 'file', PreviewConstants.TYPES.OFFICE, 10, PreviewOffice.generatePreviews);
    registerProcessor('oae-pdf-processor', 'file', PreviewConstants.TYPES.PDF, 10, PreviewPDF.generatePreviews);

    // Set up the message queue and start listenening for preview tasks.
    var options = {
        'subscribe': {
            'prefetchCount': 1
        }
    };
    MQ.bind(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, _handleGeneratePreviewsTask, options, function(err) {
        if (err) {
            log().error({'err': err}, 'Could not bind too the previews queue.');
            return callback(err);
        }
        log().info('Bound the preview processor to the message queue.');
        callback();
    });
};

/**
 * Unregisters the default processors and remove the listener for preview tasks.
 *
 * @param {Function}    [callback]      Standard callback method.
 * @param {Object}      [callback.err]  Standard error object (if any.)
 */
var disable = module.exports.disable = function(callback) {
    callback = callback || function(err) { /* error is logged within the implementation */ };
    unregisterProcessor('oae-image-processor');
    unregisterProcessor('oae-office-processor');
    unregisterProcessor('oae-pdf-processor');

    MQ.unbind(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function(err) {
        if (err) {
            log().error({'err': err}, 'Could not unbind from the previews queue.');
            return callback(err);
        }
        log().info('Unbound the preview processor to the message queue.');
        callback();
    });
};

/**
 * Refresh the preview processor configuration with the given options.
 *
 * @param  {Object}     config                          The main configuration object as defined in `config.js`. The full config object should be passed in.
 * @param  {Function}   callback                        Invoked when configuration has been refreshed
 */
var refreshPreviewConfiguration = module.exports.refreshPreviewConfiguration = function(config, callback) {
    // Disable the current processor.
    disable(function(err) {
        if (err) {
            return callback(err);
        }

        // Enable with the new config.
        _config = config;

        // Only initialize the processors/listeners
        // if we have explicitly set the PP enabled flag to true.
        if (config.previews.enabled) {

            // Initialize those default processors that need configuration.
            PreviewOffice.init(config, function(err) {
                if (err) {
                    return callback(err);
                }

                PreviewPDF.init(config, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Defer binding to the MQ listener
                    // See https://github.com/sakaiproject/Hilary/issues/314
                    callback();
                    setTimeout(enable, 5000);
                });
            });
        } else {
            callback();
        }
    });
};

/**
 * @return  {Object}    The configuration object that is currently in use.
 */
var getConfiguration = module.exports.getConfiguration = function() {
    return _config;
};

/**
 * Register a preview processor for a certain content type and mime type.
 * Each processor will be registered with a ranking, when a piece of content
 * needs processing and multiple processors are available, the one with the highest ranking will be selected.
 * The default processors are registered with a ranking of 10.
 *
 * @param {String}          processorId                     A unique identifier for this processor. This identifier can be used to remove a processor.
 * @param {String}          contentType                     The type of content for which this processor should be registered. Usually one of `file`, `sakaidoc`, ..
 * @param {String[]}        [mimeTypes]                     In case the `contentType` is a file, an array of mimetypes can be passed along to further scope which files this processor should receive.
 * @param {Number}          ranking                         The ranking for this processor. The default OAE processors have a ranking of 10.
 * @param {Function}        processorCallback               The method that can be used to perform the processing.
 * @param {PreviewContext}  processorCallback.ctx           The preview context associated to the piece of content that needs processing. This will have an authenticated global administrator attached to it.
 * @param {Function}        processorCallback.callback      Standard callback method for when the processor is done processing.
 */
var registerProcessor = module.exports.registerProcessor = function(processorId, contentType, mimeTypes, ranking, processorCallback) {
    var validator = new Validator();
    validator.check(processorId, 'Missing processor ID.').notEmpty();
    validator.check(contentType, 'Missing content type').notEmpty();
    validator.check(ranking, 'Missing or invalid ranking').isInt();
    validator.check(processorCallback, 'Missing callback method').notNull();
    if (validator.hasErrors()) {
        throw new Error(validator.getFirstError());
    }

    // Default the mime type in case it was not provided
    if (!mimeTypes || mimeTypes.length === 0) {
        mimeTypes = [ PreviewConstants.TYPES.DEFAULT ];
    }

    // Our processor object that will be inserted in the correct places in the `_processors` hash.
    var processor = { 'id': processorId, 'processor': processorCallback, 'ranking': ranking };

    // We sort the array of processors on their ranking, highest first.
    var sortProcessors = function(a, b) {
        return a.ranking < b.ranking;
    };

    // Get or create the first level hash.
    _processors[contentType] = _processors[contentType] || {};

    // Get or create the second level hash.
    for (var i = 0; i < mimeTypes.length; i++) {
        _processors[contentType][mimeTypes[i]] = _processors[contentType][mimeTypes[i]] || [];
        _processors[contentType][mimeTypes[i]].push(processor);
        _processors[contentType][mimeTypes[i]].sort(sortProcessors);
    }
};

/**
 * Unregisters a preview processor.
 *
 * @param {String}  processorId     The ID of the processor that should be unregistered.
 */
var unregisterProcessor = module.exports.unregisterProcessor = function(processorId) {
    if (!processorId) {
        throw new Error('The processor id must be specified');
    }

    // Loop over the processor object and remove the processor from each mimetype.
    _.each(_processors, function(mimetypes, contentType) {
        _.each(mimetypes, function(processors, mimeType) {
            var newProcessors = [];
            _.each(processors, function(processor) {
                if (processor.id !== processorId) {
                    newProcessors.push(processor);
                }
            });
            _processors[contentType][mimeType] = newProcessors;
        });
    });
};

/**
 * Returns the processor that is associated with a type of content.
 *
 * @param  {String}     contentType     The type of content. Typically, 'file' or 'sakaidoc'
 * @param  {String}     [mimeType]      The mimetype.
 * @return {Function}                   The function that is associated to this certain type of content item, null will be returned if nothing could be found.
 */
var getProcessor = module.exports.getProcessor = function(contentType, mimeType) {
    mimeType = mimeType || PreviewConstants.TYPES.DEFAULT;
    if (contentType && mimeType && _processors[contentType] && _processors[contentType][mimeType] && _processors[contentType][mimeType].length > 0) {
        return _processors[contentType][mimeType][0].processor;
    } else {
        return null;
    }
};

/**
 * Submits a piece of content to the preview generation queue where it can then
 * be picked up by one of the preview processors.
 *
 * @param   {String}    contentId   The ID of the piece of the content that needs new preview items.
 */
var submitForProcessing = module.exports.submitForProcessing = function(contentId) {
    MQ.submit(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, {'id': contentId});
};


/**
 * When bound to am MQ generate preview task, this method will generate the appropriate
 * preview images
 *
 * @param   {Object}    data           The task data
 * @param   {String}    data.id        The ID for the piece of content that needs new preview items.
 * @param   {Function}  callback       Invoked when generating previews has completed
 * @param   {Object}    callback.err   An error that occurred, if any
 * @api private
 */
var _handleGeneratePreviewsTask = function(data, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'data': data}, 'Error handling preview generation.');
        }
    };

    if (!data.id) {
        log().error({ 'data': data }, 'An invalid task was submitted to the generate previews task queue.');
        callback({'code': 400, 'msg': 'An invalid task was submitted to the generate previews task queue.'});
    } else {
        generatePreviews(data.id, callback);
    }
};


/**
 * Generates previews for a piece of content.
 *
 * @param {String}      contentId       The content ID for which the previews should be generated.
 * @param {Function}    callback        Standard callback method.
 * @param {Object}      callback.err    Standard error object (if any.)
 */
var generatePreviews = module.exports.generatePreviews = function(contentId, callback) {
    log().info({'contentId': contentId}, 'Starting preview generation process.');
    var ctx = new PreviewContext(_config, contentId);

    /*!
     * Wrapper for the callback method that cleans up when processing is done/errored out.
     */
    var cleanCallback = function(err) {
        ctx.cleanup();
        if (err) {
            log().error({'err': err, 'contentId': contentId}, 'Error when trying to process %s');
            // If the process fails, we set the status to 'error'.
            ctx.setStatus(ContentConstants.previews.ERROR, callback);
        } else {
            // We're done.
            log().info({'contentId': contentId}, 'Preview processing done', contentId);
            callback();
        }
    };

    // Generate a context for this preview process and
    // login to the tenant of this content item and start processing.
    ctx.login(function(err) {
        if (err) {
            // If we can't login, we cannot call cleanCallback as we won't have a session cookie
            // to set a status.
            ctx.cleanup();
            return callback(err);
        }

        // Generate the actual preview images.
        _generatePreviews(ctx, function(err) {
            if (err) {
                log().error({'err': err, 'contentId': contentId}, 'Error trying to generate previews');
                return cleanCallback(err);
            }

            // If everything ran smoothly, save them.
            ctx.savePreviews(cleanCallback);
        });
    });
};

/**
 * Generates previews for a piece of content.
 *
 * @param {PreviewContext}      ctx             The preview context associated to this file. This context should have an authenticated global administrator against it.
 * @param {Function}            callback        Standard callback method.
 * @param {Object}              callback.err    Standard error object (if any.)
 * @api private
 */
var _generatePreviews = function(ctx, callback) {
    // Get the content profile.
    RestAPI.Content.getContent(ctx.tenantRestContext, ctx.contentId, function(err, content) {
        if (err) {
            log().error({'err': err, 'contentId': ctx.contentId}, 'Could not get the content profile.');
            return callback(err);
        }

        // Stick the piece of content on the context.
        // This allows for easy retrieval in later methods.
        ctx.content = content;

        var mimeType = content.mime || PreviewConstants.TYPES.DEFAULT;
        var processor = getProcessor(content.contentType, mimeType);
        if (processor) {
            processor(ctx, callback);
        } else {
            log().info({'contentId': ctx.contentId}, 'Ignoring as the type %s is not supported for now.', content.contentType);
            callback();
        }
    });
};
