/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var crypto = require('crypto');
var log = require('oae-logger').logger('oae-activity-router');
var Telemetry = require('oae-telemetry').telemetry('activity');

var ActivitySystemConfig = require('./config');
var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;
var ActivityDAO = require('./dao');

var activityRouters = {};
var activityProducers = {};

/**
 * Register an activity router.
 *
 * @see ActivityAPI#registerActivityRouter
 */
var registerActivityRouter = module.exports.registerActivityRouter = function(resourceType, router) {
    if (activityRouters[resourceType]) {
        throw new Error('Attempted to register duplicate activity router');
    }
    activityRouters[resourceType] = router;
};

/**
 * Register an activity entity producer.
 *
 * @see ActivityAPI#registerActivityEntityProducer
 */
var registerActivityEntityProducer = module.exports.registerActivityEntityProducer = function(resourceType, producer) {
    if (activityProducers[resourceType]) {
        throw new Error('Attempted to register duplicate activity producer');
    }
    activityProducers[resourceType] = producer;
};

/**
 * Produce, route and queue an activity from an activity seed.
 *
 * @param   {ActivitySeed}  activitySeed        The activity seed that was used to post the activity
 * @param   {Function}      [callback]          Invoked when the process completes
 * @param   {Object}        [callback.err]      An error that occurred, if any
 */
var routeActivity = module.exports.routeActivity = function(activitySeed, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'activitySeed': activitySeed}, 'Error handling activity.');
        }
    };

    log().trace({'activitySeed': activitySeed}, 'Routing activity seed.');

    // Record the amount of time the activity sat in the message queue before routing began
    Telemetry.appendDuration('activity.mq.time', activitySeed.published);
    var routingStartTime = Date.now();

    // Will aggregate all the activityStreamId (i.e., route) -> activity pairings that will be delivered
    var routedActivities = {};
    var activityId = ActivityDAO.createActivityId(activitySeed.published);

    // Produce all of the activity entities
    _produceAllEntities(activitySeed, function(err, actor, object, target) {
        if (err) {
            return callback(err);
        }

        // Produce the routes for the actor, object and target entities
        _produceAllRoutes(activitySeed, actor, object, target, function(err, actorRoutes, actorPropagation, objectRoutes, objectPropagation, targetRoutes, targetPropagation) {
            if (err) {
                return callback(err);
            }

            /*!
             * Here we expand all activities into their routes, and propagate the entity data to those that are allowed to see it. This
             * happens in several steps:
             *
             *  1.  First create a blank activity for each route that is in the routes of all the entities. At the same time, if the
             *      entity has propagation set to "routes", then apply that entity to each of the new activities.
             *
             *  2.  Iterate over all our routed activities and ensure they have the minimum amount of data (e.g., even if an entity is
             *      not being propagated to the route, it should at least contain the id so we know that the entity was involved in the
             *      activity). At the same time, we can apply all the entities who have "all" propagation, as they are always applicable
             *      to every single route.
             *
             *  3.  For all entities that have specified "specify" propagation, apply the entity to all routes that are in the list of
             *      specified routes. This ensures that all users who had access to private entities (but were not explicitly in their
             *      routes) will be propagated entities to which they have access.
             */

            // 1. Create all routes and apply the "ROUTES" propagation entities where applicable
            for (var i = 0; i < actorRoutes.length; i++) {
                var actorRoute = actorRoutes[i];
                routedActivities[actorRoute] = routedActivities[actorRoute] || {};
                if (actorPropagation.type === ActivityConstants.entityPropagation.ROUTES) {
                    routedActivities[actorRoute].actor = actor;
                }
            }

            for (i = 0; i < objectRoutes.length; i++) {
                var objectRoute = objectRoutes[i];
                routedActivities[objectRoute] = routedActivities[objectRoute] || {};
                if (objectPropagation.type === ActivityConstants.entityPropagation.ROUTES) {
                    routedActivities[objectRoute].object = object;
                }
            }

            for (i = 0; i < targetRoutes.length; i++) {
                var targetRoute = targetRoutes[i];
                routedActivities[targetRoute] = routedActivities[targetRoute] || {};
                if (targetPropagation.type === ActivityConstants.entityPropagation.ROUTES) {
                    routedActivities[targetRoute].target = target;
                }
            }

            // 2. Fill all minimum activity data, including the "ALL" propagation entities.
            _.values(routedActivities).forEach(function(activity) {

                // Also use this loop to put all the activity-level properties onto each activity
                activity[ActivityConstants.properties.OAE_ACTIVITY_TYPE] = activitySeed.activityType;
                activity[ActivityConstants.properties.OAE_ACTIVITY_ID] = activityId;
                activity.verb = activitySeed.verb;
                activity.published = activitySeed.published;

                // Apply the appropriate actor data to the routed activity
                if (activitySeed.actorResource && actorPropagation.type === ActivityConstants.entityPropagation.ALL) {
                    activity.actor = actor;
                } else if (activitySeed.actorResource) {
                    activity.actor = {};
                    activity.actor.objectType = activitySeed.actorResource.resourceType;
                    activity.actor[ActivityConstants.properties.OAE_ID] = activitySeed.actorResource.resourceId;
                }

                // Apply the appropriate object data to the routed activity
                if (activitySeed.objectResource && objectPropagation.type === ActivityConstants.entityPropagation.ALL) {
                    activity.object = object;
                } else if (activitySeed.objectResource) {
                    activity.object = {};
                    activity.object.objectType = activitySeed.objectResource.resourceType;
                    activity.object[ActivityConstants.properties.OAE_ID] = activitySeed.objectResource.resourceId;
                }

                // Apply the appropriate target data to the routed activity
                if (activitySeed.targetResource && targetPropagation.type === ActivityConstants.entityPropagation.ALL) {
                    activity.target = target;
                } else if (activitySeed.targetResource) {
                    activity.target = {};
                    activity.target.objectType = activitySeed.targetResource.resourceType;
                    activity.target[ActivityConstants.properties.OAE_ID] = activitySeed.targetResource.resourceId;
                }
            });

            // 3. Apply the "SPECIFY" propagation entities where possible.
            if (activitySeed.actorResource && actorPropagation.type === ActivityConstants.entityPropagation.SPECIFY && actorPropagation.specify) {
                actorPropagation.specify.forEach(function(route) {
                    if (routedActivities[route]) {
                        routedActivities[route].actor = actor;
                    }
                });
            }

            if (activitySeed.objectResource && objectPropagation.type === ActivityConstants.entityPropagation.SPECIFY && objectPropagation.specify) {
                objectPropagation.specify.forEach(function(route) {
                    if (routedActivities[route]) {
                        routedActivities[route].object = object;
                    }
                });
            }

            if (activitySeed.targetResource && targetPropagation.type === ActivityConstants.entityPropagation.SPECIFY && targetPropagation.specify) {
                targetPropagation.specify.forEach(function(route) {
                    if (routedActivities[route]) {
                        routedActivities[route].target = target;
                    }
                });
            }

            log().trace({
                'activitySeed': activitySeed,
                'routedActivities': routedActivities
            }, 'Queueing activities to be routed.');

            // Queue the activity entities to be collected and aggregated
            _queueActivities(activitySeed, routedActivities, function(err, buckets) {
                if (err) {
                    return callback(err);
                }

                // The number of activities that were handled
                Telemetry.incr('activity.count');

                // How many routed activities are created and how long it took
                Telemetry.incr('activity.routed.count', _.keys(routedActivities).length);
                Telemetry.appendDuration('routing.time', routingStartTime);
                return callback();
            });
        });
    });
};


/**
 * Produce activity entities based on the actor, object and target resources of the given activity seed.
 *
 * @param   {ActivitySeed}      activitySeed                The activity seed from which to extract the actor, object and target resource information
 * @param   {Function}          callback                    Invoked when the process completes
 * @param   {Object}            callback.err                An error that occurred, if any
 * @param   {ActivityEntity}    callback.actor              The actor activity entity
 * @param   {ActivityEntity}    [callback.object]           The object activity entity, if one was specified
 * @param   {ActivityEntity}    [callback.target]           The actor activity entity, if one was specified
 * @api private
 */
var _produceAllEntities = function(activitySeed, callback) {
    _produceEntity(activitySeed.activityType, ActivityConstants.entityTypes.ACTOR, activitySeed.actorResource, function(err, actor) {
        if (err) {
            return callback(err);
        }

        _produceEntity(activitySeed.activityType, ActivityConstants.entityTypes.OBJECT, activitySeed.objectResource, function(err, object) {
            if (err) {
                return callback(err);
            }

            _produceEntity(activitySeed.activityType, ActivityConstants.entityTypes.TARGET, activitySeed.targetResource, function(err, target) {
                if (err) {
                    return callback(err);
                }

                return callback(null, actor, object, target);
            });
        });
    });
};

/**
 * Produce an activity entity with the given seed resource information.
 *
 * @param   {String}                activityType            The type of activity for which the entity is being produced
 * @param   {String}                entityType              The type of entity for which the entity is being produced (i.e., actor, object or target)
 * @param   {ActivitySeedResource}  resource                The activity resource that was used to seed the activity
 * @param   {Function}              callback                Invoked when the process completes
 * @param   {Object}                callback.err            An error that occurred, if any
 * @param   {ActivityEntity}        callback.activityEntity The activity entity that was produced
 * @api private
 */
var _produceEntity = function(activityType, entityType, resource, callback) {
    if (!resource) {
        return callback();
    }

    // Find the producer for this resource type. If there isn't one registered, we fall back to the default producer
    var producer = activityProducers[resource.resourceType] || _defaultActivityEntityProducer;
    
    producer(activityType, entityType, resource, function(err, entity) {
        if (err) {
            return callback(err);
        }

        // Ensure a valid resource id and resource type
        entity = entity || {};
        entity.objectType = resource.resourceType;
        entity[ActivityConstants.properties.OAE_ID] = resource.resourceId;

        log().trace({
            'activityType': activityType,
            'entityType': entityType,
            'resource': resource,
            'entity': entity
        }, 'Produced activity entity.');

        return callback(null, entity);
    });
};

/**
 * Produce the routes for the given actor, object and target activity entities.
 *
 * @param   {ActivitySeed}      activitySeed                The activity seed that was used to post the activity
 * @param   {ActivityEntity}    actor                       The actor entity that was produced for the activity
 * @param   {ActivityEntity}    [object]                    The object entity that was produced for the activity
 * @param   {ActivityEntity}    [target]                    The target entity that was produced for the activity
 * @param   {Function}          callback                    Invoked when the process completes
 * @param   {Object}            callback.err                An error that occurred, if any
 * @param   {String[]}          callback.actorRoutes        The routes to which to route the activity for the actor
 * @param   {Object}            callback.actorPropagation   How to propagate the actor entity among activity routes
 * @param   {String[]}          callback.objectRoutes       The routes to which to route the activity for the object
 * @param   {Object}            callback.objectPropagation  How to propagate the object entity among activity routes
 * @param   {String[]}          callback.targetRoutes       The routes to which to route the activity for the target
 * @param   {Object}            callback.targetPropagation  How to propagate the target entity among activity routes
 * @api private
 */
var _produceAllRoutes = function(activitySeed, actor, object, target, callback) {
    log().trace({
        'activitySeed': activitySeed,
        'actorEntity': actor,
        'objectEntity': object,
        'targetEntity': target
    }, 'Producing routes for activity entities.');

    _produceRoutes(activitySeed.activityType, ActivityConstants.entityTypes.ACTOR, actor, function(err, actorRoutes, actorPropagation) {
        if (err) {
            return callback(err);
        }

        _produceRoutes(activitySeed.activityType, ActivityConstants.entityTypes.OBJECT, object, function(err, objectRoutes, objectPropagation) {
            if (err) {
                return callback(err);
            }

            _produceRoutes(activitySeed.activityType, ActivityConstants.entityTypes.TARGET, target, function(err, targetRoutes, targetPropagation) {
                if (err) {
                    return callback(err);
                }

                return callback(null, actorRoutes, actorPropagation, objectRoutes, objectPropagation, targetRoutes, targetPropagation);
            });
        });
    });
};

/**
 * Produce the routes for the activity entity.
 *
 * @param   {String}            activityType            The type of activity being routed
 * @param   {String}            entityType              The type of entity for which activities are being routed (e.g., actor, object, target)
 * @param   {ActivityEntity}    entity                  The entity for which to produce the routes
 * @param   {Function}          callback                Invoked when the process completes
 * @param   {Object}            callback.err            An error that occurred, if any
 * @param   {String[]}          callback.routes         The routes to which to route the activity
 * @param   {Object}            callback.propagation    How to propagate the entity among the activity routes
 * @api private
 */
var _produceRoutes = function(activityType, entityType, entity, callback) {
    if (!entity) {
        return callback(null, []);
    }

    var router = activityRouters[entity.objectType];
    if (!router) {
        log().trace({
            'activityType': activityType,
            'entityType': entityType,
            'entity': entity
        }, 'No router found for object type.');
        return callback();
    }

    router(activityType, entityType, entity, function(err, routes, propagation) {
        if (err) {
            return callback(err);
        }

        routes = routes || [];

        log().trace({
            'activityType': activityType,
            'entityType': entityType,
            'entity': entity,
            'routes': routes,
            'propagation': propagation
        }, 'Generated routes for activity entity.');
        
        propagation = propagation || {'type': ActivityConstants.entityPropagation.ROUTES};

        return callback(null, routes, propagation);
    });
};

/**
 * An entity producer that simply returns the resource data as the persistent entity.
 *
 * @see #registerActivityEntityProducer for parameter details.
 * @api private
 */
var _defaultActivityEntityProducer = function(activityType, entityType, resource, callback) {
    // Simply return the resourceData. If no resource data was specified, the router will just default to an empty object.
    return callback(null, _.extend({}, resource.resourceData));
};

/**
 * Queue the given set of routed activities for collection.
 *
 * @param   {ActivitySeed}  activitySeed        The activity seed from which the activities were generated.
 * @param   {Object}        routedActivities    An object whose value is the activity to deliver, where the key is the route to which the activity should be delivered.
 * @param   {Function}      callback            Invoked when the routed activities have been queued
 * @param   {Object}        callback.err        An error that occurred, if any
 * @param   {Number[]}      callback.buckets    The collection buckets that received activities as a result of this invocation
 * @api private
 */
var _queueActivities = function(activitySeed, routedActivities, callback) {
    var allRoutes = _.keys(routedActivities);
    var activityBuckets = [];

    allRoutes.forEach(function(route) {
        // Assign all activities to their processing buckets to support safe concurrency
        var bucketNumber = _getBucketNumber(route, activitySeed);
        activityBuckets[bucketNumber] = activityBuckets[bucketNumber] || [];
        activityBuckets[bucketNumber].push({'route': route, 'activity': routedActivities[route]});
    });

    // Queue the aggregates into their associated buckets to indicate they need to be collected and delivered
    ActivityDAO.saveQueuedActivities(activityBuckets, function(err) {
        if (err) {
            return callback(err);
        }

        return callback(null, _.keys(activityBuckets));
    });
};


/**
 * Get the bucket number in which a routed activity should be queued. Bucket numbers are chosen to ensure that routed activities
 * that need to be collected in serial (e.g., only one process should collect them at a time) always land in the same bucket (i.e.,
 * because buckets are only collected by one process at one time).
 *
 * The selection is based on a hash of the route and activity type, since all routed activities of the same route and activity type
 * exhert race conditions when aggregating and replacing activities in feeds. When taking into consideration global "public" and
 * "loggedin" routes (not implemented yet, but likely implemented later), it's important to ensure we don't have "hot buckets".
 * Currently it is expected that the bucket that holds the most common activity (e.g., "content-share") of the public route will be
 * the most common bucket, so if that one fills faster than can be collected by a single process, it may be necessary to further
 * discriminate based on other factors, such as characteristics of the aggregate keys.
 *
 * By "characteristics of the aggregate keys", it should be possible to find one identifier that is common in all potential pivot
 * points of the activity. For "content-share", it is the actor, so we could include the ID of the actor in the hash for those
 * types of activities, which should further distribute activities such as "content-share" in the public route. This is not
 * implemented yet as it is not known to be necessary, especially as global public / loggedin routes are not implemented.
 *
 * More information about the race conditions in aggregating activities, please see the documentation in
 * `oae-activity/lib/internal/aggregator.js`.
 *
 * @param   {String}        route           The string of the route.
 * @param   {ActivitySeed}  activitySeed    The activity seed from which the activity seed is being generated.
 * @return  {Number}                        The bucket number in which to queue the activity for processing.
 * @api private
 */
var _getBucketNumber = function(route, activitySeed) {
    var sum = crypto.createHash('md5');
    sum.update(route);
    sum.update(activitySeed.activityType);
    return parseInt(sum.digest('hex'), 16) % ActivitySystemConfig.getConfig().numberOfProcessingBuckets;
};

