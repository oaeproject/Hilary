var _ = require('underscore');

var Cassandra = require('oae-util/lib/cassandra');

var groupModel = require('./model.js');

/**
 * Get the basic profile for a group.
 * @param  {String}   group_id  An identifier for a group. ex: g:cam:oae-team
 * @param  {Function} callback  Standard callback method where the first argument is an error object
 *                              that contains a code suitable as http statuscode and a corresponding message.
 *                              The second argument holds the group information.
 */
module.exports.getGroup = function(group_id, callback) {
    if (!isGroup(group_id)) {
        return callback({'code': 400, 'msg': 'The provided group_id is not a group identifier.'}, null);
    }

    Cassandra.runQuery('SELECT * FROM Principals WHERE principal_id = ?', [group_id], function (err, rows) {
        if (err) {
            return callback({'code': 500, 'msg': err}, null);
        }

        // Cassandra always returns the key as a column so the _colCount will always be 1.
        if (rows[0]._colCount === 1) {
            return callback({'code': 404, 'msg': "Couldn't find that group."}, null);
        }

        var group = groupModel.rowToGroup(rows[0]);
        if (group.privacy_setting === 'private') {
            return callback({'code': 404, 'msg': "Couldn't find that group."}, null);
        }

        callback(false, group);
    });
};

/**
 * Get all the members of a group.
 * 
 * @param  {String}   group_id An identifier for a group. ex: g:cam-oae-team
 * @param  {Boolean}  retrieve_basicprofile Wether or not the basic profile should be included for the principals
 * @param  {Function} callback  Standard callback method where the first argument is an error object
 *                              that contains a code suitable as http statuscode and a corresponding message.
 *                              The second argument holds the group members
 */
module.exports.getGroupMembers = function(group_id, retrieve_basicprofile, callback) {
    module.exports.getGroup(group_id, function(err, group) {
        if (err) {
            return callback(err, null);
        }

        Cassandra.runQuery('SELECT * FROM GroupMembers WHERE group_id = ?', [group_id], function (err, rows) {
            if (err) {
                return callback({'code': 500, 'msg': err}, null);
            }

            var members = [];
            for (var i = 0, j = rows[0].cols.length;i<j;i++) {
                if (rows[0].cols[i].name !== "group_id") {
                    members.push(rows[0].cols[i].name);
                }
            }
            if (members.length === 0) {
                return callback(false, members);
            }

            if (!retrieve_basicprofile) {
                return callback(false, members);
            }

            getBasicProfile(members, callback);
        });
    });
};

/**
 * Gets all the groups a principal (both user or groups) is a member of.
 * @param  {String}   principal_id      The principal to retrieve all the groups for.
 * @param  {Boolean}  retrieve_basicprofile Whether or not the profile should be retrieved. If false, only the principal_ids for each group will be returned.
 * @param  {Function} callback  Standard callback method where the first argument is an error object
 *                              that contains a code suitable as http statuscode and a corresponding message.
 *                              The second argument holds the groups this principal is a member of.
 */
module.exports.memberOf = function(principal_id, retrieve_basicprofile, callback) {
     Cassandra.runQuery('SELECT * FROM MemberOf WHERE principal_id = ?', [principal_id], function (err, rows) {
        if (err) {
            return callback({'code': 500, 'msg': err}, null);
        }

        var memberships = [];
        for (var i = 0, j = rows[0].cols.length;i<j;i++) {
            if (rows[0].cols[i].name !== "principal_id") {
                memberships.push(rows[0].cols[i].name);
            }
        }
        if (memberships.length === 0) {
            return callback(false, memberships);
        }

        if (!retrieve_basicprofile) {
            return callback(false, memberships);
        }

        getBasicProfile(memberships, callback);
    });
};

/**
 * Adds a principal to a group.
 * @param {String}   group_id        The identifier of a group. ex: g:cam:oae-team
 * @param {String[]} principalsToAdd An array of principal identifiers you wish to add. ex: [g:cam:ui-team, g:cam:backend-team]
 * @param  {Function} callback  Standard callback method where the first argument is an error object
 *                              that contains a code suitable as http statuscode and a corresponding message.
 */
module.exports.addGroupMembers = function(group_id, principalsToAdd, callback) {
    // Check if group and whether or not we have access to edit.
    module.exports.getGroup(group_id, function(err, group) {
        if (err) {
            return callback(err, null);
        }

        // If we only add in one principal.
        if (typeof principalsToAdd === "string") {
            principalsToAdd = [principalsToAdd];
        }

        // Check the prefixes of each member we wish to add.
        var proceed = true;
        for (var i = 0; i < principalsToAdd.length;i++) {
            if ( (principalsToAdd[i].slice(0, 2) !== "g:" && principalsToAdd[i].slice(0, 2) !== "u:") || (principalsToAdd[i] === group_id)) {
                proceed = false;
                break;
            }
        }

        if (!proceed) {
            return callback({'code': 400, 'msg': "You can only add users and/or groups and not the group itself."}, null);
        }

        // Verify that the provided principals actually exist in the database.
        Cassandra.runQuery('SELECT * FROM Principals WHERE principal_id IN (?)', [principalsToAdd], function (err, rows) {
            if (err) {
                return callback({'code': 500, 'msg': err}, null);
            }

            // Convert principalsToAdd to hash to create faster lookup.
            var requestPrincipals = {};
            for (var i = 0; i < principalsToAdd.length;i++) {
                requestPrincipals[principalsToAdd[i]] = true;
            }

            var all_valid = true;
            for (var i = 0; i < rows.rowCount();i++) {
                if (rows[i]._colCount === 1) {
                    // This is an invalid principal!
                    requestPrincipals[rows[i].colHash.principal_id] = false;
                    all_valid = false;
                }
            }

            if (!all_valid) {
                return callback({'code': 400, 'msg': 'Not all the provided principals exist!'});
            }

            // Ensure that we're not adding any circular dependencies by 
            // making sure that all the provided principals are NOT a parent of this group.
            // Basically the whole group graph needs to be a Directed Acyclical Graph.
            Cassandra.runQuery('SELECT * FROM MemberOf WHERE principal_id IN (?)', [principalsToAdd], function (err, rows) {
                if (err) {
                    return callback({'code': 500, 'msg': err}, null);
                }

                for (var i = 0; i < principalsToAdd.length;i++) {
                    if (typeof rows[0].colHash[principalsToAdd[i]] !== "undefined") {
                        return callback({'code': 400, 'msg': 'You cannot make a parent group member of one of it\'s children.'}, null);
                    }
                }

                // Get all the groups that this group is a member of so we can add them to the principallist later.
                Cassandra.runQuery('SELECT * FROM MemberOf WHERE principal_id  = ?', [group_id], function (err, rows) {
                    if (err) {
                        return callback({'code': 500, 'msg': err}, null);
                    }

                    var parentGroups = [];
                    for (var i = 0; i < rows[0].cols.length;i++) {
                        if (rows[0].cols[i].name !== "principal_id") {
                            parentGroups.push(rows[0].cols[i].name);
                        }
                    }

                    var q = [];
                    var parameters = [];
                    for (var i = 0; i < principalsToAdd.length;i++) {
                        q.push("?=?");
                        parameters.push(principalsToAdd[i]);
                        parameters.push("");
                    }
                    parameters.push(group_id);

                    Cassandra.runQuery("UPDATE GroupMembers SET " + q.join(', ') + " WHERE group_id = ?", parameters, function(err) {
                        if (err) {
                            return callback({'code': 500, 'msg': err}, null);
                        }

                        // Explode the principals and add them all in.
                        explodePrincipals(principalsToAdd, false, function(err, users) {
                            if (err) {
                                return callback({'code': 500, 'msg': err}, null);
                            }

                            users = principalsToAdd.concat(_.keys(users));
                            // We add this group to each principal his membership list.
                            // We also need to add all the parent groups of this group to the membership list of each principal.
                            var queries = [];
                            for (var i = 0; i < users.length;i++) {
                                var query = {'query':'', 'parameters': []};
                                var parameters = [];
                                var parentGroupsQuery = "";
                                for (var g = 0; g < parentGroups.length;g++) {
                                    parentGroupsQuery += "?=?,";
                                    query.parameters.push(parentGroups[g]);
                                    query.parameters.push("");
                                }
                                query.query= "UPDATE MemberOf SET " + parentGroupsQuery + " ?=?  WHERE principal_id=?";
                                query.parameters.push(group_id);
                                query.parameters.push("");
                                query.parameters.push(users[i]);
                                queries.push(query);
                            }

                            Cassandra.runBatchQuery(queries, function(err) {
                                if (err) {
                                    return callback({'code': 500, 'msg': err}, null);
                                }

                                callback(false, null);
                            });
                        });
                    });
                });
            });
        });
    });
};

/**
 * Create a new group within this tenant.
 * @param  {Tenant}   tenant      The current tenant
 * @param  {String}   title       The title for this group. This will be stemmed down to something that we can use in Cassandra and prefixed with g:tenant.alias:
 * @param  {String}   description A description for this group.
 * @param  {Function} callback    Standard callback method where the first argument is an error object
 *                                that contains a code suitable as http statuscode and a corresponding message.
 *                                The second argument holds the group id as a string.
 */
module.exports.createGroup = function(tenant, title, description, callback) {
    var groupId = title.replace(/[:;<>#%{}|~`@%&!$,.="'\^\+\/\?\(\)\*\s\\\\\[\]]/gi, '-');
    var id = "g:" + tenant.alias + ":" + groupId;
    // Check if the group already exists.
    module.exports.getGroup(id, function(err, group) {
        if (!err) {
            return callback({'code': 400, 'msg': 'This name is not available.'}, null);
        }

        // Create the group.
        Cassandra.runQuery('INSERT INTO Principals (principal_id, tenant, group_title, group_description) VALUES (?, ?, ?, ?)', [id, tenant.alias, title, description], function (err) {
            if (err) {
                callback({'code': 500, 'msg': err}, null);
            } else {
                callback(false, id);
            }
        });
    });
};


/**
 * Explodes a group down to all its user principals.
 * @param  {String}   group_id   The ID of a group.
 * @param  {Function} callback  Standard callback method where the first argument is an error object
 *                              that contains a code suitable as http statuscode and a corresponding message.
 *                              The second argument holds all the users principals in this group.
 * @return {[type]}
 */
module.exports.getGroupUsers = function(group_id, callback) {
    explodePrincipals([group_id], true, function(err, users) {
        var members = _.keys(users);
        callback(false, members);
    });
};

/**
 * Explodes an array of group_ids down to all the underlying principals.
 * @param  {String[]  group_ids   An array of group_ids that should be exploded.
 * @param  {Boolean}  only_users  Whether or not the results should only include the users.
 * @param  {Function} callback  Standard callback method where the first argument is an error object
 *                              that contains a code suitable as http statuscode and a corresponding message.
 *                              The second argument holds the principals in this group.
 */
var explodePrincipals = function(group_ids, only_users, callback) {
    // Use a hash so we don't have doubles (ie: fake a Set)
    var group_user_members = {};

    // Simple parallel tree recursion algorithm.
    // We multi-get all the groups on each level in the tree.
    // ie: This is breadth-first.
    Cassandra.runQuery("SELECT * FROM GroupMembers WHERE group_id IN (?)", [group_ids], function(err, rows) {
        var new_groups = [];
        // Iterate over the groups.
        for (var i = 0; i < rows.rowCount();i++) {
            // Iterate over the members in this group.
            for (var c = 0; c < rows[i]._colCount; c++) {
                var principal = rows[i].cols[c].name;
                if (principal === 'group_id')
                    continue;

                if (isGroup(principal)) {
                    // Explode this group further.
                    new_groups.push(principal);
                    if (!only_users) {
                        group_user_members[principal] = true;
                    }
                } else {
                    group_user_members[principal] = true;
                }
            }
        }

        if (new_groups.length > 0) {
            explodePrincipals(new_groups, only_users, function(err, principals) {
                for (var principal in principals) {
                    if (principals.hasOwnProperty(principal)) {
                        group_user_members[principal] = true;
                    }
                }
                callback(false, group_user_members);
            });
        }
        else {
            return callback(false, group_user_members);
        }
    });
};

/**
 * Check if an identifier really is a group identifier.
 * @param  {[type]}  group_id [description]
 * @return {Boolean} Whether or not the provided identifier is a group identifier.
 */
var isGroup = function(group_id) {
    return (group_id.slice(0, 2) === "g:");
};


/**
 * Gets all the basic profile data for an array of principals
 * @param  {String[]}  principals  An array of principals for which the profile information should be retrieved.
 * @param  {Function} callback  Standard callback method where the first argument is an error object
 *                              that contains a code suitable as http statuscode and a corresponding message.
 *                              The second argument is an array where each object holds the basic profile data for a principal.
 */
var getBasicProfile = function(principals, callback) {
    Cassandra.runQuery('SELECT * FROM Principals WHERE principal_id IN (?)', [principals], function (err, rows) {
        if (err) {
            return callback({'code': 500, 'msg': err}, null);
        }

        members = [];
        for (var i = 0, j = rows.rowCount(); i<j;i++) {
            if (rows[i].colHash.principal_id.slice(0, 2) === "g:") {
                members.push(groupModel.rowToGroup(rows[i]));
            } else {
                // todo abstract this.
                members.push({'principal_id': rows[i].colHash.principal_id, 'tenant': rows[i].colHash.tenant, 'first_name': rows[i].colHash.user_first_name, 'last_name': rows[i].colHash.user_last_name});
            }
        }
        callback(false, members);
    });
};