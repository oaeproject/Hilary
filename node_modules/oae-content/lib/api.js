/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var ShortId = require('shortid');

var Context = require('oae-context').Context;
var Validator = require('oae-util/lib/validator').Validator;
var Cassandra = require('oae-util/lib/cassandra');
var PrincipalsUtil = require('oae-principals/lib/util');
var AuthzAPI = require('oae-authz');
var AuthzUtil = require('oae-authz/lib/util');

var Content = require('./model').Content;
var ContentConstants = require('./model').Constants;


///////////////////////////////////
// Retrieving a piece of content //
///////////////////////////////////

/**
 * Get a content's basic profile information based on a pooled content id
 * @param  {Context}        ctx                 Standard context object, representing the currently logged user and its tenant
 * @param  {String}         contentId           The id of the content object we want to retrieve
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Content}        callback.contentObj Retrieved content object
 */
var getContent = module.exports.getContent = function(ctx, contentId, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Retrieve the piece of content from Cassandra
    Cassandra.runQuery('SELECT * FROM Content USING CONSISTENCY QUORUM WHERE contentId = ?', [contentId], function (err, rows) {
        if (err) {
            return callback(err);
        }

        // Cassandra always returns the key as a column so the _colCount will always be 1.
        if (rows[0].count <= 1) {
            return callback({'code': 404, 'msg': "Couldn't find content: " + contentId}, null);
        }

        var contentObj = _rowToContent(rows[0]);
        _hasAccess(ctx, contentObj, function(err, hasAccess) {
            if (err) {
                return callback(err);
            } else if (!hasAccess) {
                return callback({'code': 401, 'msg': 'You don\'t have access to this piece of content'});
            }
            callback(null, contentObj);
        });
    });
};

/**
 * Get a content item's full content profile. Next to the basic content profile, this will include the created date,
 * the profile of the user who originally created the content, and a isManager property specifying whether or not
 * the current user can manage the content. After that, different functions will be called depending on the 
 * contentType to further decorate the object
 * @param  {Context}        ctx                         Standard context object, representing the currently logged user and its tenant
 * @param  {String}         contentId                   The id of the content profile we want to retrieve
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                Error object containing the error message
 * @param  {Content}        callback.contentProfile     Retrieved content profile
 */
var getFullContentProfile = module.exports.getFullContentProfile = function(ctx, contentId, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'contentId': 400, 'msg': 'A content id must be provided'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }
        
        // Get the user object for the createdBy property
        PrincipalsUtil.getPrincipal(ctx, contentObj.createdBy, function(err, createdBy) {
            if (err) {
                return callback(err);
            }
            contentObj.createdBy = createdBy;

            // Depending on the content type, allow for specific handling for each of the content types
            var initiateAdditionalProcessing = function() {
                if (contentObj.contentType === 'link') {
                    _getFullContentProfileLink(contentObj, callback);
                } else if (contentObj.contentType === 'file') {
                    _getFullContentProfileFile(contentObj, callback);
                } else if (contentObj.contentType === 'sakaidoc') {
                    _getFullContentProfileSakaiDoc(contentObj, callback);
                }
            };

            // If the current user is an anonymous user, we know he's not a viewer or manager
            if (!ctx.user()) {
                contentObj.isManager = false;
                initiateAdditionalProcessing();
            } else {
                // Add the isManager properties
                _canManage(ctx, contentId, function(err, isManager) {
                    if (err) {
                        return callback(err);
                    }
                    contentObj.isManager = isManager;
                    initiateAdditionalProcessing();
                });
            }
        });
    });
};

/**
 * Utility function that will be used to further decorate a link's full content profile. This will add the link
 * property to the content profile
 * @param  {Content}        contentObj                  Content object representing the content profile that's decorated
 * @param  {Function}       callback                    Standard callback function takes arguments `err` and `contentProfile`
 * @param  {Object}         callback.err                Error object containing the error message
 * @param  {Content}        callback.contentProfile     Retrieved content profile
 */
var _getFullContentProfileLink = function(contentObj, callback) {
    // Set the link property onto the content object
    Cassandra.runQuery('SELECT link FROM Content USING CONSISTENCY QUORUM WHERE contentId = ?', [contentObj.contentId], function (err, rows) {
        if (err) {
            return callback(err);
        }

        var hash = Cassandra.rowToHash(rows[0]);
        contentObj.link = hash.link;
        callback(null, contentObj);
    });
};

/**
 * Utility function that will be used to further decorate a file's full content profile. 
 * @param  {Content}        contentObj                  Content object representing the content profile that's decorated
 * @param  {Function}       callback                    Standard callback function takes arguments `err` and `contentProfile`
 * @param  {Object}         callback.err                Error object containing the error message
 * @param  {Content}        callback.contentProfile     Retrieved content profile
 */
var _getFullContentProfileFile = function(contentObj, callback) {
    callback(null, contentObj);
};

/**
 * Utility function that will be used to further decorate a Sakai Docs's full content profile. This will add the link
 * property to the content profile
 * @param  {Content}        contentObj                  Content object representing the content profile that's decorated
 * @param  {Function}       callback                    Standard callback function takes arguments `err` and `contentProfile`
 * @param  {Object}         callback.err                Error object containing the error message
 * @param  {Content}        callback.contentProfile     Retrieved content profile
 */
var _getFullContentProfileSakaiDoc = function(contentObj, callback) {
    callback(null, contentObj);
};

/**
 * Internal function used to get multiple content basic profiles at the same time based on their content ids.
 * @param  {String[]}       contentIds          Array of content object ids we want to retrieve. The content profiles will be returned in the same order
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `contentObj`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Content[]}      callback.contentObj Retrieved content objects
 */
var _getMultipleContentItems = function(contentIds, callback) {
    if (contentIds.length) {
        Cassandra.runQuery("SELECT * FROM Content USING CONSISTENCY QUORUM WHERE contentId IN (?)", [contentIds], function(err, rows) {
            if (err) {
                return callback(err);
            }
            // Iterate over the content items.
            for (var i = 0; i < rows.length; i++) {
                var contentObj = _rowToContent(rows[i]);
                contentIds[_.indexOf(contentIds, contentObj.contentId)] = contentObj;
            }
            callback(null, contentIds);
        });
    } else {
        callback(null, []);
    }
};

/////////////////////////////////////
// Creating a new piece of content //
/////////////////////////////////////

/**
 * Create a link as a pooled content item
 * @param  {Context}        ctx                Standard context object containing the current user and the current tenant
 * @param  {String}         name               The display name for the link
 * @param  {String}         description        The description of the link [optional]
 * @param  {String}         visibility         The visibility setting for the piece of content. Possible values are "public", "loggedin" and "private" [optional]
 * @param  {String}         link               The URL for the link
 * @param  {Object}         additionalMembers  Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {Function}       callback           Standard callback function takes arguments `err` and `content`
 * @param  {Object}         callback.err       Error object containing the error message
 * @param  {Object}         callback.content   JSON object containing the pool id of the created content
 */
var createLink = module.exports.createLink = function(ctx, name, description, visibility, link, additionalMembers, callback) {
    callback = callback || function() {};

    // Check if the link property is present. All other validation will be done in the _createContent function
    var validator = new Validator();
    validator.check(link, {'code': 400, 'msg': 'A valid link must be provided'}).isUrl();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to create a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _createContent(ctx, 'link', name, description, visibility, additionalMembers, {'link': link}, callback);
};

/**
 * Create a file as a pooled content item
 * @param  {Context}   ctx                Standard context object containing the current user and the current tenant
 * @param  {String}    name               The display name for the file
 * @param  {String}    description        The description of the file [optional]
 * @param  {String}    visibility         The visibility setting for the piece of content. Possible values are "public", "loggedin" and "private" [optional]
 * @param  {Object}    additionalMembers  Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {Function}  callback           Standard callback function takes arguments `err` and `content`
 * @param  {Object}    callback.err       Error object containing the error message
 * @param  {Content}   callback.content   JSON object containing the pool id of the created content
 */
var createFile = module.exports.createFile = function(ctx, name, description, visibility, additionalMembers, callback) {
    callback = callback || function() {};
    _createContent(ctx, 'file', name, description, visibility, additionalMembers, {}, callback);
};

/**
 * Create a Sakai document as a pooled content item
 * @param  {Context}   ctx                Standard context object containing the current user and the current tenant
 * @param  {String}    name               The display name for the Sakai Doc
 * @param  {String}    description        The description of the Sakai Doc [optional]
 * @param  {String}    visibility         The visibility setting for the piece of content. Possible values are "public", "loggedin" and "private" [optional]
 * @param  {Object}    additionalMembers  Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {Function}  callback           Standard callback function takes arguments `err` and `content`
 * @param  {Object}    callback.err       Error object containing the error message
 * @param  {Content}   callback.content   JSON object containing the pool id of the created content
 */
var createSakaiDoc = module.exports.createSakaiDoc = function(ctx, name, description, visibility, additionalMembers, callback) {
    callback = callback || function() {};
    _createContent(ctx, 'sakaidoc', name, description, visibility, additionalMembers, {}, callback);
};

/**
 * Create a new piece of pooled content
 * @param  {Context}        ctx                Standard context object containing the current user and the current tenant
 * @param  {String}         contentType        The content type. Possible values are "file", "sakaidoc" and "link"
 * @param  {String}         name               The display name for the piece of content
 * @param  {String}         description        The description of the piece of content [optional]
 * @param  {String}         visibility         The visibility setting for the piece of content. Possible values are "public", "loggedin" and "private" [optional]
 * @param  {Object}         additionalMembers  Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {Object}         otherValues        JSON object where the keys represent other metadata values that need to be stored, and the values represent the metadata values
 * @param  {Function}       callback           Standard callback function takes arguments `err` and `content`
 * @param  {Object}         callback.err       Error object containing the error message
 * @param  {Content}        callback.content   JSON object containing the pool id of the created content
 */
var _createContent = function(ctx, contentType, name, description, visibility, additionalMembers, otherValues, callback) {
    callback = callback || function() {};

    // Use an empty description if no description has been provided
    description = description || '';
    // Setting content to public if no privacy setting is provided
    visibility = visibility || ContentConstants.visibility.PUBLIC;
    // Make sure the otherValues and additionalMembers are valid objects
    additionalMembers = additionalMembers || {};
    otherValues = otherValues || {};
    
    // Parameter validation
    var validator = new Validator();
    validator.check(name, {'code': 400, 'msg': 'A content name must be provided'}).notEmpty();
    validator.check(visibility, {'code': 400, 'msg': 'An invalid content visibility option has been provided. This can be "private", "loggedin" or "public"'}).isIn(_.values(ContentConstants.visibility));
    validator.check(contentType, {'code': 400, 'msg': 'A content type must be provided. This can be "file", "sakaidoc" or "link"'}).isIn(ContentConstants.contentTypes);
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to create a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Generate the content id
    var contentId = AuthzUtil.toUuid('c', ctx.tenant().alias, ShortId.generate());

    // Set the created by, created and lastmodified properties
    var parameters = {
        'tenant': ctx.tenant().alias,
        'visibility': visibility,
        'name': name,
        'description': description,
        'contentType': contentType,
        'createdBy': ctx.user().id,
        'created': Date.now()
    };
    // Add the other values into the query
    parameters = _.extend(parameters, otherValues);
    var q = Cassandra.constructUpsertCQL('Content', 'contentId', contentId, parameters, 'QUORUM');

    // Create the content
    Cassandra.runQuery(q.query, q.parameters, function(err) {
        if (err) {
            return callback(err);
        }
        
        var contentObj = new Content(ctx.tenant().alias, contentId, visibility, name, description, contentType, parameters.createdBy, parameters.created);
        // Now make the current user a manager of the content
        additionalMembers[ctx.user().id] = ContentConstants.roles.MANAGER;
        _setContentPermissions(ctx, contentObj, additionalMembers, function(err) {
            if (err) {
                return callback(err);
            }
            // Call the callback function and return the generated id
            callback(false, contentObj);
        });
    });
};

/////////////////////////////////
// Removing a piece of content //
/////////////////////////////////

/**
 * Delete a piece of content from the system
 * @param  {Context}   ctx               Standard context object containing the current user and the current tenant
 * @param  {String}    contentId         The content id of the content that is being deleted
 * @param  {Function}  callback          Standard callback function takes argument `err`
 * @param  {Object}    callback.err      Error object containing the error message
 */
var deleteContent = module.exports.deleteContent = function(ctx, contentId, callback) {
    callback = callback || function() {};

    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).notEmpty();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to delete a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Fist check whether or not the current user is a manager of the piece of content
    canManage(ctx, contentId, function(err, canManage, contentObj) {
        if (err) {
            return callback(err);
        } else if (!canManage) {
            return callback({'code': 401, 'msg': 'You are not allowed to manage this piece of content'});
        }
        
        // Delete the content
        Cassandra.runQuery('DELETE FROM Content WHERE contentId = ?', [contentId], function(err, rows) {
            if (err) {
                return callback(err);
            }

            // Get the members
            _getAllContentMembers(contentId, function(err, members) {
                if (err) {
                    return callback(err);
                // Return if there are no members
                } else if (members.length === 0) {
                    return callback();
                }

                // Remove the roles and delete this from everyone's library
                var updateMembers = {};
                for (var m = 0; m < members.length; m++) {
                    updateMembers[members[m].id] = false;
                }
                _setContentPermissions(ctx, contentObj, updateMembers, callback);
            });
        }); 
    });
};

////////////////////////////
// Content access control //
////////////////////////////

/**
 * TODO: Make sure that we don't have to get the entire content members list and do a direct match instead
 * Share a piece of content with a set of principals. This only be possible when the current user is a manager of the content, or if the current
 * user is logged in and the content item is public or visible to logged in users only. In case that the content is shared with principals that
 * are already content members, no updates to the existing role of those principals will be made
 * @param  {Context}   ctx               Standard context object containing the current user and the current tenant
 * @param  {String}    contentId         The content id of the content that is being shared
 * @param  {String[]}  principalIds      Array of principal ids with whom the content will be shared. By default, they will all be made members.
 * @param  {Function}  callback          Standard callback function takes arguments `err` and `content`
 * @param  {Object}    callback.err      Error object containing the error message
 * 
 */
var shareContent = module.exports.shareContent = function(ctx, contentId, principalIds, callback) {
    callback = callback || function() {};
    
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).notEmpty();
    validator.check(principalIds.length, {'code': 400, 'msg': 'The content must at least be shared with 1 user or group'}).min(1);
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to share content'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the user has access to the content
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }
        // Check if the content is visible to logged in users or public
        if (contentObj.visibility === ContentConstants.visibility.LOGGEDIN || contentObj.visibility === ContentConstants.visibility.PUBLIC) {
            _shareContent(ctx, contentObj, principalIds, callback);
        // Check if the user can manage the content
        } else {
            _canManage(ctx, contentId, function(err, canManage) {
                if (err) {
                    return callback(err);
                } else if (!canManage) {
                    return callback({'code': 401, 'msg': 'You are not allowed to share this content'});
                }
                _shareContent(ctx, contentObj, principalIds, callback);
            });
        }
    });
};

/**
 * Internal function used to share a piece of content with a set of principals. This function assume that the current user is allowed
 * to see and share the content. If some of the principals passed into this function are already content members, no updates to the 
 * existing role of those principals will be made.
 * @param  {Context}   ctx               The current execution context.
 * @param  {Content}   contentObj        Content object representing the content that is being shared
 * @param  {String[]}  principalIds      Array of principal ids with whom the content will be shared. By default, they will all be made members.
 * @param  {Function}  callback          Standard callback function takes arguments `err` and `content`
 * @param  {Object}    callback.err      Error object containing the error message
 */
var _shareContent = function(ctx, contentObj, principalIds, callback) {
    // Get the current members and filter out the ones that are already a member, as we want to avoid
    // turning an existing manager into a viewer
    _getAllContentMembers(contentObj.contentId, function(err, members) {
        if (err) {
            return callback(err);
        }
        var memberIds = _.map(members, function(member){ return member.id; });
        principalIds = _.difference(principalIds, memberIds);
        // Check if there are any principals left to share with
        if (principalIds.length === 0) {
            return callback(null);
        }

        // Make all of the remaining principals a member
        var shareObject = {};
        for (var p = 0; p < principalIds.length; p++) {
            shareObject[principalIds[p]] = ContentConstants.roles.VIEWER;
        }
        
        _setContentPermissions(ctx, contentObj, shareObject, callback);
    });
};

/**
 * Check whether or not the current user can manage a piece of content
 * @param  {Context}        ctx                 Standard context object, representing the currently logged user and its tenant
 * @param  {String}         contentId           The id of the content object we want to check
 * @param  {Function}       callback            Standard callback function takes arguments `err`, `canManage`, and `content`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Boolean}        callback.canManage  Whether or not the user can manage the content
 * @param  {Content}        callback.content    The retrieved content object containing its basic profile
 */
var canManage = module.exports.canManage = function(ctx, contentId, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).notEmpty();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to manage content'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            if (err.code === 401) {
                return callback(null, false);
            } else {
                return callback(err);
            }
        }
        _canManage(ctx, contentId, function(err, canManage) {
            if (err) {
                return callback(err);
            }
            callback(null, canManage, contentObj);
        });
    });
};

/**
 * Internal function that checks whether or not the current user can manage a piece of content. This function assumes that
 * the piece of content passed in actually exists
 * @param  {Context}        ctx                 Standard context object, representing the currently logged user and its tenant
 * @param  {String}         contentId           The id of the content object we want to check
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `canManage`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Boolean}        callback.canManage  Whether or not the user can manage the content
 */
var _canManage = function(ctx, contentId, callback) {
    AuthzAPI.hasRole(ctx.user().id, contentId, ContentConstants.roles.MANAGER, callback);
};

/**
 * Check whether or not the current user has access to a piece of content
 * @param  {Context}        ctx                 Standard context object, representing the currently logged user and its tenant
 * @param  {String}         contentId           The id of the content object we want to check
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `hasAccess`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Boolean}        callback.hasAccess  Whether or not the user has access to the content
 */
var hasAccess = module.exports.hasAccess = function(ctx, contentId, callback) {
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            // If the user doesn't have access to the content
            if (err.code ===  401) {
                return callback(null, false);
            } else {
                return callback(err);
            }
        }
        callback(null, true);
    });
};

/**
 * Internal function that checks whether or not the current user has access to a piece of content. This function assumes that
 * the piece of content passed in actually exists
 * @param  {Context}        ctx                 Standard context object, representing the currently logged user and its tenant
 * @param  {String}         contentId           The id of the content object we want to check
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `canManage`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Boolean}        callback.canManage  Whether or not the user has access to the content
 */
var _hasAccess = function(ctx, contentObj, callback) {
    // If the content is public, I always get access
    if (contentObj.visibility === ContentConstants.visibility.PUBLIC) {
        callback(null, contentObj);
    // If the content is visible to logged in people, I get access if I'm logged in
    } else if (contentObj.visibility === ContentConstants.visibility.LOGGEDIN) {
        if (ctx.user()) {
            callback(null, contentObj);
        } else {
            callback({'code': 401, 'msg': "You don't have access to this piece of content. Please try logging in"});
        }
    // If the content is private
    } else if (ctx.user()) {
        AuthzAPI.hasAnyRole(ctx.user().id, contentObj.contentId, callback);
    } else {
        callback({'code': 401, 'msg': "You don't have access to this piece of content. Please try logging in"});
    }
};

/**
 * Update, add or remove the role of a set of principals on a piece of content
 * @param  {Context}         ctx                 Standard context object, representing the currently logged user and its tenant
 * @param  {String}          contentId           The id of the content object we want to set permissions on
 * @param  {Object}          newPermissions      Object where the keys represent the principal ids for which the content permissions should be updated/added/removed. The value is a string representing the new role. If false is passed in, the permissions for that principal will be removed e.g. {'user1': 'manager', 'user2': 'viewer', 'user3': false}
 * @param  {Function}        callback            Standard callback function takes argument `err`
 * @param  {Object}          callback.err        Error object containing the error message
 */
var setContentPermissions = module.exports.setContentPermissions = function(ctx, contentId, newPermissions, callback) {
    callback = callback || {};
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).notEmpty();
    validator.check(_.keys(newPermissions).length, {'code': 400, 'msg': 'You should specify at least 1 user/group to set content permissions on'}).min(1);
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to create a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the content exists
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }
        // Check if the current user can manage the content
        _canManage(ctx, contentId, function(err, canManage) {
            if (err) {
                return callback(err);
            } else if (!canManage) {
                return callback({'code': 401, 'msg': 'You are not allowed to manage this piece of content'});
            }
            // Add the new permissions to the content. This will then update the libraries as well
            _setContentPermissions(ctx, contentObj, newPermissions, callback);
        });
    });
};

/**
 * Internal function used to update, add or remove the role of a set of principals on a piece of content. This function will assume that
 * the content object exists and that the current user is a manager of the content
 * @param  {Context}         ctx                 The current execution context
 * @param  {Content}         contentObj          The content object we want to set permissions on
 * @param  {Object}          newPermissions      Object where the keys represent the principal ids for which the content permissions should be updated/added/removed. The value is a string representing the new role. If false is passed in, the permissions for that principal will be removed e.g. {'user1': 'manager', 'user2': 'viewer', 'user3': false}
 * @param  {Function}        callback            Standard callback function takes argument `err`
 * @param  {Object}          callback.err        Error object containing the error message
 */
var _setContentPermissions = function(ctx, contentObj, newPermissions, callback) {
    // Check if all of the provided principals exist
    PrincipalsUtil.getPrincipals(ctx, _.keys(newPermissions), function(err, principals) {
        if (err) {
            return callback(err);
        }

        // Extract all of the users that are removed from the content, 
        // so the content can be removed from their library
        var removedMembers = [];
        for (var p in newPermissions) {
            if (newPermissions.hasOwnProperty(p) && newPermissions[p] === false) {
                removedMembers.push(p);
            }
        }
        // Update the roles CF
        AuthzAPI.updateRoles(contentObj.contentId, newPermissions, function(err) {
            if (err) {
                return callback(err);
            }
            // Now update all of the libraries this affects
            _updateLibraries(contentObj, removedMembers, callback);
        });
    });
};

/**
 * Get all of the principals that are directly associated to a piece of content.
 * @param  {Context}        ctx                 Standard context object, representing the currently logged user and its tenant
 * @param  {String}         contentId           The id of the content object for which we want to get the members
 * @param  {String}         start               Determines the point at which content members are returned for paging purposes.  If not provided, the first x elements will be returned
 * @param  {Integer}        limit               Number of items to return. Will default to 10 if not provided
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `members`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Object[]}       callback.members    Array that contains an object for each member. Each object has a role property that contains the role of the member and a profile property that contains the principal profile of the member
 */
var getContentMembers = module.exports.getContentMembers = function(ctx, contentId, start, limit, callback) {
    limit = limit || 10;

    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        // Get the content members
        AuthzAPI.getAuthzMembers(contentObj.contentId, start, limit, function(err, members) {
            if (err) {
                return callback(err);
            }

            // Get the basic profiles for all of these principals
            var memberIds = _.map(members, function(member){ return member.id; });
            PrincipalsUtil.getPrincipals(ctx, memberIds, function(err, memberProfiles) {
                if (err) {
                    return callback(err);
                }
                
                // Merge the member profiles and roles into a single object
                var memberList = [];
                for (var m = 0; m < members.length; m++) {
                    if (memberProfiles[members[m].id]) {
                        memberList.push({
                            'profile': memberProfiles[members[m].id],
                            'role': members[m].role
                        });
                    }
                }
                callback(null, memberList);
            });
        });
    });
};

/**
 * Internal function that gets all of the principals that are directly associated to a piece of content. This function assumes
 * that the current user has access to the content
 * @param  {String}         contentId           The id of the content object for which we want to get the members
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `members`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Object}         callback.members    Object for which the keys are principal ids and values are their roles on the content
 */
var _getAllContentMembers = function(contentId, callback) {
    AuthzAPI.getAuthzMembers(contentId, null, 10000, callback);
};

/////////////////////////////
// Update content metadata //
/////////////////////////////

/**
 * Internal function that updates the lastMofidied date of a piece of content to the current time. This will be called by all functions
 * that update content metadata or when content is shared. This function assume that a valid content object is passed in.
 * @param  {Content}           contentObj          The content object for which we want to update the lastModified date
 * @param  {Function}          callback            Standard callback function takes argument `err`
 * @param  {Object}            callback.err        Error object containing the error message
 */
var _updateContentLastModified = function(contentObj, callback) {
    contentObj.lastModified = Date.now();
    Cassandra.runQuery('UPDATE Content USING CONSISTENCY QUORUM SET ? = ? WHERE contentId = ?', ['lastModified', contentObj.lastModified, contentObj.contentId], callback);
};

/**
 * Update a content item's name, description or visibility. This can only be done by the manager of that piece of content.
 * @param  {Context}         ctx                 Standard context object, representing the currently logged user and its tenant
 * @param  {String}          contentId           The id of the content object for which we want to update the content profile
 * @param  {Object}          profileFields       Object where the keys represent the profile fields that need to be updated and the values represent the new values for those profile fields e.g. {'name': 'New content name', 'description': 'New content description', 'visibility': 'private'}
 * @param  {Function}        callback            Standard callback function takes argument `err`
 * @param  {Object}          callback.err        Error object containing the error message
 */
var updateContentMetadata = module.exports.updateContentMetadata = function(ctx, contentId, profileFields, callback) {
    callback = callback || function() {};
    
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).notEmpty();
    // Check that at a minimum name or description have been provided
    var fieldNames = profileFields ? _.keys(profileFields) : [];
    validator.check(fieldNames.length, {'code': 400, 'msg': 'You should at least specify a new name, description, visibility or link'}).min(1);
    for (var i = 0; i < fieldNames.length; i++) {
        var fieldName = fieldNames[i];
        validator.check(fieldName, {'code': 400, 'msg': fieldName + ' is not a recognized content profile field'}).isIn(['name', 'description', 'visibility', 'link']);
    }
    if (profileFields.hasOwnProperty('visibility')) {
        validator.check(profileFields['visibility'], {'code': 400, 'msg': 'An invalid content visibility option has been provided. This can be "private", "loggedin" or "public"'}).isIn(_.values(ContentConstants.visibility));
    }
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Do the actual update
    _updateContentMetadata(ctx, contentId, profileFields, callback);    
};

/**
 * Utility function that will be used to update metadata on a piece of content. Once the Content CF has been updated, 
 * the libraries in which the content shows will be updated as well. This function will assume that a valid contentId 
 * and valid content metadata is passed in
 * @param  {Context}         ctx                 Standard context object, representing the currently logged user and its tenant
 * @param  {String}          contentId           The id of the content object we want to update
 * @param  {Object}          metadata            Object where the keys represent the profile fields that need to be updated and the values represent the new values for those profile fields.
 * @param  {Function}        callback            Standard callback function takes argument `err`
 * @param  {Object}          callback.err        Error object containing the error message
 */
var _updateContentMetadata = function(ctx, contentId, metadata, callback) {
    // Fist check whether or not the current user is a manager of the piece of content
    canManage(ctx, contentId, function(err, canManage, contentObj) {
        if (err) {
            return callback(err);
        } else if (!canManage) {
            return callback({'code': 401, 'msg': 'You are not allowed to manage this piece of content'});
        }

        var q = Cassandra.constructUpsertCQL('Content', 'contentId', contentId, metadata, 'QUORUM');
        Cassandra.runQuery(q.query, q.parameters, function(err) {
            if (err) {
                return callback(err);
            }
            // Set the new metadata onto the content object
            contentObj = _.extend(contentObj, metadata);
            // Update the last modified date and all associated libraries
            _updateLibraries(contentObj, [], callback);
        });
    });
};

///////////////////////////
// Library functionality //
///////////////////////////

/**
 * Internal function that updates the libraries of all of the members of a piece of content. This will remove the old entry with
 * the old lastModified date/sorting and add the new one. This function assumes that a valid content item is passed in
 * @param  {Content}        contentObj          The content object for which we want to update in all libraries
 * @param  {String[]}       removedMembers      Array of principal ids that contains all principal that have been removed as a member of the content, and therefore their libraries should be updated so the content is removed.
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `members`
 * @param  {Object}         callback.err        Error object containing the error message
 */
var _updateLibraries = function(contentObj, removedMembers, callback) {
    // First update the lastmodified date of the content
    var oldLastModified = contentObj.lastModified;
    _updateContentLastModified(contentObj, function(err) {
        if (err) {
            return callback(err);
        }
        // Remove all of the old lastModified from everyone's library and add the new lastModified based one
        removedMembers = removedMembers || [];
        _getAllContentMembers(contentObj.contentId, function(err, members) {
            if (err) {
                return callback(err);
            }
            var queries = [];
            for (var m = 0; m < members.length; m++) {
                var member = members[m].id;
                // Only remove the old entries if the piece of content existed before and
                // the old lastModified date has been provided
                if (oldLastModified) {
                    // Remove the old entry in the private row
                    queries.push({
                        'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                        'parameters': [oldLastModified + ':' + contentObj.contentId, member]
                    });
                    // Remove the old entry in the loggedin row
                    queries.push({
                        'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                        'parameters': [oldLastModified + ':' + contentObj.contentId, member + '#' + ContentConstants.visibility.LOGGEDIN]
                    });
                    // Remove the old entry in the public row
                    queries.push({
                        'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                        'parameters': [oldLastModified + ':' + contentObj.contentId, member + '#' + ContentConstants.visibility.PUBLIC]
                    });
                }
                // Add it back to the private row
                queries.push({
                    'query': 'UPDATE LibraryByPrincipal SET ? = ? WHERE principalId = ?',
                    'parameters': [contentObj.lastModified + ':' + contentObj.contentId, contentObj.contentId, member]
                });
                // Add it back to the logged in row
                if (contentObj.visibility === ContentConstants.visibility.LOGGEDIN || contentObj.visibility === ContentConstants.visibility.PUBLIC) {
                    queries.push({
                        'query': 'UPDATE LibraryByPrincipal SET ? = ? WHERE principalId = ?',
                        'parameters': [contentObj.lastModified + ':' + contentObj.contentId, contentObj.contentId, member + '#' + ContentConstants.visibility.LOGGEDIN]
                    });
                }
                // Add it back to the public row
                if (contentObj.visibility === ContentConstants.visibility.PUBLIC) {
                    queries.push({
                        'query': 'UPDATE LibraryByPrincipal SET ? = ? WHERE principalId = ?',
                        'parameters': [contentObj.lastModified + ':' + contentObj.contentId, contentObj.contentId, member + '#' + ContentConstants.visibility.PUBLIC]
                    });
                }
            }
            // Remove the content from the libraries of all removed members
            for (var m = 0; m < removedMembers.length; m++) {
                if (oldLastModified) {
                    var removedMember = removedMembers[m];
                    // Remove the old entry in the private row
                    queries.push({
                        'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                        'parameters': [oldLastModified + ':' + contentObj.contentId, removedMember]
                    });
                    // Remove the old entry in the loggedin row
                    queries.push({
                        'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                        'parameters': [oldLastModified + ':' + contentObj.contentId, removedMember + '#' + ContentConstants.visibility.LOGGEDIN]
                    });
                    // Remove the old entry in the public row
                    queries.push({
                        'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                        'parameters': [oldLastModified + ':' + contentObj.contentId, removedMember + '#' + ContentConstants.visibility.PUBLIC]
                    });
                }
            }
            Cassandra.runBatchQuery(queries, 'QUORUM', callback);
        });
    });
};

/**
 * Get the content items inside of an authorizable's library. If the user requests its own library or the library of a group he's a member of,
 * the full list will be returned. If the user is logged in, but not a manager of the library, the :loggedin stream will be returned, containing
 * only content that's visible to logged in people or the public. In case of an anonymous user, the :public stream will be returned, containing
 * only content that is public.
 * @param  {Context}        ctx               Standard context object containing the current user and the current tenant
 * @param  {String}         principalId       The principal id of the library we're requesting
 * @param  {String}         start             Determines the point at which content items are returned for paging purposed. If not provided, the first x elements will be returned
 * @param  {Integer}        limit             Number of items to return. Will default to 10 if not provided
 * @param  {Function}       callback          Standard callback function takes arguments `err` and `content`
 * @param  {Object}         callback.err      Error object containing the error message
 * @param  {Content[]}      callback.content  Array of basic content profiles representing the requested items in the library
 */
var getLibraryItems = module.exports.getLibraryItems = function(ctx, principalId, start, limit, callback) {
    limit = limit || 10;

    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'A user or group id must be provided'}).notEmpty();
    validator.check(limit, {'code': 400, 'msg': 'A valid limit should be passed in'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if we are looking at a user library
    if (PrincipalsUtil.isUser(principalId)) {
        // We give the user the public content stream in case the user is not logged in
        if (!ctx.user()) {
            principalId = principalId + '#' + ContentConstants.visibility.PUBLIC;
        // We give the user the logged in content stream in case the current user is not
        // the same as the library we're looking at
        } else if (ctx.user().id !== principalId) {
            principalId = principalId + '#' + ContentConstants.visibility.LOGGEDIN;
        }
        _getLibraryItems(principalId, start, limit, callback);
    // Check if we are looking at a group library
    } else if (PrincipalsUtil.isGroup(principalId)) {
        // We give the user the public content stream in case the user is not logged in
        if (!ctx.user()) {
            principalId = principalId + '#' + ContentConstants.visibility.PUBLIC;
            _getLibraryItems(principalId, start, limit, callback);
        } else {
            // Check if the current user is a member of the group
            AuthzAPI.hasAnyRole(ctx.user().id, principalId, function(err, hasAnyRole) {
                if (err) {
                    return callback(err);
                }

                // If the user is not a member, we give him the logged in content stream
                if (!hasAnyRole) {
                    principalId = principalId + '#' + ContentConstants.visibility.LOGGEDIN;
                }

                _getLibraryItems(principalId, start, limit, callback);
            });
        }
    // If the passed in principal id is neither a group or user, we return an error
    } else {
        return callback({'code': 400, 'msg': 'An unrecognized principal id has been passed in'});
    }
};

/**
 * Internal function that will be used to get a user's or group's library. This function assumes that all permission check will have
 * been done and the processed principal id is passed in. It also assumes that a valid start and limit parameter are passed in.
 * @param  {String}         principalId       The principal id of the library we're requesting. This is the processed library principal id, meaning that it will be the principal id when direct access is allowed, principalId:loggedin if the user is logged in or principalId:public for anonymous users
 * @param  {String}         start             Determines the point at which content items are returned for paging purposed.  If not provided, the first x elements will be returned
 * @param  {Integer}        limit             Number of items to return. Will default to 10 if not provided
 * @param  {Function}       callback          Standard callback function takes arguments `err` and `content`
 * @param  {Object}         callback.err      Error object containing the error message
 * @param  {Content[]}      callback.content  Array of basic content profiles representing the requested items in the library
 */
var _getLibraryItems = function(principalId, start, limit, callback) {
    // Page the query.
    var paging = Cassandra.getPagingParameters(start, limit);

    Cassandra.runQuery("SELECT first " + paging.limit + " ?..\'\' FROM LibraryByPrincipal USING CONSISTENCY QUORUM WHERE principalId = ?", [paging.start, principalId], function (err, rows) {
        if (err) {
            return callback(err);
        }

        var items = [];
        for (var r = paging.startIndex; r < rows[0].count; r++) {
            var name = rows[0][r].name;
            if (name !== 'principalId') {
                items.push(rows[0][r].value);
            }
        }
        // Get the content profiles of the content items, assuming that
        // we have access to all of the returned items
        _getMultipleContentItems(items, callback);
    });
};

///////////////////////
// Utility functions //
///////////////////////

/**
 * Creates a Content item from a Cassandra row.
 * @param  {Row}    row    Cassandra Row
 * @return {Group}         Converted content object
 */
var _rowToContent = function (row) {
    var hash = Cassandra.rowToHash(row);
    return new Content(hash.tenant, hash.contentId, hash.visibility, hash.name, hash.description, hash.contentType, hash.createdBy, hash.created, hash.lastModified);
};
