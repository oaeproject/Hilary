/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var _ = require('underscore');

var Cassandra = require('oae-util/lib/cassandra');
var log = require('oae-logger').logger('oae-activity');

// Time-to-live for activities is 2 weeks (in seconds). They disappear from feeds after that time.
var DEFAULT_TTL = 2 * 7 * 24 * 60 * 60;

var ttl = null;

/**
 * Refresh the configuration of the DAO.
 *
 * @param   {Number}    [activityTtl]   The time-to-live (in seconds) for generated activities. Defaults to 2 weeks.
 */
var refreshConfiguration = module.exports.refreshConfiguration = function(activityTtl) {
    ttl = (!activityTtl || isNaN(activityTtl)) ? DEFAULT_TTL : activityTtl;
};

/**
 * Get a list of activities from the specified activity stream.
 *
 * @param   {String}        activityStreamId    The ID of the activity stream
 * @param   {Number|String} start               Number of millis since the epoc (stringified or number version) from which to start returning activities. Only activities older than this timestamp will be returned.
 * @param   {Number}        limit               The number of activities to return
 * @param   {Function}      callback            Invoked when the process completes
 * @param   {Object}        callback.err        An error that occurred, if any
 * @param   {Activity[]}    callback.activities The list of activities
 */
var getActivities = module.exports.getActivities = function(activityStreamId, start, limit, callback) {
    limit = limit || 25;
    var paging = Cassandra.getPagingParameters(start, limit);
    var activities = [];

    // Selecting with consistency ONE as having great consistency is not critical for activities
    Cassandra.runQuery('SELECT FIRST ? ? .. \'\' FROM ActivityStreams USING CONSISTENCY ONE WHERE activityStreamId = ?', [paging.limit, paging.start, activityStreamId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        return callback(null, _rowToActivities(rows[0]));
    });
};

/**
 * Save an activity to a list of routes.
 *
 * @param   {Object}    routeActivities A hash, mapping route -> Activity, outlining which activities should be saved to which routes
 * @param   {Function}  [callback]      Invoked when the process completes
 * @param   {Object}    [callback.err]  An error that occurred, if any
 */
var saveActivities = module.exports.saveActivities = function(routeActivities, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Error saving routes to database.');
        }
    };
    
    var queries = [];
    var routes = _.keys(routeActivities);
    for (var i = 0; i < routes.length; i++) {
        var route = routes[i];
        var activity = routeActivities[route];
        var activityStr = JSON.stringify(activity);
        var timestamp = activity.published;
        queries.push({
            'query': 'UPDATE ActivityStreams USING TTL ' + ttl + ' SET ? = ? WHERE activityStreamId = ?',
            'parameters': [timestamp, activityStr, route]
        });
    }

    // Saving activities with consistency ONE because consistency is not critical for activities
    Cassandra.runBatchQuery(queries, 'ONE', callback);
};

/**
 * Convert a Cassandra row into an array of activities extracted from its columns.
 *
 * @param   {Row}       row         The Cassandra row from which to extract the activities
 * @return  {Object}                The activities that were extracted from the rows
 */
var _rowToActivities = function(row) {
    var activities = [];
    row.forEach(function(name, value) {
        try {
            activities.push(JSON.parse(value));
        } catch (err) {
            log().warn({'err': err}, 'Error parsing activity value.');
        }
    });
    return activities;
};

