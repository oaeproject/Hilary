/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var ShortId = require('shortid');

var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var log = require('oae-logger').logger('content-dao');
var OaeUtil = require('oae-util/lib/util');

var Revision = require('oae-content/lib/model').Revision;


///////////////
// Retrieval //
///////////////


/**
 * Get a set of revisions.
 *
 * @param  {String}         contentId           The id of the object for which we want to get the revisions
 * @param  {String}         start               Determines the point at which revisions are returned for paging purposes.  If not provided, the first x elements will be returned
 * @param  {Integer}        limit               Number of revisions to return. Will default to 10 if not provided
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `revisions`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Revision[]}     callback.revisions  Array that contains an object for each revision.
 */
var getRevisions = module.exports.getRevisions = function(contentId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10);

    Cassandra.runPagedColumnQuery('RevisionByContent', 'contentId', contentId, start, limit, {'reversed': true}, function(err, row) {
        if (err) {
            return callback(err);
        } else if (row.count === 0) {
            return callback(null, []);
        }

        var revisionsToRetrieve = [];
        row.forEach(function(name, value) {
            revisionsToRetrieve.push(value);
        });
        
        Cassandra.runQuery('SELECT * FROM Revisions WHERE revisionId IN (?)', [revisionsToRetrieve], function(err, rows) {
            if (err) {
                return callback(err);
            }

            // Generate the Revision objects.
            var revisions = [];
            for (var i = 0; i < rows.length; i++) {
                var revision = _rowToRevision(rows[i]);
                revisions.push(revision);
            }
            callback(null, revisions);
        });
    });
};

/**
 * Get a specific revision.
 *
 * @param  {String}     revisionId          The ID of the revision to retrieve.
 * @param  {Function}   callback            Standard callback function takes arguments `err` and `revision`
 * @param  {Object}     callback.err        Error object containing the error message
 * @param  {Revision}   callback.revision   The retrieved revision
 */
var getRevision = module.exports.getRevision = function(revisionId, callback) {
    Cassandra.runQuery('SELECT * FROM Revisions WHERE revisionId = ?', [revisionId], function (err, rows) {
        if (err) {
            return callback(err);
        }

        // Cassandra always returns the key as a column so the count property will always be 1.
        if (rows[0].count <= 1) {
            return callback({'code': 404, 'msg': 'Couldn\'t find revision: ' + revisionId});
        }

        var revision = _rowToRevision(rows[0]);
        callback(null, revision);
    });
};


///////////////
// Modifiers //
///////////////

/**
 * Create a new revision in the database.
 *
 * @param  {String}     contentId           The contentId this revision is forctx.tenant().alias,
 * @param  {String}     tenantAlias         The alias of the tenant on which this revision is created
 * @param  {String}     createdBy           The ID of the user who created this revision
 * @param  {String}     uri                 A URI for this revision
 * @param  {Object}     [opts]              Extra options that should be stored on the revision
 * @param  {Function}   [callback]          An optional callback method.
 * @param  {Object}     [callback.err]      An error object (if any)
 * @param  {Revision}   [callback.revision] A revision object.
 */
var createRevision = module.exports.createRevision = function(contentId, tenantAlias, createdBy, uri, opts, callback) {
    // Copy all the options (if any)
    var values = _.extend({}, opts);

    // Add some more meta data.
    values.contentId = contentId;
    values.created = Date.now();
    values.createdBy = createdBy;
    values.uri = uri;
    var revisionId = AuthzUtil.toId('rev', tenantAlias, ShortId.generate());

    var q = Cassandra.constructUpsertCQL('Revisions', 'revisionId', revisionId, values, 'QUORUM');
    Cassandra.runQuery(q.query, q.parameters, function(err) {
        if (err) {
            return callback(err);
        }

        // Add the revision to the list.
        Cassandra.runQuery('UPDATE RevisionByContent SET ?=? WHERE contentId=?', [values.created, revisionId, contentId], function(err) {
            if (err) {
                return callback(err);
            }
            var revision = new Revision(contentId, revisionId, values.createdBy, values.created, values.uri, opts);
            callback(null, revision);
        });
    });
};


///////////////////////
// Utility functions //
///////////////////////


/**
 * Converts a Cassandra Row to a Revision object.
 *
 * @param  {Row}        row         A Helenus Row
 * @return {Revision}               A revision object or null if the column could not be converted.
 * @api private
 */
var _rowToRevision = function(row) {
    var hash = Cassandra.rowToHash(row);
    var opts = {};
    opts.mime = hash.mime || 'application/octet-stream';
    if (hash.filename) {
        opts.filename = hash.filename;
    }
    if (hash.size) {
        opts.size = hash.size;
    }
    var revision = new Revision(hash.contentId, hash.revisionId, hash.createdBy, hash.created, hash.uri, opts);
    revision.link = '/api/content/' + revision.contentId + '/download/' + revision.revisionId;
    return revision;
};
