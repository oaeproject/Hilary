/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var crypto = require('crypto');
var GoogleStrategy = require('passport-google').Strategy;
var OpenIDStrategy = require('passport-openid').Strategy;
var LocalStrategy = require('passport-local').Strategy;
var util = require('util');
var Validator = require('validator').Validator

var log = require('oae-logger').logger('oae-authentication');
var Context = require('oae-context').Context;
var PrincipalAPI = require('oae-principals');
var LoginId = require('oae-principals/lib/model').LoginId;
var User = require('oae-principals/lib/model').User;

/**
 * Utility method that gets a user by the tenant+provider+externalId combo. If no user was found it will be created.
 *
 * @param  {Context}                context         The current tenant
 * @param  {String}                 provider        The authentication mechanism providing the external userId
 * @param  {String}                 externalId      The externalId of the user
 * @param  {String}                 locale          The locale of this user.
 * @param  {String}                 timezone        The timezone of this user.
 * @param  {String}                 displayName     The prefered display name of this user.
 * @param  {Function(err, user)}    callback        A function returning the user.
 * @param  {Object}                 callback.err    An error that occured, if any
 * @param  {Boolean}                callback.user   The user object
 */
var getOrCreateUser = function(ctx, provider, externalId, locale, timezone, displayName, callback) {
    var tenantId = ctx.tenant().alias;
    var loginId = new LoginId(provider, externalId);

    // Check if this user already exists in our DB.
    PrincipalAPI.getUserIdByLoginId(loginId, tenantId, function(err, userId) {
        if (err) {
            return callback(err);
        }

        if (!userId) {
            // user did not exist, automatically create them
            log(ctx).debug({loginId: loginId}, 'Automatically creating user "%s" by local authentication.', displayName);
            return createUser(ctx, loginId, locale, timezone, displayName, callback);
        } else {
            // grab the full user metadata
            PrincipalAPI.getUser(ctx, userId, function(err, user) {
                if (err && err.code !== 404) {
                    return callback(err);
                } else if (err && err.code === 404) {
                    // If this happens, it means a user login id existed that mapped to a non-existent user. This should not
                    // ever be the case aside from a bug.
                    log(ctx).warn({loginId: loginId}, 'User had a login ID entry that did not map to an existing user.');
                    return createUser(ctx, loginId, locale, timezone, displayName, callback);
                }

                return callback(null, user);
            });
        }
    });
};

/**
 * Auto-create a user in the database.
 * 
 * @param {Context}                 ctx             The context of the request.
 * @param {LoginId}                 loginId         The loginId associated to the user
 * @param {String}                  locale          The locale of the user
 * @param {String}                  timezone        The timezone of the user
 * @param {String}                  displayName     The display name of the user
 * @param {Function(err, user)}     callback        Standard callback function, invoked when the process completes
 * @param {Object}                  callback.err    An error that occurred, if any
 * @param {User}                    callback.user   The user metadata that was created
 */
var createUser = function(ctx, loginId, locale, timezone, displayName, callback) {

    // Sometimes we can get a timezone from an external auth that we don't support
    // Rather than borking up the create user call, we set it to null so it automatically
    // gets stored with the server's timezone (UTC).
    // The user can then change it in the UI if he wishes to do so.
    if (timezone) {
        var validator = new Validator();
        validator.check(timezone).isValidTimeZone();
        if (validator.hasErrors()) {
            timezone = null;
        }
    }

    // we generate a random password when creating the user automatically
    var password = crypto.randomBytes(128).toString('hex');
    var opts = {
        'visibility': 'public',
        'locale': locale,
        'timezone': timezone
    };

    PrincipalAPI.createUser(ctx, loginId, password, displayName, opts, function(err, userId) {
        if (err) {
            return callback(err);
        }

        // Get the meta data for this user.
        ctx = new Context(ctx.tenant(), new User(ctx.tenant().alias, userId));
        PrincipalAPI.getUser(ctx, userId, callback);
    });
}


/////////////
//  LOCAL  //
/////////////

module.exports.LocalStrategyWrapper = function(tenant) {
    var options = {
        'passReqToCallback': true,
        'failureRedirect': false
    };

    var strat = new LocalStrategy(options, function(req, username, password, done) {
        var loginId = new LoginId('local', username);

        PrincipalAPI.getUserIdByLoginId(loginId, tenant.alias, function(err, userId) {
            if (err) {
                return done(err);
            } else if (!userId) {
                // user with this login id does not exist
                return done(null, false);
            }

            PrincipalAPI.checkPassword(userId, password, function(err, basicUser) {
                if (err && err.code !== 401) {
                    return done(err);
                } else if (err && err.code === 401) {
                    return done(null, false);
                }

                // By this point we know that we were succesfully logged in.
                // Retrieve the user account and stick it in the context.
                req.ctx = new Context(tenant, new User(tenant.alias, basicUser.id));
                PrincipalAPI.getUser(req.ctx, basicUser.id, function(err, user) {
                    if (err) {
                        return done(err);
                    }
                    req.ctx = new Context(tenant, user);
                    return done(null, user);
                });
            });
        });
        
    });
    strat.name = 'local-' + tenant.alias;
    return strat;
};



//////////////
//  GOOGLE  //
//////////////

module.exports.GoogleCallbackWrapper = function(tenant) {
    var that = {};
    that.context = new Context(tenant, null);
    that.callback = function(identifier, profile, done) {
        var externalId = profile.emails[0].value;
        var displayName = profile.name.givenName + " " + profile.name.familyName;

        // TODO: Get locale/timezone.
        getOrCreateUser(that.context, 'google', externalId, 'en_GB', 'Europe/London', displayName, done);
    };
    return that;
};


module.exports.GoogleStrategyWrapper = function(tenant, validate) {
    var options = {
        'providerURL': 'https://www.google.com/accounts/o8/id',
        'profile': true,
        'returnURL' : 'http://' + tenant.baseUrl + '/api/auth/google/return',
        'realm': 'http://' + tenant.baseUrl + '/'
    };

    OpenIDStrategy.call(this, options, validate);
    this.name = 'google-' + tenant.alias;
};
util.inherits(module.exports.GoogleStrategyWrapper, GoogleStrategy);



///////////////
//  TWITTER  //
///////////////

module.exports.TwitterCallbackWrapper = function(tenant) {
    var that = {};
    that.context = new Context(tenant, null);
    that.callback = function(token, tokenSecret, profile, done) {
        // Use the Twitter handle to register this user.
        var externalId = profile.username;
        var displayName = profile.displayName;

        // TODO: Get proper locale
        var locale = 'en_GB';
        var timezone = profile._json.time_zone;

        getOrCreateUser(that.context, 'twitter', externalId, locale, timezone, displayName, done);
    };
    return that;
};



////////////////
//  FACEBOOK  //
////////////////

module.exports.FacebookCallbackWrapper = function(tenant) {
    var that = {};
    that.context = new Context(tenant, null);
    that.callback = function(accessToken, refreshToken, profile, done) {
        // Use the Twitter handle to register this user.
        var externalId = profile.username;
        var displayName = profile.displayName || profile.name.givenName + ' ' + profilename.familyName;
        var locale = profile._json.locale;
        // TODO: get proper timezone.
        var timezone = 'Europe/London';

        getOrCreateUser(that.context, 'facebook', externalId, locale, timezone, displayName, done);
    };
    return that;
};
