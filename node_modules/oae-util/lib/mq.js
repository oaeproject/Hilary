/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var amqp = require('amqp');
var events = require('events');
var util = require('util');

var log = require('oae-logger').logger('mq');
var OAE = require('./oae');

var connection = null;
var queueExchange = null;
var queues = {};

var initialized = false;

var numMessagesInProcessing = 0;
var messagesInProcessing = {};

var MAX_NUM_MESSAGES_IN_PROCESSING = 1000;
var NUM_MESSAGES_TO_DUMP = 10;

/**
 * ## RabbitMQ API
 *
 * ### Events
 *
 *  * `preSubmit(name, data)`                               - Invoked just before a task is submit to the task handler (in the same process tick).
 *  * `preHandle(name, data, headers, deliveryInfo)`        - Invoked just before a task handler is invoked with the task data (in the same process tick in which the task was received).
 *  * `postHandle(err, name, data, headers, deliveryInfo)`  - Invoked after the task handler finishes processing (or if an exception is thrown in the same process tick in which it is invoked).
 *  * `idle`                                                - Invoked when all current tasks have been completed and the worker is no longer processing any tasks
 */
var MQ = module.exports = new events.EventEmitter();

/**
 * MQ constants.
 *
 *  {String}    DEFAULT_TASK_EXCHANGE_NAME          The name of the AMQP task exchange
 *  {Object}    DEFAULT_TASK_EXCHANGE_OPTS          The default options to specify when creating the AMQP task exchange
 *  {Object}    DEFAULT_TASK_QUEUE_OPTS             The default options to specify when creating the AMQP task queue
 *  {Object}    DEFAULT_TASK_QUEUE_PUBLISH_OPTS     The default options to specify when publishing tasks on the AMQP task queue
 *  {Object}    DEFAULT_TASK_QUEUE_SUBSCRIBE_OPTS   The default options to specify when subscribing to a task queue.
 */
var Constants = module.exports.Constants = {
    'DEFAULT_TASK_EXCHANGE_NAME': 'oae-taskexchange',
    'DEFAULT_TASK_EXCHANGE_OPTS': {
        'type': 'direct',
        'durable': true,
        'autoDelete': false
    },
    'DEFAULT_TASK_QUEUE_OPTS': {
        'durable': true,
        'autoDelete': false
    },
    'DEFAULT_TASK_QUEUE_PUBLISH_OPTS': {
        'deliveryMode': 2                   // 2 indicates 'persistent'
    },
    'DEFAULT_TASK_QUEUE_SUBSCRIBE_OPTS': {
        'ack': true,
        'prefetchCount': 15
    }
};

var deferredTaskHandlers = {};
var ready = false;

OAE.on('ready', function() {
    ready = true;

    var numberToBind = _.keys(deferredTaskHandlers).length;
    var numberBound = 0;
    var returned = false;

    /*!
     * Monitors all the deferred task handlers that have been bound, emitting a 'ready' event
     * when all have been bound.
     */
    var _monitorBinding = function(err) {
        if (returned) {
            // Do nothing, we've called back
            return;
        } else if (err) {
            MQ.emit('ready', err);
            returned = true;
            return;
        }

        numberBound++;
        if (!returned && numberBound >= numberToBind) {
            MQ.emit('ready');
            returned = true;
        }
    };

    if (numberToBind > 0) {
        // Bind all the deferred task handlers now that the container is ready
        _.each(deferredTaskHandlers, function(handlerInfo, taskName) {
            bind(taskName, handlerInfo.listener, handlerInfo.options, _monitorBinding);
            delete deferredTaskHandlers[taskName];
        });
    } else {
        // No deferred task handlers, we're just immediately ready
        MQ.emit('ready');
    }
});

/**
 * Initialize the Message Queue system so that it can start sending and receiving messages.
 *
 * @param   {Object}    mqConfig        The MQ Configuration object
 * @param   {Function}  callback        Invoked when initialization completes
 * @param   {Object}    callback.err    An error that occurred, if any
 */
var init = module.exports.init = function(mqConfig, callback) {
    if (!connection) {
        log().info('Initializing RabbitMQ connector.');

        connection = amqp.createConnection(mqConfig.connection);

        // When the connection drops away, we try to reconnect every 15 seconds.
        connection.setImplOptions({'reconnect': true, 'reconnectBackoffTime': 15000});

        connection.on('error', function(err) {
            log().error({'err': err}, 'Error connecting to RabbitMQ.');

            // Since this connection can error, retry, and become ready again, ensure we only continue the
            // initialization cycle once.
            if (!initialized) {
                initialized = true;
                return callback();
            }
        });

        connection.on('close', function() {
            log().info('Closed connection to RabbitMQ');
        });

        connection.on('ready', function() {
            log().info('Connection to RabbitMQ established.');

            // Initialize the exchange for the job queues
            connection.exchange(Constants.DEFAULT_TASK_EXCHANGE_NAME, Constants.DEFAULT_TASK_EXCHANGE_OPTS, function(exchange) {
                queueExchange = exchange;

                // Since this connection can error, retry, and become ready again, ensure we only continue the
                // initialization cycle once.
                if (!initialized) {
                    initialized = true;
                    return callback();
                }
            });
        });
    } else {
        log().warn('Attempted to initialize an existing RabbitMQ connector. Ignoring');
        callback();
    }
};

/**
 * Safely shutdown the MQ service after all current tasks are completed.
 *
 * @param  {Function}   Invoked when shutdown is complete
 */
var destroy = module.exports.destroy = function(callback) {
    // Unbind all task queues so we don't receive new messages
    log().info('Unbinding all task queues for shut down...');
    _unbindAll(function() {
        // Give 15 seconds for mq tasks to complete processing
        log().info('Waiting until all processing tasks complete...');
        _waitUntilIdle(15000, callback);
    });
};

OAE.registerPreShutdownHandler('mq', null, destroy);

/**
 * Bind a function to listen for a particular type of task. When bound, the node effectively becomes a "worker" for that task,
 * meaning when it receives a particular job, no other node active in the cluster will receive it.
 *
 * @param   {String}    name                                The unique label that identifies the type of job this binding is listening to
 * @param   {Function}  listener                            The function that will handle tasks of the given type
 * @param   {Object}    listener.data                       The data that was sent in the job. This is different depending on the type of job
 * @param   {Object}    [options]                           A set of options that can override the default ones.
 * @param   {Object}    [options.queue]                     Holds the options that will override the `Constants.DEFAULT_TASK_QUEUE_OPTS` options.
 * @param   {Object}    [options.subscribe]                 Holds the options that will override the `Constants.DEFAULT_TASK_QUEUE_SUBSCRIBE_OPTS` options.
 * @param   {Number}    [options.subscribe.prefetchCount]   The maximum number of tasks that a listener should handle concurrently.
 * @param   {Function}  [callback]                          Invoked after the listener has been bound to the MQ
 * @param   {Object}    [callback.err]                      An error that occurred binding to the task queue, if any
 */
var bind = module.exports.bind = function(name, listener, options, callback) {
    callback = callback || function(err) { /* error is logged within the implementation */ };
    options = options || {};
    options.queue = options.queue || {};
    options.subscribe = options.subscribe || {};

    if (queues[name] || (!ready && deferredTaskHandlers[name])) {
        log().warn({
            'queueName': name,
            'listener': listener
        }, 'Attempted to bind duplicate listener for job queue. Aborting.');
        return callback();
    }

    // If the container is not ready to handle requests, defer the actual binding of these handlers until later
    if (!ready) {
        log().trace({'name': name}, 'Deferring registration of task handler until server is ready.');
        deferredTaskHandlers[name] = {'listener': listener, 'options': options};
        return callback();
    }

    // Create/get the queue.
    var queueOptions = _.defaults(options.queue, Constants.DEFAULT_TASK_QUEUE_OPTS);
    connection.queue(name, queueOptions, function(queue) {
        queues[name] = {'queue': queue};
        log().info({'queueName': name}, 'Created a RabbitMQ task queue');

        // Bind the queue to the task exchange. The routing key is the same as the name of the job queue
        queue.bind(Constants.DEFAULT_TASK_EXCHANGE_NAME, name, function() {

            // Bind the listener to the queue, to handle all jobs of the given `name` type
            var subscribeOptions = _.defaults(options.subscribe, Constants.DEFAULT_TASK_QUEUE_SUBSCRIBE_OPTS);
            queue.subscribe(subscribeOptions, function(data, headers, deliveryInfo, message) {
                log().trace({
                    'queueName': name,
                    'data': data,
                    'headers': headers,
                    'deliveryInfo': deliveryInfo
                }, 'Received an MQ message.');

                var deliveryKey = util.format('%s:%s', deliveryInfo.queue, deliveryInfo.deliveryTag);

                // Indicate that this server has begun processing a new task
                _incrementProcessingTask(deliveryKey, data, deliveryInfo);
                MQ.emit('preHandle', name, data, headers, deliveryInfo);

                // Pass it to the listener.
                // We can only shift this element off the queue, once the listener has finished
                try {
                    listener(data, function() {
                        log().trace({
                            'queueName': name,
                            'data': data,
                            'headers': headers,
                            'deliveryInfo': deliveryInfo
                        }, 'MQ message has been processed by the listener.');

                        // Acknowledge that we've seen the message.
                        // Note: We can't use queue.shift() as that only acknowledges the last message that the queue handed to us.
                        // This message and the last message are not necessarily the same if the prefetchCount was higher than 1.
                        message.acknowledge();

                        // Indicate that this server has finished processing the task
                        _decrementProcessingTask(deliveryKey, deliveryInfo);
                        MQ.emit('postHandle', null, name, data, headers, deliveryInfo);

                    });
                } catch (err) {
                    log().error({
                        'err': err,
                        'queueName': name,
                        'data': data
                    }, 'Exception raised while handling job.');

                    // Acknowledge that we've seen the message.
                    message.acknowledge();

                    // Indicate that this server has finished processing the task
                    _decrementProcessingTask(deliveryKey, deliveryInfo);
                    MQ.emit('postHandle', err, name, data, headers, deliveryInfo);
                }
            }).addCallback(function(ok) {
                if (!ok) {
                    log().error({'err': err, 'queueName': name}, 'Error binding worker for task queue.');
                    return _destroyQueue(name, function(err) {
                        // Don't overwrite the original error with any binding errors
                        return callback(new Error('Error binding worker for task queue.'));
                    });
                }

                // Keep the consumerTag so we can unsubscribe later.
                queues[name].consumerTag = ok.consumerTag;
                return callback();
            });
        });
    });
};

/**
 * Unbind this node as a worker for the specified type of task.
 *
 * @param   {String}    name            The name of the task to which to unbind this node
 * @param   {Function}  callback        Invoked when the task has been unbound
 * @param   {Object}    callback.err    An error that occurred, if any
 */
var unbind = module.exports.unbind = function(name, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'queueName': name}, 'Error unbinding task queue handler.');
        }
    };
    _destroyQueue(name, callback);
};

/**
 * Submit a job to the task queue to be picked up by some arbitrary node in the cluster.
 *
 * @param   {String}    name        The type of job to submit
 * @param   {Object}    data        The data to send with the task. This will be received by the worker for this type of task
 * @param   {Function}  callback    Invoked when the job has been submitted
 */
var submit = module.exports.submit = function(name, data, callback) {
    callback = callback || function() {};

    MQ.emit('preSubmit', name, data);

    // We publish with the routing key `name`, which routes it to the queue (if any) that is listening on this key
    queueExchange.publish(name, data, Constants.DEFAULT_TASK_QUEUE_PUBLISH_OPTS);
    return callback();
};

/**
 * Get the names of all the task handlers that are bound to the service.
 *
 * @return {String[]}   A list of all the names of the bound task handlers
 */
var getTaskHandlerNames = module.exports.getTaskHandlerNames = function() {
    return _.keys(queues);
};

/**
 * Unbind all task handlers from the task queue.
 *
 * @param  {Function}   callback    Invoked when the handlers have been unbound
 * @api private
 */
var _unbindAll = function(callback) {
    var queueNames = getTaskHandlerNames();
    var queuesUnbound = 0;
    if (queueNames.length > 0) {
        _.each(queueNames, function(queueName) {
            log().info({'queueName': queueName}, 'Attempting to unbind a task queue.');
            _destroyQueue(queueName, function(err) {
                queuesUnbound++;

                if (!err) {
                    log().info({'queueName': queueName}, 'Successfully unbound a task queue.');
                }

                if (queuesUnbound === queueNames.length) {
                    return callback();
                }
            });
        });
    } else {
        return callback();
    }
};

/**
 * Wait until our set of pending tasks has drained. If it takes longer than `maxWaitMillis`, it will
 * dump the pending tasks in the log that are holding things up and force continue.
 *
 * @param  {Number}     maxWaitMillis   The maximum amount of time (in milliseconds) to wait for pending tasks to finish
 * @param  {Function}   callback        Invoked when processing has completed (or we've force-continued)
 * @api private
 */
var _waitUntilIdle = function(maxWaitMillis, callback) {
    if (numMessagesInProcessing <= 0) {
        log().info('Successfully entered into idle state.');
        return callback();
    }

    /*!
     * Gives at most `maxWaitMillis` time to finish. If it doesn't, we suspect we have leaked messages and
     * output a certain amount of them to the logs for inspection.
     */
    var forceContinueHandle = setTimeout(function() {
        _dumpProcessingMessages('Timed out ' + maxWaitMillis + 'ms while waiting for tasks to complete.');
        MQ.removeListener('idle', callback);
        return callback();
    }, maxWaitMillis);

    MQ.once('idle', function() {
        log().info('Successfully entered into idle state.');
        clearTimeout(forceContinueHandle);
        return callback();
    });
};

/**
 * Purge a queue.
 *
 * @param  {String}     name            The name of the queue to purge. This is the same name as the label you use to bind to a queue.
 * @param  {Function}   [callback]      Standard callback method
 * @param  {Object}     [callback.err]  An error that occurred purging the task queue, if any
 */
var purge = module.exports.purge = function(name, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'queueName': name}, 'Error purging queue.');
        }
    };

    log().info({'queueName': name}, 'Purging queue.');
    queues[name].queue.purge().addCallback(function(ok) {
        if (!ok) {
            log().error({'err': err, 'queueName': name}, 'Error purging task queue.');
            return callback({'code': 500, 'msg': 'Error purging task queue: ' + name});
        }

        return callback();
    });
};

/**
 * Purges all the known queues.
 * Note: This does *not* purge all the queues that are in RabbitMQ.
 * It only purges the queues that are known to the OAE system.
 *
 * @param  {Function}   [callback]      Standard callback method
 * @param  {Object}     [callback.err]  An error that occurred purging the task queue, if any
 */
var purgeAll = module.exports.purgeAll = function(callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Error purging all known queues.');
        }
    };

    // Get all the known queues we can purge.
    var toPurge = _.keys(queues);
    log().info({'queues': toPurge}, 'Purging all known queues.');

    /*!
     * Purges one of the known queues and calls the callback method when they are all purged (or when an error occurs.)
     *
     * @param  {Object}  err    Standard error object (if any.)
     * @api private
     */
    var doPurge = function(err) {
        if (err) {
            return callback(err);
        }

        if (toPurge.length === 0) {
            callback();
        } else {
            var queueToPurge = toPurge.pop();
            purge(queueToPurge, doPurge);
        }
    };

    // Start purging.
    doPurge();
};

/**
 * Destroy the managed task queue with the given name.
 *
 * @param   {String}    name            The type of the job message queue to destroy.
 * @param   {Function}  callback        Invoked when the process completes
 * @param   {Object}    callback.err    An error that occurred, if any
 * @api private
 */
var _destroyQueue = function(name, callback) {
    var queue = queues[name];
    if (!queue || !queue.queue) {
        log().warn({'queueName': name}, 'Attempted to unbind listener from non-existant job queue. Ignoring.');
        return callback();
    }

    var consumerTag = queue.consumerTag;
    queue = queue.queue;

    queue.unsubscribe(consumerTag).addCallback(function(ok) {
        delete queues[name];

        if (!ok) {
            log().error({'queueName': name}, 'An unknown error occurred unsubscribing a task queue.');
            return callback({'code': 500, 'msg': 'An unknown error occurred unsubscribing a task queue.'});
        }
        callback();
    });
};

/**
 * Record the fact that we have begun processing this task.
 *
 * @param  {String}     deliveryKey         A (locally) unique identifier for this message
 * @param  {Object}     data                The task data
 * @param  {Object}     deliveryInfo        The delivery info from RabbitMQ
 * @api private
 */
var _incrementProcessingTask = function(deliveryKey, data, deliveryInfo) {
    if (numMessagesInProcessing >= MAX_NUM_MESSAGES_IN_PROCESSING) {
        _dumpProcessingMessages('Reached maximum number of concurrent messages allowed in processing (' +
            MAX_NUM_MESSAGES_IN_PROCESSING + '), this probably means there were many tasks received that were never acknowledged.' +
            ' Clearing "messages in processing" to avoid a memory leak. Please analyze the set of task information (messages)' +
            ' dumped in this log and resolve the issue of tasks not being acknowledged.');

        messagesInProcessing = {};
        numMessagesInProcessing = 0;
    }

    messagesInProcessing[deliveryKey] = {'data': data, 'deliveryInfo': deliveryInfo};
    numMessagesInProcessing++;
};

/**
 * Record the fact that we have finished processing this task.
 *
 * @param  {String}     deliveryKey         A (locally) unique identifier for this message
 * @api private
 */
var _decrementProcessingTask = function(deliveryKey) {
    delete messagesInProcessing[deliveryKey];
    numMessagesInProcessing--;

    if (numMessagesInProcessing === 0) {
        MQ.emit('idle');
    } else if (numMessagesInProcessing < 0) {
        // In this case, what likely happened was we overflowed our concurrent tasks, flushed it to 0, then
        // some existing tasks completed. This is the best way I can think of handling it that will "self
        // recover" eventually. Concurrent tasks overflowing is a sign of a leak (i.e., a task is handled
        // but never acknowleged). When this happens there should be a dump of some tasks in the logs and
        // and they should be investigated and resolved.
        numMessagesInProcessing = 0;
    }
};

/**
 * Log a message with the in-processing messages in the log line. This will log at must `NUM_MESSAGES_TO_DUMP`
 * messages.
 *
 * @param  {String}     logMessage
 * @api private
 */
var _dumpProcessingMessages = function(logMessage) {
    log().warn({'messages':  _.values(messagesInProcessing).slice(0, NUM_MESSAGES_TO_DUMP)}, logMessage);
};

