/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');
var fs = require('fs');
var ShortId = require('shortid');
var Path = require('path');
var url = require('url');

var Etherpad = require('oae-content/lib/internal/etherpad');
var IO = require('oae-util/lib/io');
var MQ = require('oae-util/lib/mq');
var MQTestUtil = require('oae-util/lib/test/mq-util');
var RestAPI = require('oae-rest');
var RestContext = require('oae-rest/lib/model').RestContext;
var RestUtil = require('oae-rest/lib/util');
var Tempfile = require('oae-util/lib/tempfile');
var TestsUtil = require('oae-tests/lib/util');

var PreviewAPI = require('oae-preview-processor/lib/api');
var PreviewConstants = require('oae-preview-processor/lib/constants');
var PreviewContext = require('oae-preview-processor/lib/model').PreviewContext;
var PreviewDefaultLinks = require('oae-preview-processor/lib/processors/link/default');
var PreviewImages = require('oae-preview-processor/lib/processors/file/images');
var PreviewOffice = require('oae-preview-processor/lib/processors/file/office');
var PreviewPDF = require('oae-preview-processor/lib/processors/file/pdf');
var PreviewUtil = require('oae-preview-processor/lib/util');

describe('Preview processor', function() {

    // We fill this variable on tests startup with the configuration
    // as specified in the root config.js/beforeTests file.
    var defaultConfig = null;

    // Rest Contexts that can be used for global admin, tenant admin and anonymous users
    var signedAdminRestContext = null;
    var globalAdminRestContext = null;
    var camAdminRestContext = null;
    var anonymousRestContext = null;

    before(function(callback) {
        signedAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.localhost.host);
        globalAdminRestContext = TestsUtil.createGlobalAdminRestContext();
        camAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.cam.host);
        anonymousRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host);

        // Configure the SlideShare & Flickr processors.
        // We also switch the storage mechanism to 'test', so the PP can download the actual files.
        var update = {
            'oae-content/storage/backend': 'test',
            'oae-preview-processor/flickr/apikey': '0d7f5c9bd0277161d65dbea380a41ce2',
            'oae-preview-processor/flickr/apisecret': '14a0bda0b8857ae0',
            'oae-preview-processor/slideshare/sharedsecret': 'CI5h3oQk',
            'oae-preview-processor/slideshare/apikey': 'd1ELqsL0'
        };
        RestAPI.Config.updateConfig(globalAdminRestContext, 'admin', update, function(err) {
            assert.ok(!err);

            // Log in the admin so his cookie jar is set up appropriately
            RestAPI.User.getMe(signedAdminRestContext, function(err, meObj) {
                assert.ok(!err);

                defaultConfig = PreviewAPI.getConfiguration();

                callback();
            });
        });
    });

    after(function(callback) {
        // Revert back to local storage.
        var update = {'oae-content/storage/backend': 'local'};
        RestAPI.Config.updateConfig(globalAdminRestContext, 'admin', update, function(err) {
            assert.ok(!err);
            callback();
        });
    });

    /**
     * @return {Stream} Returns a stream that points to an image.
     */
    var getImageStream = function() {
        return fs.createReadStream(__dirname + '/data/image.png');
    };

    /**
     * @return {Stream} Returns a stream that points to an Office file.
     */
    var getOfficeStream = function() {
        return fs.createReadStream(__dirname + '/data/word.docx');
    };

    /**
     * @return {Stream} Returns a stream that points to a PDF file.
     */
    var getPDFStream = function() {
        return fs.createReadStream(__dirname + '/data/pdf.pdf');
    };

    /**
     * @return {Stream} Returns a stream that points to a ZIP file.
     */
    var getZipStream = function() {
        return fs.createReadStream(__dirname + '/data/foo.zip');
    };

    describe('Processor registration', function() {

        /**
         * Verifies that the processors are unregistered correctly and that the score as returned from the `test` function is respected
         */
        it('verify that processors can be unregistered', function(callback) {
            // Register some processors, each with a different test score
            PreviewAPI.registerProcessor('verify-pp-20', {'testval': 20, 'test': function(ctx, contentObj, callback) { callback(null, 20); }, 'generatePreviews': function() {}});
            PreviewAPI.registerProcessor('verify-pp-30', {'testval': 30, 'test': function(ctx, contentObj, callback) { callback(null, 30); }, 'generatePreviews': function() {}});
            PreviewAPI.registerProcessor('verify-pp--1', {'testval': -1, 'test': function(ctx, contentObj, callback) { callback(null, -1); }, 'generatePreviews': function() {}});

            // Create a piece of content as a regular user
            TestsUtil.generateTestUsers(signedAdminRestContext, 1, function(err, response) {
                assert.ok(!err);
                var restCtx = _.values(response)[0].restContext;
                RestAPI.Content.createFile(restCtx, 'Test Content 1', 'Test content description 1', 'private', getImageStream,  [], [], function(err, contentObj) {
                    assert.ok(!err);

                    // Generate a mock preview context
                    var mockCtx = {
                        'content': contentObj,
                        'revision': {}
                    };
                    // The processor who returns 30 should be on top
                    PreviewAPI.getProcessor(mockCtx, contentObj, function(err, processor) {
                        assert.ok(!err);
                        assert.equal(processor.testval, 30);

                        // Unregister our processors
                        PreviewAPI.unregisterProcessor('verify-pp-20');
                        PreviewAPI.unregisterProcessor('verify-pp-30');
                        PreviewAPI.unregisterProcessor('verify-pp--1');
                        callback();
                    });
                });
            });
        });

        /**
         * Verifies that all required parameters are validated when (un)registering a processor.
         */
        it('verify parameter validation', function() {
            assert.throws(function() { PreviewAPI.registerProcessor(null); }, Error, 'A preview processor needs an ID.');
            assert.throws(function() { PreviewAPI.registerProcessor('test', null); }, Error, 'A preview processor needs to specify an object that has a test and generatePreviews method.');
            assert.throws(function() { PreviewAPI.registerProcessor('test', {}); }, Error, 'A preview processor needs to specify an object that has a test and generatePreviews method.');
            assert.throws(function() { PreviewAPI.registerProcessor('test', {'generatePreviews': function() {}}); }, Error, 'A preview processor needs to specify an object that has a test and generatePreviews method.');
            assert.throws(function() { PreviewAPI.registerProcessor('test', {'test': function() {}}); }, Error, 'A preview processor needs to specify an object that has a test and generatePreviews method.');

            assert.throws(function() { PreviewAPI.unregisterProcessor(null); }, Error, 'An ID needs to be specified when unregistering a processor');
        });
    });

    describe('Preview processor initialization', function() {

        /**
         * Configuring the Office PP with the wrong path to the LibreOffice binary should result in a 500 error.
         */
        it('verify the Office PP can detect if it is configured correctly.', function(callback) {
            var config = {
                'binary': 'some-none-existinant-binary',
                'timeout': 120000
            };
            PreviewOffice.init(config, function(err) {
                assert.ok(err);
                assert.equal(err.code, 500);
                callback();
            });
        });

        /**
         * Configuring the PDF PP with the wrong path to the pdftk binary should result in a 500 error.
         */
        it('verify the PDF PP can detect if it is configured correctly.', function(callback) {
            var config = {
                'binary': 'some-none-existinant-binary',
                'timeout': 120000
            };
            PreviewPDF.init(config, function(err) {
                assert.ok(err);
                assert.equal(err.code, 500);
                callback();
            });
        });
    });

    describe('Preview generation', function() {

        /*!
         * Purges all the events out of the previews queue.
         *
         * @param  {Function}   callback        Invoked when the queue has been purged
         * @param  {Object}     callback.err    An error that occurred, if any
         */
        var _purgePreviewsQueue = function(callback) {
            var listener = function() {};
            var options = {'subscribe': {'subscribe': false}};
            MQ.bind(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, listener, options, function(err) {
                if (err) {
                    return callback(err);
                }

                // Purge anything that is in the queue.
                // Note: We need to enable the PP so that it binds to a queue that we can purge.
                MQ.purge(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Remove ourselves from the queue.
                    MQ.unbind(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function(err) {
                        if (err) {
                            return callback(err);
                        }

                        return callback();
                    });
                });
            });
        };

        /*!
         * Enable the Preview Processor if the config specifies we can run with it enabled.
         */
        before(function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            /*
             * More then likely there will be a ton of stuff in the previews queue.
             * We need to clear it out before continuing on the following tests.
             * We can't do `MQ.purge` yet, as that requires that we're bound to the previews queue,
             * which we are *not* at this point, since the Preview Processor is still disabled by this point.
             *
             * We'll bind to the queue manually, purge it, unbind ourselves and enable the Preview Processor.
             * If all went well, the queue will be empty and the PP will be idle till the first test executes.
             */
            _purgePreviewsQueue(function(err) {
                if (err) {
                    return callback(new Error(err.msg));
                }

                // Enable the Preview Processor
                PreviewAPI.enable(function(err) {
                    if (err) {
                        return callback(new Error(err.msg));
                    }

                    return callback();
                });
            });
        });

        /*!
         * Disable the Preview Processor in case we enabled it earlier.
         */
        after(function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            // Disable the API.
            PreviewAPI.disable(function(err) {
                if (err) {
                    return callback(new Error(err.msg));
                }

                return callback();
            });
        });

        /*!
         * Creates a file and waits till it has been processed.
         *
         * @param  {String}      type       `link` or `file`.
         * @param  {String}      link       The stream that points to the file that should be uploaded.
         * @param  {Stream}      stream     The stream that points to the file that should be uploaded.
         * @param  {Function}    callback   Standard callback method that gets called when the file has previews associated to it.
         */
        var _createContentAndWait = function(type, link, stream, callback) {
            // When the queue is empty, we create a piece of content for which we can generate preview items.
            MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function() {
                TestsUtil.generateTestUsers(signedAdminRestContext, 1, function(err, response) {
                    assert.ok(!err);
                    var restCtx = _.values(response)[0].restContext;
                    var contentCreated = function(err, contentObj) {
                        assert.ok(!err);

                        // Wait till the PP items have been generated.
                        MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function() {
                            // Ensure the preview items are there.
                            RestAPI.Content.getContent(restCtx, contentObj.id, function(err, updatedContent) {
                                assert.ok(!err);
                                callback(restCtx, updatedContent);
                            });
                        });
                    };
                    if (type === 'file') {
                        RestAPI.Content.createFile(restCtx, 'Test Content 1', 'Test content description 1', 'private', stream,  [], [], contentCreated);
                    } else if (type === 'link') {
                        RestAPI.Content.createLink(restCtx, link, null, 'private', link,  [], [], contentCreated);
                    } else if (type === 'collabdoc') {
                        RestAPI.Content.createCollabDoc(restCtx, 'Test document', 'Test document', 'private', [], [], function(err, contentObj) {
                            assert.ok(!err);

                            // Put some text in the document, as we would otherwise
                            // ignore the document.
                            var etherpadClient = Etherpad.getClient(contentObj.id);
                            var args = {
                                'padID': contentObj.etherpadPadId,
                                'text': 'Sweet update'
                            };
                            etherpadClient.setText(args, function(err) {
                                assert.ok(!err);

                                // Create a new revision, as the document would otherwise be ignored by the PP.
                                RestAPI.Content.publishCollabDoc(restCtx, contentObj.id, function(err) {
                                    assert.ok(!err);
                                    contentCreated(err, contentObj);
                                });
                            });
                        });
                    }
                });
            });
        };

        /*!
         * Verifies that the `downloadUrl` can in fact be downloaded.
         *
         * @param  {RestContext}    restContext     The RestContext that we should use to download the file.
         * @param  {String}         downloadUrl     The signed URL that should be verified.
         * @param  {Function}       callback        Standard callback method.
         */
        var _verifySignedUriDownload = function(restContext, downloadUrl, callback) {
            // Verify we can download it.
            var parsedUrl = url.parse(downloadUrl, true);
            RestUtil.RestRequest(restContext, '/api/download/signed', 'GET', parsedUrl.query, function(err, body, response) {
                assert.ok(!err);
                assert.equal(response.statusCode, 200);
                assert.ok(body);
                callback();
            });
        };


        /*!
         * Utility function to bind a listener to the preview reprocessing queue and let a
         * consumer handle the data of the resulting message.
         *
         * @param  {RestContext}    restCtx         The rest context with which to invoke the reprocess request. Should be bound to the global admin interface.
         * @param  {String[]}       [statuses]      The statuses parameter of the reprocessing request
         * @param  {Function}       handler         The handler to handle the MQ data
         * @param  {Object}         handler.data    The arbitrary MQ data
         * @param  {Function}       [callback]      Invoked after the reprocessing rest request has been executed
         * @param  {Object}         [callback.err]  An error that occurred invokeing the reprocess previews rest request, if any
         */
        var _reprocessWithHandler = function(restCtx, statuses, handler, callback) {
            callback = callback || function(err) { assert.ok(!err); };

            /*!
             * A convenience handler that takes care of invoking the MQ callback to let it acknowledge
             * the request.
             *
             * @param  {Object}     data            The MQ data for the message
             * @param  {Function}   mqCallback      The function to invoke to acknowledge handling the message
             */
            var _handler = function(data, mqCallback) {
                mqCallback();
                return handler(data);
            };

            // Unbind and rebind a process-all handler
            MQ.unbind(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, function(err) {
                assert.ok(!err);

                MQ.bind(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, handler, null, function(err) {
                    assert.ok(!err);

                    RestAPI.Previews.reprocessPreviews(restCtx, statuses, callback);
                });
            });
        };

        /**
         * Verifies the image processor.
         */
        it('verify image processing works', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            _createContentAndWait('file', null, getImageStream, function(restCtx, content) {
                assert.equal(content.previews.status, 'done');
                // Ensure we have a thumbnail url.
                assert.ok(content.previews.thumbnailUrl);
                assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);
                _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, callback);
            });
        });

        /**
         * Verifies the office processor.
         */
        it('verify office processing works', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            // OpenOffice can sometimes be painfully slow to start up.
            this.timeout(30000);

            _createContentAndWait('file', null, getOfficeStream, function(restCtx, content) {
                assert.equal(content.previews.status, 'done');
                // Ensure we have a thumbnail url.
                assert.ok(content.previews.thumbnailUrl);
                assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);
                _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, function() {
                    // Ensure we have small and medium images.
                    assert.ok(content.previews.smallUrl);
                    _verifySignedUriDownload(restCtx, content.previews.smallUrl, function() {
                        assert.ok(content.previews.mediumUrl);
                        _verifySignedUriDownload(restCtx, content.previews.mediumUrl, callback);
                    });
                });
            });
        });

        /**
         * Verifies the PDF processor.
         */
        it('verify pdf processing works', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            // OpenOffice can sometimes be painfully slow to start up.
            this.timeout(30000);

            _createContentAndWait('file', null, getPDFStream, function(restCtx, content) {
                assert.equal(content.previews.status, 'done');
                // Ensure we have a thumbnail url.
                assert.ok(content.previews.thumbnailUrl);
                assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);
                _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, function() {
                    // Ensure we have small and medium images.
                    assert.ok(content.previews.smallUrl);
                    _verifySignedUriDownload(restCtx, content.previews.smallUrl, function() {
                        assert.ok(content.previews.mediumUrl);
                        _verifySignedUriDownload(restCtx, content.previews.mediumUrl, callback);
                    });
                });
            });
        });

        /**
         * Verifies the default link processor.
         */
        it('verify default link processing works', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            _createContentAndWait('link', 'http://www.google.com', null, function(restCtx, content) {
                assert.equal(content.previews.status, 'done');
                assert.equal(content.previews.embeddable, false);
                // Ensure we have a thumbnail url.
                assert.ok(content.previews.thumbnailUrl);
                assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);
                _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, function() {
                    // Ensure we have small and medium images.
                    assert.ok(content.previews.smallUrl);
                    _verifySignedUriDownload(restCtx, content.previews.smallUrl, function() {
                        assert.ok(content.previews.mediumUrl);
                        _verifySignedUriDownload(restCtx, content.previews.mediumUrl, callback);
                    });
                });
            });
        });

        /**
         * Verifies the default link processor checks if the site is embeddable.
         */
        it('verify default link processing checks if a url is embeddable in an iframe', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            _createContentAndWait('link', 'http://www.apereo.org', null, function(restCtx, content) {
                assert.equal(content.previews.status, 'done');
                assert.equal(content.previews.embeddable, true);
                // Ensure we have a thumbnail url.
                assert.ok(content.previews.thumbnailUrl);
                assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);
                _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, callback);
            });
        });

        /**
         * Verifies the default link processor handles HEAD failures
         */
        it('verify default link processing can handle HEAD failures', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            // Create a new express application to a PP
            TestsUtil.createTestServer(function(app, server, port) {

                // Destroy the connection to create an erroneous HEAD request
                app.head('/', function(req, res) {
                    res.connection.destroy();
                });

                app.get('/', function(req, res) {
                    res.send(200);
                });

                // Although the HEAD request fails, the preview processing should complete correctly and the link should be marked as non-embeddable
                _createContentAndWait('link', 'http://localhost:' + port, null, function(restCtx, content) {
                    assert.equal(content.previews.status, 'done');
                    assert.equal(content.previews.embeddable, false);

                    // Ensure we have a thumbnail url
                    assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);

                    _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, function() {
                        // Ensure we have small and medium images
                        assert.ok(content.previews.smallUrl);
                        _verifySignedUriDownload(restCtx, content.previews.smallUrl, function() {
                            assert.ok(content.previews.mediumUrl);
                            _verifySignedUriDownload(restCtx, content.previews.mediumUrl, callback);
                        });
                    });
                });
            });
        });

        /**
         * Verifies the default link processor only handles http urls.
         */
        it('verify default link processing only handles http(s)', function(callback) {
            var content = {'resourceSubType': 'link', 'link': 'file://localhost/etc/passwd'};
            PreviewDefaultLinks.test(null, content, function(err, score) {
                assert.ok(!err);
                assert.strictEqual(score, -1);

                content.link = 'ftp://localhost:21/etc/passwd';
                PreviewDefaultLinks.test(null, content, function(err, score) {
                    assert.ok(!err);
                    assert.strictEqual(score, -1);
                    callback();
                });
            });
        });

        /**
         * Verifies the youtube processor and assures that metadata is retrieved/set.
         */
        it('verify youtube link processing works', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            _createContentAndWait('link', 'http://www.youtube.com/watch?v=lgTQ5I_H4Xk', null, function(restCtx, content) {
                assert.equal(content.previews.status, 'done');
                // Verify the displayName and description are set.
                assert.equal(content.displayName, 'How to prounounce "Apereo"');
                assert.equal(content.description, 'Here is Ian Dolphin, the Executive Director of the Apereo Foundation, with the official pronunciation of the word "Apereo".');
                // Ensure we have a thumbnail url.
                assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);
                _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, function() {
                    // Ensure we have small and medium images.
                    assert.ok(content.previews.smallUrl);
                    _verifySignedUriDownload(restCtx, content.previews.smallUrl, function() {
                        assert.ok(content.previews.mediumUrl);
                        _verifySignedUriDownload(restCtx, content.previews.mediumUrl, callback);
                    });
                });
            });
        });

        /**
         * Verifies the slideshare processor and assures that metadata is retrieved/set.
         */
        it('verify slideshare link processing works', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            _createContentAndWait('link', 'http://www.slideshare.net/nicolaasmatthijs/apereo-oae-state-of-the-project?search_from=3', null, function(restCtx, content) {
                assert.equal(content.previews.status, 'done');
                // Verify the displayName and description are set.
                assert.equal(content.displayName, 'Apereo OAE - State of the project');
                assert.equal(content.description, 'The Apereo Open Academic Environment is a platform that focusses on group collaboration between researchers, students and lecturers, and strongly embraces openness, creation, re-use, re-mixing and discovery of content, people and groups. This session provides a summary of the revised goals and their motivation, as well as a full demo of the new implemented functionalities.');

                // Ensure we have a thumbnail url.
                assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);
                _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, function() {
                    // Ensure we have small and medium images.
                    assert.ok(content.previews.smallUrl);
                    _verifySignedUriDownload(restCtx, content.previews.smallUrl, function() {
                        assert.ok(content.previews.mediumUrl);
                        _verifySignedUriDownload(restCtx, content.previews.mediumUrl, callback);
                    });
                });
            });
        });

        /**
         * Verifies the flickr photo processor and assures that metadata is retrieved/set.
         */
        it('verify flickr photo link processing works', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            _createContentAndWait('link', 'http://www.flickr.com/photos/johnalewis/8949876197', null, function(restCtx, content) {
                assert.equal(content.previews.status, 'done');
                // Verify the displayName and description are set.
                assert.equal(content.displayName, 'Apereo Sakai/Jasig Fellows');
                assert.equal(content.description, '');
                // Ensure we have a thumbnail url.
                assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);
                _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, function() {
                    // Ensure we have small and medium images.
                    assert.ok(content.previews.smallUrl);
                    _verifySignedUriDownload(restCtx, content.previews.smallUrl, function() {
                        assert.ok(content.previews.mediumUrl);
                        _verifySignedUriDownload(restCtx, content.previews.mediumUrl, callback);
                    });
                });
            });
        });

        /**
         * Verifies the flickr set processor and assures that metadata is retrieved/set.
         */
        it('verify flickr set link processing works', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            _createContentAndWait('link', 'http://www.flickr.com/photos/iandolphinconferences/sets/72057594140880342/', null, function(restCtx, content) {
                assert.equal(content.previews.status, 'done');
                // Verify the displayName and description are set.
                assert.equal(content.displayName, 'JA-SIG Denver 03');
                assert.equal(content.description, '');
                // Ensure we have a thumbnail url.
                assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);
                _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, function() {
                    // Ensure we have small and medium images.
                    assert.ok(content.previews.smallUrl);
                    _verifySignedUriDownload(restCtx, content.previews.smallUrl, function() {
                        assert.ok(content.previews.mediumUrl);
                        _verifySignedUriDownload(restCtx, content.previews.mediumUrl, callback);
                    });
                });
            });
        });

        /**
         * Verifies the vimeo processor and assures that metadata is retrieved/set.
         */
        it('verify vimeo link processing works', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            _createContentAndWait('link', 'https://vimeo.com/17085981', null, function(restCtx, content) {
                assert.equal(content.previews.status, 'done');
                // Verify the displayName and description are set.
                assert.equal(content.displayName, 'Cambridge Montage');
                assert.equal(content.description, 'A brief look at the world of Cambridge University');
                // Ensure we have a thumbnail url.
                assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);
                _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, function() {
                    // Ensure we have small and medium images.
                    assert.ok(content.previews.smallUrl);
                    _verifySignedUriDownload(restCtx, content.previews.smallUrl, function() {
                        assert.ok(content.previews.mediumUrl);
                        _verifySignedUriDownload(restCtx, content.previews.mediumUrl, callback);
                    });
                });
            });
        });

        /**
         * Verifies the collaborative document processor works.
         */
        it('verify collaborative document processing works', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            _createContentAndWait('collabdoc', null, null, function(restCtx, content) {
                assert.equal(content.previews.status, 'done');
                // Ensure we have a thumbnail url.
                assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);
                _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, callback);
            });
        });

        /**
         * Verifies the collaborative document processor works.
         */
        it('verify unpublished collaborative documents are ignored', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            TestsUtil.generateTestUsers(signedAdminRestContext, 1, function(err, response) {
                assert.ok(!err);
                var restCtx = _.values(response)[0].restContext;
                RestAPI.Content.createCollabDoc(restCtx, 'Test document', 'Test document', 'private', [], [], function(err, contentObj) {
                    assert.ok(!err);

                    // Wait till it has been processed.
                    MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function() {
                        // Ensure the preview items are there.
                        RestAPI.Content.getContent(restCtx, contentObj.id, function(err, updatedContent) {
                            assert.ok(!err);
                            assert.equal(updatedContent.previews.status, 'ignored');
                            assert.ok(!updatedContent.previews.thumbnailUrl);
                            callback();
                        });
                    });
                });
            });
        });

        /**
         * Verifies that the preview status of a piece of content is set to ignored if no PP can handle it.
         */
        it('verify zip files get ignored', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            _createContentAndWait('file', null, getZipStream, function(restCtx, content) {
                assert.equal(content.previews.status, 'ignored');
                assert.ok(!content.previews.thumbnailUrl);
                callback();
            });
        });

        /**
         * Verifies that the PP looks at the mime type of the revision rather than looking at the mime type that sits
         * on the content object. This is an important distinction as `content.mime` points to the mimetype of the *latest*
         * revision, which is not necessarily the revision the PP might be processing.
         */
        it('verify content with multiple revisions of different mime types', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            // Disable the PP first, so we can generate 2 revisions without the PP starting at the first one
            PreviewAPI.disable(function(err) {
                assert.ok(!err);

                // Create a piece of content with 2 separate mime types
                MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function() {
                    TestsUtil.generateTestUsers(signedAdminRestContext, 1, function(err, response) {
                        assert.ok(!err);
                        var restCtx = _.values(response)[0].restContext;

                        // Create the initial revision as a zip file. ZIP is used as this gets ignored by the
                        // PP so the unit test can end within the test timeout time.
                        RestAPI.Content.createFile(restCtx, 'Test Content 1', 'Test content description 1', 'private', getZipStream,  [], [], function(err, contentObj) {
                            assert.ok(!err);

                            // Create the second revision as an image file.
                            RestAPI.Content.updateFileBody(restCtx, contentObj.id, getImageStream, function(err, updatedContentObj) {
                                assert.ok(!err);

                                // Purge the pending previews from the queue
                                _purgePreviewsQueue(function(err) {
                                    assert.ok(!err);

                                    // Enable previews so we can handle the reprocessing
                                    PreviewAPI.enable(function(err) {
                                        assert.ok(!err);

                                        // Re-process the revisions
                                        RestAPI.Previews.reprocessPreview(signedAdminRestContext, contentObj.id, contentObj.latestRevisionId, function(err) {
                                            assert.ok(!err);
                                            RestAPI.Previews.reprocessPreview(signedAdminRestContext, contentObj.id, updatedContentObj.latestRevisionId, function(err) {
                                                assert.ok(!err);
                                                MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function() {

                                                    // The revisions should have been processed, fetch their metadata.
                                                    RestAPI.Content.getRevision(restCtx, contentObj.id, contentObj.latestRevisionId, function(err, revision) {
                                                        assert.ok(!err);
                                                        assert.equal(revision.previews.status, 'ignored');

                                                        RestAPI.Content.getRevision(restCtx, contentObj.id, updatedContentObj.latestRevisionId, function(err, revision) {
                                                            assert.ok(!err);
                                                            assert.equal(revision.previews.status, 'done');
                                                            callback();
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Verifies that a single content item and revision can be reprocessed
         */
        it('verify reprocess previews validation and authorization', function(callback) {
            // This can run, even if previews are disabled

            // Verify anonymous, regular users and tenant admins from other tenants cannot reprocess previews
            TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users) {
                assert.ok(!err);
                var user = _.values(users)[0];
                RestAPI.Previews.reprocessPreview(user.restContext, 'c:camtest:someContent', 'rev:camtest:someRevision', function(err) {
                    assert.ok(err);
                    assert.equal(err.code, 401);

                    RestAPI.Previews.reprocessPreview(anonymousRestContext, 'c:camtest:someContent', 'rev:camtest:someRevision', function(err) {
                        assert.ok(err);
                        assert.equal(err.code, 401);

                        RestAPI.Previews.reprocessPreview(camAdminRestContext, 'c:other:someContent', 'rev:other:someRevision', function(err) {
                            assert.ok(err);
                            assert.equal(err.code, 401);

                            // Verify validation of content and revision ids
                            RestAPI.Previews.reprocessPreview(camAdminRestContext, 'notAContentId', 'rev:camtest:someRevision', function(err) {
                                assert.ok(err);
                                assert.equal(err.code, 400);

                                RestAPI.Previews.reprocessPreview(camAdminRestContext, 'c:camtest:someContent', 'notARevisionId', function(err) {
                                    assert.ok(err);
                                    assert.equal(err.code, 400);

                                    // Sanity check the validation and authorization
                                    RestAPI.Previews.reprocessPreview(camAdminRestContext, 'c:camtest:someContent', 'rev:camtest:someRevision', function(err) {
                                        assert.ok(!err);
                                        return callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Verify forcing a reprocessing of a preview results in the preview being reprocessed
         */
        it('verify reprocessing a preview processes the revision preview', function(callback) {

            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            PreviewAPI.disable(function(err) {
                assert.ok(!err);

                TestsUtil.generateTestUsers(signedAdminRestContext, 1, function(err, user) {
                    assert.ok(!err);
                    user = _.values(user)[0];

                    RestAPI.Content.createFile(user.restContext, 'Test Content 1', 'Test content description 1', 'private', getImageStream, [], [], function(err, content) {
                        assert.ok(!err);

                        // Purge the pending preview from the queue
                        _purgePreviewsQueue(function(err) {
                            assert.ok(!err);

                            // Enable previews so we can handle the reprocessing
                            PreviewAPI.enable(function(err) {

                                // Precautiously ensure there are no previews generating
                                MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function() {

                                    // Force the previews to generate
                                    RestAPI.Previews.reprocessPreview(signedAdminRestContext, content.id, content.latestRevisionId, function(err) {
                                        assert.ok(!err);

                                        // Wait for the preview to finish generating
                                        MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function() {

                                            RestAPI.Content.getContent(user.restContext, content.id, function(err, content) {
                                                assert.ok(!err);
                                                assert.ok(content.previews);
                                                assert.equal(content.previews.status, 'done');
                                                return callback();
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });


        /**
         * Test that verifies when previews are reprocessed through the REST endpoint, a task is triggered.
         */
        it('verify reprocessing previews triggers an mq task', function(callback) {

            // Verify default status of error
            _reprocessWithHandler(globalAdminRestContext, null, function(data) {
                assert.ok(data);
                assert.ok(data.statuses);
                assert.equal(data.statuses.length, 1);
                assert.equal(data.statuses[0], 'error');

                // Verify we can invoke a task with all statuses
                _reprocessWithHandler(globalAdminRestContext, ['error', 'done', 'pending'], function(data) {
                    assert.ok(data);
                    assert.ok(data.statuses);
                    assert.equal(data.statuses.length, 3);
                    assert.ok(_.contains(data.statuses, 'error'));
                    assert.ok(_.contains(data.statuses, 'done'));
                    assert.ok(_.contains(data.statuses, 'pending'));

                    return callback();
                });
            });
        });

        /**
         * Test that verifies when previews are reprocessed through the REST endpoint, a task is triggered.
         */
        it('verify non-global admin users cannot reprocess previews', function(callback) {

            /*!
             * Task handler that will fail the test if invoked.
             *
             * @see MQ#bind
             */
            var _handleTaskFail = function(data) {
                assert.fail('Did not expect the task to be invoked.');
            };

            // Generate a normal user with which to try and reprocess previews
            TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users) {
                assert.ok(!err);

                var userRestCtx = users[_.keys(users)[0]].restContext;

                // Verify that an anonymous user-tenant user cannot reprocess previews
                _reprocessWithHandler(anonymousRestContext, null, _handleTaskFail, function(err) {
                    assert.ok(err);

                    // Verify that an anonymous global-tenant user cannot reprocess previews
                    RestAPI.Previews.reprocessPreviews(TestsUtil.createGlobalRestContext(), null, function(err) {
                        assert.ok(err);
                        assert.equal(err.code, 401);

                        // Verify that a regular user cannot generate a task
                        RestAPI.Previews.reprocessPreviews(userRestCtx, null, function(err) {
                            assert.ok(err);

                            // Verify that a tenant admin cannot generate a task
                            RestAPI.Previews.reprocessPreviews(camAdminRestContext, null, function(err) {
                                assert.ok(err);
                                return callback();
                            });
                        });
                    });
                });
            });
        });
    });

    describe('Preview util', function() {
        describe('#downloadRemoteFile', function() {

            it('verify remote files can be downloaded', function() {
                var tmpPath = Tempfile.createTempFile();
                PreviewUtil.downloadRemoteFile('http://localhost:2000/api/me', tmpPath.path, function(err, path) {
                    assert.ok(!err);
                    IO.readFile(path, function(err, data) {
                        assert.ok(!err);

                        // Verify there is some data there.
                        assert.ok(data);

                        // Verify we don't leak the global session into the download fetcher.
                        data = JSON.parse(data);
                        assert.ok(data.anon);
                    });
                });
            });
        });
    });
});
