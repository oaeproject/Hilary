/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var cheerio = require('cheerio');
var events = require('events');
var fs = require('fs');
var Globalize = require('globalize');
var less = require('less');
var path = require('path');
var PropertiesParser = require('properties-parser');
var readdirp = require('readdirp');
var url = require('url');
var util = require('util');
var watch = require('watch');

var ConfigAPI = require('oae-config');
var Sanitization = require('oae-util/lib/sanitization');
var Validator = require('oae-util/lib/validator').Validator;
var log = require('oae-logger').logger('oae-ui');

var UIConstants = require('./constants').UIConstants;

// The Config object for the UI module.
var uiConfig = ConfigAPI.config('oae-ui');

// The cached skin variables
var cachedSkinVariables = null;
// The cached skins per tenant.
var cachedSkins = {};

// Path to the 3akai-ux repository
var uiDirectory = null;

// A mapping object that maps pre-optimized paths to post-optimized paths in the UI
var hashes = null;

// A dictionary that will hold the content for each file. This will be lazy filled. The first
// time a particular file is requested, it will be cached. After that, the cached version will
// be used
var staticFileCache = {};

// A dictionary that will hold the widget manifests for all widgets. This will be filled upon
// initialization.
var widgetManifestCache = {};

// A dictionary that will hold all the i18n keys keyed by their locale
var i18nKeys = {};


/**
 * The UI API.
 *
 * ## Events
 *
 * * `skinParsed` - Invoked when the skin file has been parsed or re-parsed on the application node.
 */
var UIAPI = module.exports = new events.EventEmitter();
var emitter = UIAPI;

////////////////////
// Initialization //
////////////////////

/**
 * This will find all of the widget config files in the UI repository and cache. For development,
 * it will also put watches on the files in the UI repository in order to invalidate the cache
 * when a file has been changed/removed.
 *
 * @param  {String}     uiDirectory     The path to the directory containing the UI repository.
 * @param  {Object}     hashes          A mapping that will map pre-optimized paths to hashed, post-optimized static asset paths
 * @param  {Function}   callback        Standard callback method.
 * @param  {Object}     callback.err    An error object (if any)
 */
var init = module.exports.init = function(_uiDirectory, _hashes, callback) {
    // Cache the ui directory path and make sure we have the absolute path
    uiDirectory = _uiDirectory;
    hashes = _hashes;

    // Load all the globalize cultures
    require('globalize/lib/cultures/globalize.cultures');

    // Cache all of the widget manifest files
    cacheWidgetManifests();

    // Monitor the UI repository for changes and refresh the cache.
    // This will only be done in development mode
    if (process.env['NODE_ENV'] !== 'production') {
        watch.createMonitor(uiDirectory, {'ignoreDotFiles': true}, function(monitor) {
            monitor.on('created', updateFileCaches);
            monitor.on('changed', updateFileCaches);
            monitor.on('removed', updateFileCaches);
        });
    }

    // Cache the base skin file
    _cacheSkinVariables(function(err) {
        if (err) {
            return callback(err);
        }

        // Ensure the skins are not cached, as they may be invalid now
        cachedSkins = {};

        // Cache the i18n bundles
        return _cacheI18nKeys(callback);
    });
};

ConfigAPI.on('update', function(tenantAlias) {
    // Re-generate the skin.
    // Don't delete it from the cache just yet as we might still be serving requests.
    _generateSkin(tenantAlias, function(err) {
        if (err) {
            log().error({'err': err, 'tenantAlias': tenantAlias}, 'Could not re-cache the tenant skin after a config update.');
        }

        emitter.emit('skinParsed');
    });
});


/////////////
// Caching //
/////////////

/**
 * When a file in the UI repository has changed, we update the static file cache by deleting
 * the record for that file if there is one. The next time the updated/created file will be
 * re-requested, caching will be attempted again. We also check if the changed file is a
 * widget manifest file, and refresh the widget manifest cache if that's the case
 *
 * @param  {String}     filename        The absolute path to the file that has been added/updated/deleted
 * @api private
 */
var updateFileCaches = function(filename) {
    filename = filename.replace(uiDirectory, '');
    // Delete the file from the static file cache, for it to be re-cached when it is requested again
    delete staticFileCache[filename];

    // If the changed file is a widget config file, we re-cache the widget config files
    if (/^\/node_modules\/(.*?)\/manifest.json$/.test(filename)) {
        cacheWidgetManifests();

    // If the changed file is the base skin file, we re-cache it
    } else if (filename === UIConstants.paths.BASE_SKIN) {
        // The skin file has changed, reset the skin files, they will be lazy loaded
        cachedSkins = {};

        // Retrieve the skin variables.
        _cacheSkinVariables(function(err) {
            if (err) {
                log().error({'err': err}, 'Could not cache the skin variables after a file update.');
            }
        });

    // If the changed file is a bundle file, we re-cache it
    } else if (/.*\.properties$/.test(filename)) {
        _cacheBundleFile(filename);
    }
};

///////////////////////////////
// Widget config aggregation //
///////////////////////////////

/**
 * Get the aggregated list of widget manifests.
 *
 * @return {Object}     An object where each key is the widget id and the value is the widget manifest.
 */
var getWidgetManifests = module.exports.getWidgetManifests = function() {
    return widgetManifestCache;
};

/**
 * Cache all widget manifests under the UI's node_modules directory
 *
 * @api private
 */
var cacheWidgetManifests = function() {
    widgetManifestCache = {};
    // Cache all of the widget config files under node_modules
    readdirp({ 'root': uiDirectory + '/node_modules/', 'directoryFilter': ['!.bin'], 'fileFilter': 'manifest.json' })
        .on('data', function (entry) {
            // Extract the widget id from the path, which is expected
            // to be the final part of the path
            var widgetId = entry.parentDir.split(path.sep).pop();
            try {
                var widgetManifest = fs.readFileSync(entry.fullPath, 'utf8');
                widgetManifestCache[widgetId] = JSON.parse(widgetManifest);
            } catch (err) {
                widgetManifestCache[widgetId] = {};
                log().error({'err': err, 'widgetId': widgetId, 'path': entry.fullPath}, 'Could not parse the widget manifest file.');
            }
            widgetManifestCache[widgetId].id = widgetId;
            widgetManifestCache[widgetId].path = entry.parentDir + '/';
        })
        .on('warn', function (err) { log().warn({'err': err}, 'A non-fatal error occured whilst caching a widget manifest'); })
        .on('error', function (err) { log().error({'err': err}, 'A fatal error occured whilst caching a widget manifest'); });
};

//////////////////
// Static batch //
//////////////////

/**
 * Get the content of a set of static files. The returned data is an object where the key is the requested URL and
 * the values are the static file contents. In case the file couldn't be found, null will be returned.
 *
 * @param  {String[]}    files           An array of file paths relative to the UI repository.
 * @param  {Function}    callback        Standard callback method.
 * @param  {Object}      callback.err    An error object (if any)
 * @param  {Object}      callback.data   JSON Object representing the retrieved files.
 */
var getStaticBatch = module.exports.getStaticBatch = function(files, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 400, 'msg': 'The files parameter must be an array'}).isArray(files);
    // Filter out the duplicate ones
    files = _.uniq(files);
    // Make sure that all provided filenames are real strings
    for (var i = 0; i < files.length; i++) {
        validator.check(files[i], {'code': 400, 'msg': 'A valid file path needs to be provided'}).notEmpty();
        // Make sure that only absolute paths are allowed. All paths that contain a '../' have the potential of
        // exposing private server files
        validator.check(files[i], {'code': 400, 'msg': 'Only absolute paths are allowed'}).notContains('../');
    }
    validator.check(files.length, {'code': 400, 'msg': 'At least one file must be provided'}).min(1);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var results = {};
    files.forEach(function(file) {
        getStaticFile(file, function(err, data) {
            if (err) {
                results[file] = null;
            } else {
                results[file] = data;
            }

            // Check if all of them have returned
            if (_.keys(results).length === files.length) {
                callback(null, results);
            }
        });
    });
};

/**
 * Get the content of a static file and cache it if it hasn't been cached yet. This will only
 * open the file on disk if the file could not be found in the cache.
 *
 * @param  {String}      path            The path for the static file to open. A path should be relative to the UI repository
 * @param  {Function}    callback        Standard callback method
 * @param  {Object}      callback.err    An error object containing the error code and message
 * @param  {String}      callback.data   The file content for the requested file
 */
var getStaticFile = module.exports.getStaticFile = function(path, callback) {
    // Try to retrieve the file content from cache
    if (staticFileCache[path]) {
        callback(null, staticFileCache[path]);
    } else {
        cacheFile(path, callback);
    }
};

/**
 * Reads a file's content and cache it.
 *
 * @param  {String}      path                The path for the file that needs to be read
 * @param  {Function}    callback            Standard callback function
 * @param  {Object}      callback.err        An error object containing the error code and message
 * @param  {String}      callback.data       The data that sits in the file.
 * @api private
 */
var cacheFile = function(path, callback) {
    fs.readFile(uiDirectory + path, 'utf8', function(err, data) {
        if (err) {
            return callback(err);
        }

        // Cache the file content
        staticFileCache[path] = data;
        callback(null, data);
    });
};


//////////////
// SKINNING //
//////////////

/**
 * Sorts an array of sections, containing subsubsections, to reflect the order in which they appear in the less file.
 * It also removes the `index` property from each section and its subsections.
 *
 * @param  {Section[]}  The array of sections that should be sorted.
 * @return {Section[]}  The sorted array of sections as they appear in the less file.
 * @api private
 */
var sortSections = function(sections) {
    /*!
     * A comparator that can be used to sort an array of sections or subsections.
     *
     * @param  {Section}    sectionA    First section to compare.
     * @param  {Section}    sectionB    Second section to compare.
     * @return {Number}                 An integer that expresses the relative order of the passed in sections.
     */
    var comparator = function(sectionA, sectionB) {
        return (sectionA.index - sectionB.index);
    };

    // Sort the top level sections.
    sections.sort(comparator);

    // Give all of the subsections the same order as the one they have in the LESS file.
    _.each(sections, function(section) {
        section.subsections = _.values(section.subsections).sort(comparator);

        // Remove the unneeded index property of each section.
        delete section.index;
        // Remove the unneeded index property of each subsection
        _.each(section.subsections, function(subsection) {
            delete subsection.index;
        });
    });
    return sections;
};

/**
 * Get the skin file for the current tenant.
 *
 * @param  {Context}    ctx             Standard context object, representing the currently logged in user and its tenant
 * @param  {Function}   callback        Standard callback method.
 * @param  {Object}     callback.err    An error object (if any)
 * @param  {String}     callback.css    The generated CSS.
 */
var getSkin = module.exports.getSkin = function(ctx, callback) {
    var tenantAlias = ctx.tenant().alias;
    if (cachedSkins[tenantAlias]) {
        return callback(null, cachedSkins[tenantAlias]);
    } else {
        _generateSkin(tenantAlias, callback);
    }
};

/**
 * Retrieve the LESS variables that are present in the skin file.
 * Each variable will be annotated with the tenant value.
 *
 * @param  {Context}    ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}     [tenantAlias]       The optional alias of the tenant for which the variables should be retrieved. If no tenant alias is provided, the current tenant will be used.
 * @param  {Function}   callback            Standard callback method.
 * @param  {Object}     callback.err        An error object (if any)
 * @param  {Object[]}   callback.variables  The generated CSS.
 */
var getSkinVariables = module.exports.getSkinVariables = function(ctx, tenantAlias, callback) {
    tenantAlias = tenantAlias || ctx.tenant().alias;

    if (!ctx.user() || !ctx.user().isAdmin(tenantAlias)) {
        return callback({'code': 401, 'msg': 'Only administrators can retrieve the skin variables.'});
    }

    var applyTenantValues = function(err, skinVariables) {
        if (err) {
            return callback(err);
        }
        // Get the values for this tenant.
        var tenantVariables = _getTenantSkinVariableValues(tenantAlias);

        // Extend the skin variables into a new object, so we don't overwrite the global object.
        var variables = _.extend({}, skinVariables);

        // Add in the value.
        _.each(tenantVariables, function(value, key) {
            if (key && variables[key]) {
                variables[key].value = value;
            }
        });

        /*!
         * Morph it to a structure that the UI can use.
         *
         * We'll return an array of sections, which are defined in the LESS file through `@section`.
         * Each section can have a number of subsections, used to subdivide variables inside of a given
         * section.
         *
         * By default, each section will have a `main` subsection that contains all of the variables
         * that are not part of a specific subsection. This will be followed by all of the other subsections,
         * which are defined in the LESS file through @subsection.
         *
         * Each subsection will have one or more CSS variables that will be used for skinning through
         * the Admin UI.
         *
         * ex:
         *   [
         *      {
         *          'name': 'Section name A',
         *          'subsections': [
         *              {
         *                  'name': 'main',
         *                  'variables': [ <var A_V1>, <var A_V2>, ... ]
         *              },
         *              {
         *                  'name': <subsection A_S1>,
         *                  'variables': [ <var A_V3>, <var a_V4>, ... ]
         *              },
         *              ...
         *          ]
         *      },
         *      ...
         *   ]
         */
        var sections = {};
        _.each(variables, function(variable, name) {
            // Make sure that the section exists
            sections[variable.section.name] = sections[variable.section.name] || {
                'name': variable.section.name,
                'index': variable.section.index,
                'subsections': {}
            };
            // Make sure that the subsection exists
            var section = sections[variable.section.name];
            section.subsections[variable.subsection.name] = section.subsections[variable.subsection.name] || {
                'name': variable.subsection.name,
                'index': variable.subsection.index,
                'variables': []
            };
            // Add the variable to subsection's list of variables
            section.subsections[variable.subsection.name].variables.push(variable);
        });

        // Give the section the the same order as the one it has in the LESS file.
        sections = sortSections(_.values(sections));

        callback(null, sections);
    };


    if (cachedSkinVariables) {
        applyTenantValues(null, cachedSkinVariables);
    } else {
        _cacheSkinVariables(applyTenantValues);
    }
};

/**
 * Get the configured UI directory path
 *
 * @return {String}                     The configured UI directory path
 */
var getUIDirectory = module.exports.getUIDirectory = function() {
    return uiDirectory;
};

/**
 * Generates the skin file for a tenant.
 *
 * @param  {String}     tenantAlias     The alias of the tenant for which the skin should be generated.
 * @param  {Function}   callback        Standard callback method.
 * @param  {Object}     callback.err    An error object (if any)
 * @param  {String}     callback.css    The generated CSS.
 * @api private
 */
var _generateSkin = function(tenantAlias, callback) {
    // Get all the default variables in the skin, as well as the tenant overrides
    var allVariables = getTenantSkinVariables(tenantAlias);

    // Parse the less file and supply the tenant values.
    _parseLessFile(allVariables, function(err, tree) {
        if (err) {
            return callback(err);
        }

        // Generate some CSS from the parse tree and cache it.
        // See http://lesscss.org/#usage (Configuration) for more information.
        try {
            cachedSkins[tenantAlias] = tree.toCSS({
                'cleancss': true,
                'compress': true
            });
        } catch (error) {
            return callback({'code': 500, 'msg': error.message});
        }

        callback(null, cachedSkins[tenantAlias]);
    });
};

/**
 * Parses a LESS file and return the syntax tree.
 * You can pass in variables with some values that will override any values in the less file.
 * This can be used to set the tenant values and generate a parse tree for a tenant's skin file.
 *
 * @param  {Object}   [variables]       Object where the key is the LESS variable name (without the '@') and the value is the corresponding CSS value.
 * @param  {Object}   callback.err      An error object containing the error code and message.
 * @param  {Object}   callback.tree     The CSS syntax tree.
 * @api private
 */
var _parseLessFile = function(variables, callback) {
    variables = variables || {};

    // Read the skin file.
    getStaticFile(UIConstants.paths.BASE_SKIN, function(err, skin) {
        if (err) {
            log().error({'err': err}, 'Could not read the skin file.');
            return callback(err);
        }

        variables = _replaceOptimizedPaths(variables);

        // Overwrite the default values.
        _.each(variables, function(value, key) {
            var re = new RegExp('^(@' + key + '): (.*);$', 'm');
            skin = skin.replace(re, '$1: ' + value + ';');
        });

        // Parse the less file.
        var parser = less.Parser({});
        parser.parse(skin, function(err, tree) {
            if (err) {
                log().error({'err': err}, 'Could not parse the skin file.');
                return callback({'code': 500, 'msg': err});
            }

            callback(null, tree);
        });
    });
};

/**
 * Parses the skin file and retrieves the annotated LESS variables.
 *
 * @param  {Function}   callback              Standard callback method.
 * @param  {Object}     callback.err          An error object (if any)
 * @param  {String}     callback.variables    The generated CSS.
 * @api private
 */
var _cacheSkinVariables = function(callback) {
    _parseLessFile(null, function(err, tree) {
        if (err) {
            return callback(err);
        }

        var variables = {};

        /*!
         * Get all the variables out of the skin file.
         * Unfortunately we can't use tree.variables() as that doesn't give us the section and subsection names..
         * We loop over each rule in the less file and apply the following checks
         *
         *   1.  Is this rule a section declaration?
         *
         *       Sections are used to logically group skinning variables.
         *       Sections are defined in the following way:
         *
         *       \/************************
         *         ** @section  Branding **
         *         ************************\/
         *
         *   2.  Is this rule a subsection declaration?
         *
         *       Subsections are used to created logical skinning variable groups inside of
         *       a section. Subsections are defined in the following way:
         *
         *       \/* @subsection  Link colors *\/
         *
         *   3.  Is this rule a variable comment?
         *
         *       Variable comments are rules that come right above a variable declaration.
         *       These are used to give each variable a description.
         *
         *   4.  Is this rule a variable declaration?
         *
         *       Variables that can be re-used troughout the skin.
         *       The 'type' of the variable will be determined by looking at the suffix of the variable name.
         *
         *       Looks like:
         *       \/* The background color for the body *\/    --> variable comment
         *       @body-background-color: #ECEAE5;           --> variable declaration, the variable is of type 'color'.
         */

        var section = 'Default';
        var subsection = 'main';

        var sections = [];
        var subsections = [];

        var sectionRegex = new RegExp('[*] [@]section[ ]+([^*]+) [*]');
        var subsectionRegex = new RegExp('[*] [@]subsection[ ]+([^*]+) [*]');

        for (var i = 0; i < tree.rules.length; i++) {

            var rule = tree.rules[i];
            var sectionMatch = null;
            var subsectionMatch = null;

            // Section declaration
            if (rule.value && typeof rule.value === 'string' && (sectionMatch = rule.value.match(sectionRegex))) {
                // Get the name of this section.
                section = sectionMatch[1];
                sections.push(section);
                subsection = 'main';
                subsections = [subsection];

            // Subsection declaration
            } else if (rule.value && typeof rule.value === 'string' && (subsectionMatch = rule.value.match(subsectionRegex))) {
                // Get the name of this subsection.
                subsection = subsectionMatch[1];
                subsections.push(subsection);

            // Variable declaration
            } else if (rule.variable === true) {
                // Each variable should have some CSS documentation on top of it
                // that explains what the variable does.
                // This should be defined in the previous rule.
                var docRule = tree.rules[i-1];
                var description = 'TODO';
                if (docRule && docRule.value && typeof docRule.value === 'string' && docRule.value.substring(0, 2) === '/*') {
                    description = docRule.value.replace('/* ', '').replace('*/', '');
                }

                // Strip out the '@' sign from the token to get the variable name.
                var name = rule.name.substr(1);

                // Less variables don't have any type.
                // We determine the type by looking at the suffix in the variable name.
                var type = UIConstants.variables.types.STRING;
                if (/-color$/.test(name)) {
                    type = UIConstants.variables.types.COLOR;
                }
                if (/-url$/.test(name)) {
                    type = UIConstants.variables.types.URL;
                }

                variables[name] = {
                    'name': name,
                    'defaultValue': rule.value.toCSS({}),
                    'description': description,
                    'type': type,
                    'section': {
                        'name': section,
                        'index': sections.indexOf(section)
                    },
                    'subsection': {
                        'name': subsection,
                        'index': subsections.indexOf(subsection)
                    }
                };
            }
        }

        // Cache the variables.
        cachedSkinVariables = variables;

        callback(null, variables);
    });
};

/**
 * Gets the skin variables for a given tenant.
 *
 * @param  {String}     tenantAlias     The alias of the tenant for which to retrieve the skin values
 * @return {Object}                     The skin values for the given tenant
 */
var getTenantSkinVariables = module.exports.getTenantSkinVariables = function(tenantAlias) {
    var defaultVariables = _getDefaultSkinVariableValues();
    var tenantVariables = _getTenantSkinVariableValues(tenantAlias);

    // Merge the default and tenant variables, tenant variables having precedence
    return _.extend({}, defaultVariables, tenantVariables);
};

/**
 * Retrieves the CSS values that a tenant has specified he wishes to use in the skin.
 * If the tenant values could not be parsed an empty object will be returned.
 *
 * @param  {String} tenantAlias The alias of the tenant for which the values should be retrieved.
 * @return {Object}             The CSS values keyed by the LESS variable name (without the '@'.)
 * @api private
 */
var _getTenantSkinVariableValues = function(tenantAlias) {
    var variables = uiConfig.getValue(tenantAlias, 'skin', 'variables');
    if (!variables || !_.isObject(variables)) {
        return {};
    } else {
        return variables;
    }
};

/**
 * Retrieves the default CSS values that are embedded in the skin template. If the skin has not been
 * parsed and cached yet, then this returns `null`.
 *
 * @return {Object}    A simple variableName->variableValue mapping of variables that are embedded in the skin file
 * @api private
 */
var _getDefaultSkinVariableValues = function() {
    if (!cachedSkinVariables) {
        return null;
    }

    var defaultVariableValues = {};
    _.each(cachedSkinVariables, function(variableMetadata, variableName) {
        defaultVariableValues[variableName] = variableMetadata.defaultValue;
    });

    return defaultVariableValues;
};

/**
 * Given an object mapping skin variables to values, replace URL values with static application paths that
 * may have been changed due to build optimization. For example, the static asset:
 *
 * `/shared/oae/img/logo.png`
 *
 * during a build optimization could be hashed, adding the hash of the file contents into the filename:
 *
 * `/shared/oae/img/logo.ac879d8f.png`
 *
 * The reason this is done is to ensure user caches are "busted" when the file changes, and allows "infinite"
 * length caching of the resources.
 *
 * So if a user specifies that they want their logo to be "/shared/oae/img/logo.png" in their skin variables,
 * this method needs to know how to map "/shared/oae/img/logo.png" to "/shared/oae/img/logo.ac879d8f.png". To
 * do this, there is a file `hashes.json` in the root directory of the optimized UI build that specifies a
 * JSON object that the optimizer step needs to generate, to identify what the "optimized" path of the file is.
 *
 * @path   {Object}    skinVariables   An object of variableName->variableValue of skin values that we should try and map to the optimized paths
 * @return {Object}                    An object of variableName->variableValue that contains the remapped URL variable values
 * @api private
 */
var _replaceOptimizedPaths = function(skinVariables) {
    var replacedVariables = _.extend({}, skinVariables);

    // If we have a path hashes mapping, we need to replace all URLs with those that have been optimized at build-time
    if (hashes) {
        var urlRegex = /'(.*)'/;
        _.each(skinVariables, function(value, key) {
            var variableMetadata = cachedSkinVariables[key];

            // Try to apply optimized paths if the variable is a valid URL
            if (variableMetadata && variableMetadata.type === UIConstants.variables.types.URL && urlRegex.test(value)) {
                // Strip out the enclosing quotes
                var url = value.replace(urlRegex, '$1').trim();
                if (hashes[url]) {
                    // If an optimized mapping exists for this URL, replace it with the quotes
                    replacedVariables[key] = util.format('\'%s\'', hashes[url]);
                }
            }
        });
    }

    return replacedVariables;
};



//////////
// I18N //
//////////

/**
 * Function that will translate a string by replacing all of the internationalization key by its translated value. This
 * original string can be a single internationalization key, or can contain multiple internationalization keys. Parts of
 * the string that are not internationalization keys will remain unchanged. Internationalization keys are identified by
 * the following format: `__MSG__KEY__`.
 *
 * The UI bundles are re-used to achieve the translation.
 *
 * @param  {String}     str             The string to translate
 * @param  {String}     locale          The locale into which the string should be translated. If no locale is provided, the `default` locale will be used
 * @param  {Object}     [variables]     Dynamic variables that should replace ${variable} placeholder in a translation. The replacements will happen based on the object keys
 * @return {String}                     The translated string
 */
var translate = module.exports.translate = function(str, locale, variables) {
    // Replace all __MSG__KEY__ instances with the appropriate translation
    return str.replace(/__MSG__(.*?)__/gm, function(match, i18nkey) {
        var translation = null;

        // If we have an i18nkey for that locale, we use it
        if (locale && i18nKeys[locale] && i18nKeys[locale][i18nkey]) {
            translation = i18nKeys[locale][i18nkey];

        // Otherwise we fall back to the `default` locale
        } else if (i18nKeys['default'] && i18nKeys['default'][i18nkey]) {
            translation = i18nKeys['default'][i18nkey];
        }

        // If the key could not be found, we return as is
        if (!translation) {
            return match;
        }

        // Replace all of the dynamic variables
        _.each(variables, function(dynamicTranslation, dynamicVariable) {
            var regex = new RegExp('\\$\\{' + dynamicVariable + '\\}', 'g');
            translation = translation.replace(regex, dynamicTranslation);
        });
        return translation;
    });
};

/**
 * Caches all the UI bundle files in-memory
 *
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    Standard error object, if any
 * @api private
 */
var _cacheI18nKeys = function(callback) {
    _cacheI18nKeysInDirectory('/ui', function(err) {
        if (err) {
            return callback(err);
        }

        return _cacheI18nKeysInDirectory('/node_modules', callback);
    });
};

/**
 * Caches all the bundle files in a ui directory in-memory
 *
 * @param  {String}     directory       The directory that contains the i18n bundles
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    Standard error object, if any
 * @api private
 */
var _cacheI18nKeysInDirectory = function(directory, callback) {
    // Ensure that we don't call our callback twice
    var done = _.once(callback);

    // Get all the bundles in the UI directory tree
    readdirp({
        'root': uiDirectory + directory,
        'fileFilter': '*.properties'
    })
    .on('data', function (entry) {
        _cacheBundleFile(directory + '/' + entry.path, function(err) {
            if (err) {
                return done(err);
            }
        });
    })
    .on('warn', function (err) { log().warn({'err': err}, 'A non-fatal error occured whilst reading the i18n bundles'); })
    .on('error', function (err) { log().error({'err': err}, 'A fatal error occured whilst reading the i18n bundles'); })
    .on('end', done);
};

/**
 * Caches an i18n bundle
 *
 * @param  {String}     bundlePath      The path to the bundle file in the UI directory
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    Standard error object, if any
 * @api private
 */
var _cacheBundleFile = function(bundlePath, callback) {
    callback = callback || function() {};

    // The locale is defined as the string that comes before the extension
    var locale = path.basename(bundlePath, '.properties');

    // Get the bundle's file content
    getStaticFile(bundlePath, function(err, data) {
        if (err) {
            log().error({'err': err, 'path': bundlePath}, 'Could not read an i18n bundle');
            return callback({'code': 500, 'msg': 'Failed to read an i18n bundle file'});
        }

        // Parse the file and add the keys to the locale
        var keys = PropertiesParser.parse(data);
        i18nKeys[locale] = i18nKeys[locale] || {};
        i18nKeys[locale] = _.extend(i18nKeys[locale], keys);
        return callback();
    });
};


////////////////
// Templating //
////////////////

/**
 * Renders and translates a template
 *
 * @param  {String}     template    The template to render
 * @param  {Object}     data        The data that should be passed into the template renderer
 * @param  {String}     locale      The locale that should be used to translate any i18n keys. Defaults to `en_US` if none is provided
 * @return {String}                 The rendered and translated template
 */
var renderTemplate = module.exports.renderTemplate = function(template, data, locale) {
    data = data || {};
    locale = locale || 'en_US';

    data.util = {
        'html': {
            /*!
             * @see Sanitization.encodeForHTML
             */
            'encodeForHTML': function(str) {
                return Sanitization.encodeForHTML(str);
            },

            /*!
             * @see Sanitization.encodeForHTMLAttribute
             */
            'encodeForHTMLAttribute': function(str) {
                return Sanitization.encodeForHTMLAttribute(str);
            },

            /*!
             * @see Sanitization.encodeForURL
             */
            'encodeForURL': function(str) {
                return Sanitization.encodeForURL(str);
            },

            /*!
             * Ensure that all links in a given string contain a base url
             *
             * @param  {String}     str         The string that contains the links that need to be checked
             * @param  {String}     baseUrl     The base url that should be present in each link
             * @return {String}                 The same string where all links contain the proper base url
             */
            'ensureLinksStartWith': function(str, baseUrl) {
                return str.replace(/href="(.*?)"/gm, function(match, link) {
                    if (link.indexOf(baseUrl) !== 0) {
                        return 'href="' + baseUrl + link + '"';
                    }

                    return 'href="' + link + '"';
                });
            },

            /*!
             * Returns the text for a given HTML string
             *
             * @param  {String}     str     The HTML string to parse and extra text from
             * @return {String}             The extracted text
             */
            'toText': function(str) {
                // We need to wrap the string in a `div` element as plain-text would otherwise be lost
                return cheerio('<div>' + str + '</div>').text();
            },
        },
        'text': {
            /*!
             * Standard string trimming + strips out HTML comments
             *
             * @param  {String}     str     The string to trim
             * @return {String}             The trimmed string
             */
            'trim': function(str) {
                str = str.replace(/<!--(?:.|\n)*?-->/gm, '');
                str = str.trim();
                return str;
            },

            /*!
             * Truncate a string and append three dots if the length of the string is longer
             * than `maxChars`. Before truncating, the string will be trimmed. If the given
             * string is not longer than `maxChars` characters, the string is returned as-is.
             *
             * @param  {String}     text        The text to truncate
             * @param  {Number}     maxChars    The maximum length of the string before cutting it off and appending three dots
             * @return {String}                 The truncated string
             */
            'truncate': function(text, maxChars) {
                text = data.util.text.trim(text);
                if (text.length > maxChars) {
                    text = text.substring(0, maxChars) + '...';
                }
                return text;
            },

            /*!
             * Given plain text content, convert it to an appropriate HTML string. Particularly:
             *
             *  * Escape all HTML characters so the content shows as it is in plain text; and
             *  * Convert all line-breaks to <br/> so that line breaks in the content are preserved
             *
             * @param  {String}     content     The plain-text content to convert to HTML
             * @return {String}                 The HTML version of the content
             */
            'toHtml': function(str) {
                // First escape HTML
                var sanitized = Sanitization.encodeForHTML(str);

                // Honour the new-line characters in the plain text by converting to <br />
                return sanitized.replace(/&#xa;/g, '<br/>');
            },

            /**
             * Get a human readable mimeType description for a content item. Unrecognized mimeTypes
             * will default to the `other` type.
             *
             * @param  {String}     resourceSubType     The resource sub type for which to generate an appropriate description
             * @param  {String}     [mimeType]          In case the `resourceSubType` is a `file` a more detailed description can be returned by providing a mime type
             * @return {String}                         Human readable mimetype description for the provided resource subtype and mime type
             */
            'getMimetypeDescription': function(resourceSubType, mimeType) {
                var descriptor = _getMimeTypeDescriptor();
                return descriptor.getDescription(resourceSubType, mimeType);
            }
        },

        'json': {
            /*!
             * Makes a string safe to embed in a json value
             *
             * @param  {String}     str     The string to place in a json value
             * @return {String}             The safe string
             */
            'escape': function(str) {
                if (!_.isString(str)) {
                    return '';
                }

                return JSON.stringify(str).slice(1, -1);
            }
        },

        'i18n': {
            /*!
             * Translates a key
             *
             * @param  {String}     key             The i18n key to translate
             * @param  {Object}     [properties]    A set of properties that can be used to translate the key
             * @return {String}                     The translated key
             */
            'translate': function(key, properties) {
                return translate('__MSG__' + key + '__', locale, properties);
            },

            /*!
             * Format a date
             *
             * @param  {Date}       date            The date to format
             * @param  {String}     dateFormat      The format in which the date should be formatted. See https://github.com/jquery/globalize/tree/v0.1.1#dates
             * @return {String}                     The formatted date
             */
            'formatDate': function(date, dateFormat) {
                // Gloablize requires the locale to use a `-` rather than a `_`
                var globalizeLocale = locale.replace('_', '-');
                return Globalize.format(date, dateFormat, globalizeLocale);
            }
        },

        'url': {
            /*!
             * Take a URL string, and return an object.
             *
             * @see http://nodejs.org/docs/latest/api/url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost
             */
            'parse': url.parse
        }
    };

    // Parse and process it with Underscore
    try {
        var compiledTemplate = _.template(template);
        var renderedTemplate = compiledTemplate(data);

        // Remove HTML comments
        renderedTemplate = renderedTemplate.replace(/<!--(?:.|\n)*?-->/gm, '');

        // Translate the template
        var translatedTemplate = translate(renderedTemplate, locale);

        // Trim useless spaces
        return translatedTemplate.trim();
    } catch (err) {
        log().error({'err': err}, 'Unable to render template');
        return '';
    }
};


//////////////////////
// ACTIVITY ADAPTER //
//////////////////////

/**
 * The activity adapter that can be used to adapt activities in a simple view-model
 *
 * @return {Object}    The activity adapter
 */
var getActivityAdapter = module.exports.getActivityAdapter = function() {
    return _uiRequire('/shared/oae/js/activityadapter.js');
};

/**
 * The mimetype description that can be used to generate descriptions for files
 *
 * @return {Object}     The mimetype descriptor
 * @api private
 */
var _getMimeTypeDescriptor = function() {
    return _uiRequire('/shared/oae/js/mimetypes.js');
};

/**
 * Require a file from the UI repository
 *
 * @param  {String}     path    The path to the file that should be required. This should start with a `/`
 * @return {Object}             The module as returned by Node.JS's `require` method
 * @api private
 */
var _uiRequire = function(path) {
    if (hashes && hashes[path]) {
        path = hashes[path];
    }
    return require(uiDirectory + path);
};

