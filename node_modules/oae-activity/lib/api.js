/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var AuthzAPI = require('oae-authz');
var AuthzUtil = require('oae-authz/lib/util');
var log = require('oae-logger').logger('oae-activity-api');
var MQ = require('oae-util/lib/mq');
var OAE = require('oae-util/lib/oae');
var OaeUtil = require('oae-util/lib/util');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var Redis = require('oae-util/lib/redis');
var TenantsAPI = require('oae-tenants');
var Validator = require('oae-authz/lib/validator').Validator;

var ActivityAggregator = require('./internal/aggregator');
var ActivityConfig = require('oae-config').config('oae-activity');
var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;
var ActivityDAO = require('./internal/dao');
var ActivityEmitter = require('./internal/emitter');
var ActivityNotifications = require('./internal/notifications');
var ActivityRegistry = require('./internal/registry');
var ActivityRouter = require('./internal/router');
var ActivityStream = require('oae-activity/lib/model').ActivityStream;
var ActivitySystemConfig = require('./internal/config');
var ActivityTransformer = require('./internal/transformer');

// Keeps track of whether or not the activity processing handler has been bound to the task queue
var boundWorker = false;

// Keeps track of the collection polling timer so that it may be cleared if activity processing is disabled
var collectionPollingTimer = null;

/**
 * ## ActivityAPI
 *
 * ### Events
 *
 *  * `deliveredActivities(routedActivities)` - Indicates activities have just been aggregated and delivered to an activity stream. The individual (unaggregated) persistent activities are provided.
 *  * `deliveredNotitifications(routedActivities)` - Indicates activities have just been aggregated and delivered to a notification stream. The individual (unaggregated) persistent activities are provided.
 */
var ActivityAPI = module.exports = ActivityEmitter;

/**
 * Refresh the activities configuration.
 *
 * @param  {Object}        [config]                            The object containing the configuration properties. See the `config.activity` object in the base `./config.js` for more information
 * @param  {Function}      [callback]                          Invoked when the configuration has been refreshed
 * @param  {Object}        [callback.err]                      An error that occurred, if any
 */
var refreshConfiguration = module.exports.refreshConfiguration = function(config, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Error refreshing activities configuration.');
        }
    };

    config = ActivitySystemConfig.refreshConfiguration(config);

    log().info({'config': config}, 'Refreshing activity configuration.');

    // Configure redis. Either uses the main connection pool, or a dedicated one if config.activity.redis was configured
    var redisClient = Redis.getClient();
    if (config.redis) {
        redisClient = Redis.createClientFromConfig(config.redis);
    }

    ActivityDAO.init(redisClient);

    // Reset the collection polling interval
    clearInterval(collectionPollingTimer);
    if (config.processActivityJobs && config.collectionPollingFrequency > 0) {
        var collectionPollingFrequencyInMs = config.collectionPollingFrequency * 1000;
        // Delegate to the aggregator to collect/aggregate all buckets
        collectionPollingTimer = setInterval(ActivityAggregator.collectAllBuckets, collectionPollingFrequencyInMs);
    }

    // Enable / Disable the worker binding, if necessary
    if (config.processActivityJobs && !boundWorker) {
        boundWorker = true;
        // Bind directly to the `routeActivity` router method
        return MQ.bind(ActivityConstants.mq.TASK_ACTIVITY, ActivityRouter.routeActivity, {'subscribe': {'prefetchCount': config.maxConcurrentRouters}}, callback);
    } else if (!config.processActivityJobs && boundWorker) {
        boundWorker = false;
        return MQ.unbind(ActivityConstants.mq.TASK_ACTIVITY, callback);
    } else {
        return callback();
    }
};

/*!
 * When the system starts shutting down, we want to stop the collecting polling timer so that no new collections
 * begin during the grace-time for active work to complete.
 */
OAE.registerPreShutdownHandler('oae-activity', null, function(callback) {
    log().info('Clearing the activity collection poller.');
    clearInterval(collectionPollingTimer);
    return callback();
});

/**
 * Registers an activity type with the application. While not all activities that are posted are required to be registered here,
 * this is how special activity behaviour, such as aggregation pivot points, may be specified.
 *
 * # `options.groupBy`
 *
 * The groupBy option allows the ability control how an activity is aggregated in an activity feed. It takes an array of objects
 * that specify all the "pivot points" on which activity entities will be collected. If an activity has no pivot points configured
 * for it with this option, then the activity will never aggregate and collect. However it will still be protected from duplicates
 * that occur within the aggregation window, by updating the existing activity and moving it to the top of the feed as the most
 * recent activity. Following are some configuration examples.
 *
 * ## Example 1
 *
 * ```javascript
 *  options.groupBy = [
 *      {
 *          'actor': true,
 *          'object': true
 *      }
 *  ];
 * ```
 *
 * This option specifies that if multiple activities of this type are delivered to a route that share the same "actor" and "object"
 * entity, they will be rolled up into one activity, where the "target" is a collection of the different targets involves in the
 * two activities. For example:
 *
 * Activity #1: Branden shared Syllabus with GroupA
 * Activity #2: Branden shared Syllabus with UserB
 *
 * If those activities are delivered to the same route within a configurable window of time, they will be grouped together as
 * something like "Branden shared syllabus with 2 users and groups".
 *
 * ## Example 2
 *
 * ```javascript
 *  options.groupBy = [
 *      {
 *          'actor': true,
 *          'object': true
 *      },
 *      {
 *          'actor': true,
 *          'target': true
 *      }
 *  ];
 * ```
 *
 * In this scenario, an activity will be pivoted on TWO different combinations of entities: actor+object and actor+target. This
 * enables the ability to maintain 2 separate aggregation branches for the activity. For example:
 *
 * Activity #1: Branden shared Syllabus with GroupA
 * Activity #2: Branden shared Syllabus with GroupB
 * Activity #3: Branden shared Introduction with Group A
 *
 * If those activities are delivered to the same route within a configurable window of time, they will be grouped together and
 * delivered as 2 separate aggregate activities (instead of the 3 activities):
 *
 * Aggregate #1: Branden shared 2 items with Group A
 * Aggregate #2: Branden shared Syllabus with 2 users and groups
 *
 * # `options.routers`
 *
 * The `routers` option allows one to configure who should receive the activity based on the actor, object and target of the
 * activity. The array of strings expected for each router specification (see params) indicates the name of an association (as
 * registered for that entity type) to use to derive the routes. All routes from all specified associations will be unioned
 * together in order to find the final list of routes.
 *
 * ## Example
 *
 * Lets say when a user adds another user to a group (actor: user1, object: principal2, target: group1), you might have a router
 * configuration like this:
 *
 * ```javascript
 *  options.routers = {
 *      'activity': {
 *          'actor': ['self', 'followers'],
 *          'object': ['self', 'members', 'followers'],
 *          'target': ['self', 'members']
 *      },
 *      'notification': {
 *          'object': ['self'],
 *          'target': ['managers']
 *      }
 * }
 * ```
 *
 * In this routing configuration, the `actor` configuration says that the actor user themself along with all of their followers
 * should receive the activity. The `object` configuration indicates that the group/user should receive an activity as well as the
 * members and the followers. Since `object` can be either user or group, obviously users don't have "members", so if it the
 * `object` is a group, the non-existing association will be ignored. The same goes for groups who don't have followers (yet?). For
 * notifications, the `object` entity (user or group) itself will receive a notification, though group notifications will be
 * filtered out as that is not implemented, similarly, all managers of the `target` group will receive a notification about the
 * activity.
 *
 * The full list of routes combined between actor, object and target will make the entire list of routes to which the activity will
 * be delivered. Note that in order to protect resources from being delivered to unprivileged users, there is also the notion of
 * `propagation` (@see #registerActivityEntityType), which will ultimiately restrict to which routes an activity may be delivered.
 *
 * @param  {String}         activityType                                The type of activity to register
 * @param  {Object}         [options]                                   The options which specify how the activities of this type behave
 * @param  {Object[]}       [options.groupBy]                           An array of objects which specify on which entities to pivot to activate activity aggregates. If not specified, the activity will not aggregate
 * @param  {Boolean|Object} [options.notifications]                     Configuration about how this activity should notify users that they happened
 * @param  {Boolean}        [options.notifications.email]               Whether or not a notification for this activity should send an email
 * @param  {String}         [options.notifications.emailTemplateModule] If sending an email, the module where the email template for this notification resides
 * @param  {String}         [options.notifications.emailTemplateId]     If sending an email, the id for the email template
 * @param  {Object}         [options.routers]                           Routers that define how the activity is routed based on its actor, object and target entities
 * @param  {Object}         [options.routers.activity]                  The routers that will route this activity among the `activity` routes
 * @param  {String[]}       [options.routers.activity.actor]            A list of association names whose results (relative to the actor entity) will be combined to form the activity routes of this activity
 * @param  {String[]}       [options.routers.activity.object]           A list of association names whose results (relative to the object entity) will be combined to form the activity routes of this activity
 * @param  {String[]}       [options.routers.activity.target]           A list of association names whose results (relative to the target entity) will be combined to form the activity routes of this activity
 * @param  {Object}         [options.routers.notification]              The routers that will route this activity among the `notification` routes
 * @param  {String[]}       [options.routers.notification.actor]        A list of association names whose results (relative to the actor entity) will be combined to form the notification routes of this activity
 * @param  {String[]}       [options.routers.notification.object]       A list of association names whose results (relative to the object entity) will be combined to form the notification routes of this activity
 * @param  {String[]}       [options.routers.notification.target]       A list of association names whose results (relative to the target entity) will be combined to form the notification routes of this activity
 */
var registerActivityType = module.exports.registerActivityType = function(activityType, options) {
    ActivityRegistry.registerActivityType(activityType, options);
};

/**
 * Registers an activity entity type with the system. The custom behaviour defined for an activity entity type are discussed in
 * this appropriately long comment block.
 *
 *
 * # Producer
 *
 * The activity entity producer is responsible for gathering the data that will be necessary to transform it into an ActivityEntity
 * when an activity feed is requested. This model is persisted into the stream, and the "transformer" will be responsible for
 * taking this data and converting it into the ActivityEntity object that is suitable to be displayed in the activity stream.
 *
 * For example, when someone posts a comment on a content item, an activity (content-comment) is generated. When displaying the
 * activity in the stream, it is useful to have additional context associated with the comment, such as its parent, if any. The
 * producer becomes useful because it can fetch the comment that was posted as well as its parent to be persisted directly into
 * the activity feed (denormalization). So when the activity stream is requested, multiple queries are not required to fetch
 * this information about the activity each time. The activity entity "transformer" is then provided this data to generate the
 * appropriate ActivityStrea.ms model when requested by a client.
 *
 * The astute reader will notice that there is no "user context" to take into consideration here. This is because permissions are
 * not taken into consideration at this stage. The release of the data passed on by the producer is controlled by `propagation` and
 * further more by the `transformer` if appropriate. See those blocks for additional details.
 *
 *
 * # Transformer
 *
 * The entity transformer is responsible for taking the entity data that was produced by the activity entity producer, and generating
 * the ActivityEntity for the current request. Since this transformer is invoked for every entity for every activity stream request,
 * it is important to do as little heavy-lifting here as possible, and rather defer as much work to the producer as possible, as the
 * data is only produced once per activity.
 *
 * The `activityEntities` parameter is a breakdown of all the entities of the appropriate `resourceType` in the current set of
 * activities being transformed. This object is structured like so:
 *
 * ```javascript
 * {
 *      'activityId0': {
 *          'resourceId0': { <Produced Entity Data> },
 *          'resourceId1': { <Produced Entity Data> }
 *      },
 *      'activityId1': {
 *          'resourceId0': { <Produced Entity Data> },
 *          'resourceId2': { <Produced Entity Data> },
 *          'resourceId3': { <Produced Entity Data> }
 *      }
 * }
 * ```
 *
 * Similarly, the `transformedActivityEntities` that are returned by the transformer are in the same format, except the
 * <Produced Entity Data> would be replaced with the <Transformed Entity>.
 *
 * Why is the entity data discriminated by activity id *and* resource id? It is technically possible for an entity in one activity
 * to have data that is different than an entity in another entity, even if it has the same id. Some reasons for this:
 *
 *  *   The producer produces data based on a particular activityType and entityType (actor, object, target), therefore it may have
 *      chosen to include different data based on what is relevant for that particular context
 *  *   Since entities are stored in a denormalized way in the activity, they are not updated when the entity data changes over
 *      time. Therefore, a newer activity may have a more recent version of the entity.
 *
 * So, if we don't keep transformed entities keyed by the activity to which they belong, we can end up overwriting entity data in
 * other activities.
 *
 * The `<Transformed Entity>` should be a JavaScript object complient with the activitystrea.ms model: http://activitystrea.ms/. In
 * addition to the core properties there, there are some agreed-upon extension properties which can be found in
 * `ActivityConstants.properties`. You are free to create your own extension properties as well as needed, but please prefix them
 * with "oae:". Here is an example of a transformed group:
 *
 * ```javascript
 *  {
 *      "oae:id": "g:camtest:group-PTqTgCydcBf",
 *      "oae:thumbnail": {
 *          "url": "/path/to/thumbnail.png",
 *          "width": 32,
 *          "height": 32
 *      },
 *      "oae:visibility": "public",
 *      "oae:joinable": "no",
 *      "displayName": "group-PTqTgCydcBf",
 *      "url": "http://tenant.host.com/group/g:camtest:group-PTqTgCydcBf",
 *      "image": {
 *          "url": "/path/to/image.png",
 *          "width": 162,
 *          "height": 162
 *      },
 *      "objectType": "group",
 *      "id": "http://tenant.host.com/api/group/g:camtest:group-PTqTgCydcBf"
 *  }
 * ```
 *
 *
 * # Propagation
 *
 * Propagation is responsible for, given an entity, determine who is allowed to receive this entity in their activity stream. This
 * happens once per activity during the routing phase in order to narrow the list of routes down to a subset of users/groups who
 * are indeed permissible to receive the entity. There are several different "types" of propagation that can be used to describe how
 * entities may be released to streams, as enumerated by `ActivityConstants.entityPropagation`:
 *
 *  * "all"                 - Indicates that *all* users and groups can see this entity. Common for resources whose visibility is `public`
 *  * "tenant"              - Indicates that only users and groups that belong to the same tenant as the entity can see it. Common for
 *                            resources whose visibility is "loggedin"
 *  * "interacting_tenants" - Indicates that only users and groups that belong to a tenant that can "interact" with the tenant to which
 *                            the entity belongs can see this entity. Common in situations when you have a resource who is configured to
 *                            be joinable (e.g., a group manager sets the group to be joinable) but it is also private. We can indicate
 *                            with this propagation type that the group can be released so that others may discover and join it, however
 *                            only to those users who are admissible to join it (i.e., those whose tenants can interact with it)
 *  * "routes"              - The default. Indicates that only the users / groups who have been specified as routes for the entity may
 *                            receive this entity
 *  * "association"         - Indicates that the result of a particular association may receive this entity. Useful to indiciate that only
 *                            members of a private item may receive it. This propagation type must be accompanied with a property
 *                            "association" indicating the name of the assocation that should provide the list of user and group ids
 *
 * Since the result of the `propagation` function is an *array* of propagations, this gives us flexibility to specify multiple ways the
 * item is allowed to be propagated, such that they are "unioned" / combined with "OR" semantics. For the common case of a "loggedin"
 * resource, it is useful to say "only users of this tenant, or those who are members are allowed receive this resource". This can be
 * expressed with a propagation array of:
 *
 * ```json
 *  [
 *      {
 *          "type": "tenant"
 *      },
 *      {
 *          "type": "association",
 *          "association": "members"
 *      }
 *  ]
 * ```
 *
 * So that users who belong to a different tenant, but have been granted explicit access to the resource, can receive the activity that
 * holds the entity.
 *
 * @param  {String}                 activityEntityType                                  The name of the entity type to register
 * @param  {Object}                 [options]                                           The options specifying the custom entity type functionality
 * @param  {Function}               [options.producer]                                  The implementation of the entity producer (see comment summary for more information). If unspecified, the `resourceData` of the ActivitySeedResource will simply be used as the produced persistent entity
 * @param  {ActivitySeedResource}   [options.producer.resource]                         The activity seed resource that was created for the entity when the activity was fired using `ActivityAPI.postActivity`
 * @param  {Function}               [options.producer.callback]                         Standard callback function. The producer must fire this with the produced entity when complete
 * @param  {Object}                 [options.producer.err]                              An error that occurred while producing the entity, if any
 * @param  {Object}                 [options.producer.entity]                           The produced persistent activity entity that will be persisted to the routes
 * @param  {Function}               [options.transformer]                               The implementation of the entity transformer (see comment summary for more information). If unspecified, only the `objectType` and `oae:id` of the produced entity will be used as the transformed entity
 * @param  {Context}                [options.transformer.ctx]                           The API context in which the current request is being performed. Contains the current authenticated user (if any) and the current tenant
 * @param  {Object}                 [options.transformer.entities]                      The persistent activity entities (as produced by the producer) to transform to a model suitable for the UI. See the method summary for the expected format of this object
 * @param  {Function}               [options.transformer.callback]                      Standard callback function. The transformer must fire this with the transformed entities when complete
 * @param  {Object}                 [options.transformer.callback.err]                  An error that occurred while transforming the entities, if any
 * @param  {Object}                 [options.transformer.callback.transformedEntities]  The transformed entities. See the method summary for the expected format of these entities
 * @param  {Function}               [options.propagation]                               The function that determines for an entity how it should be propagated among potential routes (see comment summary for more information). If unspecified, the propagation for entities of this type will default to `ActivityConstants.entityPropagation.ROUTES`
 * @param  {AssociationsContext}    [options.propagation.associations]                  The associations object with which registered associations for the activity entity type can be accessed. Associations for this entity are registered separately and pluggable by other modules. See ActivityAPI#registerActivityEntityAssociation for more information
 * @param  {Object}                 [options.propagation.entity]                        The persistent activity entity (as produced by the producer) whose propagation rules to determine
 * @param  {Function}               [options.propagation.callback]                      Standard callback function. The propagation function must fire this with the array of propagation rules when it has completed
 * @param  {Object}                 [options.propagation.callback.err]                  An error that occurred while determining the propagation rules, if any
 * @param  {Object[]}               [options.propagation.callback.propagation]          The array of propagation rules to apply to the entity. For more information on the format of these objects, see the method summary
 */
var registerActivityEntityType = module.exports.registerActivityEntityType = function(activityEntityType, options) {
    ActivityRegistry.registerActivityEntityType(activityEntityType, options);
};

/**
 * Registers an association for an activity entity type. The association should return some value that can be used either by a router, or
 * by an ad-hoc `associationsCtx.get` or `associationsSession.getByEntityId` call. There 2 benefits of using named associations over simply
 * fetching data from their APIs in different areas (should note that the *implementation* of the association provided here will indeed
 * fetch data from the respective API):
 *
 *  1.  By providing a simple name to refer to the association, routing then becomes a matter of configuration, rather than a complex
 *      implementation that is duplicated across different activity types; and
 *  2.  By managing the access of the associations in the associations session, we can create an L1 cache that will store the result
 *      of each named association per entity in local memory until the routing session is complete. This ultimately allows us to
 *      split the process of propagation and routing which was previously combined in order to optimize the number of queries to the
 *      db during routing
 *
 * Note that to be useful in the context of routing, the association will need to return an array of strings (i.e., routes). However,
 * assocations can be created that return other values (e.g., String, Number, Object) in an ad-hoc way for use in other ways, such as
 * determining propagation or to derive other associations. A good example of this is the "members-by-role" association registered by
 * the content module.
 *
 * @param  {String}                 activityEntityType                          The type of entity for which to register this association
 * @param  {String}                 associationName                             The name of the association to register. Will be accessed by this name using the assocations context: `associationsCtx.get('associationName', ...)`
 * @param  {Function}               associationFunction                         The function to register that fetches the associated ids
 * @param  {AssociationsContext}    associationFunction.associationsCtx         The associations context that can be used to help derive this new association
 * @param  {Object}                 associationFunction.entity                  The persistent activity entity, as produced by the entity producer for this entity type
 * @param  {Function}               associationFunction.callback                Standard callback function. The association function must fire this with the association when it has completed its process
 * @param  {Object}                 associationFunction.callback.err            An error that occurred, if any
 * @param  {Array|Object}           associationFunction.callback.association    The result of the association. To be useful as a route, this should be an array of strings, however other data structures can be provided as well for ad-hoc operations using the associations context directly
 */
var registerActivityEntityAssociation = module.exports.registerActivityEntityAssociation = function(activityEntityType, associationName, associationFunction) {
    ActivityRegistry.registerActivityEntityAssociation(activityEntityType, associationName, associationFunction);
};

/**
 * Get the activity stream by the specified id.
 *
 * @param  {Context}           ctx                 The context of the current session
 * @param  {String}            [start]             Number of millis since the epoc (or, last activity id) from which to start returning activities. Only activities older than this value will be returned. By default, will start from the newest.
 * @param  {Number}            [limit]             The number of activities to return. Default: 25
 * @param  {Function}          callback            Invoked when the process completes
 * @param  {Object}            callback.err        An error that occurred, if any
 * @param  {ActivityStream}    callback.activities The activity stream containing the requested set of activities
 */
var getActivityStream = module.exports.getActivityStream = function(ctx, activityStreamId, start, limit, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Must be logged in to see an activity stream'}).isLoggedInUser(ctx);
    validator.check(activityStreamId, {'code': 400, 'msg': 'Must specify an activity stream'}).notEmpty();
    validator.check(activityStreamId, {'code': 400, 'msg': 'You can only view activity streams for a principal'}).isPrincipalId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    limit = OaeUtil.getNumberParam(limit, 25, 1);

    var userId = ctx.user().id;
    var targetAuthzPrincipal = AuthzUtil.getPrincipalFromId(activityStreamId);
    if (ctx.user().isAdmin(targetAuthzPrincipal.tenantAlias)) {
        // Admin of the target tenant can always see the stream
        return _getActivityStream(ctx, activityStreamId, start, limit, callback);
    } else if (AuthzUtil.isGroupId(activityStreamId)) {
        // You can only view a group's activity stream if you are a member of that group
        return AuthzAPI.hasAnyRole(userId, activityStreamId, function(err, hasAnyRole) {
            if (err) {
                return callback(err);
            } else if (!hasAnyRole) {
                return callback({'code': 401, 'msg': 'Must be a member of a group to see its activity stream'});
            }

            return _getActivityStream(ctx, activityStreamId, start, limit, callback);
        });
    } else if (activityStreamId === userId) {
        // You can only view a user's activity stream if it is yourself. No peeking at other user streams.
        return _getActivityStream(ctx, activityStreamId, start, limit, callback);
    }

    // If we're here, we were trying to view another user's activity stream, not allowed!
    return callback({'code': 401, 'msg': 'You are not authorized to see this user\'s activity stream'});
};

/**
 * Get the notifications for the user authenticated to the given context.
 *
 * @param  {Context}            ctx                     The context of the current session
 * @param  {String}             [start]                 Number of millis since the epoc (or, last notification id) from which to start returning notifications. Only notifications older than this value will be returned. By default, starts from the newest
 * @param  {Number}             [limit]                 The maximum number of notifications to return. Default: 25
 * @param  {Function}           callback                Invoked when the process completes
 * @param  {Object}             callback.err            An error that occurred, if any
 * @param  {ActivityStream}     callback.notifications  The requested notifications, represented as an activity stream
 */
var getNotificationStream = module.exports.getNotificationStream = function(ctx, start, limit, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You must be logged in to see notifications'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Append #notification to the end of the user id. This is basically the only thing that is being abstracted out of activity streams in `getActivityStream`
    var streamId = ctx.user().id + '#notification';
    _getActivityStream(ctx, streamId, start, limit, callback);
};

/**
 * Mark all the notifications as read for the user authenticated ot the given context.
 *
 * @param  {Context}    ctx             The context of the current session
 * @param  {Function}   callback        Invoked when the process completes
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var markNotificationsRead = module.exports.markNotificationsRead = function(ctx, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You must be logged in to mark notifications read'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    ActivityNotifications.markNotificationsRead(ctx.user().id, callback);
};

/**
 * Post an activity in the system to be routed.
 *
 * @param  {Context}       ctx                 The execution context of the current request
 * @param  {ActivitySeed}  activitySeed        The activity "seed" object, which represents the smallest amount of information necessary to generate an activity
 * @param  {Function}      callback            Invoked when the activity has been posted (but has not been routed yet)
 * @param  {Object}        callback.err        An error that occurred, if any
 */
var postActivity = module.exports.postActivity = function(ctx, activitySeed, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'activitySeed': activitySeed}, 'Error posting activity');
        }
    };

    // Short-circuit if we find that activities are disabled for this tenant
    var activitiesEnabled = ActivityConfig.getValue(ctx.tenant().alias, 'activity', 'enabled');
    if (!activitiesEnabled) {
        return callback();
    }

    // Validate the activity seed
    var validator = new Validator();
    validator.check(null, {'code': 400, 'msg': 'No activity seed provided.'}).isObject(activitySeed);
    if (activitySeed) {
        validator.check(activitySeed.activityType, {'code': 400, 'msg': 'Activity seed did not have an activity type.'}).notEmpty();
        validator.check(activitySeed.verb, {'code': 400, 'msg': 'Activity seed did not have a verb.'}).notEmpty();
        validator.check(activitySeed.published, {'code': 400, 'msg': 'Activity seed did not have a valid publish date.'}).isNumeric();

        // Validate the actor resource
        validator.check(null, {'code': 400, 'msg': 'Activity seed did not have an actor resource'}).isObject(activitySeed.actorResource);
        if (activitySeed.actorResource) {
            validator.check(activitySeed.actorResource.resourceId, {'code': 400, 'msg': 'Actor of activity seed did not have a resourceId'}).notEmpty();
            validator.check(activitySeed.actorResource.resourceType, {'code': 400, 'msg': 'Actor of activity seed did not have a resourceType'}).notEmpty();
        }

        // Validate the object resource
        if (activitySeed.objectResource) {
            validator.check(activitySeed.objectResource.resourceId, {'code': 400, 'msg': 'Object of activity seed was specified and did not have a resourceId'}).notEmpty();
            validator.check(activitySeed.objectResource.resourceType, {'code': 400, 'msg': 'Object of activity seed was specified and did not have a resourceType'}).notEmpty();
        }

        // Validate the target resource
        if (activitySeed.targetResource) {
            validator.check(activitySeed.targetResource.resourceId, {'code': 400, 'msg': 'Target of activity seed was specified and did not have a resourceId'}).notEmpty();
            validator.check(activitySeed.targetResource.resourceType, {'code': 400, 'msg': 'Target of activity seed was specified and did not have a resourceType'}).notEmpty();
        }
    }

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    MQ.submit(ActivityConstants.mq.TASK_ACTIVITY, activitySeed, callback);
};

/**
 * Internal function to get an activity stream by its ID. This bypasses permission checks.
 *
 * @param  {Context}           ctx                     The context of the current request
 * @param  {String}            activityStreamId        The ID of the activity stream to fetch
 * @param  {Number}            start                   The starting timestamp of the activities to fetch
 * @param  {Number}            limit                   The number of activities to fetch
 * @param  {Function}          callback                Invoked when the process completes
 * @param  {Object}            callback.err            An error that occurred, if any
 * @param  {ActivityStream}    callback.activityStream The activity stream
 * @api private
 */
var _getActivityStream = function(ctx, activityStreamId, start, limit, callback) {
    ActivityDAO.getActivities(activityStreamId, start, limit, function(err, activities, nextToken) {
        if (err) {
            return callback(err);
        }

        ActivityTransformer.transformActivities(ctx, activities, function(err) {
            if (err) {
                return callback(err);
            }

            // Add the tenant information to activities that have an oae:id in their external info.
            _.each(activities, function(activity) {
                _addTenantInformationToActivityEntity(activity.actor);
                _addTenantInformationToActivityEntity(activity.object);
                _addTenantInformationToActivityEntity(activity.target);
            });

            // Wrap the transformed activities in a stream
            return callback(null, new ActivityStream(activities, nextToken));
        });
    });
};

/**
 * Adds the compact tenant information to those activity entities that are OAE entities.
 * The tenant information will be placed in an 'oae:tenant' key.
 *
 * @param  {ActivityEntity}  [entity]  The entity or the collection of entities to add the tenant information to.
 * @api private
 */
var _addTenantInformationToActivityEntity = function(entity) {
    if (entity) {
        if (entity['oae:id']) {
            var tenantAlias = AuthzUtil.getResourceFromId(entity['oae:id']).tenantAlias;
            var tenant = TenantsAPI.getTenant(tenantAlias);
            if (tenant) {
                entity[ActivityConstants.properties.OAE_TENANT] = tenant.compact();
            }
        } else if (entity['oae:collection']) {
            _.each(entity['oae:collection'], _addTenantInformationToActivityEntity);
        }
    }
};
