/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var Cassandra = require('oae-util/lib/cassandra');

/**
 * Determine the role of the principal on the specified resource instance.
 * 
 * @param {String} principalUuid the UUID of the principal
 * @param {String} The UUID of the resource
 * @param {Function(err, role)} callback A function specifying the role of the principal. If the principal
 * has no role or there is an error performing the check, role will be null
 **/
var getRole = module.exports.getRole = function(principalUuid, resourceUuid, callback) {
    var cql = 'select ? from Role where principal = ?';
    Cassandra.runQuery(cql, [resourceUuid, principalUuid], function(err, rows) {
        if (!err) {
            var col = rows[0].get(resourceUuid);
            if (col) {
                callback(null, col.value);
            } else {
                callback(null, null);
            }
        } else {
            callback(err);
        }
    });
}

/**
 * Determines whether or not the principal has the specified role on the given resource.
 * 
 * @param {String} principalUuid The UUID of the princpals
 * @param {String} resourceUuid The UUID of the resource
 * @param {String} role The role to check
 * @param {Function(err, hasRole)} callback A function specifying whether or not the user has the role on the resource
 */
var hasRole = module.exports.hasRole = function(principalUuid, resourceUuid, role, callback) {
    getRole(principalUuid, resourceUuid, function(err, actualRole) {
        if (!err) {
            callback(null, role === actualRole);
        } else {
            callback(err);
        }
    });
}


/**
 * Given an resourceType (as determined by Resource.resourceType), return all {resource uuid} => {role} entries that are
 * associated to the principal. The structure of the entries result looks like the following:
 * 
 * [
 *   {
 *      "uuid": "<resource uuid 1>",
 *      "role": "<role 1>"
 *    },
 *    {
 *      "uuid": "<resource uuid 2>"
 *      "role": "<role 2>"
 *    }
 * ]
 * 
 * @param {String} principalUuid The UUID of the principal
 * @param {String} resourceType The resource type to search, as determined by Resource.resourceType
 * @param {String} start The starting entry on which to begin returning results (used for paging). **This is not a number**. If null, then the results will simply begin from the start. If the resource uuid is provided, then results will begin from that resource's location, exclusively.
 * @param {Number} limit The maximum number of entries to return (used for paging; default: 10)
 * @param {Function(err, entries)} callback A function, providing the list of role entries that match the search
 */
var getRolesForResourceType = module.exports.getRolesForResourceType = function(principalUuid, resourceType, start, limit, callback) {
    if (limit && isNaN(limit)) {
        callback({code: 400, msg: '"limit" parameter must be a number when searching for active roles'});
        return;
    } else if (!limit) {
        limit = 10;
    } 

    var firstColumnIndex = 0;
    var columnPrefix = resourceType+':';

    if (start === null) {
        start = columnPrefix;    
    } else {
        // increment the limit if the user specified the start point, because we skip the first entry to get the EXCLUSIVE
        // page range
        limit++;
        firstColumnIndex = 1;
    }

    var cql = 'select first '+limit+' ? .. \'\' from Role where principal = ?';
    Cassandra.runQuery(cql, [start, principalUuid], function(err, rows) {
        if (!err) {
            var entries = [];
            for (var i = firstColumnIndex; i < rows[0].count; i++) {
                var col = rows[0][i];

                // prevents us from overflowing into other resource types
                if (col.name.indexOf(columnPrefix) !== 0) {
                    break;
                }

                entries.push({ 'uuid': col.name, 'role': col.value });
            }
            callback(null, entries);
        } else {
            callback({code: 500, msg: err});
        }
    });
}

/**
 * Assign the given principal a role on a resource instance. If the user already has a role, it will simply be updated.
 * 
 * @param {String} principalUuid The UUID of the principal
 * @param {String} resourceUuid the UUID of the resource
 * @param {String} role The role to assign to the principal
 * @param {Function(err)} callback A function specifying whether or not the operation was successful
 */
module.exports.setRole = function(principalUuid, resourceUuid, role, callback) {
    var cql = 'update Role set ? = ? where principal = ?';
    Cassandra.runQuery(cql, [resourceUuid, role, principalUuid], callback);
}

/**
 * Remove the role assignment of the given principal on an resource instance. If the user did not have a role, this will
 * have no effect.
 * 
 * @param {String} principalUuid The UUID of the principal
 * @param {String} resourceUuid The UUID of the resource
 * @param {Function(err)} callback A function specifying whether or not the operation was successful
 */
module.exports.removeRole = function(principalUuid, resourceUuid, callback) {
    var cql = 'delete ? from Role where principal = ?';
    Cassandra.runQuery(cql, [resourceUuid, principalUuid], callback);
}

/**
 * Assign multiple principals a role on a resource instance. If the user already has a role, it will simply be updated. When
 * false is passed in as a role, the role for that principal will be removed
 *
 * @param {String}          resourceUuid    the UUID of the resource
 * @param {Object}          roles           JSON object where the keys are principal ids and the values are role values
 * @param {Function(err)}   callback        Standard callback function
 * @param {Object}          callback.err    Error object, containing the error message
 */
module.exports.setRoles = function(resourceUuid, roles, callback) {
    var queries = [];
    for (var p in roles) {
        if (roles.hasOwnProperty(p)) {
            if (roles[p]) {
                queries.push({
                    'query': 'update Role set ? = ? where principal = ?',
                    'parameters': [resourceUuid, roles[p], p]
                });
            } else if (roles[p] === false) {
                queries.push({
                    'query': 'delete ? from Role where principal = ?',
                    'parameters': [resourceUuid, p]
                });
            } else {
                return callback({'code': 400, 'msg': 'An invalid role has been passed in (undefined)'});
            }
        }
    }
    Cassandra.runBatchQuery(queries, callback);
};

/**
 * Get all principal associations to the resourceType for all the principals in the array of principalUuids. This is similar
 * to getRolesForResourceType, except it can be performed on multiple principals at once.
 * 
 * The structure of the resulting entries is structured a hash, indicating all resourceUuids that were returned and what the
 * roles associated to those resources were. For example:
 *
 * {
 *      'g:cam:group-a': { 'member': true },
 *      'g:cam:group-b': { 'member': true }
 * }
 *
 * or:
 *
 * {
 *      'c:gat:Foo.docx': { 'viewer': true, 'manager': true},
 *      'c:cam:Bar.pdf':  { 'viewer': true }
 * }
 *
 * In the latter case, 'c:gat:Foo.docx' has both 'viewer' and 'manager' role associated to it. This indicates that some principal
 * had a role of 'viewer' on the resource, while some other principal had the 'manager' role.
 *
 * @param {Array}                       principalUuids      The array of principalUuds to query for
 * @param {String}                      resourceType        The resource type of the resources to search for, as determined by Resource.resourceType
 * @param {Number}                      limit               The maximum number of resources to return per user
 * @param {Function(err, entries)}      callback            A function providing all the {resource uuid} -> {roles} mappings aggregated
 *                                                          for all the provided principals queried
 * @see getRolesForResourceType
 */
module.exports.getAssociationsForPrincipalsAndResourceType = function(principalUuids, resourceType, limit, callback) {
	limit = limit || 1000;

    if (isNaN(limit)) {
        callback({code: 400, msg: '"limit" parameter must be a number when searching for active roles'});
        return;
    }

    // we append a '|' to the "end" range, as | has a high ASCII alphabetical ordering. This may not suffice if resourceIds have
    // multi-byte characters, which is technically possible. Unfortunately, I don't think there is a better way to do this with
    // CQL.
    var columnPrefix = resourceType+':';
    var start = columnPrefix;
    var end = start+'|';

    var cql = 'select first '+limit+' ? .. ? from Role where principal in (?)';
    Cassandra.runQuery(cql, [start, end, principalUuids], function(err, rows) {
        if (!err) {
            var entries = {};

            // aggregate all resources from all the rows (principals) into the entries hash
            rows.forEach(function(row) {
                for (var c = 0; c < row.count; c++) {
                    // this column represents a principal's role on a particular resource
                    // col.name = resourceUuid; col.value = role
                    var col = row[c];

                    if (!entries[col.name]) {
                        entries[col.name] = {};
                    }

                    entries[col.name][col.value] = true;
                }
            });
            
            callback(null, entries);
        } else {
            callback(err);
        }
    });
};

