/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var Helenus = require('helenus');

var OAE = require('oae-util/lib/oae');
var IO  = require('oae-util/lib/io');
var OaeUtil = require('oae-util/lib/util');
var Telemetry = require('oae-telemetry').telemetry('cassandra');
var log = require('oae-logger').logger('oae-cassandra');

var DEFAULT_ITERATEALL_BATCH_SIZE = 100;

var CONFIG = null;
var pool = null;

/**
 * Initializes the keyspace in config.keyspace with the CF's in all the modules their schema.js code.
 *
 * @param  {Object}    config          A Configuration object that can be used as the Cassandra client config.
 * @param  {Function}  callback        Standard callback method
 * @param  {Object}    callback.err    Error object, containing the error message
 */
module.exports.init = function(config, callback) {
    callback = callback || function(){};
    CONFIG = config;

    var keyspace = CONFIG.keyspace;

    // First connect to the system keyspace to ensure the specified keyspace exists
    CONFIG.keyspace = 'system';
    pool = _createPool(CONFIG);
    pool.connect(function(err) {

        // Immediately switch the CONFIG keyspace back to the desired keyspace
        CONFIG.keyspace = keyspace;

        if (err) {
            log().error({'err': err}, 'Error connecting to cassandra');
            return callback({'code': 500, 'msg': 'Error connecting to cassandra'});
        }

        keyspaceExists(keyspace, function(err, exists) {
            if (err) {
                // ensure the pool is closed
                return close(function() {
                    callback(err);
                });
            }

            if (!exists) {
                createKeyspace(keyspace, function(err) {
                    if (err) {
                        return close(function() {
                            callback(err);
                        });
                    }

                    // reconnect the pool now with the desired keyspace
                    _reloadPool(callback);
                });
            } else {
                // reconnect the pool now with the desired keyspace
                _reloadPool(callback);
            }
        });
    });
};

/**
 * Close all the connections in the connection pool.
 *
 * @param  {Function}  callback  A standard callback function, invoked when all the connections are closed.
 */
var close = module.exports.close = function(callback) {
    pool.on('close', function(err) {
        if (err) {
            log().error({'err': err}, 'Error closing the cassandra connection pool');
            return callback({'code': 500, 'msg': 'Error closing the cassandra connection pool'});
        }

        return callback();
    });

    pool.close();
};

/**
 * Create a keyspace if it does not exist. If it does, then this will have no effect.
 *
 * @param  {String}    name                The name of your keyspace
 * @param  {Function}  callback            Callback method
 * @param  {Object}    callback.err        An error that occurred, if any
 * @param  {Boolean}   callback.created    Specifies whether or not a keyspace was actually created.
 */
var createKeyspace = module.exports.createKeyspace = function(name, callback) {
    callback = callback || function() {};

    var options = {
        name: name,
        strategyClass: CONFIG.strategyClass || 'SimpleStrategy',
        strategyOptions: CONFIG.strategyOptions,
        replication: CONFIG.replication || 1,
        durable: CONFIG.durable
    };

    // only create it if it exists.
    keyspaceExists(name, function(err, exists) {
        if (err) {
            return callback(err);
        }
        if (!exists) {
            pool.createKeyspace(name, options, function(err) {
                if (err) {
                    return callback(err);
                }
                // pause for a second to ensure the keyspace gets agreed upon across the cluster.
                setTimeout(callback, 1000, null, true);
            });
        } else {
            return callback(null, false);
        }
    });
};

/**
 * Drops a keyspace
 *
 * @param  {String}    name                The keyspace that should be dropped.
 * @param  {Function}  callback            Standard callback function
 * @param  {Object}    callback.err        An error that occurred, if any
 * @param  {Boolean}   callback.dropped    Whether or not the keyspace was dropped
 */
var dropKeyspace = module.exports.dropKeyspace = function(name, callback) {
    callback = callback || function() {};
    runQuery('DROP KEYSPACE ' + name, false, function(err) {
        if (err) {
            return callback(err);
        }
        callback(null, true);
    });
};

/**
 * Checks if a keyspace exists or not.
 *
 * @param  {String}     name            The name of the keyspace to check
 * @param  {Function}   callback        Gets called with an error object (if any) and a boolean whether or not the keyspace exists.
 * @param  {Object}     callback.err    An error that occurred, if any
 * @param  {Boolean}    callback.exists Whether or not the keyspace existed
 */
var keyspaceExists = module.exports.keyspaceExists = function(name, callback) {
    _describeKeyspace(name, function(err, def) {
        callback(err, def ? true : false);
    });
};

/**
 * Checks if a CF exists or not.
 *
 * @param  {String}   name     The name of the CF to check.
 * @param  {Function} callback Gets called with an error object (if any) and a boolean whether or not the CF exists.
 */
var columnFamilyExists = module.exports.columnFamilyExists = function(name, callback) {
    _describeKeyspace(CONFIG.keyspace, function(err, definition) {
        if (err) {
            return callback(err);
        }
        var exists = false;
        for (var i = 0; i < definition.cf_defs.length;i++) {
            if (definition.cf_defs[i].name === name) {
                exists = true;
                break;
            }
        }
        callback(null, exists);
    });
};


/**
 * Drops a Column family. A query will only be performed if the CF exists.
 *
 * @param  {String}   name     The name of CF you wish to drop.
 * @param  {Function} callback Gets called with an error object (if any) and a boolean whether or not the CF was dropped.
 */
var dropColumnFamily = module.exports.dropColumnFamily = function(name, callback) {
    // Only drop if it exists.
    columnFamilyExists(name, function(err, exists) {
        if (err) {
            return callback(err);
        } else if (!exists) {
            return callback({'code': 400, 'msg': 'The CF ' + name + ' could not be dropped as it does not exist'});
        }
        runQuery('DROP COLUMNFAMILY ?', [name], function(err) {
            if (err) {
                return callback(err);
            }
            // Helenus caches the CF schema internally.
            // there is no way of refreshing that (synchronously)
            // We close the pool and create a new connection.
            // This makes using this method not suitable for production use!
            _reloadPool(function(err) {
                if (err) {
                    return callback(err);
                }
                callback(null, true);
            });
        });
    });
};

/**
 * Drop a batch of column families. This is a helper method that will be
 * used by various OAE modules when they are initialized. The column families
 * will only be created when they don't exist yet
 *
 * @param  {Array}         families        Array containing the names of all column families that should be dropped
 * @param  {Function}      callback        Standard callback function. Gets called when the process is complete
 * @param  {Object}        callback.err    An error that occurred, if any
 */
var dropColumnFamilies = module.exports.dropColumnFamilies = function(families, callback) {
    callback = callback || function() {};
    _dropColumnFamilies(families.slice(0), callback);
};

/**
 * Synchronously drop a batch of column families. The array passed in here will be altered in order to recursively
 * drop the column families.
 *
 * @param  {Array}      families        Array containing the names of all column families that should be dropped.
 * @param  {Function}   callback        Standard callback function. Gets executed when the process is complete
 * @param  {Object}     callback.err    An error that occurred, if any
 * @api private
 */
var _dropColumnFamilies = function(families, callback) {
    if (families.length === 0) {
        return callback();
    }

    var family = families.pop();
    dropColumnFamily(family, function(err) {
        if (err) {
            return callback(err);
        }
        _dropColumnFamilies(families, callback);
    });
};

/**
 * Creates a CF if it doesn't exist yet. This is basically a helper method
 * that allows for quick creation of CF if nescecary.
 * Do NOT use this in a concurrent way as the pooled connection will be shut down!
 *
 * @param  {String}                  name               CF name
 * @param  {String}    cql                The CQL that can be used to create the CF if it doesn't exist.
 * @param  {Function}  callback           Gets called when the CF has been created (or it failed.)
 * @param  {Object)}   callback.err       Error object containing the error message
 * @param  {Boolean)}  callback.created   Whether or not the column family has actually been created
 */
var createColumnFamily = module.exports.createColumnFamily = function(name, cql, callback) {
    callback = callback || function() {};
    columnFamilyExists(name, function(err, exists) {
        if (err) {
            return callback(err);
        }

        if (!exists) {
            runQuery(cql, false, function(err) {
                if (err) {
                    return callback(err);
                }

                // Helenus caches the CF schema internally.
                // there is no way of refreshing that (synchronously)
                // We close the pool and create a new connection.
                // This makes using this method not suitable for production use!
                _reloadPool(function(err) {
                    if (err) {
                        return callback(err);
                    }
                    callback(null, true);
                });
            });
        } else {
            callback(null, false);
        }
    });
};

/**
 * Create a batch of column families. This is a helper method that will be
 * used by various OAE modules when they are initialized. The column families
 * will only be created when they don't exist yet
 *
 * @param  {Object}        families        JSON object representing the column families that need to be created. The keys are the names of the CFs, the values are the CQL statements required to create them
 * @param  {Function}      callback        Standard callback functionGets called when the CFs have been created.
 * @param  {Object}        callback.err    An error that occured, if any.
 */
var createColumnFamilies = module.exports.createColumnFamilies = function(families, callback) {
    callback = callback || function() {};
    var keys = _.keys(families).slice(0);
    _createColumnFamilies(keys, families, callback);
};

/**
 * Internal version of createColumnFamilies that is equiped to create a set of column families synchronously.
 *
 * @param  {String[]}      keys            The key array (keys of the families JSON object) identifying the CF's to create
 * @param  {Object}        families        JSON object representing the column families that need to be created. The keys are the names of the CFs, the values are the CQL statements required to create them
 * @param  {Function}      callback        Standard callback functionGets called when the CFs have been created.
 * @param  {Object}        callback.err    An error that occurred, if any
 * @api private
 */
var _createColumnFamilies = function(keys, families, callback) {
    if (keys.length === 0 ) {
        return callback();
    }

    var cfKey = keys.pop();
    createColumnFamily(cfKey, families[cfKey], function(err) {
        if (err) {
            return callback(err);
        }
        _createColumnFamilies(keys, families, callback);
    });
};

/**
 * Run a single Cassandra query.
 *
 * @param  {String}   query         The CQL query
 * @param  {array}    parameters    An array of values that can be interpreted by cassandra. If an element is detected as an array the query and parameters will be fixed.
 * @param  {Function} callback      Callback method.
 * @param  {Object}   callback.err  An error that occurred, if any
 */
var runQuery = module.exports.runQuery = function(query, parameters, callback) {
    if (query.indexOf('SELECT') === 0) {
        Telemetry.incr('read.count');
    } else {
        Telemetry.incr('write.count');
    }

    executeQuery(query, parameters, callback);
};

/**
 * Run a batch of Cassandra update and insert queries.
 *
 * @param  {Object[]}   queries             An array of simple hashes. Each hash should contain a query key and parameters key.
 * @param  {String}     [consistency]       The consistency to apply to the batch request. Should be one of QUORUM, ONE or ANY. Defaults to QUORUM.
 * @param  {Function}   callback            Callback method
 * @param  {Object}     callback.err        An error that occurred, if any
 */
var runBatchQuery = module.exports.runBatchQuery = function(queries, consistency, callback) {
    if (queries.length === 0) {
        return callback();
    }

    Telemetry.incr('write.count', queries.length);

    consistency = consistency || 'QUORUM';

    var query = 'BEGIN BATCH' + _createUsingClause(consistency) + ' \n';
    var parameters = [];
    for (var i = 0; i < queries.length;i++) {
        query += queries[i].query + '; \n';
        parameters = parameters.concat(queries[i].parameters);
    }
    query += 'APPLY BATCH;';
    executeQuery(query, parameters, callback);
};

/**
 * Query a page of data from the columns of a specified row
 *
 * @param  {String}     columnFamily            The column family to query
 * @param  {String}     keyColumnName           The name of the key column to query
 * @param  {String}     keyColumnValue          The value of the key column to query
 * @param  {String}     [start]                 The *exclusive* starting point of the query. If unspecified, will start from the beginning
 * @param  {Number}     [limit]                 The maximum number of columns to fetch. Defaults to 25
 * @param  {Object}     [opts]                  Advanced query options
 * @param  {String}     [opts.consistency]      The Cassandra consistency with which to query. Defaults to QUORUM
 * @param  {Boolean}    [opts.reversed]         Whether or not the columns should be queried in reverse direction (highest to lowest). If `true`, the `start` range should be the *high range* from which you wish to start return columns. Defaults to `false`
 * @param  {String}     [opts.end]              The *inclusive* ending point of the query. If unspecified, will query columns to the end of the row
 * @param  {Function}   callback                Invoked when the query is completed
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Column}     callback.columns        An array of Helenus Column objects, holding just the columns that were selected in this "page"
 * @param  {String}     callback.nextToken      The value to use for the `start` parameter to get the next set of results
 * @param  {Boolean}    callback.startMatched   Indicates if the `start` parameter was an exact match to a column that was removed from the result set
 */
var runPagedColumnQuery = module.exports.runPagedColumnQuery = function(columnFamily, keyColumnName, keyColumnValue, start, limit, opts, callback) {
    limit = OaeUtil.getNumberParam(limit, 25);
    opts = opts || {};
    opts.consistency = opts.consistency || 'QUORUM';

    var numberToSelect = limit;
    var params = [];
    var cqlColumnRange = null;

    // If a start or end were specified, we will need to do a range rather than just a * select
    if (start || opts.end) {
        cqlColumnRange = ' ? .. ? ';

        // When selecting with bounds, exclusion comes into effect, so we need to select just one more to account for
        // the possibility of truncating the first result.
        numberToSelect++;

        start = start || '';
        var end = opts.end || '';

        params.push(start, end);

    } else {
        cqlColumnRange = ' * ';
    }

    // SELECT FIRST 26 REVERSED ...
    var cql = 'SELECT FIRST ' + numberToSelect;
    if (opts.reversed) {
        cql += ' REVERSED';
    }

    // ... ? .. ? FROM AuthzMemembers USING CONSISTENCY QUORUM WHERE resourceId = 'c:cam:Foo.docx'
    cql += cqlColumnRange + ' FROM ? USING CONSISTENCY ' + opts.consistency + ' WHERE ? = ?';
    params.push(columnFamily, keyColumnName, keyColumnValue);

    runQuery(cql, params, function(err, rows) {
        if (err) {
            return callback(err);
        }

        var row = rows[0];
        var startMatched = false;

        if (row[0]) {
            if (row[0].name === start) {
                // Since the starting bound is exclusive, we slice out the first column if it is *exactly* equal
                // to the starting point
                row.shift();
                startMatched = true;
            } else {
                // Exclusion doesn't take effect, so we truncate the last item (if we selected it)
                if (row.count > limit) {
                    row.pop();
                }
            }
        }

        // Determine the value that can be used to retrieve the next set of columns.
        // If we did not fetch as many as we specified, indicate that there are no results left by
        // returning a null `nextToken`. This is important because since we can technically return
        // less values than requested, the consumer doesn't otherwise have a solid indication of when
        // there are no results left.
        var nextToken = null;
        if (row.count === limit) {
            nextToken = row[limit -1].name;
        }

        var columns = [];
        row.forEach(function(name, value, timestamp, ttl) {
            columns.push({
                'name': name,
                'value': value,
                'timestamp': timestamp,
                'ttl': ttl
            });
        });

        // Return the paged row
        return callback(null, columns, nextToken, startMatched);
    });
};

/**
 * Iterate through all the rows of a column family in a completely random order. This will return just the columnNames that are
 * specified in the `columnNames` parameter, and at most `batchSize` rows at a time. On each iteration of `batchSize` rows, the
 * `onEach` callback will be executed. When the `onEach.done` function parameter is invoked without an error parameter, then the
 * next batch of rows will be fetched. If an object is provided as the first parameter to `onEach.done`, then iteration will
 * stop and the `callback` method will be invoked with the error.
 *
 * Since it is possible for Cassandra to return rows that were recently deleted as "tombstones", this method can also accept an
 * `opts.slugColumnName` option, which tells the iterator to use that column to determine whether or not the row truly exists. If
 * the value in the slug column that is fetched from storage has no value, then the row is deemed invalid and will not be returned
 * in the result set. While the slug column value will be fetched from the data-store to determine if the row is valid, it will
 * only be returned in the row if specified by the `columnNames` property. Since deleted rows are simply removed from the result
 * set, it is possible for the number of `rows` in each batch to actually be less than the specified batch size.
 *
 * @param  {String[]}   [columnNames]           The names of the columns to return in the rows. If not specified (or is empty array), it selects all columns. This is generally not recommended and should be avoided if possible.
 * @param  {String}     columnFamily            The column family to iterate over.
 * @param  {String}     keyColumnName           The name of the column that represents the key of the row.
 * @param  {Object}     [opts]                  Additional optional parameters
 * @param  {Number}     [opts.batchSize]        The number of rows to fetch at a time. Defaults to 100.
 * @param  {String}     [opts.consistency]      The Cassandra consistency to use when fetching rows. Defaults to ONE.
 * @param  {String}     [opts.slugColumnName]   The name of the column to use to check whether or not the row is a "tombstone". If a row is in storage that doesn't have a value for this column, then the row will not be returned in the results.
 * @param  {Function}   onEach                  Invoked with each batch of rows that are fetched from storage. If an exception is thrown in the *same process tick* in which it is invoked, onEach will be invoked with the `err` that was thrown and no more iterations will complete.
 * @param  {Rows}       onEach.rows             A helenus `Rows` object, holding all the rows fetched from storage in this iteration.
 * @param  {Function}   onEach.done             The function to invoke when you are ready to proceed to the next batch of rows
 * @param  {Boolean}    onEach.done.err         Specify this error parameter if there was an error processing the batch of data. Specifying this error will stop iteration and it will be passed directly into the completion `callback`.
 * @param  {Function}   [callback]              Invoked when either all rows have finished being iterated, or there was an error
 * @param  {Object}     [callback.err]          An error that occurred while iterating, if any.
 */
var iterateAll = module.exports.iterateAll = function(columnNames, columnFamily, keyColumnName, opts, onEach, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({
                'err': err,
                'columnNames': columnNames,
                'columnFamily': columnFamily,
                'opts': opts
            }, 'Error while iterating over all rows in storage.');
        }
    };

    // Apply default options
    opts = opts || {};
    opts.batchSize = OaeUtil.getNumberParam(opts.batchSize, DEFAULT_ITERATEALL_BATCH_SIZE);
    opts.consistency = opts.consistency || 'ONE';

    // We need to determine whether or not we need to delete the slug column from each result
    var returnSlugColumn = true;
    if (opts.slugColumnName && columnNames) {
        returnSlugColumn = (columnNames.indexOf(opts.slugColumnName) !== -1);
        if (!returnSlugColumn) {
            // Add the slug to the column names to query if it's not there already.
            columnNames.push(opts.slugColumnName);
        }
    }

    return _iterateAll(columnNames, columnFamily, keyColumnName, opts.batchSize, opts.consistency, opts.slugColumnName, returnSlugColumn, onEach, callback);
};

/**
 * Internal version of #iterateAll method. The method contract is the same as `Cassandra#iterateAll`, but this has internal parameters
 * for iteration.
 *
 * @param  {String[]}   [columnNames]       See `columnNames` in `Cassandra#iterateAll`
 * @param  {String}     columnFamily        See `columnFamily` in `Cassandra#iterateAll`
 * @param  {String}     keyColumnName       See `keyColumnName` in `Cassandra#iterateAll`
 * @param  {Number}     batchSize           See `opts.batchSize` in `Cassandra#iterateAll`
 * @param  {String}     consistency         See `opts.consistency` in `Cassandra#iterateAll`
 * @param  {String}     slugColumnName      See `opts.slugColumnName` in `Cassandra#iterateAll`
 * @param  {Boolean}    returnSlugColumn    Whether or not the column specified by `slugColumnName` should be part of the returned rows
 * @param  {Function}   onEach              See `onEach` in `Cassandra#iterateAll`
 * @param  {Function}   callback            See `callback` in `Cassandra#iterateAll`
 * @param  {String}     fromKey             Used for recursion only. Specifies the key from which the next iteration batch should start
 * @api private
 */
var _iterateAll = function(columnNames, columnFamily, keyColumnName, batchSize, consistency, slugColumnName, returnSlugColumn, onEach, callback, fromKey) {
    var query = _buildIterateAllQuery(columnNames, columnFamily, keyColumnName, batchSize, consistency, fromKey);
    // Since Cassandra.runQuery jumps into a new process tick, there is no issue over this recursion exceeding stack size with large data-sets
    runQuery(query.query, query.parameters, function(err, rows) {
        if (err) {
            return callback(err);
        } else if (rows.length === 0) {
            // Notify the caller that we've finished
            return callback();
        }

        var validRows = [];
        rows.forEach(function(row) {
            // If there was a slug column specified and the row did not contain it, then it is considered a "tombstone" (i.e., it has been deleted and just not collected yet)
            if (!slugColumnName || (row.get(slugColumnName) && row.get(slugColumnName).value)) {
                // Clean the slug off the row if it was not requested
                if (!returnSlugColumn) {
                    delete row.get(slugColumnName).value;
                }
                validRows.push(row);
            }

            // Remember the last key to use for the next iteration
            fromKey = row.key;
        });

        try {
            // Give the rows to the caller. Wrapping in a try / catch so if an error is thrown (in the same processor tick) then
            // we can still catch the error and invoke the callback with it
            onEach(validRows, function(err) {
                if (err) {
                    return callback(err);
                }

                // Start the next iteration
                _iterateAll(columnNames, columnFamily, keyColumnName, batchSize, consistency, slugColumnName, returnSlugColumn, onEach, callback, fromKey);
            });
        } catch (ex) {
            log().error({'err': ex}, 'Error invoking consumer onEach during iterateAll');
            return callback({'code': 500, 'msg': ex.message});
        }
    });
};

/**
 * Build a query that can be used to select `batchSize` rows from a column family starting from key `fromKey`.
 *
 * @param  {String[]}   [columnNames]   The names of the columns to query in the rows. If not specified (or is empty array), it selects all columns.
 * @param  {String}     columnFamily    The column family to query.
 * @param  {String}     keyColumnName   The name of the column that represents the key of the column family.
 * @param  {Number}     batchSize       The number of rows to fetch.
 * @param  {String}     consistency     The Cassandra consistency to use when fetching rows.
 * @param  {String}     fromKey         The value of the row key from which to start fetching results.
 * @return {Object}                     An object with key `query` that contains the String CQL query, and key `parameters` that holds an array of parameters that fill the query placeholders in the Cassandra query.
 * @api private
 */
var _buildIterateAllQuery = function(columnNames, columnFamily, keyColumnName, batchSize, consistency, fromKey) {
    var cql = 'SELECT ';
    var params = [];

    if (columnNames && columnNames.length > 0) {
        var columnPlaceholders = [];
        _.each(columnNames, function(columnName) {
            columnPlaceholders.push('?');
            params.push(columnName);
        });

        cql += columnPlaceholders.join(', ');
    } else {
        cql += '*';
    }

    cql += ' FROM ' + columnFamily + ' USING CONSISTENCY ' + consistency;

    if (fromKey) {
        cql += ' WHERE ? > ?';
        params.push(keyColumnName);
        params.push(fromKey);
    }

    cql += ' LIMIT ' + batchSize;

    return {'query': cql, 'parameters': params};
};

/**
 * Convert to given cassandra row to a column hash. Keyed by the column name, with value being the column value.
 *
 * @param  {Row}       row     The cassandra Row to convert to a hash
 * @return {Object}            Return an Object, keyed by the column name, with values being the column value.
 */
var rowToHash = module.exports.rowToHash = function(row) {
    var result = {};
    row.forEach(function(name, value) {
        // We filter out null and undefined values, as Cassandra will return these when a query term has not matched
        // against an existing column
        if (value !== null && value !== undefined) {
            result[name] = value;
        }
    });
    return result;
};

/**
 * Utility method that constructs an update CQL query with a flexible number of columns, that can both
 * be used for inserts and updates. String and Number values will be persisted as their native types,
 * while Objects and Arrays will be stringified.
 *
 * This creates a query with the following form: UPDATE testCF SET ? = ?, ? = ?, ? = ? WHERE testId = ?
 *
 * @param  {String}     cf              The name of the column family in which we're doing an update/insert
 * @param  {String}     rowKey          The row key that will be used in the WHERE clause
 * @param  {String}     rowValue        The value of the row key to use in the WHERE clause
 * @param  {Object}     values          JSON object where the keys represent the column names of the columns that need to be updated/inserted and the values represent the new column values
 * @param  {String}     [consistency]   The consistency level that should be used for the query (e.g. QUORUM). This is optional in case this function would be used to construct the segments of a batch query
 * @param  {Number}     [ttl]           The ttl that should be used for the columns upserted by this query, if any. If not specified, columns upserted will not expire
 * @return {Object}                     Returns a JSON object with a query key that contains the generated CQL query and a parameters key that contains the generated parameter array {query: CQLQuery, parameters: [parameterArray]}
 */
var constructUpsertCQL = module.exports.constructUpsertCQL = function(cf, rowKey, rowValue, values, consistency, ttl) {
    // Check that cf, whereColumn and whereValue have been provided
    // Also check that values has at least 1 key-value pair
    if (!cf || !rowKey || !rowValue || _.keys(values).length === 0) {
        return false;
    }

    // Construct the query
    var q = {
        'query': '',
        'parameters': []
    };
    var placeholders = [];

    // Each entry in the value hash is one column in the cassandra row
    _.each(values, function(value, key) {
        // Stringify objects as JSON
        if (_.isObject(value)) {
            value = JSON.stringify(value);
        }

        if (!_.isUndefined(value) && !_.isNull(value)) {
            placeholders.push('? = ?');
            q.parameters.push(key, value);
        }
    });

    q.query = 'UPDATE ' + cf + _createUsingClause(consistency, ttl);
    q.query += ' SET ' + placeholders.join(', ') + ' WHERE ' + rowKey + ' = ?';
    q.parameters.push(rowValue);

    return q;
};

/**
 * Actually executes a query
 *
 * @param  {String}     query           The query
 * @param  {Object[]}   [parameters]    The parameters that match this query. Defaults to an empty array
 * @param  {Function}   callback        Callback method
 * @param  {Object}     callback.err    An error that occurred, if any
 * @api private
 */
var executeQuery = function(query, parameters, callback) {
    parameters = parameters || [];
    callback = callback || function() {};

    // Check for null parameters that have been passed in. We have to intercept this
    // because otherwise the query will fail and an "All connections are unhealty"
    // error will start coming back for each Cassandra query
    for (var p = 0; p < parameters.length; p++) {
        if (parameters[p] === null || parameters[p] === undefined) {
            _logCustomError('Invalid cassandra query specified.', {'query': query, 'parameters': parameters});
            return callback({'code': 400, 'msg': 'An incorrect query has been attempted.'});
        }
    }

    // copy the parameters if they were specified so we can log on them if there is an error.
    var logParams = parameters ? parameters.slice(0) : null;
    pool.cql(query, parameters, function(err, results) {
        if (err) {
            log().error({
                'err': err,
                'query': query,
                'parameters': logParams
            }, 'An error occurred executing a cassandra query.');
            return callback({'code': 500, 'msg': 'An error occurred executing a query'});
        }

        log().trace({
            query: query,
            parameters: logParams,
            rows: results
        }, 'Executed cassandra query.');

        callback(null, results);
    });
};

/**
 * Describes the keyspace identified by 'keyspace'.
 *
 * @param  {String}     keyspace            The keyspace to describe
 * @param  {Function}   callback            Standard callback method
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Object}     callback.definition The keyspace definition. If null, then the keyspace does not exist.
 * @api private
 */
var _describeKeyspace = function(keyspace, callback) {
    pool.getConnection()._client.describe_keyspace(keyspace, function(err, definition) {
        if (err && err.name) {
            if (err.name === 'NotFoundException') {
                callback();
            } else {
                log().error({'err': err}, 'Error while describing cassandra keyspace.');
                callback({'code': 500, 'msg': 'Error while describing cassandra keyspace'});
            }
        } else {
            callback(null, definition);
        }
    });
};

/**
 * Close and re-open the cassandra connection pool.
 *
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 * @api private
 */
var _reloadPool = function(callback) {
    close(function() {
        // Initialize the pooled connections immediately.
        pool = _createPool(CONFIG);
        pool.connect(function(err) {
            if (err) {
                log().error({'err': err}, 'Error reloading cassandra pool');
                return callback({'code': 500, 'msg': 'Error reloading cassandra pool'});
            }

            return callback();
        });
    });
};

/**
 * Create a cassandra connection pool.
 *
 * @api private
 */
var _createPool = function(config) {
    var _pool = new Helenus.ConnectionPool(config);
    _pool.on('error', function(err) {
        log().error({err: err}, 'Error emmitted from the connection pool');
    });
    return _pool;
};

/**
 * Create a CQL "USING" clause with the given consistency and ttl.
 *
 * @param  {String}     [consistency]   The consistency value of the USING clause
 * @param  {Number}     [ttl]           The ttl of the USING clause
 * @return {String}                     A "USING" clause as per CQL syntax with a space before it, but no space after. If all parameters are unspecified, will simply return an empty string.
 * @api private
 */
var _createUsingClause = function(consistency, ttl) {
    var usingClauses = [];

    if (consistency) {
        usingClauses.push('CONSISTENCY ' + consistency);
    }

    if (ttl) {
        usingClauses.push('TTL ' + ttl);
    }

    // If we have at least one, return the using clause. The join will properly split them by ' AND ', as per CQL syntax.
    if (usingClauses.length > 0) {
        return ' USING ' + usingClauses.join(' AND ');
    }

    return '';
};

/**
 * Log a custom error with a stack trace so it can be diagnosed in the logs.
 *
 * @param  {String}     msg     The message of the error
 * @param  {Object}     data    Error data to log in the message. Any `err` key on this object will be overridden by the custom error.
 * @api private
 */
var _logCustomError = function(msg, data) {
    data = data || {};
    data.err = new Error(msg);
    log().error(data, msg);
};
