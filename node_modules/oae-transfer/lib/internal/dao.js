/*!
 * Copyright 2017 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var Async = require('async');
var CodeGenerator = require('password-generator');
var ShortId = require('shortid');
var util = require('util');

var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var Cassandra = require('oae-util/lib/cassandra');
var ContentConstants = require('oae-content/lib/constants').ContentConstants;
var ContentDAO = require('oae-content/lib/internal/dao.content');
var DiscussionsConstants = require('oae-discussions/lib/constants').DiscussionsConstants;
var DiscussionsDAO = require('oae-discussions/lib/internal/dao');
var FoldersConstants = require('oae-folders/lib/constants').FoldersConstants;
var FoldersDAO = require('oae-folders/lib/internal/dao');
var GroupAPI = require('oae-principals/lib/api.group');
var LibraryAPI = require('oae-library'); 
var MeetingsConstants = require('oae-jitsi/lib/constants').MeetingsConstants;
var MeetingsDAO = require('oae-jitsi/lib/internal/dao');
var PrincipalsAPI = require('oae-principals/lib/api.user');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');

var TransferByEmail = require('oae-transfer/lib/model').TransferByEmail;


/** 
 * PUBLIC FUNCTIONS 
 */

/**
 * Create a new transfer and return it
 *
 * @param  {Object}         ctx                     Context
 * @param  {String}         originalUserId            Id user origin
 * @param  {String}         originalEmail             Email origin
 * @param  {String}         targetEmail             Email target
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {transfer}       callback.transfer       The transfer that was created
 */
var createTransfer = module.exports.createTransfer = function (ctx, originalUserId, originalEmail, targetEmail, callback) { 
    var code = _createTransferCode();
    var finalLifetime = 0;
    // Number of seconds in a day
    var secondInDay = 86400;

    // Initialize life time of the transfer
    _getLifeTimeTransfer(ctx, function (err, lifetime) {
        if (err) {
            return callback(err);
        }
        finalLifetime = lifetime * secondInDay;

        // Create transfer
        Cassandra.runQuery('INSERT INTO "TransferById" ("originalUserId", "code", "originalEmail", "targetEmail") VALUES (?, ?, ?, ?) USING TTL ?', [originalUserId, code, originalEmail, targetEmail, finalLifetime], function(err) {
            if (err) {
                return callback(err);
            }
            Cassandra.runQuery('INSERT INTO "TransferByEmail" ("originalEmail", "code", "originalUserId", "targetEmail") VALUES (?, ?, ?, ?) USING TTL ?', [originalEmail, code, originalUserId, targetEmail, finalLifetime], function(err) {
                if (err) {
                    return callback(err);
                }

                // Return transfer
                getTransferById(originalUserId, function (err, transfer) {
                    if (err) {
                        return callback(err);
                    }
                    return callback(null, transfer);
                });
            });
        });
    });
};

/**
 * Start the transfer.
 *
 * @param  {String}         originalEmail                 Email origin
 * @param  {String}         code                        Code generated by a fonction 
 * @param  {String}         targetEmail                 Email target
 * @param  {String}         targetUserId                Id user target
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error that occurred, if any
 * @param  {members}        callback.members            All the members of user resource
 */
 var makeTransfer = module.exports.makeTransfer = function (ctx, originalEmail, code, targetEmail, targetUserId, callback) {

    // Find transfer
    getTransferByEmail(originalEmail, code, function(err, transfer) {
        if (err) {
            return callback(err);
        }

        if (transfer.code !== code) {
            var err = {'code': 400, 'msg': 'Code doesn\'t match'};
            return callback(err);
        } 

        if (transfer.targetEmail !== targetEmail) {
            var err = {'code': 400, 'msg': 'Emails doesn\'t match'};
            return callback(err);
        }

        // If is the correct code make transfer
        _makeTransfer(ctx, originalEmail, code, targetEmail, targetUserId, transfer, function(err, members) {
            if (err) {
                return callback(err);
            }
            return callback(null, members);
        });
    });
};

/**
 * Get a transfer data by an id.
 *
 * @param  {String}         id                      The id of the user who created the transfer
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {transfer}       callback.transfer       User's transfer
 */
var getTransferById = module.exports.getTransferById = function (id, callback) {
    if (_.isEmpty(id)) {
        return callback(null, []);
    }

    Cassandra.runQuery('SELECT * FROM "TransferById" WHERE "originalUserId" = ?', [id], function(err, transfer) {
        if (err) {
            return callback(err);
        }

        if (_.isEmpty(transfer[0])) {
            var err = {'code': 404, 'msg': 'Transfer not found'};
            return callback(err);
        }
        return callback(null, transfer[0]);
    });
};

/**
 * Get a transfer data by an email and a code.
 *
 * @param  {String}         email                   Email of user connected
 * @param  {String}         code                    The transfer code
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {transfer}       callback.transfer       User's transfer
 */
var getTransferByEmail = module.exports.getTransferByEmail = function (originalEmail, code, callback) {
    if (_.isEmpty(code) || _.isEmpty(originalEmail)) {
        return callback(null);
    }

    Cassandra.runQuery('SELECT * FROM "TransferByEmail" WHERE "originalEmail" = ? AND "code" = ?', [originalEmail, code], function(err, transfer) {
        if (err) {
            return callback(err);
        }

        if (_.isEmpty(transfer[0])) {
            var err = {'code': 404, 'msg': 'Transfer not found'};
            return callback(err);
        }
        return callback(null, transfer[0]);
    });
};

/**
 * Delete a transfer data by an email.
 *
 * @param  {String}         code                    The transfer code
 * @param  {String}         originalEmail           Email of user connected
 * @param  {String}         originalUserId          The id of the user who created the transfer
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 */
var deleteTransfer = module.exports.deleteTransfer = function (originalEmail, code, originalUserId, callback) {
    if (_.isEmpty(originalEmail)) {
        return callback(null);
    }
    Cassandra.runQuery('DELETE FROM "TransferByEmail" WHERE "originalEmail" = ? AND "code" = ?', [originalEmail, code], function(err, result) {
        if (err) {
            return callback(err);
        }
        Cassandra.runQuery('DELETE FROM "TransferById" WHERE "originalUserId" = ?', [originalUserId], function(err, result) {
            if (err) {
                return callback(err);
            } 
            return callback(null);
        });
    });
};

/**
 * get recorded transfer.
 *
 * @param  {String}         originalUserId          Id of the original user
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 */
var getRecordedTransfer = module.exports.getRecordedTransfer = function (originalUserId, callback) {
    // Get the recorded transfer
    Cassandra.runQuery('SELECT * FROM "RecordedTransfer" WHERE "originalUserId" = ?', [originalUserId], function (err, recordedTransfer) {
        if (err) {
            return callback(err);
        } 
        return callback(null, recordedTransfer);
    });
};

/**
 * PRIVATE FUNCTIONS
 */

/**
 * Start the transfer.
 *
 * @param  {String}         originalEmail                 Email origin
 * @param  {String}         code                        Code generated by a fonction 
 * @param  {String}         targetEmail                 Email target
 * @param  {String}         targetUserId                Id user target
 * @param  {Object}         transfer                    Transfer
 *
 * @returns array members
 * @api private used to make the transter
 */
var _makeTransfer = function(ctx, originalEmail, code, targetEmail, targetUserId, transfer, callback) {

    // Get AuthzRoles 
    Cassandra.runQuery('SELECT * FROM "AuthzRoles" WHERE "principalId" = ?', [transfer.originalUserId], function(err, authzRoles) {
        if (err) {
            return callback(err);
        }

        // If there is no data to transfer, cancel it
        if (_.isEmpty(authzRoles)) {
            err = {'code': 400, 'msg': 'The user has no roles to transfer'};
            return callback(err);
        }

        // Create queries to insert and delete authzRoles and authzMembers
        _transferRoles(ctx, authzRoles, targetUserId, transfer.originalUserId, function(err, newAuthzRoles) {
            if (err) {
                return callback(err);
            }

            // Delete the transfer in the table "Transfer"
            deleteTransfer(originalEmail, code, transfer.originalUserId, function (err) {
                if (err) {
                    return callback(err);
                }

                // Record the transfer
                _recordTransfer(originalEmail, transfer.originalUserId, targetEmail, targetUserId, function (err, recordedTransfer) {
                    if (err) {
                        return callback(err);
                    }
                    if (!recordedTransfer) {
                        return callback({'code': 400, 'msg': 'A problem happened recording the transfer'});
                    }

                    if (_.isEmpty(newAuthzRoles)) {
                        // return callback
                        return callback(null); 
                    } else {

                        // Get id originalEmail
                        PrincipalsDAO.getUserIdsByEmails([originalEmail], function(err, principalIdOrigin) {
                            if (err) {
                                return callback(err);
                            } 

                            // Found all members related to this resource and put then into "members" 
                            _getMembers(ctx, newAuthzRoles, targetUserId, principalIdOrigin, function (err, members) {
                                if (err) {
                                    return callback(err);
                                } 
                                // return managers to send emails
                                return callback(null, members); 
                            });
                        }); 
                    }
                });
            });
        }); 
    });
 };

/**
 * Record the transfer.
 *
 * @param  {String}         originalEmail               Email of original user
 * @param  {String}         originalUserId              Id of original user
 * @param  {String}         targetEmail                 Email of target user
 * @param  {String}         targetUserId                Id of target user
 *
 * @returns recorded transfer
 * @api private used to record a transter
 */
var _recordTransfer = function(originalEmail, originalUserId, targetEmail, targetUserId, callback) {

    // Insert into the table the recorded transfer
    Cassandra.runQuery('INSERT INTO "RecordedTransfer" ("originalEmail", "originalUserId", "targetEmail", "targetUserId") VALUES (?, ?, ?, ?)', [originalEmail, originalUserId, targetEmail, targetUserId], function(err) {
        if (err) {
            return callback(err);
        }

        // Return transfer
        getRecordedTransfer(originalUserId, function (err, recordedTransfer) {
            if (err) {
                return callback(err);
            }
            return callback(null, recordedTransfer);
        });
    });
};

/**
 * Update roles and Get array of roles modified
 * 
 * @param {Array}       authzRoles
 * @param {String}      targetUserId
 * @param {String}      originalUserId
 * @param {Function}    callback                
 * @param {Array}       _userHashes
 *
 * @returns array of roles modified
 * @api private used to make the transter
 */
var _transferRoles = function(ctx, authzRoles, targetUserId, originalUserId, callback, _userHashes) {

    _userHashes = _userHashes || []
    
    // If no more authzroles, return list of modified roles
    if (_.isEmpty(authzRoles)) {
        return callback(null, _userHashes);
    }

    var authzRole = authzRoles.shift();
    var memberToUpdate = {};
    var newAuthzRoles = {};
    memberToUpdate[targetUserId] = authzRole.role;
    memberToUpdate[originalUserId] = false;

    _doUpdate(authzRole, targetUserId, originalUserId, function (err, doUpdate) {
        if (err) {
            return callback(err);
        }

        if(doUpdate) {

            // Update target user's role && remove origin user's role
            AuthzAPI.updateRoles(authzRole.resourceId, memberToUpdate, function(err, usersToInvalidate) {
                if (err) {
                    return callback(err);
                }

                // Insert to library
                _transferResourceLibrary(ctx, authzRole.resourceId, targetUserId, originalUserId, function (err, result) {
                    if (err) {
                        return callback(err);
                    }
                    newAuthzRoles['resourceId'] = authzRole.resourceId;
                    newAuthzRoles['role'] = authzRole.role;
                    newAuthzRoles['principalId'] = targetUserId;
                    _userHashes.push(newAuthzRoles);

                    return _transferRoles(ctx, authzRoles, targetUserId, originalUserId, callback, _userHashes);
                });
            });
        } else {
            return _transferRoles(ctx, authzRoles, targetUserId, originalUserId, callback, _userHashes);
        }
    });
};

/**
 * Look at the right of target and origin to make a decision about the transfer. 
 * If both have rights on the document and if the target user have better roles on it, we don't gonna change the right
 * 
 * @param {Object} hash
 * @param {String} targetUserId
 * @param {String} originalUserId
 *
 * @returns boolean
 * @api private used to make the transter
 */
var _doUpdate = function(hash, targetUserId, originalUserId, callback) {
    var originRole = 0;
    var targetRole = 0;
    AuthzAPI.getAuthzMembers(hash.resourceId, null, null, function(err, members) {
        if (err) {
            return callback(err);
        }

        var userOriginRole = _.find(members, function(obj) {
          return obj.id == originalUserId;
        });

        var userTargetRole = _.find(members, function(obj) {
          return obj.id == targetUserId;
        });

        if (!userTargetRole) {
            return callback(null, true);
        }

        if(userTargetRole.role === AuthzConstants.role.MANAGER) {
            targetRole = 1;
        } else if(userTargetRole.role === AuthzConstants.role.MEMBER) {
            targetRole = 2;
        } else if(userTargetRole.role === AuthzConstants.role.EDITOR) {
            targetRole = 3;
        } else if(userTargetRole.role === AuthzConstants.role.VIEWER) {
            targetRole = 4;
        } else {
            targetRole = 5;
        }
        if(userOriginRole.role === AuthzConstants.role.MANAGER) {
            originRole = 1;
        } else if(userOriginRole.role === AuthzConstants.role.MEMBER) {
            originRole = 2;
        } else if(userOriginRole.role === AuthzConstants.role.EDITOR) {
            originRole = 3;
        } else if(userOriginRole.role === AuthzConstants.role.VIEWER) {
            originRole = 4;
        } else {
            originRole = 5;
        }

        if(targetRole <= originRole) {
            return callback(null, false);
        } else {
            return callback(null, true);
        }
    });                     
};

/**
 * Generate a new 20 caracters code
 * 
 * @returns transferCode
 * @api private
 */
var _createTransferCode = function() {
    // parametters : length, memorable, pattern, prefix
    return CodeGenerator(20, false);
};

/**
 * Get managers from authzroles
 * 
 * @param {Object}  ctx
 * @param {Array}   authzRoles
 * @param {String}  targetUserId
 * @param {String}  principalIdOrigin
 *
 * @returns managers
 * @api private
 */
var _getMembers = function (ctx, authzRoleHashes, targetUserId, principalIdOrigin, callback, listMembers) {

    var listMembers = listMembers || [];
    // Return when there are no more folder in the array
    if (!authzRoleHashes || _.isEmpty(authzRoleHashes)) {
        return callback(null, listMembers);
    } 
    var hash = authzRoleHashes.shift();

    // Found all members related to this resource and put then into 'members'
    AuthzAPI.getAuthzMembers(hash.resourceId, null, null, function(err, members) {
        if (err) {
            return callback(err);
        }

        Async.eachSeries(members, function(res, callback) {

            // Get the user
            Cassandra.runQuery('SELECT * FROM "Principals" WHERE "principalId" = ?', [res.id], function (err, member) {
                if (err) {
                    return callback(err);
                } 

                // Get resource
                _getDocument(ctx, hash.resourceId, function (err, element) {
                    if (err) {
                        return callback(err);
                    }
                    
                    if (res.id !== targetUserId) {
                        member = _.chain(member).map(Cassandra.rowToHash)._wrapped[0];
                        listMembers.push([{'profile': member}, {'resource': element}]);
                    }
                    callback();
                }); 
            });
        }, function(err) {
            if (err) {
              return callback(err);
            }
            return _getMembers(ctx, authzRoleHashes, targetUserId, principalIdOrigin, callback, listMembers);
        });
    });   
};

/**
 * Get the name of the resource by it's id 
 * take advantage of the differentiation of data type to modify the library
 * 
 * @param {Object} ctx
 * @param {String} idResource
 * @param {String} principalId
 * @param {String} principalIdOrigin
 *
 * @returns nothing
 * @api private
 */
var _transferResourceLibrary = function (ctx, resourceId, principaltargetUserId, principalIdOrigin, callback) {

    // Get resource
    _getDocument(ctx, resourceId, function (err, resource) {
        if (err) {
            return callback(err);
        }

        var resourceType = resource.id.split(':')[0];
        
        var constant = '';

        // If the resource is a Content
        if (resourceType === 'c') {     
            constant = ContentConstants.library.CONTENT_LIBRARY_INDEX_NAME;
        // If the resource is a Folder
        } else if (resourceType === 'f') {
            constant = FoldersConstants.library.FOLDERS_LIBRARY_INDEX_NAME;
        // If the resource is a Discussion
        } else if (resourceType === 'd') {
            constant = DiscussionsConstants.library.DISCUSSIONS_LIBRARY_INDEX_NAME;
        // If the resource is a Discussion
        } else if (resourceType === 'm') {
            constant = MeetingsConstants.library.MEETINGS_LIBRARY_INDEX_NAME;
        }

        // Insert to library 
        _insertOnLibrary(resource, principaltargetUserId, constant, function(err) {
            if (err) {
                return callback(err);
            }

            // Remove to library 
            _removeFromLibrary(resource, principalIdOrigin, constant, function(err) {
                if (err) {
                    return callback(err);
                }
                return callback(null);                
            }); 
        }); 
    }); 
};

/**
 * Get the name of the resource by it's id 
 * take advantage of the differentiation of data type to modify the library
 * 
 * @param {Object} ctx
 * @param {String} idResource
 *
 * @returns resource
 * @api private
 */
var _getDocument = function (ctx, idResource, callback) {
    var resourceType = idResource.split(':')[0];

    // If the resource is a Content
    if (resourceType === 'c') {     
        ContentDAO.getContent(idResource, function(err, result) {
            if (err) {
                return callback(err);
            }
            return callback(null, result);        
        });

    // If the resource is a Folder
    } else if (resourceType === 'g') {
        _getFoldersByGroupIds(ctx, idResource, function(err, result) {
            if (err) {
                return callback(err);
            }
            return callback(null, result);                
        }); 

    // If the resource is a Discussion
    } else if (resourceType === 'd') {
        DiscussionsDAO.getDiscussion(idResource, function(err, result) {
            if (err) {
                return callback(err);
            }
            return callback(null, result);                
        }); 

    // If the resource is a Meeting
    } else if (resourceType === 'm') {
        MeetingsDAO.getMeeting(idResource, function(err, result) {
            if (err) {
                return callback(err);
            }
            return callback(null, result);                
        }); 
    }
};

/**
 * Get folder by group id
 * 
 * @param {Object} ctx
 * @param {String} idResource
 *
 * @returns folder
 * @api private
 */
 var _getFoldersByGroupIds = function (ctx, idResource, callback) {
    Cassandra.runQuery('SELECT * FROM "FoldersGroupId" WHERE "groupId" = ?', [idResource], function(err, result) {

        // The resource is a groupe if there is no result to this query
        if (_.isEmpty(result)) {
            GroupAPI.getGroup(ctx, idResource, function(err, group) {
                if (err) {
                    return callback(err);
                }
                return callback(null, group);
            });
        } else {
            FoldersDAO.getFolder(result[0].folderId, function(err, folder) {
                if (err) {
                    return callback(err);
                }
                return callback(null, folder);
            });
        }
    });
};

/**
 * Get the life timetransfer.
 *
 * @param  {Object}         ctx                     Context to determine the life time of a transfer code
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Error
 */
var _getLifeTimeTransfer = function (ctx, callback) {
    if (_.isEmpty(ctx)) {
        return callback(null);
    }

    var defaultTime = 1;
    var configkey = 'oae-transfer/lifetime/value';

    Cassandra.runQuery('SELECT "value" FROM "Config" WHERE "tenantAlias" = ? AND "configKey" = ?', [ctx.tenant().alias, configkey], function(err, result) {
        if (err) {
            return callback(err);
        }

        if (_.isEmpty(result)) {
            return callback(null, defaultTime);
            
        } else {
            return callback(null, result[0].value);
        }
    });
};

/**
 * Insert an element to the library.
 *
 * @param  {Object}         obj                     The element to add       
 * @param  {Object}         principalId             The id of userTarget
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Error
 */
var _insertOnLibrary = function(obj, principalId, constant, callback) {
    var entries = [{
        'id': principalId,
        'rank': obj.lastModified,
        'resource': obj
    }];
    LibraryAPI.Index.insert(constant, entries, callback);
};

/**
 * Remove an element to the library.
 *
 * @param  {Object}         obj                     The element to add       
 * @param  {Object}         principalId             The id of userTarget
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Error
 */
var _removeFromLibrary = function(obj, principalId, constant, callback) {
    var entries = [{
        'id': principalId,
        'rank': obj.lastModified,
        'resource': obj
    }];
    LibraryAPI.Index.remove(constant, entries, callback);
};
