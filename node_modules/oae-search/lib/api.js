/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzUtil = require('oae-authz/lib/util');
var FollowingDAO = require('oae-following/lib/internal/dao');
var log = require('oae-logger').logger('oae-search');
var TaskQueue = require('oae-util/lib/taskqueue');
var Telemetry = require('oae-telemetry').telemetry('search');
var Validator = require('oae-util/lib/validator').Validator;

var client = require('./internal/elasticsearch');
var SearchConstants = require('oae-search/lib/constants').SearchConstants;
var SearchResult = require('oae-search/lib/model').SearchResult;
var SearchUtil = require('oae-search/lib/util');

// Holds the currently configured index to which we will perform all requested operations, as per
// the `config.search.index` configuration object in config.js
var index = null;

// Indicates whether or not the search indexing handler has been bound to the task queue
var boundIndexWorkers = false;

var childSearchDocuments = {};
var reindexAllHandlers = {};
var searches = {};
var searchDocumentProducers = {};
var searchDocumentTransformers = {
    /*!
     * A default document transformer that simply returns the stored fields of the document, plus the id.
     * @see registerSearchDocumentTransformer
     */
    '*': function(ctx, docs, callback) {
        var result = _.map(docs, function(doc) {
            return _.extend({}, doc.fields, { 'id': doc['_id'] });
        });
        return callback(null, result);
    }
};

/**
 * Register a transformer with the search API that will transform search documents into a model that can be returned to the
 * UI for the user. There can only be one transformer per resource type. The document transformers are given the search documents
 * after they have been retrieved from ElasticSearch. Once transformed, the final search results are sent back to the client.
 *
 * @param  {String}    typeName                    The type of document this transformer acts upon
 * @param  {Function}  transformer                 The function that will transform an array of search documents into an array of view objects
 * @param  {Context}   transformer.ctx             The context of the currently authenticated user
 * @param  {Object}    transformer.docs            The raw search documents, keyed by document 'id', that were returned in the search
 * @param  {Function}  transformer.callback        The callback function the transformer should execute to indicate it has completed processing
 * @param  {Object}    transformer.callback.err    An error that occurred while transforming the docs, if any
 * @param  {Object}    transformer.callback.docs   The view model, keyed by document _id, that were translated from the hash of search documents
 * @throws {Error}                                 An error that is thrown if there is already a transformer registered for the given type
 */
var registerSearchDocumentTransformer = module.exports.registerSearchDocumentTransformer = function(typeName, transformer) {
    if (searchDocumentTransformers[typeName]) {
        throw new Error('Document transformer for type ' + typeName + ' already exists');
    }
    searchDocumentTransformers[typeName] = transformer;
};

/**
 * Register a producer with the search API that will produce search documents to be added to the search index. There can only be one
 * producer per resource type. When a new indexing task is submitted for a resource that is of `typeName` resource type, then this
 * producer will have an opportunity to produce documents to be indexed.
 *
 * @param  {String}    typeName                The resource type that this indexer indexes
 * @param  {Function}  producer                A function that will produce documents to be indexed
 * @param  {Object[]}  producer.resourceData   An array of objects that represent the data that drives the producer. The format of the actual data object will generally be different for different resource types
 * @param  {Function}  producer.callback       The callback function that should be invoked when the indexer has produced the documents
 * @param  {Object}    producer.callback.err   An error that occurred while creating the documents, if any
 * @param  {Object[]}  producer.callback.docs  The documents to be indexed
 * @throws {Error}                             An error that is thrown if there is already a producer registered for the given type
 */
var registerSearchDocumentProducer = module.exports.registerSearchDocumentProducer = function(typeName, producer) {
    if (searchDocumentProducers[typeName]) {
        throw new Error('Document producer for type ' + typeName + ' already exists');
    }
    searchDocumentProducers[typeName] = producer;
};

/**
 * Register a search with the Search API that will process search input and produce a query to run against elastic search. Once the query
 * is created by the search registered here, the search will be sent to ElasticSearch and and all results will be passed through the
 * document transformers. @see #registerSearchDocumentTransformer for more information.
 *
 * @param  {String}    typeName                            The name of the search. Once registered, this search can be invoked by using this `typeName` in the `search` method.
 * @param  {Function}  queryBuilder                        The search function that will be invoked when a search is performed. This function is responsible for generating a query as per the ElasticSearch Query DSL and returning it in the callback.
 * @param  {Context}   queryBuilder.ctx                    The context of the search being performed
 * @param  {Object}    queryBuilder.opts                   The search opts that are specific to the search
 * @param  {String[]}  [queryBuilder.opts.params]          An array of search parameters that are specific to the search (i.e., for ordered path parameters)
 * @param  {Function}  queryBuilder.callback               The callback function that should be invoked when the search has created the query
 * @param  {Object}    queryBuilder.callback.err           An error that occurred while creating the query. Pass an error parameter to indicate an error occurred, if it was successful, this parameter should be left `null`
 * @param  {Object}    queryBuilder.callback.queryData     The Query DSL object representing the query, as per the ElasticSearch documentation; If not specified, short-circuits the process to return 0 results.
 * @throws {Error}                                         An error that is thrown if there is already a search registered by the given name
 */
var registerSearch = module.exports.registerSearch = function(typeName, queryBuilder) {
    if (searches[typeName]) {
        throw new Error('Search type ' + typeName + ' already exists');
    }
    searches[typeName] = queryBuilder;
};

/**
 * Register a handler for a reindex all operation. When a full re-index has been triggered, this handler will be invoked.
 *
 * @param  {String}     handlerId               The id of the handler invoked
 * @param  {Function}   handler                 The handler function that will be invoked when a full re-index has been triggered
 * @param  {Function}   handler.callback        The callback function that should be invoked when reindexing has been completed
 * @param  {Object}     handler.callback.err    An error that occurred during reindexing, if any
 */
var registerReindexAllHandler = module.exports.registerReindexAllHandler = function(handlerId, handler) {
    if (reindexAllHandlers[handlerId]) {
        throw new Error('Reindex-all handler with id ' + handlerId + ' already exists');
    }
    reindexAllHandlers[handlerId] = handler;
};

/**
 * Create a child search document mapping in the OAE index that is a child of the main resource schema.
 *
 * @param  {String}     name                            The unique name of the document mapping
 * @param  {Object}     options                         The options for the child search document
 * @param  {String[]}   [options.resourceTypes]         A list of resource types for which this producer produces child documents. If unspecified, the producer will be invoked for all resource types
 * @param  {Function}   options.producer                A function that will produce documents to be indexed
 * @param  {Object[]}   options.producer.resourceData   An array of objects that represent the data that drives the producer. The format of the actual data object will generally be different for different resource types
 * @param  {Function}   options.producer.callback       The callback function that should be invoked when the indexer has produced the documents
 * @param  {Object}     options.producer.callback.err   An error that occurred while creating the documents, if any
 * @param  {Object[]}   options.producer.callback.docs  The documents to be indexed
 * @param  {Object}     options.schema                  The elasticsearch mapping object that defines the child search document fields
 * @param  {Function}   [callback]                      Standard callback function, invoked when the child search document mapping has been created
 * @param  {Object}     [callback.err]                  An error that occurred, if any
 */
var registerChildSearchDocument = module.exports.registerChildSearchDocument = function(name, options, callback) {
    if (childSearchDocuments[name]) {
        var err = new Error('Child search document mapping with name "' + name + '" already exists');
        log().error({'err': err, 'name': name}, 'Attempted to register duplicate child search document');
        return callback({'code': 400, 'msg': err.message});
    }

    // Determine the resource types we will support
    var resourceTypes = null;
    if (_.isArray(options.resourceTypes) && !_.isEmpty(options.resourceTypes)) {
        resourceTypes = {};
        _.each(options.resourceTypes, function(resourceType) {
            resourceTypes[resourceType] = true;
        });
    }

    childSearchDocuments[name] = {
        'schema': options.schema,
        'producer': options.producer,
        'resourceTypes': resourceTypes
    };

    // The callback defaults to a function that simply logs the fact that an error occurred
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'An unexpected error occurred while creating a child search document mapping');
        }
    };

    return _createChildSearchDocumentMapping(name, options.schema, callback);
};

/**
 * Refresh the search configuration with the given options.
 *
 * @param  {Object}     searchConfig    The search configuration object, as per `config.js`
 * @param  {Function}   callback        Invoked when configuration has been refreshed
 */
var refreshSearchConfiguration = module.exports.refreshSearchConfiguration = function(searchConfig, callback) {
    index = searchConfig.index;
    var processIndexJobs = (searchConfig.processIndexJobs !== false);

    client.refreshSearchConfiguration(index.name, {'hosts': searchConfig.hosts});

    if (processIndexJobs && !boundIndexWorkers) {
        boundIndexWorkers = true;
        TaskQueue.bind(SearchConstants.mq.TASK_INDEX_DOCUMENT, _handleIndexDocumentTask, null, function() {
            TaskQueue.bind(SearchConstants.mq.TASK_DELETE_DOCUMENT, _handleDeleteDocumentTask, null, function() {
                return TaskQueue.bind(SearchConstants.mq.TASK_REINDEX_ALL, _handleReindexAllTask, null, callback);
            });
        });
    } else if (!processIndexJobs && boundIndexWorkers) {
        boundIndexWorkers = false;
        TaskQueue.unbind(SearchConstants.mq.TASK_INDEX_DOCUMENT, function() {
            TaskQueue.unbind(SearchConstants.mq.TASK_DELETE_DOCUMENT, function() {
                return TaskQueue.unbind(SearchConstants.mq.TASK_REINDEX_ALL, callback);
            });
        });
    } else {
        // If we get here, there was no state change in handling indexing, so we don't need to do anything.
        return callback();
    }
};

/**
 * Build the search index to use for indexing and searching documents. If `destroy` is `true`, the current index and all its
 * data will be destroyed. This will leave an empty search index that needs to be reindexed!
 *
 * @param  {Boolean}    [destroy]       Whether or not to first destroy / delete the index before rebuilding. Default: `false`
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var buildIndex = module.exports.buildIndex = function(destroy, callback) {
    _ensureIndex(index.name, index.settings, destroy, function(err) {
        if (err) {
            return callback(err);
        }

        // Create the resource document mapping
        return _ensureSearchSchema(callback);
    });
};

/**
 * Perform a search of a given type.
 *
 * @param  {Context}        ctx                 The current context of the request
 * @param  {String}         searchType          The type of search to perform (e.g., 'general')
 * @param  {Object}         opts                A hash describing the search parameters
 * @param  {String[]}       [opts.pathParams]   An array of path parameters for the search. The requirements of the path parameters are specific to the type of search being performed
 * @param  {String}         [opts.q]            A full-text search query to apply to search with
 * @param  {Number}         [opts.limit]        The maximum number of search documents to return
 * @param  {Number}         [opts.start]        The document index from which to start
 * @param  {String}         [opts.sort]         The direction to sort the results. One of 'asc' or 'desc'
 * @param  {Function}       callback            Invoked when the process completes
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Object}         callback.result     The search result object
 */
var search = module.exports.search = function(ctx, searchType, opts, callback) {
    var registeredSearch = searches[searchType];
    if (!registeredSearch) {
        return callback({'code': 400, 'msg': 'Search "' + searchType + '" is not a valid search type.'});
    }

    // Invoke the search plugin to get the query object
    registeredSearch(ctx, opts, function(err, queryData) {
        if (err) {
            return callback(err);
        } else if (!queryData) {
            return callback(null, new SearchResult(0, []));
        }

        // Query only the document fields in the index, and not the _source and others
        queryData.fields = '*';

        // Perform the search with the query data
        client.search(queryData, null, function(err, elasticSearchResponse) {
            if (err) {
                log().error({'err': err}, 'An unexpected error occurred performing a search');
                return callback({'code': 500, 'msg': 'An unexpected error occurred performing the search'});
            }

            // We pull the '_extra' field out and parse it into JSON
            var hits = elasticSearchResponse.hits.hits;
            for (var i = 0; i < hits.length; i++) {
                var hit = hits[i];
                if (hit.fields._extra) {
                    try {
                        hit.fields._extra = JSON.parse(hit.fields._extra);
                    } catch (parseErr) {
                        log().warn({'err': parseErr, 'hit': hit}, 'Failed to parse _extra field of search document into JSON. Ignoring.');
                    }
                }
            }

            SearchUtil.transformSearchResults(ctx, searchDocumentTransformers, elasticSearchResponse, function(err, transformedResults) {
                if (err) {
                    return callback(err);
                }

                // Scrub the _extra field from all results
                _.each(transformedResults.results, function(doc) {
                    delete doc._extra;
                });

                return callback(null, transformedResults);
            });
        });
    });
};

/**
 * Submits a task that will re-index all search documents in storage. This task is permission protected to
 * the global admin user as the impact of reindexing all documents can stress the system.
 *
 * @param  {Context}    ctx             The processing context in which the reindexAll task was executed
 * @param  {Function}   callback        Invoked when the task has been submitted. Note that actual reindexing will happen asynchronously despite this callback
 * @param  {Object}     callback.err    An error that occurred while invoking the task, if any
 */
var postReindexAllTask = module.exports.postReindexAllTask = function(ctx, callback) {
    if (!ctx.user() || !ctx.user().isGlobalAdmin()) {
        return callback({'code': 401, 'msg': 'Only global administrator can trigger a full reindex.'});
    }

    TaskQueue.submit(SearchConstants.mq.TASK_REINDEX_ALL, null, callback);
};

/**
 * Submits a task that will index the specified set of resource and child documents.
 *
 * @param  {String}             resourceType        The resource type of all resources specified in each of the index tasks
 * @param  {Object[]}           resources           The resources to use to produce the search documents to index
 * @param  {Object}             resources[i].id     The id of the resource. This is the only required parameter of the resource object, but there can be more depending on what data is needed by the associated document producers
 * @param  {Object}             index               Specifies what aspects of the resource should be indexed
 * @param  {Boolean}            [index.resource]    Specifies if the main resource document should be indexed. Default: `false`
 * @param  {Object|Boolean}     [index.children]    If `true`, will reindex all known child document types for this resource type. If an object, each key specifies which child document types should produce documents for this index task. If unspecified, no children will be reindexed
 * @param  {Function}           [callback]          Standard callback function, invoked when the task has been submit
 * @param  {Object}             [callback.err]      An error that occurred, if any
 */
var postIndexTask = module.exports.postIndexTask = function(resourceType, resources, index, callback) {
    var validator = new Validator();
    validator.check(resourceType, {'code': 400, 'msg': 'Must specify a resource type'}).notEmpty();
    validator.check(null, {'code': 400, 'msg': '"resources" parameter must be an array'}).isArray(resources);
    validator.check(null, {'code': 400, 'msg': '"index" parameter must be an object'}).isObject(index);
    validator.check(resources.length, {'code': 400, 'msg': '"resources" parameter must be an array with one or more entries'}).min(1);
    _.each(resources, function(resource) {
        validator.check(resource.id, {'code': 400, 'msg': 'Each index resource must have an id'}).notEmpty();
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    return TaskQueue.submit(SearchConstants.mq.TASK_INDEX_DOCUMENT, {'resourceType': resourceType, 'resources': resources, 'index': index}, callback);
};

/**
 * Submits a task that will delete a search document with the specified id
 *
 * @param  {Object}     id              The id of the parent resource document to delete
 * @param  {Object}     children        An object whose key is the child document type, and values are an array of string document ids of children to delete
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var postDeleteTask = module.exports.postDeleteTask = function(id, children, callback) {
    return TaskQueue.submit(SearchConstants.mq.TASK_DELETE_DOCUMENT, {'id': id, 'children': children}, callback);
};

/**
 * Ensure that the index identified by the index name exists.
 *
 * @param  {String}     indexName               The name of the index
 * @param  {Object}     indexSettings           The settings of the index
 * @param  {Object[]}   indexSettings.hosts     An array of hosts (e.g., `[{ "host": "localhost", "port": 9200 }]`) to use
 * @param  {Boolean}    destroy                 If true, the index will be destroyed if it exists, then recreated
 * @param  {Function}   callback                Invoked when the process completes
 * @param  {Object}     callback.err            An error that occurred, if any
 * @api private
 */
var _ensureIndex = function(indexName, indexSettings, destroy, callback) {
    if (destroy) {
        log().info('Destroying index "%s"', indexName);
        client.deleteIndex(indexName, function(err) {
            if (err) {
                return callback(err);
            }

            client.createIndex(indexName, indexSettings, function(err) {
                if (err) {
                    log().error({'err': err}, 'Error recreating index "%s" after deletion.', indexName);
                    return callback(err);
                }

                log().info('Recreated index "%s" after deletion', indexName);
                return callback();
            });
        });
    } else {
        client.createIndex(indexName, indexSettings, function(err) {
            if (err) {
                log().error({'err': err}, 'Error creating index "%s"', indexName);
                return callback(err);
            }

            return callback();
        });
    }
};

/**
 * Ensure the OAE search schema is created.
 *
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 * @api private
 */
var _ensureSearchSchema = function(callback, _names) {
    if (!_names) {
        return client.putMapping(SearchConstants.search.MAPPING_RESOURCE, require('./schema/resourceSchema'), {'_source': false}, function(err) {
            if (err) {
                return callback(err);
            }

            return _ensureSearchSchema(callback, _.keys(childSearchDocuments));
        });
    } else if (_.isEmpty(_names)) {
        return callback();
    }

    var name = _names.shift();
    return _createChildSearchDocumentMapping(name, childSearchDocuments[name].schema, function(err) {
        if (err) {
            return callback(err);
        }

        // Recursively create the next child document schema mapping
        return _ensureSearchSchema(callback, _names);
    });
};

/**
 * Create a search document mapping that is a child of the resource search document mapping.
 *
 * @param  {String}     name            The name of the search document mapping
 * @param  {Object}     schema          The schema object, as per the elasticsearch mapping schema
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 * @api private
 */
var _createChildSearchDocumentMapping = function(name, schema, callback) {
    /*!
     * The below elastic search options mean:
     *
     *  * `_source: false` indicates that the _source field is disabled for the mapping, saving disk space as it is not needed
     *  * `_parent: ...` establishes a parent-child relationship from the resource document to its child documents
     *
     * For more information, please see the elasticsearch mapping documentation:
     * http://www.elasticsearch.org/guide/reference/mapping/
     */
    var opts = {
        '_source': false,
        '_parent': SearchConstants.search.MAPPING_RESOURCE
    };

    client.putMapping(name, schema, opts, callback);
};

/**
 * When bound to an TaskQueue reindex-all task, this method will reindex all resource in the search engine.
 *
 * @param  {Object}     data            The task data
 * @param  {Function}   callback        Invoked when all re-indexing has completed
 * @param  {Object}     callback.err    An error that occurred during re-indexing, if any
 * @api private
 */
var _handleReindexAllTask = function(data, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'data': data}, 'Error handling reindex-all task.');
        }
    };

    var numToProcess = _.keys(reindexAllHandlers).length;
    if (numToProcess === 0) {
        // No handlers for reindexing, nothing to do
        return callback();
    }

    // Invoke all handlers and return to the caller when they have all completed (or we get an error)
    var complete = false;
    _.each(reindexAllHandlers, function(handler, handlerId) {
        handler(function(err) {
            if (complete) {
                // Do nothing, we've already returned to the caller
                return;
            } else if (err) {
                complete = true;
                return callback(err);
            }

            numToProcess--;
            if (numToProcess === 0) {
                log().info({'handlers': _.keys(reindexAllHandlers)}, 'Finished submitting all items for re-indexing');
                complete = true;
                return callback();
            }
        });
    });
};

/**
 * When bound to an TaskQueue delete document task, this method will delete the resource from the search engine.
 *
 * @param  {Object}     data                The task data
 * @param  {String}     [data.id]           The id of the document to delete
 * @param  {Object}     [data.children]     An object keyed by `documentType`, whose value is an array of strings specifying the ids of individual child documents to be deleted from the search index
 * @param  {Function}   callback            Invoked when indexing has completed
 * @param  {Object}     callback.err        An error that occurred, if any
 * @api private
 */
var _handleDeleteDocumentTask = function(data, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'data': data}, 'Error handling search document delete task.');
        }
    };

    var deletes = [];

    // If there is a top-level resource specified, we delete its document and all known children
    if (data.id) {

        // Delete the resource with the provided id
        deletes.push({
            'deleteType': 'id',
            'documentType': SearchConstants.search.MAPPING_RESOURCE,
            'id': data.id
        });

        // Delete all child documents whose parent is the provided resource
        _.each(childSearchDocuments, function(options, documentType) {
            deletes.push({
                'deleteType': 'query',
                'documentType': documentType,
                'query': {
                    'has_parent': {
                        'parent_type': SearchConstants.search.MAPPING_RESOURCE,
                        'query': {
                            'ids': {
                                'values': [data.id]
                            }
                        }
                    }
                }
            });
        });
    }

    // For each specified sets of children document ids, delete them
    if (data.children) {
        _.each(data.children, function(ids, documentType) {
            _.each(ids, function(id) {
                deletes.push({
                    'deleteType': 'id',
                    'documentType': documentType,
                    'id': id
                });
            });
        });
    }

    // Delete the resource document, plus all its children and any requested children
    return _deleteAll(deletes, callback);
};

/**
 * Perform all delete operations
 *
 * @param  {Object[]}   deletes                     The delete operations to perform
 * @param  {String}     deletes[i].deleteType       The type of delete to perform, either "id" or "query"
 * @param  {String}     deletes[i].documentType     The type of document this should be applied to. Only documents of this type will be deleted
 * @param  {String}     [deletes[i].id]             The id of the document to delete, only relevant if this is a delete operation of type "id"
 * @param  {Object}     [deletes[i].query]          The query that matches the documents to delete. Only relevant if this is a delete operation of type "query"
 * @param  {Function}   callback                    Standard callback function
 * @api private
 */
var _deleteAll = function(deletes, callback) {
    if (_.isEmpty(deletes)) {
        return callback();
    }

    var del = deletes.shift();

    /*!
     * Invoke the _deleteAll method recursively when the requested delete operation has been
     * performed
     *
     * @param  {Object}     err     An error that occurred, if any
     */
    var _handleDocumentsDeleted = function(err) {
        if (err) {
            log().error({'err': err, 'operation': del}, 'Error deleting a document from the search index');
        }

        return _deleteAll(deletes, callback);
    };

    // Perform the appropriate delete operations
    if (del.deleteType === 'id') {
        return client.del(del.documentType, del.id, _handleDocumentsDeleted);
    } else if (del.deleteType === 'query') {
        return client.deleteByQuery(del.documentType, del.query, null, _handleDocumentsDeleted);
    }
};

/**
 * When bound to am TaskQueue index document task, this method will index the resource document(s) as described by the
 * task data.
 *
 * @param  {Object}             data            The task data. See SearchAPI#postIndexTask for more information
 * @param  {Function}           callback        Standard callback function
 * @param  {Object}             callback.err    An error that occurred, if any
 * @api private
 */
var _handleIndexDocumentTask = function(data, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'data': data}, 'Error handling search indexing task.');
        }
    };

    log().trace({'data': data}, 'Received index document task');

    var resourcesToIndex = {};
    var resourceChildrenToIndex = {};
    _.each(data.resources, function(resource) {
        data.index = data.index || {};
        data.index.children = data.index.children || {};

        // If the children property is set to boolean true, it indicates all known child documents for this
        // resource type should be indexed for the resource
        if (data.index.children === true) {
            data.index.children = {};
            _.each(childSearchDocuments, function(options, documentType) {
                // Only include this child if it is specified to be a child of this resource type
                if (!options.resourceTypes || options.resourceTypes[data.resourceType]) {
                    data.index.children[documentType] = true;
                }
            });
        }

        // Keep track of all core resource documents that need to be indexed
        if (data.index.resource) {
            resourcesToIndex[data.resourceType] = resourcesToIndex[data.resourceType] || [];
            resourcesToIndex[data.resourceType].push(resource);
        }

        // Keep track of all child documents that need to be indexed
        _.chain(data.index.children).keys().each(function(documentType) {
            resourceChildrenToIndex[documentType] = resourceChildrenToIndex[documentType] || [];
            resourceChildrenToIndex[documentType].push(resource);
        });
    });

    _produceAllResourceDocuments(resourcesToIndex, function(err, resourceDocs) {
        if (err) {
            return callback(err);
        }

        log().trace({'data': data, 'resourceDocs': resourceDocs}, 'Produced top-level resource docs');

        _produceAllChildDocuments(resourceChildrenToIndex, function(err, childResourceDocs) {
            if (err) {
                return callback(err);
            }

            log().trace({'data': data, 'childResourceDocs': childResourceDocs}, 'Produced child resource docs');

            var allDocs = _.union(resourceDocs, childResourceDocs);
            if (_.isEmpty(allDocs)) {
                return callback();
            } else if (allDocs.length > 1) {
                var ops = SearchUtil.createBulkIndexOperations(allDocs);
                client.bulk(ops, function(err) {
                    if (err) {
                        log().error({'err': err, 'ops': ops}, 'Error indexing %s documents', allDocs.length);
                    } else {
                        log().debug('Successfully indexed %s documents', allDocs.length);
                    }

                    return callback(err);
                });
            } else {
                var doc = allDocs[0];
                var id = doc.id;
                var opts = {};

                if (doc['_parent']) {
                    opts.parent = doc['_parent'];
                }

                // These properties go in the request metadata, not the actual document
                delete doc.id;
                delete doc['_parent'];

                client.index(doc['_type'], id, doc, opts, function(err) {
                    if (err) {
                        log().error({'err': err, 'id': id, 'doc': doc, 'opts': opts}, 'Error indexing a document');
                    } else {
                        log().debug('Successfully indexed a document');
                    }

                    return callback(err);
                });
            }
        });
    });
};

/**
 * Produce all resource search documents defined within `resourcesToIndex`
 *
 * @param  {Object}     resourcesToIndex        An object of form {resourceType -> resources}, containing the resources to produce for indexing
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Object[]}   callback.documents      The resource search documents that were produced
 * @api private
 */
var _produceAllResourceDocuments = function(resourcesToIndex, callback, _resourceTypes, _documents) {
    _resourceTypes = _resourceTypes || _.keys(resourcesToIndex);
    _documents = _documents || [];
    if (_.isEmpty(_resourceTypes)) {
        return callback(null, _documents);
    }

    // Select the next resourceType from the list whose documents to produce
    var resourceType = _resourceTypes.shift();
    var searchDocumentProducer = searchDocumentProducers[resourceType];
    if (searchDocumentProducer) {
        searchDocumentProducer(resourcesToIndex[resourceType], function(err, documents) {
            if (err) {
                log().error({'err': err, 'resources': resourcesToIndex[resourceType]}, 'Error producing search documents from resources');
                return callback(err);
            }

            documents = _.map(documents, function(doc) {
                var newDoc = _.extend({}, doc, {'_type': SearchConstants.search.MAPPING_RESOURCE, 'resourceType': resourceType});
                if (newDoc['_extra']) {
                    newDoc['_extra'] = JSON.stringify(newDoc['_extra']);
                }

                log().trace({'before': doc, 'after': newDoc}, 'Converted resource document');
                return newDoc;
            });

            // Union current documents with the ones we just produced and continue recursively
            _documents = _.union(_documents, documents);
            return _produceAllResourceDocuments(resourcesToIndex, callback, _resourceTypes, _documents);
        });
    } else {
        log().warn('Ignoring %s documents of type "%s", which do not have an associated document producer', resourcesToIndex[resourceType].length, resourceType);
        return _produceAllResourceDocuments(resourcesToIndex, callback, _resourceTypes, _documents);
    }
};

/**
 * Produce all resource child search documents defined within `resourceChildrenToIndex`
 *
 * @param  {Object}     resourceChildrenToIndex     An object of form {documentType -> resources}, containing the resources whose children should be produced for indexing
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error that occurred, if any
 * @param  {Object[]}   callback.documents          The resource child search documents that were produced
 * @api private
 */
var _produceAllChildDocuments = function(resourceChildrenToIndex, callback, _documentTypes, _documents) {
    _documentTypes = _documentTypes || _.keys(resourceChildrenToIndex);
    _documents = _documents || [];
    if (_.isEmpty(_documentTypes)) {
        return callback(null, _documents);
    }

    // Select the next documentType from the list whose child documents to produce
    var documentType = _documentTypes.shift();
    var childSearchDocumentProducer = childSearchDocuments[documentType].producer;
    if (childSearchDocumentProducer) {
        childSearchDocumentProducer(resourceChildrenToIndex[documentType], function(err, documents) {
            if (err) {
                log().error({'err': err, 'resources': resourceChildrenToIndex[documentType]}, 'Error producing child search documents from resources');
                return callback(err);
            }

            _documents = _.union(_documents, documents);
            return _produceAllChildDocuments(resourceChildrenToIndex, callback, _documentTypes, _documents);
        });
    } else {
        log().warn('Ignoring %s documents of type "%s", which do not have an associated child document producer', resourceChildrenToIndex[documentType].length, documentType);
        return _produceAllResourceDocuments(resourceChildrenToIndex, callback, _documentTypes, _documents);
    }
};
