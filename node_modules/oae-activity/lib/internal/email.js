/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var TZ = require('oae-util/lib/tz');
var util = require('util');

var AuthzUtil = require('oae-authz/lib/util');
var Context = require('oae-context').Context;
var EmailAPI = require('oae-email');
var Locking = require('oae-util/lib/locking');
var log = require('oae-logger').logger('oae-activity-email');
var PrincipalsAPI = require('oae-principals');
var PrincipalsConfig = require('oae-config').config('oae-principals');
var PrincipalsConstants = require('oae-principals/lib/constants').PrincipalsConstants;
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var Redis = require('oae-util/lib/redis');
var Telemetry = require('oae-telemetry').telemetry('activity-email');
var TenantsAPI = require('oae-tenants');
var TenantsUtil = require('oae-tenants/lib/util');
var UIAPI = require('oae-ui');

var ActivityAggregator = require('./aggregator');
var ActivityBuckets = require('./buckets');
var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;
var ActivityDAO = require('./dao');
var ActivityEmitter = require('./emitter');
var ActivityModel = require('oae-activity/lib/model');
var ActivityRegistry = require('./registry');
var ActivitySystemConfig = require('./config');
var ActivityTransformer = require('./transformer');
var ActivityUtil = require('oae-activity/lib/util');

// The maximum amount of users can be handled during a bucket collection
var MAX_COLLECTION_BATCH_SIZE = 50;

/*!
 * When activities get delivered to a stream, we check if any were delivered to an
 * `email` stream and queue them for email delivery.
 */
ActivityEmitter.on(ActivityConstants.events.DELIVERED_ACTIVITIES, function(deliveredActivities) {
    var usersToMail = _.chain(deliveredActivities).keys().filter(function(activityStreamId) {
        // Filter out any non-email route
        return (deliveredActivities[activityStreamId].streamType === ActivityConstants.streams.EMAIL);
    }).map(function(activityStreamId) {
        // Return the user ID
        return deliveredActivities[activityStreamId].resourceId;
    }).uniq().value();

    // If there were no activities delivered in email streams we can stop here
    if (_.isEmpty(usersToMail)) {
        return;
    }

    // We need to know the email preferences for each user so we know whether and when to send them an e-mail
    PrincipalsDAO.getPrincipals(usersToMail, ['principalId', 'tenantAlias', 'email', 'emailPreference'], function(err, users) {
        if (err) {
            return log().error({'err': err, 'usersToMail': usersToMail}, 'Failed to get the email preference field for all the users in this activity');
        }

        var usersToQueue = _.filter(users, function(user) {
            // Users without a valid email address or who've opted out of email notifications should not get emails
            return (user.email && user.emailPreference !== PrincipalsConstants.emailPreferences.NEVER);
        });

        var emailBuckets = {};
        _.each(usersToQueue, function(user) {
            var bucketId = _createEmailBucketIdForUser(user);
            emailBuckets[bucketId] = emailBuckets[bucketId] || [];
            emailBuckets[bucketId].push(user.id);
        });

        ActivityDAO.saveQueuedUserIdsForEmail(emailBuckets, function(err) {
            if (err) {
                log().error({'err': err, 'deliveredActivities': deliveredActivities}, 'Unable to store the IDs of the users who need to receive mail');
            }

            log().trace({'usersToQueue': usersToQueue}, 'Queued mail for users');
            Telemetry.incr('queued.count', usersToQueue.length);
        });
    });
});


/////////////////
// UPDATE-USER //
/////////////////

/*!
 * When a user changes his email preferences we re-queue him in the correct email bucket
 */
PrincipalsAPI.on(PrincipalsConstants.events.UPDATED_USER, function(ctx, newUser, oldUser) {
    // If the user's email preference didn't change we don't have to do anything
    if (newUser.emailPreference === oldUser.emailPreference) {
        return ActivityEmitter.emit(ActivityConstants.events.UPDATED_USER, ctx, newUser, oldUser);
    }

    // Take the user out of the old bucket
    var oldBucketId = _createEmailBucketIdForUser(oldUser);
    ActivityDAO.unqueueUsersForEmail(oldBucketId, [oldUser.id], function(err) {
        if (err) {
            return log().error({'err': err, 'user': oldUser.id}, 'Unable to unqueue a user from an email bucket when they changed their email preference');
        } else if (newUser.emailPreference === PrincipalsConstants.emailPreferences.NEVER) {
            // The user has opted out of email delivery
            return ActivityEmitter.emit(ActivityConstants.events.UPDATED_USER, ctx, newUser, oldUser);
        }

        // Queue the user with his new email preference. If he has no pending emails,
        // he will be ignored during the collection cycle
        var newBucketId = _createEmailBucketIdForUser(newUser);
        var emailBucket = {};
        emailBucket[newBucketId] = [newUser.id];
        ActivityDAO.saveQueuedUserIdsForEmail(emailBucket, function(err) {
            if (err) {
                log().error({'err': err, 'user': newUser.id}, 'Could not re-queue the user for email');
            }

            return ActivityEmitter.emit(ActivityConstants.events.UPDATED_USER, ctx, newUser, oldUser);
        });
    });
});


///////////////////////
// Bucket collection //
///////////////////////


/**
 * Perform a full collection of all email buckets. If any bucket is already locked by another process, it will be skipped. When
 * this process completes and the callback is invoked, it will guarantee that:
 *
 * a) This process was not allowed to start another collection cycle, as there were too many occuring; or
 * b) for every bucket that wasn't locked, it was collected until it was empty.
 *
 * This function is most useful for unit tests to ensure that all emails up until a point in time have been aggregated and delivered.
 *
 * @param  {Function}   [callback]      Invoked when collection is complete
 * @param  {Object}     [callback.err]  An error that occurred, if any
 */
var collectAllBuckets = module.exports.collectAllBuckets = function(callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Failed to collect all mail buckets');
        }
    };

    var errs = [];
    var count = 0;
    var allDone = function(err) {
        if (err) {
            errs.push(err);
        }

        count++;
        if (count === 3) {
            return callback(errs[0]);
        }
    };

    var numberOfBuckets = ActivitySystemConfig.getConfig().numberOfProcessingBuckets;
    var maxConcurrentCollections = ActivitySystemConfig.getConfig().maxConcurrentCollections;
    var collectionExpiry = ActivitySystemConfig.getConfig().collectionExpiry;
    ActivityBuckets.collectAllBuckets('email:immediate', numberOfBuckets, maxConcurrentCollections, collectionExpiry, _collectImmediateBucket, allDone);
    ActivityBuckets.collectAllBuckets('email:daily', numberOfBuckets, maxConcurrentCollections, collectionExpiry, _collectDailyBucket, allDone);
    ActivityBuckets.collectAllBuckets('email:weekly', numberOfBuckets, maxConcurrentCollections, collectionExpiry, _collectWeeklyBucket, allDone);
};

/**
 * Collect all the mails that are queued for immediate delivery
 *
 * @param  {Number}     bucketNumber        The bucket to process
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.finished   Indicates that this bucket is drained or has been skipped in which case it should not be retried either
 * @api private
 */
var _collectImmediateBucket = function(bucketNumber, callback) {
    collectMails(bucketNumber, PrincipalsConstants.emailPreferences.IMMEDIATE, null, null, callback);
};

/**
 * Collect all the mails that are queued for daily delivery
 *
 * @param  {Number}     bucketNumber        The bucket to process
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.finished   Indicates that this bucket is drained or has been skipped in which case it should not be retried either
 * @api private
 */
var _collectDailyBucket = function(bucketNumber, callback) {
    if (_isDailyCycle()) {
        var now = new TZ.Date('UTC');
        return collectMails(bucketNumber, PrincipalsConstants.emailPreferences.DAILY, null, now.getHours() + 1, callback);
    } else {
        return callback(null, true);
    }
};

/**
 * Collect all the mails that are queued for weekly delivery
 *
 * @param  {Number}     bucketNumber        The bucket to process
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.finished   Indicates that this bucket is drained or has been skipped in which case it should not be retried either
 * @api private
 */
var _collectWeeklyBucket = function(bucketNumber, callback) {
    if (_isWeeklyCycle()) {
        var now = new TZ.Date('UTC');
        return collectMails(bucketNumber, PrincipalsConstants.emailPreferences.WEEKLY, now.getDay(), now.getHours() + 1, callback);
    } else {
        return callback(null, true);
    }
};

/**
 * Check whether daily aggregate mails should be sent out now
 *
 * @return {Boolean}    Whether or not daily mails should be sent out now
 * @api private
 */
var _isDailyCycle = function() {
    var config = ActivitySystemConfig.getConfig();
    var now = new TZ.Date('UTC');

    // The date when the *next* mail cycle start
    var end = new TZ.Date(now.getTime() + (config.mail.pollingFrequency * 1000), 'UTC');

    // As daily mails go out on the hour, every hour, all we need to do is
    // check if the hour rolls over in this collection cycle
    return (now.getHours() !== end.getHours());
};

/**
 * Check whether weekly aggregate mails should be sent out now
 *
 * @return {Boolean}    Whether or not weekly mails should be sent out now
 * @api private
 */
var _isWeeklyCycle = function() {
    var config = ActivitySystemConfig.getConfig();
    var now = new TZ.Date('UTC');
    var today = now.getDay();

    // Due to timezones, weekly mails can be sent out a day before, on the configured day or the next day
    if (today === ((config.mail.weekly.day + 6) % 7) || today === config.mail.weekly.day || today === ((config.mail.weekly.day + 1) % 7)) {
        // The date when the *next* mail cycle start
        var end = new TZ.Date(now.getTime() + (config.mail.pollingFrequency * 1000), 'UTC');

        // As weekly mails go out on the hour, every hour (on the configured day), all we need to do is
        // check if the hour rolls over in this collection cycle
        return (now.getHours() !== end.getHours());
    } else {
        return false;
    }
};

/**
 * Drain an e-mail bucket by sending the correct e-mail to everybody whose in it.
 *
 * Steps:
 *   1.  Get all the users whom we need to mail in this iteration
 *   2.  Stop aggregating for those user's their email activity streams
 *   3.  Unqueue the users from the email bucket
 *   4.  Collect all the activities from those streams
 *   5.  Remove the activities from those streams as they are no longer required
 *   6.  Send mail
 *
 * Note that this function is only exported for testing purposes. You should use `collectAllBuckets`
 * as this method will *NOT* perform any locking on the processed bucket.
 *
 * @param  {Number}     bucketNumber        The bucket to process
 * @param  {String}     emailPreference     Which bucket type the users should be retrieved from. One of {@see PrincipalsConstants.emailPreferences}
 * @param  {Number}     [dayOfWeek]         What day of the week the email should be delivered. Only required for WEEKLY emails
 * @param  {Number}     [hour]              What hour the email should be delivered. Only required for WEEKLY and DAILY emails
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.finished   Indicates that this bucket is drained or has been skipped in which case it should not be retried either
 * @param  {User[]}     callback.users      The users that received an email
 */
var collectMails = module.exports.collectMails = function(bucketNumber, emailPreference, dayOfWeek, hour, callback) {
    var collectionStart = Date.now();
    log().trace('Collecting batch of %s users from bucket number %s:%s.', MAX_COLLECTION_BATCH_SIZE, bucketNumber, emailPreference);

    // 1. Get a set of users for whom we need to mail in this iteration
    var bucketId = _createEmailBucketId(bucketNumber, emailPreference, dayOfWeek, hour);
    ActivityDAO.getQueuedUserIdsForEmail(bucketId, null, MAX_COLLECTION_BATCH_SIZE, function(err, bucketId, userIds, nextToken) {
        if (err) {
            return callback(err);
        } else if (_.isEmpty(userIds)) {
            return callback(null, true, []);
        }

        // 2. Reset aggregation for the email streams for the queued, so that the next e-mail doesn't contain the same activities
        var activityStreamIds = _.map(userIds, function(userId) {
            return ActivityUtil.createActivityStreamId(userId, ActivityConstants.streams.EMAIL);
        });
        ActivityDAO.resetAggregationForActivityStreams(activityStreamIds, function(err) {
            if (err) {
                return callback(err);
            }

            // 3. Remove the users from the buckets
            ActivityDAO.unqueueUsersForEmail(bucketId, userIds, function(err) {
                if (err) {
                    return callback(err);
                }

                // 4. Get all the activities that should be included in the emails
                ActivityDAO.getActivitiesFromStreams(activityStreamIds, function(err, activitiesPerStream) {
                    if (err) {
                        return callback(err);
                    }

                    // 5. Delete these activities as we will be pushing them out
                    var activitiesPerStreamToDelete = {};
                    _.each(activitiesPerStream, function(activities, activityStreamId) {
                        activitiesPerStreamToDelete[activityStreamId] = _.pluck(activities, ActivityConstants.properties.OAE_ACTIVITY_ID);
                    });
                    ActivityDAO.deleteActivities(activitiesPerStreamToDelete, function(err) {
                        if (err) {
                            return callback(err);
                        }

                        // Get all the user profiles
                        PrincipalsDAO.getPrincipals(userIds, null, function(err, users) {
                            if (err) {
                                log().error({'err': err, 'userIds': userIds}, 'Failed to get the users when sending email');
                                return callback(err);
                            }

                            // Keep track of whom we need to email
                            var usersToMail = _.filter(users, function(user) {
                                // Although it's very unlikely that a user who changed his email preferences would end up here,
                                // we take it into account as it would be really unfortunate to send him any further email. Additionally,
                                // if the email stream for the user was empty (because he marked his notifications as read), we can't send
                                // him any mail either
                                var emailActivityStreamId = ActivityUtil.createActivityStreamId(user.id, ActivityConstants.streams.EMAIL);
                                return (user.emailPreference !== PrincipalsConstants.emailPreferences.NEVER && !_.isEmpty(activitiesPerStream[emailActivityStreamId]));
                            });

                            // Transform the users array so the activities are included
                            var toMail = _.map(usersToMail, function(user) {
                                var emailActivityStreamId = ActivityUtil.createActivityStreamId(user.id, ActivityConstants.streams.EMAIL);
                                return {'user': user, 'activities': activitiesPerStream[emailActivityStreamId]};
                            });

                            // 6. Send out the emails
                            _mailAll(toMail, function(err) {
                                if (err) {
                                    return callback(err);
                                }

                                Telemetry.incr(util.format('sent.%s.count', emailPreference), toMail.length);
                                Telemetry.appendDuration(util.format('sent.%s.time', emailPreference), collectionStart);

                                return callback(null, false, usersToMail);
                            });
                        });
                    });
                });
            });
        });
    });
};

/**
 * Mails a set of users
 *
 * @param  {Object[]}   toMail          An object containing the `user` and the `activities` they should receive
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 * @api private
 */
var _mailAll = function(toMail, callback) {
    if (_.isEmpty(toMail)) {
        return callback();
    }

    var to = toMail.pop();
    _mail(to.user, to.activities, function(err) {
        if (err) {
            return callback(err);
        }

        return _mailAll(toMail, callback);
    });
};

/**
 * Send a mail to a user
 *
 * @param  {User}           user            The user to mail
 * @param  {Activity[]}     activities      The set of activities that should go in the mail
 * @param  {Function}       callback        Standard callback function
 * @param  {Object}         callback.err    An error that occurred, if any
 * @api private
 */
var _mail = function(user, activities, callback) {
    // Given that we support weekly deliveries, there is a possibility that there are 2 activities
    // present in the activity stream that could aggregate
    var aggregatedActivities = _aggregate(user.id, activities);

    // Transform the activities in the activity streams format so we can pass it on to the adapter
    var tenant = TenantsAPI.getTenant(user.tenant.alias);
    var ctx = new Context(tenant, user);
    ActivityTransformer.transformActivities(ctx, aggregatedActivities, ActivityConstants.transformerTypes.ACTIVITYSTREAMS, function(err) {
        if (err) {
            log().error({'err': err}, 'Could not transform activities for mail');
            return callback(err);
        }

        // Transform the activities in a simple model that the templates can use to generate the email
        var ActivityAdapter = UIAPI.getActivityAdapter();
        var adaptedActivities = ActivityAdapter.adapt(user, aggregatedActivities);

        // Generate a unique fingerprint for this mail so we don't accidentally send it out multiple times
        // We cannot use the activityId as each activity gets a new ID when routed and/or aggregated
        // See https://github.com/oaeproject/Hilary/pull/759 for more information
        var emailHash = util.format('%s#', user.id);
        _.each(aggregatedActivities, function(activity) {
            emailHash += util.format('%s:%s#', activity[ActivityConstants.properties.OAE_ACTIVITY_TYPE], activity.published);
        });

        // Construct the data that needs to go into the email template
        var data = {
            'activities': adaptedActivities,
            'tenant': tenant,
            'user': user,
            'baseUrl': TenantsUtil.getBaseUrl(tenant),
            'skinVariables': UIAPI.getTenantSkinVariables(tenant.alias)
        };
        return EmailAPI.sendEmail('oae-activity', 'mail', user, data, {'hash': emailHash}, callback);
    });
};

/**
 * Aggregate those activities that can be aggregated in the set of passed in activities. Aggregation happens
 * regardless of the time that sits between two activities.
 *
 * @param  {String}         userId          The ID of the user for which these activities are intended
 * @param  {Activity[]}     activities      The set of activities to aggregate
 * @return {Activity[]}                     The aggregated activities
 * @private
 */
var _aggregate = function(userId, activities) {
    // Unroll the `activities` so it does not contain any aggregates
    var unrolledActivities = _unrollActivities(activities);

    // Convert the set of unrolled activities into a set of "routed activities"
    // so we can generate the aggregates for it
    var routedActivities = _.map(unrolledActivities, function(activity) {
        return {
            'route': userId,
            'activity': activity
        };
    });

    // Re-aggregate everything
    var aggregates = ActivityAggregator.createAggregates(routedActivities);

    var aggregatedActivityIds = [];
    var aggregatedActivities = [];

    // Pass 1: Select all the multi-aggregates and push them into the aggregated activities set
    _.each(aggregates, function(aggregate, aggregateKey) {
        if (aggregate.activityIds.length > 1) {
            _.each(aggregate.activityIds, function(aggregatedActivityId) {
                aggregatedActivityIds.push(aggregatedActivityId);
            });

            aggregatedActivities.push(_createActivityFromAggregate(aggregate));
        }
    });

    // Pass 2: Select all the single-aggregates, filter out those that are consumed in a multi-aggregate and push the remainder in the aggregated activities set
    _.each(aggregates, function(aggregate, aggregateKey) {
        if (aggregate.activityIds.length === 1 && !_.contains(aggregatedActivityIds, aggregate.activityIds[0])) {
            aggregatedActivities.push(_createActivityFromAggregate(aggregate));
            aggregatedActivityIds.push(aggregate.activityIds[0]);
        }
    });

    // Return an array of activities sorted in time
    return aggregatedActivities.sort(function(a, b) {
        return b.published - a.published;
    });
};

/**
 * Given an aggregate, return a proper activity
 *
 * @param  {ActivityAggregate}  aggregate   An aggregate containing a single or multiple activities
 * @return {Activity}                       The activity object
 * @api private
 */
var _createActivityFromAggregate = function(aggregate) {
    var actor = ActivityAggregator.createActivityEntity(_.values(aggregate.actors));
    var object = ActivityAggregator.createActivityEntity(_.values(aggregate.objects));
    var target = ActivityAggregator.createActivityEntity(_.values(aggregate.targets));
    return new ActivityModel.Activity(aggregate[ActivityConstants.properties.OAE_ACTIVITY_TYPE], aggregate.activityIds[0], aggregate.verb, aggregate.published, actor, object, target);
};

/**
 * Unroll a set of activities by expanding aggregated activities into separate distinct
 * aggregates. Note that the unrolled activities will probably *NOT* match the activity
 * from before aggregation.
 *
 * @param  {Activity[]}     aggregatedActivities    A set of activities that contain possible aggregates
 * @return {Activity[]}                             The expanded activities that do not contain aggregates
 * @api private
 */
var _unrollActivities = function(aggregatedActivities) {
    var activities = [];
    _.each(aggregatedActivities, function(activity) {
        var actorEntities = _getEntities(activity.actor);
        var objectEntities = _getEntities(activity.object);
        var targetEntities = _getEntities(activity.target);

        // If the activity contains at most 1 entity for the actor, object and target entities, it
        // hasn't aggregated with other activities, which means we don't have to unroll anything
        if (actorEntities.length <= 1 && objectEntities.length <= 1 && targetEntities.length <= 1) {
            activities.push(activity);
            return;
        }

        // This activity has aggregated with another activity so one (or more) entities are collections
        // that need to be unrolled
        var actor = null;
        var object = null;
        var target = null;
        while (!_.isEmpty(actorEntities) || !_.isEmpty(objectEntities) || !_.isEmpty(targetEntities)) {
            actor = actorEntities.pop() || actor;
            object = objectEntities.pop() || object;
            target = targetEntities.pop() || target;

            var newActivity = new ActivityModel.Activity(activity[ActivityConstants.properties.OAE_ACTIVITY_TYPE], activity[ActivityConstants.properties.OAE_ACTIVITY_ID], activity.verb, activity.published, actor, object, target);
            activities.push(newActivity);
        }
    });
    return activities;
};

/**
 * Get the set of entities for a given `actor`, `object` or `target` entity. If the entity
 * is null an empty array will be returned. If there's only a single entity available, an
 * array with that single value in it will be returned.
 *
 * @param  {Object}             entity      The entity to return. Either an `ActivityEntity` or an `oae:collection` of `ActivityEntity` objects
 * @return {ActivityEntity[]}               An array of `ActivityEntity` objects
 * @api private
 */
var _getEntities = function(entity) {
    if (!entity) {
        return [];
    } else if (entity.objectType !== 'collection') {
        return [entity];
    } else {
        return entity[ActivityConstants.properties.OAE_COLLECTION];
    }
};

/**
 * Given a user, return the approriate email bucket ID
 *
 * @param  {User}       user    The user object for which to generate an email bucket id
 * @return {String}             The ID of the email bucket that this user should go in
 * @api private
 */
var _createEmailBucketIdForUser = function(user) {
    var timezone = PrincipalsConfig.getValue(user.tenant.alias, 'user', 'timezone');
    var bucketNumber = _getBucketNumber(user.id);

    // Gets filled up in case the user wants a weekly or daily mail
    var hour = null;
    var dayOfWeek = null;

    // Anything else than immediate delivery needs to be scheduled appropriately
    if (user.emailPreference !== PrincipalsConstants.emailPreferences.IMMEDIATE) {
        /*!
         * Take the given timezone into account for daily and/or weekly mails. We try to deliver an e-mail
         * at the configured hour in the given timezone. In order to do this we need the timezone offset
         * between the given timezone and UTC as buckets are always handled in UTC.
         *
         * For example, the given timezone is Miami (UTC-5) and mail needs to be delivered at 13h. The mail
         * needs to leave the server at 18h (UTC time) so it arrives when it's 13h in Miami.
         *
         * For weekly emails, it's entirely possible we need to schedule email delivery on the previous/next day.
         * For example, the given timezone is Islamabad (UTC+5) and mails need to be delivered at 2am. The mail
         * needs to leave the server at 21h (UTC time) so it arrives when it's 2am in Islamabad
         */
        var mailConfig = ActivitySystemConfig.getConfig().mail;

        // Get the offset between the timezone and UTC in hours. `getTimezoneOffset` returns the offset in minutes,
        // which we can ceil as we can be a bit flexible about when the email arrives. `getTimezoneOffset` returns
        // the offset against *UTC*. This is fine as email collection always works with UTC timezones
        var offsetInHours = Math.ceil(new TZ.Date(timezone).getTimezoneOffset() / 60);

        // Add (or subtract) the offset, if the result is a negative hour, we'll need to send out the email on the day
        // before the configured day, if it's 24 or higher we'll need to send it a day later
        hour = mailConfig[user.emailPreference].hour - offsetInHours;
        if (hour < 0) {
            // Rather than doing -1, we do +6 as Javascript can't handle negative modulos
            dayOfWeek = (mailConfig.weekly.day + 6) % 7;
        } else if (hour >= 24) {
            dayOfWeek = (mailConfig.weekly.day + 1) % 7;
        } else {
            dayOfWeek = mailConfig.weekly.day;
        }

        // Ensure that we're dealing with valid 24-hour values. Because Javascript can't handle negative modulos
        // and we might've added a negative offset, we add an extra 24 hours to guarantee a positive result
        hour = (24 + hour) % 24;
    }

    return _createEmailBucketId(bucketNumber, user.emailPreference, dayOfWeek, hour);
};

/**
 * Given a bucket number, an email preference and an hour, return the appropriate email bucket
 *
 * @param  {String}     bucketNumber        The email bucket number
 * @param  {String}     emailPreference     The email preference. One of {@see PrincipalsConstants.emailPreferences}
 * @param  {Number}     [dayOfWeek]         What day of the week the email should be delivered. Only required for WEEKLY emails
 * @param  {Number}     [hour]              What hour the email should be delivered. Only required for WEEKLY and DAILY emails
 * @return {String}                         The ID of the email bucket that this user should go in
 * @api private
 */
var _createEmailBucketId = function(bucketNumber, emailPreference, dayOfWeek, hour) {
    if (emailPreference === PrincipalsConstants.emailPreferences.IMMEDIATE) {
        return util.format('oae-activity-email:%s:%s', bucketNumber, emailPreference);
    } else if (emailPreference === PrincipalsConstants.emailPreferences.DAILY) {
        return util.format('oae-activity-email:%s:%s:%d', bucketNumber, emailPreference, hour);
    } else if (emailPreference === PrincipalsConstants.emailPreferences.WEEKLY) {
        return util.format('oae-activity-email:%s:%s:%d:%d', bucketNumber, emailPreference, dayOfWeek, hour);
    }
};

/**
 * Given a user ID, return an appropriate bucket number
 *
 * @param  {String}     userId  The ID of the user for whom to retrieve the email bucket number
 * @return {String}             The email bucket number
 * @api private
 */
var _getBucketNumber = function(userId) {
    var numberOfBuckets = ActivitySystemConfig.getConfig().numberOfProcessingBuckets;
    return ActivityBuckets.getBucketNumber(userId, numberOfBuckets);
};
