/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var config = null;

// Will hold all the counts.
var stats = {
    'counts': {},
    'histograms': {}
};

/**
 * Make the current telemetry configuration available to the telemetry API.
 *
 * @param  {Object}     _config     Config object containing config values for telemetry
 */
var setTelemetryConfig = module.exports.setTelemetryConfig = function(_config) {
    config = _config;
};

/**
 * Publishers can use this method to get to the raw data.
 *
 * @return {Object}     The captured telemetry data.
 */
var getTelemetryData = module.exports.getTelemetryData = function() {
    return stats;
};

/**
 * Resets all telemetry data.
 *
 * @param  {String}     module      The name of the module for which the telemtry should be reset
 */
var reset = module.exports.reset = function(module) {
    if (module) {
        delete stats.counts[module];
        delete stats.histograms[module];
    }
};

/**
 * Allows other modules to perform telemetry tasks.
 * ex:
 *
 *     var Telemetry = require('oae-telemetry').telemetry('cassandra');
 *         Telemetry.incr('write');
 *
 * @param  {String} module The module.
 */
var telemetry = module.exports.telemetry = function(module) {
    return new Telemetry(module);
};

/**
 * The Telemetry object.
 *
 * @param  {String} module A module to namespace counts in.
 * @api private
 */
var Telemetry = function(module) {
    // Set the counters/histograms if they are empty.
    stats.counts[module] = stats.counts[module] || {};
    stats.histograms[module] = stats.histograms[module] || {};

    // Expose some functionality.
    var that = {};

    /**
     * Increment the count for this Telemetry item.
     *
     * @param  {String} name    The name of the item to increment
     * @param  {Number} [count] If specified, the metric will be incremented this many times. Defaults to 1
     */
    that.incr = function(name, count) {
        count = count || 1;
        if (!stats.counts[module][name]) {
            stats.counts[module][name] = 0;
        }
        stats.counts[module][name] += count;
    };

    /**
     * Adds a value that is suitable for histogram parsing.
     *
     * @param  {String}  name    The name to append a value on.
     * @param  {Number}  value   The value that should be added.
     */
    that.append = function(name, value) {
        if (!stats.histograms[module][name]) {
            stats.histograms[module][name] = [];
        }
        stats.histograms[module][name].push(value);
    };

    /**
     * Appends a timing value for histogram parsing that is a duration (in ms) from the provided `from` time.
     *
     * @param  {String}  name    The name to append the timing value on
     * @param  {Number}  from    The millis from which the duration should be based.
     */
    that.appendDuration = function(name, from) {
        that.append(name, _duration(from));
    };

    return that;
};


// The telemetry object that will be used to time requests.
var serverTelemetry = telemetry('server');

/**
 * This method can be used by middleware to count and/or time requests.
 * The property `telemetryUrl` on the request object will be checked to
 * see if any timing/count should occur. If null or undefined only the counter
 * for the total number of requests of that particular HTTP method will be increased.
 * If it is defined (by an API endpoint), his method will:
 *  * increase the amount of requests for that URI by 1.
 *  * increase the amount of requests for that HTTP method by 1.
 *  * measure the time it took for a response to be generated.
 *
 * @param  {Request}    req     The request.
 * @param  {Response}   res     The response
 */
module.exports.request = function(req, res) {
    if (config.enabled) {
        // Increase the amount of `method` requests.
        serverTelemetry.incr(req.method);

        // Do some time measuring.
        var start = Date.now();
        res.on('header', function(header){
            if (req.telemetryUrl) {
                // Increase the amount of requests against this API.
                serverTelemetry.incr(req.method + '.' + req.telemetryUrl + '.count');

                // Measure the response time
                serverTelemetry.append(req.method + '.' +  req.telemetryUrl + '.time', _duration(start));
            }
        });
    }
};


/**
 * Get the duration (in ms) that has expired from the `from` millis.
 *
 * @param  {Number} from   The number of milliseconds to substract from the current time.
 * @return {Number}        How many milliseconds have elapsed since the `from` time until now.
 * @api private
 */
var _duration = function(from) {
    return Date.now() - from;
};
