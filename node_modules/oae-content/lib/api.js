/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var fs = require('fs');
var mime = require('mime');
var path = require('path');
var ShortId = require('shortid');
var util = require('util');

var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzInvitations = require('oae-authz/lib/invitations');
var AuthzPermissions = require('oae-authz/lib/permissions');
var AuthzUtil = require('oae-authz/lib/util');
var Config = require('oae-config').config('oae-content');
var Context = require('oae-context').Context;
var EmitterAPI = require('oae-emitter');
var LibraryAPI = require('oae-library');
var log = require('oae-logger').logger('oae-content');
var MessageBoxAPI = require('oae-messagebox');
var MessageBoxConstants = require('oae-messagebox/lib/constants').MessageBoxConstants;
var OaeUtil = require('oae-util/lib/util');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var PrincipalsUtil = require('oae-principals/lib/util');
var ResourceActions = require('oae-resource/lib/actions');
var Signature = require('oae-util/lib/signature');
var TenantsUtil = require('oae-tenants/lib/util');
var Validator = require('oae-util/lib/validator').Validator;

var Content = require('./model').Content;
var ContentConstants = require('./constants').ContentConstants;
var ContentDAO = require('./internal/dao');
var ContentMembersLibrary = require('./internal/membersLibrary');
var ContentUtil = require('./internal/util');
var Etherpad = require('./internal/etherpad');
var Revision = require('./model').Revision;

/**
 * ### Events
 *
 * The `ContentAPI`, as enumerated in `ContentConstants.events`, emits the following events:
 *
 * * `createdComment(ctx, comment, content)`: A new comment was posted for a content item. The `ctx`, `comment` and commented `content` object are provided.
 * * `createdContent(ctx, content)`: A new content item was created. The `ctx` and the `content` object that was created are both provided.
 * * `deletedComment(ctx, comment, content, deleteType)`: An existing comment has been deleted on a content item. The `ctx`, `content` and target `comment` object are provided.
 * * `deletedContent(ctx, contentObj, members)`: A content item was deleted. The 'ctx', the deleted 'contentObj' and the list of authz principals that had this content item in their library
 * * `downloadedContent(ctx, content, revision)`: A content item was downloaded. The `ctx`, `content` and the `revision` are all provided.
 * * `editedCollabdoc(ctx, contentObj)`: A collaborative document was edited by a user without resulting in a new revision. This happens if the revision-creation was already triggered by another user leaving the document
 * * `getContentLibrary(ctx, principalId, visibility, start, limit, contentObjects)`: A content library was retrieved.
 * * `getContentProfile(ctx, content)`: A content profile was retrieved. The `ctx` and the `content` are both provided.
 * * `restoredContent(ctx, newContentObj, oldContentObj, restoredRevision)`: An older revision for a content item has been restored.
 * * `updatedContent(ctx, newContentObj, oldContentObj)`: A content item was updated. The `ctx`, the updated content object and the content before was updated are provided.
 * * `updatedContentBody(ctx, newContentObj, oldContentObj, revision)`: A content item's file body was updated. The `ctx` of the request, the `newContentObj` object after being updated, the `oldContentObj` object before the update, and the revision object.
 * * `updatedContentMembers(ctx, content, memberUpdates, addedMemberIds, updatedMemberIds, removedMemberIds)`: A content's members list was updated. The `ctx`, full `content` object of the updated content, and the hash of principalId -> role that outlines the changes that were made are provided, as well as arrays containing the ids of the added members, updated members and removed members that resulted from the change
 * * `updatedContentPreview(content)`: A content item's preview has been updated
 */
var ContentAPI = module.exports = new EmitterAPI.EventEmitter();

///////////////////////////////////
// Retrieving a piece of content //
///////////////////////////////////

/**
 * Get a content's basic profile information based on a pooled content id.
 * An access-check will be run to determine if the user can view this piece of content.
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}         contentId               The id of the content object we want to retrieve
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Content}        callback.contentObj     Retrieved content object
 */
var getContent = module.exports.getContent = function(ctx, contentId, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    ContentDAO.Content.getContent(contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        AuthzPermissions.canView(ctx, contentObj, function(err) {
            if (err) {
                return callback(err);
            }

            ContentUtil.augmentContent(ctx, contentObj);
            return callback(null, contentObj);
        });
    });
};

/**
 * Get a full content item profile. Next to the basic content profile, this will include the created date, the profile of
 * the user who originally created the content, and a isManager property specifying whether or not the current user can
 * manage the content.
 *
 * @param  {Context}        ctx                         Standard context object containing the current user and the current tenant
 * @param  {String}         contentId                   The id of the content item to get
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error that occurred, if any
 * @param  {Content}        callback.contentProfile     Full content profile
 */
var getFullContentProfile = module.exports.getFullContentProfile = function(ctx, contentId, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        // Check whether the user is a manager
        var isManager = true;
        AuthzPermissions.canManage(ctx, contentObj, function(err) {
            if (err && err.code !== 401) {
                return callback(err);
            } else if (err) {
                isManager = false;
            }

            return _getFullContentProfile(ctx, contentObj, isManager, callback);
        });
    });
};

/**
 * Add the `isManager` flag, `createdBy` user object, `canShare` flag as well as `latestRevision` and `isEditor` in case it's a collaborative document.
 *
 * @param  {Context}    ctx                         Standard context object containing the current user and the current tenant
 * @param  {Content}    contentObj                  The content object to add the extra profile information on.
 * @param  {Boolean}    isManager                   Whether or not the current user is a manager of the piece of content.
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error that occurred, if any
 * @param  {Content}    callback.contentProfile     Full content profile
 */
var _getFullContentProfile = function(ctx, contentObj, isManager, callback) {
    // Store the isManager property.
    contentObj.isManager = isManager;

    // Get the user object for the createdBy property
    PrincipalsUtil.getPrincipal(ctx, contentObj.createdBy, function(err, createdBy) {
        if (err) {
            return callback(err);
        }
        contentObj.createdBy = createdBy;

        // Check if the user can share this content item
        var canShare = true;
        AuthzPermissions.canShare(ctx, contentObj, null, AuthzConstants.role.VIEWER, function(err) {
            if (err && err.code !== 401) {
                return callback(err);
            } else if (err) {
                canShare = false;
            }

            // Specify on the return value if the current user can share the content item
            contentObj.canShare = canShare;

            // For any other than collabdoc, we simply return with the share information
            if (contentObj.resourceSubType !== 'collabdoc') {
                ContentAPI.emit(ContentConstants.events.GET_CONTENT_PROFILE, ctx, contentObj);
                return callback(null, contentObj);
            }

            // If the content item is a collaborative document, add the latest revision data and isEditor
            _getRevision(ctx, contentObj, contentObj.latestRevisionId, function(err, revision) {
                if (err) {
                    return callback(err);
                }

                contentObj.latestRevision = revision;
                AuthzPermissions.canEdit(ctx, contentObj, function(err) {
                    if (err && err.code !== 401) {
                        return callback(err);
                    } else if (err) {
                        contentObj.isEditor = false;
                    } else {
                        contentObj.isEditor = true;
                    }

                    ContentAPI.emit(ContentConstants.events.GET_CONTENT_PROFILE, ctx, contentObj);
                    return callback(null, contentObj);
                });
            });
        });
    });
};

/////////////////////////////////////
// Creating a new piece of content //
/////////////////////////////////////

/**
 * Create a new link
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}         displayName             The display name of the link
 * @param  {String}         [description]           A longer description for the link
 * @param  {String}         [visibility]            The visibility of the link. One of `public`, `loggedin`, `private`
 * @param  {String}         link                    The URL for the link
 * @param  {Object}         [additionalMembers]     Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {String[]}       [folders]               The ids of the folders to which this link should be added
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Content}        callback.content        The created link
 */
var createLink = module.exports.createLink = function(ctx, displayName, description, visibility, link, additionalMembers, folders, callback) {
    callback = callback || function() {};

    // Setting content to default if no visibility setting is provided
    visibility = visibility || Config.getValue(ctx.tenant().alias, 'visibility', 'links');

    // Check if the link property is present. All other validation will be done in the _createContent function
    var validator = new Validator();
    validator.check(link, {'code': 400, 'msg': 'A valid link must be provided'}).isUrl();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to create a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Make sure the URL starts with a protocol
    if (link.indexOf('://') === -1) {
      link = 'http://' + link;
    }

    var contentId = _generateContentId(ctx.tenant().alias);
    var revisionId = _generateRevisionId(contentId);

    _createContent(ctx, contentId, revisionId, 'link', displayName, description, visibility, additionalMembers, folders, {'link': link}, {}, function(err, content, revision, memberChangeInfo) {
        if (err) {
            return callback(err);
        }

        ContentAPI.emit(ContentConstants.events.CREATED_CONTENT, ctx, content, revision, memberChangeInfo, folders, function(errs) {
            if (errs) {
                return callback(_.first(errs));
            }

            return callback(null, content);
        });
    });
};

/**
 * Create a new file
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}         displayName             The display name of the file
 * @param  {String}         [description]           A longer description for the file
 * @param  {String}         [visibility]            The visibility of the file. One of `public`, `loggedin`, `private`
 * @param  {Object}         file                    A file object as returned by express
 * @param  {Object}         [additionalMembers]     Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {String[]}       [folders]               The ids of the folders to which this file should be added
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Content}        callback.content        The created file
 */
var createFile = module.exports.createFile = function(ctx, displayName, description, visibility, file, additionalMembers, folders, callback) {
    // Wrap the callback function into a function that cleans up the file in case something went wrong
    var cleanUpCallback = _getCleanUpCallback({'file': file}, callback);

    // Try to create the file
    return _createFile(ctx, displayName, description, visibility, file, additionalMembers, folders, cleanUpCallback);
};

/**
 * Returns a function that will call the provided callback function.
 * In case the returned function gets called with an error object, the passed in file object will
 * be removed from the file system.
 *
 * @param  {Object}    files                The ExpressJS files object
 * @param  {Function}  callback             Standard callback function
 * @param  {Object}    callback.err         An error that occurred, if any
 * @param  {Content}   callback.content     JSON object containing the pool id of the created content
 * @return {Function}                       A function that removes the file on disk in case something went wrong
 * @api private
 */
var _getCleanUpCallback = function(files, callback) {
    return function() {
        // Remember the arguments so we can pass them to the callback later.
        var callbackArguments = arguments;

        // The first argument is always the error object.
        var err = callbackArguments[0];

        if (err && files) {
            // Something went wrong with a request that has uploaded files associated to it.
            // In that case we try to remove the files.
            var fileObjects = _.values(files);
            _cleanupUploadedFiles(fileObjects, function() {
                return callback.apply(this, callbackArguments);
            });
        } else {
            // If we get here, the request might have failed, but it didn't contain an uploaded file.
            return callback.apply(this, callbackArguments);
        }
    };
};

/**
 * Recursively iterates trough an array of uploaded files and removes them.
 *
 * @param  {Object[]}   files       An array of ExpressJS file objects
 * @param  {Function}   callback    Standard callback function
 * @api private
 */
var _cleanupUploadedFiles = function(files, callback) {
    if (_.isEmpty(files)) {
        return callback();
    }

    var file = files.pop();
    if (file && file.path) {
        fs.exists(file.path, function(exists) {
            if (!exists) {
                return _cleanupUploadedFiles(files, callback);
            }

            fs.unlink(file.path, function(unlinkErr) {
                if (unlinkErr) {
                    log().warn({'err': unlinkErr, 'file': file}, 'Could not remove the uploaded file.');
                }

                return _cleanupUploadedFiles(files, callback);
            });
        });
    } else {
        return _cleanupUploadedFiles(files, callback);
    }
};

/**
 * Create a new file
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}         displayName             The display name of the file
 * @param  {String}         [description]           A longer description for the file
 * @param  {String}         [visibility]            The visibility of the file. One of `public`, `loggedin`, `private`
 * @param  {Object}         file                    A file object as returned by express
 * @param  {Object}         [additionalMembers]     Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {String[]}       [folders]               The ids of the folders to which this file should be added
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Content}        callback.content        The created file
 * @api private
 */
var _createFile = function(ctx, displayName, description, visibility, file, additionalMembers, folders, callback) {
    callback = callback || function() {};

    // Setting content to default if no visibility setting is provided
    visibility = visibility || Config.getValue(ctx.tenant().alias, 'visibility', 'files');

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Anonymous users are not allowed to upload files'}).isLoggedInUser(ctx);
    validator.check(file, {'code': 400, 'msg': 'Missing file parameter'}).notNull();
    validator.check(displayName, {'code': 400, 'msg': 'A display name must be provided'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'A display name can be at most 1000 characters long'}).isShortString();
    if (description) {
        validator.check(description, {'code': 400, 'msg': 'A content description can be at most 10000 characters long'}).isMediumString();
    }
    if (file) {
        validator.check(file.size, {'code': 400, 'msg': 'Missing size on the file object'}).notEmpty();
        validator.check(file.size, {'code': 400, 'msg': 'Invalid size on the file object'}).isInt();
        validator.check(file.size, {'code': 400, 'msg': 'Invalid size on the file object'}).min(0);
        validator.check(file.name, {'code': 400, 'msg': 'Missing name on the file object'}).notEmpty();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Generate a content ID that can be used when storing the file.
    var contentId = _generateContentId(ctx.tenant().alias);
    var revisionId = _generateRevisionId(contentId);

    // Detect the mimetype of the file using the file extension, as the one that Express gives us is pulled
    // from the HTTP request. This makes it an untrustworthy piece of information as some browsers are
    // notoriously bad at providing the correct mimetype and it can be spoofed. If the mimetype cannot
    // be determined, the mime utility falls back to application/octet-stream.
    file.type = mime.getType(file.name);

    // We store the uploaded file in a location identified by the content id, then further identified by the revision id
    var options = {'resourceId': contentId, 'prefix': revisionId};
    ContentUtil.getStorageBackend(ctx).store(ctx.tenant().alias, file, options, function(err, uri) {
        if (err) {
            return callback(err);
        }

        // Create the content and revision object.
        var otherValues = {
            'mime': file.type,
            'size': file.size.toString(),
            'filename': file.name
        };
        var revisionData = _.extend({}, otherValues, {'uri': uri});
        _createContent(ctx, contentId, revisionId, 'file', displayName, description, visibility, additionalMembers, folders, otherValues, revisionData, function(err, content, revision, memberChangeInfo) {
            if (err) {
                return callback(err);
            }

            content.filename = file.name;
            content.size = file.size;
            content.mime = file.type;

            ContentAPI.emit(ContentConstants.events.CREATED_CONTENT, ctx, content, revision, memberChangeInfo, folders, function(errs) {
                if (errs) {
                    return callback(_.first(errs));
                }

                return callback(null, content);
            });
        });
    });
};

/**
 * Create a collaborative document as a pooled content item
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}         displayName             The display name of the collaborative document
 * @param  {String}         [description]           A longer description for the collaborative document
 * @param  {String}         [visibility]            The visibility of the collaborative document. One of `public`, `loggedin`, `private`
 * @param  {Object}         [additionalMembers]     Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer", "editor" and "manager"
 * @param  {String[]}       [folders]               The ids of the folders to which this collaborative document should be added
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Content}        callback.content        The created collaborative document
 */
var createCollabDoc = module.exports.createCollabDoc = function(ctx, displayName, description, visibility, additionalMembers, folders, callback) {
    callback = callback || function() {};

    // Setting content to default if no visibility setting is provided
    visibility = visibility || Config.getValue(ctx.tenant().alias, 'visibility', 'collabdocs');

    var contentId = _generateContentId(ctx.tenant().alias);
    var revisionId = _generateRevisionId(contentId);
    Etherpad.createPad(contentId, function(err, ids) {
        if (err) {
            return callback(err);
        }

        _createContent(ctx, contentId, revisionId, 'collabdoc', displayName, description, visibility, additionalMembers, folders, ids, {}, function(err, content, revision, memberChangeInfo) {
            if (err) {
                return callback(err);
            }

            content.etherpadPadId = ids.etherpadPadId;
            content.etherpadGroupId = ids.etherpadGroupId;

            ContentAPI.emit(ContentConstants.events.CREATED_CONTENT, ctx, content, revision, memberChangeInfo, folders, function(errs) {
                if (errs) {
                    return callback(_.first(errs));
                }

                return callback(null, content);
            });
        });
    });
};

/**
 * Create a new piece of pooled content
 *
 * @param  {Context}        ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}         contentId           The id of the content item
 * @param  {Strign}         revisionId          The id of the revision for the content item
 * @param  {String}         resourceSubType     The content item type. One of `file`, `collabdoc`, `link`
 * @param  {String}         displayName         The display name of the content item
 * @param  {String}         [description]       A longer description for the content item
 * @param  {String}         visibility          The visibility of the collaborative document. One of `public`, `loggedin`, `private`
 * @param  {Object}         roles               Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager", as well as "editor" for collabdocs
 * @param  {String}         folders             The ids of the folders to which this content item should be added
 * @param  {Object}         otherValues         JSON object where the keys represent other metadata values that need to be stored, and the values represent the metadata values
 * @param  {Object}         revisionData        JSON object where the keys represent revision columns that need to be stored, and the values represent the revision values
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Content}        callback.content    The created content item
 * @param  {Revision}       callback.revision   The created revision
 * @api private
 */
var _createContent = function(ctx, contentId, revisionId, resourceSubType, displayName, description, visibility, roles, folderIds, otherValues, revisionData, callback) {
    callback = callback || function() {};

    // Use an empty description if no description has been provided
    description = description || '';
    // Make sure the otherValues and roles are valid objects
    roles = roles || {};
    otherValues = otherValues || {};

    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content ID must be provided'}).isResourceId();
    validator.check(displayName, {'code': 400, 'msg': 'A display name must be provided'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'A display name can be at most 1000 characters long'}).isShortString();
    if (description) {
        validator.check(description, {'code': 400, 'msg': 'A description can only be 10000 characters long'}).isMediumString();
    }
    validator.check(visibility, {'code': 400, 'msg': 'An invalid content visibility option has been provided. This can be "private", "loggedin" or "public"'}).isIn(_.values(AuthzConstants.visibility));
    validator.check(resourceSubType, {'code': 400, 'msg': 'A valid resourceSubType must be provided. This can be "file", "collabdoc" or "link"'}).isIn(ContentConstants.resourceSubTypes);
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to create a content item'}).isLoggedInUser(ctx);

    // Ensure all roles applied are valid. Editor is only valid for collabdocs
    var validRoles = [AuthzConstants.role.VIEWER, AuthzConstants.role.MANAGER];
    if (resourceSubType === 'collabdoc') {
        validRoles.push(AuthzConstants.role.EDITOR);
    }
    _.each(roles, function(role) {
        validator.check(role, {'code': 400, 'msg': util.format('Invalid role "%s" specified. Must be one of %s', role, validRoles.join(', '))}).isIn(validRoles);
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure the specified folders exist and can be managed by the current user
    canManageFolders(ctx, folderIds, function(err, folders) {
        if (err) {
            return callback(err);
        }

        // The current user always becomes a manager
        roles[ctx.user().id] = AuthzConstants.role.MANAGER;

        // Create the resource
        var createFn = _.partial(ContentDAO.Content.createContent, contentId, revisionId, ctx.user().id, resourceSubType, displayName, description, visibility, otherValues, revisionData);
        ResourceActions.create(ctx, roles, createFn, function(err, content, revision, memberChangeInfo) {
            if (err) {
                return callback(err);
            }

            // Add the content item to the specified folders, if any
            _addContentItemToFolders(ctx, content, folders, function(err) {
                if (err) {
                    log().warn({'err': err, 'contentId': content.id, 'folders': folders}, 'Could not add a content item to a folder');
                }

                return callback(null, content, revision, memberChangeInfo);
            });
        });
    });
};

/**
 * Retrieve the specified folders ensuring that they exist and
 * that the current user can manage all of them.
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {String[]}       folderIds               The ids of the folders to retrieve
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error object, if any
 * @param  {Folder[]}       callback.folders        The basic folder objects for the given folder ids
 * @api private
 */
var canManageFolders = function(ctx, folderIds, callback) {
    if (_.isEmpty(folderIds)) {
        return callback(null, []);
    }

    var validator = new Validator();
    _.each(folderIds, function(folderId) {
        // Validate the folder id
        validator.check(folderId, {'code': 400, 'msg': 'Invalid folder id specified'}).isResourceId();
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure that all the folders exist. We have to require the FoldersDAO
    // inline as we'd get a dependency cycle otherwise
    require('oae-folders/lib/internal/dao').getFoldersByIds(folderIds, function(err, folders) {
        if (err) {
            return callback(err);
        } else if (folders.length !== folderIds.length) {
            return callback({'code': 400, 'msg': 'One or more folders do not exist'});
        }

        // Ensure that the user can manage all the folder items
        _canManageAllFolders(ctx, folders.slice(), function(err) {
            if (err) {
                return callback(err);
            }

            return callback(null, folders);
        });
    });
};

/**
 * Check whether the current user can manage a set of folders. This operation
 * is destructive to the `folders` array.
 *
 * @param  {Context}        ctx             Standard context object containing the current user and the current tenant
 * @param  {Folder[]}       folders         The set of folders to check
 * @param  {Function}       callback        Standard callback function
 * @param  {Object}         callback.err    An error object, if any
 * @api private
 */
var _canManageAllFolders = function(ctx, folders, callback) {
    if (folders.length === 0) {
        return callback();
    }

    // We have to require the FoldersAuthz module inline
    // as we'd get a dependency cycle otherwise
    var folder = folders.pop();
    AuthzPermissions.canManage(ctx, folder, function(err) {
        if (err) {
            return callback(err);
        }

        return _canManageAllFolders(ctx, folders, callback);
    });
};

/**
 * Add a content item to a set of folders. This operation
 * is destructive to the `folders` array.
 *
 * @param  {Context}        ctx                 Standard context object containing the current user and the current tenant
 * @param  {Content}        content             The content item that should be added to the folders
 * @param  {Folder[]}       folders             A set of folders where the content item should be added to
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @api private
 */
var _addContentItemToFolders = function(ctx, content, folders, callback) {
    if (folders.length === 0) {
        return callback();
    }

    // We have to require the FoldersAPI inline
    // as we'd get a dependency cycle otherwise
    var folder = folders.pop();
    require('oae-folders')._addContentItemsToFolderLibrary(ctx, 'content-create', folder, [content], function(err) {
        if (err) {
            return callback(err);
        }

        _addContentItemToFolders(ctx, content, folders, callback);
    });
};

/////////////////////////////
// Collaborative documents //
/////////////////////////////

/**
 * Publish a collaborative document. When a document is published the following happens:
 *
 *     -  The HTML for this pad is retrieved
 *     -  A new revision is created with this HTML
 *     -  The content object is updated with this HTML
 *     -  The content item gets bumped to the top of all the libraries it resides in
 *     -  An `updatedContent` event is fired so activities and PP images can be generated
 *
 * Note that this function does *NOT* perform any permission checks. It's assumed that
 * this function deals with messages coming from RabbitMQ. Producers of those messages
 * are expected to perform the necessary permissions checks. In the typical case
 * where Etherpad is submitting edit messages, the authorization happens by virtue of the app
 * server constructing a session in Etherpad.
 *
 * @param  {Object}     data                The message as sent by Etherpad
 * @param  {String}     data.contentId      The content id of the collaborative document that was published
 * @param  {String}     data.userId         The id of the user that published the document
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 */
var handlePublish = module.exports.handlePublish = function(data, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'data': data}, 'Error handling etherpad edit');
        }
    };

    log().trace({'data': data}, 'Got an etherpad edit');

    PrincipalsDAO.getPrincipal(data.userId, function(err, user) {
        if (err) {
            return callback(err);
        }

        var ctx = new Context(user.tenant, user);

        ContentDAO.Content.getContent(data.contentId, function(err, contentObj) {
            if (err) {
                return callback(err);
            }

            // Get the latest html from etherpad
            Etherpad.getHTML(contentObj.id, contentObj.etherpadPadId, function(err, html) {
                if (err) {
                    return callback(err);
                }

                // Get the latest OAE revision and compare the html that in Etherpad.
                // We only need to create a new revision if there is an actual update
                ContentDAO.Revisions.getRevision(contentObj.latestRevisionId, function(err, revision) {
                    if (err) {
                        return callback(err);
                    } else if (Etherpad.isContentEqual(revision.etherpadHtml, html) || (!revision.etherpadHtml && Etherpad.isContentEmpty(html))) {
                        // This situation can occur if 2 users were editting a collaborative document together, one of them leaves,
                        // the other one keeps idling (but doesn't make further chances) for a while and then leaves as well. There is no
                        // need to generate another revision as we already have one with the latest HTML. We do however raise an
                        // event so we can generate an "edited document"-activity for this user as well
                        ContentAPI.emit(ContentConstants.events.EDITED_COLLABDOC, ctx, contentObj);
                        return callback();
                    }

                    // Otherwise we create a new revision
                    var newRevisionId = _generateRevisionId(contentObj.id);
                    ContentDAO.Revisions.createRevision(newRevisionId, contentObj.id, data.userId, {'etherpadHtml': html}, function(err, revision) {
                        if (err) {
                            log().error({'err': err, 'contentId': contentObj.id}, 'Could not create a revision for this collaborative document');
                            return callback({'code': 500, 'msg': 'Could not create a revision for this collaborative document'});
                        }

                        // Update the content so we can easily retrieve it.
                        // This will also bump the collab doc to the top of the library lists
                        ContentDAO.Content.updateContent(contentObj, {'latestRevisionId': revision.revisionId}, true, function(err, newContentObj) {
                            if (err) {
                                log().error({'err': err, 'contentId': contentObj.id}, 'Could not update the main Content CF this collaborative document');
                                return callback({'code': 500, 'msg': 'Could not update this collaborative document'});
                            }

                            // Add the revision on the content object so the UI doesn't have to
                            // do another request to get the HTML
                            newContentObj.latestRevision = revision;

                            // Emit an event for activities and preview processing
                            ContentAPI.emit(ContentConstants.events.UPDATED_CONTENT_BODY, ctx, newContentObj, contentObj, revision);
                            return callback();
                        });
                    });
                });
            });
        });
    });
};

/**
 * Join a collaborative document.
 * Only users who have manager permissions on the collaborative document can join the pad.
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     contentId       The ID of the collaborative document that should be joined
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 * @param  {Object}     callback.url    JSON object containing the url where the pad is accessible
 */
var joinCollabDoc = module.exports.joinCollabDoc = function(ctx, contentId, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if we have access to this piece of content.
    _canEdit(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        } else if (contentObj.resourceSubType !== 'collabdoc') {
            return callback({'code': 400, 'msg': 'This is not a collaborative document'});
        }

        // Join the pad
        Etherpad.joinPad(ctx, contentObj, function(err, data) {
            if (err) {
                return callback(err);
            }

            ContentDAO.Etherpad.saveAuthorId(data.author.authorID, ctx.user().id, function(err) {
                if (err) {
                    return callback(err);
                }

                return callback(null, {'url': data.url});
            });
        });
    });
};

/////////////////////////////////
// Removing a piece of content //
/////////////////////////////////

/**
 * Delete a content item
 *
 * @param  {Context}   ctx               Standard context object containing the current user and the current tenant
 * @param  {String}    contentId         The id of the content item to delete
 * @param  {Function}  callback          Standard callback function
 * @param  {Object}    callback.err      An error that occurred, if any
 */
var deleteContent = module.exports.deleteContent = function(ctx, contentId, callback) {
    callback = callback || function() {};

    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to delete a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Fist check whether or not the current user is a manager of the piece of content
    _canManage(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        // Delete the content
        ContentDAO.Content.deleteContent(contentObj, function(err, members) {
            if (err) {
                return callback(err);
            }

            ContentAPI.emit(ContentConstants.events.DELETED_CONTENT, ctx, contentObj, members, function(errs) {
                if (errs) {
                    return callback(_.first(errs));
                }

                return callback();
            });
        });
    });
};

////////////////////////////
// Content access control //
////////////////////////////

/**
 * Share a content item. This only be possible when the current user is a manager of the content, or if the current user is logged
 * in and the content item is public or visible to logged in users only. In case that the content is shared with principals that
 * are already content members, no updates to the existing role of those principals will be made
 *
 * @param  {Context}   ctx               Standard context object containing the current user and the current tenant
 * @param  {String}    contentId         The id of the content item to share
 * @param  {String[]}  principalIds      Array of principal ids with whom the content will be shared. By default, they will all be made members.
 * @param  {Function}  callback          Standard callback function
 * @param  {Object}    callback.err      An error that occurred, if any
 */
var shareContent = module.exports.shareContent = function(ctx, contentId, principalIds, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to share content'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the content item exists
    ContentDAO.Content.getContent(contentId, function(err, content) {
        if (err) {
            return callback(err);
        }

        ResourceActions.share(ctx, content, principalIds, AuthzConstants.role.VIEWER, function(err, memberChangeInfo) {
            if (err) {
                return callback(err);
            } else if (_.isEmpty(memberChangeInfo.changes)) {
                return callback();
            }

            ContentAPI.emit(ContentConstants.events.UPDATED_CONTENT_MEMBERS, ctx, content, memberChangeInfo, {}, function(errs) {
                if (errs) {
                    return callback(_.first(errs));
                }

                return callback();
            });
        });
    });
};

/**
 * Ensure that the content item exists and the user in context can manage it
 *
 * @param  {Context}        ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}         contentId           The id of the content object we want to check
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Content}        callback.content    The basic profile of the content item
 * @api private
 */
var _canManage = function(ctx, contentId, callback) {
    ContentDAO.Content.getContent(contentId, function(err, content) {
        if (err) {
            return callback(err);
        }

        AuthzPermissions.canManage(ctx, content, function(err) {
            if (err) {
                return callback(err);
            }

            ContentUtil.augmentContent(ctx, content);
            return callback(null, content);
        });
    });
};

/**
 * Check whether or not the current user can edit a piece of content
 *
 * @param  {Context}        ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}         contentId           The id of the content object we want to check
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Content}        callback.content    The basic profile of the content item
 */
var _canEdit = function(ctx, contentId, callback) {
    ContentDAO.Content.getContent(contentId, function(err, content) {
        if (err) {
            return callback(err);
        }

        AuthzPermissions.canEdit(ctx, content, function(err) {
            if (err) {
                return callback(err);
            }

            return callback(null, content);
        });
    });
};

/**
 * Update, add or remove the role of a set of principals on a piece of content
 *
 * @param  {Context}         ctx            Standard context object containing the current user and the current tenant
 * @param  {String}          contentId      The id of the content item to update the members for
 * @param  {Object}          changes        Object where the keys represent the principal ids for which the content permissions should be updated/added/removed. The value is a string representing the new role. If false is passed in, the permissions for that principal will be removed e.g. {'user1': 'manager', 'user2': 'viewer', 'user3': false}
 * @param  {Function}        callback       Standard callback function
 * @param  {Object}          callback.err   An error that occurred, if any
 */
var setContentPermissions = module.exports.setContentPermissions = function(ctx, contentId, changes, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to create a content item'}).isLoggedInUser(ctx);
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the content exists
    getContent(ctx, contentId, function(err, content) {
        if (err) {
            return callback(err);
        }

        // Ensure all roles applied are valid. Editor is only valid for collabdocs
        var validRoles = [AuthzConstants.role.VIEWER, AuthzConstants.role.MANAGER];
        if (content.resourceSubType === 'collabdoc') {
            validRoles.push(AuthzConstants.role.EDITOR);
        }
        _.each(changes, function(role, principalId) {
            if (role !== false) {
                validator.check(role, {'code': 400, 'msg': util.format('Invalid role "%s" specified. Must be one of %s', role, validRoles.join(', '))}).isIn(validRoles);
            }
        });
        if (validator.hasErrors()) {
            return callback(validator.getFirstError());
        }

        ResourceActions.setRoles(ctx, content, changes, function(err, memberChangeInfo) {
            if (err) {
                return callback(err);
            } else if (_.isEmpty(memberChangeInfo.changes)) {
                return callback();
            }

            ContentAPI.emit(ContentConstants.events.UPDATED_CONTENT_MEMBERS, ctx, content, memberChangeInfo, {}, function(errs) {
                if (errs) {
                    return callback(_.first(errs));
                }

                return callback();
            });
        });
    });
};

/**
 * Remove a content item from a content library. This is its own API method due to special permission handling required, as the user
 * is effectively updating a content permissions (removing themselves, or removing it from a group they manage), and they might not
 * necessarily have access to update the permissions of the private content (e.g., they are only a member). Also, tenant privacy
 * rules do not come into play in this case.
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     libraryOwnerId  The id of the principal from whose content library to remove the content item
 * @param  {String}     contentId       The id of the content item to remove from the library
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var removeContentFromLibrary = module.exports.removeContentFromLibrary = function(ctx, libraryOwnerId, contentId, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You must be authenticated to remove a piece of content from a library'}).isLoggedInUser(ctx);
    validator.check(libraryOwnerId, {'code': 400, 'msg': 'A user or group id must be provided'}).isPrincipalId();
    validator.check(contentId, {'code': 400, 'msg': 'A valid content id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Make sure the content exists
    ContentDAO.Content.getContent(contentId, function(err, content) {
        if (err) {
            return callback(err);
        }

        // Ensure the library owner exists
        PrincipalsDAO.getPrincipal(libraryOwnerId, function(err, libraryOwner) {
            if (err) {
                return callback(err);
            }

            // Ensure the user can remove the content item from the library owner's resource
            AuthzPermissions.canRemoveRole(ctx, libraryOwner, content, function(err, memberChangeInfo) {
                if (err) {
                    return callback(err);
                }

                // All validation checks have passed, finally persist the role change and update the user library
                AuthzAPI.updateRoles(contentId, memberChangeInfo.changes, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    ContentAPI.emit(ContentConstants.events.UPDATED_CONTENT_MEMBERS, ctx, content, memberChangeInfo, {}, function(errs) {
                        if (errs) {
                            return callback(_.first(errs));
                        }

                        return callback();
                    });
                });
            });
        });
    });
};


/**
 * Get the members of a content item and their roles
 *
 * @param  {Context}        ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}         contentId           The id of the content item to get the members for
 * @param  {String}         start               The content paging token from which to start fetching content members. If not provided, the first x elements will be returned
 * @param  {Number}         limit               The maximum number of results to return. Default: 10
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Object[]}       callback.members    Array that contains an object for each member. Each object has a role property that contains the role of the member and a profile property that contains the principal profile of the member
 * @param  {String}         callback.nextToken  The value to provide in the `start` parameter to get the next set of results
 */
var getContentMembersLibrary = module.exports.getContentMembersLibrary = function(ctx, contentId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(limit, {'code': 400, 'msg': 'A valid limit should be passed in'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    ContentDAO.Content.getContent(contentId, function(err, content) {
        if (err) {
            return callback(err);
        }

        // Determine if and how the current user should access the content members library
        LibraryAPI.Authz.resolveTargetLibraryAccess(ctx, content.id, content, function(err, hasAccess, visibility) {
            if (err) {
                return callback(err);
            } else if (!hasAccess) {
                return callback({'code': 401, 'msg': 'You are not authorized to access the members of this content item'});
            }

            // Get the members of the content item from the members library
            ContentMembersLibrary.list(content, visibility, {'start': start, 'limit': limit}, function(err, memberIds, nextToken) {
                if (err) {
                    return callback(err);
                } else if (_.isEmpty(memberIds)) {
                    return callback(null, [], nextToken);
                }

                // Get the roles of the members on the content item
                AuthzAPI.getDirectRoles(memberIds, content.id, function(err, memberRoles) {
                    if (err) {
                        return callback(err);
                    }

                    // Get the member profiles
                    PrincipalsUtil.getPrincipals(ctx, memberIds, function(err, memberProfiles) {
                        if (err) {
                            return callback(err);
                        }

                        var memberList = _.chain(memberIds)
                            .map(function(memberId) {
                                var memberProfile = memberProfiles[memberId];
                                var memberRole = memberRoles[memberId];
                                if (memberProfile && memberRole) {
                                    return {
                                        'profile': memberProfile,
                                        'role': memberRole
                                    };
                                }
                            })
                            .compact()
                            .value();

                        return callback(null, memberList, nextToken);
                    });
                });
            });
        });
    });
};

/**
 * Get the invitations for the specified content item
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}         contentId               The id of the content item to get the invitations for
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Invitation[]}   callback.invitations    The invitations
 */
var getContentInvitations = module.exports.getContentInvitations = function(ctx, contentId, callback) {
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A valid resource id must be specified'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    ContentDAO.Content.getContent(contentId, function(err, content) {
        if (err) {
            return callback(err);
        }

        return AuthzInvitations.getAllInvitations(ctx, content, callback);
    });
};

/**
 * Resend an invitation email for the specified email and content item
 *
 * @param  {Context}        ctx             Standard context object containing the current user and the current tenant
 * @param  {String}         contentId       The id of the content item to which the email was invited
 * @param  {String}         email           The email that was previously invited
 * @param  {Function}       callback        Standard callback function
 * @param  {Object}         callback.err    An error that occurred, if any
 */
var resendContentInvitation = module.exports.resendContentInvitation = function(ctx, contentId, email, callback) {
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A valid resource id must be specified'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    ContentDAO.Content.getContent(contentId, function(err, content) {
        if (err) {
            return callback(err);
        }

        return ResourceActions.resendInvitation(ctx, content, email, callback);
    });
};

/////////////////////////////
// Update content metadata //
/////////////////////////////

/**
 * Update the file body that is associated with a file content item.
 *
 * @param  {Context}    ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}     contentId           The id of the file to upload a new version for
 * @param  {File}       file                An expressjs File object that holds the data for the file that needs updating
 * @param  {Function}   [callback]          Standard callback function
 * @param  {Object}     [callback.err]      An error that occurred, if any
 * @param  {Content}    [callback.content]  The updated content item
 */
var updateFileBody = module.exports.updateFileBody = function(ctx, contentId, file, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Error updating the filebody for %s', contentId);
        }
    };

    // Wrap the callback function into a function that cleans up the file in case something went wrong
    var cleanUpCallback = _getCleanUpCallback({'file': file}, callback);

    // Perform the update
    return _updateFileBody(ctx, contentId, file, cleanUpCallback);
};

/**
 * Update the file body that is associated with an uploaded file.
 *
 * @param  {Context}    ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}     contentId           The id of the file to upload a new version for
 * @param  {File}       file                An expressjs File object that holds the data for the file that needs updating.
 * @param  {Function}   [callback]          Standard callback function
 * @param  {Object}     [callback.err]      An error that occurred, if any
 * @param  {Content}    [callback.content]  The updated content item
 * @api private
 */
var _updateFileBody = function(ctx, contentId, file, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a content item'}).isLoggedInUser(ctx);
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(file, {'code': 400, 'msg': 'Missing file parameter.'}).notNull();
    if (file) {
        validator.check(file.size, {'code': 400, 'msg': 'Missing size on the file object.'}).notEmpty();
        validator.check(file.size, {'code': 400, 'msg': 'Invalid size on the file object.'}).isInt();
        validator.check(file.size, {'code': 400, 'msg': 'Invalid size on the file object.'}).min(0);
        validator.check(file.name, {'code': 400, 'msg': 'Missing name on the file object.'}).notEmpty();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _canManage(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        } else if (contentObj.resourceSubType !== 'file') {
            return callback({'code': 400, 'msg': 'This content object is not a file.'});
        }

        // Create a revision id ahead of time for the new revision, so we know where to store the file body for it
        var revisionId = _generateRevisionId(contentId);

        // Detect the mimetype of the file using the file extension, as the one that Express gives us is pulled
        // from the HTTP request. This makes it an untrustworthy piece of information as some browsers are
        // notoriously bad at providing the correct mimetype and it can be spoofed. If the mimetype cannot
        // be determined, the mime utility falls back to application/octet-stream.
        file.type = mime.getType(file.name);

        // Store the file, using the current time as the folder name
        var options = {'resourceId': contentObj.id, 'prefix': revisionId};
        ContentUtil.getStorageBackend(ctx).store(ctx.tenant().alias, file, options, function(err, uri) {
            if (err) {
                return callback(err);
            }

            // Create the revision
            var opts = {
                'mime': file.type,
                'size': file.size.toString(),
                'filename': file.name,
                'uri': uri
            };

            ContentDAO.Revisions.createRevision(revisionId, contentObj.id, ctx.user().id, opts, function(err, revision) {
                if (err) {
                    return callback(err);
                }

                // Set the new filesize, filename and mimetype on the Content object so the UI
                // can retrieve all the relevant metadata in 1 Cassandra query
                opts.latestRevisionId = revision.revisionId;

                // We have to set the previews status back to pending
                opts.previews = {'status': ContentConstants.previews.PENDING};
                ContentDAO.Content.updateContent(contentObj, opts, true, function(err, updatedContentObj) {
                    if (err) {
                        return callback(err);
                    }

                    ContentAPI.emit(ContentConstants.events.UPDATED_CONTENT_BODY, ctx, updatedContentObj, contentObj, revision);

                    // Output a full content profile
                    return _getFullContentProfile(ctx, updatedContentObj, true, callback);
                });
            });
        });
    });
};

/**
 * Attaches preview items to, or set the status of, a revision of a piece of content. This can only be used by a global admin and should technically only
 *  be executed by the preview processor.
 *
 * @param  {Context}     ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}      contentId           The ID of the content item.
 * @param  {String}      revisionId          The revision ID of the content item.
 * @param  {String}      status              The result of the preview processing operation. It should be one of the values of ContentConstants.previews.
 * @param  {Object}      [files]             An object whose key that represents the preview "name" (e.g., page1.html, large.png, etc...) and the value is either an ExpressJS File object or a string representing an external URL at which to reference a preview item. When listing preview items, the items will be ordered ALPHABETICALLY according to the keys in this object.
 * @param  {Object}      [sizes]             Each key maps a filename to a preview size.
 * @param  {Object}      [contentMetadata]   An object that holds optional content metadata, data like displayName for example can be passed in here.
 * @param  {Object}      [previewMetadata]   An object that holds optional preview metadata, data like pageCount for example can be passed in here.
 * @param  {Function}    callback            Standard callback function
 * @param  {Object}      callback.err        An error that occurred, if any
 */
var setPreviewItems = module.exports.setPreviewItems = function(ctx, contentId, revisionId, status, files, sizes, contentMetadata, previewMetadata, callback) {
    files = files || {};
    sizes = sizes || {};
    contentMetadata = contentMetadata || {};
    previewMetadata = previewMetadata || {};

    // Wrap the callback method, which takes care of cleaning up the files if something goes wrong
    var cleanUpCallback = _getCleanUpCallback(files, callback);

    var validStatuses = _.values(ContentConstants.previews);
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'Missing or invalid contentId'}).isResourceId();
    validator.check(revisionId, {'code': 400, 'msg': 'Missing or invalid revisionId'}).isResourceId();
    validator.check(status, {'code': 400, 'msg': 'The status parameter must be one of: ' + validStatuses.join(', ')}).isIn(validStatuses);
    if (validator.hasErrors()) {
        return cleanUpCallback(validator.getFirstError());
    }

    ContentDAO.Content.getContent(contentId, function(err, contentObj) {
        if (err) {
            return cleanUpCallback(err);
        }

        // Ensure the user is an administrator of the content item's tenant before continuing further
        if (!ctx.user() || !(ctx.user().isGlobalAdmin() || ctx.user().isTenantAdmin(contentObj.tenant.alias))) {
            return cleanUpCallback({'code': 401, 'msg': 'Only administrators can attach preview items to a content item'});
        }

        ContentDAO.Revisions.getRevision(revisionId, function(err, revision) {
            if (err) {
                return cleanUpCallback(err);
            }

            // Ensure that the revision supplied is a revision of the specified content item
            validator.check(revision.contentId, {'code': 400, 'msg': 'Specified revisionId does not belong to the specifed content item'}).equals(contentId);
            if (validator.hasErrors()) {
                return cleanUpCallback(validator.getFirstError());
            }

            var fileData = {};
            var fileKeys = Object.keys(files);
            var todo = fileKeys.length;

            // The storage URI for the thumbnail image. Will be set to the appropriate preview uri in a later loop
            var thumbnailUri = null;


            if (status === ContentConstants.previews.ERROR || todo === 0) {
                // Preview generation failed or no files were uploaded, store that information in the database
                return ContentDAO.Previews.storeMetadata(contentObj, revisionId, status, thumbnailUri, contentMetadata, previewMetadata, fileData, function(err) {
                    ContentAPI.emit(ContentConstants.events.UPDATED_CONTENT_PREVIEW, contentObj);
                    return callback(err);
                });
            }

            // Preview generation was successful, store the files

            // We store the previews in a location within the content item, in the preview directory specified for the revision
            var storePrefix = 'previews/' + revision.previewsId;
            var called = false;

            /*!
             * Convenience method that handles the completion of storing a preview item to backend storage. When all
             * items have completed and invoked this method, it will call the final callback to exit this method.
             *
             * @param  {Object}     err     An error that occurred, if any
             */
            var _finishIteration = function(err) {
                // If we have already called back (e.g., because of an error), ignore this invokation
                if (called) {
                    return;
                }

                // Always decrement todo, whether or not there is an error
                todo--;

                // If we had an error, exit immediately
                if (err) {
                    called = true;
                    return cleanUpCallback(err);
                } else if (todo === 0 && !called) {
                    // All files have been stored, store the metadata and exit
                    called = true;
                    log().trace({'data': fileData}, 'Storing %d content preview files', fileKeys.length);
                    ContentDAO.Previews.storeMetadata(contentObj, revisionId, status, thumbnailUri, contentMetadata, previewMetadata, fileData, function(err) {
                        if (err) {
                            return callback(err);
                        }

                        // Indicate that we've just updated a preview
                        ContentAPI.emit(ContentConstants.events.UPDATED_CONTENT_PREVIEW, contentObj);

                        return callback();
                    });
                }
            };

            // Iterate each preview item, store it and record it in the `previewMetadata` hash
            fileKeys.forEach(function(key) {
                var size = sizes[key];
                if (!size) {
                    todo--;
                    log().warn('Ignoring file %s as it has no size associated to it', key);
                    return;
                }

                // Store the file with a regular storage backend
                var options = {'resourceId': contentObj.id, 'prefix': storePrefix};
                _storePreview(ctx, files[key], options, function(err, uri) {
                    if (err) {
                        return _finishIteration(err);
                    }

                    // Remember the thumbnail uri separately so we can stick it on the main content object
                    if (size === 'thumbnail') {
                        thumbnailUri = uri;

                    // Remember the small, medium and large URIs so we can stick it on the previews object
                    } else if (size === 'small') {
                        previewMetadata['smallUri'] = uri;
                    } else if (size === 'medium') {
                        previewMetadata['mediumUri'] = uri;
                    } else if (size === 'large') {
                        previewMetadata['largeUri'] = uri;
                    } else if (size === 'wide') {
                        previewMetadata['wideUri'] = uri;
                    }

                    // Aggregate the file info so it can be stored in Cassandra after all preview bodies have been stored
                    fileData[files[key].name] = size + '#' + uri;
                    return _finishIteration();
                });
            });
        });
    });
};

/**
 * Verifies the signature for a preview item that is associated to a piece of content.
 * If the signature is valid, an object will be returned that the REST handlers can use
 * to redirect the user to the actual file.
 *
 * @param  {Context}            ctx                             Standard context object containing the current user and the current tenant
 * @param  {String}             contentId                       The content ID that the preview item is associated with
 * @param  {String}             revisionId                      The revision ID that the preview item is associated with
 * @param  {String}             previewItem                     The preview item that needs to be retrieved
 * @param  {Object}             signatureData                   The signature data to check, as created by `Signature.createExpiringResourceSignature`
 * @param  {Function}           callback                        Standard callback function
 * @param  {Object}             callback.err                    An error that occurred, if any
 * @param  {Object}             callback.downloadInfo           An object containing information necessary for downloading the preview
 * @param  {String}             callback.downloadInfo.filename  The filename to suggest to the client for the download
 * @param  {DownloadStrategy}   callback.downloadInfo.strategy  The DownloadStrategy that details how to download the preview
 */
var getSignedPreviewDownloadInfo = module.exports.getSignedPreviewDownloadInfo = function(ctx, contentId, revisionId, previewItem, signatureData, callback) {
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'Missing content ID'}).isResourceId();
    validator.check(revisionId, {'code': 400, 'msg': 'Missing revision ID'}).isResourceId();
    validator.check(previewItem, {'code': 400, 'msg': 'Missing preview item'}).notEmpty();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    } else if (!Signature.verifyExpiringResourceSignature(ctx, contentId, signatureData.expires, signatureData.signature)) {
        return callback({'code': 401, 'msg': 'Invalid content signature data for accessing previews'});
    }

    ContentDAO.Previews.getContentPreview(revisionId, previewItem, function(err, preview) {
        if (err) {
            return callback(err);
        }

        var downloadStrategy = ContentUtil.getStorageBackend(ctx, preview.uri).getDownloadStrategy(ctx.tenant().alias, preview.uri);
        return callback(null, {'filename': previewItem, 'strategy': downloadStrategy});
    });
};

/**
 * Get the revisions for a revision
 *
 * @param  {Context}     ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}      contentId           The id of the content item to get the previews for
 * @param  {String}      revisionId          The id of the revision to get the previews for
 * @param  {Function}    callback            Standard callback function
 * @param  {Object}      callback.err        An error that occurred, if any
 * @param  {Object}      callback.results    Object with a key `files` that holds an array of strings that are the filenames for previews and a key `signature` which holds the signature and expires parameters that should be sent when retrieving the preview bodies.
 */
var getPreviewItems = module.exports.getPreviewItems = function(ctx, contentId, revisionId, callback) {
    getContent(ctx, contentId, function(err, content) {
        if (err) {
            return callback(err);
        }

        ContentDAO.Previews.getContentPreviews(revisionId, function(err, previews) {
            if (err) {
                return callback(err);
            }

            // Generate an expiring signature
            var signature = Signature.createExpiringResourceSignature(ctx, content.id);
            var result = {
                'files': previews,
                'signature': signature
            };

            callback(null, result);
        });
    });
};

/**
 * Update a content item. This can only be done by the manager of that piece of content.
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}         contentId               The id of the content item to update
 * @param  {Object}         profileFields           Object where the keys represent the profile fields that need to be updated and the values represent the new values for those profile fields e.g. {'displayName': 'New content name', 'description': 'New content description', 'visibility': 'private'}
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Content}        callback.newContentObj  The updated content item
 */
var updateContentMetadata = module.exports.updateContentMetadata = function(ctx, contentId, profileFields, callback) {
    callback = callback || function() {};

    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    // Check that at a minimum name or description have been provided
    var fieldNames = profileFields ? _.keys(profileFields) : [];
    validator.check(fieldNames.length, {'code': 400, 'msg': 'You should at least specify a new displayName, description, visibility or link'}).min(1);
    for (var i = 0; i < fieldNames.length; i++) {
        var fieldName = fieldNames[i];
        validator.check(fieldName, {'code': 400, 'msg': fieldName + ' is not a recognized content profile field'}).isIn(['displayName', 'description', 'visibility', 'link']);
        if (fieldName === 'displayName') {
            validator.check(profileFields['displayName'], {'code': 400, 'msg': 'A display name cannot be empty'}).notEmpty();
            validator.check(profileFields['displayName'], {'code': 400, 'msg': 'A display name can be at most 1000 characters long'}).isShortString();
        } else if (fieldName === 'description' && profileFields['description']) {
            validator.check(profileFields['description'], {'code': 400, 'msg': 'A description can only be 10000 characters long'}).isMediumString();
        } else if (fieldName === 'link') {
            validator.check(profileFields['link'], {'code': 400, 'msg': 'A valid link should be provided'}).isUrl();
        }
    }
    if (profileFields['visibility']) {
        validator.check(profileFields['visibility'], {'code': 400, 'msg': 'An invalid content visibility option has been provided. This can be "private", "loggedin" or "public"'}).isIn(_.values(AuthzConstants.visibility));
    }
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // First check whether or not the current user is a manager of the piece of content
    _canManage(ctx, contentId, function(err, oldContentObj) {
        if (err) {
            return callback(err);
        }

        if (profileFields.link) {
            if (oldContentObj.resourceSubType !== 'link') {
                return callback({'code': 400, 'msg': 'This piece of content is not a link'});
            } else if (profileFields.link !== oldContentObj.link) {
                // Reset the previews object so we don't show the old preview items while the new link is still being processed
                profileFields.previews = {'status': ContentConstants.previews.PENDING};
            }
        }

        ContentDAO.Content.updateContent(oldContentObj, profileFields, true, function(err, newContentObj) {
            if (err) {
                return callback(err);
            }

            ContentAPI.emit(ContentConstants.events.UPDATED_CONTENT, ctx, newContentObj, oldContentObj);

            // Add the isManager, createdBy, .. properties.
            _getFullContentProfile(ctx, newContentObj, true, callback);
        });
    });
};


// TODO: Split this out once we reorganize the content API
///////////////////////////
// Comment functionality //
///////////////////////////

/**
 * Create a new comment on a content item. Returns an error if saving the comment goes wrong or the user doesn't have access.
 * Only logged in users who can see the content are able to post comments.
 *
 * @param  {Context}    ctx                         Standard context object containing the current user and the current tenant
 * @param  {String}     contentId                   The id of the content item to which to post the comment
 * @param  {String}     body                        The body of the comment
 * @param  {String}     [replyToCreatedTimestamp]   The timestamp of the comment to which this comment is a reply. Not specifying this will create a top level comment
 * @param  {Function}   [callback]                  Standard callback function
 * @param  {Object}     [callback.err]              An error that occurred, if any
 * @param  {Comment}    [callback.comment]          The created comment
 */
var createComment = module.exports.createComment = function(ctx, contentId, body, replyToCreatedTimestamp, callback) {
    callback = callback || function() {};

    // Parameter validation
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authorized users can post comments'}).isLoggedInUser(ctx);
    validator.check(contentId, {'code': 400, 'msg': 'Invalid content resource id provided'}).isResourceId();
    validator.check(body, {'code': 400, 'msg': 'A comment must be provided'}).notEmpty();
    validator.check(body, {'code': 400, 'msg': 'A comment can only be 100000 characters long'}).isLongString();
    if (replyToCreatedTimestamp) {
        validator.check(replyToCreatedTimestamp, {'code': 400, 'msg': 'Invalid reply-to timestamp provided'}).isInt();
    }

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Verify the user has access to the content object
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        MessageBoxAPI.createMessage(contentId, ctx.user().id, body, {'replyToCreated': replyToCreatedTimestamp}, function(err, message) {
            if (err) {
                return callback(err);
            }

            // Get a UI-appropriate representation of the current user
            PrincipalsUtil.getPrincipal(ctx, ctx.user().id, function(err, createdBy) {
                if (err) {
                    return callback(err);
                }

                message.createdBy = createdBy;
                ContentAPI.emit(ContentConstants.events.CREATED_COMMENT, ctx, message, contentObj);
                return callback(null, message);
            });
        });
    });
};

/**
 * Get the comments for a content item. Everyone who has access to the content item will be able to retrieve the list of comments.
 *
 * @param  {Context}    ctx                  Standard context object containing the current user and the current tenant
 * @param  {String}     contentId            The id of the content item for which to get the comments
 * @param  {String}     start                The comments paging token from which to start fetching comments
 * @param  {Number}     limit                The maximum number of results to return. Default: 10
 * @param  {Function}   callback             Standard callback function
 * @param  {Object}     callback.err         An error that occurred, if any
 * @param  {Comment[]}  callback.comments    The comments on the content item
 * @param  {String}     callback.nextToken   The value to provide in the `start` parameter to get the next set of results
 */
var getComments = module.exports.getComments = function(ctx, contentId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'Invalid content resource id provided'}).isResourceId();
    validator.check(limit, {'code': 400, 'msg': 'A valid limit should be passed in'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        MessageBoxAPI.getMessagesFromMessageBox(contentId, start, limit, null, function(err, comments, nextToken) {
            if (err) {
                return callback(err);
            }

            // Get information on the commenters
            var userIds = _.chain(comments)
                .pluck('createdBy')
                .compact()
                .uniq()
                .value();

            // Get the basic principal profiles of the commenters to add to the comments as `createdBy`.
            PrincipalsUtil.getPrincipals(ctx, userIds, function(err, principals) {
                if (err) {
                    return callback(err);
                }

                _.each(comments, function(comment) {
                    var principal = principals[comment.createdBy];
                    if (principal) {
                        comment.createdBy = principal;
                    }
                });

                return callback(err, comments, nextToken);
            });
        });
    });
};

/**
 * Delete a comment from a content item. Managers of the content can delete all comments whilst people that have access
 * to the content can only delete their own comments. Therefore, anonymous users will never be able to delete comments.
 *
 * @param  {Context}    ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}     contentId               The id of the content item from which to delete the comment
 * @param  {String}     commentCreatedDate      The timestamp of the comment that should be deleted
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Comment}    [callback.softDeleted]  When the comment has been soft deleted (because it has replies), a stripped down comment object representing the deleted comment will be returned, with the `deleted` parameter set to `false`. If the comment has been deleted from Cassandra, no comment object will be returned.
 */
var deleteComment = module.exports.deleteComment = function(ctx, contentId, commentCreatedDate, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authorized users can delete comments'}).isLoggedInUser(ctx);
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(commentCreatedDate, {'code': 400, 'msg': 'A valid integer comment created timestamp must be specified'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getContent(ctx, contentId, function(err, content) {
        if (err) {
            return callback(err);
        }

        MessageBoxAPI.getMessages(contentId, [commentCreatedDate], null, function(err, messages) {
            if (err) {
                return callback(err);
            } else if (_.isEmpty(messages) || !messages[0]) {
                return callback({'code': 404, 'msg': 'The specified comment does not exist'});
            }

            // Ensure the user has access to manage the message
            var message = messages[0];
            AuthzPermissions.canManageMessage(ctx, content, message, function(err) {
                if (err) {
                    return callback(err);
                }

                return _deleteComment(ctx, content, message, callback);
            });
        });
    });
};

/**
 * Delete the comment (either hard or soft, depending on if there are any replies) with the given timestamp from the
 * message box with the given id.
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {Content}        content                 The content object on which a comment should be deleted
 * @param  {Message}        commentToDelete         The comment to delete
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Message}        [callback.comment]      If the comment was soft-deleted, this will be the model of the scrubbed deleted comment
 */
var _deleteComment = function(ctx, content, commentToDelete, callback) {
    var messageBoxId = content.id;
    // Delete the comment using the "leaf" method, which will SOFT delete if the message has replies, or HARD delete if it does not
    MessageBoxAPI.deleteMessage(messageBoxId, commentToDelete.created, {'deleteType': MessageBoxConstants.deleteTypes.LEAF}, function(err, deleteType, deletedComment) {
        if (err) {
            return callback(err);
        }

        // If the comment was hard deleted, it is not returned from the delete message endpoint. However if there is a soft delete and
        // it is returned, we want to return the new version of the comment
        deletedComment = deletedComment || commentToDelete;

        // Notify consumers that the comment was deleted
        ContentAPI.emit(ContentConstants.events.DELETED_COMMENT, ctx, deletedComment, content, deleteType);

        if (deleteType === MessageBoxConstants.deleteTypes.SOFT) {
            // If a soft-delete occurred, we want to inform the consumer of the soft-delete message model
            return callback(null, deletedComment);
        } else {
            return callback();
        }
    });
};


///////////////////////////
// Library functionality //
///////////////////////////

/**
 * Get the content library items for a user or group. If the user requests their own library or the library of a group they're a member of,
 * the full list will be returned. If the user is logged in but not a manager of the library, the :loggedin stream will be returned, containing
 * only content that's visible to logged in people or the public. In case of an anonymous user, the :public stream will be returned, containing
 * only content that is public
 *
 * @param  {Context}        ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}         principalId         The id of the principal whose content library to fetch
 * @param  {String}         start               The content paging token from which to start fetching content items. If not provided, the first x elements will be returned
 * @param  {Number}         limit               The maximum number of results to return. Default: 10
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Content[]}      callback.content    The content library items for the specified user or group
 * @param  {String}         callback.nextToken  The value to provide in the `start` parameter to get the next set of results
 */
var getContentLibraryItems = module.exports.getContentLibraryItems = function(ctx, principalId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'A user or group id must be provided'}).isPrincipalId();
    validator.check(limit, {'code': 400, 'msg': 'A valid limit should be passed in'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the principal
    PrincipalsDAO.getPrincipal(principalId, function(err, principal) {
        if (err) {
            return callback(err);
        }

        // Determine which library visibility we need to fetch
        LibraryAPI.Authz.resolveTargetLibraryAccess(ctx, principal.id, principal, function(err, hasAccess, visibility) {
            if (err) {
                return callback(err);
            } else if (!hasAccess) {
                return callback({'code': 401, 'msg': 'You do not have access to this library'});
            }

            ContentDAO.Content.getContentLibraryItems(principalId, visibility, start, limit, function(err, contentObjects, nextToken) {
                if (err) {
                    return callback(err);
                }

                _.each(contentObjects, function(contentObj) {
                    ContentUtil.augmentContent(ctx, contentObj);
                });

                // Emit an event indicating that the content library has been retrieved
                ContentAPI.emit(ContentConstants.events.GET_CONTENT_LIBRARY, ctx, principalId, visibility, start, limit, contentObjects);

                return callback(null, contentObjects, nextToken);
            });
        });
    });
};

///////////////
// Revisions //
///////////////

/**
 * Get the revisions for a content item
 *
 * @param  {Context}        ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}         contentId           The id of the content item to get the revisions for
 * @param  {Number}         [start]             The revision paging token from which to start fetching revisions
 * @param  {Number}         [limit]             The maximum number of results to return. Default: 10
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Revision[]}     callback.revisions  The revisions for the specified content item
 * @param  {String}         callback.nextToken  The value to provide in the `start` parameter to get the next set of results
 */
var getRevisions = module.exports.getRevisions = function(ctx, contentId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A contentId must be provided'}).isResourceId();
    validator.check(limit, {'code': 400, 'msg': 'A valid limit should be passed in'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the user has access on this contentId
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        // all columns except etherpadHtml
        var opts = {
            'fields': [
                'contentId',
                'created',
                'createdBy',
                'filename',
                'mediumUri',
                'mime',
                'previews',
                'previewsId',
                'revisionId',
                'size',
                'thumbnailUri',
                'uri',
                'wideUri'
            ]
        };

        return _getRevisions(ctx, contentObj, start, limit, opts, callback);
    });
};

/**
 * Internal method that retrieves revisions and augments them with the principal profile who created it.
 * This method performs no access checks.
 *
 * @param  {Context}        ctx                 Standard context object containing the current user and the current tenant
 * @param  {Content}        contentObj          The content object for which we need to retrieve the revisions.
 * @param  {Number}         [start]             The revision paging token from which to start fetching revisions
 * @param  {Number}         [limit]             The maximum number of results to return. Default: 10
 * @param  {Object}         [opts]              Additional options
 * @param  {String[]}       [opts.fields]       The columns to get from cassandra if not specified all will be fetched
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Revision[]}     callback.revisions  Array that contains an object for each revision.
 * @param  {String}         callback.nextToken  The value to provide in the `start` parameter to get the next set of results
 * @api private
 */
var _getRevisions = function(ctx, contentObj, start, limit, opts, callback) {
    // Page the query.
    ContentDAO.Revisions.getRevisions(contentObj.id, start, limit, opts, function(err, revisions, nextToken) {
        if (err) {
            return callback(err);
        }

        var userIds = _.map(revisions, function(revisions) { return revisions.createdBy; });
        PrincipalsUtil.getPrincipals(ctx, userIds, function(err, users) {
            if (err) {
                return callback(err);
            }

            // Add the user profiles to the revisions.
            _.each(revisions, function(revision) {
                if (users[revision.createdBy]) {
                    revision.createdBy = users[revision.createdBy];
                    _augmentRevision(ctx, revision, contentObj);
                }
            });

            return callback(null, revisions, nextToken);
        });
    });
};

/**
 * Get a revision
 *
 * @param  {Context}        ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}         contentId           The id of the content item to get the revision for
 * @param  {String}         [revisionId]        The id of the revision to get. If unspecified, the latest revision will be retrieved
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Revision}       callback.revision   The revision
 */
var getRevision = module.exports.getRevision = function(ctx, contentId, revisionId, callback) {
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A valid contentId must be provided'}).isResourceId();
    if (revisionId) {
        validator.check(revisionId, {'code': 400, 'msg': 'A valid revisionId must be provided'}).isResourceId();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the user has access to this content item
    getContent(ctx, contentId, function(err, content) {
        if (err) {
            return callback(err);
        }

        // The user has access, get the revision and augment it with a downloadload link
        // if this piece of content is a file
        return _getRevision(ctx, content, revisionId, callback);
    });
};

/**
 * Get the download strategy information for downloading a revision
 *
 * @param  {Context}            ctx                             Standard context object containing the current user and the current tenant
 * @param  {String}             contentId                       The id of the content item for which we want to get the revision download information
 * @param  {String}             [revisionId]                    The id of the revision whose download information to retrieve. If unspecified, the latest revision download information will be retrieved
 * @param  {Function}           callback                        Standard callback function
 * @param  {Object}             callback.err                    An error that occurred, if any
 * @param  {Object}             callback.downloadInfo           An object containing information necessary for downloading the revision
 * @param  {String}             callback.downloadInfo.filename  The filename to suggest to the client for the download
 * @param  {DownloadStrategy}   callback.downloadInfo.strategy  The DownloadStrategy that details how to download the revision
 */
var getRevisionDownloadInfo = module.exports.getRevisionDownloadInfo = function(ctx, contentId, revisionId, callback) {
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A valid contentId must be provided'}).isResourceId();
    if (revisionId) {
        validator.check(revisionId, {'code': 400, 'msg': 'A valid revisionId must be provided'}).isResourceId();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the user has access to this content item
    getContent(ctx, contentId, function(err, content) {
        if (err) {
            return callback(err);
        } else if (content.resourceSubType !== 'file') {
            return callback({'code': 400, 'msg': 'Only file content items can be downloaded'});
        }

        // Ensure we can resolve a revision id
        revisionId = revisionId || content.latestRevisionId;
        if (!revisionId) {
            return callback({'code': 400, 'msg': 'No revision id provided and content item does not have a latest revision id'});
        }

        // Get the revision that the user wishes to download
        ContentDAO.Revisions.getRevision(revisionId, function(err, revision) {
            if (err) {
                return callback(err);
            } else if (content.id !== revision.contentId) {
                // It's possible that the user specified a revision id that belonged to a different content item. Yikes!
                return callback({'code': 400, 'msg': 'The revision id provided is not associated with the specified content item'});
            }

            // Emit an event indicating that a content item is downloaded
            ContentAPI.emit(ContentConstants.events.DOWNLOADED_CONTENT, ctx, content, revision);

            return callback(null, {
                'filename': revision.filename,
                'strategy': ContentUtil.getStorageBackend(ctx, revision.uri).getDownloadStrategy(ctx.tenant().alias, revision.uri)
            });
        });
    });
};

/**
 * Internal method for retrieving a specific revision.
 * It's assumed that the parameters have been properly validated beforehand.
 *
 * @param  {Context}        ctx                 Standard context object containing the current user and the current tenant
 * @param  {Content}        contentObj          The content object for which we need to retrieve a revision.
 * @param  {String}         [revisionId]        The id of the revision to get. If unspecified, the latest will be retrieved
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Revision}       callback.revision   The revision
 * @api private
 */
var _getRevision = function(ctx, contentObj, revisionId, callback) {
    if (!revisionId) {
        // Get the latest one.
        _getRevisions(ctx, contentObj, null, 1, null, function(err, revisions) {
            if (err) {
                return callback(err);
            } else if (_.isEmpty(revisions)) {
                return callback({'code': 404, 'msg': 'No revision found for ' + contentObj.id});
            }

            // There is no need to augment the revisions here as that has already happened
            return callback(null, revisions[0]);
        });
    } else {
        ContentDAO.Revisions.getRevision(revisionId, function(err, revisionObj) {
            if (err) {
                return callback(err);

            // Double check that this revision is really attached to the specified contentId.
            // This is to counter that someone tries to get the revision of a piece of content he has no access to.
            // Ex: Alice has access to c:cam:aliceDoc but not to c:cam:bobDoc which has revision rev:cam:foo
            // doing getRevision(ctx, 'c:cam:aliceDoc', 'rev:cam:foo', ..) should return this error.
            } else if (revisionObj.contentId !== contentObj.id) {
                return callback({'code': 400, 'msg': 'This revision ID is not associated with the specified piece of content.'});
            }

            _augmentRevision(ctx, revisionObj, contentObj);
            return callback(null, revisionObj);
        });
    }
};

/**
 * Convert the given revision to a model that can be returned to the consumer from the API
 *
 * @param  {Context}    ctx         Standard context object containing the current user and the current tenant
 * @param  {Revision}   revision    The revision to augment
 * @param  {Content}    contentObj  The content object that the revision is attached to
 * @api private
 */
var _augmentRevision = function(ctx, revision, contentObj) {
    // Replace the thumbnail URI with a signed download URL
    if (revision.thumbnailUri) {
        revision.thumbnailUrl = _getPictureDownloadUrlFromUri(ctx, revision.thumbnailUri, revision.id);
        delete revision.thumbnailUri;
    }

    // Replace the medium picture URI with a signed download URL
    if (revision.mediumUri) {
        revision.mediumUrl = _getPictureDownloadUrlFromUri(ctx, revision.mediumUri, revision.id);
        delete revision.mediumUri;
    }
};

/**
 * Takes a revision and makes it the "current" revision by creating a new one and copying the existing revision's fields.
 *
 * @param  {Context}        ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}         contentId           The id of the content item to restore the revision for
 * @param  {String}         revisionId          The id of the revision to restore
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Revision}       callback.revision   The restored revision
 */
var restoreRevision = module.exports.restoreRevision = function(ctx, contentId, revisionId, callback) {
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A valid contentId must be provided'}).isResourceId();
    validator.check(revisionId, {'code': 400, 'msg': 'A valid revisionId must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Make sure the user is a manager of this piece of content and the revision exists.
    _canManage(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        ContentDAO.Revisions.getRevision(revisionId, function(err, revision) {
            if (err) {
                return callback(err);
            } else if (contentObj.id !== revision.contentId) {
                return callback({'code': 400, 'msg': 'The contentId specified is not the owner of the specified revisionId'});
            }

            // Create a new revision by copying from the specified revision
            var newRevisionId = _generateRevisionId(contentId);
            ContentDAO.Revisions.createRevision(newRevisionId, contentId, ctx.user().id, revision, function(err, newRevision) {
                if (err) {
                    return callback(err);
                }

                /*!
                 * We need to update the content item in the Content CF.
                 * We do so by copying all the non-standard fields from the revision
                 * to the Content CF.
                 */
                var blacklist = ['revisionId', 'contentId', 'createdBy', 'created', 'etherpadHtml', 'previewsId', 'downloadPath'];
                var updates = _.omit(revision, blacklist);

                // We also need to update the latest revisionID in the content CF.
                updates.latestRevisionId = newRevisionId;

                ContentDAO.Content.updateContent(contentObj, updates, true, function(err, newContentObj) {
                    if (err) {
                        return callback(err);
                    }

                    // Provide user-level data such as signed URLs for the consumer
                    _augmentRevision(ctx, newRevision, newContentObj);

                    // Emit an event
                    ContentAPI.emit(ContentConstants.events.RESTORED_REVISION, ctx, newContentObj, contentObj, revision);

                    // If this piece of content is a collaborative document,
                    // we need to set the text in etherpad.
                    if (contentObj.resourceSubType === 'collabdoc') {
                        Etherpad.setHTML(contentObj.id, contentObj.etherpadPadId, revision.etherpadHtml, function(err) {
                            if (err) {
                                return callback(err);
                            }

                            return callback(null, newRevision);
                        });
                    } else {
                        return callback(null, newRevision);
                    }
                });
            });
        });
    });
};

/**
 * Verifies if a uri and signature match up and returns an object that the REST handlers can use to redirect users
 * to the actual download page.
 *
 * @param  {Context}            ctx                             Standard context object containing the current user and the current tenant
 * @param  {Object}             qs                              The query string object of the download request as generated by `ContenUtil.getSignedDownloadUrl`
 * @param  {Object}             callback.err                    An error that occurred, if any
 * @param  {Object}             callback.downloadInfo           An object containing information necessary for downloading the signed download
 * @param  {String}             callback.downloadInfo.filename  The filename to suggest to the client for the download
 * @param  {DownloadStrategy}   callback.downloadInfo.strategy  The DownloadStrategy that details how to download the file
 */
var verifySignedDownloadQueryString = module.exports.verifySignedDownloadQueryString = function(ctx, qs, callback) {
    var uri = ContentUtil.verifySignedDownloadQueryString(qs);
    if (!uri) {
        return callback({'code': 401, 'msg': 'Invalid signature data for the provided download url'});
    }

    var downloadStrategy = ContentUtil.getStorageBackend(ctx, uri).getDownloadStrategy(ctx.tenant().alias, uri);
    return callback(null, {'strategy': downloadStrategy, 'filename': path.basename(uri)});
};

///////////////////////
// Utility functions //
///////////////////////


/**
 * Store the preview reference (if necessary), producing the backend URI that can be used to
 * download it afterward.
 *
 * @param  {Context}        ctx                 Standard context object containing the current user and the current tenant
 * @param  {String|Stream}  previewReference    Either a string indicating the external URL of the preview, or a stream indicating its location on disk for upload to back-end storage
 * @param  {Object}         [options]           The storage options indicating the `resourceId` of the content object and the storage prefix. Only applicable if the preview reference is a stream
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {String}         callback.uri        The URI to use to reference this preview in the future
 * @api private
 */
var _storePreview = function(ctx, previewReference, options, callback) {
    if (_.isString(previewReference)) {
        // If the reference is a string, it is simply an external link to some file. We will use a remote uri
        // to reference it
        return callback(null, 'remote:' + previewReference);
    } else {
        // Otherwise, it is expected to be a stream reference to a file on disk, in which case we want to store it
        // using the tenant default storage mechanism
        ContentUtil.getStorageBackend(ctx).store(ctx.tenant().alias, previewReference, options, callback);
    }
};

/**
 * Get the download url from a storage uri
 *
 * @param  {Context}    ctx         Standard context object containing the current user and the current tenant
 * @param  {String}     uri         The storage URI
 * @param  {String}     [parentId]  For logging purposes, the owner of this URI in case the URI is invalid
 * @return {String}                 A reference that can be used directly in a link to download the file
 * @api private
 */
var _getPictureDownloadUrlFromUri = function(ctx, uri, parentId) {
    try {
        return ContentUtil.getSignedDownloadUrl(ctx, uri);
    } catch (err) {
        // The backend was probably not found, we will fail safely here
        log(ctx).warn({'parentId': parentId}, 'Could not find storage backend for uri: %s', uri);
        return null;
    }
};

/**
 * Create a permission change object with the provided member ids whose roles are all set to the
 * provided `role`
 *
 * @param  {String[]}           memberIds   The ids of the members for whom to make the permission changes
 * @param  {String|Boolean}     role        The role to apply, or `false` if the intention is to remove the member from the content item
 * @return {Object}                         An object whose keys are the member ids and values are the specified role
 * @api private
 */
var _makeAllPermissionChanges = function(memberIds, role) {
    var roleChanges = {};
    _.each(memberIds, function(memberId) {
        roleChanges[memberId] = role;
    });
    return roleChanges;
};

/**
 * Generates a new content ID.
 *
 * @param  {String}     tenantAlias     The tenant alias for the content item
 * @return {String}                     The new content ID.
 * @api private
 */
var _generateContentId = function(tenantAlias) {
    return AuthzUtil.toId('c', tenantAlias, ShortId.generate());
};

/**
 * Generates a new revision ID for a content item by ID.
 *
 * @param  {String}     contentId   The ID of the content item for which to generate a new revision ID
 * @return {String}                 The new revision ID
 * @api private
 */
var _generateRevisionId = function(contentId) {
    var tenantAlias = AuthzUtil.getResourceFromId(contentId).tenantAlias;
    return AuthzUtil.toId('rev', tenantAlias, ShortId.generate());
};
