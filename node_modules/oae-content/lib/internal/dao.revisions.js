/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var ShortId = require('shortid');

var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var log = require('oae-logger').logger('content-dao');
var OaeUtil = require('oae-util/lib/util');

var ContentPreviewsDAO = require('./dao.previews');
var Revision = require('oae-content/lib/model').Revision;


///////////////
// Retrieval //
///////////////


/**
 * Get a set of revisions.
 *
 * @param  {String}         contentId           The id of the object for which we want to get the revisions
 * @param  {Number}         [start]             Determines the point at which revisions are returned for paging purposes. If not provided, the first `limit` elements will be returned. The `created` value from the last retrieved revision should be used here.
 * @param  {Number}         [limit]             Number of revisions to return. Will default to 10 if not provided
 * @param  {Object}         [opts]              Additional options
 * @param  {String[]}       [opts.fields]       Columns to fetch from cassandra if none are specified all will be fetched
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `revisions`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Revision[]}     callback.revisions  Array that contains an object for each revision.
 * @param  {String}         callback.nextToken  The value to provide in the `start` parameter to get the next set of results
 */
var getRevisions = module.exports.getRevisions = function(contentId, start, limit, opts, callback) {
    limit = OaeUtil.getNumberParam(limit, 10);

    Cassandra.runPagedColumnQuery('RevisionByContent', 'contentId', contentId, start, limit, {'reversed': true}, function(err, columns, nextToken) {
        if (err) {
            return callback(err);
        } else if (columns.length === 0) {
            return callback(null, []);
        }

        var revisionsToRetrieve = _.pluck(columns, 'value');
        getMultipleRevisions(revisionsToRetrieve, opts, function(err, revisions) {
            if (err) {
                return callback(err);
            }

            return callback(null, revisions, nextToken);
        });
    });
};

/**
 * Retrieves multiple revisions.
 *
 * @param  {String[]}       revisionIds         An array of revision IDs that should be retrieved.
 * @param  {Object}         [opts]              Additional options
 * @param  {String[]}       [opts.fields]       Columns to get from cassandra if not specified all will be fetched
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Revision[]}     callback.revisions  Array that contains an object for each revision.
 */
var getMultipleRevisions = module.exports.getMultipleRevisions = function(revisionIds, opts, callback) {
    var columns = '*';
    if (opts && opts.fields) {
        columns = opts.fields.join();
    }
    Cassandra.runQuery('SELECT ' + columns + ' FROM Revisions WHERE revisionId IN (?)', [revisionIds], function(err, rows) {
        if (err) {
            return callback(err);
        }

        // Generate the Revision objects.
        var revisions = [];
        for (var i = 0; i < rows.length; i++) {
            var revision = _rowToRevision(rows[i]);
            revisions.push(revision);
        }
        callback(null, revisions);
    });
};

/**
 * Get all revisions for the specified content IDs
 *
 * @param  {String[]}   contentIds          An array of content IDs
 * @param  {Function}   callback            A standard callback function
 * @param  {Object}     callback.err        A standard error object (if any)
 * @param  {Object}     callback.revisions  An object where arrays of revisions are keyed by their content ID
 */
var getAllRevisionsForContent = module.exports.getAllRevisionsForContent = function(contentIds, callback) {
    Cassandra.runQuery('SELECT * FROM RevisionByContent WHERE contentId IN (?)', [contentIds], function(err, rows) {
        if (err) {
            return callback(err);
        }

        // Get the revision IDs
        var revisionIds = [];
        var contentByRevisions = {};
        _.each(rows, function(row) {
            var hash = Cassandra.rowToHash(row);
            _.each(hash, function(value, columnName) {
                if (columnName !== 'contentId') {
                    revisionIds.push(value);
                    contentByRevisions[value] = hash.contentId;
                }
            });
        });

        // Get the revision objects
        getMultipleRevisions(revisionIds, null, function(err, revisions) {
            if (err) {
                return callback(err);
            }

            var revisionsByContent = {};
            _.each(revisions, function(revision) {
                var contentId = contentByRevisions[revision.revisionId];
                revisionsByContent[contentId] = revisionsByContent[contentId] || [];
                revisionsByContent[contentId].push(revision);
            });

            callback(null, revisionsByContent);
        });
    });
};

/**
 * Get a specific revision.
 *
 * @param  {String}     revisionId          The ID of the revision to retrieve.
 * @param  {Function}   callback            Standard callback function takes arguments `err` and `revision`
 * @param  {Object}     callback.err        Error object containing the error message
 * @param  {Revision}   callback.revision   The retrieved revision
 */
var getRevision = module.exports.getRevision = function(revisionId, callback) {
    Cassandra.runQuery('SELECT * FROM Revisions WHERE revisionId = ?', [revisionId], function (err, rows) {
        if (err) {
            return callback(err);
        }

        // Cassandra always returns the key as a column so the count property will always be 1.
        if (rows[0].count <= 1) {
            return callback({'code': 404, 'msg': 'Couldn\'t find revision: ' + revisionId});
        }

        var revision = _rowToRevision(rows[0]);
        callback(null, revision);
    });
};


///////////////
// Modifiers //
///////////////

/**
 * Create a new revision in the database.
 *
 * @param  {String}     revisionId              The id to assign to the revision
 * @param  {String}     contentId               The contentId this revision is for.
 * @param  {String}     createdBy               The ID of the user who created this revision.
 * @param  {Object}     [revisionProperties]    Properties to apply to the revision that is created
 * @param  {Function}   [callback]              An optional callback method.
 * @param  {Object}     [callback.err]          An error object (if any)
 * @param  {Revision}   [callback.revision]     A revision object.
 */
var createRevision = module.exports.createRevision = function(revisionId, contentId, createdBy, revisionProperties, callback) {
    // Copy all the options (if any)
    var values = _.extend({}, revisionProperties);

    // Override some new values for the new revision
    values.contentId = contentId;
    values.created = Date.now();
    values.createdBy = createdBy;
    values.previewsId = revisionProperties.previewsId || revisionId;

    // Grab the old revisionId if there was one, but take it off the resulting object
    var oldRevisionId = values.revisionId;
    delete values.revisionId;

    // Copy the preview item metadata from the source to the destination
    _copyPreviewItemsIfNecessary(revisionProperties.revisionId, revisionId, function(err) {
        if (err) {
            return callback(err);
        }

        var q = Cassandra.constructUpsertCQL('Revisions', 'revisionId', revisionId, values, 'QUORUM');
        Cassandra.runQuery(q.query, q.parameters, function(err) {
            if (err) {
                return callback(err);
            }

            // Add the revision to the revisions listing for the content item
            Cassandra.runQuery('UPDATE RevisionByContent SET ?=? WHERE contentId=?', [values.created, revisionId, contentId], function(err) {
                if (err) {
                    return callback(err);
                }

                var revision = new Revision(contentId, revisionId, values.createdBy, values.created, values);

                return callback(null, revision);
            });
        });
    });
};


///////////////////////
// Utility functions //
///////////////////////

/**
 * Copy the preview items from the source revision to the destination revision, only if the source revision is specified. This
 * will fail silently if the source revision was not specified.
 *
 * @param  {String}     [fromRevisionId]    The id of the revision from which to copy the preview items
 * @param  {String}     toRevisionId        The id of the destination revision, where the preview items will be copied
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @api private
 */
var _copyPreviewItemsIfNecessary = function(fromRevisionId, toRevisionId, callback) {
    if (!fromRevisionId) {
        // There is no source (i.e., there is no revision from which to copy), so simply do nothing and return ok
        return callback();
    }

    ContentPreviewsDAO.copyPreviewItems(fromRevisionId, toRevisionId, callback);
};

/**
 * Converts a Cassandra Row to a Revision object.
 *
 * @param  {Row}        row         A Helenus Row
 * @return {Revision}               A revision object or null if the column could not be converted.
 * @api private
 */
var _rowToRevision = function(row) {
    var hash = Cassandra.rowToHash(row);
    if (hash.previews) {
        try {
            hash.previews = JSON.parse(hash.previews);
        } catch (jsonErr) {
            hash.previews = {};
        }
    }
    return new Revision(hash.contentId, hash.revisionId, hash.createdBy, hash.created, hash);
};
