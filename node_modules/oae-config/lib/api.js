/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var fs = require('fs');

var Cassandra = require('oae-util/lib/cassandra');
var IO = require('oae-util/lib/io');
var log = require('oae-logger').logger('config');
var OAE = require('oae-util/lib/oae');
var OAEUtil = require('oae-util/lib/util');
var Validator = require('oae-util/lib/validator').Validator;

// Keeps track of the configurableModules
var configurableModules = {};

/**
 * Constructs an UPDATE CQL query with a variable amount of values to set
 * TODO: Remove this and change to Cassandra.constructUpsertCQL
 * @param {Object} configValues configuration values to set
 */
var constructUpdateCQLQuery = function(tenantid, configValues) {
    var q = {
        'query': '',
        'params': []
    }
    var tempQuery = [];
    for (var i in configValues) {
        tempQuery.push('? = ?');
        q.params.push(i, configValues[i]);
    }
    q.query = 'UPDATE Config USING CONSISTENCY QUORUM SET ' + tempQuery.join(', ') + ' WHERE tenantid = ?';
    q.params.push(tenantid);
    return q;
};

/**
 * Writes configuration to Cassandra
 * @param {Object}   configValues  The configuration to store
 * @param {Function} callback      Function executed when storing the configuration completes
 */
var writeConfig = module.exports.writeConfig = function(tenantid, configValues, callback) {
    var validator = new Validator();
    validator.check(tenantid, {'code': 400, 'msg': 'Missing tenantid'}).notEmpty();
    validator.check(_.keys(configValues).length, {'code': 400, 'msg': 'Missing configuration. Example configuration: {"oae-authentication/google-authentication/google-authentication-enabled": {"tenantid": "global","value": false}}'}).min(1);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var q = constructUpdateCQLQuery(tenantid, configValues);
    Cassandra.runQuery(q.query, q.params, function(err) {
        if (!err) {
            callback();
        } else {
            callback(err);
        }
    });
};

/**
 * Parses a Helenus row into an object that can be merged with the configuration
 * @param {Object} config Helenus result row
 */
var parseStoredConfigToObject = function(config) {
    var configToExtend = {};

    for (var i = 0, l = config.count; i < l; i++) {
        var colHash = config[i].name.split('/');
        if (colHash[0] !== 'tenantid') {
            configToExtend[colHash[0]] = {"config": {"options": {}}};
            configToExtend[colHash[0]].config.options[colHash[1]] = {"elements": {}};
            configToExtend[colHash[0]].config.options[colHash[1]].elements[colHash[2]] = {
                "value": config[i].value
            };
        }
    }

    return configToExtend;
};

/**
 * Merges the different configurations into one. config.json < global config < tenant config
 * @param {Object}    config     Contains configuration values
 * @param {Object}    modules    Contains the modules available for configuration
 * @param {Function}  callback   Function executed when config has been fully merged
 */
var mergeConfigIntoOriginal = module.exports.mergeConfigIntoOriginal = function(config, modules, callback) {
    callback(OAEUtil.extend(true, modules, parseStoredConfigToObject(config)));
};

/**
 * Reads the configuration values
 * @param {String}    tenantid   The ID of the tenant to get configuration for
 * @param {Function}  callback   Function executed after config has been read
 */
var getFullConfig = module.exports.getFullConfig = function(tenantid, callback) {
    var validator = new Validator();
    validator.check(tenantid, {'code': 400, 'msg': 'Missing tenantid'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    Cassandra.runQuery('SELECT * FROM Config USING CONSISTENCY QUORUM WHERE tenantid = ?', ['global'], function(err, globalRows) {
        if (!err) {
            getModules(function(modules) {
                // Merge the stored config files into the fetched modules data
                // config.json < global config < tenant config
                mergeConfigIntoOriginal(globalRows[0], modules, function(config) {
                    if (!err) {
                        Cassandra.runQuery('SELECT * FROM Config USING CONSISTENCY QUORUM WHERE tenantid = ?', [tenantid], function(err, tenantRows) {
                            mergeConfigIntoOriginal(tenantRows[0], config, function(config) {
                                if (!err) {
                                    callback(false, config);
                                } else {
                                    callback(err);
                                }
                            });
                        });
                    } else {
                        callback(err);
                    }
                });
            });
        } else {
            callback(err);
        }
    });
};

 /**
 * Filters out modules that don't have a configuration file in the config directory and fills an Array of modules with configuration.
 * @param {Array}     modules    Array of strings containing directory names for oae- modules.
 * @param {Function}  callback   Callback function executed when filtering is complete. Passes through the filtered Array of config objects.
 */
var filterModulesByConfig = function(modules, callback) {

    var done = 0;

    /**
     * Filters out modules that don't have a configuration file in the config directory
     * @param {Number} i index of the module to filter next
     */
    var doFilter = function(module) {
        fs.exists('node_modules/' + module + '/config/config.json', function(exists) {
            done++;
            if (exists) {
                var configFile = require(module + '/config/config.json');
                configurableModules[module] = {
                    'id': module,
                    'config': configFile
                };

                if (done === modules.length) {
                    callback(configurableModules);
                }
            }
        });
    };

    for (var i = 0; i < modules.length; i++) {
        doFilter(modules[i]);
    }
};


/**
 * Gets the available modules
 * @param {Function} callback Function executed when availables modules are retrieved
 */
var getModules = module.exports.getModules = function(callback) {
    callback = callback || function(){};

    // Read directories starting with oae- and get their configuration files.
    // If there's no configuration file the directory is skipped.
    OAE.getAvailableModules(function(finalModules) {
        configurableModules = {};
        filterModulesByConfig(finalModules, callback);
    });
};
