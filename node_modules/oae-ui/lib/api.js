/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var events = require('events');
var fs = require('fs');
var less = require('less');
var readdirp = require('readdirp');
var util = require('util');
var watch = require('watch');

var ConfigAPI = require('oae-config');
var IO = require('oae-util/lib/io');
var Validator = require('oae-util/lib/validator').Validator;
var log = require('oae-logger').logger('oae-ui');

var UIConstants = require('./constants').UIConstants;

// The Config object for the UI module.
var uiConfig = ConfigAPI.config('oae-ui');

// The cached skin variables
var cachedSkinVariables = null;
// The cached skins per tenant.
var cachedSkins = {};


// Path to the 3akai-ux repository
var uiDirectory = null;

// A dictionary that will hold the content for each file. This will be lazy filled. The first
// time a particular file is requested, it will be cached. After that, the cached version will
// be used
var staticFileCache = {};

// A dictionary that will hold the widget manifests for all widgets. This will be filled upon
// initialization.
var widgetManifestCache = {};


/**
 * The UI API.
 *
 * ## Events
 *
 * * `skinParsed` - Invoked when the skin file has been parsed on the application node.
 */
var UIAPI = module.exports = new events.EventEmitter();
var emitter = UIAPI;

////////////////////
// Initialization //
////////////////////

/**
 * This will find all of the widget config files in the UI repository and cache. For development, 
 * it will also put watches on the files in the UI repository in order to invalidate the cache
 * when a file has been changed/removed.
 *
 * @param  {String}     uiDir           The path to the directory containing the UI repository.
 * @param  {Function}   callback        Standard callback method.
 * @param  {Object}     callback.err    An error object (if any)
 */
var init = module.exports.init = function(uiDir, callback) {
    // Cache the ui directory path and make sure we have the absolute path
    uiDirectory = fs.realpathSync(uiDir);

    // Cache all of the widget manifest files
    cacheWidgetManifests();

    // Monitor the UI repository for changes and refresh the cache. 
    // This will only be done in development mode
    if (process.env['NODE_ENV'] !== 'production') {
        watch.createMonitor(uiDirectory, {'ignoreDotFiles': true}, function(monitor) {
            monitor.on('created', updateFileCaches);
            monitor.on('changed', updateFileCaches);
            monitor.on('removed', updateFileCaches);
        });
    }

    // Cache the base skin file.
    _cacheSkinVariables(callback);
};

ConfigAPI.on('update', function(tenantAlias) {
    // Re-generate the skin.
    // Don't delete it from the cache just yet as we might still be serving requests.
    _generateSkin(tenantAlias, function(err) {
        if (err) {
            log().error({'err': err, 'tenantAlias': tenantAlias}, 'Could not re-cache the tenant skin after a config update.');
        }

        emitter.emit('skinParsed');
    });
});


/////////////
// Caching //
/////////////

/**
 * When a file in the UI repository has changed, we update the static file cache by deleting
 * the record for that file if there is one. The next time the updated/created file will be
 * re-requested, caching will be attempted again. We also check if the changed file is a 
 * widget manifest file, and refresh the widget manifest cache if that's the case
 * 
 * @param  {String}     filename        The absolute path to the file that has been added/updated/deleted
 * @api private
 */
var updateFileCaches = function(filename) {
    filename = filename.replace(uiDirectory, '');
    // Delete the file from the static file cache, for it to be re-cached
    // when it is requested again
    delete staticFileCache[filename];
    // If the changed file is a widget config file, we re-cache the widget
    // config files
    if (/^\/node_modules\/(.*?)\/manifest.json$/.test(filename)) {
        cacheWidgetManifests();
    // If the changed file is the base skin file, we re-cache it.
    } else if (filename === UIConstants.paths.BASE_SKIN) {
        // The skin file has changed, reset the skin files, they will be lazy loaded.
        cachedSkins = {};

        // Retrieve the skin variables.
        _cacheSkinVariables(function(err) {
            if (err) {
                log().error({'err': err}, 'Could not cache the skin variables after a file update.');
            }
        });
    }
};

///////////////////////////////
// Widget config aggregation //
///////////////////////////////

/**
 * Get the aggregated list of widget manifests.
 * 
 * @return {Object}     An object where each key is the widget id and the value is the widget manifest.
 */
var getWidgetManifests = module.exports.getWidgetManifests = function() {
    return widgetManifestCache;
};

/**
 * Cache all widget manifests under the UI's node_modules directory
 * 
 * @api private
 */
var cacheWidgetManifests = function() {
    widgetManifestCache = {};
    // Cache all of the widget config files under node_modules
    readdirp({ 'root': uiDirectory + '/node_modules/', 'directoryFilter': ['!.bin'], 'fileFilter': 'manifest.json' })
      .on('data', function (entry) {
          var widgetId = entry.parentDir.split('/')[entry.parentDir.split('/').length - 1];
          widgetManifestCache[widgetId] = require(entry.fullPath);
          widgetManifestCache[widgetId].id = widgetId;
          widgetManifestCache[widgetId].path = entry.parentDir + '/';
      })
      .on('warn', function (err) { log().warn({'err': err}, 'A non-fatal error occured whilst caching the config schema'); })
      .on('error', function (err) { log().error({'err': err}, 'A fatal error occured whilst caching the config schema'); });
};

//////////////////
// Static batch //
//////////////////

/**
 * Get the content of a set of static files. The returned data is an object where the key is the requested URL and
 * the values are the static file contents. In case the file couldn't be found, null will be returned.
 * 
 * @param {String[]}    files           An array of file paths relative to the UI repository.
 * @param {Function}    callback        Standard callback method.
 * @param {Object}      callback.err    An error object (if any)
 * @param {Object}      callback.data   JSON Object representing the retrieved files.
 */
var getStaticBatch = module.exports.getStaticBatch = function(files, callback) {
    var validator = new Validator();
    validator.check(files, {'code': 400, 'msg': 'The files parameter must be an array'}).isArray();
    // Filter out the duplicate ones
    files = _.uniq(files);
    // Make sure that all provided filenames are real strings
    for (var i = 0; i < files.length; i++) {
        validator.check(files[i], {'code': 400, 'msg': 'A valid file path needs to be provided'}).notEmpty();
        // Make sure that only absolute paths are allowed. All paths that contain a '../' have the potential of
        // exposing private server files
        validator.check(files[i], {'code': 400, 'msg': 'Only absolute paths are allowed'}).notContains('../');
    }
    validator.check(files.length, {'code': 400, 'msg': 'At least one file must be provided'}).min(1);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var results = {};
    files.forEach(function(file) {
        getStaticFile(file, function(err, data) {
            if (err) {
                results[file] = null;
            } else {
                results[file] = data;
            }

            // Check if all of them have returned
            if (_.keys(results).length === files.length) {
                callback(null, results);
            }
        });
    });
};

/**
 * Get the content of a static file and cache it if it hasn't been cached yet. This will only 
 * open the file on disk if the file could not be found in the cache.
 * 
 * @param {String}      path            The path for the static file to open. A path should be relative to the UI repository
 * @param {Function}    callback        Standard callback method
 * @param {Object}      callback.err    An error object containing the error code and message
 * @param {String}      callback.data   The file content for the requested file
 * @api private
 */
var getStaticFile = function(path, callback) {
    // Try to retrieve the file content from cache
    if (staticFileCache[path]) {
        callback(null, staticFileCache[path]);
    } else {
        cacheFile(path, callback);
    }
};

/**
 * Reads a file's content and cache it.
 *
 * @param {String}      path                The path for the file that needs to be read
 * @param {Function}    callback            Standard callback function
 * @param {Object}      callback.err        An error object containing the error code and message
 * @param {String}      callback.data       The data that sits in the file.
 * @api private
 */
var cacheFile = function(path, callback) {
    IO.readFile(uiDirectory + path, function(err, data) {
        if (err) {
            return callback(err);
        }

        // Cache the file content
        staticFileCache[path] = data;
        callback(null, data);
    });
};


//////////////
// SKINNING //
//////////////

/**
 * Get the skin file for the current tenant.
 *
 * @param  {Context}    ctx             Standard context object, representing the currently logged in user and its tenant
 * @param  {Function}   callback        Standard callback method.
 * @param  {Object}     callback.err    An error object (if any)
 * @param  {String}     callback.css    The generated CSS.
 */
var getSkin = module.exports.getSkin = function(ctx, callback) {
    var tenantAlias = ctx.tenant().alias;
    if (cachedSkins[tenantAlias]) {
        return callback(null, cachedSkins[tenantAlias]);
    } else {
        _generateSkin(tenantAlias, callback);
    }
};

/**
 * Retrieve the LESS variables that are present in the skin file.
 * Each variable will be annotated with the tenant value.
 *
 * @param  {Context}    ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}     [tenantAlias]       The optional alias of the tenant for which the variables should be retrieved. If no tenant alias is provided, the current tenant will be used.
 * @param  {Function}   callback            Standard callback method.
 * @param  {Object}     callback.err        An error object (if any)
 * @param  {Object[]}   callback.variables  The generated CSS.
 */
var getSkinVariables = module.exports.getSkinVariables = function(ctx, tenantAlias, callback) {
    tenantAlias = tenantAlias || ctx.tenant().alias;

    if (!ctx.user() || !ctx.user().isAdmin(tenantAlias)) {
        return callback({'code': 401, 'msg': 'Only administrators can retrieve the skin variables.'});
    }

    var applyTenantValues = function(err, skinVariables) {
        if (err) {
            return callback(err);
        }
        // Get the values for this tenant.
        var tenantVariables = _getTenantSkinVariableValues(tenantAlias);

        // Extend the skin variables into a new object, so we don't overwrite the global object.
        var variables = _.extend({}, skinVariables);

        // Add in the value.
        _.each(tenantVariables, function(value, key) {
            if (key && variables[key]) {
                variables[key].value = value;
            }
        });

        /*!
         * Morph it to a structure that the UI can use.
         * We'll return an array of groups of variables.
         * ex:
         *   [
         *      {'name': 'Group name A', variables: [ <var A1>, <var A2>, ... ]}
         *      {'name': 'Group name B', variables: [ <var B1>, <var B2>, ... ]}
         *   ]
         */
        var result = [];
        var groups = {};
        _.each(variables, function(variable, name) {
            groups[variable.group.name] = groups[variable.group.name] || {
                'name': variable.group.name,
                'index': variable.group.index,
                'variables': []
            };
            groups[variable.group.name].variables.push(variable);

        });

        // Give the group the the same order as the one it has in the LESS file.
        groups = _.values(groups).sort(function(a, b) { return b.index < a.index; });

        // Remove the unneeded index property of each group.
        _.each(groups, function(group) { delete group.index; });

        callback(null, groups);
    };


    if (cachedSkinVariables) {
        applyTenantValues(null, cachedSkinVariables);
    } else {
        _cacheSkinVariables(applyTenantValues);
    }
};

/**
 * Generates the skin file for a tenant.
 *
 * @param  {String}     tenantAlias     The alias of the tenant for which the skin should be generated.
 * @param  {Function}   callback        Standard callback method.
 * @param  {Object}     callback.err    An error object (if any)
 * @param  {String}     callback.css    The generated CSS.
 * @api private
 */
var _generateSkin = function(tenantAlias, callback) {
    // Get the custom values that the tenant admin specified.
    var tenant_variables = _getTenantSkinVariableValues(tenantAlias);

    // Parse the less file and supply the tenant values.
    _parseLessFile(tenant_variables, function(err, tree) {
        if (err) {
            return callback(err);
        }

        // Generate some CSS from the parse tree and cache it.
        // See http://lesscss.org/#usage (Configuration) for more information.
        try {
            cachedSkins[tenantAlias] = tree.toCSS({
                'yuicompress': true,
                'compress': true
            });
        } catch (error) {
            return callback({'code': 500, 'msg': error.message});
        }

        callback(null, cachedSkins[tenantAlias]);
    });
};

/**
 * Parses a LESS file and return the syntax tree.
 * You can pass in variables with some values that will override any values in the less file.
 * This can be used to set the tenant values and generate a parse tree for a tenant's skin file.
 *
 * @param  {Object}   [variables]       Object where the key is the LESS variable name (without the '@') and the value is the corresponding CSS value.
 * @param  {Object}   callback.err      An error object containing the error code and message.
 * @param  {Object}   callback.tree     The CSS syntax tree.
 * @api private
 */
var _parseLessFile = function(variables, callback) {
    variables = variables || [];

    // Read the skin file.
    getStaticFile(UIConstants.paths.BASE_SKIN, function(err, skin) {
        if (err) {
            log().error({'err': err}, 'Could not read the skin file.');
            return callback(err);
        }

        // Overwrite the default values.
        _.each(variables, function(value, key) {
            var re = new RegExp('^(@' + key + '): (.*);$', 'm');
            skin = skin.replace(re, '$1: ' + value + ';');
        });

        // Parse the less file.
        var parser = less.Parser();
        parser.parse(skin, function(err, tree) {
            if (err) {
                log().error({'err': err}, 'Could not parse the skin file.');
                return callback({'code': 500, 'msg': err});
            }

            callback(null, tree);
        });
    });
};

/**
 * Parses the skin file and retrieves the annotated LESS variables.
 *
 * @param  {Function}   callback              Standard callback method.
 * @param  {Object}     callback.err          An error object (if any)
 * @param  {String}     callback.variables    The generated CSS.
 * @api private
 */
var _cacheSkinVariables = function(callback) {
    _parseLessFile(null, function(err, tree) {
        if (err) {
            return callback(err);
        }

        var variables = {};

        /*!
         * Get all the variables out of the skin file.
         * Unfortunately we can't use tree.variables() as that doesn't give us the comments above it.
         * We loop over each rule in the less file and check for three rules
         *   1.  Is this rule a group comment?
         *       Group comment rules are used to put multiple variables into a "group".
         *
         *       Group comments look like:
         *       \/**************
         *         ** BRANDING **
         *         *************\/
         *
         *   2.  Is this rule a variable comment?
         *       Variable comments are rules that come right before a variable declaration.
         *       These are used to give each variable a description.
         *
         *   3.  Is this rule a variable declaration?
         *       Variables that can be re-used troughout the system.
         *       The 'type' of the variable will be determined by looking at the suffix of the variable name.
         *
         *       Looks like:
         *       \/* The background color for the body *\/    --> variable comment
         *       @body-background-color: #ECEAE5;           --> variable declaration, the variable is of type 'color'.
         */

        var group = 'Default';
        var groups = [];
        var groupRegex = new RegExp('^\/[\*]+\\n [\*]{2} ([a-zA-Z0-9 ]+) [\*]{2}\\n [\*]+\/\\n$');

        for (var i = 0; i < tree.rules.length; i++) {
            var rule = tree.rules[i];

            // 1. Group comment
            var groupMatch = null;
            if (rule.value && typeof rule.value === 'string' && (groupMatch = rule.value.match(groupRegex))) {
                // Get the name of this group.
                group = groupMatch[1];
                groups.push(group);
            } else if (rule.variable === true) {
                // Each variable should have some CSS documentation on top of it
                // that explains what the variable does.
                // This should be defined in the previous rule.
                var docRule = tree.rules[i-1];
                var description = 'TODO';
                if (docRule && docRule.value && typeof docRule.value === 'string' && docRule.value.substring(0, 2) === '/*') {
                    description = docRule.value.replace('/* ', '').replace('*/', '');
                }

                // Strip out the '@' sign from the token to get the variable name.
                var name = rule.name.substr(1);

                // Less variables don't have any type.
                // We determine the type by looking at the suffix in the variable name.
                var type = UIConstants.variables.types.STRING;
                if (/-color$/.test(name)) {
                    type = UIConstants.variables.types.COLOR;
                }
                if (/-url$/.test(name)) {
                    type = UIConstants.variables.types.URL;
                }

                variables[name] = {
                    'name': name,
                    'defaultValue': rule.value.toCSS({}),
                    'description': description,
                    'type': type,
                    'group': {
                        'name': group,
                        'index': groups.indexOf(group)
                    }
                };
            }
        }

        // Cache the variables.
        cachedSkinVariables = variables;

        callback(null, variables);
    });
};

/**
 * Retrieves the CSS values that a tenant has specified he wishes to use in the skin.
 * If the tenant values could not be parsed an empty object will be returned.
 *
 * @param  {String} tenantAlias The alias of the tenant for which the values should be retrieved.
 * @return {Object}             The CSS values keyed by the LESS variable name (without the '@'.)
 */
var _getTenantSkinVariableValues = function(tenantAlias) {
    try {
        var variables = uiConfig.getValue(tenantAlias, 'skin', 'variables');
        return JSON.parse(variables);
    } catch (err) {
        log().warn({'err': err}, 'Could not parse the tenant variables, the default skin will be used.');
        return {};
    }
};
