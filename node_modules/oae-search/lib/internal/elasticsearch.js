/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var _ = require('underscore');
var ElasticSearchClient = require('elasticsearchclient');
var log = require('oae-logger').logger('elasticsearchclient');
var Telemetry = require('oae-telemetry').telemetry('search');

var index = null;
var client = null;

/**
 * Refresh the search configuration with the given options.
 *
 * @param  {String}    index       The index to use
 * @param  {Object}    serverOpts  The server opts with which to configure the client
 */
var refreshSearchConfiguration = module.exports.refreshSearchConfiguration = function(_index, serverOpts) {
    index = _index;
    client = new ElasticSearchClient(serverOpts);
    log().info({
        'config': {
            'index': _index,
            'serverOpts': serverOpts
        }
    }, 'Refreshed search configuration.');
};

/**
 * Create an index with the specified name.
 *
 * @param  {String}      indexName       The name of the index
 * @param  {Object}      settings        The settings of the ElasticSearch index
 * @param  {Function}    callback        Invoked when the proces completes
 * @param  {Object}      callback.err    An error that occurred, if any
 */
var createIndex = module.exports.createIndex = function(indexName, settings, callback) {
    indexExists(indexName, function(err, exists) {
        if (err) {
            return callback(err);
        }

        if (!exists) {
            log().info({
                'indexName': indexName,
                'indexSettings': settings
            }, 'Creating new search index.');

            _exec('createIndex', client.createIndex(indexName, settings, null), callback);
        } else {
            return callback();
        }
    });
};

/**
 * Delete the index with the given name.
 *
 * @param  {String}    indexName       The name of the index to delete
 * @param  {Function}  callback        Invoked when the process completes
 * @param  {Object}    callback.err    An error that occurred, if any
 */
var deleteIndex = module.exports.deleteIndex = function(indexName, callback) {
    indexExists(indexName, function(err, exists) {
        if (err) {
            return callback(err);
        }

        if (exists) {
            log().info('Deleting index "%s"', indexName);
            _exec('deleteIndex', client.deleteIndex(indexName, null), callback);
        } else {
            return callback();
        }
    });
};

/**
 * Determine whether or not the specified index exists.
 *
 * @param  {String}      indexName       The name of the index to test
 * @param  {Function}    callback        Invoked when the process completes
 * @param  {Object}      callback.err    An error that occurred, if any
 * @param  {Boolean}     callback.exists Whether or not the index exists
 */
var indexExists = module.exports.indexExists = function(indexName, callback) {
    _exec('indexStatus', client.status(indexName, null), function(err) {
        if (err && err.error === 'IndexMissingException[[' + indexName + '] missing]') {
            return callback(null, false);
        } else if (err) {
            return callback(err);
        } else {
            return callback(null, true);
        }
    });
};

/**
 * Refresh the current index so that all its documents are available for querying.
 *
 * @param  {Function}    callback        Invoked when the process completes
 * @param  {Object}      callback.err    An error that occurred, if any
 */
var refresh = module.exports.refresh = function(callback) {
    _exec('refresh', client.refresh(index, null), callback);
};

/**
 * Create a type mapping that can be searched. The type mappings use the elastic search type mapping specification, as described
 * in the ElasticSearch documentation: http://www.elasticsearch.org/guide/reference/api/admin-indices-put-mapping.html
 *
 * @param  {String}    typeName            The name of the type. Should be unique across the application.
 * @param  {Object}    fieldProperties     The field schema properties for the type, as per ElasticSearch mapping spec.
 * @param  {Object}    [opts]              Advanced mapping options
 * @param  {String}    [opts._parent]      The parent document type, if applicable
 * @param  {Boolean}   [opts._source]      Whether or not the _source document should be enabled. Defaults to `true`.
 * @param  {Function}  callback            Invoked when the process completes
 * @param  {Object}    callback.err        An error that occurred, if any
 */
var putMapping = module.exports.putMapping = function(typeName, fieldProperties, opts, callback) {
    opts = opts || {};

    mappingExists(typeName, function(err, exists) {
        if (err) {
            return callback(err);
        }

        if (!exists) {

            // Apply the default _source value if necessary
            if (opts._source !== false) {
                opts._source = true;
            }

            var data = {};
            data[typeName] = {
                '_source': {
                    'enabled': opts._source
                },
                'properties': fieldProperties
            };

            if (opts._parent) {
                data[typeName]._parent = {'type': opts._parent};
            }

            log().info({'typeData': data}, 'Creating new search type mapping.');

            _exec('putMapping', client.putMapping(index, typeName, data), callback);
        } else {
            return callback();
        }
    });
};

/**
 * Determine whether or not the mapping exists.
 *
 * @param  {String}    typeName        The name of the type to map.
 * @param  {Function}  callback        Invoked when the process completes.
 * @param  {Object}    callback.err    An error that occurred, if any
 */
var mappingExists = module.exports.mappingExists = function(typeName, callback) {
    _exec('getMapping', client.getMapping(index, typeName, null), function(err, data) {
        if (err && err.error === 'TypeMissingException[[' + index + '] type[' + typeName + '] missing]') {
            return callback(null, false);
        } else if (err) {
            return callback(err);
        } else {
            return callback(null, true);
        }
    });
};

/**
 * Search ElasticSearch using the given query.
 *
 * @param  {Object}    query           The query object
 * @param  {Object}    options         Options to send with the query
 * @param  {Function}  callback        Invoked when the process completes
 * @param  {Object}    callback.err    An error that occurred, if any
 * @param  {Object}    callback.data   The response of the query
 */
var search = module.exports.search = function(query, options, callback) {
    log().trace({ 'query': query }, 'Querying elastic search.');
    return _exec('search', client.search(index, query, options), callback);
};

/**
 * Index the given document in ElasticSearch.
 *
 * @param  {String}    typeName        The type of document to index
 * @param  {String}    id              The id of the document to index
 * @param  {Object}    doc             The document to index
 * @param  {Object}    options         The querystring options to send with the index call
 * @param  {Function}  callback        Invoked whent he process completes
 * @param  {Object}    callback.err    An error that occurred, if any
 */
var index = module.exports.index = function(typeName, id, doc, options, callback) {
    log().trace({ 'typeName': typeName, 'id': id, 'document': doc, 'options': options }, 'Indexing a document.');
    return _exec('index', client.index(index, typeName, doc, id, options), callback);
};

/**
 * Index a bulk number of documents in ElasticSearch.
 *
 * @param  {Object[]}  operations      An array of ordered operations, as per the ElasticSearch Bulk API specification
 * @param  {Function}  callback        Invoked whent he process completes
 * @param  {Object}    callback.err    An error that occurred, if any
 */
var bulk = module.exports.bulk = function(operations, callback) {
    var numOps = 0;
    for (var i = 0; i < operations.length; i++) {
        var meta = operations[i];
        var keys = _.keys(meta);
        // Verify this is a metadata line, then apply the index
        if (keys.length === 1 && (meta['create'] || meta['index'] || meta['delete'])) {
            numOps++;
            var opName = keys[0];
            meta[opName]['_index'] = index;
        }
    }

    log().trace({'operations': operations}, 'Performing a bulk set of %s operations.', numOps);
    return _exec('bulk', client.bulk(operations, null), callback);
};

/**
 * Delete the document identified by the document id from the index.
 *
 * @param  {String}    typeName        The type of document to delete
 * @param  {Object}    id              The id of the document to delete
 * @param  {Function}  callback        Invoked whent he process completes
 * @param  {Object}    callback.err    An error that occurred, if any
 */
var del = module.exports.del = function(typeName, id, callback) {
    log().trace({ 'typeName': typeName, 'documentId': id }, 'Deleting an index document.');
    return _exec('delete', client.deleteDocument(index, typeName, id, null), callback);
};

/**
 * Execute a call to the ElasticSearchClient API.
 *
 * @param  {String}              name            The name of the method
 * @param  {ElasticSearchCall}   call            The call object that will be executed
 * @param  {Function}            callback        Invoked when th eprocess completes
 * @param  {Object}              callback.err    An error that occurred, if any
 * @param  {Object}              callback.data   The search response data, if any
 * @api private
 */
var _exec = function(name, call, callback) {
    callback = callback || function() {};

    Telemetry.incr(name);
    var start = Date.now();
    var data = null;
    var err = null;

    // Grab the data
    call.data(function(_data) {
        data = _data;
    });

    // When finished, call the callback with the data
    call.done(function() {
        // Data should always be JSON, I think.
        try {
            data = JSON.parse(data);
            log().trace({ 'call': name, 'data': data }, 'Search execution completed.');
        } catch (ex) {
            log().trace({ 'call': name, 'data': data }, 'Search execution completed.');
            _logError(name, ex);
            return callback(new Error('Non-JSON body returned in response.'));
        }

        // ElasticSearch returns an object with an error attribute if there is an error
        if (data.error) {
            // We don't implicitly log this because it could be intended
            return callback(data);
        }

        Telemetry.appendDuration('exec.' + name + '.time', start);
        return callback(null, data);
    });

    // When there is an error, call the callback with the error
    call.error(function(err) {
        _logError(name, err);
        return callback(err);
    });

    call.exec();
};

/**
 * Logs the given error and applies telemetry udpates.
 *
 * @param  {String} callName The name of the call that err'd
 * @param  {Object} err      The error to log.
 * @api private
 */
var _logError = function(callName, err) {
    Telemetry.incr('exec.' + callName + '.error.count');
    log().error({ 'err': err }, 'Error executing %s query.', callName);
};
