/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var sanitize = require('validator').sanitize;
var util = require('util');

var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;
var ActivityModel = require('oae-activity/lib/model');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var Config = require('oae-config').config('oae-principals');
var Signature = require('oae-util/lib/signature');
var TenantsUtil = require('oae-tenants/lib/util');
var TZ = require('oae-util/lib/tz');

var Group = require('./model').Group;
var PrincipalsConstants = require('oae-principals/lib/constants').PrincipalsConstants;
var PrincipalsDAO = require('./internal/dao');
var User = require('./model').User;

/**
 * Gets a principal.
 * In case the principalId is a userId, Redis will be checked first. If it could not be
 * found there or if Redis failed to respond to the request, Cassandra will be checked.
 *
 * @param  {Context}    ctx                 The current context
 * @param  {String}     principalId         The ID of the principal that should be retrieved.
 * @param  {Function}   callback            A callback method.
 * @param  {Object}     callback.err        An error object (if any)
 * @param  {Group|User} callback.principal  The asked for principal.
 */
var getPrincipal = module.exports.getPrincipal = function(ctx, principalId, callback) {
    PrincipalsDAO.getPrincipal(principalId, function(err, principal) {
        if (err) {
            return callback(err);
        }

        _generatePictureURLs(ctx, principal);

        if (isUser(principalId)) {
            hideUserData(ctx, principal);
        }
        return callback(null, principal);
    });
};

/**
 * Gets a set of principals (user or groups). This method *will* return an error if some of the principals
 * don't exist.
 *
 * @param  {Context}   ctx                         The current context
 * @param  {String[]}  principalIds                The ID of the principal that should be retrieved.
 * @param  {Object}    callback.err                If an unexpected systemic error occurred, or if any of the given principals did not exist
 * @param  {String[]}  callback.err.existing       The ids of the principals that existed
 * @param  {String[]}  callback.err.missing        The ids of the principals that did not exist
 * @param  {Object}    callback.principals         Object representing the retrieved principals. The keys will be the principal ids and the values will be the principal basic profiles
 */
var getPrincipals = module.exports.getPrincipals = function(ctx, principalIds, callback) {
    PrincipalsDAO.getPrincipals(principalIds, function(err, principals) {
        if (err) {
            return callback(err);
        }

        var principalValues = _.values(principals);
        for (var i = 0; i < principalValues.length; i++) {
            var principal = principalValues[i];
            _generatePictureURLs(ctx, principal);
            if (isUser(principal.id)) {
                hideUserData(ctx, principal);
            }
        }

        return callback(null, principals);
    });
};

/**
 * Determine whether or not the given string represents a group id.
 *
 * @param  {String}  groupId    A string that may or may not be a group id
 * @return {Boolean}            Whether or not the provided identifier is a group identifier.
 */
var isGroup = module.exports.isGroup = function(groupId) {
    return PrincipalsDAO.isGroup(groupId);
};

/**
 * Determine whether or not the given string represents a user id.
 *
 * @param  {String}  userId     A string that may or may not be a user id
 * @return {Boolean}            Whether or not the provided identifier is a user identifier.
 */
var isUser = module.exports.isUser = function(userId) {
    return PrincipalsDAO.isUser(userId);
};

/**
 * Hides sensitive user information that the (possibly anonymous) user in context does not have access to see.
 *
 * If the current user has no access to the user, then the following will be scrubbed:
 *
 *  1. The displayName will be replaced by the publicAlias
 *  2. The following fields will be deleted
 *      ** publicAlias
 *      ** timezone
 *      ** locale
 *      ** extra
 *      ** smallPicture
 *      ** smallPictureUri
 *      ** mediumPicture
 *      ** mediumPictureUri
 *      ** largePicture
 *      ** largePictureUri
 *
 * If the user has access but is not the user themself, the publicAlias is scrubbed from the user.
 *
 * @param  {Context}     ctx     The current context
 * @param  {User}        user    The user object to hide as necessary
 * @api private
 */
var hideUserData = module.exports.hideUserData = function(ctx, user) {
    var isAnon = !ctx.user();
    var isLoggedIn = TenantsUtil.isLoggedIn(ctx, user.tenant.alias);
    var isTargetUser = (!isAnon && ctx.user().id === user.id);
    var isAdmin = (!isAnon && ctx.user().isAdmin && ctx.user().isAdmin(user.tenant.alias));

    if (isAdmin || isTargetUser) {
        return user;
    }

    // Hide the sensitive profile information if the user has limited access
    if ((user.visibility === AuthzConstants.visibility.LOGGEDIN && !isLoggedIn) ||
        (user.visibility === AuthzConstants.visibility.PRIVATE && !isTargetUser)) {

        user.displayName = user.publicAlias;
        user.picture = {};
        delete user.extra;

        // The profile path should be removed from the user object as well. This will tell the UI
        // when to offer a link to the profile page and when not to
        delete user.profilePath;
    }

    // Always delete these guys if it is not the target user or admin
    delete user.email;
    delete user.publicAlias;
    delete user.timezone;
    delete user.locale;
    delete user.notificationsUnread;
    delete user.notificationsLastRead;
};

/**
 * Given a user object, apply the given set of basic profile updates and return the updated user. Basically this means
 * that if a given field is not part of the core basic profile fields, it will be applied to the `extra` object instead.
 *
 * @param  {User}      user         The user object on which to apply the updates
 * @param  {Object}    fieldUpdates An object of fieldKey -> value of the field updates to apply to the user object
 * @return {User}                   The updated user with all field updates applied
 */
var createUpdatedUser = module.exports.createUpdatedUser = function(user, fieldUpdates) {
    var newDisplayName = fieldUpdates.displayName || user.displayName;
    var newUser = new User(user.tenant.alias, user.id, newDisplayName, {
        'visibility': fieldUpdates.visibility || user.visibility,
        'email': fieldUpdates.email || user.email,
        'locale': fieldUpdates.locale || user.locale,
        'timezone': fieldUpdates.timezone || user.timezone,
        'publicAlias': fieldUpdates.publicAlias || user.publicAlias,
        'notificationsUnread': fieldUpdates.notificationsUnread || user.notificationsUnread,
        'notificationsLastRead': fieldUpdates.notificationsLastRead || user.notificationsLastRead,
        'isGlobalAdmin': user.isGlobalAdmin(),
        'isTenantAdmin': user.isTenantAdmin(user.tenant.alias)
    });

    // Extract and apply the extra properties
    var extra = PrincipalsDAO.getExtraData(user, fieldUpdates);
    if (extra) {
        newUser.extra = extra;
    }
    return newUser;
};

//////////////////////////////
// ACTIVITY UTILITY METHODS //
//////////////////////////////

/**
 * Create the persistent user entity that can be transformed into an activity entity for the UI.
 *
 * @param  {String}    userId      The ID of the user
 * @param  {User}      [user]      The user that supplies the data for the entity
 * @return {Object}                An object containing the entity data that can be transformed into a UI user activity entity
 */
var createPersistentUserActivityEntity = module.exports.createPersistentUserActivityEntity = function(userId, user) {
    var persistentEntity = {'objectType': 'user', 'user': user};
    persistentEntity[ActivityConstants.properties.OAE_ID] = userId;
    return persistentEntity;
};

/**
 * Create a user activity entity that can be used in an activity stream.
 *
 * For more details on the transformed entity model, @see ActivityAPI#registerActivityEntityTransformer
 *
 * @param  {Tenant}            tenant      The tenant of the user
 * @param  {String}            userId      The id of the user
 * @param  {User}              [user]      The user object. If not specified, the generated entity with be abbreviated with just the information available
 * @return {ActivityEntity}                The activity entity that represents the given user data
 */
var transformPersistentUserActivityEntity = module.exports.transformPersistentUserActivityEntity = function(ctx, userId, user) {
    var tenant = ctx.tenant();
    var baseUrl = TenantsUtil.getBaseUrl(tenant);
    var globalId = baseUrl + '/api/user/' + userId;
    var profileUrl = baseUrl + user.profilePath;

    var opts = {'ext': {}};
    opts.ext[ActivityConstants.properties.OAE_ID] = userId;

    if (user) {
        hideUserData(ctx, user);
        _generatePictureURLs(ctx, user);

        opts.displayName = user.displayName;
        if (user.profilePath) {
            opts.url = profileUrl;

            if (user.picture.small) {
                opts.ext[ActivityConstants.properties.OAE_THUMBNAIL] = new ActivityModel.ActivityMediaLink(user.picture.small, PrincipalsConstants.picture.size.SMALL , PrincipalsConstants.picture.size.SMALL);
            }

            if (user.picture.medium) {
                opts.image = new ActivityModel.ActivityMediaLink(user.picture.medium, PrincipalsConstants.picture.size.MEDIUM , PrincipalsConstants.picture.size.MEDIUM);
            }
        }

        opts.ext[ActivityConstants.properties.OAE_VISIBILITY] = user.visibility;
        opts.ext[ActivityConstants.properties.OAE_PROFILEPATH] = user.profilePath;
    }

    return new ActivityModel.ActivityEntity('user', globalId, opts);
};

/**
 * Create the persistent group entity that can be transformed into an activity entity for the UI.
 *
 * @param  {String}    groupId     The ID of the group
 * @param  {Group}     [group]     The group that supplies the data for the entity. If not specified, only the minimal data will be returned for transformation.
 * @return {Object}                An object containing the entity data that can be transformed into a UI group activity entity
 */
var createPersistentGroupActivityEntity = module.exports.createPersistentGroupActivityEntity = function(groupId, group) {
    var persistentEntity = {'objectType': 'group', 'group': group};
    persistentEntity[ActivityConstants.properties.OAE_ID] = groupId;
    return persistentEntity;
};

/**
 * Create a group activity entity that can be used in an activity stream.
 *
 * For more details on the transformed entity model, @see ActivityAPI#registerActivityEntityTransformer
 *
 * @param  {Tenant}            tenant      The tenant of the group
 * @param  {String}            groupId     The id of the group
 * @param  {User}              [group]     The group object. If not specified, the generated entity with be abbreviated with just the information available
 * @return {ActivityEntity}                The activity entity that represents the given group data
 */
var transformPersistentGroupActivityEntity = module.exports.transformPersistentGroupActivityEntity = function(ctx, groupId, group) {
    var tenant = ctx.tenant();
    var baseUrl = TenantsUtil.getBaseUrl(tenant);
    var profileUrl = baseUrl + group.profilePath;

    // Note that the globalId is used as a canonical reference and should not depend on whether or not
    // the tenant is using http or https.
    var globalId = 'http://' + tenant.host + '/api/group/' + groupId;

    var opts = {'ext': {}};
    opts.ext[ActivityConstants.properties.OAE_ID] = groupId;

    if (group) {
        _generatePictureURLs(ctx, group);

        opts.displayName = group.displayName;
        opts.url = profileUrl;

        if (group.picture.small) {
            opts.ext[ActivityConstants.properties.OAE_THUMBNAIL] = new ActivityModel.ActivityMediaLink(group.picture.small, PrincipalsConstants.picture.size.SMALL , PrincipalsConstants.picture.size.SMALL);
        }

        if (group.picture.medium) {
            opts.image = new ActivityModel.ActivityMediaLink(group.picture.medium, PrincipalsConstants.picture.size.MEDIUM , PrincipalsConstants.picture.size.MEDIUM);
        }

        // Extension properties
        opts.ext[ActivityConstants.properties.OAE_VISIBILITY] = group.visibility;
        opts.ext[ActivityConstants.properties.OAE_PROFILEPATH] = group.profilePath;
        opts.ext[ActivityConstants.properties.OAE_JOINABLE] = group.joinable;
    }

    return new ActivityModel.ActivityEntity('group', globalId, opts);
};

/**
 * Generates picture URLs for a principal. The urls will be signed with the current user his tenant alias.
 *
 * @param  {Context}     ctx         The current context
 * @param  {Group|User}  principal   The principal to generate the picture URLs for.
 * @api private
 */
var _generatePictureURLs = function(ctx, principal) {
    if (principal.picture.smallUri) {
        principal.picture.small = getSignedPictureUrl(ctx, ctx.tenant().alias, principal.picture.smallUri);
    }
    if (principal.picture.mediumUri) {
        principal.picture.medium = getSignedPictureUrl(ctx, ctx.tenant().alias, principal.picture.mediumUri);
    }
    if (principal.picture.largeUri) {
        principal.picture.large = getSignedPictureUrl(ctx, ctx.tenant().alias, principal.picture.largeUri);
    }
};

/**
 * Generates a url on which the picture can be downloaded.
 * The download link will expire around the second day of the next month so it can be cached for a while.
 * The url will only be valid on the current tenant.
 *
 * @param  {Context}    ctx     Standard context object, representing the currently logged in user and its tenant
 * @param  {String}     tenant  The tenant alias on which this signature is valid.
 * @param  {String}     uri     The URI of the picture.
 * @return {String}             An URL where the picture can be downloaded.
 */
var getSignedPictureUrl = module.exports.getSignedPictureUrl = function(ctx, tenant, uri) {
    var settings = _getProfilePictureExpireSettings(tenant);
    var principalId = (ctx.user()) ? ctx.user().id : '';
    var body = principalId + ':' + uri;
    var sig = Signature.createRollingSignature(tenant, settings.duration, settings.offset, body);
    return util.format('/api/download/signed?uri=%s&signature=%s&expires=%s', uri, sig.signature, sig.expires);
};

/**
 * Retrieves the expire settings from the config.
 *
 * @param  {String} tenantAlias The alias of the tenant for which we should retrieve the preview expire settings.
 * @return {Object}             An object that holds a duration and offset to generate a rolling expiring signature.
 */
var _getProfilePictureExpireSettings = function(tenantAlias) {
    var min = parseInt(Config.getValue(tenantAlias, 'picture', 'expiration_minimum'), 10);
    var max = parseInt(Config.getValue(tenantAlias, 'picture', 'expiration_maximum'), 10);
    return {
        'duration': max - min,
        'offset': min
    };
};
