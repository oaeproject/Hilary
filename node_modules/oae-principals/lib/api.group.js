/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var ShortId = require('shortid');

var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzUtil = require('oae-authz/lib/util');
var Config = require('oae-config/lib/api').config('oae-principals');
var LibraryAPI = require('oae-library');
var log = require('oae-logger').logger('oae-principals');
var OaeUtil = require('oae-util/lib/util');
var Signature = require('oae-util/lib/signature');
var TenantsUtil = require('oae-tenants/lib/util');
var Validator = require('oae-authz/lib/validator').Validator;

var Group = require('./model.group').Group;
var PrincipalsConstants = require('./constants').PrincipalsConstants;
var PrincipalsDAO = require('./internal/dao');
var PrincipalsEmitter = require('./internal/emitter');
var PrincipalsUtil = require('./util');

/**
 * Get the basic profile for a group.
 *
 * @param  {Context}  ctx             The current context.
 * @param  {String}   groupId         An identifier for a group. ex: g:cam:oae-team
 * @param  {Function} callback        A standard callback method takes arguments `err` and `group`.
 * @param  {Object}   callback.err    An error object (if any.)
 * @param  {Group}    callback.group  The group object
 */
var getGroup = module.exports.getGroup = function(ctx, groupId, callback) {
    var validator = new Validator();
    validator.check(groupId, {'code': 400,'msg': 'An invalid group id was specified'}).isGroupId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    PrincipalsUtil.getPrincipal(ctx, groupId, callback);
};

/**
 * Gets a full group profile. In addition to the basic profile, this includes access information such as:
 *  `isManager`: Whether or not the user in context can manage the group
 *  `isMember`: Whether or not the user in context is a member of the group
 *  `canJoin`: Whether or not the user in context can join the group
 *
 * This also differs from `getGroup` in that if the current user is not allowed to access the group, rather than "scrubbing" sensitive information from the group, it will send back a 401 error.
 *
 * @param  {Context}   ctx             The current context.
 * @param  {String}    groupId         The group identifier.
 * @param  {Function}  callback        A standard callback method takes arguments `err` and `group`.
 * @param  {Object}    callback.err    An error object (if any.)
 * @param  {Group}     callback.group  The agumented group object
 */
var getFullGroupProfile = module.exports.getFullGroupProfile = function(ctx, groupId, callback) {
    getGroup(ctx, groupId, function(err, group) {
        if (err) {
            return callback(err);
        }

        // Determine what roles, if any, the current user has on the group
        _getAllRoles(ctx, groupId, function(err, roles) {
            if (err) {
                return callback(err);
            }

            var hasRole = (!_.isEmpty(roles));
            if (!_canView(ctx, group, hasRole)) {
                return callback({'code': 401, 'msg': 'You do not have access to this group'});
            }

            // A tenant or global administrator should be marked as a member and a manager
            var isAdmin =  (ctx.user() && ctx.user().isAdmin(group.tenant.alias));

            group.isMember = (isAdmin || _.contains(roles, PrincipalsConstants.roles.MEMBER) || _.contains(roles, PrincipalsConstants.roles.MANAGER));
            group.isManager = (isAdmin || _.contains(roles, PrincipalsConstants.roles.MANAGER));
            group.canJoin = _canJoin(ctx, group, hasRole);

            if (group.isMember) {
                // Generate a signature that can be used for push notifications
                group.signature = Signature.createExpiringResourceSignature(ctx, groupId);

            }

            return callback(null, group);
        });
    });
};

/**
 * Convenience function to get all explicit roles a user has on a group. This handles the
 * anonymous check on the provided context.
 *
 * @param  {Context}    ctx             The context of the current request
 * @param  {String}     groupId         The id of the group whose membership to check
 * @param  {Function}   callback        Standard callback method
 * @param  {Object}     callback.err    An error that occurred, if any
 * @param  {String[]}   callback.roles  The explicit roles the user has in the group, if any
 * @api private
 */
var _getAllRoles = function(ctx, groupId, callback) {
    if (!ctx.user()) {
        // Anonymous user cannot have any explicit role
        return callback(null, []);
    }

    return AuthzAPI.getAllRoles(ctx.user().id, groupId, callback);
};

/**
 * Internal function that checks whether or not the current user can view a group.
 * This also takes into account whether or not the group is joinable.
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {Group}          group               The group object representing the group we're checking access for
 * @param  {Boolean}        hasRole             Whether or not the current user has a role in the group
 * @return {Boolean}                            Whether or not the current user has access to the group
 * @api private
 */
var _canView = function(ctx, group, hasRole) {
    if (group.visibility === AuthzConstants.visibility.PUBLIC) {
        return true;

    // If we have a role in the group we can always view it
    } else if (hasRole) {
        return true;

    // For the following checks, we're dealing with users who are not a member of the group

    // An anonymous user can never see a non-public group
    } else if (!ctx.user()) {
        return false;

    // If I am from the same tenant and the group is loggedin, I can see it
    } else if (TenantsUtil.isLoggedIn(ctx, group.tenant.alias) && group.visibility === AuthzConstants.visibility.LOGGEDIN) {
        return true;

    // If I am from the same tenant and the group is private, I can only see it if it is joinable
    } else if (TenantsUtil.isLoggedIn(ctx, group.tenant.alias) && group.visibility === AuthzConstants.visibility.PRIVATE &&
        group.joinable !== AuthzConstants.joinable.NO) {
        return true;

    // If the user is admin of the group's tenant, they have access
    } else if (ctx.user().isAdmin(group.tenant.alias)) {
        return true;
    }

    // In all other cases the user can't view the group
    return false;
};

/**
 * Get all the members of a group. If the group is set as private (or loggedin and the current user is anonymous)
 * this will return a 401 error.
 *
 * @param  {Context}   ctx                     The current execution context.
 * @param  {String}    groupId                 An identifier for a group. ex: g:cam-oae-team
 * @param  {String}    start                   The principalId that comes just before the first principal you wish to have in your results.
 * @param  {Number}    limit                   The number of members you wish to retrieve.
 * @param  {Function}  callback                Standard callback method that has an error if it occurs and an array of the direct members of a group.
 * @param  {Object}    callback.err            An error object (if any.)
 * @param  {User[]}    callback.members        An array of the direct members of the group
 * @param  {String}    callback.nextToken      The value to provide in the `start` parameter to get the next set of results
 */
var getGroupMembers = module.exports.getGroupMembers = function(ctx, groupId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(groupId, {'code': 400,'msg': 'An invalid group id was specified'}).isGroupId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure that this group exists
    getGroup(ctx, groupId, function(err, group) {
        if (err) {
            return callback(err);
        }

        // Ensure proper permissions
        canViewMembers(ctx, group, function(err, canViewMembers) {
            if (err) {
                return callback(err);
            } else if (!canViewMembers) {
                return callback({'code': 401, 'msg': 'Insufficient privilege to view this group\'s members list.'});
            }

            // Finally get the members and their basic profiles
            AuthzAPI.getAuthzMembers(groupId, start, limit, function(err, members, nextToken) {
                if (err) {
                    return callback(err);
                }

                var memberIds = _.map(members, function(member) { return member.id; });
                PrincipalsUtil.getPrincipals(ctx, memberIds, function(err, memberProfiles) {
                    if (err) {
                        return callback(err);
                    }

                    var memberList = [];
                    for (var m = 0; m < members.length; m++) {
                        var member = members[m].id;
                        if (memberProfiles[member]) {
                            memberList.push({
                                'profile': memberProfiles[member],
                                'role': members[m].role
                            });
                        }
                    }

                    return callback(null, memberList, nextToken);
                });
            });
        });
    });
};

/**
 * Gets all the memberships library of the provided user or group
 *
 * @param  {Context}     ctx                     The current execution context
 * @param  {String}      principalId             The principal to retrieve all the groups for
 * @param  {String}      start                   The principalId that comes just before the first principal you wish to have in your results
 * @param  {Number}      limit                   The number of parent principals you wish to retrieve (default: 10)
 * @param  {Function}    callback                Standard callback method invoked when the process completes takes arguments `err` and `groups`
 * @param  {Object}      callback.err            An error that occured, if any
 * @param  {Group[]}     callback.groups         An (inconsistently ordered) array of groups to which the user belongs, either directly or indirectly
 * @param  {String}      callback.nextToken      The value to provide in the `start` parameter to get the next set of results
 */
var getMembershipsLibrary = module.exports.getMembershipsLibrary = function(ctx, principalId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'Must specify a valid principalId'}).isPrincipalId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    PrincipalsDAO.getPrincipal(principalId, function(err, principal) {
        if (err) {
            return callback(err);
        }

        LibraryAPI.Authz.resolveTargetLibraryAccess(ctx, principal, function(err, hasAccess, visibility) {
            if (err) {
                return callback(err);
            } else if (!hasAccess) {
                return callback({'code': 401, 'msg': 'You do not have access to this memberships library'});
            }

            _listLibraryItems(principalId, visibility, start, limit, function(err, groupIds, nextToken) {
                if (err) {
                    return callback(err);
                }

                PrincipalsUtil.getPrincipals(ctx, groupIds, function(err, groupsHash) {
                    if (err) {
                        return callback(err);
                    }

                    var results = _.map(groupIds, function(groupId) {
                        return groupsHash[groupId];
                    });

                    return callback(null, results, nextToken);
                });
            });
        });
    });
};

/**
 * Get the library items for the given principal and visibility. If the visibility is private, the library will be
 * pulled from the AuthzAPI, as it must contain the indirect group memberships.
 *
 * @param  {String}     principalId         The id of the principal whose membership library to fetch
 * @param  {String}     visibility          The visibility of the library feed to fetch
 * @param  {String}     start               The point from which to start listing this page of items. The value that goes into this parameter should come from the `nextToken` result of an invocation with the *same visibility*
 * @param  {Number}     limit               The maximum number of items to fetch
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {String[]}   callback.groupIds   The ids of the groups that are a in the requested library
 * @param  {String}     callback.nextToken  The value to use for the next request to this method to get the next page of group ids
 * @api private
 */
var _listLibraryItems = function(principalId, visibility, start, limit, callback) {
    if (visibility === AuthzConstants.visibility.PRIVATE) {
        return AuthzAPI.getPrincipalMemberships(principalId, start, limit, callback);
    } else {
        return LibraryAPI.Index.list(PrincipalsConstants.library.MEMBERSHIPS_INDEX_NAME, principalId, visibility, {'start': start, 'limit': limit}, callback);
    }
};

/**
 * Set, update or remove the role for group memberChanges.
 *
 * @param  {Context}     ctx             The current execution context
 * @param  {String}      groupId         The identifier of a group. ex: g:cam:oae-team
 * @param  {Object}      memberChanges   Object where the keys represent the principal ids which should be updated/added/removed. The value is a string representing the new role. If false is passed in, the membership for that principal will be removed e.g. {'user1': 'manager', 'user2': 'viewer', 'user3': false}
 * @param  {Function}    [callback]      A function executed when the process has completed takes arguments `err` and `added`
 * @param  {Object}      [callback.err]  The error that occured, if any
 */
var setGroupMembers = module.exports.setGroupMembers = function(ctx, groupId, memberChanges, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({
                'err': err,
                'groupId': groupId,
                'changes': memberChanges
            }, 'Error updating group membership.');
        }
    };
    memberChanges = memberChanges || {};

    // Validation
    var principals = _.keys(memberChanges);
    var validator = new Validator();
    validator.check(groupId, {'code': 400, 'msg': 'Invalid groupId specified'}).isGroupId();
    validator.check(principals.length, {'code': 400, 'msg': 'You should specify at least 1 user/group on which to update group membership'}).min(1);
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update group membership'}).isLoggedInUser(ctx);
    for (var i = 0; i < principals.length;i++) {
        validator.check(principals[i], {'code': 400, 'msg': 'You cannot make the group a member of itself'}).not(groupId);
        validator.check(principals[i], {'code': 400, 'msg': 'Invalid principal specified as member for this group.'}).isPrincipalId();
        validator.check(memberChanges[principals[i]], {'code': 400, 'msg': 'Invalid principal specified as member for this group.'}).isValidRoleChange();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the group exists
    PrincipalsDAO.getPrincipal(groupId, function(err, group) {
        if (err) {
            return callback(err);
        }

        // Make sure we can manage the group
        _canManage(ctx, group, function(err, canManage) {
            if (err) {
                return callback(err);
            } else if (!canManage) {
                return callback({'code': 401, 'msg': 'You are not authorized to update the members of this group'});
            }

            // Get the expected membership after the changes have been applied and ensure there is still a manager
            AuthzAPI.computeMemberRolesAfterChanges(groupId, memberChanges, function(err, computedPermissions, newMemberIds, updatedMemberIds, removedMemberIds) {
                if (err) {
                    return callback(err);
                } else if (!_.chain(computedPermissions).values().contains(PrincipalsConstants.roles.MANAGER).value()) {
                    return callback({'code': 400, 'msg': 'The requested operation would leave the group without a manager'});
                }

                // Ensure that we are not associating new members to this group that violate tenant interaction boundaries
                PrincipalsDAO.getPrincipals(newMemberIds, null, function(err, newMembers) {
                    if (err) {
                        return callback(err);
                    }

                    newMembers = _.values(newMembers);

                    AuthzAPI.canInteract(ctx, group.tenant.alias, newMembers, function(err, canInteract, illegalPrinicpalIds) {
                        if (err) {
                            return callback(err);
                        } else if (!canInteract) {
                            return callback({'code': 401, 'msg': 'You are not authorized to make these users a member of the group: ' + illegalPrinicpalIds.join(', ')});
                        }

                        // Update the roles in the Authz lists
                        AuthzAPI.updateRoles(group.id, memberChanges, function(err) {
                            if (err) {
                                return callback(err);
                            }

                            var oldLastModified = group.lastModified;
                            var newLastModified = Date.now().toString();
                            PrincipalsDAO.updatePrincipal(group.id, {'lastModified': newLastModified}, function(err) {
                                if (err) {
                                    return callback(err);
                                }

                                group.lastModified = newLastModified;

                                // Remove from libraries of users who have been removed from the group. This should be done
                                // before replying to the user to ensure subsequent requests to libraries by the user will
                                // not indicate the group is still in the library
                                _removeMembershipsLibraries(removedMemberIds, group.id, oldLastModified, function(err) {
                                    if (err) {
                                        log().error({
                                            'err': err,
                                            'group': group,
                                            'removedMemberIds': removedMemberIds
                                        }, 'An error occurred while removing a group from member libraries');
                                    }

                                    // Asynchronously update all the other user libraries, as the lastModified of the group has been updated
                                    var memberIds = _.keys(computedPermissions);
                                    _updateMembershipsLibraries(memberIds, group, oldLastModified, function(err) {
                                        if (err) {
                                            log().warn({
                                                'err': err,
                                                'group': group,
                                                'memberIds': memberIds
                                            }, 'An error occurred while updating memberships libraries');
                                        }
                                    });

                                    // Emit the fact that the group members have been updated and return to the caller
                                    PrincipalsEmitter.emit(PrincipalsConstants.events.UPDATED_GROUP_MEMBERS, ctx, group, memberChanges, newMemberIds, updatedMemberIds, removedMemberIds);
                                    return callback();
                                });
                            });
                        });
                    });
                });
            });
        });
    });
};

/**
 * Leave the group as the current user in context. For this to be successful, the user must be a part of the group (role
 * does not matter).
 *
 * @param  {Context}    ctx             The current execution context
 * @param  {String}     groupId         The id of the group to join
 * @param  {Function}   callback        Invoked when the process completes
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var leaveGroup = module.exports.leaveGroup = function(ctx, groupId, callback) {

    // Validation
    var validator = new Validator();
    validator.check(groupId, {'code': 400, 'msg': 'Invalid groupId specified'}).isGroupId();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to join a group'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Verify we aren't trying to leave a group we aren't a part of. This is a lighter operation than `getPrincipals`, so we do it first.
    AuthzAPI.getDirectRoles([ctx.user().id], groupId, function(err, userRole) {
        if (err) {
            return callback(err);
        } else if (!userRole[ctx.user().id]) {
            return callback({'code': 400, 'msg': 'Cannot leave a group of which you aren\'t a member'});
        }

        userRole = userRole[ctx.user().id];

        // Verify the group exists
        PrincipalsDAO.getPrincipal(groupId, function(err, group) {
            if (err) {
                return callback(err);
            }

            var memberChanges = {};
            memberChanges[ctx.user().id] = false;

            // Get the expected membership after the changes have been applied and ensure there is still a manager, but only if the user's current role was
            // manager
            AuthzAPI.computeMemberRolesAfterChanges(groupId, memberChanges, function(err, computedPermissions, newMemberIds, updatedMemberIds, removedMemberIds) {
                if (err) {
                    return callback(err);
                } else if (userRole === PrincipalsConstants.roles.MANAGER && !_.chain(computedPermissions).values().contains(PrincipalsConstants.roles.MANAGER).value()) {
                    return callback({'code': 400, 'msg': 'The requested operation would leave the group without a manager'});
                }

                AuthzAPI.updateRoles(group.id, memberChanges, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Remove the group from the user's library, but don't update the group timestamp because leaving the group isn't really an indication of
                    // relevant activity
                    _removeMembershipsLibraries([ctx.user().id], group.id, group.lastModified, function(err) {
                        if (err) {
                            return callback(err);
                        }

                        PrincipalsEmitter.emit(PrincipalsConstants.events.LEFT_GROUP, ctx, group);
                        return callback();
                    });
                });
            });
        });
    });
};

/**
 * Join the group as the current user in context. For this to be successful, the user must not already be a member
 * of the group, and the group must be joinable. If successful, the user will be added to the group with role
 * 'member'.
 *
 * @param  {Context}    ctx             The current execution context
 * @param  {String}     groupId         The id of the group to join
 * @param  {Function}   callback        Invoked when the process completes
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var joinGroup = module.exports.joinGroup = function(ctx, groupId, callback) {

    // Validation
    var validator = new Validator();
    validator.check(groupId, {'code': 400, 'msg': 'Invalid groupId specified'}).isGroupId();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to join a group'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Verify we aren't trying to join a group we're already a member of. This is a lighter operation than `getPrincipal`, so we do it first.
    AuthzAPI.hasAnyRole(ctx.user().id, groupId, function(err, hasAnyRole) {
        if (err) {
            return callback(err);
        } else if (hasAnyRole) {
            return callback({'code': 400, 'msg': 'You are already a member of this group.'});
        }

        // Verify the group exists
        PrincipalsDAO.getPrincipal(groupId, function(err, group) {
            if (err) {
                return callback(err);
            } else if (!_canJoin(ctx, group, hasAnyRole)) {
                return callback({'code': 401, 'msg': 'You cannot join this group.'});
            }

            var changeMembers = {};
            changeMembers[ctx.user().id] = PrincipalsConstants.roles.MEMBER;
            AuthzAPI.computeMemberRolesAfterChanges(group.id, changeMembers, function(err, computedPermissions) {
                if (err) {
                    return callback(err);
                }

                // Apply the changes
                AuthzAPI.updateRoles(group.id, changeMembers, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Asynchronously update the libraries of group members to indicate that the group has been interacted with
                    // more recently
                    var oldLastModified = group.lastModified;
                    var newLastModified = Date.now().toString();
                    PrincipalsDAO.updatePrincipal(group.id, {'lastModified': newLastModified}, function(err) {
                        if (err) {
                            return log().error({
                                'err': err,
                                'group': group
                            }, 'An error has occurred while updating the group `lastModified` for member library updates after a group join');
                        }

                        // This will take care of updating the group in existing member libraries and inserting it into new member libraries
                        _updateMembershipsLibraries(_.keys(computedPermissions), group, oldLastModified, function(err) {
                            if (err) {
                                log().error({
                                    'err': err,
                                    'group': group,
                                    'memberIds': _.keys(computedPermissions)
                                }, 'An error occurred while updating the library index for members after a group join');
                            }
                        });
                    });

                    // Emit an event indicating that this group was joined by the current user in context
                    PrincipalsEmitter.emit(PrincipalsConstants.events.JOINED_GROUP, ctx, group, PrincipalsConstants.roles.MEMBER);
                    return callback();
                });
            });
        });
    });
};

/**
 * Determine whether or not the user in the context is allowed to join the given group.
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {Group}          group               The group object representing the group we're checking for joining
 * @param  {Boolean}        hasRole             Whether or not the current user has a role in the group
 * @return {Boolean}                            Whether or not the current user can join the group
 * @api private
 */
var _canJoin = function(ctx, group, hasRole) {
    // You cannot join a group of which you're already a member
    if (hasRole) {
        return false;

    // Anonymous users can never join a group
    } else if (!ctx.user()) {
        return false;

    // TODO: For now we only support joining a group if it's joinable property has been set to YES
    } else if (group.joinable !== AuthzConstants.joinable.YES) {
        return false;

    // By this point we know the user is logged in and that people are allowed to join the group.
    // If the user is on the same tenant as the group, he can always request to join
    } else if (ctx.user().tenant.alias === group.tenant.alias) {
        return true;

    // If the user is from another tenant, he can only join the group if the tenant permeability
    // settings allow it AND the group's visibility setting is set to public
    } else if (TenantsUtil.canInteract(ctx.user().tenant.alias, group.tenant.alias) && group.visibility === AuthzConstants.visibility.PUBLIC) {
        return true;

    // In any other case, you cannot join the group
    } else {
        return false;
    }
};

/**
 * Create a new group within this tenant.
 *
 * @param  {Context}   ctx                  The current execution context
 * @param  {String}    displayName          The displayName for this group
 * @param  {String}    [description]        A description for this group
 * @param  {String}    [visibility]         The visibility that should be set for this group. Should be one of `AuthzConstants.visibility`'s values. If left undefined, it defaults to the configured tenant default
 * @param  {String}    [joinable]           Whether or not this group can be joined by people. Should be one of `AuthzConstants.joinable`'s values. If left undefined, it defaults to the configured tenant default
 * @param  {Object}    [permissions]        A hash where each key is a principal id and the value is one of `PrincipalsConstants.roles`
 * @param  {Function}  [callback]           Standard callback function
 * @param  {Object}    [callback.err]       An error that occured, if any
 * @param  {Group}     [callback.group]     The created group's basic profile
 */
var createGroup = module.exports.createGroup = function(ctx, displayName, description, visibility, joinable, permissions, callback) {
    var tenantAlias = ctx.tenant().alias;

    // Default parameters
    description = description || '';
    visibility = visibility || Config.getValue(tenantAlias, 'group', 'visibility');
    joinable = joinable || Config.getValue(tenantAlias, 'group', 'joinable');
    permissions = permissions || {};
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'An error occurred while creating a group');
        }
    };

    // Parameter validation
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Cannot create a group anonymously'}).isLoggedInUser(ctx);
    validator.check(displayName, {'code': 400, 'msg': 'You need to provide a displayName for this group'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'A displayName can only be 1000 characters long'}).isShortString();
    validator.check(visibility, {'code': 400, 'msg': 'The visibility setting must be one of: ' + _.values(AuthzConstants.visibility)}).isIn(_.values(AuthzConstants.visibility));
    validator.check(joinable, {'code': 400, 'msg': 'The joinable setting must be one of: ' + _.values(AuthzConstants.joinable)}).isIn(_.values(AuthzConstants.joinable));
    if (description) {
        validator.check(description, {'code': 400, 'msg': 'A description can only be 10000 characters long'}).isMediumString();
    }
    _.each(permissions, function(role, principalId) {
        validator.check(principalId, {'code': 400, 'msg': 'Only valid principal IDs are accepted'}).isPrincipalId();
        validator.check(role, {'code': 400, 'msg': 'Only `manager` or `member` are accepted as a role for a principal'}).isIn(_.values(PrincipalsConstants.roles));
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Generate the group id
    var groupId = AuthzUtil.toId(AuthzConstants.principalTypes.GROUP, tenantAlias, ShortId.generate());

    // Immediately add the current user as a manager
    var currentUser = getUserId(ctx);
    permissions[currentUser] = PrincipalsConstants.roles.MANAGER;

    // Ensure we don't violate tenant boundaries by adding users from other private tenants
    PrincipalsDAO.getPrincipals(_.keys(permissions), null, function(err, principals) {
        if (err) {
            return callback(err);
        }

        principals = _.values(principals);

        AuthzAPI.canInteract(ctx, tenantAlias, principals, function(err, canInteract, illegalPrinicpalIds) {
            if (err) {
                return callback(err);
            }

            // Create the group
            PrincipalsDAO.createGroup(groupId, tenantAlias, displayName, description, visibility, joinable, function (err, group) {
                if (err) {
                    return callback(err);
                }

                // Apply the permissions to the group
                AuthzAPI.updateRoles(group.id, permissions, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Update the user's libraries
                    _insertMembershipsLibraries(_.keys(permissions), group, function(err) {
                        if (err) {
                            log().error({
                                'err': err,
                                'group': group,
                                'permissions': permissions
                            }, 'An error occurred trying to insert to the library index while creating a group');
                        }

                        PrincipalsEmitter.emit(PrincipalsConstants.events.CREATED_GROUP, ctx, group, permissions);
                        return callback(null, group);
                    });
                });
            });
        });
    });
};

/**
 * Update a group's metadata.
 *
 * @param  {Context}        ctx                             The current execution context.
 * @param  {String}         groupId                         The ID of the group
 * @param  {Object}         profileFields                   Object where the keys represent the profile fields that need to be updated and the values represent the new values for those profile fields.
 * @param  {String}         [profileFields.displayName]     New display name for the group
 * @param  {String}         [profileFields.description]     New description for the group
 * @param  {String}         [profileFields.visibility]      New visibility setting for the group. The possible values are 'private', 'loggedin' and 'public'
 * @param  {String}         [profileFields.joinable]        New joinability setting for the group. The possible values are 'yes', 'no' and 'request'
 * @param  {Function}       callback                        Standard callback method takes argument `err`
 * @param  {Obect}          callback.err                    An error object (if any).
 * @param  {Group}          callback.updatedGroup           Group object representing the updated group
 */
var updateGroup = module.exports.updateGroup = function(ctx, groupId, profileFields, callback) {
     // Parameter validation
    var fieldNames = profileFields ? _.keys(profileFields) : [];
    var validator = new Validator();
    validator.check(groupId, {'code': 400, 'msg': 'A valid group id must be provided'}).isGroupId();
    validator.check(fieldNames.length, {'code': 400, 'msg': 'You should specify at least one field'}).min(1);
    fieldNames.forEach(function(fieldName) {
        validator.check(fieldName, {'code': 400, 'msg': fieldName + ' is not a recognized group profile field'}).isIn(['displayName', 'description', 'visibility', 'joinable']);
        if (fieldName === 'visibility') {
            validator.check(profileFields['visibility'], {'code': 400, 'msg': 'The visibility setting must be one of: ' + _.values(AuthzConstants.visibility)}).isIn(_.values(AuthzConstants.visibility));
        } else if (fieldName === 'joinable') {
            validator.check(profileFields['joinable'], {'code': 400, 'msg': 'The joinable setting must be one of: ' + _.values(AuthzConstants.joinable)}).isIn(_.values(AuthzConstants.joinable));
        } else if (fieldName === 'displayName') {
            validator.check(profileFields['displayName'], {'code': 400, 'msg': 'A displayName cannot be empty'}).notEmpty();
            validator.check(profileFields['displayName'], {'code': 400, 'msg': 'A displayName can only be 1000 characters long'}).isShortString();
        } else if (fieldName === 'description' && profileFields['description']) {
            validator.check(profileFields['description'], {'code': 400, 'msg': 'A description can only be 10000 characters long'}).isMediumString();
        }
    });
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a group'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure the target group exists
    PrincipalsDAO.getPrincipal(groupId, function(err, oldStorageGroup) {
        if (err) {
            return callback(err);
        }

        // Check if we can update this group
        _canManage(ctx, oldStorageGroup, function(err, canManage) {
            if (err) {
                return callback(err);
            } else if (!canManage) {
                return callback({'code': 401, 'msg': 'Permission denied'});
            }

            profileFields = _.extend({}, profileFields, {'lastModified': Date.now().toString()});
            PrincipalsDAO.updatePrincipal(groupId, profileFields, function(err) {
                if (err) {
                    return callback(err);
                }

                // Keep track of the updated storage group model so we can emit it in the UPDATE_GROUP event
                var updatedStorageGroup = _.extend({}, oldStorageGroup, profileFields);

                // Get the user-facing updated group object to return to the user
                PrincipalsUtil.getPrincipal(ctx, groupId, function(err, updatedGroup) {
                    if (err) {
                        return callback(err);
                    }

                    // Asynchronously update all member library indexes so that the group appears higher due to it being more recently
                    // interacted with
                    AuthzAPI.getAuthzMembers(groupId, null, 10000, function(err, memberRoles) {
                        if (err) {
                            log().error({'err': err, 'group': updatedGroup}, 'An error occurred while fetching group members to update library indexes after group update');
                        }

                        var memberIds = _.pluck(memberRoles, 'id');
                        _updateMembershipsLibraries(memberIds, updatedGroup, oldStorageGroup.lastModified, function(err) {
                            if (err) {
                                log().error({
                                    'err': err,
                                    'oldGroup': oldStorageGroup,
                                    'newGroup': updatedStorageGroup,
                                    'memberIds': memberIds
                                }, 'An error occurred while updating the library index for group members after group update');
                            }
                        });
                    });

                    // Emit the fact that we have updated this group
                    PrincipalsEmitter.emit(PrincipalsConstants.events.UPDATED_GROUP, ctx, updatedStorageGroup, oldStorageGroup);

                    // Return the full group profile for the caller
                    return getFullGroupProfile(ctx, groupId, callback);
                });
            });
        });
    });
};

/**
 * Determine whether or not the user in the context can manage a given group.
 *
 * @param  {Context}    ctx                 The current execution context
 * @param  {String}     groupId             The group to check
 * @param  {Function}   callback            The function to invoke when the process completes
 * @param  {Object}     callback.err        An error that occurred while checking access, if any
 * @param  {Boolean}    callback.canManage  Whether or not the user can manage the group
 * @param  {Group}      callback.group      The group object object that was fetched from the database
 */
var canManage = module.exports.canManage = function(ctx, groupId, callback) {
    var currentUserId = getUserId(ctx);

    // Anonymous users cannot manage a group
    if (!currentUserId) {
        return callback(null, false);
    }

    getGroup(ctx, groupId, function(err, group) {
        if (err) {
            return callback(err);
        }

        _canManage(ctx, group, function(err, canManage) {
            if (err) {
                return callback(err);
            }

            return callback(null, canManage, group);
        });
    });
};

/**
 * Determine whether or not the user in context is able to view the members of the given group.
 *
 * @param  {Context}   ctx                         The context of the current request
 * @param  {Group}     group                       The group to check
 * @param  {Function}  callback                    Invoked when the process completes
 * @param  {Object}    callback.err                An error that occurred, if any
 * @param  {Boolean}   callback.canViewMembers     Whether or not the user in context can view the members of the given group
 */
var canViewMembers = module.exports.canViewMembers = function(ctx, group, callback) {
    if (ctx.user() && ctx.user().isAdmin(group.tenant.alias)) {
        // Tenant or global admins can always view the members.
        return callback(null, true);
    } else if (group.visibility === AuthzConstants.visibility.PUBLIC) {
        // Public groups are visible to everyone
        return callback(null, true);
    } else if (group.visibility === AuthzConstants.visibility.LOGGEDIN && TenantsUtil.isLoggedIn(ctx, group.tenant.alias)) {
        // If a group is only accessible by loggedin users, the user must be logged in to the group's tenant
        return callback(null, true);
    } else if (!ctx.user()) {
        // The group is private, anonymous users can never see it
        return callback(null, false);
    } else {
        // The group is private and the user is authenticated, check if the user is a member
        AuthzAPI.hasAnyRole(ctx.user().id, group.id, callback);
    }
};

/**
 * Internal function that checks whether or not the current user can manage a group. This function assumes that
 * the passed in groupId actually exists
 *
 * @param  {Context}     ctx                 The current execution context.
 * @param  {Group}       group               The group to check.
 * @param  {Function}    callback            Callback method. takes arguments `err` and `canManage`
 * @param  {Object}      callback.err        If specified, indicates that the user cannot create the group. The error 'code' property is the http response code.
 * @param  {Boolean}     callback.canManage  Whether or not the user can manage the group.
 * @api private
 */
var _canManage = function(ctx, group, callback) {
    if (!ctx.user()) {
        return callback(null, false);
    }

    if (ctx.user().isAdmin(group.tenant.alias)) {
        return callback(null, true);
    }

    AuthzAPI.hasRole(getUserId(ctx), group.id, PrincipalsConstants.roles.MANAGER, callback);
};

/**
 * Insert the group into the memberships libraries of the given member ids
 *
 * @param  {String[]}   memberIds           The ids of the members whose libraries to update
 * @param  {Group}      group               The group whose information to insert into the libraries
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @api private
 */
var _insertMembershipsLibraries = function(memberIds, group, callback) {
    if (_.isEmpty(memberIds)) {
        return callback();
    }

    var libraryVisibilities = LibraryAPI.Authz.resolveEffectiveLibraryVisibilities(memberIds, group);
    LibraryAPI.Index.insert(PrincipalsConstants.library.MEMBERSHIPS_INDEX_NAME, libraryVisibilities, group.id, group.lastModified, callback);
};

/**
 * Update the group entries in the memberships libraries of the given member ids
 *
 * @param  {String[]}   memberIds           The ids of the members whose libraries to update
 * @param  {Group}      group               The group whose information to update in the libraries
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @api private
 */
var _updateMembershipsLibraries = function(memberIds, group, oldLastModified, callback) {
    if (_.isEmpty(memberIds)) {
        return callback();
    }

    var libraryVisibilities = LibraryAPI.Authz.resolveEffectiveLibraryVisibilities(memberIds, group);
    LibraryAPI.Index.update(PrincipalsConstants.library.MEMBERSHIPS_INDEX_NAME, libraryVisibilities, group.id, group.lastModified, oldLastModified, callback);
};

/**
 * Remove the group entries from the memberships libraries of the given member ids
 *
 * @param  {String[]}   memberIds           The ids of the members whose libraries to update
 * @param  {Group}      group               The group whose information to remove from the libraries
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @api private
 */
var _removeMembershipsLibraries = function(memberIds, groupId, oldLastModified, callback) {
    if (_.isEmpty(memberIds)) {
        return callback();
    }

    LibraryAPI.Index.remove(PrincipalsConstants.library.MEMBERSHIPS_INDEX_NAME, memberIds, groupId, oldLastModified, callback);
};

/**
 * Get the current user id from the context, if any
 *
 * @param  {Context} ctx     The user context
 * @return {String}          The id of the user in the context. Returns `null` if there is no active user (i.e., anonymous)
 * @api private
 */
var getUserId = function(ctx) {
    var user = ctx.user();
    return user ? user.id : null;
};

