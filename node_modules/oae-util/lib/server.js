/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var express = require('express');
var locale = require('locale');
var http = require('http');

var log = require('oae-logger').logger('oae-server');
var OaeEmitter = require('./emitter');
var TelemetryAPI = require('oae-telemetry');

var multipart = require('./middleware/multipart');
var Shutdown = require('./internal/shutdown');
var swagger = require('./swagger');

// The main OAE config
var config = null;

// Maintains a list of paths that are safe from CSRF attacks
var safePathPrefixes = [];

/**
 * Starts an express server on the specified port. This will be done for the global admin server, as well
 * as for the tenant server.
 *
 * @param  {Number}     port        The port on which the express server should be started
 * @param  {Object}     config      JSON object containing configuration values for Cassandra, Redis, logging and telemetry
 * @return {Express}                The created express server
 */
var setupServer = module.exports.setupServer = function(port, _config) {
    // Cache the config
    config = _config;

    // Create the express server
    var app = express();

    // Expose the HTTP server on the express app server so other modules can hook into it
    app.httpServer = http.createServer(app);

    // Start listening for requests
    app.httpServer.listen(port);

    // Don't output pretty JSON,
    app.set('json spaces', 0);

    _applyAvailabilityHandling(app.httpServer, app, port);

    // We'll be using cookies to hash the principalId
    // Signing of the cookie will be done by the session middleware
    app.use(express.cookieParser());

    /*!
     * We support the following type of request encodings:
     *
     *  * urlencoded (regular POST requests)
     *  * application/json
     *  * multipart (file uploads)
     */
    app.use(express.urlencoded());
    app.use(express.json());
    app.use(multipart(config.files));

    // This needs to come BEFORE passport and AFTER cookieParser. The secret will be used to sign the cookie
    app.use(express.cookieSession({'secret': config.cookie.secret}));

    // Add telemetry before we do anything else
    app.use(function(req, res, next) {
        TelemetryAPI.request(req, res);
        next();
    });

    return app;
};

/**
 * Aggregates the routes for the express server so that we can bind them after setting up
 * all the middleware as registering the first route puts the router onto the middleware
 * stack
 *
 * @param  {Express}       The express server these routes belong to
 * @return {Router}        An object for associating routes to the server
 */
var setupRouter = module.exports.setupRouter = function(app) {
    var that = {};
    that.routes = [];
    that.resources = {};
    that.models = {};

    /**
     * Setup a route on the associated server
     *
     * @param  {String}               method          The http method for the route
     * @param  {String|RegEx}         route           The path for the route
     * @param  {Function|Function[]}  handler         The function to handle requests to this route
     * @param  {String}               [telemetryUrl]  The string to use for telemetry tracking
     * @throws {Error}                                Error thrown when arguments aren't of the proper type
     */
    that.on = function(method, route, handler, telemetryUrl) {
        var isRouteValid = (_.isString(route) || _.isRegExp(route));
        var isHandlerValid = (_.isFunction(handler) || _.isArray(handler));
        if (_.isString(method) && isRouteValid && isHandlerValid) {
            that.routes.push({
                'method': method,
                'route': route,
                'handler': handler,
                'telemetryUrl': telemetryUrl
            });
        } else {
            throw new Error('Invalid argument type');
        }
    };

    that.swag = function(spec, handler, telemetryUrl) {
        var route = '/api' + spec.path.replace(/\/{/g, '/:').replace(/\}/g, '');
        var isRouteValid = (_.isString(route) || _.isRegExp(route));
        var isHandlerValid = (_.isFunction(handler) || _.isArray(handler));
        if (_.isString(spec.method) && isRouteValid && isHandlerValid) {
            that.routes.push({
                'method': spec.method.toLowerCase(),
                'route': route,
                'handler': handler,
                'telemetryUrl': telemetryUrl,
            });
            _addApiMethod(spec);

        } else {
            throw new Error('Invalid argument type');
        }
    };

    that.addModel = function(name, model) {
        that.models[name] = model;
    };

    /**
     * Bind all the routes, this should only be called once by the server initialization
     */
    that.bind = function() {
        _.each(that.routes, function(route) {
            // Add a telemetry handler
            var handlers = [
                function(req, res, next) {
                    req.telemetryUrl = route.telemetryUrl || route.route.replace(/:/, '');
                    next();
                }
            ];

            app[route.method].apply(app, [route.route, handlers.concat(route.handler)]);
        });
    };

    var _addApiMethod = function(spec) {
        var apiRootPath = spec.path.split('/')[1];
        var root = that.resources[apiRootPath];

        if (root && root.apis) {
            //this path already exists in swagger resources
            _.each(root.apis, function (api) {
                if (api && api.path == spec.path && api.method == spec.method) {
                    // add operation & return
                    _appendToApi(root, api, spec);
                    return;
                }
            });
        }

        var api = {
            'path': spec.path
        };
        if (!that.resources[apiRootPath]) {
            if (!root) {
                var resourcePath = '/' + apiRootPath;
                root = {
                    'apiVersion': swagger.constants.apiVersion,
                    'swaggerVersion': swagger.constants.swaggerVersion,
                    'basePath': swagger.constants.basePath,
                    'resourcePath': swagger.constants.resourcePath,
                    'apis': [],
                    'models': {}
                };
            }
            that.resources[apiRootPath] = root;
        }

        root.apis.push(api);
        _appendToApi(root, api, spec);
    };

    var _appendToApi = function(rootResource, api, spec) {

        if (!api.description) {
            api.description = spec.description;
        }
        var validationErrors = [];

        if (!spec.nickname || spec.nickname.indexOf(' ') >= 0) {
            //  nicknames don't allow spaces
            validationErrors.push({
                'path': api.path,
                'error': 'invalid nickname "' + spec.nickname + '"'
            });
        }
        // validate params
        _.each(spec.params, function (param) {
            if (param.allowableValues) {
                var avs = param.allowableValues.toString();
                var type = avs.split('[')[0];
                if (type == 'LIST') {
                    var values = avs.match(/\[(.*)\]/g).toString().replace('[', '').replace(']', '').split(',');
                    param.allowableValues = {
                        valueType: type,
                        values: values
                    };
                } else if (type == 'RANGE') {
                    var vals = avs.match(/\[(.*)\]/g).toString().replace('[', '').replace(']', '').split(',');
                    param.allowableValues = {
                        valueType: type,
                        min: vals[0],
                        max: vals[1]
                    };
                }
            }

            switch (param.paramType) {
            case 'path':
                if (api.path.indexOf('{' + param.name + '}') < 0) {
                    validationErrors.push({
                        'path': api.path,
                        'name': param.name,
                        'error': 'invalid path'
                    });
                }
                break;
            case 'query':
                break;
            case 'body':
                break;
            case 'form':
                break;
            case 'header':
                break;
            default:
                validationErrors.push({
                    'path': api.path,
                    'name': param.name,
                    'error': 'invalid param type ' + param.paramType
                });
                break;
            }
        });

        if (validationErrors.length > 0) {
            log().error(validationErrors);
            return;
        }

        if (!api.operations) {
            api.operations = [];
        }

        // TODO: replace if existing HTTP operation in same api path
        var op = {
            'parameters': spec.parameters,
            'httpMethod': spec.method,
            'notes': spec.notes,
            'errorResponses': spec.errorResponses,
            'nickname': spec.nickname,
            'summary': spec.summary,
            'consumes': spec.consumes,
            'produces': spec.produces
        };

        // Add custom fields.
        op = _.extend({}, spec, op);

        if (spec.responseClass) {
            op.responseClass = spec.responseClass;
        } else {
            op.responseClass = 'void';
        }
        api.operations.push(op);

        if (!rootResource.models) {
            rootResource.models = {};
        }
    };

    return that;
};

/**
 * Add a path to the list of safe paths. Paths added here will not be protected against CSRF
 * attacks. This is common for endpoints that have other verification mechanisms such as Shibboleth.
 *
 * @param  {String}     pathPrefix  A path prefix that will not be validated against CSRF attacks
 */
var addSafePathPrefix = module.exports.addSafePathPrefix = function(pathPrefix) {
    log().info('Adding %s to list of paths that are not CSRF-protected.', pathPrefix);
    safePathPrefixes.push(pathPrefix);
};

/**
 * This method is used to bind server functionality after all modules have had an opportunity to do so. This can be useful for things such
 * as:
 *
 *  * Response code logging / telemetry
 *  * Default "catch-all" error handling
 *
 * @param  {Express}    app     The express app for which the initialized should be finalized
 */
var postInitializeServer = module.exports.postInitializeServer = function(app, router) {
    /*!
     * Referer-based CSRF protection. If the request is not safe (e.g., POST, DELETE) and the origin of the request (as
     * specified by the HTTP Referer header) does not match the target host of the request (as specified by the HTTP
     * Host header), then the request will result in a 500 error.
     *
     * While referer-based protection is not highly recommended due to spoofing possibilities in insecure environments,
     * it currently offers the best trade-off between ease of use (e.g., for cURL interoperability), effort and security
     * against CSRF attacks.
     *
     * Middleware that gets called earlier, can force the CSRF check to be skipped by setting `_checkCSRF` on the request.
     *
     * If using a utility such as `curl` to POST requests to the API, you can bypass this by just setting the referer
     * header to "/":
     *
     * curl -X POST -e / http://my.oae.com/api/auth/login
     *
     * More information about CSRF attacks: http://en.wikipedia.org/wiki/Cross-site_request_forgery
     */
    app.use(function(req, res, next) {
        // If earlier middleware determined that CSRF is not required, we can skip the check
        if (req['_checkCSRF'] === false) {
            return next();
        }

        if (!_isSafeMethod(req.method) && !_isSafePath(req) && !_isSameOrigin(req)) {
            log().warn({
                'method': req.method,
                'host': req.headers.host,
                'referer': req.headers.referer,
                'targetPath': req.path
            }, 'CSRF validation failed: attempted to execute unsafe operation from untrusted origin.');
            return _abort(res, 500, 'CSRF validation failed: attempted to execute unsafe method from untrusted origin.');
        }

        return next();
    });

    // Explicitly apply the routes to the end
    app.use(app.router);

    // Bind routes
    router.bind();

    // Set the swagger specs as local variables on the express server
    app.locals({
        'swagger-resources': router.resources,
        'swagger-models': router.models,
    });

    // Catch-all error handler
    var appTelemetry = TelemetryAPI.telemetry('server');
    app.use(function(err, req, res, next) {
        appTelemetry.incr('error.count');
        log(req.ctx).error({
            err: err,
            req: req,
            res: res
        }, 'Unhandled error in the request chain, caught at the default error handler.');
        res.send(500, 'An unexpected error occurred.');
    });
};

/**
 * Whether or not the server is running behind HTTPs.
 *
 * @return {Boolean}   Whether or not the server is running behind https.
 */
var useHttps = module.exports.useHttps = function() {
    return config.servers.useHttps;
};

/**
 * Apply the logic and request handling required to gracefully start up and shut down the web server. This entails both:
 *
 *  * Gracefully rejecting web requests until the container has fully initialized
 *  * Gracefully rejecting web requests while the container is in the process of shutting down services
 *
 * @param  {Server}         server  The node.js http server object
 * @param  {Application}    app     The Express `app` object
 * @param  {Number}         port    The port on which the server is listening
 * @api private
 */
var _applyAvailabilityHandling = function(server, app, port) {
    var isAvailable = false;

    OaeEmitter.on('ready', function() {
        // The container is initialized, start accepting web requests
        isAvailable = true;
    });

    // Register a pre-shutdown handler that will close this express server to stop receiving requests
    Shutdown.registerPreShutdownHandler('express-server-' + port, null, function(callback) {
        log().info('Beginning shutdown.');

        // Stop accepting web requests
        isAvailable = false;

        server.close(function() {
            log().info('Express is now shut down.');
            callback();
        });
    });

    // Notify the front-end proxy that we are unable to accept requests if isAvailable is false
    app.use(function(req, res, next) {
        if (!isAvailable) {
            log().info({'path': req.path}, 'Rejecting request during shutdown with 502 error.');
            res.setHeader('Connection', 'close');
            res.send(502, 'Server is in the process of restarting');
        } else {
            next();
        }
    });
};

/**
 * Abort a request with a given code and response message.
 *
 * @param  {Response}   res     The express response object
 * @param  {Number}     code    The HTTP response code
 * @param  {String}     message The message body to provide as a reason for aborting the request
 * @api private
 */
var _abort = function(res, code, message) {
    res.setHeader('Connection', 'Close');
    return res.send(code, message);
};

/**
 * Determines if the target path for a request is considered "safe" from CSRF attacks.
 *
 * @param  {Request}    req     The express request object
 * @return {Boolean}            `true` if the path is safe from CSRF attacks, `false` otherwise
 * @api private
 */
var _isSafePath = function(req) {
    var path = req.path;
    var matchingPaths = _.filter(safePathPrefixes, function(safePathPrefix) {
        return (path.indexOf(safePathPrefix) === 0);
    });
    return (matchingPaths.length > 0);
};

/**
 * Determine whether or not the given request method is considered "safe"
 *
 * @param  {String}     method  The request method
 * @return {Boolean}            `true` if the request method is safe (e.g., GET, HEAD), `false` otherwise
 * @api private
 */
var _isSafeMethod = function(method) {
    return (method === 'GET' || method === 'HEAD');
};

/**
 * Determine whether or not the origin host of the given request is the same as the target host.
 *
 * @param  {Request}    req     The express request object to test
 * @return {Boolean}            `true` if the request is of the same origin as the target host, `false` otherwise
 * @api private
 */
var _isSameOrigin = function(req) {
    var host = req.headers.host;
    var referer = req.headers.referer;

    if (!referer) {
        return false;
    }

    if (referer.indexOf('/') !== 0) {
        // Verify the host portion against the host header
        referer = referer.split('://')[1];
        if (!referer || referer.split('/')[0] !== host) {
            // If there is nothing after the protocol (e.g., "http://") or the host before the first slash does not match
            // we deem it not to be the same origin.
            return false;
        } else {
            return true;
        }
    } else {
        // If the referer is a relative uri, it must be from same origin.
        return true;
    }
};

