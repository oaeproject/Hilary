/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var crypto = require('crypto');
var FacebookStrategy = require('passport-facebook').Strategy;
var GoogleStrategy = require('passport-google').Strategy;
var LocalStrategy = require('passport-local').Strategy;
var OpenIDStrategy = require('passport-openid').Strategy;
var passport = require('passport');
var TwitterStrategy = require('passport-twitter').Strategy;
var Validator = require('validator').Validator;

var Cassandra = require('oae-util/lib/cassandra');
var Context = require('oae-context').Context;
var log = require('oae-logger').logger('authentication');
var PrincipalsAPI = require('oae-principals');
var TenantsAPI = require('oae-tenants');
var User = require('oae-principals/lib/model').User;

var AuthenticationConstants = require('oae-authentication/lib/constants').AuthenticationConstants;
var AuthenticationUtil = require('oae-authentication/lib/util');
var LoginId = require('oae-authentication/lib/model').LoginId;

// Holds an array of strategies that are keyed by the tenant alias.
var strategies = {};

TenantsAPI.on('start', function(tenant) {
    addStrategies(tenant);
});

TenantsAPI.on('stop', function(tenant) {
    removeStrategies(tenant);
});

/**
 * Register the local login strategy for all tenants. This can be done for all tenants (including
 * global admin) at the same time, as the request is passed into the callback
 */
var initLocalAuthenticationStrategy = module.exports.initLocalAuthenticationStrategy = function() {
    // There is no need to wrap strategies where we can pass the request..
    passport.use('local', new LocalStrategy({'passReqToCallback': true}, passwordCallback));
};

/**
 * Register the Facebook, Twitter and Google passport login strategies for a given tenant. This will
 * be called for all registered tenants upon start-up and new tenants that are being started on the fly.
 * 
 * @param  {Tenant}     tenant      The tenant for which we want to register the authentication endpoints
 */
var addStrategies = module.exports.addStrategies = function(tenant) {
    var alias = tenant.alias;
    if (!strategies[alias]) {
        strategies[alias] = [];

        // All the other strategies that require more work.
        // TODO: Check the config if these strategies need to be set on this server.
        setupFacebook(tenant);
        setupTwitter(tenant);
        setupGoogle(tenant);
    }
};

/**
 * When a tenant is being stopped or deleted, we unregister the local, Facebook, Twitter and Google passport login
 * strategies so users can no longer sign in onto that tenant
 * 
 * @param  {Tenant}     tenant      The tenant for which we want to unregister the authentication endpoints
 */
var removeStrategies = module.exports.removeStrategies = function(tenant) {
    var alias = tenant.alias;
    if (strategies[alias]) {
        for (var i = 0; i < strategies[alias].length; i++) {
            passport.unuse(strategies[alias][i].name);
        }
    }
};

/**
 * Utility methods that gets a user by the login id. If no user was found it will be created.
 *
 * @param  {Context}      ctx                The current context, used to determine the tenant of the user to get / create
 * @param  {String}       authProvider       The authentication provider of the id.
 * @param  {String}       externalId         The desired externalId/username for this user.
 * @param  {String}       displayName        The display name of this user
 * @param  {String}       [opts]             Optional user profile parameters.
 * @param  {String}       [opts.locale]      The locale of this user.
 * @param  {String}       [opts.timezone]    The timezone of this user.
 * @param  {String}       [opts.visibility]  The visibility of the user. One of: @see PrincipalsModel.VISIBILITY_OPTIONS
 * @param  {String}       [opts.publicAlias] The alias to show when the user is private / inaccessible by the current user
 * @param  {Function}     callback           A function returning the user.
 * @param  {Object}       callback.err       An error that occured, if any
 * @param  {Boolean}      callback.user      The user object
 */
var getOrCreateUser = module.exports.getOrCreateUser = function(ctx, authProvider, externalId, displayName, opts, callback) {
    var tenantAlias = ctx.tenant().alias;
    var loginId = new LoginId(tenantAlias, authProvider, externalId);
    _getUserIdFromLoginId(loginId, function(err, userId) {
        if (err) {
            return callback(err);
        }

        if (!userId) {
            // no user mapped to this login id. create them
            return createUser(ctx, loginId, displayName, opts, callback);
        } else {
            // the user existed
            return PrincipalsAPI.getUser(ctx, userId, callback);
        }
    });
};

/**
 * Create a user in the database with the provided loginId.
 *
 * @param   {Context}   ctx                 The current context
 * @param   {LoginId}   loginId             The login id that will be associated with the user so they may log in
 * @param   {String}    displayName         The display name of the user
 * @param   {Object}    [opts]              Optional parameters that can be assigned to a user
 * @param   {String}    [opts.locale]       The locale of this user.
 * @param   {String}    [opts.timezone]     The timezone of this user.
 * @param   {String}    [opts.visibility]   The visibility of the user. One of: @see PrincipalsModel.VISIBILITY_OPTIONS
 * @param   {String}    [opts.publicAlias]  The alias to show when the user is private / inaccessible by the current user
 * @param   {Function}  callback            Invoked when the process completes
 * @param   {Object}    callback.err        An error that occurred, if any
 * @param   {Boolean}   callback.user       The user that was created
 */
var createUser = module.exports.createUser = function(ctx, loginId, displayName, opts, callback) {

    var validator = new Validator();
    validator.check(displayName, {'code': 400, 'msg': 'Please specify a display name.'}).notEmpty();
    _validateLoginIdForPersistence(validator, loginId);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // make sure the loginId is not already associated to a user
    _getUserIdFromLoginId(loginId, function(err, userId) {
        if (userId) {
            return callback({'code': 400, 'msg': 'This login id already exists and is already associated to a user.'});
        }

        // hash the user password
        if (loginId.provider === AuthenticationConstants.providers.LOCAL) {
           loginId.properties.password = AuthenticationUtil.hashPassword(loginId.properties.password);
        }

        // create the user in the database and immediately associate the login id
        PrincipalsAPI.createUser(ctx, displayName, opts, function(err, user) {
            if (err) {
                return callback(err);
            }

            loginId.userId = user.id;
            _associateLoginId(loginId, user.id, function(err) {
                if (err) {
                    return callback(err);
                }

                log(ctx).info({
                    loginId: {
                        tenantAlias: loginId.tenantAlias,
                        provider: loginId.provider,
                        externalId: loginId.externalId
                    },
                    userId: user.id
                }, 'Created user with a mapped login id.');

                return callback(null, user);
            });
        });
    });
};

/**
 * Associate the given Login ID info to the specified user. This makes it possible for the associated user to login with the provided
 * login credentials.
 *
 * @param   {Context}   ctx             The current context
 * @param   {LoginId}   loginId         The login id to associate to the user
 * @param   {String}    userId          The id of the user in the database
 * @param   {Function}  callback        Invoked when the process completes
 * @param   {Object}    callback.err    An error that occurred, if any
 */
var associateLoginId = module.exports.associateLoginId = function(ctx, loginId, userId, callback) {
    var validator = new Validator();
    _validateLoginIdForPersistence(validator, loginId);
    validator.check(null, {'code': 401, 'msg': 'You must be authenticated to associate a login id to a user.'}).isLoggedInUser(ctx);
    validator.check(userId, {'code': 400, 'msg': 'Must specify a user id'}).notEmpty();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var isAdmin = ctx.user().isAdmin(loginId.tenantAlias);
    var isTargetUser = (ctx.user().id === userId);

    if (!isAdmin && !isTargetUser) {
        // only admin and the user themself can associate a login id to the account
        return callback({'code': 401, 'msg': 'You cannot associate a login id to a user other than your own.'});
    }

    _getUserIdFromLoginId(loginId, function(err, existingUserIdMapping) {
        if (err) {
            return callback(err);
        } else if (existingUserIdMapping && !isAdmin) {
            // only admin can re-associate a login id to another user
            return callback({'code': 401, 'msg': 'Login ID is already associated to a user.'});
        }

        // verify we don't assign 2 ids of the same provider to a user
        _getUserLoginIds(userId, function(err, loginIds) {
            if (err) {
                return callback(err);
            } else if (loginIds[loginId.provider]) {
                return  callback({'code': 400, 'msg': 'User already has a login id of type ' + loginId.provider});
            }

            // ensure that the target user exists
            PrincipalsAPI.getUser(ctx, userId, function(err, user) {
                if (err) {
                    return callback(err);
                }

                if (!user) {
                    return callback({'code': 404, 'msg': 'User does not exist.'});
                }

                _associateLoginId(loginId, userId, function(err) {
                    if (err) {
                        callback(err);
                    } else {
                        log(ctx).info({
                            loginId: {
                                tenantAlias: loginId.tenantAlias,
                                provider: loginId.provider,
                                externalId: loginId.externalId
                            },
                            userId: userId
                        }, 'Mapped login id to user account.');
                        callback();
                    }
                });
            });
        });
    });
};

/**
 * Changes the local password of a user.
 *
 * @param  {Context}  ctx           The current context.
 * @param  {String}   userId        The user id of the user whose password that needs to be changed.
 * @param  {String}   oldPassword   The old password that can be used to authenticate this change request.
 * @param  {String}   newPassword   The new password.
 * @param  {Function} callback      Invoked when the process completes
 * @param  {Object}   callback.err  An error that occurred, if any
 */
var changePassword = module.exports.changePassword = function(ctx, userId, oldPassword, newPassword, callback) {

    // Parameter validation
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to change a password'}).isLoggedInUser(ctx);
    validator.check(userId, {'code': 400, 'msg': 'A user id must be provided'}).notEmpty();
    validator.check(newPassword, {'code': 400, 'msg': 'A new password must be provided'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // get the local login id for the user
    _getUserLoginIds(userId, function(err, loginIds) {
        if (err) {
            return callback(err);
        }

        // can only change password on the local account type
        var localLoginId = loginIds[AuthenticationConstants.providers.LOCAL];
        if (localLoginId) {

            // determine the current user access
            var isAdmin = ctx.user().isAdmin(localLoginId.tenantAlias);
            var isTargetUser = ctx.user().id === userId;

            if (!isAdmin && !isTargetUser) {
                log().info('Failed attempt to change password for user %s by user %s.', userId, ctx.user().id);
                return callback({'code': 401, 'msg': 'You\'re not authorized to change this user\'s password.'});
            } else if (isAdmin) {
                // if the user is admin we don't care about the old password
                log().info('User %s is changing the password for user %s', ctx.user().id, userId);
                return _changePassword(localLoginId, newPassword, callback);
            } else {
                // if it's the current user, we need to verify the old password
                checkPassword(localLoginId.tenantAlias, localLoginId.externalId, oldPassword, function(err, checkedUserId) {
                    if (err) {
                        // old password was probably incorrect
                        log().error({'err': err}, 'User %s failed to change password for %s', ctx.user().id, userId);
                        return callback(err);
                    }

                    log().info('User %s is changing the password for user %s', ctx.user().id, userId);
                    return _changePassword(localLoginId, newPassword, callback);
                });
            }
        } else {
            return callback({'code': 400, 'msg': 'User does not have a local account mapping.'});
        }
    });
};

/**
 * Checks the password for a specified login id
 *
 * @param  {String}    tenantAlias      The alias of the tenant to which the user belongs
 * @param  {String}    username         The local username of the user
 * @param  {String}    password         The password that can be used to compare with the one in the DB.
 * @param  {Function}  callback         Invoked when the process completes
 * @param  {Object}    callback.err     If the password check fails, this will be an error with `err.code === 401`. If there is an unexpected internal error, this will be that error.
 * @param  {object}    callback.userId  The ID of the user if the passwords match
 */
var checkPassword = module.exports.checkPassword = function(tenantAlias, username, password, callback) {
    // we can only check password on local authentication
    var loginId = new LoginId(tenantAlias, AuthenticationConstants.providers.LOCAL, username);

    var validator = new Validator();
    _validateLoginIdForLookup(validator, loginId);
    if (validator.hasErrors()) {
        return new callback(validator.getFirstError());
    }

    Cassandra.runQuery('SELECT userId, password FROM AuthenticationLoginId USING CONSISTENCY QUORUM WHERE loginId = ?', [ _flattenLoginId(loginId) ], function(err, rows) {
        if (err) {
            return callback(err);
        }

        if (rows[0].count === 0) {
            // No user found with that username.
            return callback({'code': 401, 'msg': 'No password found for this principal'});
        }

        // Check if the user provided password matches the stored password
        var result = Cassandra.rowToHash(rows[0]);
        var passwordMatches = result.userId && result.password && AuthenticationUtil.hashAndComparePassword(password, result.password);
        if (passwordMatches) {
            callback(null, result.userId);
        } else {
            log().info('Invalid password check for user %s', username);
            callback({'code': 401, 'msg': 'User name and/or password do not match.'});
        }
    });
};

/**
 * Gets the userId that is associated to the provided login ID, if any.
 *
 * @param   {String}    tenantAlias     The tenant of the login id
 * @param   {String}    provider        The provider of the login id (e.g., twitter, local, google...)
 * @param   {String}    externalId      The id of the user in the external authentication service
 * @param   {Function}  callback        Invoked when the process completes
 * @param   {Object}    callback.err    An error that occurred, if any
 * @param   {String}    callback.userId The id of the user that was associated to the login id, if any
 */
var getUserIdFromLoginId = module.exports.getUserIdFromLoginId = function(tenantAlias, provider, externalId, callback) {
    var loginId = new LoginId(tenantAlias, provider, externalId);

    var validator = new Validator();
    _validateLoginIdForLookup(validator, loginId);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getUserIdFromLoginId(loginId, callback);
};

/**
 * Hash `newPassword` and store it as the new password for the given `loginId`.
 *
 * @param   {LoginId}   loginId         The login id whose password to change
 * @param   {String}    newPassword     The password to which to change the local login id
 * @param   {Function}  callback        Invoked when the process completes
 * @param   {Object}    callback.err    An error that occurred, if any
 * @api private
 */
var _changePassword = function(loginId, newPassword, callback) {
    var hash = AuthenticationUtil.hashPassword(newPassword);
    Cassandra.runQuery('UPDATE AuthenticationLoginId USING CONSISTENCY QUORUM SET password = ? WHERE loginId = ?', [hash, _flattenLoginId(loginId)], function(err) {
        if (err) {
            log().error({'err': err}, 'Error changing a user password.');
            return callback(err);
        }

        return callback();
    });
};

/**
 * Associate the given Login ID info to the specified user. This makes it possible for the associated user to login with the provided
 * login credentials.
 *
 * @param   {LoginId}   loginId         The login id to associate
 * @param   {String}    userId          The id of the user in the database
 * @param   {Function}  callback        Invoked when the process completes
 * @param   {Object}    callback.err    An error that occurred, if any
 * @api private
 */
var _associateLoginId = function(loginId, userId, callback) {
    loginId.properties = loginId.properties || {};
    var flattenedLoginId = _flattenLoginId(loginId);

    // sanitize and prepare the columns for the upsert
    delete loginId.properties.loginId;
    loginId.properties.userId = userId;

    var query = Cassandra.constructUpsertCQL('AuthenticationLoginId', 'loginId', flattenedLoginId, loginId.properties);
    if (query) {
        var queries = [];
        queries.push(query);
        queries.push({
            'query': 'UPDATE AuthenticationUserLoginId SET ? = ? WHERE userId = ?',
            'parameters': [flattenedLoginId, '1', userId]
        });
        return Cassandra.runBatchQuery(queries, 'QUORUM', callback);
    } else {
        log().error({
            loginId: loginId,
            userId: userId
        }, 'Error constructing query to associate login id to user.');
        return callback({'code': 500, 'msg': 'Error associating login id to user ' + userId});
    }
};

/**
 * Get the login ids that are mapped to a user.
 *
 * @param {String}      userId              The id of the user
 * @param {Function}    callback            Invoked when the prcess completes
 * @param {Object}      callback.err        An error that occurred, fi any
 * @param {Object}      callback.loginIds   A hash whose keys are the authentication providers, and values are the LoginId objects that are mapped to the user
 * @api private
 */
var _getUserLoginIds = function(userId, callback) {
    if (!userId) {
        return callback(null, {});
    }

    Cassandra.runQuery('SELECT * FROM AuthenticationUserLoginId USING CONSISTENCY QUORUM WHERE userId = ?', [userId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var loginIds = {};
        var row = rows[0];
        for (var i = 0; i < row.count; i++) {
            var name = row[i].name;
            if (name !== 'userId') {
                var loginId = _expandLoginId(name);
                loginIds[loginId.provider] = loginId;
            }
        }

        return callback(null, loginIds);
    });
};

/**
 * Gets the userId that is associated to the provided login ID, if any.
 *
 * @param   {LoginId}   loginId         The login id to search
 * @param   {Function}  callback        Invoked when the process completes
 * @param   {Object}    callback.err    An error that occurred, if any
 * @param   {String}    callback.userId The id of the user that was associated to the login id, if any
 * @api private
 */
var _getUserIdFromLoginId = function(loginId, callback) {
    Cassandra.runQuery('SELECT userId FROM AuthenticationLoginId USING CONSISTENCY QUORUM WHERE loginId = ?', [ _flattenLoginId(loginId) ], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var row = rows[0];
        if (row) {
            var result = Cassandra.rowToHash(row);
            return callback(null, result.userId);
        } else {
            return callback();
        }
    });
};

/**
 * Flatten a LoginId object into a string representation that can be used for a storage key. This is in the following format:
 *
 * `<tenantAlias>:<authentication provider>:<external id>`
 *
 * @param   {LoginId}   loginId     The login id to flatten
 * @return  {String}                The flattened string key representation of the login id
 * @api private
 */
var _flattenLoginId = function(loginId) {
    if (!loginId || !loginId.tenantAlias || !loginId.provider || !loginId.externalId) {
        return null;
    }
    return loginId.tenantAlias + ':' + loginId.provider + ':' + loginId.externalId;
};

/**
 * Expand a flattened key representation of a login id into a LoginId object. This is the opposite of #_flattenLoginId.
 *
 * @param   {String}    loginIdStr  The flat string key representation of the login id
 * @return  {LoginId}               The LoginId object that is represented by the flat string
 * @api private
 */
var _expandLoginId = function(loginIdStr) {
    if (!loginIdStr) {
        return null;
    }

    var loginIdSplit = loginIdStr.split(':');
    if (loginIdSplit.length < 3) {
        return null;
    }

    // the externalId can contain *anything*, including colons. keep that in-tact with a slice-and-join.
    return new LoginId(loginIdSplit[0], loginIdSplit[1], loginIdSplit.slice(2).join(':'));
};

/**
 * Verify that the given login ID is suitable to be used to look up a user id mapping.
 *
 * @param {Validator}       validator   The validator to use to validate the loginId
 * @param {LoginId}         loginId     The login id to validate
 * @api private
 */
var _validateLoginIdForLookup = function(validator, loginId) {
    var numErrors = validator.getErrorCount();
    validator.check(null, {'code': 400, 'msg': 'Must specify a login id.'}).isObject(loginId);
    if (validator.getErrorCount() === numErrors) {
        // only validate these if loginId is a valid object
        validator.check(loginId.tenantAlias, {'code': 400, 'msg': 'Must specify a tenant id on the login id'}).notEmpty();
        validator.check(loginId.provider, {'code': 400, 'msg': 'Must specify an authentication provider on the login id'}).notEmpty();
        validator.check(loginId.externalId, {'code': 400, 'msg': 'Must specify an external id on the login id'}).notEmpty();
    }
};

/**
 * Verify that the given login ID is suitable to be persisted to storage.
 *
 * @param {Validator}       validator   The validator to use to validate the loginId
 * @param {LoginId}         loginId     The login id to validate
 * @api private
 */
var _validateLoginIdForPersistence = function(validator, loginId) {
    var numErrors = validator.getErrorCount();
    _validateLoginIdForLookup(validator, loginId);

    // only continue validating if the login id is valid so far
    if (validator.getErrorCount() === numErrors) {
        loginId.properties = loginId.properties || {};

        // custom handling for local authentication (i.e., username and password)
        if (loginId.provider === AuthenticationConstants.providers.LOCAL) {
            validator.check(loginId.properties.password, {'code': 400, 'msg': 'Must specify a password at least 6 characters long.'}).len(6);
        }
    }
};

/////////////
//  LOCAL  //
/////////////

/**
 * Function that will be called by passport to check that a username + password combination is valid
 * 
 * @param  {Request}     req             The express HTTP request object
 * @param  {String}      username        The username entered by the user
 * @param  {String}      password        The password entered by the user
 * @param  {Function}    done            Standard callback function
 * @param  {Object}      done.err        Error object containing the error message and error code
 * @param  {User}        done.user       The user object representing the logged in user when the login has been succesful
 * @api private
 */
var passwordCallback = function(req, username, password, done) {
    var tenant = req.tenant;
    checkPassword(tenant.alias, username, password, function(err, userId) {
        if (err && err.code === 401) {
            // password incorrect
            return done(null, false);
        } else if (err) {
            // some internal error occurred
            return done(err);
        }

        // By this point we know that we were succesfully logged in.
        // Retrieve the user account and stick it in the context.
        req.ctx = new Context(tenant, new User(tenant.alias, userId));
        PrincipalsAPI.getUser(req.ctx, userId, function(err, user) {
            if (err) {
                return done(err);
            }
            req.ctx = new Context(tenant, user);
            return done(null, user);
        });
    });
};



//////////////
//  GOOGLE  //
//////////////

/**
 * Register a new Google passport login strategy for a tenant
 * 
 * @param {Tenant}  tenant      Tenant for which we want to register the Google login strategy
 * @api private
 */
var setupGoogle = function(tenant) {
    var strategy = new GoogleStrategy({
        'providerURL': 'https://www.google.com/accounts/o8/id',
        'profile': true,
        'returnURL' : 'http://' + tenant.host + '/api/auth/google/callback',
        'realm': 'http://' + tenant.host + '/'
    }, function(identifier, profile, done) {
        var username = profile.emails[0].value;
        var displayName = profile.name.givenName + " " + profile.name.familyName;

        // TODO: Get locale/timezone.
        var context = new Context(tenant, null);
        getOrCreateUser(context, AuthenticationConstants.providers.GOOGLE, username, displayName, null, done);
    });
    passport.use('google-' + tenant.alias, strategy);
    strategies[tenant.alias].push(strategy);
};

///////////////
//  TWITTER  //
///////////////

/**
 * Register a new Twitter passport login strategy for a tenant
 * 
 * @param {Tenant}  tenant      Tenant for which we want to register the Twitter login strategy
 * @api private
 */
var setupTwitter = function(tenant) {
    var strategy = new TwitterStrategy({
            'consumerKey': '8eET3GSaCVE5GVd5kZsw',
            'consumerSecret': 'OIqx7h36fMWqc0Cb3tUI1jzp7bzCbE2F3zJ0Gladc',
            'callbackURL': 'http://' + tenant.host + '/api/auth/twitter/callback'
    }, function(token, tokenSecret, profile, done) {
        // Use the Twitter handle to register this user.
        var username = profile.username;
        var displayName = profile.displayName;
        var opts = {
            timezone: profile._json.time_zone
        };

        var context = new Context(tenant, null);
        getOrCreateUser(context, AuthenticationConstants.providers.TWITTER, username, displayName, opts, done);
    });
    passport.use('twitter-' + tenant.alias, strategy);
    strategies[tenant.alias].push(strategy);
};


////////////////
//  FACEBOOK  //
////////////////

/**
 * Register a new Facebook passport login strategy for a tenant
 * 
 * @param {Tenant}  tenant      Tenant for which we want to register the Facebook login strategy
 * @api private
 */
var setupFacebook = function(tenant) {
    var strategy = new FacebookStrategy({
        'clientID': '194758077323671',
        'clientSecret': '663d14e7f9ad0baeb4e43390825a659f',
        'callbackURL': 'http://' + tenant.host + '/api/auth/facebook/callback'
    }, function(accessToken, refreshToken, profile, done) {
        var username = profile.username;
        var displayName = profile.displayName;
        var opts = {
            locale: profile._json.locale
        };

        var context = new Context(tenant, null);
        getOrCreateUser(context, AuthenticationConstants.providers.FACEBOOK, username, displayName, opts, done);
    });
    passport.use('facebook-' + tenant.alias, strategy);
    strategies[tenant.alias].push(strategy);
};
