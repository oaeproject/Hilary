/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var _ = require('underscore');
var AuthzAPI = require('oae-authz');
var AuthzUtil = require('oae-authz/lib/util');
var log = require('oae-logger').logger('oae-activity');
var MQ = require('oae-util/lib/mq');
var Validator = require('oae-authz/lib/validator').Validator;

var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;
var ActivityDAO = require('./internal/dao');
var ActivityStream = require('oae-activity/lib/model').ActivityStream;

var activityProducers = {};
var activityRouters = {};
var boundWorker = false;

/**
 * Refresh the activities configuration.
 *
 * @param   {Boolean}       [processActivityJobs]   Whether or not this server node should produce and route activities. Defaults to `true`.
 * @param   {Number}        [activityTtl]           The time-to-live (in seconds) for generated activities. Defaults to 2 weeks.
 * @param   {Function}      [callback]              Invoked when the configuration has been refreshed
 * @param   {Object}        [callback.err]          An error that occurred, if any
 */
var refreshConfiguration = module.exports.refreshConfiguration = function(processActivityJobs, activityTtl, callback) {
    // If the value is not exactly `false`, default to true.
    processActivityJobs = (processActivityJobs !== false);
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Error refreshing activities configuration.');
        }
    };

    log().trace({
        'processActivityJobs': processActivityJobs,
        'activityTtl': activityTtl
    }, 'Refreshing activity configuration.');

    // Push the TTL into the DAO
    ActivityDAO.refreshConfiguration(activityTtl);

    // Enable / Disable the worker binding, if necessary
    if (processActivityJobs && !boundWorker) {
        boundWorker = true;
        return MQ.bind(ActivityConstants.mq.TASK_ACTIVITY, _handleActivityTask, callback);
    } else if (!processActivityJobs && boundWorker) {
        boundWorker = false;
        return MQ.unbind(ActivityConstants.mq.TASK_ACTIVITY, callback);
    } else {
        return callback();
    }
};

/**
 * Register an activity producer. The activity producer is responsible for taking a single resource object from the activity seed
 * and converting it into an ActivityEntity that can be used in an activity.
 *
 * The activity entity `propagation` rule specifies how the activity entity information should be propagated across the different
 * routes. The values signify the following:
 *
 * * `ActivityConstants.entityPropagation.ALL`: The data in the activity entity will be propagated to *all* routes that are generated for the current entity, and all other entity routes that are part of the activity
 * * `ActivityConstants.entityPropagation.OWN`: The data in the activity entity will be propagated to only the routes that are produced for the entity
 *
 * @param   {String}         resourceType                     The type of resource this producer is meant to produce activity objects for (e.g., content, comment, user...)
 * @param   {Function}       producer                         The function that will convert the resource object into an activity object
 * @param   {String}         producer.activityType            The type of activity being generated
 * @param   {String}         producer.entityType              The entity type for which this entity is being produced. One of actor, object, target
 * @param   {String}         producer.resource                The resource seed object that describes the resource to use to generate the activity object
 * @param   {Function}       producer.callback                The function to invoke when the object has been produced
 * @param   {Object}         producer.callback.err            An error that occurred, if any
 * @param   {ActivityEntity} producer.callback.activityEntity The activity object that was produced
 * @param   {String}         producer.callback.propagation    How the activity object should be propagated across other routes. The valid values are enumerated by `ActivityConstants.entityPropagation`
 */
var registerActivityEntityProducer = module.exports.registerActivityEntityProducer = function(resourceType, producer) {
    if (activityProducers[resourceType]) {
        throw new Error('Attempted to register duplicate activity producer');
    }
    activityProducers[resourceType] = producer;
};

/**
 * Register an activity router. The activity producer is responsible for taking a single resource object from the activity seed
 * and converting it into an ActivityEntity that can be used in an activity.
 *
 * @param   {String}         resourceType               The type of resource this router is meant to route (e.g., content, comment, user...)
 * @param   {Function}       router                     The function that will convert the resource object into an activity object
 * @param   {String}         router.activityType        The type of activity being routed
 * @param   {String}         router.entityType          The entity type for which this object is being routed. One of actor, object, target
 * @param   {ActivityEntity} router.activityEntity      The activity object model that was produced for the resource
 * @param   {Function}       router.callback            The function to invoke when the object has been produced
 * @param   {Object}         router.callback.err        An error that occurred, if any
 * @param   {ActivityEntity} router.callback.routes     The routes to which the activity should be delivered
 */
var registerActivityRouter = module.exports.registerActivityRouter = function(resourceType, router) {
    if (activityRouters[resourceType]) {
        throw new Error('Attempted to register duplicate activity router');
    }
    activityRouters[resourceType] = router;
};

/**
 * Get the activity stream by the specified id.
 *
 * @param   {Context}       ctx                 The context of the current session
 * @param   {Number|String} start               Number of millis since the epoc (stringified or number version) from which to start returning activities. Only activities older than this timestamp will be returned.
 * @param   {Number}        limit               The number of activities to return
 * @param   {Function}      callback            Invoked when the process completes
 * @param   {Object}        callback.err        An error that occurred, if any
 * @param   {Activity[]}    callback.activities The list of activities
 */
var getActivityStream = module.exports.getActivityStream = function(ctx, activityStreamId, start, limit, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 400, 'msg': 'Must be logged in to see an activity stream'}).isLoggedInUser(ctx);
    validator.check(activityStreamId, {'code': 400, 'msg': 'Must specify an activity stream'}).notEmpty();
    validator.check(activityStreamId, {'code': 400, 'msg': 'You can only view activity streams for a principal'}).isPrincipalId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var userId = ctx.user().id;
    var targetAuthzPrincipal = AuthzUtil.getPrincipalFromId(activityStreamId);
    if (ctx.user().isAdmin(targetAuthzPrincipal.tenantAlias)) {
        // Admin of the target tenant can always see the stream
        return _getActivityStream(activityStreamId, start, limit, callback);
    } else if (AuthzUtil.isGroupId(activityStreamId)) {
        // You can only view a group's activity stream if you are a member of that group
        return AuthzAPI.hasAnyRole(userId, activityStreamId, function(err, hasAnyRole) {
            if (err) {
                return callback(err);
            } else if (!hasAnyRole) {
                return callback({'code': 401, 'msg': 'Must be a member of a group to see its activity stream'});
            }

            return _getActivityStream(activityStreamId, start, limit, callback);
        });
    } else if (activityStreamId === userId) {
        // You can only view a user's activity stream if it is yourself. No peeking at other user streams.
        return _getActivityStream(activityStreamId, start, limit, callback);
    }

    // If we're here, we were trying to view another user's activity stream, not allowed!
    return callback({'code': 401, 'msg': 'You are not authorized to see this user\'s activity stream'});
};

/**
 * Post an activity in the system to be routed.
 *
 * @param   {ActivitySeed}  activitySeed        The activity "seed" object, which represents the smallest amount of information necessary to generate an activity
 * @param   {Function}      callback            Invoked when the activity has been posted (but has not been routed yet)
 * @param   {Object}        callback.err        An error that occurred, if any
 */
var postActivity = module.exports.postActivity = function(activitySeed, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'activitySeed': activitySeed}, 'Error posting activity.');
        }
    };

    var validator = new Validator();

    // Validate top-level activity properties
    validator.check(null, {'code': 400, 'msg': 'No activity seed provided.'}).isObject(activitySeed);
    validator.check(activitySeed.activityType, {'code': 400, 'msg': 'Activity seed did not have an activity type.'}).notEmpty();
    validator.check(activitySeed.verb, {'code': 400, 'msg': 'Activity seed did not have a verb.'}).notEmpty();

    // Validate the actor resource
    validator.check(null, {'code': 400, 'msg': 'Activity seed did not have an actor resource'}).isObject(activitySeed.actorResource);
    validator.check(activitySeed.actorResource.resourceId, {'code': 400, 'msg': 'Actor of activity seed did not have a resourceId'}).notEmpty();
    validator.check(activitySeed.actorResource.resourceType, {'code': 400, 'msg': 'Actor of activity seed did not have a resourceType'}).notEmpty();

    // Validate the object resource
    if (activitySeed.objectResource) {
        validator.check(activitySeed.objectResource.resourceId, {'code': 400, 'msg': 'Object of activity seed was specified and did not have a resourceId'}).notEmpty();
        validator.check(activitySeed.objectResource.resourceType, {'code': 400, 'msg': 'Object of activity seed was specified and did not have a resourceType'}).notEmpty();
    }

    // Validate the target resource
    if (activitySeed.targetResource) {
        validator.check(activitySeed.targetResource.resourceId, {'code': 400, 'msg': 'Target of activity seed was specified and did not have a resourceId'}).notEmpty();
        validator.check(activitySeed.targetResource.resourceType, {'code': 400, 'msg': 'Target of activity seed was specified and did not have a resourceType'}).notEmpty();
    }

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    MQ.submit(ActivityConstants.mq.TASK_ACTIVITY, activitySeed, callback);
};

/**
 * Internal function to get an activity stream by its ID. This bypasses permission checks.
 *
 * @param   {String}            activityStreamId        The ID of the activity stream to fetch
 * @param   {Number}            start                   The starting timestamp of the activities to fetch
 * @param   {Number}            limit                   The number of activities to fetch
 * @param   {Function}          callback                Invoked when the process completes
 * @param   {Object}            callback.err            An error that occurred, if any
 * @param   {ActivityStream}    callback.activityStream The activity stream
 * @api private
 */
var _getActivityStream = function(activityStreamId, start, limit, callback) {
    ActivityDAO.getActivities(activityStreamId, start, limit, function(err, activities) {
        if (err) {
            return callback(err);
        }

        // Wrap the activities into an activity stream
        return callback(null, new ActivityStream(activities));
    });
};

/**
 * Task handler to generate and route the activities when a task is sent.
 *
 * @param   {ActivitySeed}  activitySeed        The activity seed that was used to post the activity
 * @param   {Function}      [callback]          Invoked when the process completes
 * @param   {Object}        [callback.err]      An error that occurred, if any
 * @api private
 */
var _handleActivityTask = function(activitySeed, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Error handling activity.');
        }
    };

    // Will aggregate all the activityStreamId (i.e., route) -> activity pairings that will be delivered
    var activityStreamUpdates = {};

    var activityType = activitySeed.activityType;
    var published = activitySeed.published;
    var verb = activitySeed.verb;

    // Produce all of the activity entities
    _produceAllEntities(activitySeed, function(err, actor, actorPropagation, object, objectPropagation, target, targetPropagation) {
        if (err) {
            return callback(err);
        }

        // Produce the routes for the actor, object and target entities
        _produceAllRoutes(activitySeed, actor, object, target, function(err, actorRoutes, objectRoutes, targetRoutes) {
            if (err) {
                return callback(err);
            }

            // 1. Create all routes and apply the "OWN" propagation entities. this is how private entities get delivered to feeds
            for (var i = 0; i < actorRoutes.length; i++) {
                var actorRoute = actorRoutes[i];
                activityStreamUpdates[actorRoute] = activityStreamUpdates[actorRoute] || {};
                if (actorPropagation === ActivityConstants.entityPropagation.OWN) {
                    activityStreamUpdates[actorRoute].actor = activityStreamUpdates[actorRoute].actor || actor;
                }
            }

            for (var i = 0; i < objectRoutes.length; i++) {
                var objectRoute = objectRoutes[i];
                activityStreamUpdates[objectRoute] = activityStreamUpdates[objectRoute] || {};
                if (objectPropagation === ActivityConstants.entityPropagation.OWN) {
                    activityStreamUpdates[objectRoute].object = activityStreamUpdates[objectRoute].object || object;
                }
            }

            for (var i = 0; i < targetRoutes.length; i++) {
                var targetRoute = targetRoutes[i];
                activityStreamUpdates[targetRoute] = activityStreamUpdates[targetRoute] || {};
                if (targetPropagation === ActivityConstants.entityPropagation.OWN) {
                    activityStreamUpdates[targetRoute].target = activityStreamUpdates[targetRoute].target || target;
                }
            }

            // 2. Back-fill all entities that are set to propagate on "all". Also apply the minimum data (i.e., the resource type and id) where necessary.
            _.values(activityStreamUpdates).forEach(function(activity) {
                activity[ActivityConstants.properties.OAE_ACTIVITY_TYPE] = activityType;
                activity.verb = verb;
                activity.published = published;

                // Backfill the appropriate actor data (there should always be an actor associated to the activity)
                if (activitySeed.actorResource) {
                    if (!activity.actor && actorPropagation === ActivityConstants.entityPropagation.ALL) {
                        activity.actor = actor;
                    } else if (!activity.actor) {
                        // This activity will not receive the actor. Instead, fill in the minimum amount of data that we can (resourceType and resourceId)
                        activity.actor = {};
                        activity.actor.objectType = activitySeed.actorResource.resourceType;
                        activity.actor[ActivityConstants.properties.OAE_ID] = activitySeed.actorResource.resourceId;
                    }
                }

                // Backfill the appropriate object data if there was an object associated to the activity
                if (activitySeed.objectResource) {
                    if (!activity.object && objectPropagation === ActivityConstants.entityPropagation.ALL) {
                        activity.object = object;
                    } else if (!activity.object) {
                        // This activity will not receive the object. Instead, fill in the minimum amount of data that we can (resourceType and resourceId)
                        activity.object = {};
                        activity.object.objectType = activitySeed.objectResource.resourceType;
                        activity.object[ActivityConstants.properties.OAE_ID] = activitySeed.objectResource.resourceId;
                    }
                }

                // Backfill the appropriate target data if there was a target associated to the activity
                if (activitySeed.targetResource) {
                    if (!activity.target && targetPropagation === ActivityConstants.entityPropagation.ALL) {
                        activity.target = target;
                    } else if (!activity.target) {
                        // This activity will not receive the target. Instead, fill in the minimum amount of data that we can (resourceType and resourceId)
                        activity.target = {};
                        activity.target.objectType = activitySeed.targetResource.targetType;
                        activity.target[ActivityConstants.properties.OAE_ID] = activitySeed.targetResource.resourceId;
                    }
                }
            });

            log().trace({
                'activitySeed': activitySeed,
                'activityStreamUpdates': activityStreamUpdates
            }, 'Applying updates to activity streams.');

            // Finally store the activities in the DB
            ActivityDAO.saveActivities(activityStreamUpdates);
        });
    });
};

/**
 * Produce activity entities based on the actor, object and target resources of the given activity seed.
 *
 * @param   {ActivitySeed}      activitySeed                The activity seed from which to extract the actor, object and target resource information
 * @param   {Function}          callback                    Invoked when the process completes
 * @param   {Object}            callback.err                An error that occurred, if any
 * @param   {ActivityEntity}    callback.actor              The actor activity entity
 * @param   {String}            callback.actorPropagation   The actor entity propagation rule
 * @param   {ActivityEntity}    callback.object             The object activity entity
 * @param   {String}            callback.objectPropagation  The object entity propagation rule
 * @param   {ActivityEntity}    callback.target             The actor activity entity
 * @param   {String}            callback.targetPropagation  The actor entity propagation rule
 * @api private
 */
var _produceAllEntities = function(activitySeed, callback) {
    _produceEntity(activitySeed.activityType, ActivityConstants.entityTypes.ACTOR, activitySeed.actorResource, function(err, actor, actorPropagation) {
        if (err) {
            return callback(err);
        }

        _produceEntity(activitySeed.activityType, ActivityConstants.entityTypes.OBJECT, activitySeed.objectResource, function(err, object, objectPropagation) {
            if (err) {
                return callback(err);
            }

            _produceEntity(activitySeed.activityType, ActivityConstants.entityTypes.TARGET, activitySeed.targetResource, function(err, target, targetPropagation) {
                if (err) {
                    return callback(err);
                }

                return callback(null, actor, actorPropagation, object, objectPropagation, target, targetPropagation);
            });
        });
    });
};

/**
 * Produce the routes for the given actor, object and target activity entities.
 *
 * @param   {ActivitySeed}      activitySeed            The activity seed that was used to post the activity
 * @param   {ActivityEntity}    actor                   The actor activity entity for which to generate routes
 * @param   {ActivityEntity}    object                  The object activity entity for which to generate routes
 * @param   {ActivityEntity}    target                  The target activity entity for which to generate routes
 * @param   {Function}          callback                Invoked when the process completes
 * @param   {Object}            callback.err            An error that occurred, if any
 * @param   {String[]}          callback.actorRoutes    The routes to which to route the activity for the actor
 * @param   {String[]}          callback.objectRoutes   The routes to which to route the activity for the object
 * @param   {String[]}          callback.targetRoutes   The routes to which to route the activity for the target
 * @api private
 */
var _produceAllRoutes = function(activitySeed, actor, object, target, callback) {
    log().trace({
        'activitySeed': activitySeed,
        'actor': actor,
        'object': object,
        'target': target
    }, 'Producing routes for activity entities.');

    _produceRoutes(activitySeed.activityType, ActivityConstants.entityTypes.ACTOR, activitySeed.actorResource, actor, function(err, actorRoutes) {
        if (err) {
            return callback(err);
        }

        _produceRoutes(activitySeed.activityType, ActivityConstants.entityTypes.OBJECT, activitySeed.objectResource, object, function(err, objectRoutes) {
            if (err) {
                return callback(err);
            }

            _produceRoutes(activitySeed.activityType, ActivityConstants.entityTypes.TARGET, activitySeed.targetResource, target, function(err, targetRoutes) {
                if (err) {
                    return callback(err);
                }

                return callback(null, actorRoutes, objectRoutes, targetRoutes);
            });
        });
    });
};

/**
 * Produce the routes for the activity entity.
 *
 * @param   {String}                activityType        The type of activity being routed
 * @param   {String}                entityType          The type of entity for which activities are being routed (e.g., actor, object, target)
 * @param   {ActivitySeedResource}  resource            The activity resource that was used to generate the activity entity
 * @param   {ActivityEntity}        activityEntity      The activity entity for which the routes are being generated
 * @param   {Function}              callback            Invoked when the process completes
 * @param   {Object}                callback.err        An error that occurred, if any
 * @param   {String[]}              callback.routes     The routes to which to route the activity
 * @api private
 */
var _produceRoutes = function(activityType, entityType, resource, activityEntity, callback) {
    if (!resource || !activityEntity) {
        return callback(null, []);
    }

    var router = activityRouters[resource.resourceType];
    if (!router) {
        log().trace({
            'activityType': activityType,
            'entityType': entityType,
            'resource': resource,
            'activityEntity': activityEntity 
        }, 'No router found for object type.');
        return callback();
    }

    router(activityType, entityType, activityEntity, function(err, routes) {
        if (err) {
            return callback(err);
        }

        routes = routes || [];

        log().trace({
            'activityType': activityType,
            'entityType': entityType,
            'resource': resource,
            'activityEntity': activityEntity,
            'routes': routes
        }, 'Generated routes for activity entity.');
        
        return callback(null, routes);
    });
};

/**
 * Produce an activity entity with the given seed resource information.
 *
 * @param   {String}                activityType            The type of activity for which the entity is being produced
 * @param   {String}                entityType              The type of entity for which the entity is being produced (i.e., actor, object or target)
 * @param   {ActivitySeedResource}  resource                The activity resource that was used to seed the activity
 * @param   {Function}              callback                Invoked when the process completes
 * @param   {Object}                callback.err            An error that occurred, if any
 * @param   {ActivityEntity}        callback.activityEntity The activity entity that was produced
 * @param   {String}                callback.propagation    A rule specifying how the activity entity should be propagated across the routes. The possible values are enumerated by `ActivityConstants.entityPropagation`
 * @api private
 */
var _produceEntity = function(activityType, entityType, resource, callback) {
    if (!resource) {
        return callback();
    }

    var producer = activityProducers[resource.resourceType];
    if (!producer) {
        log().error({
            'activityType': activityType,
            'entityType': entityType,
            'resource': resource
        }, 'No activity producer found for activity entity.');
        return callback({'code': 500, 'msg': 'No activity producer found for resource type "' + resource.resourceType + '"'});
    }

    producer(activityType, entityType, resource, function(err, entity, propagation) {
        if (err) {
            return callback(err);
        }

        // Ensure a valid propagation, resource id and resource type
        propagation = propagation || ActivityConstants.entityPropagation.DEFAULT;
        entity = entity || {};
        entity.objectType = resource.resourceType;
        entity[ActivityConstants.properties.OAE_ID] = resource.resourceId;

        log().trace({
            'activityType': activityType,
            'entityType': entityType,
            'resource': resource,
            'entity': entity
        }, 'Produced activity entity.');

        return callback(null, entity, propagation);
    });
};

