/**
 * Created by jimmykasprzak on 02/05/2016.
 */
var _ = require('underscore');
var assert = require('assert');
var temp = require('temp');
var async = require('async');

var Cassandra = require('oae-util/lib/cassandra');
var RestAPI = require('oae-rest');
var TestsUtil = require('oae-tests');
var TaskQueue = require('oae-util/lib/taskqueue');
var PreviewConstants = require('oae-preview-processor/lib/constants');

describe('Loodle delete', function () {

    // Rest context that can be used every time we need to make a request as an anonymous user
    var anonymousRestContext = null;

    // Rest contexts that can be used every time we need to make a request as a tenant admin
    var camAdminRestContext = null;
    var gtAdminRestContext = null;

    // Rest context that can be used every time we need to make a request as a global admin
    var globalAdminRestContext = null;

    /**
     * Create a number of users that will be used inside of a test
     * @param  {Function(contexts)}  callback           Standard callback function
     * @param  {Object}              callback.contexts  Object where the keys are identifiers for the created users and the values are an
     *                                                  object with a user key containing the user object for the created user and a restContext key
     *                                                  containing the REST Context for that user
     */
    var setUpUsers = function (callback) {
        var contexts = {};
        var createUser = function(identifier, visibility, displayName) {
            var userId = TestsUtil.generateTestUserId(identifier);
            var email = TestsUtil.generateTestEmailAddress(null, global.oaeTests.tenants.cam.emailDomain);
            RestAPI.User.createUser(camAdminRestContext, userId, 'password', displayName, email, {'visibility' : visibility}, function(err, createdUser) {
                if (err) {
                    assert.fail('Could not create test user');
                }
                contexts[identifier] = {
                    'user': createdUser,
                    'restContext': TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, userId, 'password')
                };
                if (_.keys(contexts).length === 7) {
                    callback(contexts);
                }
            });
        };

        createUser('nicolaas', 'public', 'Nicolaas Matthijs');
        createUser('simon', 'loggedin', 'Simon Gaeremynck');
        createUser('bert', 'private', 'Bert Pareyn');
        createUser('branden', 'private', 'Branden Visser');
        createUser('anthony', 'public', 'Anthony Whyte');
        createUser('stuart', 'public', 'Stuart Freeman');
        createUser('ian', 'public', 'Ian Dolphin');
    };

    /**
     * Function that will fill up the anonymous and tenant admin REST context
     */
    before(function (callback) {
        // Fill up anonymous rest context
        anonymousRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host);

        // Fill up tenant admin rest contexts
        camAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.cam.host);
        gtAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.gt.host);

        // Fill up global admin rest context
        globalAdminRestContext = TestsUtil.createGlobalAdminRestContext();

        // Log in the tenant admin so his cookie jar is set up appropriately. This is because TestsUtil.generateTestUsers
        // will concurrently try and create users, which causes race conditions when trying to authenticate the rest
        // context.
        RestAPI.User.getMe(camAdminRestContext, function(err, meObj) {
            assert.ok(!err);

            // Unbind the current handler, if any
            TaskQueue.unbind(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, function(err) {
                assert.ok(!err);

                /*!
                 * Task handler that will just drain the queue.
                 *
                 * @see MQ#bind
                 */
                var _handleTaskDrain = function(data, mqCallback) {
                    // Simply callback, which acknowledges the message without doing anything.
                    mqCallback();
                };

                // Drain the queue
                TaskQueue.bind(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, _handleTaskDrain, null, function(err) {
                    assert.ok(!err);
                    callback();
                });
            });
        });
    });

    /**
     * Function that will clean up any files that we have lingering around.
     */
    after(function () {
        temp.cleanup();
    });

    describe('Delete a loodle', function () {

        it('should delete correctly the loodle', function (callback) {

            setUpUsers(function (contexts) {

                // Create a loodle
                RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [], [], [], function (err, data) {
                    if (err) return callback(err);

                    // Delete a loodle
                    RestAPI.Content.deleteContent(contexts['branden'].restContext, data.id, function (err) {
                        if (err) return callback(err);

                        // Check the loodle has been correctly deleted
                        RestAPI.Content.getContent(contexts['branden'].restContext, data.id, function (err, content) {
                            assert.notEqual(err, null);
                            assert.equal(err.code, 404);
                            assert.equal(err.msg, 'Couldn\'t find content: ' + data.id);

                            return callback();
                        });
                    });
                });

            });

        });

    });

    describe('Delete a group', function () {

        it('should keep the access for the group users and keep them as participants too in all the loodles the group has access to', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a loodle inside of the group
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [group.id], [], [], function (err, data) {
                        if (err) return callback(err);

                        // Delete the group
                        RestAPI.Group.deleteGroup(contexts['branden'].restContext, group.id, function (err) {
                            if (err) return callback(err);

                            async.series({
                                // Check the loodle have not been deleted
                                loodleNotDeleted: function (done) {
                                    RestAPI.Content.getContent(contexts['branden'].restContext, data.id, function (err, content) {
                                        assert.equal(err, null);

                                        return done();
                                    });
                                },
                                // Check the group users have still access to the loodle
                                stillAccess: function (done) {
                                    RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                        assert.equal(err, null);

                                        return done();
                                    });
                                },
                                // Check the group users still registred as participants
                                stillParticipants: function (done) {
                                    RestAPI.Content.getContent(contexts['branden'].restContext, data.id, function (err, content) {
                                        assert.equal(err, null);

                                        var users = _.pluck(content.loodleData.users, 'first_name');
                                        assert.equal(users.length, 2);
                                        assert.equal(_.contains(users, 'Branden'), true);
                                        assert.equal(_.contains(users, 'Simon'), true);

                                        return done();
                                    });
                                }
                            }, callback);
                        })
                    });
                });

            });

        });

    });

    describe('Delete a folder', function () {

        it('should stop the access for all the folder users to all the folder loodles when only the folder is deleted', function (callback) {

            setUpUsers(function (contexts) {

                // Create a folder
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [contexts['simon'].user.id], [], function (err, folder) {
                    if (err) return callback(err);

                    // Create a loodle inside of the folder
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [], [], [folder.id], function (err, data) {
                        if (err) return callback(err);

                        // Delete the folder
                        RestAPI.Folders.deleteFolder(contexts['branden'].restContext, folder.id, false, function (err) {
                            if (err) return callback(err);

                            // Check the folder users don't have access to the loodle anymore
                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err) {
                                assert.notEqual(err, null);
                                assert.equal(err.code, 401);
                                assert.equal(err.msg, 'The current user does not have access to this resource');

                                return callback();
                            });
                        });
                    });
                });

            });

        });

        it('should delete correctly the folder loodles when the user asked to delete the folder content items too', function (callback) {

            setUpUsers(function (contexts) {

                // Create a folder
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [contexts['simon'].user.id], [], function (err, folder) {
                    if (err) return callback(err);

                    // Create a loodle inside of the folder
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [], [], [folder.id], function (err, data) {
                        if (err) return callback(err);

                        // Delete the folder with the content items
                        RestAPI.Folders.deleteFolder(contexts['branden'].restContext, folder.id, true, function (err) {
                            if (err) return callback(err);

                            // Check the loodle has been deleted
                            RestAPI.Content.getContent(contexts['branden'].restContext, data.id, function (err) {
                                assert.notEqual(err, null);
                                assert.equal(err.code, 404);
                                assert.equal(err.msg, 'Couldn\'t find content: ' + data.id);

                                return callback();
                            });
                        });
                    });
                });

            });

        });

    });

});

