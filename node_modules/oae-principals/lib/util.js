/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var bcrypt = require('bcrypt');
var rolesAPI = require('oae-roles/lib/api');
var rolesUtil = require('oae-roles/lib/util');
var cassandra = require('oae-util/lib/cassandra');
var User = require('./model').User;
var Group = require('./model').Group;


/**
 * Gets a principal from the DB and converts the returned data to the correct model (user or group).
 * @param  {String}   principal_id The ID of the principal that should be retrieved.
 * @param  {Function(err, principal)} callback     A callback method.
 */
module.exports.getPrincipal = function(principal_id, callback) {
    cassandra.runQuery('SELECT * FROM Principals WHERE principal_id = ?', [principal_id], function (err, rows) {
        if (err) {
            return callback({'code': 500, 'msg': err});
        }

        // Cassandra always returns the key as a column so the _colCount will always be 1.
        if (rows[0]._colCount === 1) {
            return callback({'code': 404, 'msg': "Couldn't find principal: " + principal_id});
        }

        var principal;
        if (module.exports.isGroup(principal_id)) {
            principal = rowToGroup(rows[0]);
        } else {
            principal = rowToUser(rows[0]);
        }

        callback(false, principal);
    });
};

/**
 * Gets a set of principals (user or groups). An error will be thrown if some of the user/group ids
 * don't exist
 * @param  {Array<String>}              principal_ids          The ID of the principal that should be retrieved.
 * @param  {Function(err, principals)}  callback               Standard callback function
 * @param  {Object}                     callback.err           Error object containing the error message
 * @param  {Object}                     callback.principals    Object representing the retrieved principals. The keys will be the
 *                                                             principal ids and the values will be the principal basic profiles
 */
module.exports.getPrincipals = function(principal_ids, callback) {
    cassandra.runQuery("SELECT * FROM Principals WHERE principal_id IN (?)", [principal_ids], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var principals = {};
        for (var r = 0; r < rows.length; r++) {
            // An empty row will come back for non-existing principals
            if (rows[r]._colCount !== 1) {
                if (module.exports.isGroup(rows[r].colHash.principal_id)) {
                    principals[rows[r].colHash.principal_id] = rowToGroup(rows[r]);
                } else {
                    principals[rows[r].colHash.principal_id] = rowToUser(rows[r]);
                }
            }
        }
        
        // Check if all of the provided principals exist
        if (_.keys(principals).length !== principal_ids.length) {
            return callback({
                'code': 400, 
                'msg': 'Not all of the provided principals exists. The following could not be found: "[' + _.without(principal_ids, _.keys(principals)) + ']"'
            });
        } else {
            return callback(null, principals);
        }
    });
};

/**
 * Explodes an array of group_ids down to all the underlying principals.
 * @param  {String[]  group_ids   An array of group_ids that should be exploded.
 * @param  {Boolean}  only_users  Whether or not the results should only include the users.
 * @param  {Function} callback  Standard callback method where the first argument is an error object
 *                              that contains a code suitable as http statuscode and a corresponding message.
 *                              The second argument holds the principals in this group.
 */
module.exports.explodePrincipals = function(group_ids, only_users, callback) {
    // Use a hash so we don't have doubles (ie: fake a Set)
    var group_user_members = {};

    // Simple parallel tree recursion algorithm.
    // We multi-get all the groups on each level in the tree.
    // ie: This is breadth-first.
    cassandra.runQuery("SELECT * FROM GroupMembers WHERE group_id IN (?)", [group_ids], function(err, rows) {
        var new_groups = [];
        // Iterate over the groups.
        for (var i = 0; i < rows.rowCount();i++) {
            // Iterate over the members in this group.
            for (var c = 0; c < rows[i]._colCount; c++) {
                var principal = rows[i].cols[c].name;
                if (principal === 'group_id')
                    continue;

                if (module.exports.isGroup(principal)) {
                    // Explode this group further.
                    new_groups.push(principal);
                    if (!only_users) {
                        group_user_members[principal] = true;
                    }
                } else {
                    group_user_members[principal] = true;
                }
            }
        }

        if (new_groups.length > 0) {
            module.exports.explodePrincipals(new_groups, only_users, function(err, principals) {
                for (var principal in principals) {
                    if (principals.hasOwnProperty(principal)) {
                        group_user_members[principal] = true;
                    }
                }
                callback(false, group_user_members);
            });
        }
        else {
            return callback(false, group_user_members);
        }
    });
};

/**
 * Check if an identifier really is a group identifier.
 * @param  {String}  group_id An identifier
 * @return {Boolean} Whether or not the provided identifier is a group identifier.
 */
module.exports.isGroup = function(group_id) {
    var principal = rolesUtil.getPrincipalFromUuid(group_id);
    return (principal.principalType === "g");
};

/**
 * Check if an identifier really is a user identifier.
 * @param  {String}  user_id An identifier
 * @return {Boolean} Whether or not the provided identifier is a user identifier.
 */
module.exports.isUser = function(user_id) {
    var principal = rolesUtil.getPrincipalFromUuid(user_id);
    return (principal.principalType === "u");
};


/**
 * Gets all the basic profile data for an array of principals
 * @param  {String[]}  principals  An array of principals for which the profile information should be retrieved.
 * @param  {Function} callback  Standard callback method where the first argument is an error object
 *                              that contains a code suitable as http statuscode and a corresponding message.
 *                              The second argument is an array where each object holds the basic profile data for a principal.
 */
module.exports.getBasicProfile = function(principals, callback) {
    cassandra.runQuery('SELECT * FROM Principals WHERE principal_id IN (?)', [principals], function (err, rows) {
        if (err) {
            return callback({'code': 500, 'msg': err});
        }

        members = [];
        for (var i = 0, j = rows.rowCount(); i<j;i++) {
            if (rows[i].colHash.principal_id.slice(0, 2) === "g:") {
                members.push(rowToGroup(rows[i]));
            } else {
                members.push(rowToUser(rows[i]));
            }
        }
        callback(false, members);
    });
};

/**
 * Ensures that a string is a valid username.
 * Limitations:
 *  1. No usernames longer than 200 chars.
 *  2. No colons in usernames.
 * @param  {[type]} username [description]
 * @return {[type]}
 */
module.exports.validateUserName = function(username) {
    // 1. length
    if (username.length > 250) {
        return "A username has an upper limit of 250 characters.";
    } else if (username.indexOf(':') !== -1) {
        return "A username can't contain a colon.";
    }

    return true;
};


/**
 * Hashes a string with bcrypt.
 * @param  {String}   password The passwords that needs to be hashed.
 * @param  {Function(hash)} callback Gets executed when the hash has been generated.
 */
module.exports.hashPassword = function(password, callback) {
    bcrypt.genSalt(10, function(err, salt) {
        bcrypt.hash(password, salt, function(err, hash) {
            callback(hash);
        });
    });
};

/**
 * Removes wonky characters from a string so it can be used as user/group-name.
 * @param  {String} name The name that needs to be cleaned.
 * @return {String} A clean name.
 */
module.exports.cleanName = function(name) {
    return name.replace(/[:;<>#%{}|~`@%&!$,.="'\^\+\/\?\(\)\*\s\\\\\[\]]/gi, '-');
};

/**
 * Creates a Group from a Cassandra row.
 * @param  {Row} row Cassandra Row
 * @return {Group}
 */
var rowToGroup = function (row) {
    return new Group(row.colHash.tenant, row.colHash.principal_id, row.colHash.visibility, row.colHash.group_title, row.colHash.group_description);
};

/**
 * Creates a User from a Cassandra row.
 * @param  {Row} row Cassandra Row
 * @return {User}
 */
var rowToUser = function(row) {
    return new User(row.colHash.tenant, row.colHash.principal_id, row.colHash.user_username, row.colHash.visibility, row.colHash.locale, row.colHash.timezone, row.colHash.user_first_name, row.colHash.user_last_name, row.colHash.user_display_name);
};