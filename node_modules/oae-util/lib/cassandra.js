var CassandraSystem = require('cassandra-client').System;
var Connection = require('cassandra-client').Connection;
var CassandraTypes = require('cassandra-client/lib/gen-nodejs/cassandra_types');
var _ = require('underscore');

// TODO: We need some kind of general configuring mechanisme
var sys = new CassandraSystem('127.0.0.1:9160');
var KEYSPACE = "oae";
var CONFIG = {hosts: 'localhost', 'port': 9160, keyspace: KEYSPACE, 'user': '', 'pass': ''};


/**
 * Takes a hash and applies all the new values on the old config.
 * @param  {Object} config The new values you wish to set on the CONFIG.
 */
module.exports.configure = function(config) {
    _.extend(CONFIG, config);
};

/**
 * Get a connection to Cassandra.
 * @return {Connection}
 */
module.exports.getConnection = function() {
    return new Connection(CONFIG);
};

/**
 * Closes all lingering connections to Casandra.
 * @param  {Function(err)} callback Gets called when the closing is done (or an error occured)
 */
module.exports.close = function(callback) {
    sys.close(callback);
};

/**
 * Create a keyspace
 * @param  {String}   name     The name of your keyspace
 * @param  {Function(err, created)} callback Callback method
 */
module.exports.createKeyspace = function(name, callback) {
    var ksDef = new CassandraTypes.KsDef({
        name: name, 
        strategy_class: 'org.apache.cassandra.locator.SimpleStrategy', 
        strategy_options: {
            'replication_factor': '1'
        }, 
        cf_defs: []
    });
    sys.addKeyspace(ksDef, function(err) {
        if (err) {
            callback(err, false);
        }
        else {
            callback(null, true);
        }
    });
};

/**
 * Drops a keyspace
 * @param  {String}   name     The keyspace that should be dropped.
 * @param  {Function(err, dropped)} callback dropped is a boolean that states whether or not a keyspace was dropped.
 * @return {[type]}
 */
module.exports.dropKeyspace = function(name, callback) {
    module.exports.runQuery("drop keyspace " + name, false, function(err) {
        if (err) {
            callback(err, false);
        }
        else {
            callback(false, true);
        }
    });
};

/**
 * Checks if a keyspace exists or not.
 * @param  {String}   name     The name of the keyspace to check.
 * @param  {Function(err, exists)} callback Gets called with an error object (if any) and a boolean whether or not the keyspace exists.
 */
module.exports.keyspaceExists = function(name, callback) {
    sys.describeKeyspace(CONFIG.keyspace, function(err, definition) {
        if (err) {
            return callback(err, false);
        }
        
        callback(null, true);
    });
};

/**
 * Checks if a CF exists or not.
 * @param  {String}   name     The name of the CF to check.
 * @param  {Function(err, exists)} callback Gets called with an error object (if any) and a boolean whether or not the CF exists.
 */
module.exports.columnFamilyExists = function(name, callback) {
    sys.describeKeyspace(CONFIG.keyspace, function(err, definition) {
        if (err) {
            return callback(err, false);
        }
        var exists = false;
        for (var i = 0; i < definition.cf_defs.length;i++) {
            if (definition.cf_defs[i].name === name) {
                exists = true;
                break;
            }
        }

        callback(null, exists);
    });
};


/**
 * Drops a Column family. A query will only be performed if the CF exists.
 * @param  {String}   name     The name of CF you wish to drop.
 * @param  {Function(err, dropped)} callback Gets called with an error object (if any) and a boolean whether or not the CF was dropped.
 */
module.exports.dropColumnFamily = function(name, callback) {
    // Only drop if it exists.
    module.exports.columnFamilyExists(name, function(err, exists) {
        if (err) {
            return callback(err, false);
        }

        if (exists) {
            module.exports.runQuery('drop columnfamily ?', [name], function(err) {
                if (err) {
                    callback(err, false);
                }
                else {
                    callback(null, true);
                }
            });
        } else {
            callback(null, false);
        }
    });
};

/**
 * Run a single Cassandra query.
 * @param  {String}   query      The CQL query
 * @param  {array}    parameters An array of values that can be interpreted by node-cassandra-client. If an element is detected as an array the query and parameters will be fixed.
 * @param  {Function} callback   Callback method.
 */
module.exports.runQuery = function(query, parameters, callback) {
    var fixed = fixQuery(query, parameters);
    executeQuery(fixed.query, fixed.parameters, callback);
};

/**
 * Run a batched Cassandra query.
 * @param  {Object[]}   queries  An array of simple hashes. Each hash should contain a query key and parameters key.
 * @param  {Function}   callback Callback method
 */
module.exports.runBatchQuery = function(queries, callback) {
    var query = 'BEGIN BATCH USING CONSISTENCY ONE \n';
    var parameters = [];
    for (var i = 0; i < queries.length;i++) {
        var fixed = fixQuery(queries[i].query, queries[i].parameters);
        query += fixed.query + "; \n";
        parameters = parameters.concat(fixed.parameters);
    }
    query += 'APPLY BATCH;';
    executeQuery(query, parameters, callback);
};

/**
 * Adds the ability to pass in array parameters. If you pass in a parameter that is an array, the apropriate number of question marks will be added in the query.
 * @param  {String}    query      The query
 * @param  {Object[]}  parameters The parameters for this query.
 */
var fixQuery = function(query, parameters) {
    var fixedQuery = "";
    var fixedParameters = [];
    var q = query.indexOf('?');
    var from = 0;
    var i = 0;
    while (q >= 0) {
        fixedQuery += query.slice(from, q);

        // If we passed in an array add n-1 more question marks.
        if (Array.isArray(parameters[i])) {
            for (var c = 0; c < parameters[i].length - 1;c++) {
                fixedQuery += "?, ";
                fixedParameters.push(parameters[i][c]);
            }
            fixedParameters.push(parameters[i][parameters[i].length - 1]);
        }
        else {
            fixedParameters.push(parameters[i]);
        }
        fixedQuery += '?';


        // Next one.
        from = q+1;
        q = query.indexOf('?', from);
        i++;
    }

    // Append the request of the query.
    fixedQuery += query.slice(from);
    return {'query': fixedQuery, 'parameters': fixedParameters};
};

/**
 * Actually executes a query
 * @param  {String}    query       The query
 * @param  {Object[]}  parameters  The parameters that match this query
 * @param  {Function}  callback    Callback
 */
var executeQuery = function(query, parameters, callback) {
    var con = module.exports.getConnection();
    con.connect(function(err){
        if (err) {
            return callback(err, null);
        }

        con.execute(query, parameters, function(err, rows) {
            con.close(function() {
                callback(err, rows);
            });
        });
    });
};