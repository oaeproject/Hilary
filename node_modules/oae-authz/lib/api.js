/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var Cassandra = require('oae-util/lib/cassandra');
var Telemetry = require('oae-telemetry').telemetry('authz');
var Validator = require('oae-authz/lib/validator').Validator;
var AuthzUtil = require('oae-authz/lib/util');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;


/////////////////////////
// ROLES & PERMISSIONS //
/////////////////////////

/**
 * Determine the direct role assigned to a principal on a specified resource.
 *
 * @param  {String}     principalId     The principal id. This can be a user or a group
 * @param  {String}     resourceId      The resource id. This can be a group as well.
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any.
 * @param  {String}     callback.role   The role of the principal on the resource. If the principal has no role or there is an error performing the check, role will be null.
 * @api private
 */
var _getDirectRole = function(principalId, resourceId, callback) {
    getDirectRoles([principalId], resourceId, function(err, roles) {
        if (err) {
            return callback(err);
        }

        return callback(null, roles[principalId]);
    });
};

/**
 * Determine the role assigned to the given principals directly on the specified resource instance.
 *
 * @param   {String[]}     principalIds    Array of principal ids. These can be user or group ids
 * @param   {String}       resourceId      The resource id. This can be a group as well.
 * @param   {Function}     callback        Standard callback function
 * @param   {Object}       callback.err    An error that occurred, if any.
 * @param   {Object}       callback.roles  A hash keyed by principal id, with value set to the role they have directly on the resource. If the principal has no role or there is an error performing the check, role will be null.
 **/
var getDirectRoles = module.exports.getDirectRoles = function(principalIds, resourceId, callback) {
    var validator = new Validator();
    validator.check(principalIds.length, {'code': 400, 'msg': 'At least one principal Id needs to be passed in'}).min(1);
    validator.check(resourceId, {'code': 400, 'msg': 'Invalid resource id provided.'}).isResourceId();
    _.each(principalIds, function(principalId) {
        validator.check(principalId, {'code': 400, 'msg': 'Invalid principal id provided.'}).isPrincipalId();
    });
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    Cassandra.runQuery('SELECT ? FROM AuthzMembers USING CONSISTENCY QUORUM WHERE resourceId = ?', [principalIds, resourceId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        // Aggregate the roles for the principals
        var roles = Cassandra.rowToHash(rows[0]);
        return callback(null, roles);
    });
};

/**
 * Given a principal and a resource, determine all the effective roles that the principal has on the resource, by virtue of direct
 * association and indirect group inheritance.
 *
 * @param  {String}       principalId       The principal id. This can be a user or a group
 * @param  {String}       resourceId        The resource id. This can be a group as well.
 * @param  {Function}     callback          Standard callback function
 * @param  {Object}       callback.err      An error that occurred, if any
 * @param  {String[]}     callback.roles    An array containing all the roles the principal has on the resource.
 */
var getAllRoles = module.exports.getAllRoles = function(principalId, resourceId, callback) {
    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'Invalid principal id provided.'}).isPrincipalId();
    validator.check(resourceId, {'code': 400, 'msg': 'Invalid resource id provided.'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the direct role of the user
    _getDirectRole(principalId, resourceId, function(err, directRole) {
        if (err) {
            return callback(err);
        }

        // Get the indirect roles of the user.
        _getIndirectRoles(principalId, resourceId, function(err, roles) {
            if (err) {
                return callback(err);
            }

            // Add the direct role (if any.)
            if (directRole) {
                roles.push(directRole);
            }
            callback(null, roles);
        });
    });
};

/**
 * Given a principal and a resource, determine all the roles that the principal has on the resource, by virtue of
 * indirect group inheritance.
 *
 * @param   {String}       principalId     The principal id. This can be a user or a group
 * @param   {String}       resourceId      The resource id. This can be a group as well.
 * @param   {Function}     callback        Standard callback function
 * @param   {Object}       callback.err    An error that occurred, if any
 * @param   {String[]}     callback.roles  An array containing all the roles the principal has on the resource by virtue of indirect group inheritance.
 * @api private
 */
var _getIndirectRoles = function(principalId, resourceId, callback) {
    // Get the groups that are directly associated to the resource
    getResourceGroupMembers(resourceId, function(err, groups) {
        if (err) {
            return callback(err);
        }

        // Check whether any of these are part of the user's direct memberships
        var groupIds = _.keys(groups);
        if (groupIds.length === 0) {
            return callback(null, []);
        } else {
            // Make sure that the user's memberships have been exploded and cached
            checkGroupMembershipsForUser(principalId, groupIds, function(err, memberships) {
                if (err) {
                    return callback(err);
                }

                // Add the roles of the matching groups
                var allRoles = [];
                for (var m = 0; m < memberships.length; m++) {
                    if (!_.contains(allRoles, groups[memberships[m]])) {
                        allRoles.push(groups[memberships[m]]);
                    }
                }
                return callback(null, allRoles);
            });
        }
    });
};

/**
 * Get all of the groups that are directly associated to a resource.
 *
 * @param   {String}       resourceId      The resource id. This can be a group as well.
 * @param   {Function}     callback        Standard callback function
 * @param   {Object}       callback.err    An error that occurred, if any
 * @param   {Object}       callback.roles  A JSON object where the keys are the group ids of the groups directly associated to the resource and the value is the role of that group
 * @api private
 */
var getResourceGroupMembers = function(resourceId, callback) {
    // Get the groups that are directly associated to the resource
    var start = AuthzConstants.principalTypes.GROUP + ':';
    var end = start + '|';
    Cassandra.runQuery('SELECT ? .. ? FROM AuthzMembers USING CONSISTENCY QUORUM WHERE resourceId = ?', [start, end, resourceId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        // If no groups are associated to the content, we can just return
        var associatedGroups = Cassandra.rowToHash(rows[0]);
        callback(null, associatedGroups);
    });
};

/**
 * Determines whether or not a principal has the specified role directly or indirectly on a given resource.
 *
 * @param  {String}      principalId         The principal id. This can be a user or a group.
 * @param  {String}      resourceId          The resource id. This can be a group as well
 * @param  {String}      role                The role to check
 * @param  {Function}    callback            A function specifying whether or not the user has the role on the resource
 * @param  {Object}      callback.err        An error that occurred, if any
 * @param  {Boolean}     callback.hasRole    Whether or not the principal has the specified role on the resource
 */
var hasRole = module.exports.hasRole = function(principalId, resourceId, role, callback) {
    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'Invalid principal id provided.'}).isPrincipalId();
    validator.check(resourceId, {'code': 400, 'msg': 'Invalid resource id provided.'}).isResourceId();
    validator.check(role, {'code': 400, 'msg': 'Invalid role provided.'}).isValidRole();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _hasRole(principalId, resourceId, role, callback);
};

/**
 * Determines whether or not a principal has any role directly or indirectly on a given resource.
 *
 * @param  {String}      principalId         The principal id. This can be a user or a group.
 * @param  {String}      resourceId          The resource id. This can be a group as well
 * @param  {Function}    callback            A function specifying whether or not the user has the role on the resource
 * @param  {Object}      callback.err        An error that occurred, if any
 * @param  {Boolean}     callback.hasRole    Whether or not the principal has a role on the resource
 */
var hasAnyRole = module.exports.hasAnyRole = function(principalId, resourceId, callback) {
    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'Invalid principal id provided.'}).isPrincipalId();
    validator.check(resourceId, {'code': 400, 'msg': 'Invalid resource id provided.'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _hasRole(principalId, resourceId, null, callback);
};

/**
 * Determines whether or not a principal has the specified role directly or indirectly on a given resource.
 *
 * @param  {String}       principalId         The principal id. This can be a user or a group.
 * @param  {String}       resourceId          The resource id. This can be a group as well
 * @param  {String}       role                The role to check. If the role is null, we check for any role
 * @param  {Function}     callback            A function specifying whether or not the user has the role on the resource
 * @param  {Object}       callback.err        An error that occurred, if any
 * @param  {Boolean}      callback.hasRole    Whether or not the principal has the specified role on the resource
 * @api private
 */
var _hasRole = function(principalId, resourceId, role, callback) {
    // Check for a direct role first
    _getDirectRole(principalId, resourceId, function(err, directRole) {
        if (err) {
            return callback(err);
        } else if (directRole && (role === null || directRole === role)) {
            return callback(null, true);
        }
        
        // If no direct role assignment is found, we try to find a role through an indirect membership
        _getIndirectRoles(principalId, resourceId, function(err, roles) {
            if (err) {
                return callback(err);
            }
            
            // If a role is found and we are just looking for any role
            if (roles.length > 0 && role === null) {
                return callback(null, true);
            // If we are looking for a specific role and that specific role is present
            } else if (_.contains(roles, role)) {
                return callback(null, true);
            // If the specified role cannot be found
            } else {
                callback(null, false);
            }
        });
    });
};

/**
 * Assign one or multiple principals a role on a resource instance. If the user already has a role, it will simply be updated. When
 * false is passed in as a role, the role for that principal will be removed.
 *
 * @param  {String}          resourceId      The resource id.
 * @param  {Object}          changes         JSON object where the keys are principal ids and the values are role values
 * @param  {Function}        callback        Standard callback function
 * @param  {Object}          callback.err    Error object, containing the error message
 */
var updateRoles = module.exports.updateRoles = function(resourceId, changes, callback) {
    var validator = new Validator();
    validator.check(resourceId, {'code': 400, 'msg': 'Invalid resource id provided.'}).isResourceId();
    var roleChanges = _.keys(changes);
    validator.check(roleChanges.length, {'code': 400, 'msg': 'At least one role change needs to be applied'}).min(1);
    for (var i = 0; i < roleChanges.length; i++) {
        var principalId = roleChanges[i];
        validator.check(principalId, {'code': 400, 'msg': 'Invalid principal id specified: ' + principalId}).isPrincipalId();
        validator.check(changes[principalId], {'code': 400, 'msg': 'Invalid role provided.'}).isValidRoleChange();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _updateRoles(resourceId, changes, callback);
};

/**
 * Assign multiple principals a role on a resource instance. If the user already has a role, it will simply be updated. When
 * false is passed in as a role, the role for that principal will be removed.
 *
 * @param  {String}        resourceId      The resource id.
 * @param  {Object}        changes         JSON object where the keys are principal ids and the values are role values
 * @param  {Function}      callback        Standard callback function
 * @param  {Object}        callback.err    Error object, containing the error message
 * @api private
 */
var _updateRoles = function(resourceId, changes, callback) {
    var queries = [];
    var roleChanges = _.keys(changes);
    for (var i = 0; i < roleChanges.length; i++) {
        var principalId = roleChanges[i];
        if (changes[principalId]) {
            queries.push({
                'query': 'UPDATE AuthzRoles SET ? = ? WHERE principalId = ?',
                'parameters': [resourceId, changes[principalId], principalId]
            });
            queries.push({
                'query': 'UPDATE AuthzMembers SET ? = ? WHERE resourceId = ?',
                'parameters': [principalId, changes[principalId], resourceId]
            });
        } else if (changes[principalId] === false) {
            queries.push({
                'query': 'DELETE ? FROM AuthzRoles WHERE principalId = ?',
                'parameters': [resourceId, principalId]
            });
            queries.push({
                'query': 'DELETE ? FROM AuthzMembers WHERE resourceId = ?',
                'parameters': [principalId, resourceId]
            });
        } else {
            return callback({'code': 400, 'msg': 'An invalid role has been passed in (undefined)'});
        }
    }
    // Invalidate the AuthzMembershipsCache row for each user who's role has just changed and for all of the users that
    // are members of the groups for which the roles have just been changed. We only want to do this when a group
    // memberships are being updated. There's no need to do it when a content membership is updated
    if (AuthzUtil.isGroupId(resourceId)) {
        // Collect the userids that need invalidating
        var invalidatedUsers = [];
        // Collect the groups for which the members need to be invalidated
        var groupsToInvalidate = [];
        // Keep track of the groups that we've already invalidated as we walk through deep membership
        var invalidatedGroups = [resourceId];
        
        var changeKeys = _.keys(changes);
        for (var c = 0; c < changeKeys.length; c++) {
            // Just invalidate the user
            if (AuthzUtil.isUserId(changeKeys[c])) {
                invalidatedUsers.push(changeKeys[c]);
                queries.push({
                    'query': 'DELETE FROM AuthzMembershipsCache WHERE principalId = ?',
                    'parameters': [changeKeys[c]]
                });
            // Queue the group to invalidate all of its members
            } else if (AuthzUtil.isGroupId(changeKeys[c])) {
                groupsToInvalidate.push(changeKeys[c]);
            }
        }
        
        var invalidateGroupMembers = function() {
            if (groupsToInvalidate.length === 0) {
                Cassandra.runBatchQuery(queries, 'QUORUM', callback);
            } else {
                var groupId = groupsToInvalidate.shift();
                // Get all of the members of the group, so they can be invalidated
                getAuthzMembers(groupId, null, 10000, function(err, members) {
                    if (err) {
                        return callback(err);
                    }

                    for (var i = 0; i < members.length; i++) {
                        var memberId = members[i].id;
                        // The members can be invalidated
                        if (AuthzUtil.isUserId(memberId) && !_.contains(invalidatedUsers, memberId)) {
                            invalidatedUsers.push(memberId);
                            queries.push({
                                'query': 'DELETE FROM AuthzMembershipsCache WHERE principalId = ?',
                                'parameters': [memberId]
                            });
                        // Group members need to be further exploded. In order to do this, we need to check whether or not the list 
                        // of groups that have already been invalidated and the list of groups that are queued up to be invalidated 
                        // don't contain this group, otherwise we'll invalidate the group twice.
                        } else if (AuthzUtil.isGroupId(memberId) && !_.contains(invalidatedGroups, memberId) && !_.contains(groupsToInvalidate, memberId)) {
                            groupsToInvalidate.push(memberId);
                            invalidatedGroups.push(memberId);
                        }
                    }
                    invalidateGroupMembers();
                });
            }
        };

        // Get all of the members of the current group
        invalidateGroupMembers();
   
    } else {
        Cassandra.runBatchQuery(queries, 'QUORUM', callback);
    }
};


///////////////////
// AUTHZ MEMBERS //
///////////////////

/**
 * Get all the direct members of a resource and their role on the resource.
 *
 * @param  {String}      resourceId              A unique identifier for a resource. ex: g:cam-oae-team or c:cam:XCDSasD
 * @param  {String}      start                   The principal id that comes just before the first principal you wish to have in your results.
 * @param  {Number}      limit                   The number of members you wish to retrieve.
 * @param  {Function}    callback                Standard callback function
 * @param  {Object}      callback.err            An error that occurred, if any
 * @param  {Object[]}    callback.members        Array of objects for each of the direct member of the resource. Each object has an 'id' key containing the principal id of the member and a 'role' key containing the role of that principal
 */
var getAuthzMembers = module.exports.getAuthzMembers = function(resourceId, start, limit, callback) {
    limit = limit || 10;

    var validator = new Validator();
    validator.check(resourceId, {'code': 400, 'msg': 'Invalid resource id provided'}).isResourceId();
    validator.check(limit, {'code': 400, 'msg': 'The limit parameter needs to be a number'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var members = [];
    Cassandra.runPagedColumnQuery('AuthzMembers', 'resourceId', resourceId, start, limit, null, function(err, row) {
        if (err) {
            return callback(err);
        }

        row.forEach(function(name, value) {
            members.push({'id': name, 'role': value});
        });

        return callback(null, members);
    });
};

/**
 * Given a list of groups, we check if a user is a direct or indirect member of any of these. This is done by first checking whether or
 * not the user's membership list has been exploded. If so, we do a direct match against that exploded list. If the user's memberships
 * have not yet been exploded, we explode the user's memberships, do a direct match against the retrieved list and then cache the exploded
 * list
 * 
 * @param  {String}      userId                 Id of the user for which we're checking whether or not he is a member of a set of groups
 * @param  {String[]}    groupIds               Array of group ids for which we're checking if the user is a member
 * @param  {Function}    callback               Standard callback function
 * @param  {Object}      callback.err           An error that occurred, if any
 * @param  {String[]}    callback.memberships   Array of group ids containing all the groups from the provided list that the user is a member of
 * @api private
 */
var checkGroupMembershipsForUser = function(userId, groupIds, callback) {
    // Check if the exploded list is there
    Cassandra.runQuery('SELECT FIRST 2 * FROM AuthzMembershipsCache USING CONSISTENCY QUORUM WHERE principalId = ?', [userId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        // There are columns in the exploded row
        if (rows[0].count > 1) {
            Cassandra.runQuery('SELECT ? FROM AuthzMembershipsCache USING CONSISTENCY QUORUM WHERE principalId = ?', [groupIds, userId], function(err, rows) {
                if (err) {
                    return callback(err);
                }
    
                // Return the matching groups
                var memberships = Cassandra.rowToHash(rows[0]);
                return callback(null, _.keys(memberships));
            });
        // There are no columns, we need to explode the user's group memberships
        } else {
             explodeGroupMemberships(userId, function(err, allMemberships) {
                 if (err) {
                    return callback(err);
                }
                
                // Return the matching groups
                var memberships = _.intersection(groupIds, allMemberships);
                return callback(null, memberships);
            });
        }
    });
};

/**
 * Get all the Authz groups of which a principal is a member. This includes all group ancestors to which the user is indirectly a member.
 * Once these have been retrieved, they will be cached inside of Cassandra for fast permission checks
 * 
 * @param  {String}      principalId                 Principal id for who we want to explode the group memberships
 * @param  {Function}    callback                    Standard callback function
 * @param  {Object}      callback.err                An error that occurred, if any
 * @param  {String[]}    callback.memberships        Array of group ids that represents the full list of direct and indirect memberships for the provided principal
 * @api private
 */
var explodeGroupMemberships = function(principalId, callback) {
    // Get the full exploded membership list for the user
    _getAuthzGroupMembershipAncestry(principalId, function(err, memberships) {
        if (err) {
            return callback(err);
        }
        // Publish the memberships into Cassandra
        if (_.keys(memberships).length > 0) {
            var publishMemberships = Cassandra.constructUpsertCQL('AuthzMembershipsCache', 'principalId', principalId, memberships, 'QUORUM');
            Cassandra.runQuery(publishMemberships.query, publishMemberships.parameters, function(err) {
                if (err) {
                    return callback(err);
                }
                callback(null, _.keys(memberships));
            });
        } else {
            callback(null, []);
        }
    });
};

/**
 * Gets all the Authz groups of which a principal (either user or group) is a member. This includes all group ancestors to
 * which the user is indirectly a member.
 *
 * @param  {String}         principalId         The principal id for which to retrieve all the group memberships
 * @param  {String}         start               Determines the point at which group memberships members are returned for paging purposes.  If not provided, the first x elements will be returned
 * @param  {Integer}        limit               Number of group memberships to return. Will default to 10 if not provided
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occured, if any
 * @param  {String[]}       callback.groups     An array of group ids representing the groups to which the user belongs, either directly or indirectly
 */
var getPrincipalMemberships = module.exports.getPrincipalMemberships = function(principalId, start, limit, callback) {
    limit = limit || 10;

    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'Invalid principal id provided'}).isPrincipalId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    Cassandra.runPagedColumnQuery('AuthzMembershipsCache', 'principalId', principalId, start, limit, null, function(err, row, startMatched) {
        if (err) {
            return callback(err);
        }

        var memberships = [];
        if (row.count > 0 || startMatched) {
            // If we retrieved columns or the start matched a column exactly, then we know we had a cache
            row.forEach(function(name) {
                memberships.push(name);
            });

            return callback(null, memberships);
        } else {
            explodeGroupMemberships(principalId, function(err, allMemberships) {
                if (err) {
                    return callback(err);
                }

                var startIndex = 0;
                if (start) {
                    // We don't want to include the start element, so pick the next element as the start
                    startIndex = _.indexOf(allMemberships, start) + 1;
                }
                var memberships = allMemberships.slice(startIndex, startIndex + limit);
                return callback(null, memberships);
            });
        }
    });
};

/**
 * Given some principal, get their entire group membership ancestry. In other words, get all the groups to which they belong,
 * and the groups to all those groups belong, and so on.
 *
 * @param   {String}        principalId         The principal id for which to retrieve the authz group membership ancestry
 * @param   {Function}      callback            Standard callback function
 * @param   {Object}        callback.err        The err that occured, if any
 * @param   {Object}        callback.ancestry   A hash keyed by the group id of each group of which the user is indirectly a member. The value of each entry is `true`.
 * @api private
 */
var _getAuthzGroupMembershipAncestry = function(principalId, callback) {
    var results = {};

    var _multiGetAuthzGroupMembershipAncestry = function(principalIds, results) {
        getRolesForPrincipalsAndResourceType(principalIds, AuthzConstants.resourceTypes.GROUP, 10000, function(err, entries) {
            if (err) {
                return callback(err);
            }

            var nextPrincipalBatch = [];
            var ancestors = _.keys(entries);
            // for each group parent, determine if we've already recorded their membership. if not, we record it, and search it's parents
            for (var i = 0; i < ancestors.length; i++) {
                var ancestorId = ancestors[i];
                if (!results[ancestorId]) {
                    results[ancestorId] = true;
                    nextPrincipalBatch.push(ancestorId);
                }
            }

            // if we found new ancestors, we need to recurse to find their ancestors. Otherwise we're done.
            if (nextPrincipalBatch.length > 0) {
                return _multiGetAuthzGroupMembershipAncestry(nextPrincipalBatch, results);
            } else {
                return callback(null, results);
            }
        });
    };

    _multiGetAuthzGroupMembershipAncestry([principalId], results, callback);
};

/**
 * Get all principal roles associated to the resourceType for all the principals in the array of principal ids. This can be performed on
 * multiple principals at once.
 *
 * The structure of the resulting entries is structured a hash, indicating all resource ids that were returned and what the
 * roles associated to those resources were. For example:
 *
 *     {
 *      'u:cam:simong': { 'member': true },
 *      'g:cam:group-b': { 'member': true }
 *     }
 *
 * or:
 *
 *     {
 *      'c:gat:Foo.docx': { 'viewer': true, 'manager': true},
 *      'c:cam:Bar.pdf':  { 'viewer': true }
 *     }
 *
 * In the latter case, 'c:gat:Foo.docx' has both 'viewer' and 'manager' role associated to it. This indicates that some principal
 * had a role of 'viewer' on the resource, while some other principal had the 'manager' role.
 *
 * @param  {Array}          principalIds        The array of principal ids to query for
 * @param  {String}         resourceType        The resource type of the resources to search for, as determined by Resource.resourceType
 * @param  {Number}         limit               The maximum number of resources to return per user
 * @param  {Function}       callback            A function providing all the {resource id} -> {roles} mappings aggregated for all the provided principals queried
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Object}         callback.entries    A JSON Object representing the roles associated to the users
 */
var getRolesForPrincipalsAndResourceType = module.exports.getRolesForPrincipalsAndResourceType = function(principalIds, resourceType, limit, callback) {
    limit = limit || 1000;
    principalIds = principalIds || [];

    var validator = new Validator();
    validator.check(limit, {'code': 400, 'msg': '"limit" parameter must be a number when searching for active roles'});
    validator.check(resourceType, {'code': 400, 'msg': 'A resourceType needs to be provided'}).notEmpty();
    validator.check(principalIds.length, {'code': 400, 'msg': 'At least one principal Id needs to be passed in'}).min(1);
    for (var i = 0; i < principalIds.length; i++) {
        var principalId = principalIds[i];
        validator.check(principalId, {'code': 400, 'msg': 'Invalid principal id specified: ' + principalId}).isPrincipalId();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // we append a '|' to the "end" range, as | has a high ASCII alphabetical ordering. This may not suffice if resourceIds have
    // multi-byte characters, which is technically possible. Unfortunately, I don't think there is a better way to do this with
    // CQL.
    var start = resourceType + ':';
    var end = start + '|';

    var cql = 'SELECT FIRST ' + limit + ' ? .. ? FROM AuthzRoles USING CONSISTENCY QUORUM WHERE principalId IN (?)';
    Cassandra.runQuery(cql, [start, end, principalIds], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var entries = {};

        // Aggregate all resources from all the rows (principals) into the entries hash
        var expandRow = function(name, value) {
            if (!entries[name]) {
                entries[name] = {};
            }
            entries[name][value] = true;
        };
        for (var i = 0; i < rows.length; i++) {
            rows[i].forEach(expandRow);
        }
        
        callback(null, entries);
    });
};
