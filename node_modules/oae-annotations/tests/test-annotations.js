/*
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');
var fs = require('fs');
var util = require('util');

var ActivityTestsUtil = require('oae-activity/lib/test/util');
var EmailTestsUtil = require('oae-email/lib/test/util');
var RestAPI = require('oae-rest');
var TestsUtil = require('oae-tests');

var AnnotationConstants = require('oae-annotations/lib/constants').AnnotationConstants;

describe('Annotations', function() {

    var anonymousCamRestContext = null;
    var anonymousGtRestContext = null;
    var camAdminRestContext = null;
    var gtAdminRestContext = null;

    before(function(callback) {
        anonymousCamRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host);
        anonymousGtRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.gt.host);
        camAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.cam.host);
        gtAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.gt.host);
        return callback();
    });

    /**
     * Get a readable stream to a file
     *
     * @return {Stream}     A stream to a file
     */
    var _getDataStream = function() {
        var file = __dirname + '/data/paper.txt';
        return fs.createReadStream(file);
    };

    /**
     * Set up the fixture by generating:
     *   -  4 users on the `camtest` tenant (simon, mrvisser, nico & bert)
     *   -  3 users on the `gttest` tenant (clay, stuart & stephen)
     *   -  1 public content item of type file where Simon, mrvisser and clay are managers and nico and stuart are viewers
     *
     * @param  {Function}   callback                Standard callback function
     * @param  {Content}    callback.content        The created file
     * @param  {User}       callback.simon          The user who created the file (cam tenant)
     * @param  {User}       callback.mrvisser       A manager on the content item (cam tenant)
     * @param  {User}       callback.nico           A viewer on the content item (cam tenant)
     * @param  {User}       callback.bert           An unrelated user (cam tenant)
     * @param  {User}       callback.clay           A manager on the content item (gt tenant)
     * @param  {User}       callback.stuart         A viewer on the content item (gt tenant)
     * @param  {User}       callback.stephen        An unrelated user (gt tenant)
     * @throws {Error}                              An assertion error is thrown when generating the users or content fails
     */
    var _setupFixture = function(callback) {
        TestsUtil.generateTestUsers(camAdminRestContext, 4, function(err, users, simon, mrvisser, nico, bert) {
            assert.ok(!err);

            // Generate some users on another tenant
            TestsUtil.generateTestUsers(gtAdminRestContext, 3, function(err, users, clay, stuart, stephen) {
                assert.ok(!err);

                RestAPI.Content.createFile(simon.restContext, 'Test file', null, 'public', _getDataStream, [mrvisser.user.id, clay.user.id], [nico.user.id, stuart.user.id], [], function(err, content) {
                    assert.ok(!err);

                    return callback(content, simon, mrvisser, nico, bert, clay, stuart, stephen);
                });
            });
        });
    };

    describe('Functionality', function() {

        /**
         * Test that verifies that annotations are bound to a revision
         */
        it('verify annotations are bound to a revision', function(callback) {
            _setupFixture(function(content, simon, mrvisser, nico, bert, clay, stuart, stephen) {
                var firstRevisionId = content.latestRevisionId;

                // Generate an annotation on the first revision
                var ranges = [{
                    'start': '/div[1]/div',
                    'end': '/div[1]/div',
                    'startOffset': 3,
                    'endOffset': 9
                }];
                RestAPI.Annotations.createAnnotation(simon.restContext, content.id, firstRevisionId, 1, 'first', 'quote', ranges, function(err, firstAnnotation) {
                    assert.ok(!err);

                    // Create a second revision
                    RestAPI.Content.updateFileBody(simon.restContext, content.id, _getDataStream, function(err, content) {
                        assert.ok(!err);
                        var secondRevisionId = content.latestRevisionId;

                        // Sanity check that the revision ids are different (otherwise all of the following is useless)
                        assert.notEqual(firstRevisionId, secondRevisionId);

                        // Generate an annotation on the second revision
                        RestAPI.Annotations.createAnnotation(simon.restContext, content.id, secondRevisionId, 1, 'second', 'quote', ranges, function(err, secondAnnotation) {
                            assert.ok(!err);

                            // When retrieving the annotations for the second revision, we should get the last annotation
                            RestAPI.Annotations.getAnnotations(simon.restContext, content.id, secondRevisionId, 1, function(err, annotations) {
                                assert.ok(!err);
                                assert.equal(annotations.length, 1);
                                assert.strictEqual(annotations[0].text, secondAnnotation.text);
                                assert.strictEqual(annotations[0].quote, secondAnnotation.quote);

                                // When retrieving the annotations for the second revision, we should get the first annotation
                                RestAPI.Annotations.getAnnotations(simon.restContext, content.id, firstRevisionId, 1, function(err, annotations) {
                                    assert.ok(!err);
                                    assert.equal(annotations.length, 1);
                                    assert.strictEqual(annotations[0].text, firstAnnotation.text);
                                    assert.strictEqual(annotations[0].quote, firstAnnotation.quote);

                                    return callback();
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    describe('Authorization', function() {

        /**
         * Test that verifies that only explicit content viewers and/or managers can create annotations
         */
        it('verify only explicit content viewers and/or managers can create annotations', function(callback) {
            _setupFixture(function(content, simon, mrvisser, nico, bert, clay, stuart, stephen) {

                var ranges = [{
                    'start': '/div[1]/div',
                    'end': '/div[1]/div',
                    'startOffset': 3,
                    'endOffset': 9
                }];

                // Anonymous users cannot create annotations
                RestAPI.Annotations.createAnnotation(anonymousCamRestContext, content.id, content.latestRevisionId, 1, 'text', 'quote', ranges, function(err) {
                    assert.equal(err.code, 401);

                    // Non-members cannot create annotations, even though the content item is public
                    RestAPI.Annotations.createAnnotation(bert.restContext, content.id, content.latestRevisionId, 1, 'text', 'quote', ranges, function(err) {
                        assert.equal(err.code, 401);

                        // Tenant admins from other tenants cannot update annotations
                        RestAPI.Annotations.createAnnotation(gtAdminRestContext, content.id, content.latestRevisionId, 1, 'text', 'quote', ranges, function(err) {
                            assert.equal(err.code, 401);

                            // Viewers, managers and admin should be able to annotate
                            RestAPI.Annotations.createAnnotation(nico.restContext, content.id, content.latestRevisionId, 1, 'text', 'quote', ranges, function(err, annotationA) {
                                assert.ok(!err);
                                RestAPI.Annotations.createAnnotation(mrvisser.restContext, content.id, content.latestRevisionId, 1, 'text', 'quote', ranges, function(err, annotationB) {
                                    assert.ok(!err);
                                    RestAPI.Annotations.createAnnotation(camAdminRestContext, content.id, content.latestRevisionId, 1, 'text', 'quote', ranges, function(err, annotationC) {
                                        assert.ok(!err);

                                        // Sanity check that all annotations were persisted
                                        RestAPI.Annotations.getAnnotations(simon.restContext, content.id, content.latestRevisionId, 1, function(err, annotations) {
                                            assert.ok(!err);
                                            assert.equal(annotations.length, 3);
                                            assert.ok(_.find(annotations, function(annotation) { return annotation.id === annotationA.id; }));
                                            assert.ok(_.find(annotations, function(annotation) { return annotation.id === annotationB.id; }));
                                            assert.ok(_.find(annotations, function(annotation) { return annotation.id === annotationC.id; }));
                                            return callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that only content managers and annotations creators can update annotations
         */
        it('verify only content managers and annotations creators can update annotations', function(callback) {
            _setupFixture(function(content, simon, mrvisser, nico, bert, clay, stuart, stephen) {
                var ranges = [{
                    'start': '/div[1]/div',
                    'end': '/div[1]/div',
                    'startOffset': 3,
                    'endOffset': 9
                }];

                // Nico annotates the document
                RestAPI.Annotations.createAnnotation(nico.restContext, content.id, content.latestRevisionId, 1, 'one', 'quote', ranges, function(err, annotation) {
                    assert.ok(!err);
                    assert.strictEqual(annotation.text, 'one');

                    // Anonymous users cannot update annotations
                    RestAPI.Annotations.updateAnnotation(anonymousCamRestContext, content.id, content.latestRevisionId, annotation.id, 'two', function(err) {
                        assert.equal(err.code, 401);

                        // Unaffiliated users cannot update annotations
                        RestAPI.Annotations.updateAnnotation(stephen.restContext, content.id, content.latestRevisionId, annotation.id, 'two', function(err) {
                            assert.equal(err.code, 401);

                            // Tenant admins from other tenants cannot update annotations
                            RestAPI.Annotations.updateAnnotation(gtAdminRestContext, content.id, content.latestRevisionId, annotation.id, 'two', function(err) {
                                assert.equal(err.code, 401);

                                // Nico should be able to update his own annotation
                                RestAPI.Annotations.updateAnnotation(nico.restContext, content.id, content.latestRevisionId, annotation.id, 'two', function(err, annotation) {
                                    assert.ok(!err);
                                    assert.strictEqual(annotation.text, 'two');
                                    // Sanity-check the update was persisted
                                    RestAPI.Annotations.getAnnotations(nico.restContext, content.id, content.latestRevisionId, 1, function(err, annotations) {
                                        assert.ok(!err);
                                        assert.equal(annotations.length, 1);
                                        assert.strictEqual(annotations[0].text, 'two');

                                        // Managers should be able to update annotations from other users
                                        RestAPI.Annotations.updateAnnotation(simon.restContext, content.id, content.latestRevisionId, annotation.id, 'three', function(err, annotation) {
                                            assert.ok(!err);
                                            assert.strictEqual(annotation.text, 'three');
                                            // Sanity-check the update was persisted
                                            RestAPI.Annotations.getAnnotations(simon.restContext, content.id, content.latestRevisionId, 1, function(err, annotations) {
                                                assert.ok(!err);
                                                assert.equal(annotations.length, 1);
                                                assert.strictEqual(annotations[0].text, 'three');

                                                // Admins should be able to update annotations
                                                RestAPI.Annotations.updateAnnotation(camAdminRestContext, content.id, content.latestRevisionId, annotation.id, 'four', function(err, annotation) {
                                                    assert.ok(!err);
                                                    assert.strictEqual(annotation.text, 'four');
                                                    // Sanity-check the update was persisted
                                                    RestAPI.Annotations.getAnnotations(camAdminRestContext, content.id, content.latestRevisionId, 1, function(err, annotations) {
                                                        assert.ok(!err);
                                                        assert.equal(annotations.length, 1);
                                                        assert.strictEqual(annotations[0].text, 'four');
                                                        return callback();
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that only content managers and annotations creators can delete annotations
         */
        it('verify only content managers and annotations creators can delete annotations', function(callback) {
            _setupFixture(function(content, simon, mrvisser, nico, bert, clay, stuart, stephen) {
                var ranges = [{
                    'start': '/div[1]/div',
                    'end': '/div[1]/div',
                    'startOffset': 3,
                    'endOffset': 9
                }];

                // Nico annotates the document
                RestAPI.Annotations.createAnnotation(nico.restContext, content.id, content.latestRevisionId, 1, 'text', 'quote', ranges, function(err, annotation) {
                    assert.ok(!err);

                    // Nico should be able to delete his own annotation
                    RestAPI.Annotations.deleteAnnotation(nico.restContext, content.id, content.latestRevisionId, annotation.id, function(err) {
                        assert.ok(!err);
                        // Sanity-check the delete was persisted
                        RestAPI.Annotations.getAnnotations(nico.restContext, content.id, content.latestRevisionId, 1, function(err, annotations) {
                            assert.ok(!err);
                            assert.equal(annotations.length, 0);

                            RestAPI.Annotations.createAnnotation(nico.restContext, content.id, content.latestRevisionId, 1, 'text', 'quote', ranges, function(err, annotation) {
                                assert.ok(!err);
                                
                                // Managers should be able to delete annotations from other users
                                RestAPI.Annotations.deleteAnnotation(simon.restContext, content.id, content.latestRevisionId, annotation.id, function(err) {
                                    assert.ok(!err);
                                    // Sanity-check the delete was persisted
                                    RestAPI.Annotations.getAnnotations(simon.restContext, content.id, content.latestRevisionId, 1, function(err, annotations) {
                                        assert.ok(!err);
                                        assert.equal(annotations.length, 0);

                                        RestAPI.Annotations.createAnnotation(nico.restContext, content.id, content.latestRevisionId, 1, 'text', 'quote', ranges, function(err, annotation) {
                                            assert.ok(!err);

                                            // Admins should be able to delete annotations
                                            RestAPI.Annotations.deleteAnnotation(camAdminRestContext, content.id, content.latestRevisionId, annotation.id, function(err) {
                                                assert.ok(!err);
                                                // Sanity-check the delete was persisted
                                                RestAPI.Annotations.getAnnotations(camAdminRestContext, content.id, content.latestRevisionId, 1, function(err, annotations) {
                                                    assert.ok(!err);
                                                    assert.equal(annotations.length, 0);
                                                    return callback();
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that annotations are linked to a revision. This test ensures
         * that it's not possible to update or delete an annotation via its ID and an unrelated
         * content and revision ID
         */
        it('verify annotations inherit the permissions from the content item', function(callback) {
            _setupFixture(function(firstContent, simon, mrvisser, nico, bert, clay, stuart, stephen) {
                var ranges = [{
                    'start': '/div[1]/div',
                    'end': '/div[1]/div',
                    'startOffset': 3,
                    'endOffset': 9
                }];

                // Simon annotates the document
                RestAPI.Annotations.createAnnotation(simon.restContext, firstContent.id, firstContent.latestRevisionId, 1, 'one', 'quote', ranges, function(err, annotation) {
                    assert.ok(!err);
                    assert.strictEqual(annotation.text, 'one');

                    // Bert (who is unrelated to the first content item), creates another content item
                    // and will try to manipulate the first content item by using the content and revision id
                    // of his document and the annotation id of the first
                    RestAPI.Content.createFile(bert.restContext, 'Test file', null, 'public', _getDataStream, [], [], [], function(err, secondContent) {
                        assert.ok(!err);

                        // Try to update Simon's annotation
                        RestAPI.Annotations.updateAnnotation(bert.restContext, secondContent.id, secondContent.latestRevisionId, annotation.id, 'all your annotations are belong to us', function(err, updatedAnnotation) {
                            assert.equal(err.code, 401);
                            assert.ok(!updatedAnnotation);
                            RestAPI.Annotations.updateAnnotation(bert.restContext, secondContent.id, firstContent.latestRevisionId, annotation.id, 'all your annotations are belong to us', function(err, updatedAnnotation) {
                                assert.equal(err.code, 401);
                                assert.ok(!updatedAnnotation);
                                RestAPI.Annotations.updateAnnotation(bert.restContext, firstContent.id, secondContent.latestRevisionId, annotation.id, 'all your annotations are belong to us', function(err, updatedAnnotation) {
                                    assert.equal(err.code, 401);
                                    assert.ok(!updatedAnnotation);

                                    // Sanity check that the malicious update was not persisted
                                    RestAPI.Annotations.getAnnotations(simon.restContext, firstContent.id, firstContent.latestRevisionId, 1, function(err, annotations) {
                                        assert.ok(!err);
                                        assert.equal(annotations.length, 1);
                                        assert.strictEqual(annotations[0].text, 'one');

                                        // Try to delete Simon's annotation
                                        RestAPI.Annotations.deleteAnnotation(bert.restContext, secondContent.id, secondContent.latestRevisionId, annotation.id, function(err) {
                                            assert.equal(err.code, 401);
                                            RestAPI.Annotations.deleteAnnotation(bert.restContext, secondContent.id, firstContent.latestRevisionId, annotation.id, function(err) {
                                                assert.equal(err.code, 401);
                                                RestAPI.Annotations.deleteAnnotation(bert.restContext, firstContent.id, secondContent.latestRevisionId, annotation.id, function(err) {
                                                    assert.equal(err.code, 401);

                                                    // Sanity check that the malicious delete was not persisted
                                                    RestAPI.Annotations.getAnnotations(simon.restContext, firstContent.id, firstContent.latestRevisionId, 1, function(err, annotations) {
                                                        assert.ok(!err);
                                                        assert.equal(annotations.length, 1);
                                                        assert.strictEqual(annotations[0].text, 'one');
                                                        return callback();
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Verify a set of expected read permissions
         *
         * @param  {Content}    content         The content item for which to try to retrieve the annotations
         * @param  {Object[]}   expectations    A set of expectations that need to be verified. Each object should have a `restContext` key holding the context for the request and a `hasAccess` key that indicates whether to expect a succesfull response
         * @param  {Function}   callback        Standard callback function
         * @throws {Error}                      An assertion error is thrown if the expectation is not met
         */
        var _verifyReadPermissions = function(content, expectations, callback) {
            if (expectations.length === 0) {
                return callback();
            }

            var expectation = expectations.pop();
            RestAPI.Annotations.getAnnotations(expectation.restContext, content.id, content.latestRevisionId, 1, function(err, annotations) {
                if (expectation.hasAccess) {
                    assert.ok(!err);
                    assert.equal(annotations.length, 1);
                } else {
                    assert.equal(err.code, 401);
                    assert.ok(!annotations);
                }

                // Verify the next permission
                _verifyReadPermissions(content, expectations, callback);
            });
        };

        /**
         * Test that verifies that annotations can only be retrieved if the user has access to the content item
         */
        it('verify annotations can only be retrieved if the user has access to the content item', function(callback) {
            _setupFixture(function(content, simon, mrvisser, nico, bert, clay, stuart, stephen) {

                var ranges = [{
                    'start': '/div[1]/div',
                    'end': '/div[1]/div',
                    'startOffset': 3,
                    'endOffset': 9
                }];

                // Simon annotates the document
                RestAPI.Annotations.createAnnotation(simon.restContext, content.id, content.latestRevisionId, 1, 'text', 'quote', ranges, function(err, annotation) {
                    assert.ok(!err);

                    // Since the content item is public, everybody should be able to see it
                    var expectations = [
                        // The anonymous user
                        {'restContext': anonymousCamRestContext, 'hasAccess': true},

                        // The anonymous user on another tenant
                        {'restContext': anonymousGtRestContext, 'hasAccess': true},

                        // A non-member
                        {'restContext': bert.restContext, 'hasAccess': true},

                        // A non-member from another tenant
                        {'restContext': stephen.restContext, 'hasAccess': true},

                        // A viewer
                        {'restContext': nico.restContext, 'hasAccess': true},

                        // A viewer from another tenant
                        {'restContext': stuart.restContext, 'hasAccess': true},

                        // A manager
                        {'restContext': mrvisser.restContext, 'hasAccess': true},

                        // A manager from another tenant
                        {'restContext': clay.restContext, 'hasAccess': true},

                        // A manager + annotation creator
                        {'restContext': simon.restContext, 'hasAccess': true},

                        // A tenant admin
                        {'restContext': camAdminRestContext, 'hasAccess': true},

                        // A tenant admin from another tenant
                        {'restContext': gtAdminRestContext, 'hasAccess': true},
                    ];
                    _verifyReadPermissions(content, expectations, function() {

                        // When we change the visibility setting of the content item to `loggedin`, the anonymous user and 
                        // users from other tenants who aren't explicit members shouldn't be able to retrieve annotations anymore
                        RestAPI.Content.updateContent(simon.restContext, content.id, {'visibility': 'loggedin'}, function(err) {
                            assert.ok(!err);

                            expectations = [
                                // The anonymous user
                                {'restContext': anonymousCamRestContext, 'hasAccess': false},

                                // The anonymous user on another tenant
                                {'restContext': anonymousGtRestContext, 'hasAccess': false},

                                // A non-member
                                {'restContext': bert.restContext, 'hasAccess': true},

                                // A non-member from another tenant
                                {'restContext': stephen.restContext, 'hasAccess': false},

                                // A viewer
                                {'restContext': nico.restContext, 'hasAccess': true},

                                // A viewer from another tenant
                                {'restContext': stuart.restContext, 'hasAccess': true},

                                // A manager
                                {'restContext': mrvisser.restContext, 'hasAccess': true},

                                // A manager from another tenant
                                {'restContext': clay.restContext, 'hasAccess': true},

                                // A manager + annotation creator
                                {'restContext': simon.restContext, 'hasAccess': true},

                                // A tenant admin
                                {'restContext': camAdminRestContext, 'hasAccess': true},

                                // A tenant admin from another tenant
                                {'restContext': gtAdminRestContext, 'hasAccess': false},
                            ];
                            _verifyReadPermissions(content, expectations, function() {
                                // When we change the visibility setting of the content item to `private`, the anonymous user,  
                                // users from other tenants who aren't explicit members and non-members shouldn't be able to 
                                // retrieve annotations anymore
                                RestAPI.Content.updateContent(simon.restContext, content.id, {'visibility': 'private'}, function(err) {
                                    assert.ok(!err);

                                    expectations = [
                                        // The anonymous user
                                        {'restContext': anonymousCamRestContext, 'hasAccess': false},

                                        // The anonymous user on another tenant
                                        {'restContext': anonymousGtRestContext, 'hasAccess': false},

                                        // A non-member
                                        {'restContext': bert.restContext, 'hasAccess': false},

                                        // A non-member from another tenant
                                        {'restContext': stephen.restContext, 'hasAccess': false},

                                        // A viewer
                                        {'restContext': nico.restContext, 'hasAccess': true},

                                        // A viewer from another tenant
                                        {'restContext': stuart.restContext, 'hasAccess': true},

                                        // A manager
                                        {'restContext': mrvisser.restContext, 'hasAccess': true},

                                        // A manager from another tenant
                                        {'restContext': clay.restContext, 'hasAccess': true},

                                        // A manager + annotation creator
                                        {'restContext': simon.restContext, 'hasAccess': true},

                                        // A tenant admin
                                        {'restContext': camAdminRestContext, 'hasAccess': true},

                                        // A tenant admin from another tenant
                                        {'restContext': gtAdminRestContext, 'hasAccess': false},
                                    ];
                                    _verifyReadPermissions(content, expectations, callback);
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    describe('Validation', function() {

        /**
         * Assert that a given value is an ISO 8601 formatted timestamp
         *
         * @param  {String}     value       The value to check
         * @param  {Number}     timestamp   The time in milliseconds since epoch from which the given value can deviate at most 2 seconds
         * @throws {Error}                  An assertion error is throw if the given value is no ISO 8601 formatted string or deviates too much from the given timestamp
         */
        var _assertISO8601 = function(value, timestamp) {
            // Assert the passed in value is a string
            assert.strictEqual(typeof value, 'string');

            // Check the value matches the iso 8601 format
            assert.ok(value.match(/(\d{4})-(\d{2})-(\d{2})T(\d{2})\:(\d{2})\:(\d{2})\.(\d{3})\Z/));

            // Convert the value to a date and check if the value is within roughly 2 seconds of the specified timestamp
            var date = new Date(value);
            assert.ok((timestamp - 2000) < date.getTime());
            assert.ok((timestamp + 2000) > date.getTime());
        };

        /**
         * Test that verifies that the parameters for creating annotations are validated
         */
        it('#createAnnotation', function(callback) {
            _setupFixture(function(content, simon) {
                var ranges = [{
                    'start': '/div[1]/div',
                    'end': '/div[1]/div',
                    'startOffset': 3,
                    'endOffset': 9
                }];

                // Invalid url parameters
                RestAPI.Annotations.createAnnotation(simon.restContext, 'invalid content id', content.latestRevisionId, 1, 'text', 'quote', ranges, function(err, annotation) {
                    assert.equal(err.code, 400);
                    RestAPI.Annotations.createAnnotation(simon.restContext, content.id, 'invalid revision id', 1, 'text', 'quote', ranges, function(err, annotation) {
                        assert.equal(err.code, 400);
                        RestAPI.Annotations.createAnnotation(simon.restContext, 'c:cam:missing', content.latestRevisionId, 1, 'text', 'quote', ranges, function(err, annotation) {
                            assert.equal(err.code, 404);
                            RestAPI.Annotations.createAnnotation(simon.restContext, content.id, 'rev:cam:missing id', 1, 'text', 'quote', ranges, function(err, annotation) {
                                assert.equal(err.code, 404);

                                // Invalid or missing parameters
                                RestAPI.Annotations.createAnnotation(simon.restContext, content.id, content.latestRevisionId, null, 'text', 'quote', ranges, function(err, annotation) {
                                    assert.equal(err.code, 400);
                                    RestAPI.Annotations.createAnnotation(simon.restContext, content.id, content.latestRevisionId, 'non numeric', 'text', 'quote', ranges, function(err, annotation) {
                                        assert.equal(err.code, 400);
                                        RestAPI.Annotations.createAnnotation(simon.restContext, content.id, content.latestRevisionId, 1, null, 'quote', ranges, function(err, annotation) {
                                            assert.equal(err.code, 400);
                                            RestAPI.Annotations.createAnnotation(simon.restContext, content.id, content.latestRevisionId, 1, 'text', null, ranges, function(err, annotation) {
                                                assert.equal(err.code, 400);
                                                RestAPI.Annotations.createAnnotation(simon.restContext, content.id, content.latestRevisionId, 1, 'text', 'quote', null, function(err, annotation) {
                                                    assert.equal(err.code, 400);
                                                    RestAPI.Annotations.createAnnotation(simon.restContext, content.id, content.latestRevisionId, 1, 'text', 'quote', [], function(err, annotation) {
                                                        assert.equal(err.code, 400);

                                                        // Check the `ranges` parameter. The awkward `invalidRanges` construction
                                                        // is due to underscore's extend function not deep-copying array values
                                                        var invalidRanges = [_.extend({}, ranges[0])];
                                                        delete invalidRanges[0].start;
                                                        RestAPI.Annotations.createAnnotation(simon.restContext, content.id, content.latestRevisionId, 1, 'text', 'quote', invalidRanges, function(err, annotation) {
                                                            assert.equal(err.code, 400);
                                                            invalidRanges = [_.extend({}, ranges[0])];
                                                            delete invalidRanges[0].end;
                                                            RestAPI.Annotations.createAnnotation(simon.restContext, content.id, content.latestRevisionId, 1, 'text', 'quote', invalidRanges, function(err, annotation) {
                                                                assert.equal(err.code, 400);
                                                                invalidRanges = [_.extend({}, ranges[0])];
                                                                delete invalidRanges[0].startOffset;
                                                                RestAPI.Annotations.createAnnotation(simon.restContext, content.id, content.latestRevisionId, 1, 'text', 'quote', invalidRanges, function(err, annotation) {
                                                                    assert.equal(err.code, 400);
                                                                    invalidRanges = [_.extend({}, ranges[0])];
                                                                    delete invalidRanges[0].endOffset;
                                                                    RestAPI.Annotations.createAnnotation(simon.restContext, content.id, content.latestRevisionId, 1, 'text', 'quote', invalidRanges, function(err, annotation) {
                                                                        assert.equal(err.code, 400);
                                                                        invalidRanges = [_.extend({}, ranges[0])];
                                                                        invalidRanges[0].startOffset = 'Non numeric';
                                                                        RestAPI.Annotations.createAnnotation(simon.restContext, content.id, content.latestRevisionId, 1, 'text', 'quote', invalidRanges, function(err, annotation) {
                                                                            assert.equal(err.code, 400);
                                                                            invalidRanges = [_.extend({}, ranges[0])];
                                                                            invalidRanges[0].endOffset = 'Non numeric';
                                                                            RestAPI.Annotations.createAnnotation(simon.restContext, content.id, content.latestRevisionId, 1, 'text', 'quote', invalidRanges, function(err, annotation) {
                                                                                assert.equal(err.code, 400);

                                                                                // Assert you cannot annotate links
                                                                                RestAPI.Content.createLink(simon.restContext, 'test', 'test', 'public', 'http://www.google.com', [], [], [], function(err, link) {
                                                                                    assert.ok(!err);
                                                                                    RestAPI.Annotations.createAnnotation(simon.restContext, link.id, link.latestRevisionId, 1, 'text', 'quote', ranges, function(err, annotation) {
                                                                                        assert.equal(err.code, 400);

                                                                                        // Try annotation a revision from another content item
                                                                                        RestAPI.Annotations.createAnnotation(simon.restContext, content.id, link.latestRevisionId, 1, 'text', 'quote', ranges, function(err, annotation) {
                                                                                            assert.equal(err.code, 401);

                                                                                            // Sanity-check
                                                                                            RestAPI.Annotations.createAnnotation(simon.restContext, content.id, content.latestRevisionId, 1, 'text', 'quote', ranges, function(err, annotation) {
                                                                                                assert.ok(!err);

                                                                                                // Assert the annotation is returned in the response and has a valid id
                                                                                                assert.ok(annotation);
                                                                                                assert.ok(annotation.id);
                                                                                                assert.strictEqual(annotation.text, 'text');
                                                                                                assert.strictEqual(annotation.quote, 'quote');

                                                                                                // Assert the `created` timestamp is an ISO 8601 string
                                                                                                _assertISO8601(annotation.created, Date.now());

                                                                                                // Assert the user profile is returned
                                                                                                assert.ok(annotation.user);
                                                                                                assert.strictEqual(annotation.user.id, simon.user.id);
                                                                                                return callback();
                                                                                            });
                                                                                        });
                                                                                    });
                                                                                });
                                                                            });
                                                                        });
                                                                    });
                                                                });
                                                            });
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that the parameters for creating annotations are validated
         */
        it('#updateAnnotation', function(callback) {
            _setupFixture(function(content, simon) {
                var ranges = [{
                    'start': '/div[1]/div',
                    'end': '/div[1]/div',
                    'startOffset': 3,
                    'endOffset': 9
                }];
                RestAPI.Annotations.createAnnotation(simon.restContext, content.id, content.latestRevisionId, 1, 'text', 'quote', ranges, function(err, annotation) {
                    assert.ok(!err);

                    // Invalid url parameters
                    RestAPI.Annotations.updateAnnotation(simon.restContext, 'invalid content id', content.latestRevisionId, annotation.id, 'new text', function(err) {
                        assert.equal(err.code, 400);
                        RestAPI.Annotations.updateAnnotation(simon.restContext, content.id, 'invalid revision id', annotation.id, 'new text', function(err) {
                            assert.equal(err.code, 400);
                            RestAPI.Annotations.updateAnnotation(simon.restContext, 'c:cam:missing', content.latestRevisionId, annotation.id, 'new text', function(err) {
                                assert.equal(err.code, 404);
                                RestAPI.Annotations.updateAnnotation(simon.restContext, content.id, 'rev:cam:missing id', annotation.id, 'new text', function(err) {
                                    assert.equal(err.code, 404);
                                    RestAPI.Annotations.updateAnnotation(simon.restContext, content.id, content.latestRevisionId, 'invalid annotation id', 'new text', function(err) {
                                        assert.equal(err.code, 404);

                                        // Missing text
                                        RestAPI.Annotations.updateAnnotation(simon.restContext, content.id, content.latestRevisionId, annotation.id, null, function(err) {
                                            assert.equal(err.code, 400);
                                            RestAPI.Annotations.updateAnnotation(simon.restContext, content.id, content.latestRevisionId, annotation.id, '', function(err) {
                                                assert.equal(err.code, 400);

                                                // Assert you cannot annotate links
                                                RestAPI.Content.createLink(simon.restContext, 'test', 'test', 'public', 'http://www.google.com', [], [], [], function(err, link) {
                                                    assert.ok(!err);
                                                    RestAPI.Annotations.updateAnnotation(simon.restContext, link.id, link.latestRevisionId, annotation.id, 'updated text', function(err) {
                                                        assert.equal(err.code, 400);

                                                        // Try annotation a revision from another content item
                                                        RestAPI.Annotations.updateAnnotation(simon.restContext, content.id, link.latestRevisionId, annotation.id, 'updated text', function(err) {
                                                            assert.equal(err.code, 401);

                                                            // Sanity-check
                                                            RestAPI.Annotations.updateAnnotation(simon.restContext, content.id, content.latestRevisionId, annotation.id, 'updated text', function(err, annotation) {
                                                                assert.ok(!err);

                                                                // Assert that we return the updated annotation
                                                                assert.ok(annotation);
                                                                assert.strictEqual(annotation.text, 'updated text');
                                                                assert.ok(annotation.updatedBy);
                                                                assert.strictEqual(annotation.updatedBy.id, simon.user.id);

                                                                // Assert the `updated` timestamp is an ISO 8601 string
                                                                _assertISO8601(annotation.updated, Date.now());

                                                                // Assert the update persisted
                                                                RestAPI.Annotations.getAnnotations(simon.restContext, content.id, content.latestRevisionId, 1, function(err, annotations) {
                                                                    assert.ok(!err);
                                                                    assert.equal(annotations.length, 1);
                                                                    assert.strictEqual(annotations[0].text, annotation.text);

                                                                    return callback();
                                                                });
                                                            });
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that the parameters for creating annotations are validated
         */
        it('#deleteAnnotation', function(callback) {
            _setupFixture(function(content, simon) {
                var ranges = [{
                    'start': '/div[1]/div',
                    'end': '/div[1]/div',
                    'startOffset': 3,
                    'endOffset': 9
                }];
                RestAPI.Annotations.createAnnotation(simon.restContext, content.id, content.latestRevisionId, 1, 'text', 'quote', ranges, function(err, annotation) {
                    assert.ok(!err);

                    // Invalid url parameters
                    RestAPI.Annotations.deleteAnnotation(simon.restContext, 'invalid content id', content.latestRevisionId, annotation.id, function(err) {
                        assert.equal(err.code, 400);
                        RestAPI.Annotations.deleteAnnotation(simon.restContext, content.id, 'invalid revision id', annotation.id, function(err) {
                            assert.equal(err.code, 400);
                            RestAPI.Annotations.deleteAnnotation(simon.restContext, 'c:cam:missing', content.latestRevisionId, annotation.id, function(err) {
                                assert.equal(err.code, 404);
                                RestAPI.Annotations.deleteAnnotation(simon.restContext, content.id, 'rev:cam:missing id', annotation.id, function(err) {
                                    assert.equal(err.code, 404);
                                    RestAPI.Annotations.deleteAnnotation(simon.restContext, content.id, content.latestRevisionId, 'invalid annotation id', function(err) {
                                        assert.equal(err.code, 404);

                                        // Sanity check
                                        RestAPI.Annotations.deleteAnnotation(simon.restContext, content.id, content.latestRevisionId, annotation.id, function(err) {
                                            assert.ok(!err);
                                            RestAPI.Annotations.getAnnotations(simon.restContext, content.id, content.latestRevisionId, 1, function(err, annotations) {
                                                assert.ok(!err);
                                                assert.equal(annotations.length, 0);

                                                return callback();
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });                 
        });

        /**
         * Test that verifies that the parameters for retrieving annotations are validated
         */
        it('#getAnnotations', function(callback) {
            _setupFixture(function(content, simon) {
                var ranges = [{
                    'start': '/div[1]/div[0]',
                    'end': '/div[1]/div[3]',
                    'startOffset': 3,
                    'endOffset': 9
                }];
                RestAPI.Annotations.createAnnotation(simon.restContext, content.id, content.latestRevisionId, 4, 'some text', 'selected text', ranges, function(err, annotation) {
                    assert.ok(!err);

                    // Invalid url parameters
                    RestAPI.Annotations.getAnnotations(simon.restContext, 'invalid content id', content.latestRevisionId, 4, function(err, annotations) {
                        assert.equal(err.code, 400);
                        RestAPI.Annotations.getAnnotations(simon.restContext, content.id, 'invalid revision id', 4, function(err, annotations) {
                            assert.equal(err.code, 400);

                            // The page number should be defaulted to something sensible
                            RestAPI.Annotations.getAnnotations(simon.restContext, content.id, content.latestRevisionId, 'not a numeric page', function(err, annotations) {
                                assert.ok(!err);
                                assert.equal(annotations.length, 0);

                                // Get the annotations for the page we've annotated
                                RestAPI.Annotations.getAnnotations(simon.restContext, content.id, content.latestRevisionId, 4, function(err, annotations) {
                                    assert.ok(!err);
                                    assert.equal(annotations.length, 1);

                                    // Assert we get all the expected data
                                    assert.strictEqual(annotations[0].id, annotation.id);

                                    // The createdBy property should hold a user object
                                    assert.ok(_.isObject(annotations[0].createdBy));
                                    assert.strictEqual(annotations[0].createdBy.id, simon.user.id);
                                    assert.strictEqual(annotations[0].createdBy.resourceType, 'user');

                                    // Annotator properties
                                    assert.strictEqual(annotations[0].text, 'some text');
                                    assert.strictEqual(annotations[0].quote, 'selected text');
                                    assert.strictEqual(annotations[0].pageNumber, 4);
                                    assert.ok(_.isArray(annotations[0].ranges));
                                    assert.strictEqual(annotations[0].ranges.length, 1);
                                    assert.deepEqual(annotations[0].ranges[0], ranges[0]);
                                    return callback();
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    describe('Activity', function() {

        /**
         * Assert that an annotion activity is present (or not) in a user's activity stream
         *
         * @param  {RestContext}    restContext     The rest context to use when fetching the activity stream
         * @param  {String}         userId          The ID of the user whose activity stream should be retrieved
         * @param  {Boolean}        expectInStream  Whether or not the activity should be in the stream
         * @param  {String}         actorId         The expected id of the actor entity
         * @param  {Content}        content         The content object on which the annotation was made (also used to verify the target entity)
         * @param  {Annotation}     annotation      The annotation that was made (used to verify the object entity)
         * @param  {String}         activityType    The expected activity type
         * @param  {String}         verb            The expected activity verb
         * @param  {Function}       callback        Standard callback function
         * @throws {Error}                          An assertion error is thrown if an expectation isn't met or when an error occurs
         */
        var _assertAnnotationActivity = function(restContext, userId, expectInStream, actorId, content, annotation, activityType, verb, callback) {
            ActivityTestsUtil.collectAndGetActivityStream(restContext, userId, null, function(err, activityStream) {
                assert.ok(!err);
                _assertActivityInStream(activityStream, expectInStream, actorId, content, annotation, activityType, verb, callback);
            });
        };

        /**
         * Assert that an annotion activity is present (or not) in a user's notification stream
         *
         * @param  {RestContext}    restContext     The rest context to use when fetching the notification stream
         * @param  {Boolean}        expectInStream  Whether or not the activity should be in the stream
         * @param  {String}         actorId         The expected id of the actor entity
         * @param  {Content}        content         The content object on which the annotation was made (also used to verify the target entity)
         * @param  {Annotation}     annotation      The annotation that was made (used to verify the object entity)
         * @param  {String}         activityType    The expected activity type
         * @param  {String}         verb            The expected activity verb
         * @param  {Function}       callback        Standard callback function
         * @throws {Error}                          An assertion error is thrown if an expectation isn't met or when an error occurs
         */
        var _assertAnnotationNotification = function(restContext, expectInStream, actorId, content, annotation, activityType, verb, callback) {
            ActivityTestsUtil.collectAndGetNotificationStream(restContext, null, function(err, notificationStream) {
                assert.ok(!err);
                _assertActivityInStream(notificationStream, expectInStream, actorId, content, annotation, activityType, verb, callback);
            });
        };

        /**
         * Assert that an annotion activity is present (or not) in an activity stream
         *
         * @param  {Activity[]}     activityStream  The activity stream in which to search for the activity
         * @param  {Boolean}        expectInStream  Whether or not the activity should be in the stream
         * @param  {String}         actorId         The expected id of the actor entity
         * @param  {Content}        content         The content object on which the annotation was made (also used to verify the target entity)
         * @param  {Annotation}     annotation      The annotation that was made (used to verify the object entity)
         * @param  {String}         activityType    The expected activity type
         * @param  {String}         verb            The expected activity verb
         * @param  {Function}       callback        Standard callback function
         * @throws {Error}                          An assertion error is thrown if an expectation isn't met or when an error occurs
         */
        var _assertActivityInStream = function(activityStream, expectInStream, actorId, content, annotation, activityType, verb, callback) {
            var activity = _.find(activityStream.items, function(activity) { return activity['oae:activityType'] === activityType; });
            if (!expectInStream) {
                assert.ok(!activity);
                return callback();
            }

            ActivityTestsUtil.assertActivity(activity, activityType, verb, actorId, annotation.id, content.id);
            var url = util.format('/api/content/%s/annotations/%s/%s', content.id, content.latestRevisionId, annotation.id);
            assert.ok(activity.object.id.indexOf(url) > 0);

            // Assert the author of the annotation is present
            assert.ok(activity.object.author);

            // Assert the full annotation object is present
            assert.ok(activity.object[AnnotationConstants.activity.PROP_OAE_ANNOTATION]);
            assert.strictEqual(activity.object[AnnotationConstants.activity.PROP_OAE_ANNOTATION].text, annotation.text);
            assert.strictEqual(activity.object[AnnotationConstants.activity.PROP_OAE_ANNOTATION].quote, annotation.quote);
            assert.strictEqual(activity.object[AnnotationConstants.activity.PROP_OAE_ANNOTATION].pageNumber, annotation.pageNumber);
            return callback();
        };

        /**
         * Test that verifies that annotation create activities are routed to the appropriate users
         */
        it('verify annotation create activities are routed to all members of the content item', function(callback) {
            _setupFixture(function(content, simon, mrvisser, nico, bert, clay, stuart, stephen) {

                // Stephen will follow Nico so we can check that followers get activities too
                RestAPI.Following.follow(stephen.restContext, nico.user.id, function(err) {
                    assert.ok(!err);

                    // Trigger an annotation activity
                    var ranges = [{
                        'start': '/div[1]/div',
                        'end': '/div[1]/div',
                        'startOffset': 3,
                        'endOffset': 9
                    }];
                    RestAPI.Annotations.createAnnotation(nico.restContext, content.id, content.latestRevisionId, 1, 'text', 'quote', ranges, function(err, annotation) {
                        assert.ok(!err);
                        var actorId = nico.user.id;

                        // Assert the creator has an activity
                        _assertAnnotationActivity(nico.restContext, nico.user.id, true, actorId, content, annotation, 'annotation-create', 'create', function() {
                            // Assert content managers get an activity
                            _assertAnnotationActivity(mrvisser.restContext, mrvisser.user.id, true, actorId, content, annotation, 'annotation-create', 'create', function() {
                                // Assert content viewers get an activity
                                _assertAnnotationActivity(stuart.restContext, stuart.user.id, true, actorId, content, annotation, 'annotation-create', 'create', function() {
                                    // Assert followers get an activity
                                    _assertAnnotationActivity(stephen.restContext, stephen.user.id, true, actorId, content, annotation, 'annotation-create', 'create', function() {
                                        // Assert unrelated users do not get an activity
                                        _assertAnnotationActivity(bert.restContext, bert.user.id, false, actorId, content, annotation, 'annotation-create', 'create', function() {

                                            // Assert that the content members and managers get a notification
                                            _assertAnnotationNotification(simon.restContext, true, actorId, content, annotation, 'annotation-create', 'create', function() {
                                                _assertAnnotationNotification(mrvisser.restContext, true, actorId, content, annotation, 'annotation-create', 'create', function() {
                                                    _assertAnnotationNotification(stuart.restContext, true, actorId, content, annotation, 'annotation-create', 'create', function() {
                                                        // Assert followers do not get a notification
                                                        _assertAnnotationNotification(stephen.restContext, false, actorId, content, annotation, 'annotation-create', 'create', function() {
                                                            // Assert unrelated users do not get a notification
                                                            _assertAnnotationNotification(bert.restContext, false, actorId, content, annotation, 'annotation-create', 'create', callback);
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that annotation update activities are routed to the appropriate users
         */
        it('verify annotation update activities are routed to all members of the content item', function(callback) {
            _setupFixture(function(content, simon, mrvisser, nico, bert, clay, stuart, stephen) {

                // Stephen will follow Simon so we can check that followers get activities too
                RestAPI.Following.follow(stephen.restContext, simon.user.id, function(err) {
                    assert.ok(!err);

                    // Trigger an annotation activity
                    var ranges = [{
                        'start': '/div[1]/div',
                        'end': '/div[1]/div',
                        'startOffset': 3,
                        'endOffset': 9
                    }];
                    RestAPI.Annotations.createAnnotation(nico.restContext, content.id, content.latestRevisionId, 1, 'text', 'quote', ranges, function(err, annotation) {
                        assert.ok(!err);
                        RestAPI.Annotations.updateAnnotation(simon.restContext, content.id, content.latestRevisionId, annotation.id, 'updated text', function(err, updatedAnnotation) {
                            assert.ok(!err);
                            var actorId = simon.user.id;

                            // Assert the updator has an activity
                            _assertAnnotationActivity(simon.restContext, simon.user.id, true, actorId, content, updatedAnnotation, 'annotation-update', 'update', function() {
                                // Assert the creator has an activity
                                _assertAnnotationActivity(nico.restContext, nico.user.id, true, actorId, content, updatedAnnotation, 'annotation-update', 'update', function() {
                                    // Assert content managers get an activity
                                    _assertAnnotationActivity(mrvisser.restContext, mrvisser.user.id, true, actorId, content, updatedAnnotation, 'annotation-update', 'update', function() {
                                        // Assert content viewers get an activity
                                        _assertAnnotationActivity(stuart.restContext, stuart.user.id, true, actorId, content, updatedAnnotation, 'annotation-update', 'update', function() {
                                            // Assert followers get an activity
                                            _assertAnnotationActivity(stephen.restContext, stephen.user.id, true, actorId, content, updatedAnnotation, 'annotation-update', 'update', function() {
                                                // Assert unrelated users do not get an activity
                                                _assertAnnotationActivity(bert.restContext, bert.user.id, false, actorId, content, updatedAnnotation, 'annotation-update', 'update', function() {

                                                    // Updates don't trigger a notification
                                                    _assertAnnotationNotification(mrvisser.restContext, false, actorId, content, updatedAnnotation, 'annotation-update', 'update', function() {
                                                        _assertAnnotationNotification(stuart.restContext, false, actorId, content, updatedAnnotation, 'annotation-update', 'update', function() {
                                                            _assertAnnotationNotification(stephen.restContext, false, actorId, content, updatedAnnotation, 'annotation-update', 'update', function() {
                                                                _assertAnnotationNotification(bert.restContext, false, actorId, content, updatedAnnotation, 'annotation-update', 'update', callback);
                                                            });
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    describe('Emails', function() {

        /**
         * Drain the email queue
         */
        beforeEach(function(callback) {
            EmailTestsUtil.clearEmailCollections(callback);
        });

        /**
         * Test that verifies annotation create activities result in an email
         */
        it('verify annotation create activities trigger an email', function(callback) {
            _setupFixture(function(content, simon, mrvisser, nico, bert, clay, stuart, stephen) {
                // Trigger an annotation activity
                var ranges = [{
                    'start': '/div[1]/div',
                    'end': '/div[1]/div',
                    'startOffset': 3,
                    'endOffset': 9
                }];
                var quote = 'This is the text that I selected';
                var text = 'This is the text that I wanted to add';
                RestAPI.Annotations.createAnnotation(nico.restContext, content.id, content.latestRevisionId, 1, text, quote, ranges, function(err, annotation) {
                    assert.ok(!err);

                    EmailTestsUtil.collectAndFetchAllEmails(function(messages) {
                        // There should be 5 emails (3 managers, 2 viewers)
                        assert.equal(messages.length, 5);

                        // Ensure the activity ID is in the HTML
                        var message = _.find(messages, function(message) { return message.to[0].address === simon.user.email; });
                        assert.ok(message);
                        assert.ok(message.html);
                        assert.ok(message.html.indexOf(annotation.id) > 0);
                        assert.ok(message.html.indexOf(text) > 0);
                        assert.ok(message.html.indexOf(quote) > 0);
                        return callback();
                    });
                });
            });
        });
    });
});
