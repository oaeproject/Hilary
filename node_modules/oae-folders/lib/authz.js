/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var util = require('util');

var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzAPI = require('oae-authz');
var AuthzUtil = require('oae-authz/lib/util');
var ContentAPI = require('oae-content');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var TenantsUtil = require('oae-tenants/lib/util');

var FoldersConstants = require('./constants').FoldersConstants;
var FoldersDAO = require('./internal/dao');

/**
 * Determine if the current user invoking the current request is allowed to view a given folder
 *
 * @param  {Context}        ctx                 Standard context object containing the current user and the current tenant
 * @param  {Folder}         folder              The folder for which to check if the current user can view it
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Boolean}        callback.canView    `true` if the current user in context can view the folder, `false` otherwise
 */
var canViewFolderProfile = module.exports.canViewFolderProfile = function(ctx, folder, callback) {
    var user = ctx.user();
    AuthzAPI.resolveImplicitRole(ctx, folder.groupId, folder.tenant.alias, folder.visibility, FoldersConstants.roles.ALL_PRIORITY, function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (implicitRole) {
            // We have an implicit access, no reason to try and find an explicit access because we can at least view the item
            return callback(null, true);
        } else if (!user) {
            // Anonymous user with no implicit access cannot view
            return callback(null, false);
        }

        // By this point, we only have access to view if we have a role on the item
        return AuthzAPI.hasAnyRole(user.id, folder.groupId, callback);
    });
};

/**
 * Determine if the user invoking the current request is allowed to manage a given folder
 *
 * @param  {Context}        ctx                 Standard context object containing the current user and the current tenant
 * @param  {Folder}         folder              The folder for which to check if the current user can manage it
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Boolean}        callback.canManage  `true` if the current user in context can manage the folder, `false` otherwise
 */
var canManageFolder = module.exports.canManageFolder = function(ctx, folder, callback) {
    var user = ctx.user();

    // Anonymous can never manage
    if (!user) {
        return callback(null, false);
    }

    AuthzAPI.resolveImplicitRole(ctx, folder.groupId, folder.tenant.alias, folder.visibility, FoldersConstants.roles.ALL_PRIORITY, function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (implicitRole === FoldersConstants.roles.MANAGER) {
            // We have an implicit management role (e.g., we are an administrator), return true
            return callback(null, true);
        }

        // By this point, we can only manage if we have explicit manager role
        return AuthzAPI.hasRole(user.id, folder.groupId, FoldersConstants.roles.MANAGER, callback);
    });
};

/**
 * Determine if the user invoking the current request is allowed to share a given folder, and if
 * it is possible for the target principals to become members of the folder
 *
 * @param  {Context}        ctx                             Standard context object containing the current user and the current tenant
 * @param  {Folder}         folder                          The folder for which to check if the current user can share it
 * @param  {String[]}       principalIds                    The ids of the principals with which the user is trying to share
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Boolean}        callback.canShare               `true` if the current user in context can share the folder, `false` otherwise
 * @param  {String[]}       callback.illegalPrincipalIds    If permission check failed because of target principal ids, this array will hold the principal ids that violated access boundaries
 */
var canShareFolder = module.exports.canShareFolder = function(ctx, folder, principalIds, callback) {
    var user = ctx.user();

    // Anonymous users can never share
    if (!user) {
        return callback(null, false);
    }

    // Get the principal objects for the principals we wish to share with
    PrincipalsDAO.getPrincipals(principalIds, null, function(err, principals) {
        if (err) {
            return callback(err);
        } else if (_.keys(principals).length !== principalIds.length) {
            return callback({'code': 400, 'msg': 'One or more target members being granted access do not exist'});
        }

        principals = _.values(principals);

        // Verify that the current user can interact with the content and the specified principals
        AuthzAPI.canInteract(ctx, folder.tenant.alias, principals, function(err, canInteract, illegalPrincipalIds) {
            if (err) {
                return callback(err);
            } else if (!canInteract) {
                return callback(null, false, illegalPrincipalIds);
            }

            AuthzAPI.resolveImplicitRole(ctx, folder.groupId, folder.tenant.alias, folder.visibility, FoldersConstants.roles.ALL_PRIORITY, function(err, implicitRole, canInteract) {
                if (err) {
                    return callback(err);
                } else if (implicitRole === FoldersConstants.roles.MANAGER) {
                    // Managers can always share
                    return callback(null, true);
                } else if (canInteract) {
                    // If we can interact with the item, we can always share it
                    return callback(null, true);
                }

                // If the folder is private, only managers can share it
                if (folder.visibility === AuthzConstants.visibility.PRIVATE) {
                    AuthzAPI.hasRole(user.id, folder.groupId, FoldersConstants.roles.MANAGER, function(err, hasRole) {
                        return callback(err, hasRole);
                    });
                    return;
                }

                // At this point, we have to see if the user has any explicit role on the resource to see if they can share it
                AuthzAPI.hasAnyRole(user.id, folder.groupId, function(err, hasAnyRole) {
                    return callback(err, hasAnyRole);
                });
            });
        });
    });
};

/**
 * Determine if the user invoking the current request is allowed to set the permissions of a given
 * folder, and if it is possible for the target principals to become members of the folder
 *
 * @param  {Context}        ctx                             Standard context object containing the current user and the current tenant
 * @param  {Folder}         folder                          The folder for which to check if the current user can change the permissions
 * @param  {String[]}       addMemberIds                    The ids of the principals that are being added to the folder
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Boolean}        callback.canSet                 `true` if the current user in context can set the folder permissions, `false` otherwise
 * @param  {String[]}       callback.illegalPrincipalIds    If permission check failed because of target principal ids, this array will hold the principal ids that violated access boundaries
 */
var canSetFolderPermissions = module.exports.canSetFolderPermissions = function(ctx, folder, addMemberIds, callback) {
    // Anonymous can never update the permissions of a folder
    if (!ctx.user()) {
        return callback(null, false);
    }

    // Get the principal objects for the principals we wish to change the permissions
    // We need to grab them from the DAO as we might need the full object in the authz API
    PrincipalsDAO.getPrincipals(addMemberIds, null, function(err, principals) {
        if (err) {
            return callback(err);
        } else if (_.keys(principals).length !== addMemberIds.length) {
            return callback({'code': 400, 'msg': 'One or more target members being granted access do not exist'});
        }

        principals = _.values(principals);

        // Verify that the current user can interact with the content and the specified principals
        AuthzAPI.canInteract(ctx, folder.tenant.alias, principals, function(err, canInteract, illegalPrincipalIds) {
            if (err) {
                return callback(err);
            } else if (!canInteract) {
                return callback(null, false, illegalPrincipalIds);
            }

            // Boundaries are all good, perform the manager check
            return canManageFolder(ctx, folder, callback);
        });
    });
};

/**
 * Determine if the user invoking the current request is allowed to add content items to a given
 * folder, and if it is possible for the target content items to be added to the folder
 *
 * @param  {Context}    ctx                                 Standard context object containing the current user and the current tenant
 * @param  {Folder}     folder                              The folder for which to check if the current user can add items to it
 * @param  {String[]}   contentItems                        The content items being added to the folder
 * @param  {Function}   callback                            Standard callback function
 * @param  {Object}     callback.err                        An error that occurred, if any
 * @param  {Boolean}    callback.canAddItems                `true` if the current user in context can set the folder permissions, `false` otherwise
 * @param  {String[]}   callback.illegalContentItemIds      If permission check failed because of target content items, this array will hold the content item ids that violated access boundaries
 */
var canAddItemsToFolder = module.exports.canAddItemsToFolder = function(ctx, folder, contentItems, callback) {
    // Anonymous users can never add something to a folder
    if (!ctx.user()) {
        return callback({'code': 401, 'msg': 'You must be authenticated to add items to a folder'});
    }

    var privateAndOtherResources = _separatePrivateResources(contentItems);
    var privateResources = privateAndOtherResources.privateResources;
    var otherResources = privateAndOtherResources.otherResources;

    // First ensure that the current user has manager access to all the private items, if any
    ContentAPI.canManageAll(ctx, privateResources, function(err, canManageAll, illegalContentItems) {
        if (err) {
            return callback(err);
        } else if (!canManageAll) {
            return callback(null, false, _.pluck(illegalContentItems, 'id'));
        }

        // Ensure that the user is not making a tenant boundary violation with private items by
        // associating a folder to a content item who are from tenants that are not in the same
        // tenant network
        illegalContentItems = _.filter(privateResources, function(privateResource) {
            return !TenantsUtil.canInteract(folder.tenant.alias, privateResource.tenant.alias);
        });

        if (!_.isEmpty(illegalContentItems)) {
            return callback(null, false, _.pluck(illegalContentItems, 'id'));
        }

        // Ensure that the user is not making tenant or privacy boundary violations with the
        // non-private content items. These are done differently than the private items simply
        // because for the private items the user must be a manager, and standard interaction checks
        // will not cover that
        AuthzAPI.canInteract(ctx, folder.tenant.alias, otherResources, function(err, canInteract, illegalContentIds) {
            if (err) {
                return callback(err);
            } else if (!canInteract) {
                return callback(null, false, illegalContentIds);
            }

            // Finally, ensure we can manage the folder to which we are adding the content items
            return canManageFolder(ctx, folder, callback);
        });
    });
};

/**
 * Determine if the user invoking the current request is allowed to remove content items from a given folder
 *
 * @param  {Context}    ctx                         Standard context object containing the current user and the current tenant
 * @param  {Folder}     folder                      The folder for which to check if the current user can remove items from it
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error that occurred, if any
 * @param  {Boolean}    callback.canRemoveItems     `true` if the current user in context can set the folder permissions, `false` otherwise
 */
var canRemoveItemsFromFolder = module.exports.canRemoveItemsFromFolder = function(ctx, folder, callback) {
    // Anonymous users can never remove something from a folder
    if (!ctx.user()) {
        return callback({'code': 401, 'msg': 'You must be authenticated to remove items from a folder'});
    }

    return canManageFolder(ctx, folder, callback);
};

/**
 * Resolve the overall access the current user in context has on the given folder
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {Folder}         folder                  The folder for which to resolve the effective user access
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Boolean}        callback.canView        Whether or not the current user can view the given folder
 * @param  {Boolean}        callback.canManage      Whether or not the current user can manage the given folder
 * @param  {Boolean}        callback.canAddItem     Whether or not the current user can add a content item to the given folder
 */
var resolveEffectiveFolderAccess = module.exports.resolveEffectiveFolderAccess = function(ctx, folder, callback) {
    var user = ctx.user();
    AuthzAPI.resolveEffectiveRole(ctx, folder.groupId, folder.tenant.alias, folder.visibility, FoldersConstants.roles.ALL_PRIORITY, function(err, effectiveRole, canInteract) {
        if (err) {
            return callback(err);
        }

        var canView = _.isString(effectiveRole);
        var canManage = (effectiveRole === FoldersConstants.roles.MANAGER);
        var canAddItem = canManage;

        // Anyone who can interact can share, unless the folder is private. In that case, only managers can share
        var canShare = canInteract;
        if (folder.visibility !== AuthzConstants.visibility.PUBLIC && folder.visibility !== AuthzConstants.visibility.LOGGEDIN) {
            canShare = canManage;
        }

        return callback(null, canView, canManage, canShare, canAddItem);
    });
};

/**
 * Given a content item, get the folders that it resides in.
 *
 * @param  {String}     contentId           The content id for which to retrieve the folders it resides in
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Folder[]}   callback.folders    The folders that contain the content item
 */
var getFoldersForContent = module.exports.getFoldersForContent = function(contentId, callback) {
    AuthzAPI.getAuthzMembers(contentId, null, 10000, function(err, members) {
        if (err) {
            log().error({'err': err, 'contentId': contentId}, 'Unable to get the members of a piece of content');
            return callback(err);
        }

        var groupIds = AuthzUtil.getGroupIds(members);
        FoldersDAO.getFoldersByGroupIds(groupIds, callback);
    });
};

/**
 * Given a folder, get all the ids of content items that are in it. Note that
 * this function does not perform any access-checks or visibility scoping.
 *
 * @param  {Folder}         folder                  The folder for which to retrieve the content ids
 * @param  {Function}       callback                Standard callback funciton
 * @param  {Object}         callback.err            An error object, if any
 * @param  {String[]}       callback.contentIds     The ids of the content items that are in the folder
 * @api private
 */
var getContentInFolder = module.exports.getContentInFolder = function(folder, callback, _start, _contentIds) {
    _contentIds = _contentIds || [];

    // Get the content items in this folder from the canonical source
    AuthzAPI.getRolesForPrincipalAndResourceType(folder.groupId, 'c', _start, 1000, function(err, roles, nextToken) {
        if (err) {
            return callback(err);
        }

        // Keep track of the retrieved content items
        var contentIds = _.pluck(roles, 'id');
        _contentIds = _contentIds.concat(contentIds);

        // If there are more items to retrieve, pull them in
        if (nextToken) {
            _getContentInFolder(folder, callback, nextToken, _contentIds);

        // Otherwise we can return to the caller
        } else {
            return callback(null, _contentIds);
        }
    });
};

/**
 * Determine whether or not the user in context can post a message to the provided folder.
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {Folder}         folder                  The folder to test for access
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Boolean}        callback.canPost        `true` if the user in context can post a message to the provided folder
 */
var canPostFolderMessage = module.exports.canPostFolderMessage = function(ctx, folder, callback) {
    var user = ctx.user();

    // Anonymous can never post to a folder
    if (!user) {
        return callback(null, false);
    }

    // Try to determine the implicit role of the current user on the folder
    AuthzAPI.resolveImplicitRole(ctx, folder.groupId, folder.tenant.alias, folder.visibility, FoldersConstants.roles.ALL_PRIORITY, function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (implicitRole === FoldersConstants.roles.MANAGER) {
            // Implicit managers can always post, regardless of tenant
            return callback(null, true);
        } else if (canInteract) {
            // If we can interact with the item, we can always post to it
            return callback(null, true);
        }

        // See if this user has any explicit role, if so they can post
        return AuthzAPI.hasAnyRole(user.id, folder.groupId, callback);
    });
};

/**
 * Determine whether or not the user in context can delete the provided message from the provided folder.
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {Folder}         folder                  The folder to test for access
 * @param  {Message}        message                 The message to test for access
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Boolean}        callback.canDelete      `true` if the user in context can delete a message from the provided folder
 */
var canDeleteFolderMessage = module.exports.canDeleteFolderMessage = function(ctx, folder, message, callback) {
    var user = ctx.user();

    // Anonymous users cannot remove messages
    if (!user) {
        return callback(null, false);
    }

    // Try to determine the implicit role of the current user on the folder
    AuthzAPI.resolveImplicitRole(ctx, folder.groupId, folder.tenant.alias, folder.visibility, FoldersConstants.roles.ALL_PRIORITY, function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (implicitRole === FoldersConstants.roles.MANAGER) {
            // Managers can always delete messages
            return callback(null, true);
        } else if (canInteract && message.createdBy === user.id) {
            // The user is still able to interact with this tenant, they can delete their own message
            return callback(null, true);
        }

        // It's not our message, or we cannot implicitly interact. We need explicit manager access to delete the message
        return AuthzAPI.hasRole(user.id, folder.groupId, FoldersConstants.roles.MANAGER, callback);
    });
};

/**
 * Separate the list of resources between those that are private and those that are not
 *
 * @param  {Object[]}   resources                   An array of resources to separate
 * @param  {String}     resources[i].visibility     Each resource should have a visibility field to test
 * @return {Object}                                 An object with 2 fields: `privateResources` and `otherResources`; indicating the private and non-private resources of the array, respectively
 * @api private
 */
var _separatePrivateResources = function(resources) {
    var split = _.partition(resources, function(resource) {
        return (resource.visibility === AuthzConstants.visibility.PRIVATE);
    });

    return {'privateResources': split[0], 'otherResources': split[1]};
};
