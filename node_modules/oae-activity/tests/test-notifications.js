/*
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');

var ContentConstants = require('oae-content/lib/constants').ContentConstants;
var EmailTestsUtil = require('oae-email/lib/test/util');
var OaeUtil = require('oae-util/lib/util');
var RestAPI = require('oae-rest');
var RestContext = require('oae-rest/lib/model').RestContext;
var TestsUtil = require('oae-tests');

var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;
var ActivityModel = require('oae-activity/lib/model');
var ActivityRouter = require('oae-activity/lib/internal/router');
var ActivityTestsUtil = require('oae-activity/lib/test/util');


describe('Notifications', function() {

    // Rest context that can be used every time we need to make a request as an anonymous user
    var anonymousCamRestContext = null;

    // Rest context that can be used every time we need to make a request as a tenant admin
    var camAdminRestContext = null;

    // Rest context that can be used every time we need to make a request as a global admin
    var globalAdminRestContext = null;

    /*!
     * Create a default activity configuration object, overridden with the given `overlay` object.
     *
     * @param  {Object}    overlay     Configuration properties with which to overide the default.
     * @return {Object}                An object that represents the default configuration for unit tests, overridden by the overlay.
     */
    var createDefaultConfig = function(overlay) {
        return _.extend({'collectionPollingFrequency': -1}, overlay);
    };

    /**
     * Function that will fill up the tenant admin and anymous rest context
     */
    before(function(callback) {
        anonymousCamRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host);
        camAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.cam.host);
        globalAdminRestContext = TestsUtil.createGlobalAdminRestContext();
        callback();
    });

    describe('Notification Stream', function() {

        /**
         * Test that verifies anonymous cannot get a notification stream
         */
        it('verifies anonymous cannot get a notification stream', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, createdUsers) {
                assert.ok(!err);
                RestAPI.Activity.getNotificationStream(anonymousCamRestContext, null, function(err, response) {
                    assert.ok(err);
                    assert.equal(err.code, 401);
                    assert.ok(!response);
                    return callback();
                });
            });
        });

        /**
         * Test that verifies notifications are not sent to the actor of an activity.
         */
        it('verifies a notification is never sent to the actor of an activity', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, createdUsers) {
                assert.ok(!err);
                var mrvisser = createdUsers[_.keys(createdUsers)[0]];
                var simong = createdUsers[_.keys(createdUsers)[1]];

                // Create content with simong as a user
                RestAPI.Content.createLink(mrvisser.restContext, 'Google', 'Google', 'private', 'http://www.google.ca', [], [simong.user.id], function(err, content) {
                    assert.ok(!err);

                    // Sanity check that the content is in simong's notification stream
                    ActivityTestsUtil.collectAndGetNotificationStream(simong.restContext, null, function(err, notificationStream) {
                        assert.ok(!err);
                        assert.equal(notificationStream.items.length, 1);
                        assert.equal(notificationStream.items[0].actor['oae:id'], mrvisser.user.id);
                        assert.equal(notificationStream.items[0].object['oae:id'], content.id);

                        // Verify that no notification was routed to mrvisser, as they performed the action and this would be super annoying
                        ActivityTestsUtil.collectAndGetNotificationStream(mrvisser.restContext, null, function(err, notificationStream) {
                            assert.ok(!err);
                            assert.equal(notificationStream.items.length, 0);
                            callback();
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies a notification is sent to users when a content item is created with them as a member
         */
        it('verifies a notification is sent when creating content with a user member', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, createdUsers) {
                assert.ok(!err);
                var mrvisser = createdUsers[_.keys(createdUsers)[0]];
                var simong = createdUsers[_.keys(createdUsers)[1]];

                // Create content with simong as a user and verify it winds up in the notification stream
                RestAPI.Content.createLink(mrvisser.restContext, 'Google', 'Google', 'private', 'http://www.google.ca', [], [simong.user.id], function(err, content) {
                    assert.ok(!err);

                    ActivityTestsUtil.collectAndGetNotificationStream(simong.restContext, null, function(err, notificationStream) {
                        assert.ok(!err);
                        assert.equal(notificationStream.items.length, 1);
                        assert.equal(notificationStream.items[0].actor['oae:id'], mrvisser.user.id);
                        assert.equal(notificationStream.items[0].object['oae:id'], content.id);
                        callback();
                    });
                });
            });
        });

        /**
         * Test that verifies that receiving non-aggregating notifications will appropriately update the unreadNotificationsCount
         */
        it('verify unread notifications count', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, createdUsers) {
                assert.ok(!err);
                var mrvisser = createdUsers[_.keys(createdUsers)[0]];
                var simong = createdUsers[_.keys(createdUsers)[1]];

                // Generate 2 non-aggregating activities
                RestAPI.Content.createLink(mrvisser.restContext, 'Google', 'Google', 'private', 'http://www.google.ca', [], [simong.user.id], function(err, content) {
                    assert.ok(!err);
                    RestAPI.Group.createGroup(mrvisser.restContext, 'Group title', 'Group description', 'private', 'request', [], [simong.user.id], function(err, newGroup) {
                        assert.ok(!err);

                        // Simon should have 2 notifications
                        ActivityTestsUtil.collectAndGetNotificationStream(simong.restContext, null, function(err, notificationStream) {
                            assert.ok(!err);
                            assert.equal(notificationStream.items.length, 2);

                            // Verify the notificationsUnread count on the me feed
                            RestAPI.User.getMe(simong.restContext, function(err, meData) {
                                assert.ok(!err);
                                assert.strictEqual(meData.notificationsUnread, 2);
                                callback();
                            });
                        });
                    });
                });
            });
        });
    });

    describe('Mark Notifications Read', function() {

        /**
         * Test that verifies anonymous cannot mark a notification stream as read
         */
        it('verifies anonymous cannot mark a notification stream as read', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, createdUsers) {
                assert.ok(!err);
                RestAPI.Activity.markNotificationsRead(anonymousCamRestContext, function(err) {
                    assert.ok(err);
                    assert.equal(err.code, 401);
                    return callback();
                });
            });
        });

        /**
         * Test that verifies marking notifications as read and counts work.
         */
        it('verifies toggling of notifications read', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, createdUsers) {
                assert.ok(!err);
                var mrvisser = createdUsers[_.keys(createdUsers)[0]];
                var simong = createdUsers[_.keys(createdUsers)[1]];

                RestAPI.User.getMe(simong.restContext, function(err, me) {
                    assert.ok(!err);
                    assert.ok(!me.notificationsUnread);
                    assert.ok(!me.notificationsLastRead);

                    // Create content with simong as a member
                    RestAPI.Content.createLink(mrvisser.restContext, 'Google', 'Google', 'private', 'http://www.google.ca', [], [simong.user.id], function(err, firstContentObj) {
                        assert.ok(!err);

                        // Ensure the notification gets delivered
                        ActivityTestsUtil.collectAndGetNotificationStream(simong.restContext, null, function(err, notificationStream) {
                            assert.ok(!err);
                            assert.equal(notificationStream.items.length, 1);
                            assert.equal(notificationStream.items[0].actor['oae:id'], mrvisser.user.id);
                            assert.equal(notificationStream.items[0].object['oae:id'], firstContentObj.id);

                            // Verify the notificationsUnread status
                            RestAPI.User.getMe(simong.restContext, function(err, me) {
                                assert.ok(!err);

                                // We now have unread notifications, but still no "lastRead" status
                                assert.strictEqual(me.notificationsUnread, 1);
                                assert.strictEqual(me.notificationsLastRead, undefined);

                                ActivityTestsUtil.markNotificationsAsRead(simong.restContext, function(result) {
                                    var lastReadTime = result.lastReadTime;
                                    assert.strictEqual(lastReadTime, OaeUtil.getNumberParam(lastReadTime));

                                    // Verify the notificationsLastRead status
                                    RestAPI.User.getMe(simong.restContext, function(err, me) {
                                        assert.ok(!err);

                                        // We now have no unread notifications, and a lastRead status
                                        assert.strictEqual(me.notificationsUnread, 0);
                                        assert.strictEqual(me.notificationsLastRead, lastReadTime);

                                        // Create 2 content items again with simong as a member so we can assert the aggregation has been reset
                                        RestAPI.Content.createLink(mrvisser.restContext, 'Google', 'Google', 'private', 'http://www.google.ca', [], [simong.user.id], function(err, secondContentObj) {
                                            assert.ok(!err);

                                            RestAPI.Content.createLink(mrvisser.restContext, 'Google', 'Google', 'private', 'http://www.google.ca', [], [simong.user.id], function(err, thirdContentObj) {
                                                assert.ok(!err);

                                                // Ensure the notifications get delivered but don't aggregate with the older "marked as read" item
                                                ActivityTestsUtil.collectAndGetNotificationStream(simong.restContext, null, function(err, notificationStream) {
                                                    assert.ok(!err);
                                                    assert.equal(notificationStream.items.length, 2);
                                                    ActivityTestsUtil.assertActivity(notificationStream.items[0], 'content-create', 'create', mrvisser.user.id, [secondContentObj.id, thirdContentObj.id]);
                                                    ActivityTestsUtil.assertActivity(notificationStream.items[1], 'content-create', 'create', mrvisser.user.id, firstContentObj.id);

                                                    // Verify the notificationsUnread is incremented and notificationsLastRead status
                                                    RestAPI.User.getMe(simong.restContext, function(err, me) {
                                                        assert.ok(!err);

                                                        // We now have unread notifications, and a lastRead status
                                                        assert.strictEqual(me.notificationsUnread, 2);
                                                        assert.strictEqual(me.notificationsLastRead, lastReadTime);

                                                        callback();
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    describe('Mail deduplication', function() {

        /*!
         * Flush the mail queue so other tests don't impact the mail deduplication tests
         */
        beforeEach(EmailTestsUtil.clearEmailCollections);

        /**
         * Test that verifies that when the activity router gets stuck and keeps reprocessing
         * the same activity feed, we don't generate emails for each one
         */
        it('verify mails for the same activity and the same user are only sent once', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 3, function(err, createdUsers, simong, mrvisser, nico) {
                assert.ok(!err);

                // Give mrvisser and nico an email address
                RestAPI.User.updateUser(mrvisser.restContext, mrvisser.user.id, {'email': 'mrvisser@example.com', 'emailPreference': 'immediate'}, function(err) {
                    assert.ok(!err);
                    RestAPI.User.updateUser(nico.restContext, nico.user.id, {'email': 'nico@example.com', 'emailPreference': 'immediate'}, function(err) {
                        assert.ok(!err);

                        // Create a piece of content and make nico and mrvisser managers. They should each get an e-mail
                        RestAPI.Content.createLink(simong.restContext, 'Yahoo!', 'Yahoo!', 'public', 'http://www.yahoo.com', [mrvisser.user.id, nico.user.id], [], function(err, link) {
                            assert.ok(!err);

                            // Assert that both nico and mrvisser received an e-mail, but noone else
                            EmailTestsUtil.collectAndFetchEmails(function(messages) {
                                assert.equal(messages.length, 2);
                                assert.ok(_.contains(['mrvisser@example.com', 'nico@example.com'], messages[0]._message.to));
                                assert.ok(_.contains(['mrvisser@example.com', 'nico@example.com'], messages[1]._message.to));
                                assert.notEqual(messages[0]._message.to, messages[1]._message.to);

                                // Simulate an unexpected loop and try to route the same activity seed multiple times
                                var actorResource = new ActivityModel.ActivitySeedResource('user', simong.user.id);
                                var objectResource = new ActivityModel.ActivitySeedResource('content', link.id);
                                var seed = new ActivityModel.ActivitySeed(ContentConstants.activity.ACTIVITY_CONTENT_UPDATE, Date.now(), ActivityConstants.verbs.UPDATE, actorResource, objectResource);
                                ActivityRouter.routeActivity(seed, function(err) {
                                    assert.ok(!err);
                                    ActivityRouter.routeActivity(seed, function(err) {
                                        assert.ok(!err);
                                        ActivityRouter.routeActivity(seed, function(err) {
                                            assert.ok(!err);

                                            // Assert that only 1 mail got sent to both nico and mrvisser
                                            EmailTestsUtil.collectAndFetchEmails(function(messages) {
                                                assert.equal(messages.length, 2);
                                                assert.ok(_.contains(['mrvisser@example.com', 'nico@example.com'], messages[0]._message.to));
                                                assert.ok(_.contains(['mrvisser@example.com', 'nico@example.com'], messages[1]._message.to));
                                                assert.notEqual(messages[0]._message.to, messages[1]._message.to);
                                                return callback();
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });
});
