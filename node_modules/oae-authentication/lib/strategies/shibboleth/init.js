/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var Cassandra = require('oae-util/lib/cassandra');
var ConfigAPI = require('oae-config');
var Context = require('oae-context').Context;
var log = require('oae-logger').logger('oae-authentication');
var Redis = require('oae-util/lib/redis');

var AuthenticationAPI = require('oae-authentication');
var AuthenticationConfig = ConfigAPI.config('oae-authentication');
var AuthenticationConstants = require('oae-authentication/lib/constants').AuthenticationConstants;
var AuthenticationUtil = require('oae-authentication/lib/util');

var ShibbolethAPI = require('./api');
var ShibbolethStrategy = require('./strategy');

module.exports = function(config) {

    // Refresh the shibboleth configuration
    ShibbolethAPI.refreshConfiguration(config);


    // Build up the OAE strategy
    var strategy = {};

    /**
     * @see oae-authentication/lib/strategy#shouldBeEnabled
     */
    strategy.shouldBeEnabled = ShibbolethAPI.isEnabled;

    /**
     * @see oae-authentication/lib/strategy#getPassportStrategy
     */
    strategy.getPassportStrategy = function(tenant) {
        // We fetch the config values *in* the getPassportStrategy so it can be re-configured at run-time

        // The entity ID of the Shibboleth IdP
        var idpEntityID = AuthenticationConfig.getValue(tenant.alias, AuthenticationConstants.providers.SHIBBOLETH, 'idpEntityID');

        // The priority list that identifies which attribute should be used as the external id
        var externalIdAttributes = AuthenticationConfig.getValue(tenant.alias, AuthenticationConstants.providers.SHIBBOLETH, 'externalIdAttributes');
        externalIdAttributes = _.chain(externalIdAttributes.split(' ')).compact().uniq().value();

        // Attribute mappings
        var mapDisplayName = AuthenticationConfig.getValue(tenant.alias, AuthenticationConstants.providers.SHIBBOLETH, 'mapDisplayName');
        var mapEmail = AuthenticationConfig.getValue(tenant.alias, AuthenticationConstants.providers.SHIBBOLETH, 'mapEmail');
        var mapLocale = AuthenticationConfig.getValue(tenant.alias, AuthenticationConstants.providers.SHIBBOLETH, 'mapLocale');

        var passportStrategy = new ShibbolethStrategy({
            'idpEntityID': idpEntityID
        }, function(headers, callback) {

            log().trace({
                'tenant': tenant,
                'headers': headers
            }, 'Received Shibboleth authentication callback');

            // The `remote_user` header is configured in Shibboleth to identify this user. We use
            // this value as a fall-back in case the priority list in the Shibboleth strategy
            // doesn't result in anything useful
            var externalId = headers['remote_user'];

            // The external ID is configurable in the admin UI as a priority list (similar to
            // how `mod_shib` works). We try to find an attribute in the released set that matches
            // any of the configurable attributes. Rather than relying on `mod_shib`'s `remote_user`
            // attribute, we rely on the configured list as it allows administrators to specify
            // attributes on a per-tenant basis
            for (var i = 0; ((externalId === headers['remote_user']) && (i < externalIdAttributes.length)); i++) {
                var attribute = externalIdAttributes[i];
                if (headers[attribute]) {
                    externalId = headers[attribute];
                }
            }

            if (!externalId) {
                log().error({'headers': headers, 'tenant': tenant}, 'No suitable attribute was found for the `externalId` attribute');
                return callback({'code': 500, 'msg': 'No suitable attribute was found for the `externalId` attribute'});
            }

            /*
             * There are a lot of SAML attributes that may indicate a user's display name. The administrator
             * should provide a suitable mapping to construct the displayname. If no suitable value was returned
             * from the mapping, we fall back to the `remote_user` attribute, as this is always provided
             */
            var displayName = AuthenticationUtil.renderTemplate(mapDisplayName, headers) || headers['remote_user'];

            // Set the optional profile parameters
            var opts = {};
            AuthenticationUtil.setProfileParameter(opts, 'email', mapEmail, headers);
            AuthenticationUtil.setProfileParameter(opts, 'locale', mapLocale, headers);

            // We consider Shibboleth to be an authoritative source for user's their
            // email adresses. There's no need for the user to verify it
            if (opts.email) {
                opts.emailVerified = true;
            }

            var context = new Context(tenant, null);
            AuthenticationAPI.getOrCreateUser(context, AuthenticationConstants.providers.SHIBBOLETH, externalId, null, displayName, opts, function(err, user, loginId, created) {
                if (err) {
                    return callback(err);

                // There is no need to persist the metadata when the user account already exists
                } else if (!created) {
                    return callback(null, user);
                }

                // Remove unneeded headers as we need to serialize it
                delete headers['x-real-ip'];
                delete headers['x-forwarded-for'];
                delete headers['host'];
                delete headers['x-nginx-proxy'];
                delete headers['cache-control'];
                delete headers['x-cache-control'];
                delete headers['accept'];
                delete headers['user-agent'];
                delete headers['referer'];
                delete headers['accept-encoding'];
                delete headers['accept-language'];
                delete headers['cookie'];
                delete headers['x-forwarded-host'];
                delete headers['x-forwarded-server'];

                // We store extra information as it might be useful later on
                var metadata = {
                    /*
                     * The Shib persistent ID is a triple of:
                     *    * The IdP's entity ID
                     *    * The SP's entity ID
                     *    * A randomly generated ID identifying the user
                     *  e.g.: https://idp.testshib.org/idp/shibboleth!https://shib-sp.oae-performance.oaeproject.org/shibboleth!wjsKmFPZ7Kjml9HqD0Dbio5vzVo=
                     *
                     * This ID can be used with the IdP to retrieve profile attributes of the user or to check if that user
                     * is still part of the organization. We store it for use it later on.
                     * @see https://wiki.shibboleth.net/confluence/display/SHIB2/IdPPersistentNameIdentifier
                     */
                    'persistentId': headers['persistent-id'],

                    // The entity ID of the IdP
                    'identityProvider': headers['shib-identity-provider'],

                    // Affiliation information
                    'affiliation': headers['affiliation'],
                    'unscopedAffiliation': headers['unscoped-affiliation'],

                    // Persist all the attributes as a stringified JSON object
                    'allAttributes': JSON.stringify(headers)
                };
                var q = Cassandra.constructUpsertCQL('ShibbolethMetadata', 'loginId', loginId, metadata);
                if (!q) {
                    log().error({
                        'loginId': loginId,
                        'metadata': metadata,
                        'headers': headers,
                        'user': user
                    }, 'Unable to construct a Shibboleth metadata query');
                    return callback({'code': 500, 'msg': 'Unable to store Shibboleth metadata'});
                }
                Cassandra.runQuery(q.query, q.parameters, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    return callback(null, user);
                });
            });
        });
        return passportStrategy;
    };

    // Register our strategy
    AuthenticationAPI.registerStrategy(AuthenticationConstants.providers.SHIBBOLETH, strategy);
};
