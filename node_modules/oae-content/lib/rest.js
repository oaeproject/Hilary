/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var log = require('oae-logger').logger('content-rest');
var OAE = require('oae-util/lib/oae');
var OaeUtil = require('oae-util/lib/util');

var ContentAPI = require('./api');
var ContentConstants = require('./constants').ContentConstants;

/**
 * Verify the signature information provided by a signed download request and
 * pass it on to the download handler to complete the download request
 *
 * @param  {Request}     req    The Express Request object
 * @param  {Response}    res    The Express Response object
 * @api private
 */
var _handleSignedDownload = function(req, res) {
    ContentAPI.verifySignedDownloadQueryString(req.ctx, req.query, function(err, downloadInfo) {
        if (err) {
            return res.send(err.code, err.msg);
        }

        return _handleDownload(res, downloadInfo, true);
    });
};

/**
 * @REST postContentCreateCollabdoc
 *
 * Create a new collaborative document
 *
 * @Server      tenant
 * @Method      POST
 * @Path        /content/create
 * @FormParam   {string}            displayName         The display name of the collaborative document
 * @FormParam   {string}            resourceSubType     The content item type                                                                       [collabdoc]
 * @FormParam   {string}            [description]       A longer description for the collaborative document
 * @FormParam   {string[]}          [managers]          Unique identifier(s) for users and groups to add as managers of the collaborative document. The user creating the collaborative document will be added as a manager automatically
 * @FormParam   {string[]}          [viewers]           Unique identifier(s) for users and groups to add as members of the collaborative document
 * @FormParam   {string}            [visibility]        The visibility of the collaborative document. Defaults to the configured tenant default     [loggedin,private,public]
 * @Return      {BasicContent}                          The created collaborative document
 */

/**
 * @REST postContentCreateFile
 *
 * Create new file
 *
 * @Server      tenant
 * @Method      POST
 * @Path        /content/create
 * @FormParam   {string}            displayName         The display name of the file
 * @FormParam   {File}              file                The binary content for the file
 * @FormParam   {string}            resourceSubType     The content item type                                                                [file]
 * @FormParam   {string}            [description]       A longer description for the file
 * @FormParam   {string[]}          [managers]          Unique identifier(s) for users and groups to add as managers of the file. The user creating the file will be added as a manager automatically
 * @FormParam   {string[]}          [viewers]           Unique identifier(s) for users and groups to add as members of the file
 * @FormParam   {string}            [visibility]        The visibility of the file. Defaults to the configured tenant default               [loggedin,private,public]
 * @Return      {BasicContent}                          The created file
 */

/**
 * @REST postContentCreateLink
 *
 * Create new link
 *
 * @Server      tenant
 * @Method      POST
 * @Path        /content/create
 * @FormParam   {string}            displayName         The display name of the link
 * @FormParam   {string}            link                The URL to which the link points
 * @FormParam   {string}            resourceSubType     The content item type                                                                       [link]
 * @FormParam   {string}            [description]       A longer description for the link
 * @FormParam   {string[]}          [managers]          Unique identifier(s) for users and groups to add as managers of the link. The user creating the link will be added as a manager automatically
 * @FormParam   {string[]}          [viewers]           Unique identifier(s) for users and groups to add as members of the link
 * @FormParam   {string}            [visibility]        The visibility of the link. Defaults to the configured tenant default                       [loggedin,private,public]
 * @Return      {BasicContent}                          The created link
 */
OAE.tenantRouter.on('post', '/api/content/create', function(req, res) {
    // Ensure proper arrays for the additional members
    req.body.managers = OaeUtil.toArray(req.body.managers);
    req.body.viewers = OaeUtil.toArray(req.body.viewers);

    // Construct a hash for additional members that maps each user to their role
    var additionalMembers = {};
    _.each(req.body.managers, function(userId) {
        additionalMembers[userId] = ContentConstants.roles.MANAGER;
    });
    _.each(req.body.viewers, function(userId) {
        additionalMembers[userId] = ContentConstants.roles.VIEWER;
    });

    // Link creation
    if (req.body.resourceSubType === 'link') {
        ContentAPI.createLink(req.ctx, req.body.displayName, req.body.description, req.body.visibility, req.body.link, additionalMembers, function(err, contentObj) {
            if (err) {
                return res.send(err.code, err.msg);
            }
            res.send(201, contentObj);
        });
    // File creation
    } else if (req.body.resourceSubType === 'file') {
        var uploadedFile = null;
        if (req.files) {
            uploadedFile = req.files.file;
        }
        ContentAPI.createFile(req.ctx, req.body.displayName, req.body.description, req.body.visibility, additionalMembers, uploadedFile, function(err, contentObj) {
            if (err) {
                // At this point we can use regular responses again.
                return res.send(err.code, err.msg);
            }
            // Set the response type to text/plain, as the UI uses an iFrame upload mechanism to support IE9
            // file uploads. If the response type is not set to text/plain, IE9 will try to download the response.
            res.set('Content-Type', 'text/plain');
            res.send(201, contentObj);
        });
    // Collaborative document creation
    } else if (req.body.resourceSubType === 'collabdoc') {
        ContentAPI.createCollabDoc(req.ctx, req.body.displayName, req.body.description, req.body.visibility, additionalMembers, function(err, contentObj) {
            if (err) {
                return res.send(err.code, err.msg);
            }
            res.send(201, contentObj);
        });
    // Not a recognized file type
    } else {
        res.send(400, 'Unrecognized resourceSubType. Accepted values are "link", "file" and "collabdoc"');
    }
});

/**
 * @REST deleteContentContentId
 *
 * Delete a content item
 *
 * @Server      tenant
 * @Method      DELETE
 * @Path        /content/{contentId}
 * @PathParam   {string}                contentId           The id of the content item to delete
 * @Return      {void}
 */
OAE.tenantRouter.on('delete', '/api/content/:contentId', function(req, res) {
    ContentAPI.deleteContent(req.ctx, req.params.contentId, function(err) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200);
    });
});

/**
 * @REST getContentContentId
 *
 * Get a full content item profile
 *
 * @Server      tenant
 * @Method      GET
 * @Path        /content/{contentId}
 * @PathParam   {string}                contentId           The id of the content item to get
 * @Return      {Content}                                   Full content profile
 */
OAE.tenantRouter.on('get', '/api/content/:contentId', function(req, res) {
    ContentAPI.getFullContentProfile(req.ctx, req.params.contentId, function(err, contentProfile) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, contentProfile);
    });
});

/**
 * @REST postContentContentId
 *
 * Update a content item
 *
 * @Server      tenant
 * @Method      POST
 * @Path        /content/{contentId}
 * @PathParam   {string}                contentId           The id of the content item to update
 * @FormParam   {string}                [description]       Updated description for the content item
 * @FormParam   {string}                [displayName]       Updated display name for the content item
 * @FormParam   {string}                [link]              Updated URL for a link
 * @FormParam   {string}                [visibility]        Updated visibility for the discussion           [loggedin,private,public]
 * @Return      {Content}                                   The updated content item
 */
OAE.tenantRouter.on('post', '/api/content/:contentId', function(req, res) {
    ContentAPI.updateContentMetadata(req.ctx, req.params.contentId, req.body, function(err, newContentObj) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, newContentObj);
    });
});

/**
 * @REST getContentContentIdDownload
 *
 * Download the latest revision of a file
 *
 * @Server      tenant
 * @Method      GET
 * @Path        /content/{contentId}/download
 * @PathParam   {string}                contentId           The id of the file to download
 * @Return      {File}                                      The latest revision of the file
 */
OAE.tenantRouter.on('get', '/api/content/:contentId/download', function(req, res) {
    ContentAPI.getRevisionDownloadInfo(req.ctx, req.params.contentId, null, function(err, downloadInfo) {
        if (err) {
            return res.send(err.code, err.msg);
        }

        return _handleDownload(res, downloadInfo, false);
    });
});

/**
 * @REST getContentContentIdDownloadRevisionId
 *
 * Download a revision of a file
 *
 * @Server      tenant
 * @Method      GET
 * @Path        /content/{contentId}/download/{revisionId}
 * @PathParam   {string}                contentId           The id of the file to download
 * @PathParam   {string}                revisionId          The id of the revision to download
 * @Return      {File}                                      The specified revision of the file
 */
OAE.tenantRouter.on('get', '/api/content/:contentId/download/:revisionId', function(req, res) {
    ContentAPI.getRevisionDownloadInfo(req.ctx, req.params.contentId, req.params.revisionId, function(err, downloadInfo) {
        if (err) {
            return res.send(err.code, err.msg);
        }

        return _handleDownload(res, downloadInfo, true);
    });
});

/**
 * @REST postContentContentIdNewversion
 *
 * Upload a new version of a file
 *
 * @Server      tenant
 * @Method      POST
 * @Path        /content/{contentId}/newversion
 * @PathParam   {string}             contentId              The id of the file to upload a new version for
 * @FormParam   {File}               file                   The new binary content for the file
 * @Return      {Content}                                   The updated content item
 */
OAE.tenantRouter.on('post', '/api/content/:contentId/newversion', function(req, res) {
    if (!req.files || !req.files.file) {
        return res.send(400, 'Missing file parameter');
    }

    ContentAPI.updateFileBody(req.ctx, req.params.contentId, req.files.file, function(err, updatedContentObj) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        // Set the response type to text/plain, as the UI uses an iFrame upload mechanism to support IE9
        // file uploads. If the response type is not set to text/plain, IE9 will try to download the response.
        res.set('Content-Type', 'text/plain');
        res.send(200, updatedContentObj);
    });
});

/**
 * @REST postContentContentIdJoin
 *
 * Join a collaborative document
 *
 * @Server      tenant
 * @Method      POST
 * @Path        /content/{contentId}/join
 * @PathParam   {string}             contentId              The id of the collaborative document to join
 * @Return      {CollabdocJoinInfo}                         Information on how to join the collaborative document
 */
OAE.tenantRouter.on('post', '/api/content/:contentId/join', function(req, res) {
    ContentAPI.joinCollabDoc(req.ctx, req.params.contentId, function(err, data) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, data);
    });
});

/**
 * @REST postContentContentIdRevisionsRevisionIdPreviews
 *
 * Attach a preview item to a content item
 *
 * @Api         private
 * @Server      tenant
 * @Method      POST
 * @Path        /content/{contentId}/revisions/{revisionId}/previews
 * @PathParam   {string}            contentId               The id of the content item to attach a preview to
 * @PathParam   {string}            revisionId              The id of the revision to attach a preview to
 * @BodyParam   {UpdatedPreview}    body                    Updated preview metadata
 * @FormParam   {File}              file                    The binary content of the preview
 * @Return      {void}
 */
OAE.tenantRouter.on('post', '/api/content/:contentId/revisions/:revisionId/previews', function(req, res) {
    var contentMetadata = null;
    var previewMetadata = null;
    var sizes = null;
    var files = null;
    try {
        contentMetadata = JSON.parse(req.body.contentMetadata);
        previewMetadata = JSON.parse(req.body.previewMetadata);
        sizes = JSON.parse(req.body.sizes);

        if (req.body.links) {
            files = JSON.parse(req.body.links);
        }
    } catch (err) {
        var invalidField = null;
        if (!contentMetadata) {
            invalidField = 'contentMetadata';
        } else if (!previewMetadata) {
            invalidField = 'previewMetadata';
        } else if (!sizes) {
            invalidField = 'sizes';
        } else if (!files) {
            invalidField = 'links';
        }

        return res.send(400, 'Malformed metadata object. Expected proper JSON for: ' + invalidField);
    }

    if (req.files) {
        files = files || {};
        _.extend(files, req.files);
    }

    ContentAPI.setPreviewItems(req.ctx, req.params.contentId, req.params.revisionId, req.body.status, files, sizes, contentMetadata, previewMetadata, function(err) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(201);
    });
});

/**
 * @REST getContentContentIdRevisionsRevisionIdPreviews
 *
 * Get the previews for a revision
 *
 * @Server      tenant
 * @Method      GET
 * @Path        /content/{contentId}/revisions/{revisionId}/previews
 * @PathParam   {string}             contentId              The id of the content item to get the previews for
 * @PathParam   {string}             revisionId             The id of the revision to get the previews for
 * @Return      {PreviewsList}                              The revision previews
 */
OAE.tenantRouter.on('get', '/api/content/:contentId/revisions/:revisionId/previews', function(req, res) {
    ContentAPI.getPreviewItems(req.ctx, req.params.contentId, req.params.revisionId, function(err, previews) {
        if (err) {
            return res.send(err.code, err.msg);
        }

        res.send(200, previews);
    });
});

/**
 * @REST getContentContentIdRevisionsRevisionIdPreviewsItem
 *
 * Download a preview
 *
 * @Server      tenant
 * @Method      GET
 * @Path        /content/{contentId}/revisions/{revisionId}/previews/{item}
 * @PathParam   {string}             contentId              The id of the content item to download the preview for
 * @PathParam   {string}             revisionId             The id of the revision to download the preview for
 * @PathParam   {string}             item                   The preview item to download
 * @QueryParam  {string}             expires                The timestamp (millis since epoch) at which the signature expires
 * @QueryParam  {string}             signature              The access control signature
 * @Return      {File}                                      The preview
 */
OAE.tenantRouter.on('get', '/api/content/:contentId/revisions/:revisionId/previews/:item', function(req, res) {
    var signature = {
        'signature': req.query.signature,
        'expires': req.query.expires,
        'lastModified': req.query.lastmodified
    };
    ContentAPI.getSignedPreviewDownloadInfo(req.ctx, req.params.contentId, req.params.revisionId, req.params.item, signature, function(err, downloadInfo) {
        if (err) {
            return res.send(err.code, err.msg);
        }

        return _handleDownload(res, downloadInfo, true);
    });
});

/**
 * @REST getContentContentIdRevisions
 *
 * Get the revisions for a content item
 *
 * @Server      tenant
 * @Method      GET
 * @Path        /content/{contentId}/revisions
 * @PathParam   {string}            contentId           The id of the content item to get the revisions for
 * @QueryParam  {number}            [limit]             The maximum number of results to return. Default: 10
 * @QueryParam  {string}            [start]             The revision paging token from which to start fetching revisions
 * @Return      {Revisions}                             The revisions for the specified content item
 */
OAE.tenantRouter.on('get', '/api/content/:contentId/revisions', function(req, res) {
    var limit = OaeUtil.getNumberParam(req.query.limit, 10, 1, 25);
    ContentAPI.getRevisions(req.ctx, req.params.contentId, req.query.start, limit, function(err, revisions, nextToken) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, {'results': revisions, 'nextToken': nextToken});
    });
});

/**
 * @REST getContentContentIdRevisionsRevisionId
 *
 * Get a revision
 *
 * @Server      tenant
 * @Method      GET
 * @Path        /content/{contentId}/revisions/{revisionId}
 * @PathParam   {string}            contentId           The id of the content item to get the revision for
 * @PathParam   {string}            revisionId          The id of the revision to get
 * @Return      {Revision}                              The revision
 */
OAE.tenantRouter.on('get', '/api/content/:contentId/revisions/:revisionId', function(req, res) {
    ContentAPI.getRevision(req.ctx, req.params.contentId, req.params.revisionId, function(err, revision) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, revision);
    });
});

/**
 * @REST postContentContentIdRevisionsRevisionIdRestore
 *
 * Restore a revision
 *
 * @Server      tenant
 * @Method      POST
 * @Path        /content/{contentId}/revisions/{revisionId}/restore
 * @PathParam   {string}            contentId           The id of the content item to restore the revision for
 * @PathParam   {string}            revisionId          The id of the revision to restore
 * @Return      {Revision}                              The restored revision
 */
OAE.tenantRouter.on('post', '/api/content/:contentId/revisions/:revisionId/restore', function(req, res) {
    ContentAPI.restoreRevision(req.ctx, req.params.contentId, req.params.revisionId, function(err, newRevision) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, newRevision);
    });
});

/**
 * @REST getContentContentIdMembers
 *
 * Get the members of a content item and their roles
 *
 * @Server      tenant
 * @Method      GET
 * @Path        /content/{contentId}/members
 * @PathParam   {string}            contentId           The id of the content item to get the members for
 * @QueryParam  {number}            [limit]             The maximum number of results to return. Default: 10
 * @QueryParam  {string}            [start]             The content paging token from which to start fetching content members
 * @Return      {MembersResponse}                       Members of the specified content item
 */
OAE.tenantRouter.on('get', '/api/content/:contentId/members', function(req, res) {
    var limit = OaeUtil.getNumberParam(req.query.limit, 10, 1, 25);
    ContentAPI.getContentMembersLibrary(req.ctx, req.params.contentId, req.query.start, limit, function(err, members, nextToken) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, {'results': members, 'nextToken': nextToken});
    });
});

/**
 * @REST postContentContentIdMembers
 *
 * Update the members of a content item
 *
 * @Server      tenant
 * @Method      POST
 * @Path        /content/{contentId}/members
 * @PathParam   {string}                contentId           The id of the content item to update the members for
 * @BodyParam   {ContentMembersUpdate}  body                Object that describes the membership updates to apply to the content item
 * @Return      {void}
 */
OAE.tenantRouter.on('post', '/api/content/:contentId/members', function(req, res) {
    // Parse the incoming false values
    var requestKeys = _.keys(req.body);
    for (var r = 0; r < requestKeys.length; r++) {
        req.body[requestKeys[r]] = OaeUtil.castToBoolean(req.body[requestKeys[r]]);
    }
    ContentAPI.setContentPermissions(req.ctx, req.params.contentId, req.body, function(err) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200);
    });
});

/**
 * @REST postContentContentIdShare
 *
 * Share a content item
 *
 * @Server      tenant
 * @Method      POST
 * @Path        /content/{contentId}/share
 * @PathParam   {string}        contentId           The id of the content item to share
 * @FormParam   {string[]}      viewers             Unique identifier(s) for users and groups to share the content item with
 * @Return      {void}
 */
OAE.tenantRouter.on('post', '/api/content/:contentId/share', function(req, res) {
    // Make sure viewers is an array
    req.body.viewers = OaeUtil.toArray(req.body.viewers);
    ContentAPI.shareContent(req.ctx, req.params.contentId, req.body.viewers, function(err) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200);
    });
});

/**
 * @REST postContentContentIdMessages
 *
 * Create a new comment on a content item
 *
 * @Server      tenant
 * @Method      POST
 * @Path        /content/{contentId}/messages
 * @PathParam   {string}        contentId           The id of the content item to which to post the comment
 * @FormParam   {string}        body                The body of the comment
 * @FormParam   {string}        [replyTo]           The timestamp of the comment to which this comment is a reply. Not specifying this will create a top level comment
 * @Return      {Message}                           The created comment
 */
OAE.tenantRouter.on('post', '/api/content/:contentId/messages', function(req, res) {
    ContentAPI.createComment(req.ctx, req.params.contentId, req.body.body, req.body.replyTo, function(err, message) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(201, message);
    });
});

/**
 * @REST getContentContentIdMessages
 *
 * Get the comments for a content item
 *
 * @Server      tenant
 * @Method      GET
 * @Path        /content/{contentId}/messages
 * @PathParam   {string}            contentId           The id of the content item for which to get the comments
 * @QueryParam  {number}            [limit]             The maximum number of results to return. Default: 10
 * @QueryParam  {string}            [start]             The comments paging token from which to start fetching comments
 * @Return      {MessagesResponse}                      The comments on the content item
 */
OAE.tenantRouter.on('get', '/api/content/:contentId/messages', function(req, res) {
    var limit = OaeUtil.getNumberParam(req.query.limit, 10, 1, 25);
    ContentAPI.getComments(req.ctx, req.params.contentId, req.query.start, limit, function(err, messages, nextToken) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, {'results': messages, 'nextToken': nextToken});
    });
});

/**
 * @REST deleteContentContentIdMessagesCreated
 *
 * Delete a comment from a content item
 *
 * @Server      tenant
 * @Method      DELETE
 * @Path        /content/{contentId}/messages/{created}
 * @PathParam   {string}                contentId           The id of the content item from which to delete the comment
 * @PathParam   {string}                created             The timestamp of the comment that should be deleted
 * @Return      {Message}                                   The deleted comment
 */
OAE.tenantRouter.on('delete', '/api/content/:contentId/messages/:created', function(req, res) {
    ContentAPI.deleteComment(req.ctx, req.params.contentId, req.params.created, function(err, deleted) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, deleted);
    });
});

/**
 * @REST getContentLibraryPrincipalId
 *
 * Get the content library items for a user or group
 *
 * @Server      tenant
 * @Method      GET
 * @Path        /content/library/{principalId}
 * @PathParam   {string}            principalId         The id of the principal whose content library to fetch
 * @QueryParam  {number}            [limit]             The maximum number of results to return. Default: 10
 * @QueryParam  {string}            [start]             The content paging token from which to start fetching content items
 * @Return      {ContentLibrary}                        The content library items for the specified user or group
 */
OAE.tenantRouter.on('get', '/api/content/library/:principalId', function(req, res) {
    var limit = OaeUtil.getNumberParam(req.query.limit, 12, 1, 25);
    ContentAPI.getContentLibraryItems(req.ctx, req.params.principalId, req.query.start, limit, function(err, items, nextToken) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, {'results': items, 'nextToken': nextToken});
    });
});

/**
 * @REST deleteContentContentIdMessagesCreated
 *
 * Remove a content item from a content library
 *
 * @Server      tenant
 * @Method      DELETE
 * @Path        /content/library/{principalId}/{contentId}
 * @PathParam   {string}            principalId             The id of the principal from whose content library to remove the content item
 * @PathParam   {string}            contentId               The id of the content item to remove from the library
 * @Return      {void}
 */
OAE.tenantRouter.on('delete', '/api/content/library/:principalId/:contentId', function(req, res) {
    ContentAPI.removeContentFromLibrary(req.ctx, req.params.principalId, req.params.contentId, function(err) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200);
    });
});

/**
 * @REST getDownloadSigned
 *
 * Download a content item using an access control signature
 *
 * @Server      admin,tenant
 * @Method      GET
 * @Path        /download/signed
 * @QueryParam  {string}             expires                The timestamp (millis since epoch) at which the signature expires
 * @QueryParam  {string}             signature              The access control signature
 * @Return      {File}                                      The content item
 */
OAE.globalAdminRouter.on('get', '/api/download/signed', _handleSignedDownload);
OAE.tenantRouter.on('get', '/api/download/signed', _handleSignedDownload);

/**
 * Send the correct HTTP response according to a download strategy. Note that the "direct" download strategy is not being handled here
 * as the direct strategy should not be requested to the application for action, instead its target is delivered to the user verbatim
 * with no signature.
 *
 * @param  {Response}           res                     The Express Response object
 * @param  {Object}             downloadInfo            An object that represents an item that can be downloaded from the application
 * @param  {String}             downloadInfo.filename   The file name of the download
 * @param  {DownloadStrategy}   downloadInfo.strategy   How the application should deliver the download
 * @param  {Boolean}            [expiresMax]            Whether a far future expires response header should be set
 * @api private
 */
var _handleDownload = function(res, downloadInfo, expiresMax) {
    var downloadStrategy = downloadInfo.strategy;

    // A 204 suggest that the LB (nginx, apache, lighthttpd, ..) will be handling the download via the x-sendfile mechanism
    if (downloadStrategy.strategy === ContentConstants.backend.DOWNLOAD_STRATEGY_INTERNAL) {
        // Nginx internal download
        res.setHeader('X-Accel-Redirect', downloadStrategy.target);

        // Apache internal download
        res.setHeader('X-Sendfile', downloadStrategy.target);

        // Lighthttpd internal download
        res.setHeader('X-LIGHTTPD-send-file', downloadStrategy.target);

        if (expiresMax) {
            // Add the cache headers manually as some webservers are not
            // able to deal with setting cache headers and internal redirects
            // @see https://github.com/oaeproject/Hilary/issues/995
            res.setHeader('Expires', 'Thu, 31 Dec 2037 23:55:55 GMT');
            res.setHeader('Cache-Control', 'max-age=315360000');
        }

        res.setHeader('Content-Disposition', 'attachment; filename="' + downloadInfo.filename + '"');
        res.send(204, downloadStrategy.target);

    // A redirect strategy will invoke a redirect to the target
    } else if (downloadStrategy.strategy === ContentConstants.backend.DOWNLOAD_STRATEGY_REDIRECT) {
        // We can't guarantee that the backend won't want to update some details about the target over time. e.g., update some tracking
        // variables over time for analytics or additional security. Therefore, we do a temporary redirect (302)
        res.setHeader('Location', downloadStrategy.target);
        res.send(302);

    // The app server will send the file to the client. This should *NOT* be used in production and is only really here for easier unit
    // testing purposes
    } else if (downloadStrategy.strategy === ContentConstants.backend.DOWNLOAD_STRATEGY_TEST) {
        return res.download(downloadStrategy.target);

    // In all other cases we respond with a 404
    } else {
        res.send(404);
    }
};
