/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var clone = require('clone');
var sanitize = require('validator').sanitize;

var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var log = require('oae-logger').logger('principals-dao');
var Redis = require('oae-util/lib/redis');
var TZ = require('oae-util/lib/tz');

var Group = require('oae-principals/lib/model').Group;
var User = require('oae-principals/lib/model').User;
var PrincipalsUtil = require('oae-principals/lib/util');

/**
 * Query a principal row from storage and map it to the appropriate principal object (user or group).
 *
 * @param   {String}        principalId         The id of the principal to query
 * @param   {Function}      callback            Invoked when the process completes
 * @param   {Object}        callback.err        An error that occurred, if any
 * @param   {User|Group}    callback.prinicpal  The principal, either a user or a group, depending on the type of entity to which the id mapped. If the principal does not exist, this will be `null`
 */
var getPrincipal = module.exports.getPrincipal = function(principalId, callback) {
    if (isUser(principalId)) {
        // Try and get the user from the cache first. If they aren't cached, we will fetch them from the DB and it will get cached then
        getUserFromRedis(principalId, function(err, user) {
            if (err && err.code !== 404) {
                log().error({'err': err}, 'Error occurred when trying to get a user from Redis.');
            } else if (user) {
                // We found a user in the cache, immediately return it
                return callback(null, user);
            }

            // The user wasn't cached, fetch from the DB
            return getPrincipalFromCassandra(principalId, callback);
        });
    } else {
        // Get groups from the DB.
        getPrincipalFromCassandra(principalId, callback);
    }
};

/**
 * Query a set of principal rows from storage and map it to the appropriate principal object (user or group).
 *
 * @param   {String[]}      principalIds            The ids of the principals to query
 * @param   {Function}      callback                Invoked when the process completes
 * @param   {Object}        callback.err            If an unexpected systemic error occurred, or if any of the given principals did not exist
 * @param   {String[]}      callback.err.existing   The ids of the principals that existed
 * @param   {String[]}      callback.err.missing    The ids of the principals that did not exist
 * @param   {Object[]}      callback.principals     A hash of principals, keyed by the principal id, and whose value is the principal (either user or group) to which the id mapped.
 */
var getPrincipals = module.exports.getPrincipals = function(principalIds, callback) {
    if (!principalIds || principalIds.length === 0) {
        return callback(null, {});
    }

    // If we're only requesting 1 principal we can hand it off to the getPrincipal method.
    // This will try looking in the cache first, which might be faster.
    if (principalIds.length === 1) {
        return getPrincipal(principalIds[0], function(err, user) {
            if (err) {
                return callback(err);
            }

            var users = {};
            users[principalIds[0]] = user;
            return callback(null, users);
        });
    }

    Cassandra.runQuery('SELECT * FROM Principals USING CONSISTENCY QUORUM WHERE principalId IN (?)', [principalIds], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var principals = {};
        var missing = [];
        for (var i = 0; i < rows.length; i++) {
            var row = rows[i];
            var principal = getPrincipalFromRow(row);
            if (principal) {
                principals[principal.id] = principal;
            } else {
                missing.push(row.get('principalId').value);
            }
        }

        if (missing.length > 0) {
            return callback({
                'code': 400,
                'msg': 'Some principals could not be found',
                'existing': _.keys(principals),
                'missing': missing
            });
        }

        return callback(null, principals);
    });
};

/**
 * Iterate through all the principals. This will return just the raw principal properties that are specified in the `properties`
 * parameter, and only `batchSize` principals at a time. On each iteration of `batchSize` principals, the `onEach` callback
 * will be invoked, and the next batch will not be fetched until you have invoked the `onEach.done` function parameter. When
 * complete (e.g., there are 0 principals left to iterate through or an error has occurred), the `callback` parameter will be
 * invoked.
 *
 * @param  {String[]}   [properties]            The names of the principal properties to return in the principal objects. If not specified (or is empty array), it returns just the `principalId`s
 * @param  {Number}     [batchSize]             The number of principals to fetch at a time. Defaults to 100
 * @param  {Function}   onEach                  Invoked with each batch of principals that are fetched from storage
 * @param  {Object}     onEach.principalRow     An object holding the raw principal data that was fetched from storage
 * @param  {Function}   onEach.done             The function to invoke when processing of the current batch is complete
 * @param  {Object}     onEach.done.err         An error that occurred, if any, while processing the current batch. If you specify this error, iteration will finish and the completion callback will be invoked
 * @param  {Function}   [callback]              Invoked when all rows have been iterated, or an error has occurred
 * @param  {Object}     [callback.err]          An error that occurred, while iterating rows, if any
 * @see Cassandra#iterateAll
 */
var iterateAll = module.exports.iterateAll = function(properties, batchSize, onEach, callback) {
    if (!properties || !properties.length) {
        properties = ['principalId'];
    }

    /*!
     * Handles each batch from the cassandra iterateAll method.
     *
     * @see Cassandra#iterateAll
     */
    var _iterateAllOnEach = function(rows, done) {
        // Convert the rows to a hash and delegate action to the caller onEach method
        var hashedRows = [];
        rows.forEach(function(row) {
            hashedRows.push(Cassandra.rowToHash(row));
        });

        return onEach(hashedRows, done);
    };

    var opts = {
        'batchSize': batchSize,
        'consistency': 'ONE',
        'slugColumnName': 'visibility'
    };

    Cassandra.iterateAll(properties, 'Principals', 'principalId', opts, _iterateAllOnEach, callback);
};

/**
 * Determine whether or not the given string represents a group id.
 *
 * @param  {String}  groupId    A string that may or may not be a group id
 * @return {Boolean}            Whether or not the provided identifier is a group identifier.
 */
var isGroup = module.exports.isGroup = function(groupId) {
    return AuthzUtil.isGroupId(groupId);
};

/**
 * Determine whether or not the given string represents a user id.
 *
 * @param  {String}  userId     A string that may or may not be a user id
 * @return {Boolean}            Whether or not the provided identifier is a user identifier.
 */
var isUser = module.exports.isUser = function(userId) {
    return AuthzUtil.isUserId(userId);
};

/**
 * Get a principal from Cassandra.
 *
 * @param  {String}         principalId         The ID of the principal that should be retrieved.
 * @param  {Function}       callback            A callback method.
 * @param  {Object}         callback.err        An error object (if any)
 * @param  {Group|User}     callback.principal  The asked for principal.
 * @api private
 */
var getPrincipalFromCassandra = function(principalId, callback) {
    Cassandra.runQuery('SELECT * FROM Principals USING CONSISTENCY QUORUM WHERE principalId = ?', [principalId], function (err, rows) {
        if (err) {
            return callback(err);
        }

        var principal = getPrincipalFromRow(rows[0]);

        if (!principal) {
            return callback({'code': 404, 'msg': 'Couldn\'t find principal: ' + principalId});
        } else if (isGroup(principal.id)) {
            return callback(null, principal);
        }

        // Deep-copy the User object *before* we apply the visibility settings.
        // this allows us to retrieve a full object from redis later.
        var hash = clone(principal);

        // Immediately callback, storing something in redis can happen async.
        callback(null, principal);

        // Redis takes only strings as hash field values so convert non-strings.
        // Convert or remove values that shouldn't be in redis.
        delete hash.isAdmin;
        delete hash.tenant;
        hash.tenantAlias = principal.tenant.alias;
        hash.isGlobalAdmin = '' + hash.isGlobalAdmin();
        hash.isTenantAdmin = '' + hash.isTenantAdmin(principal.tenant.alias);

        // The picture object is always present.
        // It's faster to store plain hashes rather than doing JSON.parse/stringify.
        if (hash.picture.smallUri) {
            hash.smallPictureUri = hash.picture.smallUri;
        }
        if (hash.picture.mediumUri) {
            hash.mediumPictureUri = hash.picture.mediumUri;
        }
        if (hash.picture.largeUri) {
            hash.largePictureUri = hash.picture.largeUri;
        }
        delete hash.picture;

        // Convert the extra object.
        if (hash.extra) {
            try {
                hash.extra = JSON.stringify(hash.extra);
            } catch (err) {
                log().error({'err': err}, 'Failed to stringify the extra object for %s, bypassing the cache.', principalId);
                // return to avoid caching an incomplete object
                return;
            }
        }

        // Store it in redis
        Redis.getClient().hmset(principalId, hash);
    });
};

/**
 * Get a user from Redis. If the user can't be found an error object with code 404 will be returned.
 *
 * @param  {String}     userId              The ID of the user that should be retrieved.
 * @param  {Function}   callback            A callback method.
 * @param  {Object}     callback.err        Standard error object. If the user could not be found, a 404 code will be used.
 * @param  {User}       callback.principal  The asked for user (or null).
 * @api private
 */
var getUserFromRedis = function(userId, callback) {
    Redis.getClient().hgetall(userId, function(err, hash) {
        if (err) {
            return callback({'code': 500, 'msg': err});
        } else if (!hash) {
            return callback({'code': 404, 'msg': 'Principal not found in redis'});
        }

        // We don't need to do validation as that has already happened.
        hash.isGlobalAdmin = (hash.isGlobalAdmin === 'true');
        hash.isTenantAdmin = (hash.isTenantAdmin === 'true');
        hash.principalId = userId;

        var user = hashToUser(hash);

        // Any potential extra fields.
        if (hash.extra) {
            try {
                user.extra = JSON.parse(hash.extra);
            } catch (err) {
                log().error({'err': err}, 'Failed to parse the stringified extra object for %s', userId);
            }
        }

        return callback(null, user);
    });
};


/**
 * Creates a User or Group from a cassandra row.
 *
 * @param  {Row}        row     Cassandra Row
 * @return {User|Group}         A user or group object.
 * @api private
 */
var getPrincipalFromRow = function(row) {
    if (row.count <= 1) {
        return null;
    }

    return isGroup(row.get('principalId').value) ? getGroupFromRow(row) : getUserFromRow(row);
};

/**
 * Creates a Group from a Cassandra row.
 *
 * @param  {Row}    row     Cassandra Row
 * @return {Group}          A group object.
 * @api private
 */
var getGroupFromRow = function(row) {
    var hash = Cassandra.rowToHash(row);
    return new Group(hash.tenantAlias, hash.principalId, hash.alias, hash);
};

/**
 * Creates a User from a Cassandra row.
 *
 * @param  {Row}    row     Cassandra Row
 * @return {User}           A User object.
 * @api private
 */
var getUserFromRow = function(row) {
    var hash = Cassandra.rowToHash(row);
    hash.isGlobalAdmin = (row.get('admin:global') && sanitize(row.get('admin:global').value).toBooleanStrict());
    hash.isTenantAdmin = (row.get('admin:tenant') && sanitize(row.get('admin:tenant').value).toBooleanStrict());

    return hashToUser(hash);
};

/**
 * Creates a User from a hash.
 *
 * @param  {Object} hash Hash that has the required keys and values.
 * @return {User}        A User object.
 */
var hashToUser = module.exports.hashToUser = function(hash) {
    // Ensure that the timezone we're setting is something the app can deal with.
    var timezone = hash.timezone;
    try {
        var date = new TZ.Date(null, timezone);
        if (!date.getTimezone()) {
            throw new Error();
        }
    } catch (err) {
        // We can't deal with this timezone.
        // default to UTC
        timezone = 'Etc/UTC';
    }

    var user = new User(hash.tenantAlias, hash.principalId, hash.displayName, {
        'visibility': hash.visibility,
        'locale': hash.locale,
        'timezone': timezone,
        'publicAlias': hash.publicAlias,
        'isGlobalAdmin': hash.isGlobalAdmin,
        'isTenantAdmin': hash.isTenantAdmin,
        'smallPictureUri': hash.smallPictureUri,
        'mediumPictureUri': hash.mediumPictureUri,
        'largePictureUri': hash.largePictureUri
    });

    // The hash might contain extra data we wish to pass back. Anything that isn't recognized as a top-level user
    // field, extract it out into an 'extra' object.
    var blacklist = ['id', 'principalId', 'resourceType', 'tenantAlias', 'displayName', 'visibility', 'locale',
                     'smallPictureUri', 'mediumPictureUri', 'largePictureUri',
                     'profilePath', 'timezone', 'publicAlias', 'extra', 'admin:global', 'admin:tenant'];
    _.each(hash, function(value, key) {
        if (!_.contains(blacklist, key) && !_.isFunction(user[key])) {
            user.extra = user.extra || {};
            user.extra[key] = value;
        }
    });
    return user;
};

/**
 * Invalidates a user in the cache.
 *
 * @param {String}      userId          The ID of the user you wish to invalidate.
 * @param {Function}    callback        Callback method
 * @param {Object}      callback.err    An error object
 */
var invalidateCachedUser = module.exports.invalidateCachedUser = function(userId, callback) {
    Redis.getClient().del(userId, callback);
};
