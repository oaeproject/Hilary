/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');

var RestAPI = require('oae-rest');
var TestsUtil = require('oae-tests');

var ActivityTestUtil = require('oae-activity/lib/test/util');

describe('Activity push', function() {

    // Rest context that can be used every time we need to make a request as a tenant admin
    var camAdminRestContext = null;

    /**
     * Function that will fill up the tenant admin and anymous rest context
     */
    before(function(callback) {
        camAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.cam.host);
        return callback();
    });

    describe('Protocol', function() {

        /**
         * Test that verifies that messages that are sent by a client need to have an ID
         */
        it('verify missing id results in an immediate disconnect', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, mrvisser) {
                RestAPI.User.getMe(mrvisser.restContext, function(err, meData) {
                    assert.ok(!err);

                    var data = {
                        'authentication': {
                            'userId': meData.id,
                            'tenantAlias': meData.tenant.alias,
                            'signature': meData.signature
                        }
                    };
                    ActivityTestUtil.getFullySetupPushClient(data, function(client) {
                        var socket = client.getRawSocket();

                        var receivedMessages = 0;

                        // The socket should close
                        client.on('close', function() {
                            // We need to have received a message first
                            assert.equal(receivedMessages, 1);
                            callback();
                        });

                        client.on('message', function(message) {
                            // Ensure we only get one message
                            assert.strictEqual(receivedMessages, 0);
                            assert.equal(message.error.code, 400);
                            receivedMessages++;
                        });

                        // Send a message that contains no ID
                        socket.write('{}');
                    });
                });
            });
        });

        /**
         * Test that verifies that non JSON messages get rejected
         */
        it('verify a malformed message results in an immediate disconnect', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, mrvisser) {
                RestAPI.User.getMe(mrvisser.restContext, function(err, meData) {
                    assert.ok(!err);

                    var data = {
                        'authentication': {
                            'userId': meData.id,
                            'tenantAlias': meData.tenant.alias,
                            'signature': meData.signature
                        }
                    };
                    ActivityTestUtil.getFullySetupPushClient(data, function(client) {
                        var socket = client.getRawSocket();

                        var receivedMessages = 0;

                        // The socket should close because we're not authenticated
                        client.on('close', function() {
                            // We need to have received a message first
                            assert.equal(receivedMessages, 1);
                            callback();
                        });

                        client.on('message', function(message) {
                            // Ensure we only get one message
                            assert.strictEqual(receivedMessages, 0);
                            assert.equal(message.error.code, 400);
                            receivedMessages++;
                        });

                        // Send a malformed message
                        socket.write('NO JSON');
                    });
                });
            });
        });

        /**
         * Test that verifies the sockets gets closed when the client does not provide their authentication credentials within a reasonable timeframe
         */
        it('verify authentication timeout', function(callback) {
            ActivityTestUtil.getPushClient(function(client) {
                client.on('close', function() {
                    return callback();
                });
            });
        });
    });

    describe('Authentication', function() {

        /**
         * Test that verifies that the very first frame that gets sent has to be an authentication frame
         */
        it('verify no authentication frame results in a disconnect', function(callback) {
            ActivityTestUtil.getPushClient(function(client) {
                client.sendMessage('foo', {}, function(err, msg) {
                    assert.ok(err);
                    assert.equal(err.code, 401);
                });

                var timeoutID = setTimeout(function() {
                    assert.fail('Expected the socket to be closed by now');
                }, 7000);

                client.on('close', function() {
                    clearTimeout(timeoutID);
                    callback();
                });
            });
        });

        /**
         * Test that verifies that an invalid user id results in an error
         */
        it('verify an invalid user id results in a error', function(callback) {
            ActivityTestUtil.getPushClient(function(client) {

                var receivedResponse = false;

                // Sending an invalid authentication frame should fail
                client.sendMessage('authentication', {'userId': 'not-a-user-id', 'signature': {}}, function(err, data) {
                    assert.equal(err.code, 400);
                    receivedResponse = true;
                });

                client.on('close', function() {
                    assert.ok(receivedResponse, 'Expected to receive a message before closing the socket');
                    callback();
                });
            });
        });

        /**
         * Test that verifies that an invalid signature results in an error
         */
        it('verify a missing signature results in a error', function(callback) {
            ActivityTestUtil.getPushClient(function(client) {

                var receivedResponse = false;

                // Sending an invalid authentication frame should fail
                client.sendMessage('authentication', {'userId': 'u:camtest:foobar'}, function(err, data) {
                    assert.equal(err.code, 400);
                    receivedResponse = true;
                });

                client.on('close', function() {
                    assert.ok(receivedResponse, 'Expected to receive a message before closing the socket');
                    callback();
                });
            });
        });

        /**
         * Test that verifies that clients can authenticate themselves on the socket
         */
        it('verify authentication', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, mrvisser) {
                RestAPI.User.getMe(mrvisser.restContext, function(err, meData) {
                    assert.ok(!err);

                    ActivityTestUtil.getPushClient(function(client) {
                        // The first message should always be the authentication message
                        // If not, the backend should close the socket.
                        client.authenticate(meData.id, meData.tenant.alias, meData.signature, function(err, data) {
                            assert.ok(!err);
                            client.close(callback);
                        });
                    });
                });
            });
        });
    });

    describe('Subscribing', function() {

        /**
         * Test that verifies the subscription validation
         */
        it('verify validation', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, mrvisser) {

                RestAPI.User.getMe(mrvisser.restContext, function(err, mrvisserMeData) {
                    assert.ok(!err);

                    var data = {
                        'authentication': {
                            'userId': mrvisserMeData.id,
                            'tenantAlias': mrvisserMeData.tenant.alias,
                            'signature': mrvisserMeData.signature
                        }
                    };
                    ActivityTestUtil.getFullySetupPushClient(data, function(client) {

                        // Registering on an unknown feed should result in an error
                        client.subscribe(mrvisser.user.id, 'unknown', {'some': 'token'}, null, function(err, msg) {
                            assert.equal(err.code, 400);

                            // Specifying an unknown format should result in a validation error
                            client.subscribe(mrvisser.user.id, 'activity', {'some': 'token'}, 'unknown format', function(err, msg) {
                                assert.equal(err.code, 400);

                                client.close(callback);
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies subscribing and authorization on activity streams
         */
        it('verify subscribing and authorization on activity streams', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, mrvisser, simon) {

                RestAPI.User.getMe(mrvisser.restContext, function(err, mrvisserMeData) {
                    assert.ok(!err);

                    var data = {
                        'authentication': {
                            'userId': mrvisserMeData.id,
                            'tenantAlias': mrvisserMeData.tenant.alias,
                            'signature': mrvisserMeData.signature
                        }
                    };
                    ActivityTestUtil.getFullySetupPushClient(data, function(client) {

                        // Mrvisser cannot subscribe on Simon's feed
                        client.subscribe(simon.user.id, 'activity', mrvisserMeData.signature, null, function(err, msg) {
                            assert.equal(err.code, 401);

                            // He can register for his own feed without a token since he's authenticated on the socket
                            client.subscribe(mrvisser.user.id, 'activity', null, null, function(err, msg) {
                                assert.ok(!err);

                                // He can register on a group feed
                                RestAPI.Group.createGroup(mrvisser.restContext, 'Group title', 'Group description', 'public', 'yes', [], [], function(err, group) {
                                    assert.ok(!err);
                                    RestAPI.Group.getGroup(mrvisser.restContext, group.id, function(err, group) {
                                        assert.ok(!err);
                                        client.subscribe(group.id, 'activity', group.signature, null, function(err, msg) {
                                            assert.ok(!err);

                                            client.close(callback);
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies subscribing and authorization on notification streams
         */
        it('verify subscribing and authorization on notification streams', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, mrvisser, simon) {

                RestAPI.User.getMe(mrvisser.restContext, function(err, mrvisserMeData) {
                    assert.ok(!err);

                    var data = {
                        'authentication': {
                            'userId': mrvisserMeData.id,
                            'tenantAlias': mrvisserMeData.tenant.alias,
                            'signature': mrvisserMeData.signature
                        }
                    };
                    ActivityTestUtil.getFullySetupPushClient(data, function(client) {

                        // Mrvisser cannot subscribe on Simon's feed
                        client.subscribe(simon.user.id, 'notification', mrvisserMeData.signature, null, function(err, msg) {
                            assert.equal(err.code, 401);

                            // Groups don't have notification feeds
                            RestAPI.Group.createGroup(mrvisser.restContext, 'Group title', 'Group description', 'public', 'yes', [], [], function(err, group) {
                                assert.ok(!err);
                                RestAPI.Group.getGroup(mrvisser.restContext, group.id, function(err, group) {
                                    assert.ok(!err);
                                    client.subscribe(group.id, 'notification', group.signature, null, function(err, msg) {
                                        assert.equal(err.code, 400);

                                        // He can register for his own feed without a token since he's authenticated on the socket
                                        client.subscribe(mrvisser.user.id, 'notification', null, null, function(err, msg) {
                                            assert.ok(!err);

                                            client.close(callback);
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that you only get activities that occur on the subscribed resources
         */
        it('verify segregation', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, mrvisser) {

                RestAPI.User.getMe(mrvisser.restContext, function(err, mrvisserMeData) {
                    assert.ok(!err);

                    RestAPI.Content.createLink(mrvisser.restContext, 'Yahoo', 'Yahoo', 'public', 'http://www.yahoo.ca', [], [], [], function(err, yahooLink) {
                        assert.ok(!err);
                        RestAPI.Content.getContent(mrvisser.restContext, yahooLink.id, function(err, yahooLink) {
                            assert.ok(!err);
                            RestAPI.Content.createLink(mrvisser.restContext, 'Google', 'Google', 'public', 'http://www.google.ca', [], [], [], function(err, googleLink) {
                                assert.ok(!err);
                                RestAPI.Content.getContent(mrvisser.restContext, googleLink.id, function(err, googleLink) {
                                    assert.ok(!err);

                                    // Route and deliver activities
                                    ActivityTestUtil.collectAndGetActivityStream(mrvisser.restContext, null, null, function(err) {
                                        assert.ok(!err);

                                        // Subscribe on the Yahoo link
                                        var data = {
                                            'authentication': {
                                                'userId': mrvisserMeData.id,
                                                'tenantAlias': mrvisserMeData.tenant.alias,
                                                'signature': mrvisserMeData.signature
                                            },
                                            'streams': [{'resourceId': yahooLink.id, 'streamType': 'activity', 'token': yahooLink.signature}]
                                        };
                                        ActivityTestUtil.getFullySetupPushClient(data, function(client) {
                                            client.on('message', function(message) {
                                                if (message) {
                                                    assert.fail('No activities should be pushed to this stream as nothing happened on the "yahoo" link');
                                                }
                                            });

                                            // Trigger an update on the google item, we should not get an activity on the websocket for that content item
                                            RestAPI.Content.updateContent(mrvisser.restContext, googleLink.id, {'displayName': 'Google woo'}, function(err) {
                                                assert.ok(!err);

                                                // Route and deliver activities
                                                ActivityTestUtil.collectAndGetActivityStream(mrvisser.restContext, null, null, function(err) {
                                                    assert.ok(!err);

                                                    client.close(callback);
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that multiple clients can listen on the same feed
         */
        it('verify multiple clients on same feed', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, mrvisser) {

                RestAPI.User.getMe(mrvisser.restContext, function(err, mrvisserMeData) {
                    assert.ok(!err);

                    // Get 2 clients
                    var data = {
                        'authentication': {
                            'userId': mrvisserMeData.id,
                            'tenantAlias': mrvisserMeData.tenant.alias,
                            'signature': mrvisserMeData.signature
                        },
                        'streams': [
                            {
                                'resourceId': mrvisserMeData.id,
                                'streamType': 'activity',
                                'token': mrvisserMeData.signature
                            },
                            {
                                'resourceId': mrvisserMeData.id,
                                'streamType': 'notification',
                                'token': mrvisserMeData.signature
                            }
                        ]
                    };
                    ActivityTestUtil.collectAndGetActivityStream(mrvisser.restContext, null, null, function(err) {
                        assert.ok(!err);

                        // Setup the clients
                        ActivityTestUtil.getFullySetupPushClient(data, function(clientA) {
                            ActivityTestUtil.getFullySetupPushClient(data, function(clientB) {

                                // Do something that ends up in the `activity`  activitystream
                                RestAPI.Content.createLink(mrvisser.restContext, 'Yahoo', 'Yahoo', 'public', 'http://www.yahoo.ca', [], [], [], function(err, link) {
                                    assert.ok(!err);
                                });

                                var clientAReceived = false;
                                var clientBReceived = false;

                                clientA.once('message', function(message) {
                                    assert.ok(!message.error);
                                    clientAReceived = true;
                                    if (clientAReceived && clientBReceived) {
                                        bothReceived();
                                    }

                                });
                                clientB.once('message', function(message) {
                                    assert.ok(!message.error);
                                    clientBReceived = true;
                                    if (clientAReceived && clientBReceived) {
                                        bothReceived();
                                    }
                                });

                                /**
                                 * Gets executed when both client A and B have received their message
                                 */
                                var bothReceived = function() {

                                    // If we close client B, only A should receive a message
                                    clientB.close(function() {

                                        clientB.on('message', function() {
                                            assert.fail('The socket on client B has been closed, this socket should not receive any more messages');
                                        });

                                        // Do something that ends up in the `activity`  activitystream
                                        RestAPI.Content.createLink(mrvisser.restContext, 'Yahoo', 'Yahoo', 'public', 'http://www.yahoo.ca', [], [], [], function(err, link) {
                                            assert.ok(!err);
                                        });

                                        clientA.once('message', function(message) {
                                            assert.ok(!message.error);
                                            clientA.close(callback);
                                        });
                                    });
                                };
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that the format for activity entities can be specified
         */
        it('verify the activity entities format can be specified', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, mrvisser, simong) {

                RestAPI.User.getMe(mrvisser.restContext, function(err, mrvisserMeData) {
                    assert.ok(!err);

                    // Register a push client for mrvisser who is subscribed to his activitystream with the regular format and his notification stream with the internal format
                    var data = {
                        'authentication': {
                            'userId': mrvisserMeData.id,
                            'tenantAlias': mrvisserMeData.tenant.alias,
                            'signature': mrvisserMeData.signature
                        },
                        'streams': [
                            {
                                'resourceId': mrvisserMeData.id,
                                'streamType': 'activity',
                                'token': mrvisserMeData.signature,
                                'format': 'activitystreams'
                            },
                            {
                                'resourceId': mrvisserMeData.id,
                                'streamType': 'notification',
                                'token': mrvisserMeData.signature,
                                'format': 'internal'
                            }
                        ]
                    };

                    // Setup the client
                    ActivityTestUtil.getFullySetupPushClient(data, function(client) {

                        // Simon will now create a discussion and share it with mrvisser, this will trigger an activity that gets delivered on both streams
                        // To ensure proper scrubbing of data, simon will have a private profile
                        RestAPI.User.updateUser(simong.restContext, simong.user.id, {'visibility': 'private'}, function(err, updatedUser) {
                            assert.ok(!err);
                            simong.user = updatedUser;
                            var discussion = null;

                            RestAPI.Discussions.createDiscussion(simong.restContext, 'Test discussion', 'Test discussion description', 'public', [], [mrvisser.user.id], function(err, _discussion) {
                                assert.ok(!err);
                                discussion = _discussion;
                            });

                            var activitiesReceived = 0;
                            client.on('message', function(message) {
                                activitiesReceived++;

                                var activity = message.activity;
                                assert.ok(activity);

                                var allowedActorProperties = null;
                                var allowedObjectProperties = null;

                                if (message.streamType === 'notification') {
                                    // Assert that the activity entities are internally formatted
                                    assert.equal(message.format, 'internal');

                                    // Assert that the actor entity is a user object augmented with an oae:id and objectType
                                    assert.ok(activity.actor);
                                    assert.equal(activity.actor['oae:id'], simong.user.id);
                                    assert.equal(activity.actor['id'], simong.user.id);
                                    assert.equal(activity.actor['displayName'], simong.user.publicAlias);
                                    assert.equal(activity.actor['lastModified'], simong.user.lastModified);
                                    assert.equal(activity.actor['visibility'], 'private');
                                    assert.ok(_.isObject(activity.actor['picture']));
                                    assert.equal(activity.actor['resourceType'], 'user');
                                    assert.equal(activity.actor['objectType'], 'user');
                                    assert.ok(_.isObject(activity.actor['tenant']));

                                    // Ensure only these properties are present
                                    allowedActorProperties = ['oae:id', 'id', 'displayName', 'visibility', 'picture', 'resourceType', 'objectType', 'tenant', 'lastModified'];
                                    _.each(activity.actor, function(value, key) {
                                        assert.ok(_.contains(allowedActorProperties, key) , key + ' is not allowed on an internally formatted activity entity');
                                    });


                                    // Assert that the object entity is a discussion object augmented with an oae:id and objectType
                                    assert.ok(activity.object);
                                    assert.equal(activity.object['oae:id'], discussion.id);
                                    assert.equal(activity.object['id'], discussion.id);
                                    assert.equal(activity.object['visibility'], discussion.visibility);
                                    assert.equal(activity.object['displayName'], discussion.displayName);
                                    assert.equal(activity.object['description'], discussion.description);
                                    assert.equal(activity.object['createdBy'], discussion.createdBy);
                                    assert.equal(activity.object['created'], discussion.created);
                                    assert.equal(activity.object['lastModified'], discussion.lastModified);
                                    assert.equal(activity.object['profilePath'], discussion.profilePath);
                                    assert.equal(activity.object['resourceType'], discussion.resourceType);
                                    assert.equal(activity.object['objectType'], 'discussion');
                                    assert.ok(_.isObject(activity.object['tenant']));

                                    allowedObjectProperties = [ 'tenant', 'id', 'visibility', 'displayName', 'description', 'resourceSubType', 'createdBy', 'created', 'lastModified', 'profilePath', 'resourceType', 'latestRevisionId', 'previews', 'signature', 'objectType', 'oae:id' ];
                                    _.each(activity.object, function(value, key) {
                                        assert.ok(_.contains(allowedObjectProperties, key) , key + ' is not allowed on an internally formatted activity entity');
                                    });
                                } else {
                                    // Assert that the activity entities are activitystrea.ms formatted
                                    assert.equal(message.format, 'activitystreams');

                                    // Assert that the actor entity is in the proper activitystreams format
                                    assert.ok(activity.actor);
                                    assert.equal(activity.actor['oae:id'], simong.user.id);
                                    assert.equal(activity.actor['oae:visibility'], simong.user.visibility);
                                    assert.equal(activity.actor['displayName'], simong.user.publicAlias);
                                    assert.equal(activity.actor['objectType'], 'user');
                                    assert.equal(activity.actor['id'], 'http://' + global.oaeTests.tenants.cam.host + '/api/user/' + simong.user.id);
                                    assert.ok(_.isObject(activity.actor['oae:tenant']));

                                    allowedActorProperties = ['oae:id', 'oae:visibility', 'displayName', 'objectType', 'id', 'oae:tenant'];
                                    _.each(activity.actor, function(value, key) {
                                        assert.ok(_.contains(allowedActorProperties, key) , key + ' is not allowed on an ActivityStrea.ms compliant formatted activity entity');
                                    });

                                    // Assert that the object entity is in the proper activitystreams format
                                    assert.ok(activity.object);
                                    assert.equal(activity.object['oae:id'], discussion.id);
                                    assert.equal(activity.object['oae:visibility'], discussion.visibility);
                                    assert.equal(activity.object['oae:profilePath'], discussion.profilePath);
                                    assert.equal(activity.object['oae:resourceSubType'], discussion.resourceSubType);
                                    assert.equal(activity.object['displayName'], discussion.displayName);
                                    assert.equal(activity.object['url'], 'http://' + global.oaeTests.tenants.cam.host + '/discussion/camtest/' + discussion.id.split(':')[2]);
                                    assert.equal(activity.object['objectType'], 'discussion');
                                    assert.equal(activity.object['id'], 'http://' + global.oaeTests.tenants.cam.host + '/api/discussion/' + discussion.id);
                                    assert.ok(_.isObject(activity.object['oae:tenant']));

                                    allowedObjectProperties = [ 'oae:id', 'oae:visibility', 'oae:profilePath', 'displayName', 'url', 'objectType', 'id', 'oae:tenant' ];
                                    _.each(activity.object, function(value, key) {
                                        assert.ok(_.contains(allowedObjectProperties, key) , key + ' is not allowed on an ActivityStrea.ms compliant formatted activity entity');
                                    });
                                }

                                if (activitiesReceived === 2) {
                                    return callback();
                                }
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies a socket can subscribe for the same activity stream twice but with a different format
         */
        it('verify a subscription can be made to the same activity stream with a different format', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, mrvisser, simong) {

                RestAPI.User.getMe(mrvisser.restContext, function(err, mrvisserMeData) {
                    assert.ok(!err);

                    /*
                     * Register a push client for mrvisser who is subscribed to:
                     *  * `activity`-stream with the `activitystream` format
                     *  * `activity`-stream with the `internal` format
                     *  * `notification`-stream with the `internal` format
                     */
                    var data = {
                        'authentication': {
                            'userId': mrvisserMeData.id,
                            'tenantAlias': mrvisserMeData.tenant.alias,
                            'signature': mrvisserMeData.signature
                        },
                        'streams': [
                            {
                                'resourceId': mrvisserMeData.id,
                                'streamType': 'activity',
                                'token': mrvisserMeData.signature,
                                'format': 'activitystreams'
                            },
                            {
                                'resourceId': mrvisserMeData.id,
                                'streamType': 'activity',
                                'token': mrvisserMeData.signature,
                                'format': 'internal'
                            },
                            {
                                'resourceId': mrvisserMeData.id,
                                'streamType': 'notification',
                                'token': mrvisserMeData.signature,
                                'format': 'internal'
                            }
                        ]
                    };

                    // Setup the client
                    ActivityTestUtil.getFullySetupPushClient(data, function(client) {

                        // Create/share a discussion with mrvisser
                        RestAPI.Discussions.createDiscussion(simong.restContext, 'Test discussion', 'Test discussion description', 'public', [], [mrvisser.user.id], function(err, discussion) {
                            assert.ok(!err);
                        });

                        var activitiesReceived = 0;
                        var formatReceived = {
                            'internal': 0,
                            'activitystreams': 0
                        };
                        client.on('message', function(message) {

                            activitiesReceived++;
                            formatReceived[message.format]++;

                            if (activitiesReceived === 3) {
                                assert.strictEqual(formatReceived['internal'], 2);
                                assert.strictEqual(formatReceived['activitystreams'], 1);

                                return callback();
                            }
                        });
                    });
                });
            });
        });
    });
});
