/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var Crypto = require('crypto');
var fs = require('fs');

var log = require('oae-logger').logger('signature');

var Validator = require('oae-util/lib/validator').Validator;


var privKey = null;
var pubKey = null;

/**
 * Read the key files.
 */
var init = module.exports.init = function() {
    privKey = fs.readFileSync('key.pem').toString('ascii');
    pubKey = fs.readFileSync('key.pub').toString('ascii');

    var defaultKey = "MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAJzVDZcFhH64XcGy9neYgOsGNpojBxxg\nrJaUSr0cyl4PcWrVwWL6UtWZGiycnqbK49wCakMYdxFZm2T0mxCQw30CAwEAAQ==";


    // Complain very loud if the keys have not been changed.
    if (pubKey.indexOf(defaultKey) !== -1) {
        // TODO: This will most likely end-up in bootstrap.log, which might be overlooked, console.log?
        var warningMessage = 'You are using the default keys to sign URLs, this is *NOT* secure and should be changed immediately.\n';
        warningMessage += 'The system will continue to function, but it is strongly recommended that you change your keys.\n';
        warningMessage += 'If you have OpenSSL installed you can generate a key by running:\n';
        warningMessage += '  openssl genrsa -out key.pem 1024\n';
        warningMessage += '  openssl rsa -in mykey.pem -pubout > key.pub\n'
        warningMessage += 'Make sure that each app server has the same set of keys though.'
        log().warn(warningMessage);
    }
};

/**
 * Sign a string with our private key.
 *
 * @param  {String}  body    The string to sign.
 * @return {String}          A signature.
 */
var sign = module.exports.sign = function(body) {
    var signer = Crypto.createSign('RSA-SHA256');
    signer.update(body);
    return signer.sign(privKey, 'hex');
};

/**
 * Verify that the passed in signature matches the body.
 *
 * @param  {String} body      The body that was originally signed.
 * @param  {String} signature The signature that was passed in by the user.
 * @return {Boolean}          Whether or not the body was untampered with
 */
var verify = module.exports.verify = function(body, signature) {
    var verifier = Crypto.createVerify('RSA-SHA256');
    verifier.update(body);
    return verifier.verify(pubKey, signature, 'hex')
};

/**
 * Creates a signature that is valid for `expires` amount of minutes.
 *
 * @param  {String} body    The body that needs signing
 * @param  {Number} expires The number of minutes this signature is valid.
 * @return {Object}         An object with a `signature` key that holds the signature and a `expires` key which holds the timestamp when the signature will expire.
 */
var createExpiringSignature = module.exports.createExpiringSignature = function(body, expires) {
    var expires = Date.now() + (expires * 60000);
    body += '#' + expires;
    var signature = sign(body);
    return {
        'signature': signature,
        'expires' : expires
    }
};

/**
 * Verifies if the signature matches a given body.
 *
 * The `expires` value will be taken into account and checked against the current time.
 * @param  {String} body      The body that the signature was placed on.
 * @param  {String} signature The signature as generated by `createExpiringSignature`.
 * @param  {Number} expires   A timestamp in ms when this signature expires.
 * @return {Boolean}          Whether or not the signature is valid.
 */
var verifyExperingSignature = module.exports.verifyExperingSignature = function(body, signature, expires) {
    // Check the expiry date.
    if (Date.now() > expires) {
        return false;
    }

    // Check the signature.
    body += '#' + expires;
    return verify(body, signature);
};

/**
 * Check whether or not a signature is valid.
 *
 * @param  {String} body   The body that was used to generate the signature.
 * @see verify
 */
Validator.prototype.verifySignature = function(body) {
    if (!this.str || !verify(body, this.str)) {
        this.error(this.msg || 'Invalid signature');
    }
    return this;
};

/**
 * Check whether or not an expiring signature is valid.
 *
 * @param  {String} body    The body that was used to generate the signature.
 * @param  {Number} expires The timestamp in ms when the signature expires.
 * @see verifyExperingSignature
 */
Validator.prototype.verifyExperingSignature = function(body, expires) {
    if (!this.str || !verifyExperingSignature(body, this.str, expires)) {
        this.error(this.msg || 'Invalid signature');
    }
    return this;
};
