/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var Cassandra = require('oae-util/lib/cassandra');
var OAE = require('oae-util/lib/oae');
var PrincipalsUtil = require('oae-principals/lib/util');
var Shortid = require('shortid');
var Validator = require('oae-util/lib/validator').Validator;
var _ = require('underscore');

/**
 * A function that delets a specific annotation
 * 
 * @param  {Context}        ctx             Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         revisionID      The revision id of the document the notations are to be placed upon.
 * @param  {String}         annotationID    The id of the annotation that is to be deleted.
 * @param  {Function}       callback        Standard callback function takes arguments 'err'
 * @param  {Object}         callback.err    Standard error object.
 */
var deleteAnnotation = module.exports.deleteAnnotation = function(ctx, revisionId, annotationId, callback){
    var validator = new Validator();
    validator.check(revisionId, {'code': 401, 'msg': 'Need a valid revisionId'}).isResourceId();
    validator.check(annotationId, {'code': 401, 'msg': 'Need a valid annotationId'}).isShortString();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can delete an annotation'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    Cassandra.runQuery('DELETE ? FROM Annotations WHERE revisionId = ? ',[annotationId, revisionId],function(err){
        if (err) {
            return callback(err);
        }
        return callback();
    });
};

/**
 * A function that updates a specific annotation
 * 
 * @param  {Context}        ctx             Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         revisionID      The revision id of the document the notations are to be placed upon.
 * @param  {String}         page            The page number on wich the annotation wich is to be updated is located.
 * @param  {String}         annotationID    The id of the annotation that is to be deleted.
 * @param  {Object}         Data            The data wich is to be used to replace the annotation.
 * @param  {Function}       callback        Standard callback function takes arguments 'err' and 'data'.
 * @param  {Object}         callback.err    Standard error object.
 * @param  {Sting}          callback.data   A string that represents the location of the annotation
 */
var updateAnnotation = module.exports.updateAnnotation = function(ctx, revisionId, page, annotationId, data, callback){
    var validator = new Validator();
    validator.check(revisionId, {'code': 401, 'msg': 'Need a valid revisionId'}).isResourceId();
    validator.check(page, {'code': 401, 'msg': 'Need a valid page number'}).isShortString();
    validator.check(annotationId, {'code': 401, 'msg': 'Need a valid annotationId'}).isShortString();
    validator.check(null, {'code': 401, 'msg': 'You must supply annotation data'}).isObject(data);
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can delete an annotation'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    // The annotator does not send along the ID in its object so we need to re-append that
    data.id = annotationId;
    data.userId = ctx.user().id;
    Cassandra.runQuery('UPDATE Annotations SET ? = ? WHERE revisionId = ? ',[annotationId, JSON.stringify(data), revisionId],function(err){
        if (err) {
            return callback(err);
        }
        // Annotator asks for a 303 with a link to the location of the annotation
        return callback();
    });  
    
};

/**
 * A function that creates an annotation
 * 
 * @param  {Context}        ctx             Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         revisionID      The revision id of the document the notations are to be placed upon.
 * @param  {String}         page            The page number on wich the annotation wich is to be created is located.
 * @param  {Object}         Data            The data wich is to be used to create the annotation.
 * @param  {Function}       callback        Standard callback function takes arguments 'err' and 'data'.
 * @param  {Object}         callback.err    Standard error object.
 * @param  {Sting}          callback.data   A string that represents the location of the annotation
 */
var createAnnotation = module.exports.createAnnotation = function(ctx, revisionId, page, data, callback){
    var validator = new Validator();
    validator.check(revisionId, {'code': 401, 'msg': 'Need a valid revisionId'}).isResourceId();
    validator.check(page, {'code': 401, 'msg': 'Need a valid page number'}).isShortString();
    validator.check(null, {'code': 401, 'msg': 'You must supply annotation data'}).isObject(data);
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can delete an annotation'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    // Generate the newId and append it to the data we already have
    data.id = page + '_' + Shortid.generate();
    data.userId = ctx.user().id;
    Cassandra.runQuery('UPDATE Annotations SET ? = ? WHERE revisionId = ?', [data.id, JSON.stringify(data), revisionId], function(err){
        if (err) {
            return callback(err);
        }
        // Annotator asks for a 303 with a link to the location of the annotation
        return callback(null, data);
    });
};

/**
 * A function that gets a specific annotation
 * 
 * @param  {Context}        ctx             Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         revisionID      The revision id of the document the notations are to be placed upon.
 * @param  {String}         annotationID    The id of the annotation that is to be returned.
 * @param  {Function}       callback        Standard callback function takes arguments 'err' and 'data'.
 * @param  {Object}         callback.err    Standard error object.
 * @param  {Object}         callback.data   A Json object containing the annotation.
 */
var getAnnotation = module.exports.getAnnotation = function(ctx, revisionId, annotationId, callback){
    var validator = new Validator();
    validator.check(revisionId, {'code': 401, 'msg': 'Need a valid revisionId'}).isResourceId();
    validator.check(annotationId, {'code': 401, 'msg': 'Need a valid annotationId'}).isShortString();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can delete an annotation'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    Cassandra.runQuery('SELECT ? FROM Annotations WHERE revisionId = ?', [annotationId, revisionId], function(err, rows){
        if (err) {
            return callback(err);
        }
        // We need to clean up the response from cassandra a bit
        var data = JSON.parse(rows[0].get(annotationId).value);
        PrincipalsUtil.getPrincipal(ctx, data.userId, function(err, user){
           if (err){
               return callback(err);
           }
           data.createdBy=user.createdBy;
           return callback(null, data)
        });
    });
};

/**
 * A function that gets a all annotations on a page
 * 
 * @param  {Context}        ctx             Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         revisionID      The revision id of the document the notations are to be placed upon.
 * @param  {String}         page            The page number of the annotations that are to be returned.
 * @param  {Function}       callback        Standard callback function takes arguments 'err' and 'data'.
 * @param  {Object}         callback.err    Standard error object.
 * @param  {Object}         callback.data   A Json object containing all the annotations.
 */
var getAnnotations = module.exports.getAnnotations = function(ctx, revisionId, page, callback){
    var validator = new Validator();
    validator.check(revisionId, {'code': 401, 'msg': 'Need a valid revisionId'}).isResourceId();
    validator.check(page, {'code': 401, 'msg': 'Need a valid page number'}).isShortString();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can delete an annotation'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    // Create a int holding the page number so we can manipulate it numericly
    page = parseInt(page, 10);
    var nextPage = page+1;
    /**
     * Query cassandra for all the annotations that are on the page. By
     * asking it to return all the annotations who's id begins with 
     * the current page.
     */ 
    Cassandra.runQuery('SELECT ? .. ? FROM Annotations WHERE revisionId = ?', [page.toString() + '_', nextPage.toString() + '_', revisionId], function(err, rows){
        if (err) {
            return callback(err);
        }
        /**
         * Cassasandra gives a object wich is not completly compatible with 
         * annotator so we need to clean it up a bit.
         */
        _parseJson(rows[0], ctx, function(err, data) {
        return callback(null, data);
        });
    });
};



/**
 * Strip the un needed information from a string before creating a JSON object from it.
 * 
 * @param  {Object}         Data                    The data wich needs to be cleaned and parsed to JSON.
 * @param  {Context}        ctx                     Standard context object, representing the currently logged in user and its tenant.
 * @param  {Function}       callback                Standard callback function takes arguments 'err' and 'parsedData'.
 * @param  {Object}         callback.err            Standard error object.
 * @param  {Object}         callback.parsedData     A Json object containing all the parsed annotations.
 */
var _parseJson = function(data, ctx, callback) {
    var userIds = {};
    var parsedData = [];
    _.each(data, function(item) {
        var value = JSON.parse(item.value);
        userIds[value.userId] = 1;
        parsedData.push(value);
    });
    
    // Call getPrincipals to get all the required data.
    PrincipalsUtil.getPrincipals(ctx, _.keys(userIds), function(err, users) {
        if (err){
            return callback(err);
        }
        
        // Map each user object into its id
        var userObjects = {};
        _.each(users, function(user) {
            userObjects[user.id] = user;
        });
        
        // This loop Assigns the pared items to parsedData
        _.each(parsedData, function(item) {
            item.createdBy = userObjects[item.userId];
        });
        
        return callback(null, parsedData);
    });
}
