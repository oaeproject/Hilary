/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var time = require('time');
var sanitize = require('validator').sanitize;
var time = require('time');
var ShortId = require('shortid');

var AuthzAPI = require('oae-authz');
var Resource = require('oae-authz/lib/model').Resource;
var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var Validator = require('oae-principals/lib/validator').Validator;

var PrincipalsAPI = require('oae-principals');
var PrincipalsModel = require('oae-principals/lib/model');
var PrincipalsUtil = require('oae-principals/lib/util');

/**
 * Creates a new user under this tenant.
 *
 * @param  {Context}                    ctx                 The current context
 * @param  {LoginId}                    loginId             The provider-specific authentication ID of this user, as defined by `model.LoginId`.
 * @param  {String}                     password            The password for this user.
 * @param  {String}                     displayName         A display name, if this is left undefined the first and last name will be concatenated.
 * @param  {Object}                     opts                An object defining optional settings that can be set on the user
 * @param  {String}                     opts.visibility     This user his visibility setting. (One of VISIBILITY_OPTIONS)
 * @param  {String}                     opts.locale         The user his locale
 * @param  {String}                     opts.timezone       The user his timezone
 * @param  {Function(err, userId)}      callback            Callback method.
 * @param  {Object}                     callback.err        Error object if something goes wrong.
 * @param  {String}                     callback.userId     The user ID.
 */
module.exports.createUser = function(ctx, loginId, password, displayName, opts, callback) {
    callback = callback || function() {};
    opts.locale = opts.locale || 'en_GB';
    opts.timezone = opts.timezone || time.currentTimezone;
    opts.visibility = opts.visibility || PrincipalsModel.VISIBILITY_OPTIONS.PUBLIC;

    var validator = new Validator();
    validator.check(null, {'code': 400, 'msg': 'The login id provided is invalid'}).isValidLoginId(loginId);
    validator.check(password, {'code': 400, 'msg': 'A password must be provided'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'A display name must be provided'}).notEmpty();
    validator.check(password, {'code': 400, 'msg': 'Your password is too short (this is the only password requirement.)'}).len(6);
    validator.check(opts.visibility, {'code': 400, 'msg': 'The specified visibility setting is unknown.'}).isIn(_.values(PrincipalsModel.VISIBILITY_OPTIONS));
    validator.check(opts.timezone, {'code': 400, 'msg': 'The specified timezone is invalid'}).isValidTimeZone();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var tenantId = ctx.tenant().alias;

    // ensure that the login ID is not already associated to a user
    _getUserIdByLoginId(loginId, tenantId, function(err, existingUserId) {
        if (err) {
            return callback(err);
        } else if (existingUserId) {
            return callback({'code': 400, 'msg': 'A user with this login id already exists.'});
        }

        // create the user and map them to the login id
        var userId = AuthzUtil.toUuid('u', tenantId, ShortId.generate());
        var hash = PrincipalsUtil.hashPassword(password);
        var flatLoginId = _flattenLoginId(loginId);
        var queries = [
            {
                'query': 'INSERT INTO Principals (principalId, tenant, visibility, locale, timezone, password, displayName) VALUES (?, ?, ?, ?, ?, ?, ?)',
                'parameters': [userId, tenantId, opts.visibility, opts.locale, opts.timezone, hash, displayName]
            },
            {
                'query': 'UPDATE PrincipalsUserLoginIds SET ? = ? WHERE userId = ?',
                'parameters': [flatLoginId, '1', userId]
            },
            {
                'query': 'UPDATE PrincipalsLoginIds SET ? = ? WHERE loginId = ?',
                'parameters': [tenantId, userId, flatLoginId]
            }
        ];

        // Create the user
        Cassandra.runBatchQuery(queries, 'QUORUM', function(err) {
            if (err) {
                return callback(err);
            }
            return callback(null, userId);
        });
    });
};

/**
 * Update a user
 *
 * @param  {Context}        ctx             The current context.
 * @param  {String}         userId          The userId of the user you wish to update.
 * @param  {Object}         profileFields   Object that represent the profile fields that should be updated.
 *                                          Possible keys are visibility, displayName, locale and timezone
 * @param  {Function(err)}  callback        Callback method.
 * @param  {Object}         callback.err    Error object if something goes wrong.
 */
module.exports.updateUser = function(ctx, userId, profileFields, callback) {
    callback = callback || function() {};
    profileFields = profileFields || {};
    
    // Parameter validation
    var validator = new Validator();
    validator.check(userId, {'code': 400, 'msg': 'A user id must be provided'}).notEmpty();
    // Check that there is at least one updated profile field.
    validator.check(_.keys(profileFields).length, {'code': 400, 'msg': 'At least one basic profile field should be specified.'}).min(1);
    // In case a new visibility has been passed in, we check for its validity
    if (profileFields['visibility']) {
        validator.check(profileFields['visibility'], {'code': 400, 'msg': 'An invalid visibility option has been passed on'}).isIn(_.values(PrincipalsModel.VISIBILITY_OPTIONS));
    }
    if (profileFields['timezone']) {
        validator.check(profileFields['timezone'], {'code': 400, 'msg': 'The specified timezone is invalid'}).isValidTimeZone();
    }
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a user'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    
    // Only update existing users.
    getUser(ctx, userId, function(err, user) {
        if (err) {
            return callback(err);
        }

        // Only the current user or an admin can update a user.
        var principalResource = AuthzUtil.getResourceFromUuid(userId);
        if (ctx.user().id === userId || ctx.user().isAdmin(principalResource.tenantId)) {
            var q = Cassandra.constructUpsertCQL('Principals', 'principalId', userId, profileFields, 'QUORUM');
            if (!q) {
                return callback({'code': 500, 'msg': 'Unable to store profile fields'});
            }
            Cassandra.runQuery(q.query, q.parameters, callback);
        } else {
            callback({'code': 401, 'msg': 'You cannot update this user his profile.'});
        }
    });
};

/**
 * Given a LoginId object, determine the internal user ID to which it maps.
 *
 * @param {LoginId}     loginId         The login id to use to lookup the user id
 * @param {String}      tenantId        The tenant id for which the login is effective for the user
 * @param {Function}    callback        Callback function executed when the process completes
 * @param {Object}      callback.err    An error that occurred, if any
 * @param {String}      callback.userId The user id of the user who can authenticate with this login id
 */
var getUserIdByLoginId = module.exports.getUserIdByLoginId = function(loginId, tenantId, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 400, 'msg': 'The login id provided is invalid'}).isValidLoginId(loginId);
    validator.check(tenantId, {'code': 400, 'msg': 'An empty tenant was provided'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getUserIdByLoginId(loginId, tenantId, callback);
}

/**
 * Given a user id, determine the login id for that user.
 *
 * @param {String}      userId              The user id to search
 * @param {Function}    callback            Callback function executed when the process completes
 * @param {Object}      callback.err        An error that occurred, if any
 * @param {String}      callback.loginId    The login id the user can use to log in to the system
 */
var getLoginIdByUserId = module.exports.getLoginIdByUserId = function(userId, callback) {
    var validator = new Validator();
    validator.check(userId, {'code': 400, 'msg': 'The user id provided was empty'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // select first 2 to avoid userId being the first
    Cassandra.runQuery('SELECT FIRST 1 * FROM PrincipalsUserLoginIds USING CONSISTENCY QUORUM WHERE userId = ?', [userId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var row = rows[0];
        var loginId = null;

        // we grab the first login id that we find. Each login id is stored as the column name, with a slug value of '1'.
        row.forEach(function(name, value) {
            if (!loginId && name !== 'userId' && value === '1') {
                loginId = _explodeLoginId(name);
            }
        });

        // this *shouldn't* happen, make it noticeable if it does so it can be repaired
        if (!loginId) {
            log().warn('User %s did not have a suitable login id.', userId);
        }

        return callback(null, loginId);
    });
}

/**
 * Get a user from the DB
 *
 * @param  {Context}                ctx             The current context
 * @param  {String}                 userId          The userId for the user you wish to retrieve.
 * @param  {Function(err, user)}    callback        Callback method.
 * @param  {Object}                 callback.err    Error object if something goes wrong.
 * @param  {Object}                 callback.user   The user objct.
 */
var getUser = module.exports.getUser = function(ctx, userId, callback) {
    if (!userId || !PrincipalsUtil.isUser(userId)) {
        return callback({'code': 400, 'msg': 'The provided userId is not a valid user identifier.'});
    }

    PrincipalsUtil.getPrincipal(ctx, userId, callback);
};

/**
 * Gets the basic profile for a user.
 * The user's visibility setting determines what the profile hash will contain.
 * {
 *   'profilePath': '/person/simong',
 *   'userId': 'u:cam:simong',
 *   'isFollowing': true,
 *   'accountPermissions': 'public',
 *   'proﬁle': {
 *       'ﬁrstName': 'Simon',
 *       'lastName': 'Gaeremynck',
 *       'displayName': 'Simon "simong" Gaeremynck'
 *       'picture': 'pathToCroppedProﬁlePicture'
 *   }
 * };
 *
 * @param  {Context}  ctx           The current context
 * @param  {String}   userId        The id of the user for which the profile should be retrieved.
 * @param  {Object}   callback.err  Error object if something goes wrong.
 * @param  {Object}   callback.user The user.
 */
module.exports.getBasicProfile = function(ctx, userId, callback) {
    // Anonymous is a bit of a special case.
    module.exports.getUser(ctx, userId, function(err, user) {
        if (err) {
            return callback(err);
        }
        var data = {
            'profilePath': '/person/' + userId,
            'userId': user.id,
            'visibility': user.visibility,
            'profile': {
                'firstName': user.firstName,
                'lastName': user.lastName,
                'displayName': user.displayName,
            }
        };

        var keys = _.keys(user.extra);
        for (var i = 0; i < keys.length; i++) {
            data.profile[keys[i]] = user.extra[keys[i]];
        }

        callback(null, data);
    });
};

/**
 * Gets the me feed for the current user, if anonymous returns 'anon': true
 * If logged in returns structured me feed object in the callback
 *  {
 *     "profilePath": "/person/u:global:bert",
 *     "userId": "u:global:bert",
 *     "visibility": "private",
 *     "isTenantAdmin": true,
 *     "isGlobalAdmin": false,
 *     "profile": {
 *         "firstName": "Bert",
 *         "lastName": "Pareyn",
 *         "displayName": "Bert Pareyn"
 *     },
 *     "locale": {
 *         "locale": "en_GB",
 *         "timezone": {
 *             "name": "Europe/London",
 *             "offset": 1
 *         }
 *     }
 * }
 * If error returns error object
 * @param  {Context}              ctx            The current context
 * @param  {String}               user           The user the me feed is for
 * @param  {Function(err, data)}  callback       Callback method.
 * @param  {Object}               callback.err   Error object if something goes wrong.
 * @param  {Object}               callback.data  The me feed data for the user.
 */
module.exports.getMe = function(ctx, user, callback) {
    if (ctx.user() === undefined || ctx.user() === null) {
        return callback({'code': 200,'msg': {'anon': true}});
    }

    PrincipalsAPI.getBasicProfile(ctx, user.id, function(err, data) {
        if (err) {
            return callback(err);
        }

        // calculate timezone offset in hours.
        var now = new time.Date();
        now.setTimezone(ctx.user().timezone);
        var offset = -1 * now.getTimezoneOffset() / 60;

        data.isTenantAdmin = ctx.user().isTenantAdmin(ctx.user().tenant);
        data.isGlobalAdmin = ctx.user().isGlobalAdmin();

        data.locale = {
            'locale': ctx.user().locale,
            'timezone': {
                'name': ctx.user().timezone,
                'offset': offset
            }
        };

        callback(null, data);
    });
};

/**
 * Sets the visibility of a user.
 *
 * @param {Context}         ctx             A context object representing the current user.
 * @param {String}          userId          The ID of the user that needs the visibility change.
 * @param {String}          visibility      The desired visibility. Valid options are defined in @see PrincipalsModel.VISIBILITY_OPTIONS
 * @param {Function(err)}   callback        Callback method.
 * @param {String}          callback.err    Error object.
 */
module.exports.setUserVisibility = function(ctx, userId, visibility, callback) {
    callback = callback || function() {};
    validator = new Validator();
    validator.check(visibility, {'code': 400, 'msg': 'The specified visibility setting is unknown.'}).isIn(_.values(PrincipalsModel.VISIBILITY_OPTIONS));
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    var principalResource = AuthzUtil.getResourceFromUuid(userId);
    if (ctx.user().id === userId || ctx.user().isAdmin(principalResource.tenantId)) {
        getUser(ctx, userId, function(err, user) {
            if (err) {
                return callback(err);
            }
            Cassandra.runQuery('UPDATE Principals USING CONSISTENCY QUORUM SET visibility = ? WHERE principalId = ?', [visibility, userId], callback);
        });
    } else {
        return callback({'code': 401, 'msg': 'You\'re not authorized to change someone else their profile!'});
    }
};

/**
 * Checks if a password matches a user id
 *
 * @param  {String}                 userId          The userId of the user
 * @param  {String}                 password        The plain-text password.
 * @param  {Function(err, user)}    callback        Callback method.
 * @param  {Object}                 callback.err    Error object.
 * @param  {Object}                 callback.user   An object that has a key 'id' that holds the full user id.
 *                                                  This object will be null if the user was not found or the password didn't match.
 */
module.exports.checkPassword = function(userId, password, callback) {
    var validator = new Validator();
    validator.check(userId, {'code': 400, 'msg': 'The user id provided was empty'}).notEmpty();
    validator.check(password, {'code': 400, 'msg': 'The password provided was empty'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _checkPassword(userId, password, callback);
};

/**
 * Changes the password of a user.
 *
 * @param  {Context}  ctx         The current context.
 * @param  {String}   userId      The user id of the user whose password that needs to be changed.
 * @param  {String}   oldPassword The old password that can be used to authenticate this change request.
 * @param  {String}   newPassword The new password.
 * @param  {Function} callback    [description]
 */
var changePassword = module.exports.changePassword = function(ctx, userId, oldPassword, newPassword, callback) {

    // initial validation, for regular users and admins
    var validator = new Validator();
    validator.check(userId, {'code': 400, 'msg': 'The user id provided was empty'}).notEmpty();
    validator.check(newPassword, {'code': 400, 'msg': 'The new password provided was empty'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Global/Tenant admins can change passwords.
    var principalResource = AuthzUtil.getResourceFromUuid(userId);
    if (ctx.user().isAdmin(principalResource.tenantId)) {
        return _changePassword(userId, newPassword, callback);
    }

    // validate the old password only after we've done admin bypass
    validator.check(oldPassword, {'code': 400, 'msg': 'The old password provided was empty'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Otherwise the password must match.
    _checkPassword(userId, oldPassword, function(err, user) {
        if (!err && user) {
            return _changePassword(userId, newPassword, callback);
        }

        // By this point this user shouldn't be allowed to do anything.
        return callback({'code': 401, 'msg': 'You\'re not authorized to change this user\'s password.'}, false);
    });
};

/**
 * Set a flag that indicates whether a user is a tenant admin.
 * The ctx user must be a tenant or global admin to be able to do this.
 *
 * @param  {Context}        ctx             Context that holds the tenant.
 * @param  {User}           principalId     The user that needs the flag
 * @param  {Boolean}        isAdmin         Flag that indicates whether the provided user should be a tenant admin.
 * @param  {Function(err)}  callback        Callback method
 * @param  {Object}         callback.err    Error object.
 */
module.exports.setTenantAdmin = function(ctx, principalId, isAdmin, callback) {
    var principalResource = AuthzUtil.getResourceFromUuid(principalId);
    if (ctx.user() && (ctx.user().isTenantAdmin(principalResource.tenantId) || ctx.user().isGlobalAdmin())) {
        _setAdmin(ctx, 'admin:tenant', isAdmin, principalId, callback);
    } else {
        return callback({'code': 401, 'msg': 'You do not have sufficient rights to make someone an admin.'});
    }
};

/**
 * Set a flag that indicates whether a user is a glbal admin.
 * The ctx user must be a global admin to be able to do this.
 *
 * @param  {Context}        ctx             Context that holds the tenant.
 * @param  {User}           user            The user that needs the flag
 * @param  {Boolean}        isAdmin         Flag that indicates whether the provided user should be a global admin.
 * @param  {Function(err)}  callback        Callback method
 * @param  {Object}         callback.err    Error object.
 */
module.exports.setGlobalAdmin = function(ctx, principalId, isAdmin, callback) {
    if (ctx.user() && ctx.user().isGlobalAdmin()) {
        _setAdmin(ctx, 'admin:global', isAdmin, principalId, callback);
    } else {
        return callback({'code': 401, 'msg': 'You do not have sufficient rights to make someone an admin.'});
    }
};

/**!
 * Change the password of the given user to the given password.
 *
 * @param {String}      userId              The user id of the user whose password to change
 * @param {String}      newPassword         The new password to change to
 * @param {Function}    callback            Callback function, invoked when the process completes
 * @param {Object}      callback.err        An error that occurred, if any
 * @param {Boolean}     callback.changed    Whether or not the password was changed
 */
var _changePassword = function(userId, newPassword, callback) {
    // Hash and store the password
    var hash = PrincipalsUtil.hashPassword(newPassword);
    Cassandra.runQuery('UPDATE Principals USING CONSISTENCY QUORUM SET password = ? WHERE principalId = ?', [hash, userId], function(err, rows) {
        if (err) {
            return callback(err, false);
        }

        callback(null, true);
    });
};

/**!
 * Checks the password for a specified user id.
 *
 * @param  {String}             userId      The id of the user whose password should be checked.
 * @param  {String}             password    The password that can be used to compare with the one in the DB.
 * @param  {Function(err, id)}  callback    Callback method
 * @param  {Object}             err         Error object
 * @param  {object}             id          The ID of the user if the passwords match. Otherwise false.
 */
var _checkPassword = function(userId, password, callback) {
    Cassandra.runQuery('SELECT password FROM Principals USING CONSISTENCY QUORUM WHERE principalId = ?', [userId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        if (rows[0].count === 0) {
            // No user found with that username.
            return callback({'code': 401, 'msg': 'No password found for this principal'});
        }

        // Check if the user provided password matches the stored password
        if (PrincipalsUtil.checkPassword(password, rows[0].get('password').value)) {
            callback(false, {'id': userId});
        } else {
            callback({'code': 401, 'msg': 'User name and/or password do not match.'});
        }
    });
};

/**
 * Internal method that makes a user an admin. This method will do all the necessary validation
 * of the user ctx and passed in parameters.
 *
 * @param  {Context}        ctx             Context that holds the current user and tenant.
 * @param  {String}         adminType       One of admin:global` or `admin:tenant`
 * @param  {Boolean}        isAdmin         Flag that indicates whether this user should be an admin or not.
 * @param  {String}         principalId     The uuid of the user that needs to be made an admin.
 * @param  {Function(err)}  callback        Callback method
 * @param  {Object}         callback.err    Error object.
 * @private
 */
var _setAdmin = function(ctx, adminType, isAdmin, principalId, callback) {
    if (!PrincipalsUtil.isUser(principalId)) {
        return callback({'code': 400, 'msg': 'The provided principalId is not a user.'});
    }
    // Double-check that this user exists.
    module.exports.getUser(ctx, principalId, function(err, user) {
        // If we get an error, this user does not exist.
        if (err) {
            return callback(err);
        }

        // Sanitize input and store it in cassandra.
        isAdmin = sanitize(isAdmin).toBooleanStrict();
        Cassandra.runQuery("UPDATE Principals USING CONSISTENCY QUORUM SET ?=? WHERE principalId = ?", [adminType, isAdmin, principalId], callback);
    });
};

/**!
 * Given a LoginId object, determine the internal user ID to which it maps.
 *
 * @param {LoginId}                 loginId         The login id to use to lookup the user id
 * @param {String}                  tenantId        The tenant to which the user belongs
 * @param {Function(err, userId)}   callback        Callback function executed when the process completes
 * @param {Object}                  callback.err    An error that occurred, if any
 * @param {String}                  callback.userId The user id of the user who can authenticate with this login id
 */
var _getUserIdByLoginId = function(loginId, tenantId, callback) {
    // the column names are the tenantIds and the value of the column is the user id
    var rowKey = _flattenLoginId(loginId);
    Cassandra.runQuery('SELECT ? FROM PrincipalsLoginIds USING CONSISTENCY QUORUM WHERE loginId = ?', [ tenantId, rowKey ], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var row = rows[0];
        var userIdCol = row.get(tenantId);
        var userId = userIdCol ? userIdCol.value : null;
        return callback(null, userId);
    });
};

/**!
 * Convert a loginId object to its flat representation: <provider>:<external id>.
 *
 * @param   {LoginId} loginId   The loginId object to flatten
 * @return  {String}            The flat representation of this loginId
 */
var _flattenLoginId = function(loginId) {
    return loginId.provider + ':' + loginId.externalId;
}

/**!
 * Explode a flattened login id (<provider>:<external id>) into a LoginId object.
 *
 * @param   {String}  loginIdStr    A flattened representation of a login id (e.g., local:branden, google:my-email@gmail.com)
 * @return  {LoginId}               The structured representation of the login id. If the login ID is not valid, then `null` is returned.
 */
var _explodeLoginId = function(loginIdStr) {
    if (!loginIdStr) {
        log().warn('Attempted to parse an undefined login id.');
        return null;
    }

    // make sure we can explode this into a login id
    var parts = loginIdStr.split(':');
    if (parts.length < 2) {
        log().warn('Login ID "%s" was attempted to be parsed, but is not valid (must contain at least one colon)', loginIdStr);
        return null;
    }

    // the external id is actually everything after the 2nd colon, as it can contain colons.
    // we cannot restrict externalIds to not be able to have colons
    var externalId = parts.slice(1).join(':');

    // make sure the resulting loginId is valid
    var loginId = new PrincipalsModel.LoginId(parts[0], externalId);
    var validator = new Validator();
    validator.check(null, "Invalid loginId").isValidLoginId(loginId);
    if (validator.hasErrors()) {
        log().warn({ validationError: validator.getFirstError() }, 'Login ID "%s" was attempted to be parsed, but is not valid.', loginIdStr);
        return null;
    }

    return loginId;
}
