/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var AuthzUtil = require('oae-authz/lib/util');
var ContentConstants = require('oae-content/lib/constants').ContentConstants;
var ContentDAO = require('oae-content/lib/internal/dao');
var EmitterAPI = require('oae-emitter');
var log = require('oae-logger').logger('oae-preview-processor');
var RestAPI = require('oae-rest');
var RestUtil = require('oae-rest/lib/util');
var TaskQueue = require('oae-util/lib/taskqueue');
var Telemetry = require('oae-telemetry').telemetry('preview-processor');
var Validator = require('oae-util/lib/validator').Validator;

var PreviewConstants = require('./constants');
var PreviewContext = require('./model').PreviewContext;
var FilterGenerator = require('./filters').FilterGenerator;

// OAE Processors
var ImagesProcessor = require('oae-preview-processor/lib/processors/file/images');
var OfficeProcessor = require('oae-preview-processor/lib/processors/file/office');
var PDFProcessor = require('oae-preview-processor/lib/processors/file/pdf');

var DefaultLinkProcessor = require('oae-preview-processor/lib/processors/link/default');
var FlickrLinkProcessor = require('oae-preview-processor/lib/processors/link/flickr');
var SlideShareLinkProcessor = require('oae-preview-processor/lib/processors/link/slideshare');
var VimeoLinkProcessor = require('oae-preview-processor/lib/processors/link/vimeo');
var YoutubeLinkProcessor = require('oae-preview-processor/lib/processors/link/youtube');

var CollabDocProcessor = require('oae-preview-processor/lib/processors/collabdoc/collabdoc');

var FolderProcessor = require('oae-preview-processor/lib/processors/folder');

var config = null;

// A hash of registered processors.
var _processors = {};

/**
 * ## PreviewProcessorAPI
 *
 * ### Events
 *
 *  * `processed(contentObj, revision, status)` - Indicates a revision for a piece of content has finished processing
 */
var PreviewProcessorAPI = module.exports = new EmitterAPI.EventEmitter();

/**
 * Start listening for preview tasks.
 *
 * @param  {Function}    [callback]      Standard callback method
 * @param  {Object}      [callback.err]  Standard error object (if any)
 */
var enable = module.exports.enable = function(callback) {
    callback = callback || function(err) { /* error is logged within the implementation */ };

    // Set up the message queue and start listenening for preview tasks
    var options = {
        'subscribe': {
            'prefetchCount': 1
        }
    };

    // Bind an error listener to the REST methods
    RestUtil.on('error', _restErrorLister);

    TaskQueue.bind(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, _handleGeneratePreviewsTask, options, function(err) {
        if (err) {
            log().error({'err': err}, 'Could not bind to the generate previews queue');
            return callback(err);
        }

        log().info('Bound the preview processor to the generate previews task queue');

        TaskQueue.bind(PreviewConstants.MQ.TASK_GENERATE_FOLDER_PREVIEWS, _handleGenerateFolderPreviewsTask, options, function(err) {
            if (err) {
                log().error({'err': err}, 'Could not bind to the generate folder previews queue');
                return callback(err);
            }

            log().info('Bound the preview processor to the generate folder previews task queue');

            TaskQueue.bind(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, _handleRegeneratePreviewsTask, null, function(err) {
                if (err) {
                    log().error({'err': err}, 'Could not bind to the regenerate previews queue');
                    return callback(err);
                }

                log().info('Bound the preview processor to the regenerate previews task queue');
                return callback();
            });
        });
    });
};

/**
 * Remove the listener for preview tasks
 *
 * @param  {Function}    [callback]      Standard callback method
 * @param  {Object}      [callback.err]  Standard error object (if any)
 */
var disable = module.exports.disable = function(callback) {
    callback = callback || function(err) { /* error is logged within the implementation */ };

    TaskQueue.unbind(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function(err) {
        if (err) {
            log().error({'err': err}, 'Could not unbind from the previews queue');
            return callback(err);
        }

        log().info('Unbound the preview processor from the generate previews task queue');

        TaskQueue.unbind(PreviewConstants.MQ.TASK_GENERATE_FOLDER_PREVIEWS, function(err) {
            if (err) {
                log().error({'err': err}, 'Could not unbind from the folder previews queue');
                return callback(err);
            }

            log().info('Unbound the preview processor from the folder generate previews task queue');

            TaskQueue.unbind(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, function(err) {
                if (err) {
                    log().error({'err': err}, 'Could not unbind from the regenerate previews queue');
                    return callback(err);
                }

                log().info('Unbound the preview processor from the regenerate previews task queue');

                // Remove our REST error listener
                RestUtil.removeListener('error', _restErrorLister);

                return callback();
            });
        });
    });
};

/**
 * Logs an error that originates from the REST Api.
 *
 * @param  {Object}     err     An error object.
 * @api private
 */
var _restErrorLister = function(err) {
    log().error({'err': err}, 'Got an unexpected error from the REST api');
};

/**
 * Refresh the preview processor configuration with the given options.
 *
 * @param  {Object}     config      The main configuration object as defined in `config.js`. The full config object should be passed in.
 * @param  {Function}   callback    Standard callback function
 */
var refreshPreviewConfiguration = module.exports.refreshPreviewConfiguration = function(_config, callback) {
    // Stop listening for tasks.
    disable(function(err) {
        if (err) {
            return callback(err);
        }

        // Store this configuration.
        config = _config;

        if (config.previews.enabled) {
            _initializeDefaultProcessors(function(err) {
                if (err) {
                    return callback(err);
                }

                // Register the processors.
                _registerDefaultProcessors();

                // Start listening for messages by enabling it.
                enable(callback);
            });
        } else {
            // Nothing to do when the PP is disabled.
            callback();
        }
    });
};

/**
 * @return {Object}    The configuration object that is currently in use.
 */
var getConfiguration = module.exports.getConfiguration = function() {
    return config;
};

/**
 * Register a preview processor.
 * A preview processor is an object which exposes 2 methods:
 * 1/ `test`
 * Every time a new piece of content needs previews generated it will be passed to the `test` method of each known processor.
 * Each processor should pass back how suitable they are to generate previews for a particular piece of content.
 * The function will be called in the following way:
 *    `processor.test(previewCtx, contentObj, callback)`
 * The callback signature should be:
 *     `callback(error, score)`
 * where error is a standard OAE error object (or null) and score is an integer expressing how well suited this processor
 * is for handling this type of file. Any negative value means the processor should not be used.
 * Values between 0 and 10 are reserved for default OAE processors.
 * The processor who returns the highest score will be selected to perform the preview generation.
 *
 * 2/ `generatePreviews`
 * The method that will perform the actual preview generation.
 *
 *
 * @param  {String}     processorId                 A unique identifier for this processor. This identifier can be used to remove a processor.
 * @param  {Object}     processor                   The processor that can be used to handle a piece of content.
 * @param  {Function}   processor.test              The method that passes an integer back which expresses how suitable this processor is for a new piece of content.
 * @param  {Function}   processor.generatePreviews  The method that generates previews for a piece of content.
 */
var registerProcessor = module.exports.registerProcessor = function(processorId, processor) {
    var validator = new Validator();
    validator.check(processorId, 'Missing processor ID').notEmpty();
    if (processorId) {
        validator.check(_processors[processorId], 'This processor is already registerd').isNull();
    }
    validator.check(null, 'Missing processor').isObject(processor);
    if (processor) {
        validator.check(processor.test, 'The processor has no test method').notNull();
        validator.check(processor.generatePreviews, 'The processor has no generatePreviews method').notNull();
    }
    if (validator.hasErrors()) {
        throw new Error(validator.getFirstError());
    }

    _processors[processorId] = processor;
};

/**
 * Unregisters a preview processor.
 *
 * @param  {String}  processorId     The ID of the processor that should be unregistered.
 */
var unregisterProcessor = module.exports.unregisterProcessor = function(processorId) {
    if (!processorId) {
        throw new Error('The processor id must be specified');
    }

    delete _processors[processorId];
};

/**
 * Returns the processor that is best equiped to generate previews for a piece of content.
 *
 * @param  {Context}    ctx                 Standard context object containing the current user and the current tenant
 * @param  {Content}    contentObj          The content object for which we need to find a processor.
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Processor}  callback.processor  The processor who can generate previews for this piece of content. If no processor is equiped to deal with this piece of content, null will be returned.
 */
var getProcessor = module.exports.getProcessor = function(ctx, contentObj, callback) {
    var scoredProcessors = [];
    var processors = _.values(_processors);

    _.each(processors, function(processor) {
        processor.test(ctx, contentObj, function(err, score) {
            if (err) {
                return callback(err);
            }

            // Add it to the list.
            scoredProcessors.push({'score': score, 'processor': processor});

            // If we've tested all processors we can select the best one.
            if (scoredProcessors.length === processors.length) {
                // Sort them descending on the score.
                scoredProcessors.sort(function(a, b) {
                    if (a.score < b.score) {
                        return 1;
                    }
                    if (a.score > b.score) {
                        return -1;
                    }
                    return 0;
                });

                // If all processors return a negative number, then we need to return null.
                // This means that this type of content will have no preview images.
                if (scoredProcessors[0].score < 0) {
                    return callback(null, null);
                }

                // In case there are 2 processors who return the same score we need to log a warning.
                // This isn't exactly optimal, but it's up to the developer implementing a 3rd party processor
                // to ensure it doesn't conflict with the OAE processors (or any other ones in the system.)
                if (scoredProcessors[0].score === scoredProcessors[1].score) {
                    log().warn({'contentId': contentId}, 'Has 2 processors with an equal score');
                }

                // Return the best one.
                callback(null, scoredProcessors[0].processor);
            }
        });
    });
};

/**
 * Submits a piece of content to the preview generation queue where it can then
 * be picked up by one of the preview processors.
 *
 * @param  {String}     contentId   The ID of the piece of the content that needs new preview items.
 * @param  {String}     revisionId  The ID of the revision for which we need to generate previews.
 */
var submitForProcessing = module.exports.submitForProcessing = function(contentId, revisionId) {
    log().trace({'contentId': contentId, 'revisionId': revisionId}, 'Submitting for preview processing');
    TaskQueue.submit(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, {'contentId': contentId, 'revisionId': revisionId});
};

/**
 * Submits a folder to the preview generation queue where it can then
 * be picked up by one of the preview processors.
 *
 * @param  {String}     folderId    The ID of the folder that needs new preview items
 */
var submitFolderForProcessing = module.exports.submitFolderForProcessing = function(folderId) {
    log().trace({'folderId': folderId}, 'Submitting for folder preview processing');
    TaskQueue.submit(PreviewConstants.MQ.TASK_GENERATE_FOLDER_PREVIEWS, {'folderId': folderId});
};

/**
 * Submits a task that triggers preview items matching specified filters to be regenerated.
 *
 * @param  {Context}    ctx                                 Standard context object containing the current user and the current tenant
 * @param  {Object}     filters                             An object that holds the filters that should be applied on the content items. See `FilterGenerator` for more information
 * @param  {Function}   [callback]                          Invoked when the task has been fired
 * @param  {Object}     [callback.err]                      An error that occurred, if any
 */
var reprocessPreviews = module.exports.reprocessPreviews = function(ctx, filters, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'statuses': statuses}, 'Failed to invoke reprocess previews task');
        }
    };

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Must be global administrator to reprocess previews'}).isGlobalAdministratorUser(ctx);
    validator.check(null, {'code': 400, 'msg': 'At least one filter must be specified'}).isObject(filters);
    if (_.isObject(filters)) {
        validator.check(_.keys(filters).length, {'code': 400, 'msg': 'At least one filter must be specified'}).min(1);
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var filterGenerator = new FilterGenerator(filters);
    if (filterGenerator.hasErrors()) {
        return callback(filterGenerator.getFirstError());
    }

    TaskQueue.submit(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, {'filters': filters}, callback);
};

/**
 * Reprocess a single preview for a content revision.
 *
 * @param  {Context}    ctx         Standard context object containing the current user and the current tenant
 * @param  {String}     contentId   The id of the content item for which to reprocess the preview
 * @param  {String}     revisionId  The id of the revision to reprocess
 */
var reprocessPreview = module.exports.reprocessPreview = function(ctx, contentId, revisionId, callback) {
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(revisionId, {'code': 400, 'msg': 'A revision id must be provided'}).isResourceId();
    validator.check(null, {'code': 401, 'msg': 'Must be logged in to reprocess previews'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var contentTenantAlias = AuthzUtil.getResourceFromId(contentId).tenantAlias;
    if (!ctx.user().isAdmin(contentTenantAlias)) {
        return callback({'code': 401, 'msg': 'You must be admin of the content item\'s tenant to reprocess its previews'});
    }

    submitForProcessing(contentId, revisionId);
    return callback();
};

/**
 * When bound to an MQ generate preview task, this method will generate the appropriate
 * preview images for folders
 *
 * @param  {Object}     data                The task data
 * @param  {String}     data.folderId       The ID of the folder that needs new preview items
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @api private
 */
var _handleGenerateFolderPreviewsTask = function(data, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'data': data}, 'Error handling folder preview generation');
        }
    };

    if (!data.folderId) {
        log().error({'data': data}, 'An invalid generate folder previews task was submitted to the generate folder previews task queue');
        return callback({'code': 400, 'msg': 'An invalid generate folder previews task was submitted to the generate folder previews task queue'});
    }

    log().info({'folderId': data.folderId}, 'Starting preview folder generation process');
    FolderProcessor.generatePreviews(data.folderId, function(err) {
        if (err) {
            log().error({'err': err, 'folderId': data.folderId}, 'Error when trying to process a folder');
            Telemetry.incr('error.count');
            return callback(err);
        } else {
            // We're done.
            log().info({'folderId': data.folderId}, 'Folder preview processing done');
            Telemetry.incr('ok.count');
            return callback();
        }
    });
};

/**
 * When bound to am MQ generate preview task, this method will generate the appropriate
 * preview images
 *
 * @param  {Object}     data                The task data
 * @param  {String}     data.contentId      The ID for the piece of content that needs new preview items.
 * @param  {String}     data.revisionId     The ID of the revision of the piece of content that needs new preview items.
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @api private
 */
var _handleGeneratePreviewsTask = function(data, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'data': data}, 'Error handling preview generation');
        }
    };

    if (!data.contentId) {
        log().error({'data': data}, 'An invalid generate previews task was submitted to the generate previews task queue');
        return callback({'code': 400, 'msg': 'An invalid generate previews task was submitted to the generate previews task queue'});
    }

    var start = Date.now();
    log().info({'contentId': data.contentId, 'data': data}, 'Starting preview generation process');
    var ctx = new PreviewContext(config, data.contentId, data.revisionId);

    // Generate a context for this preview process and login to the tenant of this content item and start processing
    ctx.login(function(err) {
        if (err) {
            // If we can't login, we cannot call cleanCallback as we won't have a session cookie
            // to set a status
            ctx.cleanup();
            Telemetry.appendDuration('process.time', start);
            Telemetry.incr('error.count');
            return callback(err);
        }

        // Get the content and revision profile
        ctx.getContentData(function(err) {
            if (err) {
                return ctx.setStatus('error', callback);
            }

            // Generate the actual preview images
            _generatePreviews(ctx, function(err) {
                ctx.cleanup();
                Telemetry.appendDuration('process.time', start);
                PreviewProcessorAPI.emit(PreviewConstants.EVENTS.PREVIEWS_FINISHED, ctx.content, ctx.revision, ctx.getStatus());
                if (err) {
                    log().error({'err': err, 'contentId': data.contentId}, 'Error when trying to process this file');
                    Telemetry.incr('error.count');
                    return callback(err);
                } else {
                    // We're done.
                    log().info({'contentId': data.contentId}, 'Preview processing done');
                    Telemetry.incr('ok.count');
                    return callback();
                }
            });
        });
    });
};

/**
 * Generates previews for a piece of content.
 *
 * @param  {PreviewContext}      ctx             The preview context associated to this file. This context should have an authenticated global administrator against it.
 * @param  {Function}            callback        Standard callback function
 * @param  {Object}              callback.err    An error that occurred, if any
 * @api private
 */
var _generatePreviews = function(ctx, callback) {
    // Get the best processor and start processing.
    getProcessor(ctx, ctx.content, function(err, processor) {
        if (err) {
            return callback(err);
        } else if (processor) {
            processor.generatePreviews(ctx, ctx.content, function(err, ignored) {
                if (err) {
                    ctx.setStatus('error', callback);
                } else if (ignored) {
                    ctx.setStatus('ignored', callback);
                } else {
                    ctx.savePreviews(callback);
                }
            });
        } else {
            log().info({'contentId': ctx.contentId, 'content': ctx.content, 'revision': ctx.revision}, 'Ignoring as this type of content is not supported for now');
            ctx.setStatus('ignored', callback);
        }
    });
};

/**
 * Reprocesses the previews of all content items who match the `data.filters`.
 *
 * @param  {Object}     data            The task data
 * @param  {Object}     data.filters    An object containing the filters that should be processed
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 * @api private
 */
var _handleRegeneratePreviewsTask = function(data, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'opts': opts}, 'Error reprocessing all previews');
        }
    };

    if (!data.filters) {
        log().error({'data': data}, 'An invalid regenerate previews task was submitted to the regenerate previews task queue');
        return callback({'code': 400, 'msg': 'An invalid regenerate previews task was submitted to the regenerate previews task queue'});
    }

    var filterGenerator = new FilterGenerator(data.filters);

    // This can strictly not happen as we shouldn't be submitting invalid filters on the queue
    // but we should check it in case something happened in-transport
    if (filterGenerator.hasErrors()) {
        log().error({'data': data, 'errors': filterGenerator.getErrors()}, 'An invalid regenerate previews task was submitted to the regenerate previews task queue');
        return callback({'code': 400, 'msg': 'An invalid regenerate previews task was submitted to the regenerate previews task queue'});
    }

    log().info({'filters': data.filters}, 'Starting reprocessing task');

    // Track status of processing
    var start = Date.now();
    var totalScanned = 0;
    var totalReprocessed = 0;

    /*!
     * Handles each batch from the ContentDAO.Content.iterateAll method.
     *
     * @see ContentDAO.Content#iterateAll
     * @api private
     */
    var _onEach = function(contentRows, done) {
        log().info('Scanning %d content items to see if previews need to be reprocessed', contentRows.length);
        totalScanned += contentRows.length;

        // Get those rows we can use to filter upon
        var contentToFilter = _.filter(contentRows, function(contentRow) {
            if (contentRow.previews) {
                try {
                    contentRow.previews = JSON.parse(contentRow.previews);
                    return true;
                } catch (ex) {
                    // If the preview is invalid JSON, something bad happened. Lets try and reprocess it so the processor can better set the preview data
                    log().warn({'contentRow': contentRow}, 'Found invalid JSON for content item. Forcing regeneration of previews');
                }
            } else {
                // If there is no previews object, something is wrong. Try and reprocess it and reset it
                log().warn({'contentId': contentRow.contentId}, 'Found no previews object for content item. Forcing regeneration of previews');
            }

            // If we reach this point, it means the previews object was in an incorrect state
            // so we can't use it for filtering. We should reprocess this piece of content immediately
            totalReprocessed++;
            submitForProcessing(contentRow.contentId, contentRow.latestRevisionId);
            return false;
        });

        // 1st phase: filter based on content types
        var filteredContent = filterGenerator.filterContent(contentToFilter);

        // If we don't need to filter by revisions we can simply reprocess the latest revisions
        // of the content items that are left
        if (!filterGenerator.needsRevisions() || _.isEmpty(filteredContent)) {
            _.each(filteredContent, function(content) {
                totalReprocessed++;
                submitForProcessing(content.contentId, content.latestRevisionId);
            });
            return done();
        } else {
            // We need to filter by revisions
            var contentIds = _.map(filteredContent, function(contentObj) { return contentObj.contentId; });
            ContentDAO.Revisions.getAllRevisionsForContent(contentIds, function(err, revisionsByContent) {
                if (err) {
                    log().error({'err': err}, 'Error trying to retrieve revisions for content');
                }

                // Stick the revisions on their content item
                var filteredContentById = _.indexBy(filteredContent, 'contentId');
                _.each(revisionsByContent, function(revisions, contentId) {
                    filteredContentById[contentId].revisions = revisions;
                });
                filteredContent = _.values(filteredContentById);

                // Run the second filtering phase
                filteredContent = filterGenerator.filterRevisions(filteredContent);

                // Submit all those are left
                _.each(filteredContent, function(content) {
                    _.each(content.revisions, function(revision) {
                        totalReprocessed++;
                        submitForProcessing(content.contentId, revision.revisionId);
                    });
                });

                return done();
            });
        }
    };

    ContentDAO.Content.iterateAll(filterGenerator.getContentColumnNames(), 1000, _onEach, function(err) {
        if (err) {
            log().error({'err': err}, 'Error scanning content items for preview reprocessing');
            return callback(err);
        }

        log().info({
            'timeElapsed': Date.now() - start,
            'totalScanned': totalScanned,
            'totalReprocessed': totalReprocessed
        }, 'Finished scanning content items for reprocessing');
        return callback();
    });
};

/**
 * Initializes those default processors who need initialization.
 *
 * @param  {Function} callback      Standard callback function
 * @param  {Object}   callback.err  An error that occurred, if any
 * @api private
 */
var _initializeDefaultProcessors = function(callback) {
    // Initialize those processors that need it.
    OfficeProcessor.init(config.previews.office, function(err) {
        if (err) {
            return callback(err);
        }

        PDFProcessor.init(config.previews, function(err) {
            if (err) {
                return callback(err);
            }

            DefaultLinkProcessor.init(config.previews.link, callback);
        });
    });
};

/**
 * Registers the default OAE processors.
 *
 * @api private
 */
var _registerDefaultProcessors = function() {
    registerProcessor('oae-file-images', ImagesProcessor);
    registerProcessor('oae-file-office', OfficeProcessor);
    registerProcessor('oae-file-pdf', PDFProcessor);

    registerProcessor('oae-link-default', DefaultLinkProcessor);
    registerProcessor('oae-link-flickr', FlickrLinkProcessor);
    registerProcessor('oae-link-slideshare', SlideShareLinkProcessor);
    registerProcessor('oae-link-vimeo', VimeoLinkProcessor);
    registerProcessor('oae-link-youtube', YoutubeLinkProcessor);

    registerProcessor('oae-collabdoc', CollabDocProcessor);
};
