/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var fs = require('fs');
var mkdirp = require('mkdirp');
var path = require('path');
var request = require('request');
var rimraf = require('rimraf');
var url = require('url');
var util = require('util');

var IO = require('oae-util/lib/io');
var log = require('oae-logger').logger('oae-preview-processor');
var RestAPI = require('oae-rest');
var RestContext = require('oae-rest/lib/model').RestContext;

var extensionRegex = /^[a-zA-Z]+$/;

/**
 * @typedef PreviewContext
 * @type {Object}
 * @property {String}      contentId           The ID of the piece of content we're processing.
 * @property {Object}      content             The content object. This gets lazy loaded, so bear in mind that this is not available immediately.
 * @property {String}      baseDir             The directory where all preview related files should be stored. Once the preview process operation finishes, this directory will removed.
 * @property {RestContext} tenantRestContext   The RestContext that is used to download the item from the tenant host. This will be retrieved by letting the global admin log in on the tenant. This will only be filled in once the `login` method is called.
 */

/**
 * A context object that holds various properties and utility methods.
 *
 * @param  {Object}         config          The main configuration object as defined in `config.js`. The full config object should be passed in.
 * @param  {String}         contentId       The ID of the piece of content we'll be processing.
 * @param  {String}         revisionId      The revision ID of the piece of content we'll be processing.
 * @return {PreviewContext}                 A PreviewContext object.
 */
var PreviewContext = module.exports.PreviewContext = function(config, contentId, revisionId) {
    var protocol = (config.servers.useHttps ? 'https' : 'http');
    var host = config.servers.serverInternalAddress || config.servers.globalAdminHost;
    var strictSSL = config.servers.strictHttps;

    var globalRestContext = new RestContext(protocol + '://' + host, {
        'username': config.previews.credentials.username,
        'userPassword': config.previews.credentials.password,
        'hostHeader': config.servers.globalAdminHost,
        'strictSSL': strictSSL
    });

    var _thumbnailPath = null;
    var _previews = [];
    var _contentMetadata = {};
    var _previewMetadata = {};
    var _status = null;

    var that = {};
    that.contentId = contentId;
    that.revisionId = revisionId;

    // Should be filled in by the caller
    that.content = null;
    that.revision = null;

    that.tenantRestContext = null; // Will be filled in by the login method

    // Some file systems don't like : in filenames.
    var safeContentId = contentId.replace(/:/g, '-');

    // The base directory for anything related to this piece of content.
    // When all the processing is done, this should contain a file called 'thumbnail.png' which can be used as
    // the piece of content's thumbnail image
    that.baseDir = path.resolve(config.previews.tmpDir + '/' + safeContentId);

    // Create the actual directory
    mkdirp.sync(that.baseDir);

    /**
     * Removes the directory where all images should be stored in.
     */
    that.cleanup = function() {
        log().trace({'contentId': contentId}, 'Removing %s', that.baseDir);
        try {
            rimraf.sync(that.baseDir);
        } catch (err) {
            log().error({'err': err, 'contentId': contentId}, 'Error cleaning up temporary files');
        }
    };

    /**
     * Logs into the the tenant where this piece of content resides. If we already have a running
     * session for this tenant, it will be re-used.
     *
     * @param  {Function}    callback        Standard callback function
     * @param  {Object}      callback.err    An error that occurred, if any
     */
    that.login = function(callback) {
        var tenantAlias = that.contentId.split(':')[1];
        log().trace({'contentId': contentId}, 'Logging into %s', tenantAlias);

        // Log in via signed auth, and get a new RestContext
        RestAPI.Admin.getSignedTenantAuthenticationRequestInfo(globalRestContext, tenantAlias, function(err, requestInfo) {
            if (err) {
                log().error({'err': err, 'contentId': contentId}, 'We could not get signed authentication request info for the tenant. The status of the content item will not be set');
                return callback(err);
            }

            // Parse the URL we should use to authenticate to the tenant
            var parsedUrl = url.parse(requestInfo.url);

            // We need to try and use the internally configured host rather than using the external host,
            // so we extract the Host header portion from the suggested URI and replace the connection URI
            // with the internal host
            var protocol = parsedUrl.protocol;
            var hostHeader = parsedUrl.host;

            // Use internal address if configured
            var host = config.servers.serverInternalAddress || hostHeader;
            var restCtx = new RestContext(util.format('%s//%s', protocol, host), {'hostHeader': hostHeader, 'strictSSL': strictSSL});

            // Perform the actual login
            RestAPI.Admin.doSignedAuthentication(restCtx, requestInfo.body, function(err, body, response) {
                if (err) {
                    log().error({'err': err, 'contentId': contentId}, 'We could not log in on the tenant. The status of the content item will not be set');
                    return callback(err);
                }

                // Use this context for subsequent requests to the tenant
                that.tenantRestContext = restCtx;
                return callback();
            });
        });
    };

    /**
     * Gets the content profile and the revision object.
     * The data will be made available on the context at `content` and `revision`.
     *
     * @param  {Function}   callback        Standard callback function
     * @param  {Object}     callback.err    An error that occurred, if any
     */
    that.getContentData = function(callback) {
        RestAPI.Content.getContent(that.tenantRestContext, contentId, function(err, content) {
            if (err) {
                log().error({'err': err, 'contentId': contentId}, 'Could not get the content profile.');
                return callback(err);
            }

            // Stick the piece of content on the context.
            that.content = content;

            RestAPI.Content.getRevision(that.tenantRestContext, contentId, revisionId, function(err, revision) {
                if (err) {
                    log().error({'err': err, 'contentId': contentId, 'revisionId': revisionId}, 'Could not get the revision');
                    return callback(err);
                }

                // Stick the revision on the context.
                that.revision = revision;

                callback();
            });
        });
    };

    /**
     * Download the revision of the content item in context to a temporary file on disk.
     * It will be removed when the preview processing operation completes
     *
     * @param  {Function}   callback        Standard callback function
     * @param  {Object}     callback.err    An error that occurred, if any
     * @param  {String}     callback.path   The path on disk where the file has been downloaded to.
     */
    that.download = function(callback) {
        // For security reasons we will *NOT* use the actual filename
        // as this path could end up in commands that need to be executed.
        // We will tack on the extension if-and-only-if that extension only exists out of a-zA-Z characters.
        var extension = 'unknown';
        var name = that.revision.filename;
        if (name.lastIndexOf('.') !== -1) {
            var ext = name.substr(name.lastIndexOf('.') + 1);
            if (ext !== '' && extensionRegex.test(ext)) {
                extension = ext;
            }
        }

        var path = that.baseDir + '/' + safeContentId + '.' + extension;
        log().trace({'contentId': contentId}, 'Downloading %s to %s', that.revision.filename, path);
        RestAPI.Content.download(that.tenantRestContext, contentId, revisionId, path, function(err) {
            if (err) {
                log().error({'err': err, 'contentId': contentId}, 'Error trying to download the file');
                fs.unlink(path, function(unlinkErr) {
                    if (unlinkErr) {
                        log().error({'err': unlinkErr, 'contentId': contentId}, 'Could not remove the downloaded file on download error');
                    }
                    callback(err);
                });
            } else {
                callback(null, path);
            }
        });
    };

    /**
     * Sets the path to the thumbnail image.
     *
     * @param  {String} path The path where the thumbnail image is located.
     */
    that.setThumbnail = function(path) {
        _thumbnailPath = path;
    };

    /**
     * Adds a preview image.
     *
     * @param  {String} path The path where a preview image is located.
     * @param  {String} size The size of this file. One of 'small', 'medium', 'large', 'activity' or 'thumbnail'.
     */
    that.addPreview = function(path, size) {
        _previews.push({'path': path, 'size': size});
    };

    /**
     * Any extra metadata that should be stored on the content item in the previews object.
     *
     * @param  {String}     name    The key that should be used on the piece of content. (ex: pageCount)
     * @param  {String}     value   The value. (ex: 7)
     */
    that.addPreviewMetadata = function(name, value) {
        _previewMetadata[name] = value;
    };

    /**
     * @return {Object} An object that holds the extra preview metadata that should be stored. Any changes made to this object will be passed along the the `savePreviews` method.
     */
    that.getPreviewMetadata = function() {
        return _previewMetadata;
    };

    /**
     * Any extra metadata that should be stored on the content item. Items such as `displayName`, `description`, .. can be passed in here.
     *
     * @param  {String}     name    The key that should be used on the piece of content. (ex: displayName)
     * @param  {String}     value   The value
     */
    that.addContentMetadata = function(name, value) {
        _contentMetadata[name] = value;
    };

    /**
     * @return {Object} An object that holds the extra content metadata that should be stored. Any changes made to this object will be passed along the the `savePreviews` method.
     */
    that.getContentMetadata = function() {
        return _contentMetadata;
    };

    /**
     * @return {Object[]}  An array of preview objects. Each object has a 'path' key that specifies where the preview is stored and a 'size' key that specifies which type of preview this is.
     */
    that.getPreviews = function() {
        return _previews;
    };

    /**
     * @return {String}    The path to the thumbnail
     */
    that.getThumbnail = function() {
        return _thumbnailPath;
    };

    /**
     * Saves the preview and thumbnail images.
     * This will also set the preview status to 'done'.
     * Processors generally shouldn't have to call this themselves.
     *
     * @param  {Function}    callback        Standard callback function
     * @param  {Object}      callback.err    An error that occurred, if any
     */
    that.savePreviews = function(callback) {
        log().trace({'contentId': contentId}, 'Saving previews');
        var files = {};
        var sizes = {};
        // The thumbnail (if any)
        if (_thumbnailPath) {
            files['thumbnail.png'] = function() { return fs.createReadStream(_thumbnailPath); };
            sizes['thumbnail.png'] = 'thumbnail';
        }

        // The preview images.
        _previews.forEach(function(preview) {
            var filename;
            // Local paths start with a '/'
            if (preview.path.match(/^\//)) {
                filename = path.basename(preview.path);
                files[filename] = function() { return fs.createReadStream(preview.path); };
            } else {
                filename = path.basename(preview.path);
                files[filename] = preview.path;
            }
            sizes[filename] = preview.size;
        });

        _status = 'done';
        RestAPI.Content.setPreviewItems(that.tenantRestContext, contentId, revisionId, 'done', files, sizes, _contentMetadata, _previewMetadata, callback);
    };

    /**
     * Sets the processing status on the piece of content.
     *
     * @param  {String}     status      The status that should be set. One of ContentConstants.previews
     * @param  {Function}   callback    Standard callback function
     */
    that.setStatus = function(status, callback) {
        log().trace({'contentId': contentId}, 'Setting status to %s', status);
        _status = status;
        RestAPI.Content.setPreviewItems(that.tenantRestContext, contentId, revisionId, status, {}, {}, {}, {}, callback);
    };

    /**
     * Gets the processing status of the piece of content.
     *
     * @return {String} The processing status of the piece of content
     */
    that.getStatus = function() {
        return _status;
    };

    return that;
};
