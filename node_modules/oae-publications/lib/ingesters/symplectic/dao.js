/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var AuthenticationDAO = require('oae-authentication/lib/internal/dao');
var Cassandra = require('oae-util/lib/cassandra');
var log = require('oae-logger').logger('oae-publications-symplectic');

var PublicationsConfig = require('oae-config').config('oae-publications');

/**
 * Sets the timestamp when a run was initiated for a tenant
 *
 * @param  {String}     tenantAlias             The alias of the tenant for which we should retrieve the last time we ran a synchronization
 * @param  {Number}     [lastFullRun]           The timestamp the last full synchronization was *started*. If not provided, `lastIncrementalRun` should be provided
 * @param  {Number}     [lastIncrementalRun]    The timestamp the last incremental sychronization was *started*. If not provided, `lastFullRun` should be provided
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            Standard error object, if any
 */
var setLastRunTimes = module.exports.setLastRunTimes = function(tenantAlias, lastFullRun, lastIncrementalRun, callback) {
    var parameters = {};

    if (lastFullRun) {
        parameters.lastFullRun = lastFullRun;
    }
    if (lastIncrementalRun) {
        parameters.lastIncrementalRun = lastIncrementalRun;
    }

    var q = Cassandra.constructUpsertCQL('Symplectic', 'tenantAlias', tenantAlias, parameters, 'QUORUM');
    Cassandra.runQuery(q.query, q.parameters, callback);
};

/**
 * Gets the timestamps when we last did a full and/or incremental synchronization update for a tenant
 *
 * @param  {String}     tenantAlias                     The alias of the tenant for which we should retrieve the last time we ran a synchronization
 * @param  {Object}     callback.err                    Standard error object, if any
 * @param  {Function}   callback                        Standard callback function
 * @param  {Number}     callback.lastFullRun            The timestamp when we did our last full run, will be null if we've never done a full run
 * @param  {Number}     callback.lastIncrementalRun     The timestamp when we did our last incremental run, will be null if we've never done a full run
 */
var getLastRunTimes = module.exports.getLastRunTimes = function(tenantAlias, callback) {
    Cassandra.runQuery('SELECT lastFullRun, lastIncrementalRun FROM Symplectic WHERE tenantAlias = ?', [tenantAlias], function(err, rows) {
        if (err) {
            return callback(err);
        } else if (rows[0].count <= 1) {
            return callback();
        }

        var lastFullRun = null;
        var lastIncrementalRun = null;

        if (rows[0].get('lastFullRun') && rows[0].get('lastFullRun').value) {
            var lastFullRunDate = rows[0].get('lastFullRun').value;
            lastFullRun = lastFullRunDate.getTime();
        }
        if (rows[0].get('lastIncrementalRun') && rows[0].get('lastIncrementalRun').value) {
            var lastIncrementalRunDate = rows[0].get('lastIncrementalRun').value;
            lastIncrementalRun = lastIncrementalRunDate.getTime();
        }

        return callback(null, lastFullRun, lastIncrementalRun);
    });
};

/**
 * Adds a user to the list for retrieval on later incremental synchronizations
 *
 * @param  {String}     tenantAlias             The alias of the tenant for which were retrieving the publications
 * @param  {String}     user.oaeUserId          The user ID of this user within OAE
 * @param  {String}     [user.externalUserId]   The user ID that identifies this user in Symplectic
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            Standard error object, if any
 */
var addUserToRetryList = module.exports.addUserToRetryList = function(tenantAlias, user, callback) {
    callback = callback || function(err) {
        if (err) {
            return log().error({'err': err, 'user': user}, 'Unable to store user in retry list');
        }
    };

    var parameters = {};
    parameters[user.oaeUserId] = user.externalUserId || '';

    var q = Cassandra.constructUpsertCQL('SymplecticUsers', 'tenantAlias', tenantAlias, parameters, 'QUORUM');
    Cassandra.runQuery(q.query, q.parameters, callback);
};

/**
 * Gets a set of users that should be retried
 *
 * @param  {String}     tenantAlias             The alias of the tenant for which were retrieving the users
 * @param  {String}     start                   The user ordering token from which to start fetching users (see `nextToken` in callback params)
 * @param  {Number}     limit                   The amount of users that should be retrieved, defaults to `25`
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            Standard error object, if any
 * @param  {Object[]}   callback.users          An array of objects where each object represents a user. Each object will have an `externalUserId` and a `oaeUserId`
 * @param  {String}     callback.nextToken      The value to provide in the `start` parameter to get the next set of results
 */
var getUsersFromRetryList = module.exports.getUsersFromRetryList = function(tenantAlias, start, limit, callback) {
    Cassandra.runPagedColumnQuery('SymplecticUsers', 'tenantAlias', tenantAlias, start, limit, {'reversed': true}, function(err, columns, nextToken) {
        if (err) {
            return callback();
        }

        var users = {};
        var externalIdsToRetrieve = [];
        _.each(columns, function(column) {
            var oaeUserId = column.name;
            var user = {
                'oaeUserId': oaeUserId
            };

            var externalUserId = column.value;
            if (externalUserId) {
                user.externalUserId = externalUserId;
            } else {
                externalIdsToRetrieve.push(user.oaeUserId);
            }

            users[oaeUserId] = user;
        });

        AuthenticationDAO.getUsersLoginIds(externalIdsToRetrieve, function(err, loginIdsPerUser) {
            if (err) {
                return callback();
            }

            var authenticationStrategy = PublicationsConfig.getValue(tenantAlias, 'symplectic', 'authenticationStrategy');
            _.each(loginIdsPerUser, function(loginIds, userId) {
                if (loginIds[authenticationStrategy]) {
                    users[userId].externalUserId = loginIds[authenticationStrategy].externalId.toLowerCase();
                } else {
                    // This user doesn't have a loginId for the configured authentication strategy which means we can't look him up in Symplectic
                    // There's no point in him being in this list then
                    delete users[userId];
                }
            });
            
            return callback(null, _.values(users), nextToken);
        });

    });
};

/**
 * Removes a set of users from the list of users that should be retried for a tenant
 *
 * @param  {String}     tenantAlias     The alias of the tenant for which were removing the users
 * @param  {String[]}   users           An array of OAE user ids that should no longer be retried
 * @param  {Function}   callback        Standard callback function
 * @param  {object}     callback.err    Standard error object, if any
 */
var deleteUsersFromRetryList = module.exports.deleteUsersFromRetryList = function(tenantAlias, users, callback) {
    if (_.isEmpty(users)) {
        return callback();
    }

    Cassandra.runQuery('DELETE ? FROM SymplecticUsers WHERE tenantAlias = ?', [users, tenantAlias], callback);
};

/**
 * Clear the list of users that should retried for a tenant
 *
 * @param  {String}     tenantAlias     The alias of the tenant for which were removing the users
 * @param  {Function}   callback        Standard callback function
 * @param  {object}     callback.err    Standard error object, if any
 */
var deleteAllUsersFromRetryList = module.exports.deleteAllUsersFromRetryList = function(tenantAlias, callback) {
    Cassandra.runQuery('DELETE FROM SymplecticUsers WHERE tenantAlias = ?', [tenantAlias], callback);
};
