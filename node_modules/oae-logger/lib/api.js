/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var bunyan = require('bunyan');

// The logger to use when no logger is specified
var SYSTEM_LOGGER_NAME = 'system';

// Logger state variables to record active loggers and current configuration
var config = null;
var loggers = {};

/**
 * Refresh the log configuration of all the cached logs with that of the provided log configuration.
 *
 * @param  {Object}     newConfig   The new configuration to apply to all the loggers
 */
var refreshLogConfiguration = module.exports.refreshLogConfiguration = function(newConfig) {
    logger('oae-logger')().info('Refreshing log configuration');
    config = newConfig;
    _refreshLogConfigurations();
};

/**
 * Create / retrieve a logger with the provided name.
 *
 * @param  {String}     name   The name of the logger, this name will be used to identify this logger for potentially custom log configuration
 * @return {Function}          A function that can be used to retrieve the logger takes argument `ctx`
 */
var logger = module.exports.logger = function(name) {
    name = name || SYSTEM_LOGGER_NAME;

    // Lazy-load the logger and cache it so new loggers don't have to be recreated all the time
    if (!loggers[name]) {
        loggers[name] = _createLogger(name);
    }

    // Return a function that returns the logger. this is the only way we can reserve the ability to refresh the logger
    // configuration on the fly. At the moment the "ctx" param is not used, however it is planned to be able to have
    // tenant/user-specific configuration or ctx-specific information in the log entries
    return function(ctx) {
        return loggers[name];
    };
};

/**
 * Update all the existing loggers to be configured with the current configuration.
 *
 * @api private
 */
var _refreshLogConfigurations = function() {
    _.each(loggers, function(logger, name) {
        loggers[name] = _createLogger(name);
    });
};

/**
 * Create a logger with the provided name.
 *
 * @param  {String}     name    The name to assign to the created logger
 * @api private
 */
var _createLogger = function(name) {
    var _config = _.extend({}, config || _resolveBootstrapLoggerConfig());
    _config.name = name;
    return bunyan.createLogger(_config);
};

/**
 * Determine what the default bootstrap logger configuration should be.
 *
 * @return {Object}    The log configuration to use by default
 * @api private
 */
var _resolveBootstrapLoggerConfig = function() {
    var bootstrapConfig = {
        'streams': [{
            'level': process.env['OAE_BOOTSTRAP_LOG_LEVEL'] || 'debug'
        }],
        'serializers': {
            'err': bunyan.stdSerializers.err
        }
    };

    var bootstrapLogFile = process.env['OAE_BOOTSTRAP_LOG_FILE'];
    if (bootstrapLogFile) {
        bootstrapConfig.streams[0].path = bootstrapLogFile;
    } else {
        bootstrapConfig.streams[0].stream = process.stdout;
    }

    return bootstrapConfig;
};
