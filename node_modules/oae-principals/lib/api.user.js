/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var time = require('time');
var Bcrypt = require('bcrypt');
var sanitize = require('validator').sanitize;
var time = require('time');

var AuthzAPI = require('oae-authz');
var Resource = require('oae-authz/lib/model').Resource;
var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var Validator = require('oae-util/lib/validator').Validator;

var PrincipalsAPI = require('./api');
var PrincipalsModel = require('./model');
var PrincipalsUtil = require('./util');


/**
 * Creates a new user under this tenant.
 *
 * @param  {Context}                    ctx                 The current context
 * @param  {String}                     username            The username this user can login with.
 * @param  {String}                     password            The password for this user.
 * @param  {String}                     visibility          This user his visibility setting. (One of VISIBILITY_OPTIONS)
 * @param  {String}                     locale              The user his locale
 * @param  {String}                     timezone            The user his timezone
 * @param  {String}                     firstName           This user his first name.
 * @param  {String}                     lastName            This user his last name,
 * @param  {String}                     displayName         A display name, if this is left undefined the first and last name will be concatenated.
 * @param  {Function(err, userId)}      callback            Callback method.
 * @param  {Object}                     callback.err        Error object if something goes wrong.
 * @param  {String}                     callback.userId     The user ID.
 */
module.exports.createUser = function(ctx, username, password, visibility, locale, timezone, firstName, lastName, displayName, callback) {
    callback = callback || function() {};
    locale = locale || 'en_GB';
    timezone = timezone || time.currentTimezone;
    visibility = visibility || PrincipalsModel.VISIBILITY_OPTIONS.PUBLIC;

    var validator = new Validator();
    validator.check(username, {'code': 400, 'msg': 'A username must be provided'}).notEmpty();
    validator.check(password, {'code': 400, 'msg': 'A password must be provided'}).notEmpty();
    validator.check(username, {'code': 400, 'msg': 'A username can\'t contain a colon.'}).notContains(':');
    validator.check(username, {'code': 400, 'msg': 'A username has an upper limit of 250 characters.'}).max(250);
    validator.check(password, {'code': 400, 'msg': 'Your password is too short (this is the only password requirement.)'}).len(6);
    validator.check(visibility, {'code': 400, 'msg': 'The specified visibility setting is unknown.'}).isIn(_.values(PrincipalsModel.VISIBILITY_OPTIONS));
    validator.check(timezone, {'code': 400, 'msg': 'The specified timezone is invalid'}).isValidTimeZone();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    var clean_username = PrincipalsUtil.cleanName(username);

    // hash the password and store everything in the DB.
    var id = AuthzUtil.toUuid('u', ctx.tenant().alias, clean_username);
    module.exports.getUser(ctx, id, function(err, user) {
        if (!err && user) {
            return callback({'code': 400, 'msg': 'A user with this username already exists.'});
        }

        PrincipalsUtil.hashPassword(password, function(hash) {
            displayName = displayName || firstName + " " + lastName;
            // Create the user
            Cassandra.runQuery('INSERT INTO Principals (principal_id, tenant, visibility, locale, timezone, user_username, user_password, user_first_name, user_last_name, user_display_name) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?) USING CONSISTENCY QUORUM', 
                                [id, ctx.tenant().alias, visibility, locale, timezone, username, hash, firstName, lastName, displayName], function (err) {
                if (err) {
                    return callback(err);
                } 
                callback(false, id);
            });
        });
    });
};

/**
 * Update a user
 *
 * @param  {Context}        ctx             The current context.
 * @param  {String}         userId          The userid of the user you wish to update.
 * @param  {Object}         profileFields   Object that represent the profile fields that should be updated.
 *                                          Possible keys are visibility, user_first_name, user_last_name,
 *                                          user_display_name, locale and timezone
 * @param  {Function(err)}  callback        Callback method.
 * @param  {Object}         callback.err    Error object if something goes wrong.
 */
module.exports.updateUser = function(ctx, userId, profileFields, callback) {
    callback = callback || function() {};
    profileFields = profileFields || {};
    
    // Parameter validation
    var validator = new Validator();
    validator.check(userId, {'code': 400, 'msg': 'A user id must be provided'}).notEmpty();
    // Check that there is at least one updated profile field.
    validator.check(_.keys(profileFields).length, {'code': 400, 'msg': 'At least one basic profile field should be specified.'}).min(1);
    // In case a new visibility has been passed in, we check for its validity
    if (profileFields['visibility']) {
        validator.check(profileFields['visibility'], {'code': 400, 'msg': 'An invalid visibility option has been passed on'}).isIn(_.values(PrincipalsModel.VISIBILITY_OPTIONS));
    }
    if (profileFields['timezone']) {
        validator.check(profileFields['timezone'], {'code': 400, 'msg': 'The specified timezone is invalid'}).isValidTimeZone();
    }
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a user'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    
    // Only update existing users.
    module.exports.getUser(ctx, userId, function(err, user) {
        if (err) {
            return callback(err);
        }

        // Only the current user or an admin can update a user.
        var principalResource = AuthzUtil.getResourceFromUuid(userId);
        if (ctx.user().id === userId || ctx.user().isAdmin(principalResource.tenantId)) {
            var q = Cassandra.constructUpsertCQL('Principals', 'principal_id', userId, profileFields, 'QUORUM');
            if (!q) {
                return callback({'code': 500, 'msg': 'Unable to store profile fields'});
            }
            Cassandra.runQuery(q.query, q.parameters, callback);
        } else {
            callback({'code': 401, 'msg': 'You cannot update this user his profile.'});
        }
    });
};

/**
 * Get the user within a tenant (determined from the ctx)
 *
 * @param  {Context}                ctx             The current context
 * @param  {String}                 username        The username to look on
 * @param  {Function(err, user)}    callback        Callback method
 * @param  {Object}                 callback.err    Error object if something goes wrong.
 * @param  {Object}                 callback.user   The user object.
 */
module.exports.getTenantUser = function(ctx, username, callback) {
    username = PrincipalsUtil.cleanName(username);
    var userId = AuthzUtil.toUuid('u', ctx.tenant().alias, username);
    module.exports.getUser(ctx, userId, callback);
};

/**
 * Get a user from the DB
 *
 * @param  {Context}                ctx             The current context
 * @param  {String}                 userId          The userid for the user you wish to retrieve.
 * @param  {Function(err, user)}    callback        Callback method.
 * @param  {Object}                 callback.err    Error object if something goes wrong.
 * @param  {Object}                 callback.user   The user objct.
 */
module.exports.getUser = function(ctx, userId, callback) {
    if (!userId || !PrincipalsUtil.isUser(userId)) {
        return callback({'code': 400, 'msg': 'The provided userId is not a valid user identifier.'});
    }

    PrincipalsUtil.getPrincipal(ctx, userId, callback);
};

/**
 * Gets the basic profile for a user.
 * The user's visibility setting determines what the profile hash will contain.
 * {
 *   'profilePath': '/person/simong',
 *   'userId': 'u:cam:simong',
 *   'isFollowing': true,
 *   'accountPermissions': 'public',
 *   'proﬁle': {
 *       'ﬁrstName': 'Simon',
 *       'lastName': 'Gaeremynck',
 *       'displayName': 'Simon "simong" Gaeremynck'
 *       'picture': 'pathToCroppedProﬁlePicture'
 *   }
 * };
 *
 * @param  {Context}  ctx           The current context
 * @param  {String}   userId        The id of the user for which the profile should be retrieved.
 * @param  {Object}   callback.err  Error object if something goes wrong.
 * @param  {Object}   callback.user The user.
 */
module.exports.getBasicProfile = function(ctx, userId, callback) {
    // Anonymous is a bit of a special case.
    module.exports.getUser(ctx, userId, function(err, user) {
        if (err) {
            return callback(err);
        }
        var data = {
            'profilePath': '/person/' + userId,
            'userId': user.id,
            'visibility': user.visibility,
            'profile': {
                'firstName': user.firstName,
                'lastName': user.lastName,
                'displayName': user.displayName,
            }
        };

        var keys = _.keys(user.extra);
        for (var i = 0; i < keys.length; i++) {
            data.profile[keys[i]] = user.extra[keys[i]];
        }

        callback(null, data);
    });
};

/**
 * Gets the me feed for the current user, if anonymous returns 'anon': true
 * If logged in returns structured me feed object in the callback
 *  {
 *     "profilePath": "/person/u:global:bert",
 *     "userId": "u:global:bert",
 *     "visibility": "private",
 *     "isTenantAdmin": true,
 *     "isGlobalAdmin": false,
 *     "profile": {
 *         "firstName": "Bert",
 *         "lastName": "Pareyn",
 *         "displayName": "Bert Pareyn"
 *     },
 *     "locale": {
 *         "locale": "en_GB",
 *         "timezone": {
 *             "name": "Europe/London",
 *             "offset": 1
 *         }
 *     }
 * }
 * If error returns error object
 * @param  {Context}              ctx            The current context
 * @param  {String}               user           The user the me feed is for
 * @param  {Function(err, data)}  callback       Callback method.
 * @param  {Object}               callback.err   Error object if something goes wrong.
 * @param  {Object}               callback.data  The me feed data for the user.
 */
module.exports.getMe = function(ctx, user, callback) {
    if (ctx.user() === undefined || ctx.user() === null) {
        return callback({'code': 200,'msg': {'anon': true}});
    }

    PrincipalsAPI.getBasicProfile(ctx, user.id, function(err, data) {
        if (err) {
            return callback(err);
        }

        // calculate timezone offset in hours.
        var now = new time.Date();
        now.setTimezone(ctx.user().timezone);
        var offset = -1 * now.getTimezoneOffset() / 60;

        data.isTenantAdmin = ctx.user().isTenantAdmin(ctx.user().tenant);
        data.isGlobalAdmin = ctx.user().isGlobalAdmin();

        data.locale = {
            'locale': ctx.user().locale,
            'timezone': {
                'name': ctx.user().timezone,
                'offset': offset
            }
        };

        callback(null, data);
    });
};

/**
 * Sets the visibility of a user.
 *
 * @param {Context}         ctx             A context object representing the current user.
 * @param {String}          userId          The ID of the user that needs the visibility change.
 * @param {String}          visibility      The desired visibility. Valid options are defined in @see PrincipalsModel.VISIBILITY_OPTIONS
 * @param {Function(err)}   callback        Callback method.
 * @param {String}          callback.err    Error object.
 */
module.exports.setUserVisibility = function(ctx, userId, visibility, callback) {
    callback = callback || function() {};
    validator = new Validator();
    validator.check(visibility, {'code': 400, 'msg': 'The specified visibility setting is unknown.'}).isIn(_.values(PrincipalsModel.VISIBILITY_OPTIONS));
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    var principalResource = AuthzUtil.getResourceFromUuid(userId);
    if (ctx.user().id === userId || ctx.user().isAdmin(principalResource.tenantId)) {
        module.exports.getUser(ctx, userId, function(err, user) {
            if (err) {
                return callback(err);
            }
            Cassandra.runQuery('UPDATE Principals USING CONSISTENCY QUORUM SET visibility=? WHERE principal_id = ?', [visibility, userId], callback);
        });
    } else {
        return callback({'code': 401, 'msg': 'You\'re not authorized to change someone else their profile!'});
    }
};

/**
 * Checks if a password matches a username within a tenant.
 *
 * @param  {Object}                 tenant          The current tenant
 * @param  {String}                 username        The username that a user uses to login. (NOT the id.)
 * @param  {String}                 password        The plain-text password.
 * @param  {Function(err, user)}    callback        Callback method.
 * @param  {Object}                 callback.err    Error object.
 * @param  {Object}                 callback.user   An object that has a key 'id' that holds the full user id.
 *                                                  This object will be null if the user was not found or the password didn't match.
 */
module.exports.checkPassword = function(tenant, username, password, callback) {
    var userId = AuthzUtil.toUuid('u', tenant.alias, username);
    checkPasswordForUserId(userId, password, callback);
};

/**
 * Changes the password of a user.
 *
 * @param  {Context}  ctx         The current context.
 * @param  {String}   userId      The user id of the user whose password that needs to be changed.
 * @param  {String}   oldPassword The old password that can be used to authenticate this change request.
 * @param  {String}   newPassword The new password.
 * @param  {Function} callback    [description]
 */
module.exports.changePassword = function(ctx, userId, oldPassword, newPassword, callback) {

    var changePassword = function() {
        // Hash and store it.
        PrincipalsUtil.hashPassword(newPassword, function(hash) {
            Cassandra.runQuery("UPDATE Principals USING CONSISTENCY QUORUM SET user_password=? WHERE principal_id = ?", [hash, userId], function(err, rows) {
                if (err) {
                    return callback(err, false);
                }

                callback(null, true);
            });
        });
    };

    // Global admins can change passwords.
    var principalResource = AuthzUtil.getResourceFromUuid(userId);
    if (ctx.user().isAdmin(principalResource.tenantId)) {
        return changePassword();
    }

    // Otherwise the password must match.
    checkPasswordForUserId(userId, oldPassword, function(err, user) {
        if (!err && user) {
            return changePassword();
        }

        // By this point this user shouldn't be allowed to do anything.
        return callback({'code': 401, 'msg': 'You\'re not authorized to change this user\'s password.'}, false);
    });
};

/**
 * Checks the password for a specified user id.
 *
 * @param  {String}             userId      The id of the user whose password should be checked.
 * @param  {String}             password    The password that can be used to compare with the one in the DB.
 * @param  {Function(err, id)}  callback    Callback method
 * @param  {Object}             err         Error object
 * @param  {object}             id          The ID of the user if the passwords match. Otherwise false.
 */
var checkPasswordForUserId = function(userId, password, callback) {
    Cassandra.runQuery("SELECT user_password FROM Principals USING CONSISTENCY QUORUM WHERE principal_id = ?", [userId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        if (rows[0].count === 0) {
            // No user found with that username.
            return callback({'code': 401, 'msg': 'No password found for this principal'});
        }

        Bcrypt.compare(password, rows[0].get('user_password').value, function(err, res) {
            if (!res) {
                callback({'code': 401, 'msg': 'User name and/or password do not match.'});
            } else {
                callback(false, {'id': userId});
            }
        });
    });
};

/**
 * Set a flag that indicates whether a user is a tenant admin.
 * The ctx user must be a tenant or global admin to be able to do this.
 *
 * @param  {Context}        ctx             Context that holds the tenant.
 * @param  {User}           principalId     The user that needs the flag
 * @param  {Boolean}        isAdmin         Flag that indicates whether the provided user should be a tenant admin.
 * @param  {Function(err)}  callback        Callback method
 * @param  {Object}         callback.err    Error object.
 */
module.exports.setTenantAdmin = function(ctx, principalId, isAdmin, callback) {
    var principalResource = AuthzUtil.getResourceFromUuid(principalId);
    if (ctx.user() && (ctx.user().isTenantAdmin(principalResource.tenantId) || ctx.user().isGlobalAdmin())) {
        _setAdmin(ctx, 'admin:tenant', isAdmin, principalId, callback);
    } else {
        return callback({'code': 401, 'msg': 'You do not have sufficient rights to make someone an admin.'});
    }
};

/**
 * Set a flag that indicates whether a user is a glbal admin.
 * The ctx user must be a global admin to be able to do this.
 *
 * @param  {Context}        ctx             Context that holds the tenant.
 * @param  {User}           user            The user that needs the flag
 * @param  {Boolean}        isAdmin         Flag that indicates whether the provided user should be a global admin.
 * @param  {Function(err)}  callback        Callback method
 * @param  {Object}         callback.err    Error object.
 */
module.exports.setGlobalAdmin = function(ctx, principalId, isAdmin, callback) {
    if (ctx.user() && ctx.user().isGlobalAdmin()) {
        _setAdmin(ctx, 'admin:global', isAdmin, principalId, callback);
    } else {
        return callback({'code': 401, 'msg': 'You do not have sufficient rights to make someone an admin.'});
    }
};

/**
 * Internal method that makes a user an admin. This method will do all the necessary validation
 * of the user ctx and passed in parameters.
 *
 * @param  {Context}        ctx             Context that holds the current user and tenant.
 * @param  {String}         adminType       One of admin:global` or `admin:tenant`
 * @param  {Boolean}        isAdmin         Flag that indicates whether this user should be an admin or not.
 * @param  {String}         principalId     The uuid of the user that needs to be made an admin.
 * @param  {Function(err)}  callback        Callback method
 * @param  {Object}         callback.err    Error object.
 * @private
 */
var _setAdmin = function(ctx, adminType, isAdmin, principalId, callback) {
    if (!PrincipalsUtil.isUser(principalId)) {
        return callback({'code': 400, 'msg': 'The provided principalId is not a user.'});
    }
    // Double-check that this user exists.
    module.exports.getUser(ctx, principalId, function(err, user) {
        // If we get an error, this user does not exist.
        if (err) {
            return callback(err);
        }

        // Sanitize input and store it in cassandra.
        isAdmin = sanitize(isAdmin).toBooleanStrict();
        Cassandra.runQuery("UPDATE Principals USING CONSISTENCY QUORUM SET ?=? WHERE principal_id = ?", [adminType, isAdmin, principalId], callback);
    });
};
