/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var ShortId = require('shortid');

var Context = require('oae-context').Context;
var Validator = require('oae-util/lib/validator').Validator;
var Cassandra = require('oae-util/lib/cassandra');
var PrincipalUtil = require('oae-principals/lib/utils');
var RolesAPI = require('oae-roles');
var PermissionsAPI = require('oae-permissions');
var RolesUtil = require('oae-roles/lib/util');

var Content = require('./model').Content;
var ContentConstants = require('./model').Constants;


///////////////////////////////////
// Retrieving a piece of content //
///////////////////////////////////

/**
 * Get a content's basic profile information based on a pooled content id
 * @param  {Context}                    ctx                 Standard context object, representing the currently logged user and its tenant
 * @param  {String}                     contentId           The id of the content object we want to retrieve
 * @param  {Function(err, contentObj)}  callback            Standard callback function
 * @param  {Object}                     callback.err        Error object containing the error message
 * @param  {Content}                    callback.contentObj Retrieved content object
 */
var getContent = module.exports.getContent = function(ctx, contentId, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'contentId': 400, 'msg': 'A content id must be provided'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getErrors());
    }

    // Retrieve the piece of content from Cassandra
    Cassandra.runQuery('SELECT * FROM Content WHERE contentId = ?', [contentId], function (err, rows) {
        if (err) {
            return callback({'code': 500, 'msg': err});
        }

        // Cassandra always returns the key as a column so the _colCount will always be 1.
        if (rows[0]._colCount === 1) {
            return callback({'code': 404, 'msg': "Couldn't find content: " + contentId}, null);
        }

        var contentObj = _rowToContent(rows[0]);
        _hasAccess(ctx, contentObj, function(err, hasAccess) {
            if (err) {
                return callback(err);
            } else if (!hasAccess) {
                return callback({'code': 401, 'msg': 'You don\'t have access to this piece of content'});
            }
            callback(null, contentObj);
        });
    });
};

/**
 * Internal function used to get multiple content basic profiles at the same time based on their content ids.
 * @param  {Array<String>}              contentIds          Array of content object ids we want to retrieve. 
 *                                                          The content profiles will be returned in the same order
 * @param  {Function(err, content)}     callback            Standard callback function
 * @param  {Object}                     callback.err        Error object containing the error message
 * @param  {Array<Content>}             callback.contentObj Retrieved content objects
 */
var _getMultipleContentItems = function(contentIds, callback) {
    if (contentIds.length) {
        Cassandra.runQuery("SELECT * FROM Content WHERE contentId IN (?)", [contentIds], function(err, rows) {
            if (err) {
                return callback(err);
            }
            // Iterate over the content items.
            for (var i = 0; i < rows.rowCount(); i++) {
                var contentObj = _rowToContent(rows[i]);
                contentIds[_.indexOf(contentIds, contentObj.contentId)] = contentObj;
            }
            callback(null, contentIds);
        });
    } else {
        callback(null, []);
    }
};

/////////////////////////////////////
// Creating a new piece of content //
/////////////////////////////////////

/**
 * Create a new piece of pooled content
 * @param  {Context}                 ctx               Standard context object containing the current user and the current tenant
 * @param  {User}                    currentUser       The principal uuid of the user creating the content. This user will also be added as a 
 *                                                     manager of the content
 * @param  {String}                  visibility        The visibility setting for the piece of content. Possible values are "public", "loggedin" 
 *                                                     and "private" [optional]
 * @param  {String}                  title             The display title for the piece of content
 * @param  {String}                  description       The description of the piece of content [optional]
 * @param  {String}                  contentType       The content type. Possible values are "file", "sakaidoc" and "link"
 * @param  {Function(err, content)}  callback          Standard callback function
 * @param  {Object}                  callback.err      Error object containing the error message
 * @param  {Object}                  callback.content  JSON object containing the pool id of the created content
 */
var createContent = module.exports.createContent = function(ctx, visibility, title, description, contentType, callback) {
    callback = callback || function() {};

    // Parameter validation
    var validator = new Validator();
    validator.check(title, {'code': 400, 'msg': 'A content title must be provided'}).notEmpty();
    validator.check(contentType, {'code': 400, 'msg': 'A content type must be provided. This can be "file", "sakaidoc" or "link"'}).isIn(ContentConstants.contentTypes);
    validator.check(ctx, {'code': 401, 'msg': 'You have to be logged in to be able to create a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getErrors());
    }

    // Setting content to public if no privacy setting is provided
    visibility = visibility || ContentConstants.visibility.PUBLIC;

    // Generate the content id
    var contentId = RolesUtil.toUuid('c', ctx.tenant().alias, ShortId.generate());
    var lastModified = new Date().getTime();
    description = description || '';

    // Create the content
    Cassandra.runQuery('INSERT INTO Content (contentId, tenant, visibility, title, description, contentType, lastModified) VALUES (?, ?, ?, ?, ?, ?, ?)', [contentId, ctx.tenant().alias, visibility, title, description, contentType, lastModified], function (err) {
        if (err) {
            callback({'code': 500, 'msg': err});
        } else {
            var contentObj = new Content(ctx.tenant().alias, contentId, visibility, title, description, contentType, lastModified);
            // Now make the current user a manager of the content
            var newPermissions = {};
            newPermissions[ctx.user().id] = ContentConstants.roles.MANAGER;
            _setContentPermissions(contentObj, newPermissions, function(err) {
                if (err) {
                    callback({'code': 500, 'msg': err});
                } else {
                    // Call the callback function and return the generated id
                    callback(false, {'contentId': contentId});
                }
            });
        }
    });
};

/////////////////////////////////
// Removing a piece of content //
/////////////////////////////////

/**
 * Delete a piece of content from the system
 * @param  {Context}            ctx               Standard context object containing the current user and the current tenant
 * @param  {String}             contentId         The content id of the content that is being deleted
 * @param  {Function(err)}      callback          Standard callback function
 * @param  {Object}             callback.err      Error object containing the error message
 */
module.exports.deleteContent = function(ctx, contentId, callback) {
    callback = callback || function() {};

    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).notEmpty();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to delete a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getErrors());
    }

    // Fist check whether or not the current user is a manager of the piece of content
    canManage(ctx, contentId, function(err, canManage, contentObj) {
        if (err) {
            return callback(err);
        } else if (!canManage) {
            return callback({'code': 401, 'msg': 'You are not allowed to manage this piece of content'});
        }
        // Get the members
        _getContentMembers(contentId, function(err, members) {
            if (err) {
                return callback(err);
            // Return if there are no members
            } else if (_.keys(members).length === 0) {
                return callback();
            }
            // Remove the roles and delete this from everyone's library
            for (var member in members) {
                if (members.hasOwnProperty(member)) {
                    members[member] = false;
                }
            }
            _setContentPermissions(contentObj, members, function(err) {
                if (err) {
                    return callback(err);
                }
                // Delete the ContentMembers row and delete the Content row
                var queries = [{
                    'query': 'DELETE FROM ContentMembers WHERE contentId = ?',
                    'parameters': [contentId]
                }, {
                    'query': 'DELETE FROM Content WHERE contentId = ?',
                    'parameters': [contentId]
                }];
                Cassandra.runBatchQuery(queries, function(err) {
                    if (err) {
                        return callback(err);
                    }
                    callback();
                });
            });
        }); 
    });
};

////////////////////////////
// Content access control //
////////////////////////////

/**
 * Share a piece of content with a set of principals. This only be possible when the current user is a manager of the content, or if the current
 * user is logged in and the content item is public or visible to logged in users only. In case that the content is shared with principals that
 * are already content members, no updates to the existing role of those principals will be made
 * @param  {Context}                 ctx               Standard context object containing the current user and the current tenant
 * @param  {String}                  contentId         The content id of the content that is being shared
 * @param  {Array<String>}           principalIds      Array of principal ids with whom the content will be shared. By default, they will
 *                                                     all be made members.
 * @param  {Function(err, content)}  callback          Standard callback function
 * @param  {Object}                  callback.err      Error object containing the error message
 */
var shareContent = module.exports.shareContent = function(ctx, contentId, principalIds, callback) {
    callback = callback || function() {};
    
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).notEmpty();
    validator.check(principalIds.length, {'code': 400, 'msg': 'The content must at least be shared with 1 user or group'}).min(1);
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to share content'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getErrors());
    }

    // Check if the user has access to the content
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }
        // Check if the content is visible to logged in users or public
        if (contentObj.visibility === ContentConstants.visibility.LOGGEDIN || contentObj.visibility === ContentConstants.visibility.PUBLIC) {
            _shareContent(contentObj, principalIds, callback);
        // Check if the user can manage the content
        } else {
            _canManage(ctx, contentId, function(err, canManage) {
                if (err) {
                    return callback(err);
                } else if (!canManage) {
                    return callback({'code': 401, 'msg': 'You are not allowed to share this content'});
                }
                _shareContent(contentObj, principalIds, callback);
            });
        }
    });
};

/**
 * Internal function used to share a piece of content with a set of principals. This function assume that the current user is allowed
 * to see and share the content. If some of the principals passed into this function are already content members, no updates to the 
 * existing role of those principals will be made.
 * @param  {Content}                 contentObj        Content object representing the content that is being shared
 * @param  {Array<String>}           principalIds      Array of principal ids with whom the content will be shared. By default, they will
 *                                                     all be made members.
 * @param  {Function(err, content)}  callback          Standard callback function
 * @param  {Object}                  callback.err      Error object containing the error message
 */
var _shareContent = function(contentObj, principalIds, callback) {
    // Get the current members and filter out the ones that are already a member, as we want to avoid
    // turning an existing manager into a viewer
    _getContentMembers(contentObj.contentId, function(err, members) {
        if (err) {
            return callback(err);
        }
        principalIds = _.without(principalIds, members);
        // Make all of the remaining principals a member
        var shareObject = {};
        for (var p = 0; p < principalIds.length; p++) {
            shareObject[principalIds[p]] = ContentConstants.roles.VIEWER;
        }
        
        _setContentPermissions(contentObj, shareObject, callback);
    });
};

/**
 * Check whether or not the current user can manage a piece of content
 * @param  {Context}                             ctx                 Standard context object, representing the currently logged user and its tenant
 * @param  {String}                              contentId           The id of the content object we want to check
 * @param  {Function(err, canManage, content)}   callback            Standard callback function
 * @param  {Object}                              callback.err        Error object containing the error message
 * @param  {Boolean}                             callback.canManage  Whether or not the user can manage the content
 * @param  {Content}                             callback.content    The retrieved content object containing its basic profile
 */
var canManage = module.exports.canManage = function(ctx, contentId, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).notEmpty();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to manage content'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getErrors());
    }

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            if (err.code === 401) {
                return callback(null, false);
            } else {
                return callback(err);
            }
        }
        _canManage(ctx, contentId, function(err, canManage) {
            if (err) {
                return callback(err);
            }
            callback(null, canManage, contentObj);
        });
    });
};

/**
 * Internal function that checks whether or not the current user can manage a piece of content. This function assumes that
 * the piece of content passed in actually exists
 * @param  {Context}                    ctx                 Standard context object, representing the currently logged user and its tenant
 * @param  {String}                     contentId           The id of the content object we want to check
 * @param  {Function(err, canManage)}   callback            Standard callback function
 * @param  {Object}                     callback.err        Error object containing the error message
 * @param  {Boolean}                    callback.canManage  Whether or not the user can manage the content
 */
var _canManage = function(ctx, contentId, callback) {
    PermissionsAPI.isAllowed(ctx.user().id, ContentConstants.roles.MANAGER, contentId, function(err, canManage) {
        if (err) {
            return callback(err);
        }
        callback(null, canManage);
    });
};

/**
 * Check whether or not the current user has access to a piece of content
 * @param  {Context}                    ctx                 Standard context object, representing the currently logged user and its tenant
 * @param  {String}                     contentId           The id of the content object we want to check
 * @param  {Function(err, hasAccess)}   callback            Standard callback function
 * @param  {Object}                     callback.err        Error object containing the error message
 * @param  {Boolean}                    callback.hasAccess  Whether or not the user has access to the content
 */
var hasAccess = module.exports.hasAccess = function(ctx, contentId, callback) {
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            // If the user doesn't have access to the content
            if (err.code ===  401) {
                return callback(null, false);
            } else {
                return callback(err);
            }
        }
        callback(null, true);
    });
};

/**
 * Internal function that checks whether or not the current user has access to a piece of content. This function assumes that
 * the piece of content passed in actually exists
 * @param  {Context}                    ctx                 Standard context object, representing the currently logged user and its tenant
 * @param  {String}                     contentId           The id of the content object we want to check
 * @param  {Function(err, canManage)}   callback            Standard callback function
 * @param  {Object}                     callback.err        Error object containing the error message
 * @param  {Boolean}                    callback.canManage  Whether or not the user has access to the content
 */
var _hasAccess = function(ctx, contentObj, callback) {
    // If the content is public, I always get access
    if (contentObj.visibility === ContentConstants.visibility.PUBLIC) {
        callback(null, contentObj);
    // If the content is visible to logged in people, I get access if I'm logged in
    } else if (contentObj.visibility === ContentConstants.visibility.LOGGEDIN) {
        if (ctx.user()) {
            callback(null, contentObj);
        } else {
            callback({'code': 401, 'msg': "You don't have access to this piece of content. Please try logging in"});
        }
    // If the content is private
    } else if (ctx.user()) {
        PermissionsAPI.isAllowedAny(ctx.user().id, contentObj.contentId, function(err, hasAccess) {
            if (err) {
                return callback(err);
            }
            callback(null, hasAccess);
        });
    } else {
        callback({'code': 401, 'msg': "You don't have access to this piece of content. Please try logging in"});
    }
};

/**
 * Update, add or remove the role of a set of principals on a piece of content
 * @param  {Context}         ctx                 Standard context object, representing the currently logged user and its tenant
 * @param  {String}          contentId           The id of the content object we want to set permissions on
 * @param  {Object}          newPermissions      Object where the keys represent the principal ids for which the content permissions
 *                                               should be updated/added/removed. The value is a string representing the new role. If
 *                                               false is passed in, the permissions for that principal will be removed
 *                                               e.g. {'user1': 'manager', 'user2': 'viewer', 'user3': false}
 * @param  {Function(err)}   callback            Standard callback function
 * @param  {Object}          callback.err        Error object containing the error message
 */
var setContentPermissions = module.exports.setContentPermissions = function(ctx, contentId, newPermissions, callback) {
    callback = callback || {};
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).notEmpty();
    validator.check(_.keys(newPermissions).length, {'code': 400, 'msg': 'You should specify at least 1 user/group to set content permissions on'}).min(1);
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to create a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getErrors());
    }

    // Check if the content exists
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }
        // Check if the current user can manage the content
        _canManage(ctx, contentId, function(err, canManage) {
            if (err) {
                return callback(err);
            } else if (!canManage) {
                return callback({'code': 401, 'msg': 'You are not allowed to manage this piece of content'});
            }
            // Check if all of the provided principals exist
            var principalsToCheck = _.keys(newPermissions); 
            var principalsNotFound = [];
            var done = 0;
            principalsToCheck.forEach(function(p) {
                // Check if all of the principals actually exist
                // TODO: Move this out to a principal API function
                PrincipalUtil.getPrincipal(p, function(err, principal) {
                    if (err) {
                        principalsNotFound.push(err);
                    }
                    done++;
                    if (done === principalsToCheck.length) {
                        if (principalsNotFound.length) {
                            callback({'code': 500, 'msg': principalsNotFound});
                        } else {
                            // Add the new permissions to the content. This will then update the libraries as well
                            _setContentPermissions(contentObj, newPermissions, function(err) {
                                if (err) {
                                    return callback(err);
                                }
                                callback(null);
                            });
                        }
                    }
                });
            });
        });
    });
};

/**
 * Internal function used to update, add or remove the role of a set of principals on a piece of content. This function will assume that
 * the content object exists and that the current user is a manager of the content
 * @param  {Content}         contentObj          The content object we want to set permissions on
 * @param  {Object}          newPermissions      Object where the keys represent the principal ids for which the content permissions
 *                                               should be updated/added/removed. The value is a string representing the new role. If
 *                                               false is passed in, the permissions for that principal will be removed
 *                                               e.g. {'user1': 'manager', 'user2': 'viewer', 'user3': false}
 * @param  {Function(err)}   callback            Standard callback function
 * @param  {Object}          callback.err        Error object containing the error message
 */
var _setContentPermissions = function(contentObj, newPermissions, callback) {
    var oldLastModified = contentObj.lastModified;
    // Update the last modified date
    _updateContentLastModified(contentObj, function(err) {
        if (err) {
            return callback(err);
        }
        var removedMembers = [];
        var queries = [];
        // First split all the ones that need to be added/updated from those that need to be deleted
        for (var p in newPermissions) {
            if (newPermissions.hasOwnProperty(p)) {
                if (newPermissions[p]) {
                    queries.push({
                        'query': 'UPDATE ContentMembers SET ? = ? WHERE contentId = ?',
                        'parameters': [p, newPermissions[p], contentObj.contentId]
                    });
                } else if (newPermissions[p] === false) {
                    removedMembers.push(p);
                    queries.push({
                        'query': 'DELETE ? FROM ContentMembers WHERE contentId = ?',
                        'parameters': [p, contentObj.contentId]
                    });
                } else {
                    return callback({'code': 400, 'msg': 'An invalid role has been passed in (undefined)'});
                }
            }
        }
        // Update the roles CF first, so we can re-generate from this if something goes wrong
        // Doing the roles first will make sure that people that shouldn't have access won't have
        // access
        RolesAPI.setRoles(contentObj.contentId, newPermissions, function(err) {
            if (err) {
                return callback(err);
            }
            // Updates the ContentMembers CF
            Cassandra.runBatchQuery(queries, function(err) {
                if (err) {
                    return callback(err);
                }
                // Now update all of the libraries this affects
                _updateLibraries(contentObj, oldLastModified, removedMembers, function(err) {
                    if (err) {
                        return callback(err);
                    }
                    callback(null);
                });
            });
        });
    });
};

/**
 * Get all of the principals that are directly associated to a piece of content.
 * @param  {String}                     contentId           The id of the content object for which we want to get the members
 * @param  {Function(err, members)}     callback            Standard callback function
 * @param  {Object}                     callback.err        Error object containing the error message
 * @param  {Object }                    callback.members    Object for which the keys are principal ids and values are their
 *                                                          roles on the content
 */
var getContentMembers = module.exports.getContentMembers = function(ctx, contentId, callback) {
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getErrors());
    }

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }
        _getContentMembers(contentId, function(err, members) {
            if (err) {
                return callback(err);
            }
            callback(null, members);
        });
    });
};

/**
 * Internal function that gets all of the principals that are directly associated to a piece of content. This function assumes
 * that the current user has access to the content
 * @param  {String}                     contentId           The id of the content object for which we want to get the members
 * @param  {Function(err, members)}     callback            Standard callback function
 * @param  {Object}                     callback.err        Error object containing the error message
 * @param  {Object }                    callback.members    Object for which the keys are principal ids and values are their
 *                                                          roles on the content
 */
var _getContentMembers = function(contentId, callback) {
    Cassandra.runQuery("SELECT * FROM ContentMembers WHERE contentId = ?", [contentId], function (err, rows) {
        if (err) {
            return callback({'code': 500, 'msg': err});
        }

        var members = {};
        for (var r = 0; r < rows[0].cols.length; r++) {
            if (rows[0].cols[r].name !== "contentId") {
                members[rows[0].cols[r].name] = rows[0].cols[r].value;
            }
        }
        callback(null, members);
    });
};

/////////////////////////////
// Update content metadata //
/////////////////////////////

/**
 * Internal function that updates the lastMofidied date of a piece of content to the current time. This will be called by all functions
 * that update content metadata or when content is shared. This function assume that a valid content object is passed in.
 * @param  {Content}                    contentObj          The content object for which we want to update the lastModified date
 * @param  {Function(err, members)}     callback            Standard callback function
 * @param  {Object}                     callback.err        Error object containing the error message
 */
var _updateContentLastModified = function(contentObj, callback) {
    contentObj.lastModified = new Date().getTime();
    Cassandra.runQuery('UPDATE Content SET ? = ? WHERE contentId = ?', ['lastModified', contentObj.lastModified, contentObj.contentId], function (err, rows) {
        if (err) {
            return callback(err);
        }
        callback(null);
    });
};

/**
 * TODO
 */
var updateContentProfile = module.exports.updateContentProfile = function(ctx, contentId, profileFields, callback) {
    
};

/**
 * TODO
 */
var updatePrivacySettings = module.exports.updatePrivacySettings = function(ctx, contentId, visibility, callback) {
    
};

///////////////////////////
// Library functionality //
///////////////////////////

/**
 * Internal function that updates the libraries of all of the members of a piece of content. This will remove the old entry with
 * the old lastModified date/sorting and add the new one. This function assumes that a valid content item is passed in
 * @param  {Content}                    contentObj          The content object for which we want to update in all libraries
 * @param  {String }                    oldLastModified     The previous lastModified date of the content object. This is the one
 *                                                          that will currently be used for sorting in all libraries where it is
 *                                                          being used.
// TODO
 * @param  {Function(err, members)}     callback            Standard callback function
 * @param  {Object}                     callback.err        Error object containing the error message
 */
var _updateLibraries = function(contentObj, oldLastModified, removedMembers, callback) {
    removedMembers = removedMembers || [];
    // Remove all of the old lastModified from everyone's library and add the new lastModified based one
    _getContentMembers(contentObj.contentId, function(err, members) {
        if (err) {
            return callback(err);
        }
        var queries = [];
        for (var member in members) {
            if (members.hasOwnProperty(member)) {
                // Only remove the old entries if the piece of content existed before and
                // the old lastModified date has been provided
                if (oldLastModified) {
                    // Remove the old entry in the private row
                    queries.push({
                        'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                        'parameters': [oldLastModified + ':' + contentObj.contentId, member]
                    });
                    // Remove the old entry in the loggedin row
                    queries.push({
                        'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                        'parameters': [oldLastModified + ':' + contentObj.contentId, member + ':' + ContentConstants.visibility.LOGGEDIN]
                    });
                    // Remove the old entry in the public row
                    queries.push({
                        'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                        'parameters': [oldLastModified + ':' + contentObj.contentId, member + ':' + ContentConstants.visibility.PUBLIC]
                    });
                }
                // Add it back to the public row
                queries.push({
                    'query': 'UPDATE LibraryByPrincipal SET ? = ? WHERE principalId = ?',
                    'parameters': [contentObj.lastModified + ':' + contentObj.contentId, contentObj.contentId, member]
                });
                // Add it back to the logged in row
                if (contentObj.visibility === ContentConstants.visibility.LOGGEDIN || contentObj.visibility === ContentConstants.visibility.PUBLIC) {
                    queries.push({
                        'query': 'UPDATE LibraryByPrincipal SET ? = ? WHERE principalId = ?',
                        'parameters': [contentObj.lastModified + ':' + contentObj.contentId, contentObj.contentId, member + ':' + ContentConstants.visibility.LOGGEDIN]
                    });
                }
                // Add it back to the public row
                if (contentObj.visibility === ContentConstants.visibility.PUBLIC) {
                    queries.push({
                        'query': 'UPDATE LibraryByPrincipal SET ? = ? WHERE principalId = ?',
                        'parameters': [contentObj.lastModified + ':' + contentObj.contentId, contentObj.contentId, member + ':' + ContentConstants.visibility.PUBLIC]
                    });
                }
            }
        }
        // Remove the content from the libraries of all removed members
        for (var m = 0; m < removedMembers.length; m++) {
            if (oldLastModified) {
                // Remove the old entry in the private row
                queries.push({
                    'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                    'parameters': [oldLastModified + ':' + contentObj.contentId, removedMembers[m]]
                });
                // Remove the old entry in the loggedin row
                queries.push({
                    'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                    'parameters': [oldLastModified + ':' + contentObj.contentId, removedMembers[m] + ':' + ContentConstants.visibility.LOGGEDIN]
                });
                // Remove the old entry in the public row
                queries.push({
                    'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                    'parameters': [oldLastModified + ':' + contentObj.contentId, removedMembers[m] + ':' + ContentConstants.visibility.PUBLIC]
                });
            }
        }
        Cassandra.runBatchQuery(queries, function(err) {
            if (err) {
                return callback(err);
            }
            callback(null);
        });
    });
};

/**
 * Get the content items inside of an authorizable's library. If the user requests its own library or the library of a group he's a member of,
 * the full list will be returned. If the user is logged in, but not a manager of the library, the :loggedin stream will be returned, containing
 * only content that's visible to logged in people or the public. In case of an anonymous user, the :public stream will be returned, containing
 * only content that is public.
 * @param  {Context}                 ctx               Standard context object containing the current user and the current tenant
 * @param  {String}                  principalId       The principal id of the library we're requesting
 * @param  {String}                  start             Determines the point at which content items are returned for paging purposed.
 *                                                     If not provided, the first x elements will be returned
 * @param  {Integer}                 limit             Number of items to return. Will default to 10 if not provided
 * @param  {Function(err, content)}  callback          Standard callback function
 * @param  {Object}                  callback.err      Error object containing the error message
 * @param  {Array<Content>}          callback.content  Array of basic content profiles representing the requested items in the library
 */
var getLibraryItems = module.exports.getLibraryItems = function(ctx, principalId, start, limit, callback) {
    limit = limit || 10;

    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'A user or group id must be provided'}).notEmpty();
    validator.check(limit, {'code': 400, 'msg': 'A valid limit should be passed in'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getErrors());
    }

    // We give the user the public content stream in case the user is not logged in
    if (!ctx.user()) {
        principalId = principalId + ':' + ContentConstants.visibility.PUBLIC;
    // We give the user the logged in content stream in case the current user is not
    // the same as the library we're looking at
    } else if (ctx.user().id !== principalId) {
        principalId = principalId + ':' + ContentConstants.visibility.LOGGEDIN;
    }

    // Page the query.
    var startColumnIndex = 0;
    if (start) {
        limit++;
        startColumnIndex = 1;
    } else {
        start = '';
    }

    Cassandra.runQuery("SELECT first " + limit + " ?..\'\' FROM LibraryByPrincipal WHERE principalId = ?", [limit, principalId], function (err, rows) {
        if (err) {
            return callback({'code': 500, 'msg': err});
        }

        var items = [];
        for (var r = startColumnIndex; r < rows[0].cols.length; r++) {
            if (rows[0].cols[r].name !== 'principalId') {
                items.push(rows[0].cols[r].value);
            }
        }
        // Get the content profiles of the content items, assuming that
        // we have access to all of the returned items
        _getMultipleContentItems(items, function(err, contentItems) {
            if (err) {
                return callback(err);
            }
            callback(null, contentItems);
        });
    });
};

///////////////////////
// Utility functions //
///////////////////////

/**
 * Creates a Content item from a Cassandra row.
 * @param  {Row}    row    Cassandra Row
 * @return {Group}         Converted content object
 */
var _rowToContent = function (row) {
    return new Content(row.colHash.tenant, row.colHash.contentId, row.colHash.visibility, row.colHash.title, row.colHash.description, row.colHash.contentType, row.colHash.lastModified);
};