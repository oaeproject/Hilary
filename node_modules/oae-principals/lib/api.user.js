/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var fs = require('fs');
var Path = require('path');
var sanitize = require('validator').sanitize;
var ShortId = require('shortid');

var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var log = require('oae-logger').logger('oae-principals');
var Redis = require('oae-util/lib/redis');
var Validator = require('oae-util/lib/validator').Validator;
var TZ = require('oae-util/lib/tz');
var Validator = require('oae-util/lib/validator').Validator;

var PrincipalsConstants = require('./constants').PrincipalsConstants;
var PrincipalsDAO = require('./internal/dao');
var PrincipalsEmitter = require('./internal/emitter');
var PrincipalsModel = require('./model');
var PrincipalsUtil = require('./util');

var RESTRICTED_FIELDS = [ 'admin:tenant', 'admin:global' ];

/**
 * Creates a new user under this tenant.
 *
 * @param   {Context}   ctx                     The current context
 * @param   {String}    displayName             A display name to represent the user on the UI
 * @param   {Object}    [opts]                  Optional parameters for the user
 * @param   {String}    [opts.visibility]       This user his visibility setting. (One of VISIBILITY_OPTIONS)
 * @param   {String}    [opts.locale]           The user his locale
 * @param   {String}    [opts.timezone]         The user his timezone
 * @param   {String}    [opts.publicAlias]      This name will be what is seen when when the user is displayed to someone who does not have access to the profile
 * @param   {Function}  callback                Callback method
 * @param   {Object}    callback.err            Error object if something goes wrong.
 * @param   {User}      callback.createdUser    A User object representing the created user
 */
var createUser = module.exports.createUser = function(ctx, displayName, opts, callback) {
    opts = opts || {};
    callback = callback || function(err) {
        if (err) {
            log().error({
                'err': err,
                'displayName': displayName
            }, 'Error creating user.');
        }
    };

    opts.locale = opts.locale || 'en_GB';
    opts.timezone = opts.timezone || 'Etc/UTC';
    opts.visibility = opts.visibility || PrincipalsModel.VISIBILITY_OPTIONS.PUBLIC;
    opts.publicAlias = opts.publicAlias || displayName;

    var validator = new Validator();
    validator.check(displayName, {'code': 400, 'msg': 'A display name must be provided'}).notEmpty();
    validator.check(opts.visibility, {'code': 400, 'msg': 'The specified visibility setting is unknown.'}).isIn(_.values(PrincipalsModel.VISIBILITY_OPTIONS));
    validator.check(opts.timezone, {'code': 400, 'msg': 'The specified timezone is invalid'}).isValidTimeZone();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var tenantAlias = ctx.tenant().alias;
    var id = AuthzUtil.toId('u', tenantAlias, ShortId.generate());
    
    // Create the user
    Cassandra.runQuery('INSERT INTO Principals (principalId, tenant, displayName, visibility, locale, timezone, publicAlias) VALUES (?, ?, ?, ?, ?, ?, ?) USING CONSISTENCY QUORUM', 
            [id, tenantAlias, displayName, opts.visibility, opts.locale, opts.timezone, opts.publicAlias], function (err) {
        if (err) {
            return callback(err);
        }

        var createdUser = new PrincipalsModel.User(tenantAlias, id, displayName, opts);
        PrincipalsEmitter.emit(PrincipalsConstants.events.CREATED_USER, ctx, createdUser);
        return callback(null, createdUser);
    });
};

/**
 * Update a user
 *
 * @param  {Context}        ctx             The current context.
 * @param  {String}         userId          The userId of the user you wish to update.
 * @param  {Object}         profileFields   Object that represent the profile fields that should be updated. Possible keys are visibility, displayName, publicAlias, locale and timezone
 * @param  {Function}       callback        Callback method takes argument `err`.
 * @param  {Object}         callback.err    Error object if something goes wrong.
 */
var updateUser = module.exports.updateUser = function(ctx, userId, profileFields, callback) {
    callback = callback || function() {};
    profileFields = profileFields || {};
    
    var profileFieldKeys = _.keys(profileFields);

    // Parameter validation
    var validator = new Validator();
    validator.check(userId, {'code': 400, 'msg': 'A user id must be provided'}).notEmpty();
    // Check that there is at least one updated profile field.
    validator.check(profileFieldKeys.length, {'code': 400, 'msg': 'At least one basic profile field should be specified.'}).min(1);

    // verify that restricted properties aren't set here
    var invalidKeys = _.intersection(RESTRICTED_FIELDS, profileFieldKeys);
    validator.check(invalidKeys.length, {'code': 400, 'msg': 'Restricted property was attempted to be set.'}).max(0);

    // In case a new visibility has been passed in, we check for its validity
    if (profileFields['visibility']) {
        validator.check(profileFields['visibility'], {'code': 400, 'msg': 'An invalid visibility option has been passed on'}).isIn(_.values(PrincipalsModel.VISIBILITY_OPTIONS));
    }
    if (profileFields['timezone']) {
        validator.check(profileFields['timezone'], {'code': 400, 'msg': 'The specified timezone is invalid'}).isValidTimeZone();
    }
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a user'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    
    // Only update existing users.
    getUser(ctx, userId, function(err, user) {
        if (err) {
            return callback(err);
        }

        // Only the current user or an admin can update a user.
        var principalResource = AuthzUtil.getResourceFromId(userId);
        if (ctx.user().id === userId || ctx.user().isAdmin(principalResource.tenantAlias)) {
            var q = Cassandra.constructUpsertCQL('Principals', 'principalId', userId, profileFields, 'QUORUM');
            if (!q) {
                return callback({'code': 500, 'msg': 'Unable to store profile fields'});
            }
            Cassandra.runQuery(q.query, q.parameters, function(err) {
                if (err) {
                    return callback(err);
                }

                PrincipalsEmitter.emit(PrincipalsConstants.events.UPDATED_USER, ctx, userId);
                PrincipalsDAO.invalidateCachedUser(userId, callback);
            });
        } else {
            callback({'code': 401, 'msg': 'You cannot update this user his profile.'});
        }
    });
};

/**
 * Get a user from the DB
 *
 * @param  {Context}   ctx             The current context
 * @param  {String}    userId          The userId for the user you wish to retrieve.
 * @param  {Function}  callback        Callback method takes arguments `err` and `user`.
 * @param  {Object}    callback.err    Error object if something goes wrong.
 * @param  {User}      callback.user   The user object.
 */
var getUser = module.exports.getUser = function(ctx, userId, callback) {
    if (!userId || !PrincipalsUtil.isUser(userId)) {
        return callback({'code': 400, 'msg': 'The provided userId is not a valid user identifier.'});
    }

    PrincipalsUtil.getPrincipal(ctx, userId, callback);
};

/**
 * Gets the basic profile for a user.
 * The user's visibility setting determines what the profile hash will contain.
 *
 *     {
 *       'profilePath': '/person/simong',
 *       'userId': 'u:cam:simong',
 *       'isFollowing': true,
 *       'accountPermissions': 'public',
 *       'proÔ¨Åle': {
 *           'displayName': 'Simon "simong" Gaeremynck',
 *           'publicAlias': 'simong',
 *           'picture': 'pathToCroppedProfilePicture'
 *       }
 *     };
 *
 * @param  {Context}  ctx           The current context
 * @param  {String}   userId        The id of the user for which the profile should be retrieved.
 * @param  {Object}   callback.err  Error object if something goes wrong.
 * @param  {Object}   callback.user The user.
 */
var getBasicProfile = module.exports.getBasicProfile = function(ctx, userId, callback) {
    getUser(ctx, userId, function(err, user) {
        if (err) {
            return callback(err);
        }
        var data = {
            'profilePath': '/person/' + userId,
            'userId': user.id,
            'visibility': user.visibility,
            'profile': user.extra || {},
            'smallPicture': user.smallPicture,
            'mediumPicture': user.mediumPicture,
            'largePicture': user.largePicture
        };
        if (user.displayName) {
            data.profile.displayName = user.displayName;
        }
        if (user.publicAlias) {
            data.profile.publicAlias = user.publicAlias;
        }

        callback(null, data);
    });
};

/**
 * Gets the me feed for the current user, if anonymous returns 'anon': true
 * If logged in returns structured me feed object in the callback
 *
 *     {
 *         "profilePath": "/person/u:global:bert",
 *         "userId": "u:global:bert",
 *         "visibility": "private",
 *         "isTenantAdmin": true,
 *         "isGlobalAdmin": false,
 *         "profile": {
 *             "displayName": "Bert Pareyn",
 *             "publicAlias": "Bert the Merciful"
 *         },
 *         "locale": {
 *             "locale": "en_GB",
 *             "timezone": {
 *                 "name": "Europe/London",
 *                 "offset": 1
 *             }
 *         }
 *     }
 *
 * If error returns error object
 *
 * @param  {Context}   ctx            The current context
 * @param  {Function}  callback       Callback method takes arguments `err` and `data`.
 * @param  {Object}    callback.err   Error object if something goes wrong.
 * @param  {Object}    callback.data  The me feed data for the user.
 */
var getMe = module.exports.getMe = function(ctx, callback) {
    if (!ctx.user()) {
        return callback({'code': 200,'msg': {
                'anon': true,
                'tenant': ctx.tenant().alias
            }
        });
    }

    getBasicProfile(ctx, ctx.user().id, function(err, data) {
        if (err) {
            return callback(err);
        }

        // calculate timezone offset in hours.
        var now = new TZ.Date(new Date(), ctx.user().timezone);
        var offset = -1 * now.getTimezoneOffset() / 60;

        data.isTenantAdmin = ctx.user().isTenantAdmin(ctx.user().tenant);
        data.isGlobalAdmin = ctx.user().isGlobalAdmin();

        data.locale = {
            'locale': ctx.user().locale,
            'timezone': {
                'name': ctx.user().timezone,
                'offset': offset
            }
        };

        callback(null, data);
    });
};

/**
 * Set a flag that indicates whether a user is a tenant admin.
 * The ctx user must be a tenant or global admin to be able to do this.
 *
 * @param  {Context}   ctx             Context that holds the tenant.
 * @param  {User}      principalId     The user that needs the flag
 * @param  {Boolean}   isAdmin         Flag that indicates whether the provided user should be a tenant admin.
 * @param  {Function}  callback        Callback method
 * @param  {Object}    callback.err    Error object.
 */
var setTenantAdmin = module.exports.setTenantAdmin = function(ctx, principalId, isAdmin, callback) {
    var principalResource = AuthzUtil.getResourceFromId(principalId);
    if (ctx.user() && ctx.user().isAdmin(principalResource.tenantAlias)) {
        _setAdmin(ctx, 'admin:tenant', isAdmin, principalId, callback);
    } else {
        return callback({'code': 401, 'msg': 'You do not have sufficient rights to make someone an admin.'});
    }
};

/**
 * Set a flag that indicates whether a user is a glbal admin.
 * The ctx user must be a global admin to be able to do this.
 *
 * @param  {Context}   ctx             Context that holds the tenant.
 * @param  {User}      user            The user that needs the flag
 * @param  {Boolean}   isAdmin         Flag that indicates whether the provided user should be a global admin.
 * @param  {Function}  callback        Callback method
 * @param  {Object}    callback.err    Error object.
 */
var setGlobalAdmin = module.exports.setGlobalAdmin = function(ctx, principalId, isAdmin, callback) {
    if (ctx.user() && ctx.user().isGlobalAdmin && ctx.user().isGlobalAdmin()) {
        _setAdmin(ctx, 'admin:global', isAdmin, principalId, callback);
    } else {
        return callback({'code': 401, 'msg': 'You do not have sufficient rights to make someone an admin.'});
    }
};

/**
 * Internal method that makes a user an admin. This method will do all the necessary validation
 * of the user ctx and passed in parameters.
 *
 * @param  {Context}        ctx             Context that holds the current user and tenant.
 * @param  {String}         adminType       One of admin:global` or `admin:tenant`
 * @param  {Boolean}        isAdmin         Flag that indicates whether this user should be an admin or not.
 * @param  {String}         principalId     The uuid of the user that needs to be made an admin.
 * @param  {Function}       callback        Callback method takes argument `err`
 * @param  {Object}         callback.err    Error object.
 * @api private
 */
var _setAdmin = function(ctx, adminType, isAdmin, principalId, callback) {
    if (!PrincipalsUtil.isUser(principalId)) {
        return callback({'code': 400, 'msg': 'The provided principalId is not a user.'});
    }

    // Double-check that this user exists.
    getUser(ctx, principalId, function(err, user) {
        if (err) {
            return callback(err);
        }

        // Sanitize input and store it in cassandra.
        isAdmin = sanitize(isAdmin).toBooleanStrict();
        Cassandra.runQuery("UPDATE Principals USING CONSISTENCY QUORUM SET ?=? WHERE principalId = ?", [adminType, isAdmin, principalId], function(err) {
            if (err) {
                return callback(err);
            }
            PrincipalsDAO.invalidateCachedUser(principalId, callback);
        });
    });
};
