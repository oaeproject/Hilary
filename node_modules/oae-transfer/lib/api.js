/*!
 * Copyright 2017 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var async = require('async');
var codeGenerator = require('password-generator');
var ShortId = require('shortid');
var Validator = require('oae-util/lib/validator').Validator;

var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var Cassandra = require('oae-util/lib/cassandra');
var ContentConstants = require('oae-content/lib/constants').ContentConstants;
var ContentDAO = require('oae-content/lib/internal/dao.content');
var DiscussionsConstants = require('oae-discussions/lib/constants').DiscussionsConstants;
var DiscussionsDAO = require('oae-discussions/lib/internal/dao');
var EmailAPI = require('oae-email/lib/api');
var FoldersConstants = require('oae-folders/lib/constants').FoldersConstants;
var LibraryAPI = require('oae-library'); 
var MeetingsConstants = require('oae-jitsi/lib/constants').MeetingsConstants;
var MeetingsDAO = require('oae-jitsi/lib/internal/dao');
var PrincipalsAPI = require('oae-principals/lib/api.user');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var TenantsUtil = require('oae-tenants/lib/util');

var TransferConstants = require('oae-transfer/lib/constants').TransferConstants;
var TransferDAO = require('./internal/dao');

/**
 * PUBLIC FUNCTIONS
 */

/**
 * Initiate a new transfer.
 *
 * @param  {Context}    ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}     originalEmail       The email of the account from which the data will be transferred
 * @param  {String}     targetEmail         The email of the account to which the data will be transferred
 * @param  {String}     originalUserId      The account identifier from which the data will be transferred
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred
 * @api private
 */
var initiateTransfer = module.exports.initiateTransfer = function (ctx, originalUserId, originalEmail, targetEmail, callback) {
    callback = callback || function() {};

    // Verify basic properties
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Anonymous users cannot create a transfer'}).isLoggedInUser(ctx);
    validator.check(originalUserId, {'code': 400, 'msg': 'An originalUserId must be provided'}).notEmpty();
    validator.check(originalEmail, {'code': 400, 'msg': 'An originalEmail must be provided'}).notEmpty();
    validator.check(targetEmail, {'code': 400, 'msg': 'A targetEmail must be provided'}).notEmpty();
    validator.check(originalEmail, {'code': 400, 'msg': 'Invalid email'}).isEmail();
    validator.check(targetEmail, {'code': 400, 'msg': 'Invalid email'}).isEmail();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var code = _initiateTransferCode();

    TransferDAO.initiateTransfer(ctx, code, originalUserId, originalEmail, targetEmail, function(err, transfer) {
        if (err) {
            return callback(err);
        }
        return callback(null, transfer);
    });
};

/**
 * Get a transfer by id.
 *
 * @param  {Context}    ctx                 Standard context object containing the current user and the current tenant
 * @param  {string}     originalUserId      The account identifier from which the data will be transferred
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred
 * @api private
 */
var getTransferById = module.exports.getTransferById = function (ctx, originalUserId, callback) {
    callback = callback || function() {};

    // Verify basic properties
    var validator = new Validator();
    validator.check(originalUserId, {'code': 400, 'msg': 'Id cannot be empty'}).notEmpty();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    TransferDAO.getTransferById(originalUserId, function(err, transfer) {
        if (err) {
            return callback(err);
        }

        // A user can have a lot of transfer but only one can be 'ongoing'
        transfer = _.find(transfer, function(t) {return t.status === TransferConstants.status.ONGOING; });

        if (_.isEmpty(transfer)) {
            var err = {'code': 404, 'msg': 'Transfer not found'};
            return callback(err);
        }

        return callback(null, transfer);
    });
};

/**
 * Complete the transfer.
 *
 * @param  {Context}    ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}     originalEmail           The email of the account from which the data will be transferred
 * @param  {String}     code                    The code used by the user to secure the transfer
 * @param  {String}     targetEmail             The email of the account to which the data will be transferred
 * @param  {String}     targetUserId            Id user target
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred
 * @param  {Object}     callback.parsedData     Return array of updated users
 * @api private
 */
var completeTransfer = module.exports.completeTransfer = function (ctx, originalEmail, code, targetEmail, targetUserId, callback) {

    callback = callback || function() {};

    // Verify basic properties
    var validator = new Validator();

    validator.check(null, {'code': 401, 'msg': 'Anonymous users cannot make a transfer'}).isLoggedInUser(ctx);
    validator.check(code, {'code': 400, 'msg': 'Code cannot be empty'}).notEmpty();
    validator.check(targetUserId, {'code': 400, 'msg': 'An targetUserId must be provided'}).notEmpty();
    validator.check(originalEmail, {'code': 400, 'msg': 'An originalEmail must be provided'}).notEmpty();
    validator.check(targetEmail, {'code': 400, 'msg': 'A targetEmail must be provided'}).notEmpty();
    validator.check(originalEmail, {'code': 400, 'msg': 'Invalid email'}).isEmail();
    validator.check(targetEmail, {'code': 400, 'msg': 'Invalid email'}).isEmail();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Find transfer
    TransferDAO.getTransferByEmail(originalEmail, code, function(err, transfer) {
        if (err) {
            return callback(err);
        }

        // A user can have a lot of transfer but only one can be 'ongoing'
        transfer = _.find(transfer, function(t) { return t.status === TransferConstants.status.ONGOING; });

        if (_.isEmpty(transfer)) {
            var err = {'code': 404, 'msg': 'Transfer not found'};
            return callback(err);
        }

        if (transfer.code !== code || transfer.targetEmail !== targetEmail) {
            var err = {'code': 400, 'msg': 'Code or e-mails doesn\'t match'};
            return callback(err);
        } 

        _completeTransfer(ctx, originalEmail, code, targetEmail, targetUserId, transfer, function(err, members) {
            if (err) {
                return callback(err);
            }

            if (_.isEmpty(members)) {Â 
                return callback();
            } else {

                // If there is no error, send emails to manager to advice them
                _sendEmail(ctx, members, targetUserId, originalEmail, targetEmail, function(err, parsedData) {
                    if (err) {
                        return callback(err);
                    }
                    return callback(null, parsedData);
                });
            }
        });
    });
};

/**
 * Cancel the transfer.
 *
 * @param  {Context}    ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}     originalEmail       The email of the account from which the data will be transferred  
 * @param  {String}     code                The code used by the user to secure the transfer
 * @param  {string}     originalUserId      The account identifier from which the data will be transferred
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred
 * @api private
 */
var cancelTransfer = module.exports.cancelTransfer = function (ctx, originalEmail, code, originalUserId, callback) {

    callback = callback || function() {};

    // Verify basic properties
    var validator = new Validator();
    validator.check(code, {'code': 400, 'msg': 'Code cannot be empty'}).notEmpty();
    validator.check(originalUserId, {'code': 400, 'msg': 'Id cannot be empty'}).notEmpty();
    validator.check(originalEmail, {'code': 400, 'msg': 'Email cannot be empty'}).notEmpty();
    validator.check(originalEmail, {'code': 400, 'msg': 'Invalid email'}).isEmail();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    TransferDAO.cancelTransfer(originalEmail, code, originalUserId, function(err) {
        if (err) {
            return callback(err);
        } 
        return callback();
    });
};

/**
 * PRIVATE FUNCTIONS
 */

/**
 * Complete the transfer.
 *
 * @param  {Context}        ctx                         Standard context object containing the current user and the current tenant
 * @param  {String}         originalEmail               The email of the account from which the data will be transferred
 * @param  {String}         code                        The code used by the user to secure the transfer
 * @param  {String}         targetEmail                 The email of the account to which the data will be transferred
 * @param  {String}         transfer                    The transfer
 * @param  {String}         targetUserId                The identifier of the account to which the data will be transferred
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error that occurred, if any
 * @param  {members}        callback.members            All the members of user resource
 */
 var _completeTransfer = function (ctx, originalEmail, code, targetEmail, targetUserId, transfer, callback) {

    TransferDAO.getAuthzRoles(transfer.originalUserId, function(err, authzRoles) {
        if (err) {
            return callback(err);
        }

        // If there is no data to transfer, cancel it
        if (_.isEmpty(authzRoles)) {
            var err = {'code': 404, 'msg': 'No permissions to transfer'};
            return callback(err);
        }

        // Create queries to insert and delete authzRoles and authzMembers
        _transferRoles(ctx, authzRoles, targetUserId, transfer.originalUserId, function(err, newAuthzRoles) {
            if (err) {
                return callback(err);
            }

            // Set the transfer as 'complete'
            TransferDAO.completeTransfer(code, transfer.originalUserId, originalEmail, targetEmail, targetUserId, function (err, transfer) {
                if (err) {
                    return callback(err);
                }
                if (!transfer) {
                    return callback({'code': 400, 'msg': 'A problem happened completing the transfer'});
                }

                if (_.isEmpty(newAuthzRoles)) {
                    return callback(); 
                } else {

                    // Found all members related to this resource to send them an email
                    _getMembers(ctx, newAuthzRoles, targetUserId, transfer.originalUserId, function (err, members) {
                        if (err) {
                            return callback(err);
                        } 
                        return callback(null, members); 
                    });
                }
            });
        }); 
    });
};

/**
 * Get managers from authzroles
 * 
 * @param {Context} ctx                 Standard context object containing the current user and the current tenant
 * @param {Array}   authzRoles          An array of an object composed of the principal id, a resource and his permission on it
 * @param {String}  targetUserId        The identifier of the account to which the data will be transferred
 * @param {String}  originalUserId      The account identifier from which the data will be transferred
 *
 * @returns managers
 * @api private
 */
var _getMembers = function (ctx, authzRoleHashes, targetUserId, originalUserId, callback) {

    var listMembers = [];

    async.eachSeries(authzRoleHashes, function(resource, outerCallback) {

        // Found all members related to this resource and put then into 'members'
        AuthzAPI.getAuthzMembers(resource.resourceId, null, null, function(err, members) {
            if (err) {
                return callback(err);
            }

            // For each resource, get each members
            async.eachSeries(members, function(member, innerCallback) {

                if (member.id == (targetUserId || originalUserId)) {
                    return innerCallback();
                }

                // Get the user
                TransferDAO.getPrincipalFromCassandra(member.id, function (err, member) {
                    if (err) {
                        return callback(err);
                    } 

                    // Get resource
                    _getDocument(ctx, resource.resourceId, function (err, element) {
                        if (err) {
                            return callback(err);
                        }

                        member = _.chain(member).map(Cassandra.rowToHash)._wrapped[0];
                        listMembers.push([{'profile': member}, {'resource': element}]);

                        return innerCallback();
                    }); 
                });
            }, function() {
                return outerCallback();
            });
        });
    }, function() {
        return callback(null, listMembers);
    });
};

/**
 * Get the name of the resource by its id 
 * take advantage of the differentiation of data type to modify the library
 * 
 * @param {Context} ctx              Standard context object containing the current user and the current tenant
 * @param {String}  resourceId       The id of the resource to transfer
 *
 * @returns resource
 * @api private
 */
var _getDocument = function (ctx, resourceId, callback) {

    var resourceType = resourceId.split(':')[0];

    switch (resourceType) {
        case 'c':
            ContentDAO.getContent(resourceId, function(err, result) {
                if (err) {
                    return callback(err);
                }
                return callback(null, result);        
            });
            break;
        case 'g':
            TransferDAO.getFoldersByGroupIds(ctx, resourceId, function(err, result) {
                if (err) {
                    return callback(err);
                }
                return callback(null, result);                
            }); 
            break;
        case 'd':
            DiscussionsDAO.getDiscussion(resourceId, function(err, result) {
                if (err) {
                    return callback(err);
                }
                return callback(null, result);                
            }); 
            break;
        case 'm':
            MeetingsDAO.getMeeting(resourceId, function(err, result) {
                if (err) {
                    return callback(err);
                }
                return callback(null, result);                
            });
            break;
    }
};

/**
 * Update roles and Get array of roles modified
 *  
* @param {Context}      ctx                 Standard context object containing the current user and the current tenant
 * @param {Array}       authzRoles          An array of an object composed of the principal id, a resource and his permission on it      
 * @param {String}      targetUserId        The identifier of the account to which the data will be transferred
 * @param {String}      originalUserId      The account identifier from which the data will be transferred
 * @param {Function}    callback                
 * @param {Array}       _userHashes
 *
 * @returns array of roles modified
 * @api private used to make the transter
 */
var _transferRoles = function(ctx, authzRoles, targetUserId, originalUserId, callback, _userHashes) {

    _userHashes = _userHashes || []
    
    // If no more authzroles, return list of modified roles
    if (_.isEmpty(authzRoles)) {
        return callback(null, _userHashes);
    }

    var authzRole = authzRoles.shift();
    var memberToUpdate = {};
    var newAuthzRoles = {};
    memberToUpdate[targetUserId] = authzRole.role;
    memberToUpdate[originalUserId] = false;

    _doUpdate(authzRole, targetUserId, originalUserId, function (err, doUpdate) {
        if (err) {
            return callback(err);
        }

        if (doUpdate) {

            // Update target user's role && remove origin user's role
            AuthzAPI.updateRoles(authzRole.resourceId, memberToUpdate, function(err, usersToInvalidate) {
                if (err) {
                    return callback(err);
                }

                // Insert to library
                _transferResourceLibrary(ctx, authzRole.resourceId, targetUserId, originalUserId, function (err, result) {
                    if (err) {
                        return callback(err);
                    }
                    newAuthzRoles['resourceId'] = authzRole.resourceId;
                    newAuthzRoles['role'] = authzRole.role;
                    newAuthzRoles['principalId'] = targetUserId;
                    _userHashes.push(newAuthzRoles);

                    return _transferRoles(ctx, authzRoles, targetUserId, originalUserId, callback, _userHashes);
                });
            });
        } else {
            return _transferRoles(ctx, authzRoles, targetUserId, originalUserId, callback, _userHashes);
        }
    });
};

/**
 * Look at the right of target and origin to make a decision about the transfer. 
 * if the target user has better permission, we don't change it
 * 
 * @param {Object} hash
 * @param {String} targetUserId         The identifier of the account to which the data will be transferred
 * @param {String} originalUserId       The account identifier from which the data will be transferred
 *
 * @returns boolean
 * @api private used to make the transter
 */
var _doUpdate = function(hash, targetUserId, originalUserId, callback) {

    AuthzAPI.getAuthzMembers(hash.resourceId, null, null, function(err, members) {
        if (err) {
            return callback(err);
        }

        var userOriginRole = _.find(members, function(obj) {
          return obj.id == originalUserId;
        });

        var userTargetRole = _.find(members, function(obj) {
          return obj.id == targetUserId;
        });

        if (!userTargetRole) {
            return callback(null, true);
        }

        _isRoleHigherThan(userTargetRole.role, userOriginRole.role, function(isRoleHighterThan) {
            if (isRoleHighterThan) {
                return callback(null, true);
            }
            return callback(null, false);
        });
    });                     
};

/**
 * Determine if userTargetRole is an higher right than userOriginRole
 * 
 * @param {String} userTargetRole       The user role 
 * @param {String} userOriginRole       The user role
 *
 * @returns boolean
 * @api private used to make the transter
 */
var _isRoleHigherThan = function(userTargetRole, userOriginRole, callback) {

    var originRole = 5;
    var targetRole = 5;

    switch (userTargetRole) {
        case AuthzConstants.role.MANAGER:
            targetRole = 1;
            break;
        case AuthzConstants.role.MEMBER:
            targetRole = 2;
            break;
        case AuthzConstants.role.EDITOR:
            targetRole = 3;
            break;
        case AuthzConstants.role.VIEWER:
            targetRole = 4;
            break;
    }

    switch (userOriginRole) {
        case AuthzConstants.role.MANAGER:
            originRole = 1;
            break;
        case AuthzConstants.role.MEMBER:
            originRole = 2;
            break;
        case AuthzConstants.role.EDITOR:
            originRole = 3;
            break;
        case AuthzConstants.role.VIEWER:
            originRole = 4;
            break;
    }

    if (targetRole <= originRole) {
        return callback(false);
    } else {
        return callback(true);
    }
};

/**
 * Get the name of the resource by its id 
 * take advantage of the differentiation of data type to modify the library
 * 
 * @param {Context}     ctx                     Standard context object containing the current user and the current tenant
 * @param {String}      resourceId              The id of the resource to transfer
 * @param {String}      targetUserId            The identifier of the account to which the data will be transferred
 * @param {String}      originalUserId          The account identifier from which the data will be transferred
 *
 * @returns nothing
 * @api private
 */
var _transferResourceLibrary = function (ctx, resourceId, targetUserId, originalUserId, callback) {

    // Get resource
    _getDocument(ctx, resourceId, function (err, resource) {
        if (err) {
            return callback(err);
        }

        var resourceType = resource.id.split(':')[0];
        
        var libraryIndexName = '';

        switch (resourceType) {
            case 'c':
                libraryIndexName = ContentConstants.library.CONTENT_LIBRARY_INDEX_NAME;
                break;
            case 'f':
                libraryIndexName = FoldersConstants.library.FOLDERS_LIBRARY_INDEX_NAME;
                break;
            case 'd':
                libraryIndexName = DiscussionsConstants.library.DISCUSSIONS_LIBRARY_INDEX_NAME;
                break;
            case 'm':
                libraryIndexName = MeetingsConstants.library.MEETINGS_LIBRARY_INDEX_NAME;
                break;
        }

        // Insert to library 
        _addOnLibrary(resource, targetUserId, libraryIndexName, function(err) {
            if (err) {
                return callback(err);
            }

            // Remove to library 
            _removeFromLibrary(resource, originalUserId, libraryIndexName, function(err) {
                if (err) {
                    return callback(err);
                }
                return callback();                
            }); 
        }); 
    }); 
};

/**
 * Generate a new 20 caracters code
 *      Parametters : length, memorable, pattern, prefix
 * 
 * @returns transferCode
 * @api private
 */
var _initiateTransferCode = function() {
    return codeGenerator(20, false);
};

/**
 * Insert an element to the library.
 *
 * @param  {Object}         obj                     The resource to insert into the library       
 * @param  {Object}         principalId             The user id of the library where we want to insert a resource
 * @param  {Object}         constant                The resource constant corresponding to folder, content, meeting, discussion or group
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Error
 */
var _addOnLibrary = function(obj, principalId, constant, callback) {
    var entries = [{
        'id': principalId,
        'rank': obj.lastModified,
        'resource': obj
    }];
    LibraryAPI.Index.insert(constant, entries, callback);
};

/**
 * Remove an element to the library.
 *
 * @param  {Object}         obj                     The resource to insert into the library       
 * @param  {Object}         principalId             The user id of the library where we want to insert a resource
 * @param  {Object}         constant                The resource constant corresponding to folder, content, meeting, discussion or group
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Error
 */
var _removeFromLibrary = function(obj, principalId, constant, callback) {
    var entries = [{
        'id': principalId,
        'rank': obj.lastModified,
        'resource': obj
    }];
    LibraryAPI.Index.remove(constant, entries, callback);
};

/**
 * Send an email token to a user that can be used to notify the user transfer
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {Manager}    members         List of couple member-resource
 * @param  {String}     oldUserMail     The email of the account from which the data will be transferred
 * @param  {String}     newUserMail     The email of the account to which the data will be transferred
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred
 * @api private
 */
var _sendEmail = function(ctx, members, targetUserId, oldUserMail, newUserMail, callback) {

    // ParseData from variable informations to make an union on user. Start with members
    _parseData(members, function(err, parsedData) {
        if (err) {
            return callback(err);
        }

        async.forEachOf(parsedData, function (hash, i, callback) {

            // Generate a token
            var token = ShortId.generate();

            // Store the token
            PrincipalsDAO.storeEmailToken(ctx.user().id, hash.profile.email, token, function(err) {
                if (err) {
                    return callback(err);
                }

                var userToEmail = _.extend({}, hash.profile, {'email': hash.profile.email, 'id': hash.profile.principalId,'tenant':{'alias': hash.profile.tenantAlias}});
                
                // Send an email to the specified e-mail address
                var data = {
                    'actor': ctx.user(),
                    'transferringAccount': ctx.user(),
                    'tenant': ctx.tenant().displayName,
                    'user': userToEmail,
                    'baseUrl': TenantsUtil.getBaseUrl(ctx.tenant()),
                    'skinVariables': require('oae-ui').getTenantSkinVariables(ctx.tenant().alias),
                    'token': token,
                    'oldUserMail': oldUserMail,
                    'newUserMail': newUserMail,
                    'resources': hash.resources,
                };

                EmailAPI.sendEmail('oae-transfer', 'notify', userToEmail, data, {'hash': Date.now()});
                callback();
            });
        }, function (err) {
            if (err) {
                return callback(err);
            }
            return callback(null, parsedData);
        });
    });
};

/**
 * This function aims to restructure the memberHashes variable. The current structure is not 
 * the best solution to send one email per user. We would like to group resources per user to 
 * facilitate the function of sending emails.
 *
 * The variable associationMemberResource at the beggining have this structure :
 *            [ [ { profile: [Object] }, { resource: [Object] } ],
 *            [ { profile: [Object] }, { resource: [Object] } ],
 *            [ { profile: [Object] }, { resource: [Object] } ],
 *            [ { profile: [Object] }, { resource: [Object] } ],
 *            [ { profile: [Object] }, { resource: [Object] } ] ]
 *
 * This function will transform the previous structure into this one : 
 *            [ { profile: 
 *                { principalId: 'u:camtest:r1IlKuv8sof',
 *                  displayName: 'random-user-HyNeFOPUisM',
 *                  email: 'random-user-bkqey_viijf_hksgf_wijjg@cam.ac.uk',
 *                  emailPreference: 'immediate',
 *                  locale: 'en_GB',
 *                  publicAlias: 'random-user-HyNeFOPUisM',
 *                  tenantAlias: 'camtest',
 *                  visibility: 'public' },
 *               resources: [ Object, Object ] },
 *             { profile: 
 *                { principalId: 'u:camtest:Sy5xFdw8sjf',
 *                  displayName: 'random-user-SyugtOvUjsf',
 *                  email: 'random-user-h1pefddlojf_h1kgkod8sjz@cam.ac.uk',
 *                  emailPreference: 'immediate',
 *                  locale: 'en_GB',
 *                  publicAlias: 'random-user-SyugtOvUjsf',
 *                  tenantAlias: 'camtest',
 *                  visibility: 'public' },
 *               resources: [ Object, Object, Object ] } ];
 *
 * @param  {Object}     associationMemberResource           List of member associated to a unique resource
 * @param  {Function}   callback                            Standard callback function
 * @param  {Object}     callback._listOfResourcesByMember   List of resources by members
 * @param  {Object}     callback.err                        An error that occurred, if any
 */
var _parseData = function(associationMemberResource, callback, _listOfResourcesByMember) {

    // Return when there are no more association user-elemnt in the array '_listOfResourcesByMember'
    if (!associationMemberResource || _.isEmpty(associationMemberResource)) {
        return callback(null, _listOfResourcesByMember);
    }
    
    // Create another list make a list of resource by user 
    var _listOfResourcesByMember = _listOfResourcesByMember || [];

    // Get the user and the resource form the association to analyse
    var memberAndResource = associationMemberResource.shift();
    var member = memberAndResource[0];
    var resource = memberAndResource[1];

    if (_.isEmpty(_listOfResourcesByMember)) {
        _listOfResourcesByMember.push({'profile': member.profile, 'resources': []});
    }

    var userFoundOnTheList = false;
    var iterate = 0;
    
    async.eachSeries(_listOfResourcesByMember, function (element, callback) {
        
        // If the user is found on '_listOfResourcesByMember', add the resource to user 
        if (element.profile.principalId === member.profile.principalId) {
            userFoundOnTheList = true;
            element.resources.push(resource);
        } 
        iterate += 1;

        return callback();

    }, function () {

        // If user was not found in the list, create it
        if (!userFoundOnTheList) {
            _listOfResourcesByMember.push({'profile': member.profile, 'resources': []});
            _listOfResourcesByMember[iterate].resources.push(resource);   
        }

        return _parseData(associationMemberResource, callback, _listOfResourcesByMember);
    });
};
