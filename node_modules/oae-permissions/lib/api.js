/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var rolesAPI = require('oae-roles/lib/api');
var principalsAPI = require('oae-principals/lib/api');

/**
 * Determine whether or not the principal specified by principalUuid can perform the action on the given resourceUuid
 * 
 * @param {String}                   principalUuid      The principal to check
 * @param {String}                   action             The action to check
 * @param {String}                   resourceUuid       The resource to check
 * @param {Function(err, isAllowed)} callback           A function specifying whether or not the user can perform the operation
 * @param {Object}                   callback.err       An error that occured, if any
 * @param {Boolean}                  callback.isAllowed Whether or not the principal can perform the operation on the resource
 */
module.exports.isAllowed = function(principalUuid, action, resourceUuid, callback) {
    // first check this principal directly
    rolesAPI.hasRole(principalUuid, resourceUuid, action, function(err, hasRole) {
        if (!err) {
            if (hasRole) {
                return callback(null, true);
            } else {
                // get the entire (indirect as well) group ancestry of the principal and check if they have the access

                // TODO: There is a potential optimization here to not aggressively get all ancestors, but rather check one level at a time
                // We can do the above optimization assuming we can short-circuit the checks when we get one positive check.
                principalsAPI.memberOf(principalUuid, false, null, null, function(err, groupUuids) {
                    if (!err) {
                        return internalIsAllowed(groupUuids, action, resourceUuid, callback);
                    } else {
                        return callback(err);
                    }
                });
            }
        } else {
            return callback(err);
        }
    });
}

/**
 * Determine whether or not the principal specified by principalUuid can perform at least one action on the given resourceUuid

 * @param {String}                   principalUuid      The principal to check
 * @param {String}                   resourceUuid       The resourceUuid to check
 * @param {Function(err, isAllowed)} callback           A function specifying whether or not the user can perform any operation
 * @param {Object}                   callback.err       An error that occured, if any
 * @param {Boolean}                  callback.isAllowed Whether or not the principal is authorized to perform any action on the resource
 */
module.exports.isAllowedAny = function(principalUuid, resourceUuid, callback) {
    // first check the principal directly
    rolesAPI.getRole(principalUuid, resourceUuid, function(err, role) {
        if (!err) {
            if (role) {
                // there was a role, short-circuit and indicate that the user has some role on the resource
                return callback(null, true);
            } else {
                principalsAPI.memberOf(principalUuid, false, null, null, function(err, groupUuids) {
                    if (!err) {
                        return internalIsAllowed(groupUuids, null, resourceUuid, callback);
                    } else {
                        return callback(err);
                    }
                });
            }
        } else {
            return callback(err);
        }
    });
}

/**
 * Determine all the permissions the principal has on the resource specified by resourceUuid. Permissions may have been granted directly on the
 * principal, or indirectly through group membership.
 *
 * @param {String}                      principalUuid        The UUID of the principal
 * @param {Function(err, permissions)}  callback             The callback function, invoked when the process has completed
 * @param {Object}                      callback.err         An error that occured, if any
 * @param {Array<String>}               callback.permissions All the permissions that the principal has on the resource either directly or through group membership
 */
 module.exports.getAllPermissions = function(principalUuid, resourceUuid, callback) {

    // variables for monitoring the status of asynchronous role checks
    var permissions = {};
    var index = 0;
    var numPrincipals = -1;
    var errResult = false;

    // aggregatePermissions monitors the progress of asynchronous aggregation of permissions on the resource and calls back when appropriate
    var aggregatePermissions = function(err, role) {
        if (errResult) {
            // do nothing, there was an err while checking permissions and we've already called back
        } else if (err) {
            // we've received an error, record it and we can call back immediately
            errResult = err;
            return callback(errResult);
        } else {
            index++;

            if (role) {
                // We simply add the role as the permission for now. In the future if we start association actual permissions to roles, we will
                // need to grab the actions that are assigned to the role for the resource instead.
                permissions[role] = true;
            }

            if (index >= numPrincipals) {
                // we've successfully aggregated all potential permissions, call back with them
                return callback(null, Object.keys(permissions));
            }
        }
    }

    // aggregate all roles for all group ancestors.
    principalsAPI.memberOf(principalUuid, false, null, null, function(err, groupUuids) {
        numPrincipals = groupUuids.length;
        groupUuids.forEach(function(groupUuid) {
            rolesAPI.getRole(groupUuid, resourceUuid, aggregatePermissions);
        });
    });
 }

/**
 * Determine whether or not one of the principals in the array of principalUuids is able to perform the action on the
 * resource specified. If the action is null, then we will determine if the user can perform *any* action on the
 * resource specified.
 *
 * @param {Array<String>}            principalUuids     The array of principals to check
 * @param {String}                   action             The action to check. If null, check for any action.
 * @param {String}                   resourceUuid       The resource to check
 * @param {Function(err, isAllowed)} callback           A function invoked when the process is complete.
 * @param {Object}                   callback.err       An error that occured, if any
 * @param {Boolean}                  callback.isAllowed Whether or not one of the principals is authorized to perform the action
 */
var internalIsAllowed = function(principalUuids, action, resourceUuid, callback) {

    // short circuit if there is no ancestry
    if (!(principalUuids.length > 0)) {
        return callback(null, false);
    }

    // variables for monitoring the progress of permissions checks
    var index = 0;
    var isAllowedResult = false;
    var errResult = false;

    // this function monitors the progress of asynchronous permissions checks, calling back to the caller when appropriate
    var checkStatus = function(err, isAllowed) {
        if (errResult || isAllowedResult) {
            // do nothing, because we've already finished executing and called the callback
        } else if (err) {
            // we got an error while executing, call back with the error
            errResult = err;
            return callback(errResult);
        } else if (isAllowed) {
            // one of the principals is allowed to perform the action, short circuit
            isAllowedResult = isAllowed;
            return callback(null, isAllowedResult);
        } else {
            index++;
            if (index >= principalUuids.length) {
                // we've reached the end of the check and none are allowed, return false
                return callback(null, false);
            }
        }
    }

    // invoke the entire ancestry asynchronously. checkStatus will determine the result and when it is possible to call back.
    principalUuids.forEach(function(principalUuid) {
        if (action !== null) {
            rolesAPI.hasRole(principalUuid, resourceUuid, action, checkStatus);
        } else {
            // we pass checkStatus directly here on the basis that the 'isAllowed' parameter is a duck-check and not strictly typed.
            rolesAPI.getRole(principalUuid, resourceUuid, checkStatus);
        }
    });
}