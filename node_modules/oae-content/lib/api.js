/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var events = require('events');
var fs = require('fs');
var mime = require('mime');
var path = require('path');
var ShortId = require('shortid');

var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzUtil = require('oae-authz/lib/util');
var Config = require('oae-config').config('oae-content');
var Context = require('oae-context').Context;
var LibraryAPI = require('oae-library');
var log = require('oae-logger').logger('oae-content');
var MessageBoxAPI = require('oae-messagebox');
var MessageBoxConstants = require('oae-messagebox/lib/constants').MessageBoxConstants;
var OaeUtil = require('oae-util/lib/util');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var PrincipalsUtil = require('oae-principals/lib/util');
var Signature = require('oae-util/lib/signature');
var TenantsUtil = require('oae-tenants/lib/util');
var Validator = require('oae-util/lib/validator').Validator;

var Content = require('./model').Content;
var ContentConstants = require('./constants').ContentConstants;
var ContentDAO = require('./internal/dao');
var ContentMembersLibrary = require('./internal/membersLibrary');
var ContentUtil = require('./internal/util');
var Etherpad = require('./internal/etherpad');
var Revision = require('./model').Revision;

/**
 * ### Events
 *
 * The `ContentAPI`, as enumerated in `ContentConstants.events`, emits the following events:
 *
 * * `createdContent(ctx, content)`: A new content item was created. The `ctx` and the `content` object that was created are both provided.
 * * `updatedContent(ctx, newContentObj, oldContentObj)`: A content item was updated. The `ctx`, the updated content object and the content before was updated are provided.
 * * `updatedContentBody(ctx, newContentObj, oldContentObj, revision)`: A content item's file body was updated. The `ctx` of the request, the `newContentObj` object after being updated, the `oldContentObj` object before the update, and the revision object.
 * * `editedCollabdoc(ctx, contentObj)`: A collaborative document was edited by a user without resulting in a new revision. This happens if the revision-creation was already triggered by another user leaving the document
 * * `restoredContent(ctx, newContentObj, oldContentObj, restoredRevision)`: An older revision for a content item has been restored.
 * * `deletedContent(ctx, contentId)`: A content item was deleted. The `ctx` and the `contentId` of the deleted item are provided.
 * * `updatedContentMembers(ctx, content, memberUpdates, newMemberIds, updatedMemberIds, removedMemberIds)`: A content's members list was updated. The `ctx`, full `content` object of the updated content, and the hash of principalId -> role that outlines the changes that were made are provided, as well as arrays containing the ids of the new members, updated members and removed members that resulted from the change
 * * `createdComment(ctx, comment, content)`: A new comment was posted for a content item. The `ctx`, `comment` and commented `content` object are provided.
 * * `deletedComment(ctx, comment, content, deleteType)`: An existing comment has been deleted on a content item. The `ctx`, `content` and target `comment` object are provided.
 */
var ContentAPI = module.exports = new events.EventEmitter();

///////////////////////////////////
// Retrieving a piece of content //
///////////////////////////////////

/**
 * Get a content's basic profile information based on a pooled content id.
 * An access-check will be run to determine if the user can view this piece of content.
 *
 * @param  {Context}        ctx                     Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId               The id of the content object we want to retrieve
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Content}        callback.contentObj     Retrieved content object
 */
var getContent = module.exports.getContent = function(ctx, contentId, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    ContentDAO.Content.getContent(contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        _hasAccess(ctx, contentObj, function(err, hasAccess) {
            if (err) {
                return callback(err);
            } else if (!hasAccess) {
                return callback({'code': 401, 'msg': 'You don\'t have access to this piece of content'});
            }

            ContentUtil.augmentContent(ctx, contentObj);
            return callback(null, contentObj);
        });
    });
};

/**
 * Get a full content item profile. Next to the basic content profile, this will include the created date, the profile of
 * the user who originally created the content, and a isManager property specifying whether or not the current user can
 * manage the content.
 *
 * @param  {Context}        ctx                         Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId                   The id of the content item to get
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error that occurred, if any
 * @param  {Content}        callback.contentProfile     Full content profile
 */
var getFullContentProfile = module.exports.getFullContentProfile = function(ctx, contentId, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        // Check whether the user is a manager.
        _canManage(ctx, contentObj, function(err, isManager) {
            if (err) {
                return callback(err);
            }

            return _getFullContentProfile(ctx, contentObj, isManager, callback);
        });
    });
};

/**
 * Add the `isManager` flag, `createdBy` user object, `canShare` flag and the `latestRevision` in case it's a collaborative document.
 *
 * @param  {Context}    ctx                         Standard context object, representing the currently logged in user and its tenant
 * @param  {Content}    contentObj                  The content object to add the extra profile information on.
 * @param  {Boolean}    isManager                   Whether or not the current user is a manager of the piece of content.
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error that occurred, if any
 * @param  {Content}    callback.contentProfile     Full content profile
 */
var _getFullContentProfile = function(ctx, contentObj, isManager, callback) {
    // Store the isManager property.
    contentObj.isManager = isManager;

    // Get the user object for the createdBy property
    PrincipalsUtil.getPrincipal(ctx, contentObj.createdBy, function(err, createdBy) {
        if (err) {
            return callback(err);
        }
        contentObj.createdBy = createdBy;

        // Check if the user can share this content item
        _canShareContent(ctx, contentObj, function(err, canShare) {
            if (err) {
                return callback(err);
            }

            // Specify on the return value if the current user can share the content item
            contentObj.canShare = canShare;

            // For any other than collabdoc, we simply return with the share information
            if (contentObj.resourceSubType !== 'collabdoc') {
                return callback(null, contentObj);
            }

            // If the content item is a collaborative document, add the latest revision data
            _getRevision(ctx, contentObj, contentObj.latestRevisionId, function(err, revision) {
                if (err) {
                    return callback(err);
                }

                contentObj.latestRevision = revision;
                return callback(null, contentObj);
            });
        });
    });
};

/////////////////////////////////////
// Creating a new piece of content //
/////////////////////////////////////

/**
 * Create a new link
 *
 * @param  {Context}        ctx                Standard context object containing the current user and the current tenant
 * @param  {String}         displayName        The display name of the link
 * @param  {String}         [description]      A longer description for the link
 * @param  {String}         [visibility]       The visibility of the link. One of `public`, `loggedin`, `private`
 * @param  {String}         link               The URL for the link
 * @param  {Object}         additionalMembers  Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {Function}       callback           Standard callback function
 * @param  {Object}         callback.err       An error that occurred, if any
 * @param  {Content}        callback.content   The created link
 */
var createLink = module.exports.createLink = function(ctx, displayName, description, visibility, link, additionalMembers, callback) {
    callback = callback || function() {};

    // Setting content to default if no visibility setting is provided
    visibility = visibility || Config.getValue(ctx.tenant().alias, 'visibility', 'links');

    // Check if the link property is present. All other validation will be done in the _createContent function
    var validator = new Validator();
    validator.check(link, {'code': 400, 'msg': 'A valid link must be provided'}).isUrl();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to create a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var contentId = _generateContentId(ctx.tenant().alias);
    var revisionId = _generateRevisionId(contentId);
    _createContent(ctx, contentId, revisionId, 'link', displayName, description, visibility, additionalMembers, {'link': link}, {}, function(err, content, revision) {
        if (err) {
            return callback(err);
        }

        ContentAPI.emit(ContentConstants.events.CREATED_CONTENT, ctx, content, revision, additionalMembers);
        return callback(err, content);
    });
};

/**
 * Create a new file
 *
 * @param  {Context}   ctx                Standard context object containing the current user and the current tenant
 * @param  {String}    displayName        The display name of the file
 * @param  {String}    [description]      A longer description for the file
 * @param  {String}    [visibility]       The visibility of the file. One of `public`, `loggedin`, `private`
 * @param  {Object}    additionalMembers  Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {Object}    file               A file object as returned by express
 * @param  {Function}  callback           Standard callback function
 * @param  {Object}    callback.err       An error that occurred, if any
 * @param  {Content}   callback.content   The created file
 */
var createFile = module.exports.createFile = function(ctx, displayName, description, visibility, additionalMembers, file, callback) {
    // Wrap the callback function into a function that cleans up the file in case something went wrong
    var cleanUpCallback = _getCleanUpCallback({'file': file}, callback);

    // Try to create the file
    return _createFile(ctx, displayName, description, visibility, additionalMembers, file, cleanUpCallback);
};

/**
 * Returns a function that will call the provided callback function.
 * In case the returned function gets called with an error object, the passed in file object will
 * be removed from the file system.
 *
 * @param  {Object}    files                The ExpressJS files object.
 * @param  {Function}  callback             Standard callback function
 * @param  {Object}    callback.err         An error that occurred, if any
 * @param  {Content}   callback.content     JSON object containing the pool id of the created content
 * @return {Function}                       A function that removes the file on disk in case something went wrong.
 * @api private
 */
var _getCleanUpCallback = function(files, callback) {
    return function() {
        // Remember the arguments so we can pass them to the callback later.
        var callbackArguments = arguments;

        // The first argument is always the error object.
        var err = callbackArguments[0];

        if (err && files) {
            // Something went wrong with a request that has uploaded files associated to it.
            // In that case we try to remove the files.
            var fileObjects = _.values(files);
            _cleanupUploadedFiles(fileObjects, function() {
                return callback.apply(this, callbackArguments);
            });
        } else {
            // If we get here, the request might have failed, but it didn't contain an uploaded file.
            return callback.apply(this, callbackArguments);
        }
    };
};

/**
 * Recursively iterates trough an array of uploaded files and removes them.
 *
 * @param  {Object[]}   files       An array of ExpressJS file objects
 * @param  {Function}   callback    Standard callback function
 * @api private
 */
var _cleanupUploadedFiles = function(files, callback) {
    if (_.isEmpty(files)) {
        return callback();
    }

    var file = files.pop();
    if (file && file.path) {
        fs.exists(file.path, function(exists) {
            if (!exists) {
                return _cleanupUploadedFiles(files, callback);
            }

            fs.unlink(file.path, function(unlinkErr) {
                if (unlinkErr) {
                    log().warn({'err': unlinkErr, 'file': file}, 'Could not remove the uploaded file.');
                }

                return _cleanupUploadedFiles(files, callback);
            });
        });
    } else {
        return _cleanupUploadedFiles(files, callback);
    }
};

/**
 * Create a new file
 *
 * @param  {Context}   ctx                Standard context object containing the current user and the current tenant
 * @param  {String}    displayName        The display name of the file
 * @param  {String}    [description]      A longer description for the file
 * @param  {String}    [visibility]       The visibility of the file. One of `public`, `loggedin`, `private`
 * @param  {Object}    additionalMembers  Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {Object}    file               A file object as returned by express.
 * @param  {Function}  callback           Standard callback function
 * @param  {Object}    callback.err       An error that occurred, if any
 * @param  {Content}   callback.content   The created file
 * @api private
 */
var _createFile = function(ctx, displayName, description, visibility, additionalMembers, file, callback) {
    callback = callback || function() {};

    // Setting content to default if no visibility setting is provided
    visibility = visibility || Config.getValue(ctx.tenant().alias, 'visibility', 'files');

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Anonymous users are not allowed to upload files'}).isLoggedInUser(ctx);
    validator.check(file, {'code': 400, 'msg': 'Missing file parameter'}).notNull();
    validator.check(displayName, {'code': 400, 'msg': 'A display name must be provided'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'A display name can be at most 1000 characters long'}).isShortString();
    if (description) {
        validator.check(description, {'code': 400, 'msg': 'A content description can be at most 10000 characters long'}).isMediumString();
    }
    if (file) {
        validator.check(file.size, {'code': 400, 'msg': 'Missing size on the file object'}).notEmpty();
        validator.check(file.size, {'code': 400, 'msg': 'Invalid size on the file object'}).isInt();
        validator.check(file.size, {'code': 400, 'msg': 'Invalid size on the file object'}).min(0);
        validator.check(file.name, {'code': 400, 'msg': 'Missing name on the file object'}).notEmpty();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Generate a content ID that can be used when storing the file.
    var contentId = _generateContentId(ctx.tenant().alias);
    var revisionId = _generateRevisionId(contentId);

    // Detect the mimetype of the file using the file extension, as the one that Express gives us is pulled
    // from the HTTP request. This makes it an untrustworthy piece of information as some browsers are
    // notoriously bad at providing the correct mimetype and it can be spoofed. If the mimetype cannot
    // be determined, the mime utility falls back to application/octet-stream.
    file.type = mime.lookup(file.name);

    // We store the uploaded file in a location identified by the content id, then further identified by the revision id
    var options = {'resourceId': contentId, 'prefix': revisionId};
    ContentUtil.getStorageBackend(ctx).store(ctx, file, options, function(err, uri) {
        if (err) {
            return callback(err);
        }

        // Create the content and revision object.
        var otherValues = {
            'mime': file.type,
            'size': file.size.toString(),
            'filename': file.name
        };
        var revisionData = _.extend({}, otherValues, {'uri': uri});
        _createContent(ctx, contentId, revisionId, 'file', displayName, description, visibility, additionalMembers, otherValues, revisionData, function(err, contentObj, revision) {
            if (err) {
                return callback(err);
            }

            contentObj.filename = file.name;
            contentObj.size = file.size;
            contentObj.mime = file.type;

            ContentAPI.emit(ContentConstants.events.CREATED_CONTENT, ctx, contentObj, revision, additionalMembers);
            return callback(null, contentObj);
        });
    });
};

/////////////////////////////
// Collaborative documents //
/////////////////////////////

/**
 * Create a collaborative document as a pooled content item
 *
 * @param  {Context}   ctx                Standard context object containing the current user and the current tenant
 * @param  {String}    displayName        The display name of the collaborative document
 * @param  {String}    [description]      A longer description for the collaborative document
 * @param  {String}    [visibility]       The visibility of the collaborative document. One of `public`, `loggedin`, `private`
 * @param  {Object}    additionalMembers  Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {Function}  callback           Standard callback function
 * @param  {Object}    callback.err       An error that occurred, if any
 * @param  {Content}   callback.content   The created collaborative document
 */
var createCollabDoc = module.exports.createCollabDoc = function(ctx, displayName, description, visibility, additionalMembers, callback) {
    callback = callback || function() {};

    // Setting content to default if no visibility setting is provided
    visibility = visibility || Config.getValue(ctx.tenant().alias, 'visibility', 'collabdocs');

    var contentId = _generateContentId(ctx.tenant().alias);
    var revisionId = _generateRevisionId(contentId);
    Etherpad.createPad(contentId, function(err, ids) {
        if (err) {
            return callback(err);
        }

        _createContent(ctx, contentId, revisionId, 'collabdoc', displayName, description, visibility, additionalMembers, ids, {}, function(err, content, revision) {
            if (err) {
                return callback(err);
            }

            content.etherpadPadId = ids.etherpadPadId;
            content.etherpadGroupId = ids.etherpadGroupId;

            ContentAPI.emit(ContentConstants.events.CREATED_CONTENT, ctx, content, revision, additionalMembers);
            return callback(null, content);
        });
    });
};

/**
 * Publish a collaborative document. When a document is published the following happens:
 *
 *     -  The HTML for this pad is retrieved
 *     -  A new revision is created with this HTML
 *     -  The content object is updated with this HTML
 *     -  The content item gets bumped to the top of all the libraries it resides in
 *     -  An `updatedContent` event is fired so activities and PP images can be generated
 *
 * Note that this function does *NOT* perform any permission checks. It's assumed that
 * this function deals with messages coming from RabbitMQ. Producers of those messages
 * are expected to perform the necessary permissions checks. In the typical case
 * where Etherpad is submitting edit messages, the authorization happens by virtue of the app
 * server constructing a session in Etherpad.
 *
 * @param  {Object}     data                The message as sent by Etherpad
 * @param  {String}     data.contentId      The content id of the collaborative document that was published
 * @param  {String}     data.userId         The id of the user that published the document
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 */
var handlePublish = module.exports.handlePublish = function(data, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'data': data}, 'Error handling etherpad edit');
        }
    };

    log().trace({'data': data}, 'Got an etherpad edit');

    PrincipalsDAO.getPrincipal(data.userId, function(err, user) {
        if (err) {
            return callback(err);
        }

        var ctx = new Context(user.tenant, user);

        ContentDAO.Content.getContent(data.contentId, function(err, contentObj) {
            if (err) {
                return callback(err);
            }

            // Get the latest html from etherpad
            Etherpad.getHTML(contentObj.id, contentObj.etherpadPadId, function(err, html) {
                if (err) {
                    return callback(err);
                }

                // Get the latest OAE revision and compare the html that in Etherpad.
                // We only need to create a new revision if there is an actual update
                ContentDAO.Revisions.getRevision(contentObj.latestRevisionId, function(err, revision) {
                    if (err) {
                        return callback(err);
                    } else if (Etherpad.isContentEqual(revision.etherpadHtml, html) || (!revision.etherpadHtml && Etherpad.isContentEmpty(html))) {
                        // This situation can occur if 2 users were editting a collaborative document together, one of them leaves,
                        // the other one keeps idling (but doesn't make further chances) for a while and then leaves as well. There is no
                        // need to generate another revision as we already have one with the latest HTML. We do however raise an
                        // event so we can generate an "edited document"-activity for this user as well
                        ContentAPI.emit(ContentConstants.events.EDITED_COLLABDOC, ctx, contentObj);
                        return callback();
                    }

                    // Otherwise we create a new revision
                    var newRevisionId = _generateRevisionId(contentObj.id);
                    ContentDAO.Revisions.createRevision(newRevisionId, contentObj.id, data.userId, {'etherpadHtml': html}, function(err, revision) {
                        if (err) {
                            log().error({'err': err, 'contentId': contentObj.id}, 'Could not create a revision for this collaborative document');
                            return callback({'code': 500, 'msg': 'Could not create a revision for this collaborative document'});
                        }

                        // Update the content so we can easily retrieve it.
                        // This will also bump the collab doc to the top of the library lists
                        ContentDAO.Content.updateContent(contentObj, {'latestRevisionId': revision.revisionId}, true, function(err, newContentObj) {
                            if (err) {
                                log().error({'err': err, 'contentId': contentObj.id}, 'Could not update the main Content CF this collaborative document');
                                return callback({'code': 500, 'msg': 'Could not update this collaborative document'});
                            }

                            // Add the revision on the content object so the UI doesn't have to
                            // do another request to get the HTML
                            newContentObj.latestRevision = revision;

                            // Emit an event for activities and preview processing
                            ContentAPI.emit(ContentConstants.events.UPDATED_CONTENT_BODY, ctx, newContentObj, contentObj, revision);
                            return callback();
                        });
                    });
                });
            });
        });
    });
};

/**
 * Join a collaborative document.
 * Only users who have manager permissions on the collaborative document can join the pad.
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     contentId       The ID of the collaborative document that should be joined
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 * @param  {Object}     callback.url    JSON object containing the url where the pad is accessible
 */
var joinCollabDoc = module.exports.joinCollabDoc = function(ctx, contentId, callback) {
    // Check if we have access to this piece of content.
    canManage(ctx, contentId, function(err, canManage, contentObj) {
        if (err) {
            return callback(err);
        } else if (!canManage) {
            return callback({'code': 401, 'msg': 'You need to be a manager of this piece of content to be able to join it'});
        } else if (contentObj.resourceSubType !== 'collabdoc') {
            return callback({'code': 400, 'msg': 'This is not a collaborative document'});
        }

        // Join the pad
        Etherpad.joinPad(ctx, contentObj, function(err, data) {
            if (err) {
                return callback(err);
            }

            ContentDAO.Etherpad.saveAuthorId(data.author.authorID, ctx.user().id, function(err) {
                if (err) {
                    return callback(err);
                }

                return callback(null, {'url': data.url});
            });
        });
    });
};

/**
 * Create a new piece of pooled content
 *
 * @param  {Context}        ctx                Standard context object containing the current user and the current tenant
 * @param  {String}         contentId          The id of the content item
 * @param  {Strign}         revisionId         The id of the revision for the content item
 * @param  {String}         resourceSubType    The content item type. One of `file`, `collabdoc`, `link`
 * @param  {String}         displayName        The display name of the content item
 * @param  {String}         [description]      A longer description for the content item
 * @param  {String}         visibility         The visibility of the collaborative document. One of `public`, `loggedin`, `private`
 * @param  {Object}         additionalMembers  Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {Object}         otherValues        JSON object where the keys represent other metadata values that need to be stored, and the values represent the metadata values
 * @param  {Object}         revisionData       JSON object where the keys represent revision columns that need to be stored, and the values represent the revision values
 * @param  {Function}       callback           Standard callback function
 * @param  {Object}         callback.err       An error that occurred, if any
 * @param  {Content}        callback.content   The created content item
 * @param  {Revision}       callback.revision  The created revision
 * @api private
 */
var _createContent = function(ctx, contentId, revisionId, resourceSubType, displayName, description, visibility, additionalMembers, otherValues, revisionData, callback) {
    callback = callback || function() {};

    // Use an empty description if no description has been provided
    description = description || '';
    // Make sure the otherValues and additionalMembers are valid objects
    additionalMembers = additionalMembers || {};
    otherValues = otherValues || {};

    // Parameter validation
    var validator = new Validator();
    validator.check(displayName, {'code': 400, 'msg': 'A display name must be provided'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'A display name can be at most 1000 characters long'}).isShortString();
    if (description) {
        validator.check(description, {'code': 400, 'msg': 'A description can only be 10000 characters long'}).isMediumString();
    }
    validator.check(contentId, {'code': 400, 'msg': 'A content ID must be provided'}).isResourceId();
    validator.check(visibility, {'code': 400, 'msg': 'An invalid content visibility option has been provided. This can be "private", "loggedin" or "public"'}).isIn(_.values(AuthzConstants.visibility));
    validator.check(resourceSubType, {'code': 400, 'msg': 'A valid resourceSubType must be provided. This can be "file", "collabdoc" or "link"'}).isIn(ContentConstants.resourceSubTypes);
    validator.check(null, {'code': 400, 'msg': 'The additional members should be specified as an object'}).isObject(additionalMembers);
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to create a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // We need to check if we can interact with the additional members
    // before we create the content item
    var additionalMemberIds = _.keys(additionalMembers);
    PrincipalsDAO.getPrincipals(additionalMemberIds, null, function(err, principals) {
        if (err) {
            return callback(err);
        } else if (_.keys(principals).length !== additionalMemberIds.length) {
            return callback({'code': 400, 'msg': 'One or more target members being granted access do not exist'});
        }

        principals = _.values(principals);

        AuthzAPI.canInteract(ctx, ctx.tenant().alias, principals, function(err, canInteract, illegalPrincipalIds) {
            if (err) {
                return callback(err);
            } else if (!_.isEmpty(illegalPrincipalIds)) {
                return callback({'code': 400, 'msg': 'One or more target members being granted access are not authorized to become members on this content item'});
            }

            ContentDAO.Content.createContent(contentId, revisionId, ctx.user().id, resourceSubType, displayName, description, visibility, additionalMembers, otherValues, revisionData, function(err, contentObj, revision) {
                if (err) {
                    return callback(err);
                }

                // Make the current user a manager of the content
                additionalMembers[ctx.user().id] = ContentConstants.roles.MANAGER;
                _setContentPermissions(ctx, contentObj, additionalMembers, function(err, contentObj) {
                    if (err) {
                        return callback(err);
                    }

                    var allMembers = _.union(principals, [ctx.user()]);
                    ContentMembersLibrary.insert(contentObj, allMembers, function(err) {
                        if (err) {
                            log().warn({
                                'err': err,
                                'contentId': contentObj.id,
                                'principalIds': _.pluck(allMembers, 'id')
                            }, 'An error occurred while inserting members into a content members library while creating a content item');
                        }

                        return callback(null, contentObj, revision);
                    });
                });
            });
        });
    });
};

/////////////////////////////////
// Removing a piece of content //
/////////////////////////////////

/**
 * Delete a content item
 *
 * @param  {Context}   ctx               Standard context object containing the current user and the current tenant
 * @param  {String}    contentId         The id of the content item to delete
 * @param  {Function}  callback          Standard callback function
 * @param  {Object}    callback.err      An error that occurred, if any
 */
var deleteContent = module.exports.deleteContent = function(ctx, contentId, callback) {
    callback = callback || function() {};

    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to delete a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Fist check whether or not the current user is a manager of the piece of content
    canManage(ctx, contentId, function(err, canManage, contentObj) {
        if (err) {
            return callback(err);
        } else if (!canManage) {
            return callback({'code': 401, 'msg': 'You are not allowed to manage this piece of content'});
        }

        // Delete the content
        ContentDAO.Content.deleteContent(contentObj, function(err) {
            if (err) {
                return callback(err);
            }
            ContentAPI.emit(ContentConstants.events.DELETED_CONTENT, ctx, contentId);
            return callback();
        });
    });
};

////////////////////////////
// Content access control //
////////////////////////////

/**
 * Share a content item. This only be possible when the current user is a manager of the content, or if the current user is logged
 * in and the content item is public or visible to logged in users only. In case that the content is shared with principals that
 * are already content members, no updates to the existing role of those principals will be made
 *
 * @param  {Context}   ctx               Standard context object containing the current user and the current tenant
 * @param  {String}    contentId         The id of the content item to share
 * @param  {String[]}  principalIds      Array of principal ids with whom the content will be shared. By default, they will all be made members.
 * @param  {Function}  callback          Standard callback function
 * @param  {Object}    callback.err      An error that occurred, if any
 */
var shareContent = module.exports.shareContent = function(ctx, contentId, principalIds, callback) {
    callback = callback || function() {};

    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(principalIds.length, {'code': 400, 'msg': 'The content must at least be shared with 1 user or group'}).min(1);
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to share content'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the content item exists
    ContentDAO.Content.getContent(contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        // Check if the user is allowed to share this content item
        _canShareContent(ctx, contentObj, function(err, canShare) {
            if (err) {
                return callback(err);
            } else if (!canShare) {
                return callback({'code': 401, 'msg': 'You are not allowed to share this content'});
            }

            // Check the impact of making each user in the list a manager. We use this method to get a summary
            // of which users will be newly added and to ensure we are not violating tenant boundary
            // restrictions. We are testing with the "manager" role since we don't want this method to fail
            // on the basis that we might be making the last manager of the content item a "viewer", leaving it
            // without any managers
            var testPermissionChanges = _makeAllPermissionChanges(principalIds, ContentConstants.roles.MANAGER);
            _checkNewContentPermissions(ctx, contentObj, testPermissionChanges, function(err, membershipAfterChanges, newMemberIds, updatedMemberIds, removedMemberIds, newMembers) {
                if (err) {
                    return callback(err);
                } else if (_.isEmpty(newMembers)) {
                    // If there are no users being added, this means all users we are trying to
                    // share with already have this in their library, so we just succeed with a
                    // no-op
                    return callback();
                }

                // Set the viewer permissions for only users who previously had no role on the item
                var realPermissionChanges = _makeAllPermissionChanges(newMemberIds, ContentConstants.roles.VIEWER);
                _setContentPermissions(ctx, contentObj, realPermissionChanges, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Insert the new users into the content members library
                    ContentMembersLibrary.insert(contentObj, newMembers, function(err) {
                        if (err) {
                            log().warn({
                                'err': err,
                                'contentId': contentObj.id,
                                'principalIds': _.pluck(newMembers, 'id')
                            }, 'An error occurred while inserting principals into content members library after share');
                        }

                        ContentAPI.emit(ContentConstants.events.UPDATED_CONTENT_MEMBERS, ctx, contentObj, realPermissionChanges, newMemberIds, [], []);
                        return callback();
                    });
                });
            });
        });
    });
};

/**
 * Checks if a content item can be shared
 *
 * @param  {Context}    ctx                             The context of the current request
 * @param  {Content}    contentObj                      The content to test for access
 * @param  {Function}   callback                        Standard callback function
 * @param  {Object}     callback.err                    An error that occurred, if any
 * @param  {Boolean}    callback.canShare               `true` if the user in context is allowed to share the content item. `false` otherwise
 * @api private
 */
var _canShareContent = function(ctx, contentObj, callback) {
    // Anonymous users can never share
    var user = ctx.user();
    if (!user) {
        return callback(null, false);
    }

    // Check if we have access on the content item
    AuthzAPI.resolveImplicitRole(ctx, contentObj.id, contentObj.tenant.alias, contentObj.visibility, ContentConstants.roles.ALL_PRIORITY, function(err, implicitRole, canInteract) {
        if (implicitRole === ContentConstants.roles.MANAGER) {
            // Managers can always share
            return callback(null, true);
        } else if (canInteract) {
            // If we can interact with the item, we can always share it
            return callback(null, true);
        } else if (contentObj.visibility === AuthzConstants.visibility.PRIVATE) {
            // If the content is private, we need to be a manager to share it
            return AuthzAPI.hasRole(user.id, contentObj.id, ContentConstants.roles.MANAGER, callback);
        }

        // There is no implicit access and the content item is not private, so if we have any
        // explicit role on the content item we can share it
        return AuthzAPI.hasAnyRole(user.id, contentObj.id, callback);
    });
};

/**
 * Check whether or not the current user can manage a piece of content
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the content object we want to check
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Boolean}        callback.canManage  Whether or not the user can manage the content
 * @param  {Content}        callback.content    The retrieved content object containing its basic profile
 */
var canManage = module.exports.canManage = function(ctx, contentId, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to manage content'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            if (err.code === 401) {
                return callback(null, false);
            } else {
                return callback(err);
            }
        }

        _canManage(ctx, contentObj, function(err, canManage) {
            if (err) {
                return callback(err);
            }

            return callback(null, canManage, contentObj);
        });
    });
};

/**
 * Determine if the current user in context can manage all of the given content items
 *
 * @param  {Context}    ctx                         The context of the current request
 * @param  {Content[]}  contentItems                The content items to test
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error that occurred, if any
 * @param  {Boolean}    callback.canManageAll       Whether or not the user in context can manage all the provided content items
 * @param  {Content[]}  callback.cannotManageItems  If the user cannot manage all content items, this array will hold all the items they cannot manage
 */
var canManageAll = module.exports.canManageAll = function(ctx, contentItems, callback) {
    _canManageAll(ctx, contentItems.slice(), callback);
};

/**
 * Determine if the current user in context can manage all of the given content items. This internal
 * version of the `canManageAll` function is destructive to the `contentItems` array parameter
 *
 * @param  {Context}    ctx                         The context of the current request
 * @param  {Content[]}  contentItems                The content items to test
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error that occurred, if any
 * @param  {Boolean}    callback.canManageAll       Whether or not the user in context can manage all the provided content items
 * @param  {Content[]}  callback.cannotManageItems  If the user cannot manage all content items, this array will hold all the items they cannot manage
 * @api private
 */
var _canManageAll = function(ctx, contentItems, callback, _cannotManageContentItems) {
    _cannotManageContentItems = _cannotManageContentItems || [];
    if (_.isEmpty(contentItems)) {
        return callback(null, _.isEmpty(_cannotManageContentItems), _cannotManageContentItems);
    }

    var contentItem = contentItems.pop();
    _canManage(ctx, contentItem, function(err, canManage) {
        if (err) {
            return callback(err);
        } else if (!canManage) {
            _cannotManageContentItems.push(contentItem);
        }

        return _canManageAll(ctx, contentItems, callback, _cannotManageContentItems);
    });
};

/**
 * Internal function that checks whether or not the current user can manage a piece of content. This function assumes that
 * the piece of content passed in actually exists
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {Content}        contentObj          The content object we want to check
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Boolean}        callback.canManage  Whether or not the user can manage the content
 * @api private
 */
var _canManage = function(ctx, contentObj, callback) {
    if (!ctx.user()) {
        return callback(null, false);
    } else if (ctx.user().isAdmin(contentObj.tenant.alias)) {
        return callback(null, true);
    }

    return AuthzAPI.hasRole(ctx.user().id, contentObj.id, ContentConstants.roles.MANAGER, callback);
};

/**
 * Check whether or not the current user has access to a piece of content
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the content object we want to check
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Boolean}        callback.hasAccess  Whether or not the user has access to the content
 */
var hasAccess = module.exports.hasAccess = function(ctx, contentId, callback) {
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            // If the user doesn't have access to the content
            if (err.code ===  401) {
                return callback(null, false);
            } else {
                return callback(err);
            }
        }

        return callback(null, true);
    });
};

/**
 * Internal function that checks whether or not the current user has access to a piece of content. This function assumes that
 * the piece of content passed in actually exists
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {Content}        contentObj          The content object representing the content item we're checking access for
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Boolean}        callback.canManage  Whether or not the user has access to the content
 * @api private
 */
var _hasAccess = function(ctx, contentObj, callback) {
    if (contentObj.visibility === AuthzConstants.visibility.PUBLIC) {
        return callback(null, contentObj);
    // If the content is visible to logged in users, I get access if I'm logged in
    } else if (contentObj.visibility === AuthzConstants.visibility.LOGGEDIN && TenantsUtil.isLoggedIn(ctx, contentObj.tenant.alias)) {
        return callback(null, contentObj);
    // If the user is admin of the content's tenant, they have access
    } else if (ctx.user() && ctx.user().isAdmin(contentObj.tenant.alias)) {
        return callback(null, contentObj);
    // If the content is private
    } else if (ctx.user()) {
        return AuthzAPI.hasAnyRole(ctx.user().id, contentObj.id, callback);
    }

    return callback({'code': 401, 'msg': 'You don\'t have access to this piece of content'});
};

/**
 * Update, add or remove the role of a set of principals on a piece of content
 *
 * @param  {Context}         ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}          contentId           The id of the content item to update the members for
 * @param  {Object}          permissionChanges   Object where the keys represent the principal ids for which the content permissions should be updated/added/removed. The value is a string representing the new role. If false is passed in, the permissions for that principal will be removed e.g. {'user1': 'manager', 'user2': 'viewer', 'user3': false}
 * @param  {Function}        callback            Standard callback function
 * @param  {Object}          callback.err        An error that occurred, if any
 */
var setContentPermissions = module.exports.setContentPermissions = function(ctx, contentId, permissionChanges, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(_.keys(permissionChanges).length, {'code': 400, 'msg': 'You should specify at least 1 user/group to set content permissions on'}).min(1);
    _.each(permissionChanges, function(role, principalId) {
        validator.check(principalId, {'code': 400, 'msg': 'A principalId needs to be specified for a role.'}).isPrincipalId();
        // A role can be set to false if we're removing it.
        if (role !== false) {
            validator.check(role, {'code': 400, 'msg': 'An invalid role has been specified.'}).isIn(ContentConstants.roles.ALL_PRIORITY);
        }
    });
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to create a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the content exists
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        // Check if the current user can manage the content
        _canManage(ctx, contentObj, function(err, canManage) {
            if (err) {
                return callback(err);
            } else if (!canManage) {
                return callback({'code': 401, 'msg': 'You are not allowed to manage this piece of content'});
            }

            // Ensure that we're not crossing tenant boundaries or violating principal visibility settings
            _checkNewContentPermissions(ctx, contentObj, permissionChanges, function(err, membershipAfterChanges, newMemberIds, updatedMemberIds, removedMemberIds, newMembers) {
                if (err) {
                    return callback(err);
                }

                // Apply the permission changes to the content. This will then update the content libraries as well
                _setContentPermissions(ctx, contentObj, permissionChanges, function(err, newContentObj) {
                    if (err) {
                        return callback(err);
                    }

                    // If setting the content permissions results in any new members, we should insert them into the content members library
                    ContentMembersLibrary.insert(contentObj, newMembers, function(err) {
                        if (err) {
                            log().warn({
                                'err': err,
                                'contentId': contentObj.id,
                                'principalIds': newMemberIds
                            }, 'An error occurred while inserting principals into content members library while setting content permissions');
                        }

                        // If setting the content permissions results in removing members from the content item, we should remove them from the content members library
                        ContentMembersLibrary.remove(contentObj, removedMemberIds, function(err) {
                            if (err) {
                                log().warn({
                                    'err': err,
                                    'contentId': contentObj.id,
                                    'principalIds': removedMemberIds
                                }, 'An error occurred while removing principals from content members library while setting content permissions');
                            }

                            ContentAPI.emit(ContentConstants.events.UPDATED_CONTENT_MEMBERS, ctx, newContentObj, permissionChanges, newMemberIds, updatedMemberIds, removedMemberIds);
                            return callback();
                        });
                    });
                });
            });
        });
    });
};

/**
 * Internal method that checks if the new permission set for a piece of content doesn't leave the content item without any managers
 * and that the current user can interact with all the specified principals
 *
 * @param  {Context}    ctx                                 The current execution context
 * @param  {Content}    contentObj                          The content object we want to set permissions on
 * @param  {Object}     newPermissions                      Object where the keys represent the principal ids for which the content permissions should be updated/added/removed. The value is a string representing the new role. If false is passed in, the permissions for that principal will be removed e.g. {'user1': 'manager', 'user2': 'viewer', 'user3': false}
 * @param  {Function}   callback                            Standard callback function takes argument `err`
 * @param  {Object}     callback.err                        Error object containing the error message
 * @param  {Object}     callback.membershipAfterChanges     An object whose key is a principal id and value is a role, representing what the full content membership would be if the changes were applied
 * @param  {String[]}   callback.newMemberIds               An array of principal ids, representing the members being added to the content item
 * @param  {String[]}   callback.updatedMemberIds           An array of principal ids, representing whose roles are being updated on the content item
 * @param  {String[]}   callback.removedMemberIds           An array of principal ids, representing, the members being removed from the content item
 * @param  {Object[]}   callback.newMembers                 The full principal objects of just the new members being added
 * @api private
 */
var _checkNewContentPermissions = function(ctx, contentObj, newPermissions, callback) {
    AuthzAPI.computeMemberRolesAfterChanges(contentObj.id, newPermissions, function(err, membershipAfterChanges, newMemberIds, updatedMemberIds, removedMemberIds) {
        if (err) {
            return callback(err);
        }

        // Check if all of the provided principals being added exist
        PrincipalsDAO.getPrincipals(newMemberIds, null, function(err, newMembers) {
            if (err) {
                return callback(err);
            }

            newMembers = _.values(newMembers);
            if (newMembers.length !== newMemberIds.length) {
                return callback({'code': 400, 'msg': 'One or more target members being granted access do not exist'});
            }

            // Check if we're allowed to interact with the new members. We don't check the removed /
            // updated members as we need to be able to change their permissions regardless of their
            // visibility/tenant settings
            AuthzAPI.canInteract(ctx, contentObj.tenant.alias, newMembers, function(err, canInteract, illegalPrincipalIds) {
                if (err) {
                    return callback(err);
                } else if (!_.isEmpty(illegalPrincipalIds)) {
                    return callback({'code': 400, 'msg': 'One or more target members being granted access are not authorized to become members on this content item'});
                } else if (!_.chain(membershipAfterChanges).values().contains(ContentConstants.roles.MANAGER).value()) {
                    return callback({'code': 400, 'msg': 'After this operation, the content item would be left without a manager'});
                }

                return callback(null, membershipAfterChanges, newMemberIds, updatedMemberIds, removedMemberIds, newMembers);
            });
        });
    });
};

/**
 * Internal function used to update, add or remove the role of a set of principals on a content item. This function will assume that
 * the content object exists and that the current user is a manager of the content. It will update the lastModified date of the content
 * item as well since the content item should appear newly updated in user libraries. It's assumed that the new content permissions
 * don't cause any inconsistencies such as no managers or members left on the piece of content.
 *
 * @param  {Context}         ctx                        The current execution context
 * @param  {Content}         contentObj                 The content object we want to set permissions on
 * @param  {Object}          newPermissions             Object where the keys represent the principal ids for which the content permissions should be updated/added/removed. The value is a string representing the new role. If false is passed in, the permissions for that principal will be removed e.g. {'user1': 'manager', 'user2': 'viewer', 'user3': false}
 * @param  {Function}        callback                   Standard callback function
 * @param  {Object}          callback.err               An error that occurred, if any
 * @param  {Content}         callback.newContentObj     The content object with the updated `lastModified` timestamp
 * @api private
 */
var _setContentPermissions = function(ctx, contentObj, newPermissions, callback) {
    // Update the roles CF
    AuthzAPI.updateRoles(contentObj.id, newPermissions, function(err) {
        if (err) {
            return callback(err);
        }

        var removedMemberIds = [];
        _.each(newPermissions, function(role, principalId) {
            if (role === false) {
                removedMemberIds.push(principalId);
            }
        });

        // Now update all of the libraries this affects
        ContentDAO.Content.updateContentLibraries(contentObj, removedMemberIds, function(err, newContentObj) {
            if (err) {
                // If there was an error updating libraries here, the permissions were still changed, so we should not return an error. Just log it.
                log().warn({
                    'err': err,
                    'contentObj': contentObj,
                    'removedMemberIds': removedMemberIds
                }, 'Failed to update user libraries after updating content permissions.');

                if (newContentObj) {
                    // We successfully updated the timestamp of the content object, so we return that one
                    return callback(null, newContentObj);
                } else {
                    // We did not successfully update the timestamp, return the old content object
                    return callback(null, contentObj);
                }
            }

            return callback(null, newContentObj);
        });
    });
};


/**
 * Remove a content item from a content library. This is its own API method due to special permission handling required, as the user
 * is effectively updating a content permissions (removing themselves, or removing it from a group they manage), and they might not
 * necessarily have access to update the permissions of the private content (e.g., they are only a member). Also, tenant privacy
 * rules do not come into play in this case.
 *
 * @param  {Context}    ctx             The context of the current request
 * @param  {String}     libraryOwnerId  The id of the principal from whose content library to remove the content item
 * @param  {String}     contentId       The id of the content item to remove from the library
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var removeContentFromLibrary = module.exports.removeContentFromLibrary = function(ctx, libraryOwnerId, contentId, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You must be authenticated to remove a piece of content from a library'}).isLoggedInUser(ctx);
    validator.check(libraryOwnerId, {'code': 400, 'msg': 'A user or group id must be provided'}).isPrincipalId();
    validator.check(contentId, {'code': 400, 'msg': 'A valid content id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Make sure the content exists
    ContentDAO.Content.getContent(contentId, function(err, content) {
        if (err) {
            return callback(err);
        }

        // Verify the current user has access to remove content items from the target library
        LibraryAPI.Authz.canRemoveFromLibrary(ctx, libraryOwnerId, function(err, canRemove) {
            if (err) {
                return callback(err);
            } else if (!canRemove) {
                return callback({'code': 401, 'msg': 'You are not authorized to delete a piece of content from this library'});
            }

            var permissionChanges = {};
            permissionChanges[libraryOwnerId] = false;

            // Ensure we are actually removing something, and that we'll be left with at least one manager afterward
            AuthzAPI.computeMemberRolesAfterChanges(contentId, permissionChanges, function(err, membershipAfterChanges, newMemberIds, updatedMemberIds, removedMemberIds) {
                if (err) {
                    return callback(err);
                } else if (!_.chain(membershipAfterChanges).values().contains(ContentConstants.roles.MANAGER).value()) {
                    // If the anticipated membership after these changes has no manager, bail out
                    return callback({'code': 400, 'msg': 'The requested change results in a piece of content with no managers'});
                } else if (_.isEmpty(removedMemberIds)) {
                    return callback({'code': 400, 'msg': 'The specified piece of content is not in this library'});
                }

                // All validation checks have passed, finally persist the role change and update the user library
                AuthzAPI.updateRoles(contentId, permissionChanges, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    LibraryAPI.Index.remove(ContentConstants.library.CONTENT_LIBRARY_INDEX_NAME, [ libraryOwnerId ], content.id, content.lastModified, function(err) {
                        if (err) {
                            log().error({
                                'err': err,
                                'principalIds': principalIds,
                                'contentId': content.id
                            }, 'Error removing content item from principal libraries');
                            return callback(err);
                        }

                        ContentAPI.emit(ContentConstants.events.UPDATED_CONTENT_MEMBERS, ctx, content, permissionChanges, newMemberIds, updatedMemberIds, removedMemberIds);
                        return callback();
                    });
                });
            });
        });
    });
};


/**
 * Get the members of a content item and their roles
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the content item to get the members for
 * @param  {String}         start               The content paging token from which to start fetching content members. If not provided, the first x elements will be returned
 * @param  {Number}         limit               The maximum number of results to return. Default: 10
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Object[]}       callback.members    Array that contains an object for each member. Each object has a role property that contains the role of the member and a profile property that contains the principal profile of the member
 * @param  {String}         callback.nextToken  The value to provide in the `start` parameter to get the next set of results
 */
var getContentMembersLibrary = module.exports.getContentMembersLibrary = function(ctx, contentId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(limit, {'code': 400, 'msg': 'A valid limit should be passed in'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    ContentDAO.Content.getContent(contentId, function(err, content) {
        if (err) {
            return callback(err);
        }

        // Determine if and how the current user should access the content members library
        LibraryAPI.Authz.resolveTargetLibraryAccess(ctx, content.id, content.visibility, function(err, hasAccess, visibility) {
            if (err) {
                return callback(err);
            } else if (!hasAccess) {
                return callback({'code': 401, 'msg': 'You are not authorized to access the members of this content item'});
            }

            // Get the members of the content item from the members library
            ContentMembersLibrary.list(content, visibility, {'start': start, 'limit': limit}, function(err, memberIds, nextToken) {
                if (err) {
                    return callback(err);
                } else if (_.isEmpty(memberIds)) {
                    return callback(null, [], nextToken);
                }

                // Get the roles of the members on the content item
                AuthzAPI.getDirectRoles(memberIds, content.id, function(err, memberRoles) {
                    if (err) {
                        return callback(err);
                    }

                    // Get the member profiles
                    PrincipalsUtil.getPrincipals(ctx, memberIds, function(err, memberProfiles) {
                        if (err) {
                            return callback(err);
                        }

                        var memberList = _.chain(memberIds)
                            .map(function(memberId) {
                                var memberProfile = memberProfiles[memberId];
                                var memberRole = memberRoles[memberId];
                                if (memberProfile && memberRole) {
                                    return {
                                        'profile': memberProfile,
                                        'role': memberRole
                                    };
                                }
                            })
                            .compact()
                            .value();

                        return callback(null, memberList, nextToken);
                    });
                });
            });
        });
    });
};

/////////////////////////////
// Update content metadata //
/////////////////////////////

/**
 * Update the file body that is associated with a file content item.
 *
 * @param  {Context}    ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}     contentId           The id of the file to upload a new version for
 * @param  {File}       file                An expressjs File object that holds the data for the file that needs updating
 * @param  {Function}   [callback]          Standard callback function
 * @param  {Object}     [callback.err]      An error that occurred, if any
 * @param  {Content}    [callback.content]  The updated content item
 */
var updateFileBody = module.exports.updateFileBody = function(ctx, contentId, file, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Error updating the filebody for %s', contentId);
        }
    };

    // Wrap the callback function into a function that cleans up the file in case something went wrong
    var cleanUpCallback = _getCleanUpCallback({'file': file}, callback);

    // Perform the update
    return _updateFileBody(ctx, contentId, file, cleanUpCallback);
};

/**
 * Update the file body that is associated with an uploaded file.
 *
 * @param  {Context}    ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}     contentId           The id of the file to upload a new version for
 * @param  {File}       file                An expressjs File object that holds the data for the file that needs updating.
 * @param  {Function}   [callback]          Standard callback function
 * @param  {Object}     [callback.err]      An error that occurred, if any
 * @param  {Content}    [callback.content]  The updated content item
 * @api private
 */
var _updateFileBody = function(ctx, contentId, file, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a content item'}).isLoggedInUser(ctx);
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(file, {'code': 400, 'msg': 'Missing file parameter.'}).notNull();
    if (file) {
        validator.check(file.size, {'code': 400, 'msg': 'Missing size on the file object.'}).notEmpty();
        validator.check(file.size, {'code': 400, 'msg': 'Invalid size on the file object.'}).isInt();
        validator.check(file.size, {'code': 400, 'msg': 'Invalid size on the file object.'}).min(0);
        validator.check(file.name, {'code': 400, 'msg': 'Missing name on the file object.'}).notEmpty();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    canManage(ctx, contentId, function(err, isManager, contentObj) {
        if (err) {
            return callback(err);
        } else if (!isManager) {
            return callback({'code': 401, 'msg': 'You are not allowed to manage this piece of content'});
        } else if (contentObj.resourceSubType !== 'file') {
            return callback({'code': 400, 'msg': 'This content object is not a file.'});
        }

        // Create a revision id ahead of time for the new revision, so we know where to store the file body for it
        var revisionId = _generateRevisionId(contentId);

        // Detect the mimetype of the file using the file extension, as the one that Express gives us is pulled
        // from the HTTP request. This makes it an untrustworthy piece of information as some browsers are
        // notoriously bad at providing the correct mimetype and it can be spoofed. If the mimetype cannot
        // be determined, the mime utility falls back to application/octet-stream.
        file.type = mime.lookup(file.name);

        // Store the file, using the current time as the folder name
        var options = {'resourceId': contentObj.id, 'prefix': revisionId};
        ContentUtil.getStorageBackend(ctx).store(ctx, file, options, function(err, uri) {
            if (err) {
                return callback(err);
            }

            // Create the revision
            var opts = {
                'mime': file.type,
                'size': file.size.toString(),
                'filename': file.name,
                'uri': uri
            };

            ContentDAO.Revisions.createRevision(revisionId, contentObj.id, ctx.user().id, opts, function(err, revision) {
                if (err) {
                    return callback(err);
                }

                // Set the new filesize, filename and mimetype on the Content object so the UI
                // can retrieve all the relevant metadata in 1 Cassandra query
                opts.latestRevisionId = revision.revisionId;

                // We have to set the previews status back to pending
                opts.previews = {'status': ContentConstants.previews.PENDING};
                ContentDAO.Content.updateContent(contentObj, opts, true, function(err, updatedContentObj) {
                    if (err) {
                        return callback(err);
                    }

                    ContentAPI.emit(ContentConstants.events.UPDATED_CONTENT_BODY, ctx, updatedContentObj, contentObj, revision);

                    // Output a full content profile
                    return _getFullContentProfile(ctx, updatedContentObj, true, callback);
                });
            });
        });
    });
};

/**
 * Attaches preview items to, or set the status of, a revision of a piece of content. This can only be used by a global admin and should technically only
 *  be executed by the preview processor.
 *
 * @param  {Context}     ctx                 Current execution context.
 * @param  {String}      contentId           The ID of the content item.
 * @param  {String}      revisionId          The revision ID of the content item.
 * @param  {String}      status              The result of the preview processing operation. It should be one of the values of ContentConstants.previews.
 * @param  {Object}      [files]             An object whose key that represents the preview "name" (e.g., page1.html, large.png, etc...) and the value is either an ExpressJS File object or a string representing an external URL at which to reference a preview item. When listing preview items, the items will be ordered ALPHABETICALLY according to the keys in this object.
 * @param  {Object}      [sizes]             Each key maps a filename to a preview size.
 * @param  {Object}      [contentMetadata]   An object that holds optional content metadata, data like displayName for example can be passed in here.
 * @param  {Object}      [previewMetadata]   An object that holds optional preview metadata, data like pageCount for example can be passed in here.
 * @param  {Function}    callback            Standard callback function
 * @param  {Object}      callback.err        An error that occurred, if any
 */
var setPreviewItems = module.exports.setPreviewItems = function(ctx, contentId, revisionId, status, files, sizes, contentMetadata, previewMetadata, callback) {
    files = files || {};
    sizes = sizes || {};
    contentMetadata = contentMetadata || {};
    previewMetadata = previewMetadata || {};

    // Wrap the callback method, which takes care of cleaning up the files if something goes wrong
    var cleanUpCallback = _getCleanUpCallback(files, callback);

    var validStatuses = _.values(ContentConstants.previews);
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'Missing or invalid contentId'}).isResourceId();
    validator.check(revisionId, {'code': 400, 'msg': 'Missing or invalid revisionId'}).isResourceId();
    validator.check(status, {'code': 400, 'msg': 'The status parameter must be one of: ' + validStatuses.join(', ')}).isIn(validStatuses);
    if (validator.hasErrors()) {
        return cleanUpCallback(validator.getFirstError());
    }

    ContentDAO.Content.getContent(contentId, function(err, contentObj) {
        if (err) {
            return cleanUpCallback(err);
        }

        // Ensure the user is an administrator of the content item's tenant before continuing further
        if (!ctx.user() || !(ctx.user().isGlobalAdmin() || ctx.user().isTenantAdmin(contentObj.tenant.alias))) {
            return cleanUpCallback({'code': 401, 'msg': 'Only administrators can attach preview items to a content item'});
        }

        ContentDAO.Revisions.getRevision(revisionId, function(err, revision) {
            if (err) {
                return cleanUpCallback(err);
            }

            // Ensure that the revision supplied is a revision of the specified content item
            validator.check(revision.contentId, {'code': 400, 'msg': 'Specified revisionId does not belong to the specifed content item'}).equals(contentId);
            if (validator.hasErrors()) {
                return cleanUpCallback(validator.getFirstError());
            }

            var fileData = {};
            var fileKeys = Object.keys(files);
            var todo = fileKeys.length;

            // The storage URI for the thumbnail image. Will be set to the appropriate preview uri in a later loop
            var thumbnailUri = null;


            if (status === ContentConstants.previews.ERROR || todo === 0) {
                // Preview generation failed or no files were uploaded, store that information in the database
                return ContentDAO.Previews.storeMetadata(contentObj, revisionId, status, thumbnailUri, contentMetadata, previewMetadata, fileData, callback);
            }

            // Preview generation was successful, store the files

            // We store the previews in a location within the content item, in the preview directory specified for the revision
            var storePrefix = 'previews/' + revision.previewsId;
            var called = false;

            /*!
             * Convenience method that handles the completion of storing a preview item to backend storage. When all
             * items have completed and invoked this method, it will call the final callback to exit this method.
             *
             * @param  {Object}     err     An error that occurred, if any
             */
            var _finishIteration = function(err) {
                // If we have already called back (e.g., because of an error), ignore this invokation
                if (called) {
                    return;
                }

                // Always decrement todo, whether or not there is an error
                todo--;

                // If we had an error, exit immediately
                if (err) {
                    called = true;
                    return cleanUpCallback(err);
                } else if (todo === 0 && !called) {
                    // All files have been stored, store the metadata and exit
                    called = true;
                    log().trace({'data': fileData}, 'Storing %d content preview files', fileKeys.length);
                    ContentDAO.Previews.storeMetadata(contentObj, revisionId, status, thumbnailUri, contentMetadata, previewMetadata, fileData, function(err) {
                        if (err) {
                            return callback(err);
                        }

                        // Indicate that we've just updated a preview
                        ContentAPI.emit(ContentConstants.events.UPDATED_CONTENT_PREVIEW, ctx, contentObj.id, contentObj);

                        return callback();
                    });
                }
            };

            // Iterate each preview item, store it and record it in the `previewMetadata` hash
            fileKeys.forEach(function(key) {
                var size = sizes[key];
                if (!size) {
                    todo--;
                    log().warn('Ignoring file %s as it has no size associated to it', key);
                    return;
                }

                // Store the file with a regular storage backend
                var options = {'resourceId': contentObj.id, 'prefix': storePrefix};
                _storePreview(ctx, files[key], options, function(err, uri) {
                    if (err) {
                        return _finishIteration(err);
                    }

                    // Remember the thumbnail uri separately so we can stick it on the main content object
                    if (size === 'thumbnail') {
                        thumbnailUri = uri;

                    // Remember the small, medium and large URIs so we can stick it on the previews object
                    } else if (size === 'small') {
                        previewMetadata['smallUri'] = uri;
                    } else if (size === 'medium') {
                        previewMetadata['mediumUri'] = uri;
                    } else if (size === 'large') {
                        previewMetadata['largeUri'] = uri;
                    } else if (size === 'wide') {
                        previewMetadata['wideUri'] = uri;
                    }

                    // Aggregate the file info so it can be stored in Cassandra after all preview bodies have been stored
                    fileData[files[key].name] = size + '#' + uri;
                    return _finishIteration();
                });
            });
        });
    });
};

/**
 * Verifies the signature for a preview item that is associated to a piece of content.
 * If the signature is valid, an object will be returned that the REST handlers can use
 * to redirect the user to the actual file.
 *
 * @param  {Context}            ctx                             The current context
 * @param  {String}             contentId                       The content ID that the preview item is associated with
 * @param  {String}             revisionId                      The revision ID that the preview item is associated with
 * @param  {String}             previewItem                     The preview item that needs to be retrieved
 * @param  {Object}             signatureData                   The signature data to check, as created by `Signature.createExpiringResourceSignature`
 * @param  {Function}           callback                        Standard callback function
 * @param  {Object}             callback.err                    An error that occurred, if any
 * @param  {Object}             callback.downloadInfo           An object containing information necessary for downloading the preview
 * @param  {String}             callback.downloadInfo.filename  The filename to suggest to the client for the download
 * @param  {DownloadStrategy}   callback.downloadInfo.strategy  The DownloadStrategy that details how to download the preview
 */
var getSignedPreviewDownloadInfo = module.exports.getSignedPreviewDownloadInfo = function(ctx, contentId, revisionId, previewItem, signatureData, callback) {
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'Missing content ID'}).isResourceId();
    validator.check(revisionId, {'code': 400, 'msg': 'Missing revision ID'}).isResourceId();
    validator.check(previewItem, {'code': 400, 'msg': 'Missing preview item'}).notEmpty();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    } else if (!Signature.verifyExpiringResourceSignature(ctx, contentId, signatureData.expires, signatureData.signature)) {
        return callback({'code': 401, 'msg': 'Invalid content signature data for accessing previews'});
    }

    ContentDAO.Previews.getContentPreview(revisionId, previewItem, function(err, preview) {
        if (err) {
            return callback(err);
        }

        var downloadStrategy = ContentUtil.getStorageBackend(ctx, preview.uri).getDownloadStrategy(ctx, preview.uri);
        return callback(null, {'filename': previewItem, 'strategy': downloadStrategy});
    });
};

/**
 * Get the revisions for a revision
 *
 * @param  {Context}     ctx                 The current context.
 * @param  {String}      contentId           The id of the content item to get the previews for
 * @param  {String}      revisionId          The id of the revision to get the previews for
 * @param  {Function}    callback            Standard callback function
 * @param  {Object}      callback.err        An error that occurred, if any
 * @param  {Object}      callback.results    Object with a key `files` that holds an array of strings that are the filenames for previews and a key `signature` which holds the signature and expires parameters that should be sent when retrieving the preview bodies.
 */
var getPreviewItems = module.exports.getPreviewItems = function(ctx, contentId, revisionId, callback) {
    getContent(ctx, contentId, function(err, content) {
        if (err) {
            return callback(err);
        }

        ContentDAO.Previews.getContentPreviews(revisionId, function(err, previews) {
            if (err) {
                return callback(err);
            }

            // Generate an expiring signature
            var signature = Signature.createExpiringResourceSignature(ctx, content.id);
            var result = {
                'files': previews,
                'signature': signature
            };

            callback(null, result);
        });
    });
};

/**
 * Update a content item. This can only be done by the manager of that piece of content.
 *
 * @param  {Context}        ctx                     Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId               The id of the content item to update
 * @param  {Object}         profileFields           Object where the keys represent the profile fields that need to be updated and the values represent the new values for those profile fields e.g. {'displayName': 'New content name', 'description': 'New content description', 'visibility': 'private'}
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Content}        callback.newContentObj  The updated content item
 */
var updateContentMetadata = module.exports.updateContentMetadata = function(ctx, contentId, profileFields, callback) {
    callback = callback || function() {};

    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    // Check that at a minimum name or description have been provided
    var fieldNames = profileFields ? _.keys(profileFields) : [];
    validator.check(fieldNames.length, {'code': 400, 'msg': 'You should at least specify a new displayName, description, visibility or link'}).min(1);
    for (var i = 0; i < fieldNames.length; i++) {
        var fieldName = fieldNames[i];
        validator.check(fieldName, {'code': 400, 'msg': fieldName + ' is not a recognized content profile field'}).isIn(['displayName', 'description', 'visibility', 'link']);
        if (fieldName === 'displayName') {
            validator.check(profileFields['displayName'], {'code': 400, 'msg': 'A display name cannot be empty'}).notEmpty();
            validator.check(profileFields['displayName'], {'code': 400, 'msg': 'A display name can be at most 1000 characters long'}).isShortString();
        } else if (fieldName === 'description' && profileFields['description']) {
            validator.check(profileFields['description'], {'code': 400, 'msg': 'A description can only be 10000 characters long'}).isMediumString();
        } else if (fieldName === 'link') {
            validator.check(profileFields['link'], {'code': 400, 'msg': 'A valid link should be provided'}).isUrl();
        }
    }
    if (profileFields['visibility']) {
        validator.check(profileFields['visibility'], {'code': 400, 'msg': 'An invalid content visibility option has been provided. This can be "private", "loggedin" or "public"'}).isIn(_.values(AuthzConstants.visibility));
    }
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // First check whether or not the current user is a manager of the piece of content
    canManage(ctx, contentId, function(err, canManage, oldContentObj) {
        if (err) {
            return callback(err);
        } else if (!canManage) {
            return callback({'code': 401, 'msg': 'You are not allowed to manage this piece of content'});
        }

        if (profileFields.link) {
            if (oldContentObj.resourceSubType !== 'link') {
                return callback({'code': 400, 'msg': 'This piece of content is not a link'});
            } else if (profileFields.link !== oldContentObj.link) {
                // Reset the previews object so we don't show the old preview items while the new link is still being processed
                profileFields.previews = {'status': ContentConstants.previews.PENDING};
            }
        }

        ContentDAO.Content.updateContent(oldContentObj, profileFields, true, function(err, newContentObj) {
            if (err) {
                return callback(err);
            }

            ContentAPI.emit(ContentConstants.events.UPDATED_CONTENT, ctx, newContentObj, oldContentObj);

            // Add the isManager, createdBy, .. properties.
            _getFullContentProfile(ctx, newContentObj, true, callback);
        });
    });
};


// TODO: Split this out once we reorganize the content API
///////////////////////////
// Comment functionality //
///////////////////////////

/**
 * Create a new comment on a content item. Returns an error if saving the comment goes wrong or the user doesn't have access.
 * Only logged in users who can see the content are able to post comments.
 *
 * @param  {Context}    ctx                         Standard context object, representing the currently logged in user and its tenant
 * @param  {String}     contentId                   The id of the content item to which to post the comment
 * @param  {String}     body                        The body of the comment
 * @param  {String}     [replyToCreatedTimestamp]   The timestamp of the comment to which this comment is a reply. Not specifying this will create a top level comment
 * @param  {Function}   [callback]                  Standard callback function
 * @param  {Object}     [callback.err]              An error that occurred, if any
 * @param  {Comment}    [callback.comment]          The created comment
 */
var createComment = module.exports.createComment = function(ctx, contentId, body, replyToCreatedTimestamp, callback) {
    callback = callback || function() {};

    // Parameter validation
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authorized users can post comments'}).isLoggedInUser(ctx);
    validator.check(contentId, {'code': 400, 'msg': 'Invalid content resource id provided'}).isResourceId();
    validator.check(body, {'code': 400, 'msg': 'A comment must be provided'}).notEmpty();
    validator.check(body, {'code': 400, 'msg': 'A comment can only be 100000 characters long'}).isLongString();
    if (replyToCreatedTimestamp) {
        validator.check(replyToCreatedTimestamp, {'code': 400, 'msg': 'Invalid reply-to timestamp provided'}).isInt();
    }

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Verify the user has access to the content object
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        MessageBoxAPI.createMessage(contentId, ctx.user().id, body, {'replyToCreated': replyToCreatedTimestamp}, function(err, message) {
            if (err) {
                return callback(err);
            }

            // Get a UI-appropriate representation of the current user
            PrincipalsUtil.getPrincipal(ctx, ctx.user().id, function(err, createdBy) {
                if (err) {
                    return callback(err);
                }

                message.createdBy = createdBy;
                ContentAPI.emit(ContentConstants.events.CREATED_COMMENT, ctx, message, contentObj);
                return callback(null, message);
            });
        });
    });
};

/**
 * Get the comments for a content item. Everyone who has access to the content item will be able to retrieve the list of comments.
 *
 * @param  {Context}    ctx                  Standard context object, representing the currently logged in user and its tenant
 * @param  {String}     contentId            The id of the content item for which to get the comments
 * @param  {String}     start                The comments paging token from which to start fetching comments
 * @param  {Number}     limit                The maximum number of results to return. Default: 10
 * @param  {Function}   callback             Standard callback function
 * @param  {Object}     callback.err         An error that occurred, if any
 * @param  {Comment[]}  callback.comments    The comments on the content item
 * @param  {String}     callback.nextToken   The value to provide in the `start` parameter to get the next set of results
 */
var getComments = module.exports.getComments = function(ctx, contentId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'Invalid content resource id provided'}).isResourceId();
    validator.check(limit, {'code': 400, 'msg': 'A valid limit should be passed in'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        MessageBoxAPI.getMessagesFromMessageBox(contentId, start, limit, null, function(err, comments, nextToken) {
            if (err) {
                return callback(err);
            }

            // Get information on the commenters
            var userIds = _.chain(comments)
                .pluck('createdBy')
                .compact()
                .uniq()
                .value();

            // Get the basic principal profiles of the commenters to add to the comments as `createdBy`.
            PrincipalsUtil.getPrincipals(ctx, userIds, function(err, principals) {
                if (err) {
                    return callback(err);
                }

                _.each(comments, function(comment) {
                    var principal = principals[comment.createdBy];
                    if (principal) {
                        comment.createdBy = principal;
                    }
                });

                return callback(err, comments, nextToken);
            });
        });
    });
};

/**
 * Delete a comment from a content item. Managers of the content can delete all comments whilst people that have access
 * to the content can only delete their own comments. Therefore, anonymous users will never be able to delete comments.
 *
 * @param  {Context}    ctx                     Standard context object, representing the currently logged in user and its tenant
 * @param  {String}     contentId               The id of the content item from which to delete the comment
 * @param  {String}     commentCreatedDate      The timestamp of the comment that should be deleted
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Comment}    [callback.softDeleted]  When the comment has been soft deleted (because it has replies), a stripped down comment object representing the deleted comment will be returned, with the `deleted` parameter set to `false`. If the comment has been deleted from Cassandra, no comment object will be returned.
 */
var deleteComment = module.exports.deleteComment = function(ctx, contentId, commentCreatedDate, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authorized users can delete comments'}).isLoggedInUser(ctx);
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(commentCreatedDate, {'code': 400, 'msg': 'A valid integer comment created timestamp must be specified'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getContent(ctx, contentId, function(err, content) {
        if (err) {
            return callback(err);
        }

        MessageBoxAPI.getMessages(contentId, [commentCreatedDate], null, function(err, messages) {
            if (err) {
                return callback(err);
            } else if (_.isEmpty(messages) || !messages[0]) {
                return callback({'code': 404, 'msg': 'The specified comment does not exist'});
            }

            var message = messages[0];
            if (ctx.user().id === message.createdBy) {
                return _deleteComment(ctx, content, message, callback);
            }

            // We aren't the creator of the message, see if we can manage the content to do it
            _canManage(ctx, content, function(err, canManage) {
                if (err) {
                    return callback(err);
                } else if (!canManage) {
                    return callback({'code': 401, 'msg': 'You do not have access to delete this comment'});
                }

                return _deleteComment(ctx, content, message, callback);
            });
        });
    });
};

/**
 * Delete the comment (either hard or soft, depending on if there are any replies) with the given timestamp from the
 * message box with the given id.
 *
 * @param  {Context}        ctx                     Standard context object, representing the currently logged in user and its tenant
 * @param  {Content}        content                 The content object on which a comment should be deleted
 * @param  {Message}        commentToDelete         The comment to delete
 * @param  {Function}       callback                Invoked when the process completes
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Message}        [callback.comment]      If the comment was soft-deleted, this will be the model of the scrubbed deleted comment
 */
var _deleteComment = function(ctx, content, commentToDelete, callback) {
    var messageBoxId = content.id;
    // Delete the comment using the "leaf" method, which will SOFT delete if the message has replies, or HARD delete if it does not
    MessageBoxAPI.deleteMessage(messageBoxId, commentToDelete.created, {'deleteType': MessageBoxConstants.deleteTypes.LEAF}, function(err, deleteType, deletedComment) {
        if (err) {
            return callback(err);
        }

        // If the comment was hard deleted, it is not returned from the delete message endpoint. However if there is a soft delete and
        // it is returned, we want to return the new version of the comment
        deletedComment = deletedComment || commentToDelete;

        // Notify consumers that the comment was deleted
        ContentAPI.emit(ContentConstants.events.DELETED_COMMENT, ctx, deletedComment, content, deleteType);

        if (deleteType === MessageBoxConstants.deleteTypes.SOFT) {
            // If a soft-delete occurred, we want to inform the consumer of the soft-delete message model
            return callback(null, deletedComment);
        } else {
            return callback();
        }
    });
};


///////////////////////////
// Library functionality //
///////////////////////////

/**
 * Get the content library items for a user or group. If the user requests their own library or the library of a group they're a member of,
 * the full list will be returned. If the user is logged in but not a manager of the library, the :loggedin stream will be returned, containing
 * only content that's visible to logged in people or the public. In case of an anonymous user, the :public stream will be returned, containing
 * only content that is public
 *
 * @param  {Context}        ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}         principalId         The id of the principal whose content library to fetch
 * @param  {String}         start               The content paging token from which to start fetching content items. If not provided, the first x elements will be returned
 * @param  {Number}         limit               The maximum number of results to return. Default: 10
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Content[]}      callback.content    The content library items for the specified user or group
 * @param  {String}         callback.nextToken  The value to provide in the `start` parameter to get the next set of results
 */
var getContentLibraryItems = module.exports.getContentLibraryItems = function(ctx, principalId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'A user or group id must be provided'}).isPrincipalId();
    validator.check(limit, {'code': 400, 'msg': 'A valid limit should be passed in'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the principal
    PrincipalsDAO.getPrincipal(principalId, function(err, principal) {
        if (err) {
            return callback(err);
        }

        // Determine which library visibility we need to fetch
        LibraryAPI.Authz.resolveTargetLibraryAccess(ctx, principal.id, principal.visibility, function(err, hasAccess, visibility) {
            if (err) {
                return callback(err);
            } else if (!hasAccess) {
                return callback({'code': 401, 'msg': 'You do not have access to this library'});
            }

            ContentDAO.Content.getContentLibraryItems(principalId, visibility, start, limit, function(err, contentObjects, nextToken) {
                if (err) {
                    return callback(err);
                }

                _.each(contentObjects, function(contentObj) {
                    ContentUtil.augmentContent(ctx, contentObj);
                });

                return callback(null, contentObjects, nextToken);
            });
        });
    });
};

///////////////
// Revisions //
///////////////

/**
 * Get the revisions for a content item
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the content item to get the revisions for
 * @param  {Number}         [start]             The revision paging token from which to start fetching revisions
 * @param  {Number}         [limit]             The maximum number of results to return. Default: 10
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Revision[]}     callback.revisions  The revisions for the specified content item
 * @param  {String}         callback.nextToken  The value to provide in the `start` parameter to get the next set of results
 */
var getRevisions = module.exports.getRevisions = function(ctx, contentId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A contentId must be provided'}).isResourceId();
    validator.check(limit, {'code': 400, 'msg': 'A valid limit should be passed in'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the user has access on this contentId
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        // all columns except etherpadHtml
        var opts = {
            'fields': [
                'contentId',
                'created',
                'createdBy',
                'filename',
                'mediumUri',
                'mime',
                'previews',
                'previewsId',
                'revisionId',
                'size',
                'thumbnailUri',
                'uri',
                'wideUri'
            ]
        };
        _getRevisions(ctx, contentObj, start, limit, opts, callback);
    });
};

/**
 * Internal method that retrieves revisions and augments them with the principal profile who created it.
 * This method performs no access checks.
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {Content}        contentObj          The content object for which we need to retrieve the revisions.
 * @param  {Number}         [start]             The revision paging token from which to start fetching revisions
 * @param  {Number}         [limit]             The maximum number of results to return. Default: 10
 * @param  {Object}         [opts]              Additional options
 * @param  {String[]}       [opts.fields]       The columns to get from cassandra if not specified all will be fetched
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Revision[]}     callback.revisions  Array that contains an object for each revision.
 * @param  {String}         callback.nextToken  The value to provide in the `start` parameter to get the next set of results
 * @api private
 */
var _getRevisions = function(ctx, contentObj, start, limit, opts, callback) {
    // Page the query.
    ContentDAO.Revisions.getRevisions(contentObj.id, start, limit, opts, function(err, revisions, nextToken) {
        if (err) {
            return callback(err);
        }

        var userIds = _.map(revisions, function(revisions) { return revisions.createdBy; });
        PrincipalsUtil.getPrincipals(ctx, userIds, function(err, users) {
            if (err) {
                return callback(err);
            }

            // Add the user profiles to the revisions.
            _.each(revisions, function(revision) {
                if (users[revision.createdBy]) {
                    revision.createdBy = users[revision.createdBy];
                    _augmentRevision(ctx, revision, contentObj);
                }
            });

            return callback(null, revisions, nextToken);
        });
    });
};

/**
 * Get a revision
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the content item to get the revision for
 * @param  {String}         [revisionId]        The id of the revision to get. If unspecified, the latest revision will be retrieved
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Revision}       callback.revision   The revision
 */
var getRevision = module.exports.getRevision = function(ctx, contentId, revisionId, callback) {
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A valid contentId must be provided'}).isResourceId();
    if (revisionId) {
        validator.check(revisionId, {'code': 400, 'msg': 'A valid revisionId must be provided'}).isResourceId();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the user has access to this content item
    getContent(ctx, contentId, function(err, content) {
        if (err) {
            return callback(err);
        }

        // The user has access, get the revision and augment it with a downloadload link
        // if this piece of content is a file
        return _getRevision(ctx, content, revisionId, callback);
    });
};

/**
 * Get the download strategy information for downloading a revision
 *
 * @param  {Context}            ctx                             The context of the request
 * @param  {String}             contentId                       The id of the content item for which we want to get the revision download information
 * @param  {String}             [revisionId]                    The id of the revision whose download information to retrieve. If unspecified, the latest revision download information will be retrieved
 * @param  {Function}           callback                        Standard callback function
 * @param  {Object}             callback.err                    An error that occurred, if any
 * @param  {Object}             callback.downloadInfo           An object containing information necessary for downloading the revision
 * @param  {String}             callback.downloadInfo.filename  The filename to suggest to the client for the download
 * @param  {DownloadStrategy}   callback.downloadInfo.strategy  The DownloadStrategy that details how to download the revision
 */
var getRevisionDownloadInfo = module.exports.getRevisionDownloadInfo = function(ctx, contentId, revisionId, callback) {
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A valid contentId must be provided'}).isResourceId();
    if (revisionId) {
        validator.check(revisionId, {'code': 400, 'msg': 'A valid revisionId must be provided'}).isResourceId();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the user has access to this content item
    getContent(ctx, contentId, function(err, content) {
        if (err) {
            return callback(err);
        } else if (content.resourceSubType !== 'file') {
            return callback({'code': 400, 'msg': 'Only file content items can be downloaded'});
        }

        // Ensure we can resolve a revision id
        revisionId = revisionId || content.latestRevisionId;
        if (!revisionId) {
            return callback({'code': 400, 'msg': 'No revision id provided and content item does not have a latest revision id'});
        }

        // Get the revision that the user wishes to download
        ContentDAO.Revisions.getRevision(revisionId, function(err, revision) {
            if (err) {
                return callback(err);
            } else if (content.id !== revision.contentId) {
                // It's possible that the user specified a revision id that belonged to a different content item. Yikes!
                return callback({'code': 400, 'msg': 'The revision id provided is not associated with the specified content item'});
            }

            return callback(null, {
                'filename': revision.filename,
                'strategy': ContentUtil.getStorageBackend(ctx, revision.uri).getDownloadStrategy(ctx, revision.uri)
            });
        });
    });
};

/**
 * Internal method for retrieving a specific revision.
 * It's assumed that the parameters have been properly validated beforehand.
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {Content}        contentObj          The content object for which we need to retrieve a revision.
 * @param  {String}         [revisionId]        The id of the revision to get. If unspecified, the latest will be retrieved
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Revision}       callback.revision   The revision
 * @api private
 */
var _getRevision = function(ctx, contentObj, revisionId, callback) {
    if (!revisionId) {
        // Get the latest one.
        _getRevisions(ctx, contentObj, null, 1, null, function(err, revisions) {
            if (err) {
                return callback(err);
            } else if (_.isEmpty(revisions)) {
                return callback({'code': 404, 'msg': 'No revision found for ' + contentObj.id});
            }

            // There is no need to augment the revisions here as that has already happened
            return callback(null, revisions[0]);
        });
    } else {
        ContentDAO.Revisions.getRevision(revisionId, function(err, revisionObj) {
            if (err) {
                return callback(err);

            // Double check that this revision is really attached to the specified contentId.
            // This is to counter that someone tries to get the revision of a piece of content he has no access to.
            // Ex: Alice has access to c:cam:aliceDoc but not to c:cam:bobDoc which has revision rev:cam:foo
            // doing getRevision(ctx, 'c:cam:aliceDoc', 'rev:cam:foo', ..) should return this error.
            } else if (revisionObj.contentId !== contentObj.id) {
                return callback({'code': 400, 'msg': 'This revision ID is not associated with the specified piece of content.'});
            }

            _augmentRevision(ctx, revisionObj, contentObj);
            return callback(null, revisionObj);
        });
    }
};

/**
 * Convert the given revision to a model that can be returned to the consumer from the API
 *
 * @param  {Context}    ctx         Standard context object, representing the currently logged in user and its tenant
 * @param  {Revision}   revision    The revision to augment
 * @param  {Content}    contentObj  The content object that the revision is attached to
 * @api private
 */
var _augmentRevision = function(ctx, revision, contentObj) {
    // Replace the thumbnail URI with a signed download URL
    if (revision.thumbnailUri) {
        revision.thumbnailUrl = _getPictureDownloadUrlFromUri(ctx, revision.thumbnailUri, revision.id);
        delete revision.thumbnailUri;
    }

    // Replace the medium picture URI with a signed download URL
    if (revision.mediumUri) {
        revision.mediumUrl = _getPictureDownloadUrlFromUri(ctx, revision.mediumUri, revision.id);
        delete revision.mediumUri;
    }
};

/**
 * Takes a revision and makes it the "current" revision by creating a new one and copying the existing revision's fields.
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the content item to restore the revision for
 * @param  {String}         revisionId          The id of the revision to restore
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Revision}       callback.revision   The restored revision
 */
var restoreRevision = module.exports.restoreRevision = function(ctx, contentId, revisionId, callback) {
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A valid contentId must be provided'}).isResourceId();
    validator.check(revisionId, {'code': 400, 'msg': 'A valid revisionId must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Make sure the user is a manager of this piece of content and the revision exists.
    canManage(ctx, contentId, function(err, canManage, contentObj) {
        if (err) {
            return callback(err);
        } else if (!canManage) {
            return callback({'code': 401, 'msg': 'Manager rights are required to restore a revision.'});
        }

        ContentDAO.Revisions.getRevision(revisionId, function(err, revision) {
            if (err) {
                return callback(err);
            } else if (contentObj.id !== revision.contentId) {
                return callback({'code': 400, 'msg': 'The contentId specified is not the owner of the specified revisionId'});
            }

            // Create a new revision by copying from the specified revision
            var newRevisionId = _generateRevisionId(contentId);
            ContentDAO.Revisions.createRevision(newRevisionId, contentId, ctx.user().id, revision, function(err, newRevision) {
                if (err) {
                    return callback(err);
                }

                /*!
                 * We need to update the content item in the Content CF.
                 * We do so by copying all the non-standard fields from the revision
                 * to the Content CF.
                 */
                var blacklist = ['revisionId', 'contentId', 'createdBy', 'created', 'etherpadHtml', 'previewsId', 'downloadPath'];
                var updates = _.omit(revision, blacklist);

                // We also need to update the latest revisionID in the content CF.
                updates.latestRevisionId = newRevisionId;

                ContentDAO.Content.updateContent(contentObj, updates, true, function(err, newContentObj) {
                    if (err) {
                        return callback(err);
                    }

                    // Provide user-level data such as signed URLs for the consumer
                    _augmentRevision(ctx, newRevision, newContentObj);

                    // Emit an event
                    ContentAPI.emit(ContentConstants.events.RESTORED_REVISION, ctx, newContentObj, contentObj, revision);

                    // If this piece of content is a collaborative document,
                    // we need to set the text in etherpad.
                    if (contentObj.resourceSubType === 'collabdoc') {
                        Etherpad.setHTML(contentObj.id, contentObj.etherpadPadId, revision.etherpadHtml, function(err) {
                            if (err) {
                                return callback(err);
                            }
                            callback(null, newRevision);
                        });
                    } else {
                        callback(null, newRevision);
                    }
                });
            });
        });
    });
};

/**
 * Verifies if a uri and signature match up and returns an object that the REST handlers can use to redirect users
 * to the actual download page.
 *
 * @param  {Context}            ctx                             Current execution context
 * @param  {Object}             qs                              The query string object of the download request as generated by `ContenUtil.getSignedDownloadUrl`
 * @param  {Object}             callback.err                    An error that occurred, if any
 * @param  {Object}             callback.downloadInfo           An object containing information necessary for downloading the signed download
 * @param  {String}             callback.downloadInfo.filename  The filename to suggest to the client for the download
 * @param  {DownloadStrategy}   callback.downloadInfo.strategy  The DownloadStrategy that details how to download the file
 */
var verifySignedDownloadQueryString = module.exports.verifySignedDownloadQueryString = function(ctx, qs, callback) {
    var uri = ContentUtil.verifySignedDownloadQueryString(qs);
    if (!uri) {
        return callback({'code': 401, 'msg': 'Invalid signature data for the provided download url'});
    }

    var downloadStrategy = ContentUtil.getStorageBackend(ctx, uri).getDownloadStrategy(ctx, uri);
    return callback(null, {'strategy': downloadStrategy, 'filename': path.basename(uri)});
};

///////////////////////
// Utility functions //
///////////////////////

/**
 * Store the preview reference (if necessary), producing the backend URI that can be used to
 * download it afterward.
 *
 * @param  {Context}        ctx                 The context of the current request
 * @param  {String|Stream}  previewReference    Either a string indicating the external URL of the preview, or a stream indicating its location on disk for upload to back-end storage
 * @param  {Object}         [options]           The storage options indicating the `resourceId` of the content object and the storage prefix. Only applicable if the preview reference is a stream
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that incurred, if any
 * @param  {String}         callback.uri        The URI to use to reference this preview in the future
 * @api private
 */
var _storePreview = function(ctx, previewReference, options, callback) {
    if (_.isString(previewReference)) {
        // If the reference is a string, it is simply an external link to some file. We will use a remote uri
        // to reference it
        return callback(null, 'remote:' + previewReference);
    } else {
        // Otherwise, it is expected to be a stream reference to a file on disk, in which case we want to store it
        // using the tenant default storage mechanism
        ContentUtil.getStorageBackend(ctx).store(ctx, previewReference, options, callback);
    }
};

/**
 * Get the download url from a storage uri
 *
 * @param  {Context}    ctx         The context of the request accessing the download
 * @param  {String}     uri         The storage URI
 * @param  {String}     [parentId]  For logging purposes, the owner of this URI in case the URI is invalid
 * @return {String}                 A reference that can be used directly in a link to download the file
 * @api private
 */
var _getPictureDownloadUrlFromUri = function(ctx, uri, parentId) {
    try {
        return ContentUtil.getSignedDownloadUrl(ctx, uri);
    } catch (err) {
        // The backend was probably not found, we will fail safely here
        log(ctx).warn({'parentId': parentId}, 'Could not find storage backend for uri: %s', uri);
        return null;
    }
};

/**
 * Create a permission change object with the provided member ids whose roles are all set to the
 * provided `role`
 *
 * @param  {String[]}           memberIds   The ids of the members for whom to make the permission changes
 * @param  {String|Boolean}     role        The role to apply, or `false` if the intention is to remove the member from the content item
 * @return {Object}                         An object whose keys are the member ids and values are the specified role
 * @api private
 */
var _makeAllPermissionChanges = function(memberIds, role) {
    var roleChanges = {};
    _.each(memberIds, function(memberId) {
        roleChanges[memberId] = role;
    });
    return roleChanges;
};

/**
 * Generates a new content ID.
 *
 * @param  {String}     tenantAlias     The tenant alias for the content item
 * @return {String}                     The new content ID.
 * @api private
 */
var _generateContentId = function(tenantAlias) {
    return AuthzUtil.toId('c', tenantAlias, ShortId.generate());
};

/**
 * Generates a new revision ID for a content item by ID.
 *
 * @param  {String}     contentId   The ID of the content item for which to generate a new revision ID
 * @return {String}                 The new revision ID
 * @api private
 */
var _generateRevisionId = function(contentId) {
    var tenantAlias = AuthzUtil.getResourceFromId(contentId).tenantAlias;
    return AuthzUtil.toId('rev', tenantAlias, ShortId.generate());
};
