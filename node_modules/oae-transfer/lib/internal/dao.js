/*!
 * Copyright 2017 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var async = require('async');
var util = require('util');

var Cassandra = require('oae-util/lib/cassandra');
var FoldersDAO = require('oae-folders/lib/internal/dao');
var GroupAPI = require('oae-principals/lib/api.group');

var Transfer = require('oae-transfer/lib/model').Transfer;

// Number of seconds in a day
const SECONDS_IN_A_DAY = 24 * 60 * 60;

/** 
 * PUBLIC FUNCTIONS 
 */

/**
 * Create a new transfer and return it.
 *
 * @param  {Object}         ctx                     Context
 * @param  {String}         originalUserId          The account identifier from which the data will be transferred
 * @param  {String}         code                    The code used by the user to secure the transfer
 * @param  {String}         originalEmail           The email of the account from which the data will be transferred
 * @param  {String}         targetEmail             The email of the account to which the data will be transferred
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {transfer}       callback.transfer       The transfer that was created
 */
var initiateTransfer = module.exports.initiateTransfer = function (ctx, code, originalUserId, originalEmail, targetEmail, callback) { 
    
    // Initialize TTL of the transfer
    _getTTLTransfer(ctx, function (err, TTL) {
        if (err) {
            return callback(err);
        }
        var finalTTL = TTL * SECONDS_IN_A_DAY;
        var date = Date.now(); 

        // Create transfer
        Cassandra.runQuery('INSERT INTO "Transfer" ("originalUserId", "code", "originalEmail", "targetEmail", "targetUserId", "state", "dateLastAction") VALUES (?, ?, ?, ?, ?, ?, ?) USING TTL ?', [originalUserId, code, originalEmail, targetEmail, '', 'onging', date.toString(), finalTTL], function(err) {
            if (err) {
                return callback(err);
            }
            Cassandra.runQuery('INSERT INTO "TransferByEmail" ("originalUserId", "code", "originalEmail", "targetEmail", "targetUserId", "state", "dateLastAction") VALUES (?, ?, ?, ?, ?, ?, ?) USING TTL ?', [originalUserId, code, originalEmail, targetEmail, '', 'onging', date.toString(), finalTTL], function(err) {
                if (err) {
                    return callback(err);
                }
                var transfer = new Transfer(originalUserId, code, originalEmail, targetEmail, null, 'ongoing', date);

                return callback(null, transfer);
            });
        });
    });
};

/**
 * Get transfer by a user id.
 *
 * @param  {String}         originalUserId          The account identifier from which the data will be transferred
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {transfer}       callback.transfer       User's transfer
 */
var getTransferById = module.exports.getTransferById = function (originalUserId, callback) {
    Cassandra.runQuery('SELECT * FROM "Transfer" WHERE "originalUserId" = ?', [originalUserId], function(err, transfer) {
        if (err) {
            return callback(err);
        }
        return callback(null, transfer[0]);
    });
};

/**
 * Get transfer by an email and a code.
 *
 * @param  {String}         originalEmail           The email of the account from which the data will be transferred
 * @param  {String}         code                    The code used by the user to secure the transfer
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {transfer}       callback.transfer       User's transfer
 */
var getTransferByEmail = module.exports.getTransferByEmail = function (originalEmail, code, callback) {
    Cassandra.runQuery('SELECT * FROM "TransferByEmail" WHERE "originalEmail" = ? AND "code" = ?', [originalEmail, code], function(err, transfer) {
        if (err) {
            return callback(err);
        }
        return callback(null, transfer[0]);
    });
};

/**
 * Cancel a transfer.
 *
 * @param  {String}         originalEmail           The email of the account from which the data will be transferred
 * @param  {String}         code                    The code used by the user to secure the transfer
 * @param  {String}         originalUserId          The account identifier from which the data will be transferred
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 */
var cancelTransfer = module.exports.cancelTransfer = function (originalEmail, code, originalUserId, callback) {
    var date = Date.now();
    Cassandra.runQuery('UPDATE "Transfer" SET "state" = ?, "date" = ? WHERE "originalUserId" = ? AND "code" = ?', ['canceled', date.toString(), originalUserId, code], function(err) {
        if (err) {
            return callback(err);
        }
        Cassandra.runQuery('UPDATE "TransferByEmail" SET "state" = ?, "date" = ? WHERE "originalEmail" = ? AND "code" = ?', ['canceled', date.toString(), originalEmail, code], function(err) {
            if (err) {
                return callback(err);
            }
            return callback();
        });
    });
};

/**
 * Complete a transfer.
 *
 * @param  {String}         code                    The code used by the user to secure the transfer
 * @param  {String}         originalUserId          The account identifier from which the data will be transferred
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 */
var completeTransfer = module.exports.completeTransfer = function (code, originalUserId, originalEmail, targetEmail, targetUserId, callback) {
    var date = Date.now();
    Cassandra.runQuery('UPDATE "Transfer" SET "state" = ?, "dateLastAction" = ? WHERE "originalUserId" = ? AND "code" = ?', ['completed', date.toString(), originalUserId, code], function(err) {
        if (err) {
            return callback(err);
        }
        Cassandra.runQuery('UPDATE "TransferByEmail" SET "state" = ?, "dateLastAction" = ? WHERE "originalEmail" = ? AND "code" = ?', ['completed', date.toString(), originalUserId, code], function(err) {
            if (err) {
                return callback(err);
            }
            var transfer = new Transfer(originalUserId, code, originalEmail, targetEmail, targetUserId, 'completed', date);
            return callback(null, transfer);
        });
    });
};

/**
 * Get all permissions of a user.
 *
 * @param  {String}         userId                      A user id
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error that occurred, if any
 * @param  {members}        callback.authzRoles         All the permission a user get
 */
 var getAuthzRoles = module.exports.getAuthzRoles = function (userId, callback) { 
    Cassandra.runQuery('SELECT * FROM "AuthzRoles" WHERE "principalId" = ?', [userId], function(err, authzRoles) {
        if (err) {
            return callback(err);
        }
        return callback(null, authzRoles);
    });
};

/**
 * Get user from cassandra.
 * 
 * @param {Object}  ctx                 Context
 * @param {Array}   userId              The user id
 *
 * @returns user
 * @api private
 */
var getPrincipalFromCassandra = module.exports.getPrincipalFromCassandra = function (userId, callback) {
    Cassandra.runQuery('SELECT * FROM "Principals" WHERE "principalId" = ?', [userId], function (err, member) {
        if (err) {
            return callback(err);
        } 
        return callback(null, member);
    });      
};

/**
 * Get folder by group id.
 * 
 * @param {Object} ctx              Context
 * @param {String} resourceId       The id of the resource to transfer
 *
 * @returns folder
 * @api private
 */
 var getFoldersByGroupIds = module.exports.getFoldersByGroupIds = function (ctx, resourceId, callback) {

    Cassandra.runQuery('SELECT * FROM "FoldersGroupId" WHERE "groupId" = ?', [resourceId], function(err, result) {

        // The resource is a group if there is no result to this query
        if (_.isEmpty(result)) {
            GroupAPI.getGroup(ctx, resourceId, function(err, group) {
                if (err) {
                    return callback(err);
                }
                return callback(null, group);
            });
        } else {
            FoldersDAO.getFolder(result[0].folderId, function(err, folder) {
                if (err) {
                    return callback(err);
                }
                return callback(null, folder);
            });
        }
    });
};

/**
 * PRIVATE FUNCTIONS
 */

/**
 * Get the time to live transfer of a specific tenant.
 *
 * @param  {Object}         ctx                     Context to determine the time to live of a transfer code
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Error
 */
var _getTTLTransfer = function (ctx, callback) {

    var defaultTime = 1;
    var configkey = 'oae-transfer/TTL/value';

    Cassandra.runQuery('SELECT "value" FROM "Config" WHERE "tenantAlias" = ? AND "configKey" = ?', [ctx.tenant().alias, configkey], function(err, result) {
        if (err) {
            return callback(err);
        }

        if (_.isEmpty(result)) {
            return callback(null, defaultTime);
            
        } else {
            return callback(null, result[0].value);
        }
    });
};
