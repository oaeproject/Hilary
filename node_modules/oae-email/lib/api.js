/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var crypto = require('crypto');
var events = require('events');
var fs = require('fs');
var nodemailer = require('nodemailer');
var path = require('path');
var redback = require('redback');
var util = require('util');

var IO = require('oae-util/lib/io');
var Locking = require('oae-util/lib/locking');
var log = require('oae-logger').logger('oae-email');
var OaeModules = require('oae-util/lib/modules');
var Redis = require('oae-util/lib/redis');
var Sanitization = require('oae-util/lib/sanitization');
var Telemetry = require('oae-telemetry').telemetry('oae-email');
var TenantsAPI = require('oae-tenants');
var Validator = require('oae-util/lib/validator').Validator;

var EmailConfig = require('oae-config').config('oae-email');
var EmailRateLimiter = null;

// These hashes cache both the base templates (in the source tree) and the tenant override templates
// (provided in a directory by a system configuration property).
var baseCompiledTemplates = {};
var overrideCompiledTemplates = {};

// The configuration value that specifies where the override templates lay
var customEmailTemplatesDir = null;

/*!
 * Whether or not the server is in debug mode. If true, no emails will ever be sent, instead the email
 * data will be logged. This is equivalent to "disabling" emails.
 */
var debug = true;

// The cached connection pool with the configured mail values. This can be smtp, sendmail, ..
var emailTransport = null;

// The interval in which the same email can't be sent out multiple times
var deduplicationInterval = null;

// The configuration for e-mail throttling
var throttleConfig = {
    'timespan': null,
    'count': null
};


/**
 * ## EmailAPI
 *
 * ### Events
 *
 * * `debugSent(message)` - If `debug` is enabled, this event is fired and indicates an email was sent from the system. The `message` object, which is a MailComposer-compatable object is provided
 *
 * ### Templates
 *
 * All emails that are sent are based on an internationalizable template. To load a new template for the system, you must
 * create a directory in your OAE module called `emailTemplates`. The directory structure looks like this (using oae-content
 * as an example):
 *
 *  * oae-content/                              (module directory)
 *      ** emailTemplates/                      (directory that is scanned by oae-email)
 *          *** default/                        (the default templates, chosen if there is no locale)
 *              **** templateId.meta.json.jst   (the "meta" template for template with id "templateId")
 *              **** templateId.html.jst        (the "html" template for template with id "templateId")
 *              **** templateId.txt.jst         (the "text" template for template with id "templateId")
 *          *** en_CA/                          (the en_CA locale templates, used if the receiving user has locale en_CA)
 *              **** templateId.meta.json.jst
 *              **** templateId.html.jst
 *              **** templateId.txt.jst
 *
 * **The 'default' locale:** The default locale is chosen if the user's locale does not have a template provided for it.
 * **The 'meta.json' template:** This template should produce a JSON object that specifies email metadata. This template **must** exist, and should at least provide the "subject" of the email.
 * **The 'html' template:** This template provides an HTML-formatted version of the email content. One of HTML and TXT templates must be provided.
 * **The 'txt' template:** This template provides a plain-text version of the email content. If this is not provided, the HTML version will be converted to plain-text in replacement. One of HTML and TXT must be provided.
 *
 * Template overrides can be specified on a per-tenant basis. The overrides directory can be specified with the config property
 * `customEmailTemplatesDir`. If a template is overridden (e.g., exists in the override directory), it will be selected over
 * the base templates. The template directory structure is the same as the base templates, except each module directory should
 * exist in a folder named after the tenant alias that is overridden.
 *
 * ### JST Files
 *
 * All templates: meta.json.jst, html.jst and txt.jst are JavaScriptTemplates, and are compiled and rendered using UnderscoreJS:
 * http://underscorejs.org/#template
 */
var EmailAPI = module.exports = new events.EventEmitter();

/**
 * Initialize the email module.
 *
 * @param  {Object}     emailSystemConfig   The `email` config object from the system `config.js`. Refer to that file for the configuration options
 * @param  {Function}   callback            Invoked when emails have been initialized
 * @param  {Object}     callback.err        An error that occurred, if any
 */
var init = module.exports.init = function(emailSystemConfig, callback) {
    // Email configuration
    customEmailTemplatesDir = emailSystemConfig.customEmailTemplatesDir;
    debug = (emailSystemConfig.debug !== false);
    deduplicationInterval = emailSystemConfig.deduplicationInterval || (7 * 24 * 60 * 60);
    emailSystemConfig.throttling = emailSystemConfig.throttling || {};
    throttleConfig.count = emailSystemConfig.throttling.count || 10;
    throttleConfig.timespan = emailSystemConfig.throttling.timespan || 2 * 60;

    // Create the Redback rate limiter for emails
    var EmailRedback = redback.use(Redis.getClient(), {'namespace': 'oae-email:redback'});

    /*!
     * For robust unit tests, any provided timespan needs to cover at least 2 buckets so that when
     * we do a count on the rate, we don't risk rolling over to a new interval and miss the emails
     * we just sent, resetting the frequency to 0 and intermittently failing the test. Therefore
     * we set the bucket interval to be (timespan / 2).
     *
     * Additionally, when a bucket is incremented in redback, the following 2 buckets are cleared.
     * Therefore in order to ensure we don't roll over to a new bucket while incrementing and risking
     * our previous bucket getting cleared, we must ensure we have at least 5 buckets so that the
     * clearing of the "next 2" buckets does not impact the counting of the "previous 2". (e.g., if
     * the current time bucket is 2, redback will clear buckets 3 and 4 while we count back from 0,
     * 1 and 2).
     */
    var bucketInterval = Math.ceil(throttleConfig.timespan / 2);
    EmailRateLimiter = EmailRedback.createRateLimit('email', {
        // The rate limiter seems to need at least 5 buckets to work, so lets give it exactly 5 (there are exactly bucket_span / bucket_interval buckets)
        'bucket_span': bucketInterval * 5,
        'bucket_interval': bucketInterval,
        'subject_expiry': throttleConfig.timespan
    });

    // If there was an existing email transport, we close it.
    if (emailTransport) {
        emailTransport.close();
        emailTransport = null;
    }

    // Open an email transport if we're not in debug mode
    if (!debug) {
        if (emailSystemConfig.transport === 'SMTP') {
            log().info({'data': emailSystemConfig.smtpTransport}, 'Configuring SMTP email transport.');
            emailTransport = nodemailer.createTransport('SMTP', emailSystemConfig.smtpTransport);
        } else if (emailSystemConfig.transport === 'sendmail') {
            log().info({'data': emailSystemConfig.sendmailTransport}, 'Configuring Sendmail email transport.');
            emailTransport = nodemailer.createTransport('Sendmail', emailSystemConfig.sendmailTransport.path);
        } else {
            log().error({
                'err': new Error('Attempted to initialize Email API with invalid mail transport'),
                'transport': emailTransport
            }, 'Attempted to initialize Email API with invalid mail transport');
            return callback({'code': 400, 'msg': 'Misconfigured mail transport'});
        }
    }

    return refreshTemplates(callback);
};

/**
 * Refresh the email templates used for sending emails. This refreshes both the base templates located in the source
 * packages as well as the overrides provided in the directory configured by the system `config.js` file.
 *
 * @param  {Function}   callback        Invoked when the templates have been refreshed.
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var refreshTemplates = module.exports.refreshTemplates = function(callback) {
    // First refresh the base templates an then the override templates
    _refreshBaseTemplates(function(err) {
        if (err) {
            return callback(err);
        }

        return _refreshOverrideTemplates(customEmailTemplatesDir, callback);
    });
};

/**
 * Send a templated email to a user. This is only done when the exact same email hasn't been sent out before.
 * This prevents the server from sending out duplicate emails due to potential application hick-ups
 *
 * There are two ways of identifying an e-mail:
 *   1.  By passing in a `hash in the additional options.
 *   2.  When the `hash` field is left undefined, a hash will be generated by concatenating the following fields:
 *           *  to
 *           *  subject
 *           *  txt body
 *           *  html body
 *
 * If an e-mail has been sent out in the past `deduplicationInterval` seconds, an error object will be returned
 *
 * Additionally, throttling will be used to reduce the amount of emails a user can receive in a configurable timespan.
 * Once a user's email address has been throttled, it will take a full interval during which no mails should be sent
 * to their address before it gets unthrottled.
 *
 * @param  {String}     templateModule      The module that provides the template (e.g., 'oae-email')
 * @param  {String}     templateId          The id of the template
 * @param  {User}       toUser              The user that will be receiving the email. This is accessible in the email templates (e.g., `<%= user.displayName %>`)
 * @param  {String}     toUser.email        The email address of the user. If this is not available an error with code 400 is returned and no email is sent
 * @param  {Object}     [data]              An object that represents the data of the email. This will be accessible in the email templates (e.g., `<%= data.activity['displayName'] %>`)
 * @param  {Object}     [opts]              Additional options
 * @param  {String}     [opts.hash]         A unique fingerprint for this email. If an email with this hash has already been sent out in the last `deduplicationInterval` seconds, it will not be sent out. If left null, a hash of the mail will be used to attempt de-duplication
 * @param  {Function}   [callback]          Invoked when the email has been sent
 * @param  {Object}     [callback.err]      An error that occurred, if any
 */
var sendEmail = module.exports.sendEmail = function(templateModule, templateId, toUser, data, opts, callback) {
    data = data || {};
    opts = opts || {};
    callback = callback || function(err) {
        if (err && err.code === 400) {
            log().error({'err': err}, 'Failed to deliver due to validation error');
        }
    };

    var validator = new Validator();
    validator.check(templateModule, {'code': 400, 'msg': 'Must specify a template module'}).notEmpty();
    validator.check(templateId, {'code': 400, 'msg': 'Must specify a template id'}).notEmpty();
    validator.check(null, {'code': 400, 'msg': 'Must specify a user when sending an email'}).isObject(toUser);

    // Only validate the user email if it was a valid object
    if (toUser) {
        validator.check(toUser.email, {'code': 400, 'msg': 'User must have a valid email address to receive email'}).isEmail();
    }

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    log().trace({
        'templateModule': templateModule,
        'templateId': templateId,
        'toUser': toUser,
        'data': data,
        'opts': opts
    }, 'Preparing template for mail to be sent.');

    var renderedTemplates = {};

    var templateCtx = {'user': toUser, 'data': data, 'util': _createEmailTemplateUtil()};
    var metaTemplate = _resolveTemplate(toUser.tenant.alias, templateModule, toUser.locale, templateId, 'meta.json');
    var htmlTemplate = _resolveTemplate(toUser.tenant.alias, templateModule, toUser.locale, templateId, 'html');
    var txtTemplate = _resolveTemplate(toUser.tenant.alias, templateModule, toUser.locale, templateId, 'txt');

    // Verify the user templates have enough data to send an email
    if (!metaTemplate) {
        var noMetaTemplateErr = {'code': 500, 'msg': 'No email metadata template existed for user'};
        log().error({
            'err': new Error(noMetaTemplateErr.msg),
            'templateModule': templateModule,
            'templateId': templateId,
            'toUser': {
                'id': toUser.id,
                'locale': toUser.locale
            }
        }, noMetaTemplateErr.msg);
        return callback(noMetaTemplateErr);
    } else if (!htmlTemplate && !txtTemplate) {
        var noContentTemplateErr = {'code': 500, 'msg': 'No email content (text or html) template existed for user'};
        log().error({
            'err': new Error(noContentTemplateErr.msg),
            'templateModule': templateModule,
            'templateId': templateId,
            'toUser': {
                'id': toUser.id,
                'locale': toUser.locale
            }
        }, noContentTemplateErr.msg);
        return callback(noContentTemplateErr);
    }

    renderedTemplates = {};
    var metaContent = null;
    var htmlContent = null;
    var txtContent = null;

    try {
        // Try and parse the meta template into JSON
        metaContent = JSON.parse(metaTemplate(templateCtx));
    } catch (metaErr) {
        log().error({
            'err': metaErr,
            'templateModule': templateModule,
            'templateId': templateId,
            'toUser': {
                'id': toUser.id,
                'locale': toUser.locale
            }
        }, 'Error parsing email metadata template for user');
        return callback({'code': 500, 'msg': 'Error parsing email metadata template for user'});
    }

    // Try and render the html template
    if (htmlTemplate) {
        try {
            htmlContent = htmlTemplate(templateCtx);
        } catch (htmlErr) {
            log().warn({
                'err': htmlErr,
                'templateModule': templateModule,
                'templateId': templateId,
                'toUser': {
                    'id': toUser.id,
                    'locale': toUser.locale
                }
            }, 'Failed to parse email html template for user');
        }
    }

    // Try and render the text template
    if (txtTemplate) {
        try {
            txtContent = txtTemplate(templateCtx);
        } catch (txtErr) {
            log().warn({
                'err': txtErr,
                'templateModule': templateModule,
                'templateId': templateId,
                'toUser': {
                    'id': toUser.id,
                    'locale': toUser.locale
                }
            }, 'Failed to parse email html template for user');
        }
    }

    if (htmlContent || txtContent) {
        // If one of HTML or TXT templates managed to render, we will send the email with the content we have
        renderedTemplates['meta.json'] = metaContent;
        renderedTemplates['html'] = htmlContent;
        renderedTemplates['txt'] = txtContent;
    } else {
        return callback({'code': 500, 'msg': 'Could not parse a suitable content template for user'});
    }

    // If the `from` header is not set, we generate an intelligent `from` header based on the tenant domain
    var host = TenantsAPI.getTenant(toUser.tenant.alias).host;
    var domain = EmailConfig.getValue(toUser.tenant.alias, 'general', 'from') || 'noreply@' + host;
    from = util.format('"Apereo OAE" <%s>', domain);

    // Build the email object that will be sent through nodemailer. The 'from' property can be overridden by
    // the meta.json, then we further override that with some hard values
    var emailInfo = _.extend({'from': from, 'messageId': Date.now() + '@' + host}, renderedTemplates['meta.json'], {
        'to': toUser.email,
        'generateTextFromHTML': true
    });

    if (renderedTemplates['txt']) {
        emailInfo.text = renderedTemplates['txt'];
    }

    if (renderedTemplates['html']) {
        emailInfo.html = renderedTemplates['html'];
    }

    _sendEmail(emailInfo, opts, callback);
};

/**
 * Sends an email if it hasn't been sent before
 *
 * @param  {Object}     emailInfo       An object containing all the information to send an e-mail
 * @param  {Object}     opts            Additional options
 * @param  {String}     [opts.hash]     If specified, it will be used to identify this email
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    Standard error object, if any. If the email was sent previously, we'll return a 403 error code
 * @api private
 */
var _sendEmail = function(emailInfo, opts, callback) {
    var md5sum = crypto.createHash('md5');

    if (opts.hash) {
        md5sum.update(opts.hash.toString());

    // If no unique hash was specified by the user, we will generate one based on the mail data that is available
    } else {
        md5sum.update(emailInfo['to'] || '');
        md5sum.update(emailInfo['subject'] || '');
        md5sum.update(emailInfo['txt'] || '');
        md5sum.update(emailInfo['html'] || '');
    }
    var hash = md5sum.digest('hex');

    // We lock the mail for a sufficiently long time
    var lockKey = util.format('oae-email-locking:%s', hash);
    Locking.acquire(lockKey, deduplicationInterval, function(err, token) {
        if (err) {
            log().error({'err': err, 'hash': hash, 'emailInfo': emailInfo}, 'Unable to lock email hash');
            return callback(err);
        } else if (!token) {
            Telemetry.incr('lock.fail');
            log().error({'hash': hash, 'emailInfo': emailInfo}, 'A lock was already in place. A duplicate email is being sent out');
            return callback({'code': 403, 'msg': 'This email has already been sent out'});
        }

        // Ensure we're not sending out too many emails to a single user within the last timespan
        EmailRateLimiter.count(emailInfo.to, throttleConfig.timespan, function(err, count) {
            if (err) {
                log().error({'err': err}, 'Failed to perform email throttle check');
                return callback({'code': 500, 'msg': 'Failed to perform email throttle check'});
            } else if (count > (throttleConfig.count - 1)) {
                Telemetry.incr('throttled');
                log().warn({'to': emailInfo.to}, 'Throttling in effect');
                return callback({'code': 403, 'msg': 'Throttling in effect'});
            }

            // We will proceed to send an email, so add it to the rate-limit counts
            EmailRateLimiter.add(emailInfo.to, function(err) {
                if (err) {
                    log().warn({'err': err, 'to': emailInfo.to}, 'An unexpected error occurred trying to increment email rate-limit counts');
                }

                // We got a lock and aren't throttled, send our mail
                if (debug) {
                    // When in debug mode, manually create the raw email object (email headers and all) and
                    // output the email that *would* have been sent
                    var mailObj = new nodemailer.Nodemailer(emailInfo);
                    mailObj.generateMailObject();

                    log().info({
                        'emailInfo': emailInfo,
                        'mailObj': mailObj.mailcomposer
                    }, 'Sending email to %s', emailInfo.to);

                    EmailAPI.emit('debugSent', mailObj.mailcomposer);

                    return callback();
                } else {
                    // We are not debugging, so send the email
                    emailTransport.sendMail(emailInfo, function(err, response) {
                        if (err) {
                            log().error({'err': err}, 'Error sending email to recipient.');
                            return callback(err);
                        }

                        return callback();
                    });
                }
            });
        });
    });
};

/**
 * Refresh the base email templates, which are the ones located within the module source packages. If the
 * process is unsuccessful (an `err` is returned), there will be no change to the base email templates.
 *
 * @param  {Function}   callback        Invoked when the process completes
 * @param  {Object}     callback.err    An error that occurred, if any
 * @api private
 */
var _refreshBaseTemplates = function(callback) {
    var modules = OaeModules.getAvailableModules();

    // Refresh the base templates (from the oae source code repository)
    _compileTemplatesForModules(__dirname + '/../..', modules, function(err, newCompiledTemplates) {
        if (err) {
            return callback(err);
        }

        baseCompiledTemplates = newCompiledTemplates;
        return callback();
    });
};

/**
 * Refresh the tenant override email templates. If this fails, there is no change to the existing cached templates,
 * if any.
 *
 * @param  {String}     basedir         The base directory where the tenant override email templates are located
 * @param  {Function}   callback        Invoked when the templates have been refreshed
 * @param  {Object}     callback.err    An error that occurred, if any
 * @api private
 */
var _refreshOverrideTemplates = function(basedir, callback) {
    if (!basedir) {
        return callback();
    }

    var modules = OaeModules.getAvailableModules();

    // Overrides for a tenant are stored in a folder named after the tenant alias
    IO.getFileListForFolder(basedir, function(err, tenantAliases) {
        if (err) {
            return callback(err);
        }

        _compileTemplatesForTenants(basedir, tenantAliases, modules, function(err, newCompiledTemplates) {
            if (err) {
                return callback(err);
            }

            overrideCompiledTemplates = newCompiledTemplates;
            return callback();
        });
    });
};

/**
 * Compile the templates for a list of tenants.
 *
 * @param  {String}     basedir                     The base directory where the tenant folders are located
 * @param  {String[]}   tenantAliases               The list of tenant aliases for which to compile templates
 * @param  {String[]}   modules                     The list of modules for which to compile templates for each tenant
 * @param  {Function}   callback                    Invoked when the process completes
 * @param  {Object}     callback.err                An error that occurred, if any
 * @param  {Object}     callback.compiledTemplates  An object keyed by tenant whose value are the templates for each module
 * @param  {Object}     [_compiledTemplates]        Internal parameter to track the templates that have been compiled. Used for recursion
 * @api private
 */
var _compileTemplatesForTenants = function(basedir, tenantAliases, modules, callback, _compiledTemplates) {
    _compiledTemplates = _compiledTemplates || {};
    if (_.isEmpty(tenantAliases)) {
        return callback(null, _compiledTemplates);
    }

    var tenantAlias = tenantAliases.shift();
    var tenantDir = util.format('%s/%s', basedir, tenantAlias);
    _compileTemplatesForModules(tenantDir, modules.slice(), function(err, newCompiledTemplates) {
        // Save the templates compiled from this tenant directory for the tenant
        _compiledTemplates[tenantAlias] = newCompiledTemplates;
        _compileTemplatesForTenants(basedir, tenantAliases, modules, callback, _compiledTemplates);
    });
};

/**
 * Compile the templates for a list of modules.
 *
 * @param  {String}     basedir                     The base directory where the module folders are located
 * @param  {String[]}   modules                     The list of modules for which to compile templates
 * @param  {Function}   callback                    Invoked when the process completes
 * @param  {Object}     callback.err                An error that occurred, if any
 * @param  {Object}     callback.compiledTemplates  An object keyed by module whose value are the compiled templates for each locale
 * @param  {Object}     [_compiledTemplates]        Internal parameter to track the templates that have been compiled. Used for recursion
 * @api private
 */
var _compileTemplatesForModules = function(basedir, modules, callback, _compiledTemplates) {
    _compiledTemplates = _compiledTemplates || {};
    if (_.isEmpty(modules)) {
        return callback(null, _compiledTemplates);
    }

    // Each directory underneath a module is a locale. Fetch them and parse each locale's templates
    var module = modules.shift();
    var emailTemplatesPath = _templatesPath(basedir, module);
    IO.getFileListForFolder(emailTemplatesPath, function(err, locales) {
        if (err) {
            return callback(err);
        } else if (_.isEmpty(locales)) {
            return _compileTemplatesForModules(basedir, modules, callback, _compiledTemplates);
        }

        _compiledTemplates[module] = _compiledTemplates[module] || {};
        _compileTemplatesForLocales(basedir, module, locales, _compiledTemplates, function(err) {
            if (err) {
                return callback(err);
            }

            return _compileTemplatesForModules(basedir, modules, callback, _compiledTemplates);
        });
    });
};

/**
 * Compile the templates for a list of locales
 *
 * @param  {String}     basedir                     The base directory where the module folders are located
 * @param  {String}     module                      The module for which to compile the locale-specific templates
 * @param  {String[]}   locales                     The list of locales for which to compile the templates
 * @param  {Object}     compiledTemplates           The template object to which the compiled templates will be attached
 * @param  {Function}   callback                    Invoked when the process completes
 * @param  {Object}     callback.err                An error that occurred, if any
 * @api private
 */
var _compileTemplatesForLocales = function(basedir, module, locales, compiledTemplates, callback) {
    if (_.isEmpty(locales)) {
        return callback();
    }

    var locale = locales.shift();
    var localePath = _templatesPath(basedir, module, locale);

    compiledTemplates[module][locale] = compiledTemplates[module][locale] || {};

    // Find all the templates in the locale directory.
    IO.getFileListForFolder(localePath, function(err, templates) {
        if (err) {
            return callback(err);
        }

        // Identify a valid template by the existence of a *.meta.json.jst file
        var templateIds = {};
        _.each(templates, function(template) {
            var re = /^(.*)\.meta\.json\.jst$/;
            if (re.test(template)) {
                templateIds[template.replace(re, '$1')] = true;
            }
        });
        templateIds = _.keys(templateIds);

        if (_.isEmpty(templateIds)) {
            return _compileTemplatesForLocales(basedir, module, locales, compiledTemplates, callback);
        }

        _compileTemplatesForTemplateIds(basedir, module, locale, templateIds, compiledTemplates, function(err) {
            if (err) {
                return callback(err);
            }

            return _compileTemplatesForLocales(basedir, module, locales, compiledTemplates, callback);
        });
    });
};

/**
 * Compile the templates for a list of template ids. The templates that need to be compiled are the meta.json, txt
 * and html templates for each email template id.
 *
 * @param  {String}     basedir                     The base directory where the locale folders are located
 * @param  {String}     module                      The module for which to compile the locale-specific templates
 * @param  {String}     locale                      The locale for which to compile the templates
 * @param  {String[]}   templateIds                 The ids of the templates to compile
 * @param  {Object}     compiledTemplates           The template object to which the compiled templates will be attached
 * @param  {Function}   callback                    Invoked when the process completes
 * @param  {Object}     callback.err                An error that occurred, if any
 * @api private
 */
var _compileTemplatesForTemplateIds = function(basedir, module, locale, templateIds, compiledTemplates, callback) {
    if (_.isEmpty(templateIds)) {
        return callback();
    }

    var templateId = templateIds.shift();
    var templateMetaPath = _templatesPath(basedir, module, locale, templateId + '.meta.json.jst');
    var templateHtmlPath = _templatesPath(basedir, module, locale, templateId + '.html.jst');
    var templateTxtPath = _templatesPath(basedir, module, locale, templateId + '.txt.jst');

    // Compile each template individually
    _compileTemplate(templateMetaPath, function(err, compiledMetaTemplate) {
        if (err) {
            return callback(err);
        }

        _compileTemplate(templateHtmlPath, function(err, compiledHtmlTemplate) {
            if (err) {
                return callback(err);
            }

            _compileTemplate(templateTxtPath, function(err, compiledTxtTemplate) {
                if (err) {
                    return callback(err);
                }

                // Attach the templates to the given object of compiled templates
                compiledTemplates[module][locale][templateId] = {
                    'meta.json': compiledMetaTemplate,
                    'html': compiledHtmlTemplate,
                    'txt': compiledTxtTemplate
                };

                return _compileTemplatesForTemplateIds(basedir, module, locale, templateIds, compiledTemplates, callback);
            });
        });
    });
};

/**
 * Compile the template at the given path.
 *
 * @param  {String}     templatePath                The path to the template file to be compiled
 * @param  {Function}   callback                    Invoked when the template has been compiled
 * @param  {Object}     callback.err                An error that occurred, if any
 * @param  {Function}   callback.compiledTemplate   A function generated by underscorejs ("compiled template") that can be used to render the template
 * @api private
 */
var _compileTemplate = function(templatePath, callback) {
    fs.exists(templatePath, function(exists) {
        if (!exists) {
            return callback();
        }

        fs.readFile(templatePath, 'utf8', function(err, templateContent) {
            if (err) {
                return callback(err);
            }

            if (templateContent) {
                var compiledTemplate = null;
                try {
                    compiledTemplate = _.template(templateContent);
                } catch (ex) {
                    return callback({'code': 500, 'msg': ex.message});
                }

                return callback(null, compiledTemplate);
            } else {
                return callback({'code': 500, 'msg': 'Template file ' + templatePath + ' had no content.'});
            }
        });
    });
};

/**
 * Get the path for a template file or directory.
 *
 * @param  {String}     basedir     The base directory for the templates
 * @param  {String}     module      The module for the templates
 * @param  {String}     [locale]    The locale for the templates
 * @param  {String}     [template]  The full filename for the template (e.g., meta.json.jst)
 * @return {String}                 Returns the path where the locales, template files or specific template file should be found
 * @api private
 */
var _templatesPath = function(basedir, module, locale, template) {
    var templatePath = util.format('%s/%s/emailTemplates', basedir, module);

    if (locale) {
        templatePath += '/' + locale;
        if (template) {
            templatePath += '/' + template;
        }
    }

    return templatePath;
};

/**
 * Fetch the appropriate template file (either override or base) for the given tenant, module, user locale, template id and
 * template type. This method uses the template override rules to determine which, if any, override to use, then falls back
 * to the base template if necessary. If there is no appropriate override or base template, then this will return null.
 *
 * @param  {String}     tenantAlias     The alias of the tenant
 * @param  {String}     templateModule  The module to which the template belongs
 * @param  {String}     templateLocale  The locale for which to fetch the template
 * @param  {String}     templateId      The id of the template
 * @param  {String}     templateType    The type of template to fetch (i.e., one of 'html', 'txt' or 'meta.json')
 * @return {Function}                   The compiled underscorejs template function that can be used to render the template. If `null`, there was no suitable template for the given criteria.
 * @api private
 */
var _resolveTemplate = function(tenantAlias, templateModule, templateLocale, templateId, templateType) {
    // Try the override first, falling back to the base template if necessary
    return _getTemplate(overrideCompiledTemplates[tenantAlias], templateModule, templateLocale, templateId, templateType) ||
        _getTemplate(baseCompiledTemplates, templateModule, templateLocale, templateId, templateType);
};

/**
 * Fetch the appropriate template file (either override or base) for the given module, user locale, template id and
 * template type from the `compiledTemplates` object. If a template cannot be found for the given locale, this will
 * try and fall back to the 'default' template locale to find the appropriate template. If no template can be found,
 * `null` will be returned.
 *
 * @param  {Object}     compiledTemplates   An object of compiled templates to use to find the appropriate template
 * @param  {String}     templateModule      The module to which the template belongs
 * @param  {String}     templateLocale      The locale for which to fetch the template
 * @param  {String}     templateId          The id of the template
 * @param  {String}     templateType        The type of template to fetch (i.e., one of 'html', 'txt' or 'meta.json')
 * @return {Function}                       The compiled underscorejs template function that can be used to render the template. If `null`, there was no suitable template for the given criteria.
 * @api private
 */
var _getTemplate = function(compiledTemplates, templateModule, templateLocale, templateId, templateType) {
    var template =
        compiledTemplates &&
        compiledTemplates[templateModule] &&
        compiledTemplates[templateModule][templateLocale] &&
        compiledTemplates[templateModule][templateLocale][templateId] &&
        compiledTemplates[templateModule][templateLocale][templateId][templateType];

    // If we couldn't find the requested template, fall back to the default template
    return template || _getDefaultTemplate(compiledTemplates, templateModule, templateId, templateType);
};

/**
 * Fetch the template from the 'default' locale from the given object of compiled templates.
 *
 * @param  {Object}     compiledTemplates   An object of compiled templates to use to find the appropriate template
 * @param  {String}     templateModule      The module to which the template belongs
 * @param  {String}     templateId          The id of the template
 * @param  {String}     templateType        The type of template to fetch (i.e., one of 'html', 'txt' or 'meta.json')
 * @return {Function}                       The compiled underscorejs template function that can be used to render the template. If `null`, there was no 'default' locale template for the given criteria.
 * @api private
 */
var _getDefaultTemplate = function(compiledTemplates, templateModule, templateId, templateType) {
    var template =
        compiledTemplates &&
        compiledTemplates[templateModule] &&
        compiledTemplates[templateModule]['default'] &&
        compiledTemplates[templateModule]['default'][templateId] &&
        compiledTemplates[templateModule]['default'][templateId][templateType];

    // If we couldn't find the default template, we return null;
    return template || null;
};

/**
 * Create the util object that is available for template JST code to use for
 * advanced functions such as escaping / sanitizing HTML content
 *
 * @return {Object}     util                                The util object that can be used to help render email templates
 *                      util.sanitization                   The `oae-util/lib/sanitization` object that can be used to sanitize user input into appropriate HTML
 *                      util.formatting                     A variety of utilities for formatting content
 *                      util.formatting.plainTextToHTML     Converts plain text input into basic HTML. e.g., turning text line-breaks into <br />
 * @api private
 */
var _createEmailTemplateUtil = function() {
    return {
        'formatting': {
            'plainTextToHTML': _plainTextToHTML
        },
        'sanitization': Sanitization
    };
};

/**
 * Given plain text content, convert it to an appropriate HTML string. Particularly:
 *
 *  * Escape all HTML characters so the content shows as it is in plain text; and
 *  * Convert all line-breaks to <br/> so that line breaks in the content are preserved
 *
 * @param  {String}     content         The plain-text content to convert to HTML
 * @return {String}                     The HTML version of the content
 * @api private
 */
var _plainTextToHTML = function(content) {
    // First escape HTML
    var sanitized = Sanitization.encodeForHTML(content);

    // Honour the new-line characters in the plain text by converting to <br />
    return sanitized.replace(/&#xa;/g, '<br/>');
};
