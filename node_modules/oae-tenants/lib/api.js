/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var express = require('express');
var http = require('http');
var redis = require('redis');
var util = require('util');

var OAE = require('oae-util/lib/oae');
var IO = require('oae-util/lib/io');
var Cassandra = require('oae-util/lib/cassandra');
var Pubsub = require('oae-util/lib/pubsub');
var Validator = require('oae-util/lib/validator').Validator;

var model = require('./model');

var runningServers = {};



Pubsub.on('oae-tenants', function (message) {
    // Commands are of the form:
    //     start 2001
    //     stop 2001
    var args = message.split(' ');
    var cmd = args.shift();
    if (cmd === 'start') {
        var port = args.shift();
        getTenantByPort(port, function(err, tenant) {
            if (err) {
                return console.warn(err.msg);
            }
            _startTenant(tenant, function(err, startedInMaintenanceMode) {
                if (err) {
                    console.warn('Could not start tenant on port %d', port);
                } else {
                    if (startedInMaintenanceMode) {
                        console.log('Tenant %s on port %d started (in maintenance mode.)', tenant.alias, port);
                    } else {
                        console.log('Tenant %s on port %d started.', tenant.alias, port);
                    }
                }
            });
        });
    } else if (cmd === 'stop') {
        var port = args.shift();
        getTenantByPort(port, function(err, tenant) {
            if (err) {
                return console.warn(err.msg);
            }
            _stopTenant(tenant, function(err) {
                if (err) {
                    console.warn(err.msg);
                } else {
                    console.log('Tenant on port %d stopped.', port);
                }
            });
        });
    } else {
        console.log('Received a message but did not know what to do with it: %s', message);
    }
});

/**
 * Publishes a message that a new tenant should be started.
 * Note that the actual server startup will happen asynchronous from this method.
 *
 * @param {Tenant}          tenant          The tenant object representing the tenant to be started
 */
module.exports.startTenant = function(tenant) {
    Pubsub.publish('oae-tenants', 'start ' + tenant.port);
};

/**
 * Start a new tenant by listening on the provided ports.
 *
 * @param {Tenant}                          tenant                      The tenant object representing the tenant to be started
 * @param {Function(err, maintenanceMode)}  callback                    Standard callback function
 * @param {Object}                          callback.err                An error object (if any)
 * @param {Boolean}                         callback.maintenanceMode    Whether or not this tenant started in maintenance mode.
 * @private
 */
var _startTenant = function(tenant, callback) {
    callback = callback || function() {};
    if (tenant) {
        if (runningServers[tenant.port]) {
            // We already created the server object.
            // Take it out of maintenance mode.
            runningServers[tenant.port].inMaintenanceMode = !tenant.active;
            callback(false, !tenant.active);
        } else {
            // Create a basic express server.
            tenant.server = express();

            // Keep all the servers in memory so we can access them later.
            runningServers[tenant.port] = http.createServer(tenant.server);
            runningServers[tenant.port].listen(tenant.port);
            runningServers[tenant.port].inMaintenanceMode = !tenant.active;

            // Provide this middleware that checks if this server should be in maintenance mode
            // and if not, expose the tenant on each request.
            tenant.server.use(function(req, res, next) {
                if (runningServers[tenant.port].inMaintenanceMode) {
                    // If we're running in maintenance mode, there is no point in keeping connections open.
                    res.setHeader('Connection', 'Close');
                    return res.send(200, 'This server is currently in maintenance mode. Please check back later.');
                }
                req.tenant = tenant;
                req.user = null;
                next();
            });

            // Each tenant has it's own passport impl
            tenant.passport = require('passport');

            // The server has start uped, register all our endpoints.
            registerAPI(tenant, function() {
                callback(false, !tenant.active);
            });
        }
    } else {
        callback({'code': 400, 'msg': 'No tenant was provided.'});
    }
};

/**
 * Stops a running tenant.
 *
 * @param   {Tenant}        tenant          The tenant object representing the tenant to be stopped
 * @param   {Function(err)} callback        Standard callback function
 * @param   {Object}        callback.err    An error object (if any.)
 * @private
 */
var _stopTenant = function(tenant, callback) {
    if (tenant && runningServers[tenant.port]) {
        // Stick that server into maintenance mode.
        runningServers[tenant.port].inMaintenanceMode = true;
        callback();
    } else {
        callback({'code': 404, 'msg': 'No server found on that port.'});
    }
};

/**
 * Put a tenant in maintenance mode or take it out of it.
 * @param {Array<Number>}   ports               An array of ports that should be stopped.
 * @param {Boolean}         needsMaintenance    True if the tenant needs to go into maintenance mode
 * @param {Function(err)}   callback            Callback function executed when request is completed.
 * @param {Object}          callback.err        An error object (if any.)
 */
var putTenantsInMaintenanceMode = module.exports.putTenantsInMaintenanceMode = function(ports, needsMaintenance, callback) {
    callback = callback || function() {};
    if (!ports) {
        return callback({'code': 400, 'msg': 'Please provide a ports array'});
    }
    if (!util.isArray(ports)) {
        ports = [ports];
    }

    // Store the activity flag in cassandra.
    var queries = [];
    ports.forEach(function(port) {
        queries.push({
            'query': 'UPDATE Tenant SET active = ? WHERE port = ?',
            'parameters': [!needsMaintenance, port]
        });
    });
    Cassandra.runBatchQuery(queries, function(err) {
        if (err) {
            return callback(err);
        }

        // Broadcast the message accross the cluster
        // so we can start/stop the tenants.
        var cmd = (needsMaintenance) ? 'stop' : 'start';
        ports.forEach(function(port) {
            Pubsub.publish('oae-tenants', cmd + ' ' + port);
        });
        callback();
    });
};

/**
 * Rather than physically deleting a tenant, we just stick it in maintenance mode for now.
 *
 * @param {Tenant}   ports               The tenant object representing the tenant to be stopped
 * @param {Function} callback            Callback function executed when request is completed.
 */
var deleteTenants = module.exports.deleteTenants = function(ports, callback) {
    callback = callback || function() {};
    if (!ports) {
        return callback({'code': 400, 'msg': 'Please provide a ports array'});
    }
    if (!util.isArray(ports)) {
        ports = [ports];
    }

    var queries = []
    ports.forEach(function(port) {
        queries.push({
            'query': 'UPDATE Tenant SET active = ?, deleted = ? WHERE port = ?',
            'parameters': [false, true, port]
        });
    });
    Cassandra.runBatchQuery(queries, function(err) {
        if (err) {
            return callback(err);
        }
        // Broadcast the message accross the cluster
        // so we can stop the tenants.
        ports.forEach(function(port) {
            Pubsub.publish('oae-tenants', 'stop ' + port);
        });
        callback();
    });
};

/**
 * Get all the tenants in the datastore.
 * @param {Function(err, tenants)}  callback            Standard callback function
 * @param {Object}                  callback.err        Error object containing the error message
 * @param {Array<Tenant>}           callback.tenants    Array of all the existing tenants
 */ 
var getAllTenants = module.exports.getAllTenants = function(callback) {
    Cassandra.runQuery('SELECT * FROM Tenant', false, function(err, rows) {
        if (!err) {
            var tenants = [];
            if (hasTenant(rows)) {
                rows.forEach(function(row) {
                    var tenant = mapToTenant(row, false);
                    if (!tenant.deleted) {
                        tenants.push(tenant);
                    }
                });
            }
            callback(null, tenants);
        } else {
            callback(err);
        }
    });
};

/**
 * Get the unique tenant by their mapped port.
 * 
 * @param {Number}   port The port number on which the tenant listens
 * @param {Function} callback A function(err, tenant) specifying the tenant requested
 */
var getTenantByPort = module.exports.getTenantByPort = function(port, callback) {
    Cassandra.runQuery('SELECT * FROM Tenant WHERE port = ?', [ port ], function(err, rows) {
        if (!err) {
            if (hasTenant(rows)) {
                var tenant = mapToTenant(rows[0]);
                callback(null, tenant);
            } else {
                callback({'code': 404, 'msg': 'There is no tenant listening on port ' + port});
            }
        } else {
            callback(err);
        }
    });
};

/**
 * Get the unique tenant by their alias.
 * 
 * @param {String}   alias The alias assigned to the tenant
 * @param {Function} callback A function(err, tenant) specifying the tenant requested
 */
var getTenantByAlias = module.exports.getTenantByAlias = function(alias, callback) {
    getAllTenants(function(err, tenants) {
        if (!err) {
            var tenant = null;
            if (tenants !== null) {
                for (var i = 0; i < tenants.length; i++) {
                    if (tenants[i].alias === alias) {
                        tenant = tenants[i];
                        break;
                    }
                }
            }
            callback(null, tenant);
        } else {
            callback(err);
        }
    });
};

/**
 * Create a tenant using the provided information.
 * 
 * @param {String}                  alias           The unique alias assigned to the tenant
 * @param {String}                  name            A descriptive short name for the tenant
 * @param {String}                  description     A long description of the tenant
 * @param {Number}                  port            The port on which the tenant should listen
 * @param {String}                  baseUrl         The baseUrl on which this tenant is proxying (ie: oae.cam.ac.uk or oae.gatech.edu)
 * @param {Function(err, tenant)}   callback        A function(err, tenant) specifying the tenant information that was persisted.
 * @param {Object}                  callback.err    An error object (if any)
 * @param {Tenant}                  callback.tenant The tenant that was persisted.
 */
var createTenant = module.exports.createTenant = function(alias, name, description, port, baseUrl, callback) {
    callback = callback || function() {};
    var validator = new Validator();
    validator.check(alias, {'code': 400, 'msg': 'Missing alias'}).notEmpty();
    validator.check(name, {'code': 400, 'msg': 'Missing name'}).notEmpty();
    validator.check(description, {'code': 400, 'msg': 'Missing description'}).notEmpty();
    validator.check(port, {'code': 400, 'msg': 'Missing port'}).notEmpty();
    validator.check(port, {'code': 400, 'msg': 'Provided port is not a number'}).isInt();
    validator.check(baseUrl, {'code': 400, 'msg': 'Missing base url'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getTenantByPort(port, function(err, tenant) {
        if (!tenant) {
            getTenantByAlias(alias, function(err, tenant) {
                if (!tenant) {
                    baseUrl = baseUrl || "localhost:" + port;
                    description = description || "";
                    tenant = new model.Tenant(alias, name, description, port, baseUrl, true, false);
                    // no tenant by this alias or port exist, create one
                    Cassandra.runQuery('UPDATE Tenant SET alias = ?, name = ?, description = ?, baseUrl = ?, active = ? where port = ?',
                        [tenant.alias, tenant.name, tenant.description, baseUrl, tenant.active, tenant.port], function(err) {
                        if (!err) {
                            // Send a message to all the app servers in the cluster that they
                            // should start up the tenant.
                            Pubsub.publish('oae-tenants', 'start ' + port);
                            callback(false, tenant);
                        } else {
                            callback(err);
                        }
                    });
                } else {
                    callback({'code': 400, 'msg': 'A tenant with the alias ' + alias + ' already exists'});
                }
            });
        } else {
            callback({'code': 400, 'msg': 'A tenant is already running on port ' + port});
        }
    });
};

/**
 * Register all of the REST end points from all modules against a tenant
 * @param {Tenant}      tenant      The tenant object representing the tenant for which the REST
 *                                  endpoints need to be registered
 * @param {Function}    callback    Standard callback function execute when all of the REST endpoints
 *                                  have finished registering
 */
var registerAPI = function(tenant, callback) {
    OAE.getAvailableModules(function(modules) {
        var modulesLoaded = 0;
        for (var m = 0; m < modules.length; m++) {
            (function(m) {
                var path = "node_modules/" + modules[m] + "/lib/rest.js";
                IO.pathExists(path, function(exists) {
                    if (exists) {
                        require(modules[m] + "/lib/rest")(tenant);
                    }
                    modulesLoaded++;
                    if (modulesLoaded === modules.length) {
                        callback();
                    }
                });
            }(m));
        }
    });
};

/**
 * Determines whether or not this set of rows represents a result set with a tenant.
 */
var hasTenant = function(rows) {
    return (rows[0] && rows[0].count > 1);
};

/**
 * Map a cassandra row element to a tenant object.
 */
var mapToTenant = function(row, returnDeleted) {
    var hash = Cassandra.rowToHash(row);
    return new model.Tenant(hash.alias, hash.name, hash.description, hash.port, hash.baseUrl, hash.active, hash.deleted);
};
