/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzUtil = require('oae-authz/lib/util');
var OaeUtil = require('oae-util/lib/util');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var PrincipalsUtil = require('oae-principals/lib/util');
var SearchConstants = require('oae-search/lib/constants').SearchConstants;
var SearchAPI = require('oae-search');
var SearchUtil = require('oae-search/lib/util');
var TenantsUtil = require('oae-tenants/lib/util');
var Validator = require('oae-util/lib/validator').Validator;

var LibraryAPI = require('oae-library');

/**
 * Register a search that searches through a user or group library.
 *
 * @param  {String}     searchName                                  The name under which this search will be available
 * @param  {String[]}   resourceTypes                               The types of resources this search should return. e.g., discussion or content
 * @param  {Object}     [options]                                   Additional options that describe how this library search should function
 * @param  {Object}     [options.searches]                          Contains functions that can return a search filter per library visibility
 * @param  {Function}   [options.searches.public]                   The function to use to derive the filter for the public library bucket
 * @param  {Context}    [options.searches.public.ctx]               The context of the current request
 * @param  {User|Group} [options.searches.public.libraryOwner]      An object that represents the owner of this library (e.g., User if it's a user library, etc...)
 * @param  {Object}     [options.searches.public.opts]              The search options (i.e., the request query string and path variables)
 * @param  {Function}   [options.searches.public.callback]          Standard callback for the custom search
 * @param  {Object}     [options.searches.public.callback.err]      An error that occurred while creating the filter, if any
 * @param  {Object}     [options.searches.public.callback.filter]   The filter to use for the query, as constructed using the `SearchUtil.filter*` methods
 * @param  {Function}   [options.searches.loggedin]                 The function to use to derive the filter for the loggedin library bucket. See `options.searches.public` parameter for function parameters
 * @param  {Function}   [options.searches.private]                  The function to use to derive the filter for the private library bucket. See `options.searches.public` parameter for function parameters
 */
module.exports.registerLibrarySearch = function(searchName, resourceTypes, options) {
    options = options || {};
    options.searches = options.searches || {};

    SearchAPI.registerSearch(searchName, function(ctx, opts, callback) {
        // Sanitize the custom search options
        opts = opts || {};
        opts.principalId = opts.pathParams[0];
        opts.limit = OaeUtil.getNumberParam(opts.limit, 12, 1, 25);

        var validator = new Validator();
        validator.check(opts.principalId, {'code': 400, 'msg': 'Must specificy an id of a user or group to search'}).isPrincipalId();
        if (validator.hasErrors()) {
            return callback(validator.getFirstError());
        }

        PrincipalsDAO.getPrincipal(opts.principalId, function(err, libraryOwner) {
            if (err) {
                return callback(err);
            }

            LibraryAPI.Authz.resolveTargetLibraryAccess(ctx, libraryOwner, function(err, canAccess, visibility) {
                if (err) {
                    return callback(err);
                } else if (!canAccess) {
                    return callback({'code': 401, 'msg': 'You are not authorized to access this library search feed'});
                }

                var query = SearchUtil.createQueryStringQuery(opts.q);
                var filterFunction = (_.isFunction(options.searches[visibility])) ? options.searches[visibility] : _defaultLibraryFilter(resourceTypes, visibility);
                filterFunction(ctx, libraryOwner, opts, function(err, filter) {
                    if (err) {
                        return callback(err);
                    }

                    return callback(null, SearchUtil.createQuery(query, filter, opts));
                });
            });
        });
    });
};

/**
 * Provides a sane default privacy filter for searching libraries. This logic mimicks the library visibility logic
 * such that if a library is requested, only the appropriate items in the visibility bucket are returned
 *
 * @param  {String[]}   resourceTypes       The types of resources to filter by
 * @param  {String}     visibility          The target library visibility to filter as per AuthzConstants#visibility
 * @return {Function}                       The function that can provide a default search filter, as per the `options.searches.<visibility>` search parameter specifications in Library.Search#registerLibrarySearch
 */
var _defaultLibraryFilter = function(resourceTypes, visibility) {
    return function(ctx, libraryOwner, opts, callback) {
        // Only look for resources that are in the user's library
        var baseFilter = SearchUtil.filterAnd(
            SearchUtil.filterTerm('_type', SearchConstants.search.MAPPING_RESOURCE),
            SearchUtil.filterTerms('resourceType', resourceTypes),
            SearchUtil.createHasChildQuery(AuthzConstants.search.MAPPING_RESOURCE_MEMBERS, SearchUtil.filterTerms('direct_members', [opts.principalId]))
        );

        if (visibility === AuthzConstants.visibility.PRIVATE) {
            filter = baseFilter;
        } else if (visibility === AuthzConstants.visibility.LOGGEDIN) {
            filter = SearchUtil.filterAnd(
                baseFilter,
                SearchUtil.filterOr(
                    SearchUtil.filterTerm('visibility', AuthzConstants.visibility.PUBLIC),
                    SearchUtil.filterAnd(
                        SearchUtil.filterTerm('tenantAlias', libraryOwner.tenant.alias),
                        SearchUtil.filterTerm('visibility', AuthzConstants.visibility.LOGGEDIN)
                    )
                )
            );
        } else {
            filter = SearchUtil.filterAnd(baseFilter, SearchUtil.filterTerm('visibility', AuthzConstants.visibility.PUBLIC));
        }

        return callback(null, filter);
    };
};

