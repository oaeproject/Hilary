/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var crypto = require('crypto');
var GoogleStrategy = require('passport-google').Strategy;
var OpenIDStrategy = require('passport-openid').Strategy;
var LocalStrategy = require('passport-local').Strategy;
var util = require('util');
var Validator = require('validator').Validator;

var Cassandra = require('oae-util/lib/cassandra');
var Context = require('oae-context').Context;
var log = require('oae-logger').logger('authentication');
var PrincipalsAPI = require('oae-principals');
var User = require('oae-principals/lib/model').User;

var AuthenticationConstants = require('oae-authentication/lib/constants').AuthenticationConstants;
var AuthenticationUtil = require('oae-authentication/lib/util');
var LoginId = require('oae-authentication/lib/model').LoginId;

/**
 * Utility methods that gets a user by the login id. If no user was found it will be created.
 *
 * @param  {Context}      ctx                The current context, used to determine the tenant of the user to get / create
 * @param  {String}       authProvider       The authentication provider of the id.
 * @param  {String}       externalId         The desired externalId/username for this user.
 * @param  {String}       displayName        The display name of this user
 * @param  {String}       [opts]             Optional user profile parameters.
 * @param  {String}       [opts.locale]      The locale of this user.
 * @param  {String}       [opts.timezone]    The timezone of this user.
 * @param  {String}       [opts.visibility]  The visibility of the user
 * @param  {String}       [opts.publicAlias] The alias to show when the user is private / inaccessible by the current user
 * @param  {Function}     callback           A function returning the user.
 * @param  {Object}       callback.err       An error that occured, if any
 * @param  {Boolean}      callback.user      The user object
 */
var getOrCreateUser = module.exports.getOrCreateUser = function(ctx, authProvider, externalId, displayName, opts, callback) {
    var tenantId = ctx.tenant().alias;
    var loginId = new LoginId(tenantId, authProvider, externalId);
    _getUserIdFromLoginId(loginId, function(err, userId) {
        if (err) {
            return callback(err);
        }

        if (!userId) {
            // no user mapped to this login id. create them
            return createUser(ctx, loginId, displayName, opts, callback);
        } else {
            // the user existed
            return PrincipalsAPI.getUser(ctx, userId, callback);
        }
    });
};

/**
 * Create a user in the database with the provided loginId.
 *
 * @param   {Context}   ctx                 The current context
 * @param   {LoginId}   loginId             The login id that will be associated with the user so they may log in
 * @param   {String}    displayName         The display name of the user
 * @param   {Object}    [opts]              Optional parameters that can be assigned to a user
 * @param   {String}    [opts.locale]       The locale of this user.
 * @param   {String}    [opts.timezone]     The timezone of this user.
 * @param   {String}    [opts.visibility]   The visibility of the user
 * @param   {String}    [opts.publicAlias]  The alias to show when the user is private / inaccessible by the current user
 * @param   {Function}  callback            Invoked when the process completes
 * @param   {Object}    callback.err        An error that occurred, if any
 * @param   {Boolean}   callback.user       The user that was created
 */
var createUser = module.exports.createUser = function(ctx, loginId, displayName, opts, callback) {

    var validator = new Validator();
    _validateLoginIdForPersistence(validator, loginId);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // make sure the loginId is not already associated to a user
    _getUserIdFromLoginId(loginId, function(err, userId) {
        if (userId) {
            return callback({ code: 400, msg: 'This login id already exists and is already associated to a user.' });
        }

        // hash the user password
        if (loginId.provider === AuthenticationConstants.providers.LOCAL) {
           loginId.properties.password = AuthenticationUtil.hashPassword(loginId.properties.password);
        }

        // create the user in the database and immediately associate the login id
        PrincipalsAPI.createUser(ctx, displayName, opts, function(err, user) {
            if (err) {
                return callback(err);
            }

            loginId.userId = user.id;
            _associateLoginId(loginId, user.id, function(err) {
                if (err) {
                    return callback(err);
                }

                log(ctx).info({
                    loginId: {
                        tenantId: loginId.tenantId,
                        provider: loginId.provider,
                        externalId: loginId.externalId
                    },
                    userId: user.id
                }, 'Created user with a mapped login id.');

                return callback(null, user);
            });
        });
    });
}

/**
 * Associate the given Login ID info to the specified user. This makes it possible for the associated user to login with the provided
 * login credentials.
 *
 * @param   {Context}   ctx             The current context
 * @param   {LoginId}   loginId         The login id to associate to the user
 * @param   {String}    userId          The id of the user in the database
 * @param   {Function}  callback        Invoked when the process completes
 * @param   {Object}    callback.err    An error that occurred, if any
 */
var associateLoginId = module.exports.associateLoginId = function(ctx, loginId, userId, callback) {
    var validator = new Validator();
    _validateLoginIdForPersistence(validator, loginId);
    validator.check(userId, {code: 400, msg: 'Must specify a user id'}).notEmpty();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var isAdmin = ctx.user() && ctx.user().isAdmin(loginId.tenantId);
    var isTargetUser = ctx.user() && ctx.user().id === userId;

    if (!isAdmin && !isTargetUser) {
        // only admin and the user themself can associate a login id to the account
        return callback({ code: 401, msg: 'Not allowed to associate a login id to this user' });
    }

    _getUserIdFromLoginId(loginId, function(err, existingUserIdMapping) {
        if (err) {
            return callback(err);
        } else if (existingUserIdMapping && !isAdmin) {
            // only admin can re-associate a login id to another user
            return callback({ code: 401, msg: 'Login ID is already associated to a user.'});
        }

        // verify we don't assign 2 ids of the same provider to a user
        _getUserLoginIds(userId, function(err, loginIds) {
            if (err) {
                return callback(err);
            } else if (loginIds[loginId.provider]) {
                return  callback({ code: 400, msg: 'User already has a login id of type ' + loginId.provider });
            }

            // ensure that the target user exists
            PrincipalsAPI.getUser(ctx, userId, function(err, user) {
                if (err) {
                    return callback(err);
                }

                if (!user) {
                    return callback({ code: 404, msg: 'User does not exist.'});
                }

                _associateLoginId(loginId, userId, function(err) {
                    if (err) {
                        callback(err);
                    } else {
                        log(ctx).info({
                            loginId: {
                                tenantId: loginId.tenantId,
                                provider: loginId.provider,
                                externalId: loginId.externalId
                            },
                            userId: userId
                        }, 'Mapped login id to user account.');
                        callback();
                    }
                });
            });
        });
    });
}

/**
 * Changes the local password of a user.
 *
 * @param  {Context}  ctx           The current context.
 * @param  {String}   userId        The user id of the user whose password that needs to be changed.
 * @param  {String}   oldPassword   The old password that can be used to authenticate this change request.
 * @param  {String}   newPassword   The new password.
 * @param  {Function} callback      Invoked when the process completes
 * @param  {Object}   callback.err  An error that occurred, if any
 */
var changePassword = module.exports.changePassword = function(ctx, userId, oldPassword, newPassword, callback) {

    var _changePassword = function(loginId) {
        // Hash and store it.
        var hash = AuthenticationUtil.hashPassword(newPassword);
        Cassandra.runQuery('UPDATE AuthenticationLoginId USING CONSISTENCY QUORUM SET password = ? WHERE loginId = ?', [hash, _flattenLoginId(loginId)], function(err) {
            if (err) {
                callback(err);
            } else {
                log(ctx).info('Password successfully changed for user %s by %s.', userId, ctx.user().id);
                callback();
            }
        });
    };

    // get the local login id for the user
    _getUserLoginIds(userId, function(err, loginIds) {
        if (err) {
            return callback(err);
        }

        // can only change password on the local account type
        var localLoginId = loginIds[AuthenticationConstants.providers.LOCAL];
        if (localLoginId) {

            // determine the current user access
            var isAdmin = ctx.user() && ctx.user().isAdmin(localLoginId.tenantId);
            var isTargetUser = ctx.user() && ctx.user().id === userId;

            if (!isAdmin && !isTargetUser) {
                return callback({'code': 401, 'msg': 'You\'re not authorized to change this user\'s password.'});
            } else if (isAdmin) {
                // if the user is admin we don't care about the old password
                return _changePassword(localLoginId);
            } else {
                // if it's the current user, we need to verify the old password
                checkPassword(localLoginId.tenantId, localLoginId.externalId, oldPassword, function(err, user) {
                    if (err) {
                        // old password was probably incorrect
                        return callback(err);
                    // do a sanity check on the user id to ensure the user that was checked against was the correct user
                    } else if (user && user.id === ctx.user().id) {
                        return _changePassword(localLoginId);
                    } else {
                        // I don't know how this could happen
                        return callback({'code': 500, 'msg': 'An unknown error occurred when trying to change the password.'});
                    }
                });
            }
        } else {
            return callback({'code': 400, 'msg': 'User does not have a local account mapping.'});
        }
    });
};

/**
 * Checks the password for a specified user id.
 *
 * @param  {String}    tenantId     The tenant to which the user belongs
 * @param  {String}    username     The local username of the user
 * @param  {String}    password     The password that can be used to compare with the one in the DB.
 * @param  {Function}  callback     Invoked when the process completes
 * @param  {Object}    callback.err If the password check fails, this will be an error with `err.code === 401`. If there is an unexpected internal error, this will be that error.
 * @param  {object}    callback.id  The ID of the user if the passwords match
 */
var checkPassword = module.exports.checkPassword = function(tenantId, username, password, callback) {
    // we can only check password on local authentication
    var loginId = new LoginId(tenantId, AuthenticationConstants.providers.LOCAL, username);

    var validator = new Validator();
    _validateLoginIdForLookup(validator, loginId);
    if (validator.hasErrors()) {
        return new callback(validator.getFirstError());
    }

    Cassandra.runQuery('SELECT userId, password FROM AuthenticationLoginId USING CONSISTENCY QUORUM WHERE loginId = ?', [ _flattenLoginId(loginId) ], function(err, rows) {
        if (err) {
            return callback(err);
        }

        if (rows[0].count === 0) {
            // No user found with that username.
            return callback({'code': 401, 'msg': 'No password found for this principal'});
        }

        // Check if the user provided password matches the stored password
        var result = Cassandra.rowToHash(rows[0]);
        var passwordMatches = result.userId && result.password && AuthenticationUtil.hashAndComparePassword(password, result.password);
        if (passwordMatches) {
            callback(null, { 'id': result.userId });
        } else {
            log().info('Invalid password check for user %s', username);
            callback({'code': 401, 'msg': 'User name and/or password do not match.'});
        }
    });
};

/**
 * Gets the userId that is associated to the provided login ID, if any.
 *
 * @param   {String}    tenantId        The tenant of the login id
 * @param   {String}    provider        The provider of the login id (e.g., twitter, local, google...)
 * @param   {String}    externalId      The id of the user in the external authentication service
 * @param   {Function}  callback        Invoked when the process completes
 * @param   {Object}    callback.err    An error that occurred, if any
 * @param   {String}    callback.userId The id of the user that was associated to the login id, if any
 */
var getUserIdFromLoginId = module.exports.getUserIdFromLoginId = function(tenantId, provider, externalId, callback) {
    var loginId = new LoginId(tenantId, provider, externalId);

    var validator = new Validator();
    _validateLoginIdForLookup(validator, loginId);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getUserIdFromLoginId(loginId, callback);
}


/**
 * Associate the given Login ID info to the specified user. This makes it possible for the associated user to login with the provided
 * login credentials.
 *
 * @param   {LoginId}   loginId         The login id to associate
 * @param   {String}    userId          The id of the user in the database
 * @param   {Function}  callback        Invoked when the process completes
 * @param   {Object}    callback.err    An error that occurred, if any
 */
var _associateLoginId = function(loginId, userId, callback) {
    loginId.properties = loginId.properties || {};
    var flattenedLoginId = _flattenLoginId(loginId);

    // sanitize and prepare the columns for the upsert
    delete loginId.properties.loginId;
    loginId.properties.userId = userId;

    var query = Cassandra.constructUpsertCQL('AuthenticationLoginId', 'loginId', flattenedLoginId, loginId.properties);
    if (query) {
        var queries = [];
        queries.push(query);
        queries.push({
            'query': 'UPDATE AuthenticationUserLoginId SET ? = ? WHERE userId = ?',
            'parameters': [flattenedLoginId, '1', userId]
        });
        return Cassandra.runBatchQuery(queries, 'QUORUM', callback);
    } else {
        log().error({
            loginId: loginId,
            userId: userId
        }, 'Error constructing query to associate login id to user.');
        return callback(new Error('Error associating login id to user ' + userId));
    }
}

/**
 * Get the login ids that are mapped to a user.
 *
 * @param {String}      userId              The id of the user
 * @param {Function}    callback            Invoked when the prcess completes
 * @param {Object}      callback.err        An error that occurred, fi any
 * @param {Object}      callback.loginIds   A hash whose keys are the authentication providers, and values are the LoginId objects that are mapped to the user
 */
var _getUserLoginIds = function(userId, callback) {
    if (!userId) {
        return callback(null, {});
    }

    Cassandra.runQuery('SELECT * FROM AuthenticationUserLoginId USING CONSISTENCY QUORUM WHERE userId = ?', [userId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var loginIds = {};
        rows.forEach(function(row) {
            row.forEach(function(name, value) {
                if (name !== 'userId') {
                    var loginId = _expandLoginId(name);
                    loginIds[loginId.provider] = loginId;
                }
            });
        });

        return callback(null, loginIds);
    });
}

/**
 * Gets the userId that is associated to the provided login ID, if any.
 *
 * @param   {LoginId}   loginId         The login id to search
 * @param   {Function}  callback        Invoked when the process completes
 * @param   {Object}    callback.err    An error that occurred, if any
 * @param   {String}    callback.userId The id of the user that was associated to the login id, if any
 */
var _getUserIdFromLoginId = function(loginId, callback) {
    Cassandra.runQuery('SELECT userId FROM AuthenticationLoginId USING CONSISTENCY QUORUM WHERE loginId = ?', [ _flattenLoginId(loginId) ], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var row = rows[0];
        if (row) {
            var result = Cassandra.rowToHash(row);
            return callback(null, result.userId);
        } else {
            return callback();
        }
    });
}

/**
 * Flatten a LoginId object into a string representation that can be used for a storage key.
 *
 * @param   {LoginId}   loginId     The login id to flatten
 * @return  {String}                The flattened string key representation of the login id
 */
var _flattenLoginId = function(loginId) {
    if (!loginId || !loginId.tenantId || !loginId.provider || !loginId.externalId) {
        return null;
    }
    return loginId.tenantId + ':' + loginId.provider + ':' + loginId.externalId;
}

/**
 * Expand a flattened key representation of a login id into a LoginId object. This is the opposite of #_flattenLoginId.
 *
 * @param   {String}    loginIdStr  The flat string key representation of the login id
 * @return  {LoginId}               The LoginId object that is represented by the flat string
 */
var _expandLoginId = function(loginIdStr) {
    if (!loginIdStr) {
        return null;
    }

    var loginIdSplit = loginIdStr.split(':');
    if (loginIdSplit.length < 3) {
        return null;
    }

    // the externalId can contain *anything*, including colons. keep that in-tact with a slice-and-join.
    return new LoginId(loginIdSplit[0], loginIdSplit[1], loginIdSplit.slice(2).join(':'));
}

/**
 * Verify that the given login ID is suitable to be used to look up a user id mapping.
 *
 * @param {Validator}       validator   The validator to use to validate the loginId
 * @param {LoginId}         loginId     The login id to validate
 */
var _validateLoginIdForLookup = function(validator, loginId) {
    var numErrors = validator.getErrorCount();
    validator.check(null, { 'code': 400, 'msg': 'Must specify a login id.' }).isObject(loginId);
    if (validator.getErrorCount() === numErrors) {
        // only validate these if loginId is a valid object
        validator.check(loginId.tenantId, {code: 400, msg: 'Must specify a tenant id on the login id'}).notEmpty();
        validator.check(loginId.provider, {code: 400, msg: 'Must specify an authentication provider on the login id'}).notEmpty();
        validator.check(loginId.externalId, {code: 400, msg: 'Must specify an external id on the login id'}).notEmpty();
    }
}

/**
 * Verify that the given login ID is suitable to be persisted to storage.
 *
 * @param {Validator}       validator   The validator to use to validate the loginId
 * @param {LoginId}         loginId     The login id to validate
 */
var _validateLoginIdForPersistence = function(validator, loginId) {
    var numErrors = validator.getErrorCount();
    _validateLoginIdForLookup(validator, loginId);

    // only continue validating if the login id is valid so far
    if (validator.getErrorCount() === numErrors) {
        loginId.properties = loginId.properties || {};

        // custom handling for local authentication (i.e., username and password)
        if (loginId.provider === AuthenticationConstants.providers.LOCAL) {
            validator.check(loginId.properties.password, { code: 400, msg: 'Must specify a password at least 6 characters long.' }).len(6);
        }
    }
}

/////////////
//  LOCAL  //
/////////////

module.exports.LocalStrategyWrapper = function(tenant) {
    var options = {
        'passReqToCallback': true,
        'failureRedirect': false
    };

    var strat = new LocalStrategy(options, function(req, username, password, done) {
        checkPassword(tenant.alias, username, password, function(err, basicUser) {
            if (err && err.code !== 401) {
                return done(err);
            } else if (err && err.code === 401) {
                return done(null, false);
            }

            // By this point we know that we were succesfully logged in.
            // Retrieve the user account and stick it in the context.
            req.ctx = new Context(tenant, new User(tenant.alias, basicUser.id));
            PrincipalsAPI.getUser(req.ctx, basicUser.id, function(err, user) {
                if (err) {
                    return done(err);
                }

                req.ctx = new Context(tenant, user);
                return done(null, user);
            });
        });
    });
    strat.name = 'local-' + tenant.alias;
    return strat;
};



//////////////
//  GOOGLE  //
//////////////

module.exports.GoogleCallbackWrapper = function(tenant) {
    var that = {};
    that.context = new Context(tenant, null);
    that.callback = function(identifier, profile, done) {
        var username = profile.emails[0].value;
        var displayName = profile.name.givenName + " " + profile.name.familyName;

        // TODO: Get locale/timezone.
        getOrCreateUser(that.context, AuthenticationConstants.providers.GOOGLE, username, displayName, null, done);
    };
    return that;
};

module.exports.GoogleStrategyWrapper = function(tenant, validate) {
    var options = {
        'providerURL': 'https://www.google.com/accounts/o8/id',
        'profile': true,
        'returnURL' : 'http://' + tenant.baseUrl + '/api/auth/google/return',
        'realm': 'http://' + tenant.baseUrl + '/'
    };

    OpenIDStrategy.call(this, options, validate);
    this.name = 'google-' + tenant.alias;
};
util.inherits(module.exports.GoogleStrategyWrapper, GoogleStrategy);



///////////////
//  TWITTER  //
///////////////

module.exports.TwitterCallbackWrapper = function(tenant) {
    var that = {};
    that.context = new Context(tenant, null);
    that.callback = function(token, tokenSecret, profile, done) {
        // Use the Twitter handle to register this user.
        var username = profile.username;
        var displayName = profile.displayName;
        var opts = {
            timezone: profile._json.time_zone
        };

        getOrCreateUser(that.context, AuthenticationConstants.providers.TWITTER, username, displayName, opts, done);
    };
    return that;
};



////////////////
//  FACEBOOK  //
////////////////

module.exports.FacebookCallbackWrapper = function(tenant) {
    var that = {};
    that.context = new Context(tenant, null);
    that.callback = function(accessToken, refreshToken, profile, done) {
        var username = profile.username;
        var displayName = profile.displayName;
        var opts = {
            locale: profile._json.locale
        };

        getOrCreateUser(that.context, AuthenticationConstants.providers.FACEBOOK, username, displayName, opts, done);
    };
    return that;
};

