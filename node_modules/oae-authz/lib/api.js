/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var Cassandra = require('oae-util/lib/cassandra');
var PrincipalsUtil = require('oae-principals/lib/util');
var Telemetry = require('oae-telemetry').telemetry('authz');
var TenantsUtil = require('oae-tenants/lib/util');

var AuthzUtil = require('oae-authz/lib/util');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var Validator = require('oae-authz/lib/validator').Validator;


/////////////////////////
// ROLES & PERMISSIONS //
/////////////////////////

/**
 * Determine the direct role assigned to a principal on a specified resource.
 *
 * @param  {String}     principalId     The principal id. This can be a user or a group
 * @param  {String}     resourceId      The resource id. This can be a group as well.
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any.
 * @param  {String}     callback.role   The role of the principal on the resource. If the principal has no role or there is an error performing the check, role will be null.
 * @api private
 */
var _getDirectRole = function(principalId, resourceId, callback) {
    getDirectRoles([principalId], resourceId, function(err, roles) {
        if (err) {
            return callback(err);
        }

        return callback(null, roles[principalId]);
    });
};

/**
 * Determine the role assigned to the given principals directly on the specified resource instance.
 *
 * @param  {String[]}     principalIds    Array of principal ids. These can be user or group ids
 * @param  {String}       resourceId      The resource id. This can be a group as well.
 * @param  {Function}     callback        Standard callback function
 * @param  {Object}       callback.err    An error that occurred, if any.
 * @param  {Object}       callback.roles  A hash keyed by principal id, with value set to the role they have directly on the resource. If the principal has no role or there is an error performing the check, role will be null.
 **/
var getDirectRoles = module.exports.getDirectRoles = function(principalIds, resourceId, callback) {
    var validator = new Validator();
    validator.check(principalIds.length, {'code': 400, 'msg': 'At least one principal Id needs to be passed in'}).min(1);
    validator.check(resourceId, {'code': 400, 'msg': 'Invalid resource id provided.'}).isResourceId();
    _.each(principalIds, function(principalId) {
        validator.check(principalId, {'code': 400, 'msg': 'Invalid principal id provided.'}).isPrincipalId();
    });
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    Cassandra.runQuery('SELECT ? FROM AuthzMembers USING CONSISTENCY QUORUM WHERE resourceId = ?', [principalIds, resourceId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        // Aggregate the roles for the principals
        var roles = Cassandra.rowToHash(rows[0]);
        return callback(null, roles);
    });
};

/**
 * Given a principal and a resource, determine all the effective roles that the principal has on the resource, by virtue of direct
 * association and indirect group inheritance.
 *
 * @param  {String}       principalId       The principal id. This can be a user or a group
 * @param  {String}       resourceId        The resource id. This can be a group as well.
 * @param  {Function}     callback          Standard callback function
 * @param  {Object}       callback.err      An error that occurred, if any
 * @param  {String[]}     callback.roles    An array containing all the roles the principal has on the resource.
 */
var getAllRoles = module.exports.getAllRoles = function(principalId, resourceId, callback) {
    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'Invalid principal id provided.'}).isPrincipalId();
    validator.check(resourceId, {'code': 400, 'msg': 'Invalid resource id provided.'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the direct role of the user
    _getDirectRole(principalId, resourceId, function(err, directRole) {
        if (err) {
            return callback(err);
        }

        // Get the indirect roles of the user.
        _getIndirectRoles(principalId, resourceId, function(err, roles) {
            if (err) {
                return callback(err);
            }

            // Add the direct role (if any.)
            if (directRole) {
                roles.push(directRole);
            }
            callback(null, roles);
        });
    });
};

/**
 * Given a principal and a resource, determine all the roles that the principal has on the resource, by virtue of
 * indirect group inheritance.
 *
 * @param  {String}       principalId     The principal id. This can be a user or a group
 * @param  {String}       resourceId      The resource id. This can be a group as well.
 * @param  {Function}     callback        Standard callback function
 * @param  {Object}       callback.err    An error that occurred, if any
 * @param  {String[]}     callback.roles  An array containing all the roles the principal has on the resource by virtue of indirect group inheritance.
 * @api private
 */
var _getIndirectRoles = function(principalId, resourceId, callback) {
    // Get the groups that are directly associated to the resource
    getResourceGroupMembers(resourceId, function(err, groups) {
        if (err) {
            return callback(err);
        }

        // Check whether any of these are part of the user's direct memberships
        var groupIds = _.keys(groups);
        if (groupIds.length === 0) {
            return callback(null, []);
        } else {
            // Make sure that the user's memberships have been exploded and cached
            checkGroupMembershipsForUser(principalId, groupIds, function(err, memberships) {
                if (err) {
                    return callback(err);
                }

                // Add the roles of the matching groups
                var allRoles = [];
                for (var m = 0; m < memberships.length; m++) {
                    if (!_.contains(allRoles, groups[memberships[m]])) {
                        allRoles.push(groups[memberships[m]]);
                    }
                }
                return callback(null, allRoles);
            });
        }
    });
};

/**
 * Get all of the groups that are directly associated to a resource.
 *
 * @param  {String}       resourceId      The resource id. This can be a group as well.
 * @param  {Function}     callback        Standard callback function
 * @param  {Object}       callback.err    An error that occurred, if any
 * @param  {Object}       callback.roles  A JSON object where the keys are the group ids of the groups directly associated to the resource and the value is the role of that group
 * @api private
 */
var getResourceGroupMembers = function(resourceId, callback) {
    // Get the groups that are directly associated to the resource
    var start = AuthzConstants.principalTypes.GROUP + ':';
    var end = start + '|';
    Cassandra.runQuery('SELECT ? .. ? FROM AuthzMembers USING CONSISTENCY QUORUM WHERE resourceId = ?', [start, end, resourceId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        // If no groups are associated to the content, we can just return
        var associatedGroups = Cassandra.rowToHash(rows[0]);
        callback(null, associatedGroups);
    });
};

/**
 * Determines whether or not a principal has the specified role directly or indirectly on a given resource.
 *
 * @param  {String}      principalId         The principal id. This can be a user or a group.
 * @param  {String}      resourceId          The resource id. This can be a group as well
 * @param  {String}      role                The role to check
 * @param  {Function}    callback            A function specifying whether or not the user has the role on the resource
 * @param  {Object}      callback.err        An error that occurred, if any
 * @param  {Boolean}     callback.hasRole    Whether or not the principal has the specified role on the resource
 */
var hasRole = module.exports.hasRole = function(principalId, resourceId, role, callback) {
    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'Invalid principal id provided.'}).isPrincipalId();
    validator.check(resourceId, {'code': 400, 'msg': 'Invalid resource id provided.'}).isResourceId();
    validator.check(role, {'code': 400, 'msg': 'Invalid role provided.'}).isValidRole();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _hasRole(principalId, resourceId, role, callback);
};

/**
 * Determines whether or not a principal has any role directly or indirectly on a given resource.
 *
 * @param  {String}      principalId         The principal id. This can be a user or a group.
 * @param  {String}      resourceId          The resource id. This can be a group as well
 * @param  {Function}    callback            A function specifying whether or not the user has the role on the resource
 * @param  {Object}      callback.err        An error that occurred, if any
 * @param  {Boolean}     callback.hasRole    Whether or not the principal has a role on the resource
 */
var hasAnyRole = module.exports.hasAnyRole = function(principalId, resourceId, callback) {
    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'Invalid principal id provided.'}).isPrincipalId();
    validator.check(resourceId, {'code': 400, 'msg': 'Invalid resource id provided.'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _hasRole(principalId, resourceId, null, callback);
};

/**
 * Determines whether or not a principal has the specified role directly or indirectly on a given resource.
 *
 * @param  {String}       principalId         The principal id. This can be a user or a group.
 * @param  {String}       resourceId          The resource id. This can be a group as well
 * @param  {String}       role                The role to check. If the role is null, we check for any role
 * @param  {Function}     callback            A function specifying whether or not the user has the role on the resource
 * @param  {Object}       callback.err        An error that occurred, if any
 * @param  {Boolean}      callback.hasRole    Whether or not the principal has the specified role on the resource
 * @api private
 */
var _hasRole = function(principalId, resourceId, role, callback) {
    // Check for a direct role first
    _getDirectRole(principalId, resourceId, function(err, directRole) {
        if (err) {
            return callback(err);
        } else if (directRole && (role === null || directRole === role)) {
            return callback(null, true);
        }

        // If no direct role assignment is found, we try to find a role through an indirect membership
        _getIndirectRoles(principalId, resourceId, function(err, roles) {
            if (err) {
                return callback(err);
            }

            // If a role is found and we are just looking for any role
            if (roles.length > 0 && role === null) {
                return callback(null, true);
            // If we are looking for a specific role and that specific role is present
            } else if (_.contains(roles, role)) {
                return callback(null, true);
            // If the specified role cannot be found
            } else {
                callback(null, false);
            }
        });
    });
};

/**
 * Assign one or multiple principals a role on a resource instance. If the user already has a role, it will simply be updated. When
 * false is passed in as a role, the role for that principal will be removed.
 *
 * @param  {String}          resourceId      The resource id.
 * @param  {Object}          changes         JSON object where the keys are principal ids and the values are role values
 * @param  {Function}        callback        Standard callback function
 * @param  {Object}          callback.err    Error object, containing the error message
 */
var updateRoles = module.exports.updateRoles = function(resourceId, changes, callback) {
    var validator = new Validator();
    validator.check(resourceId, {'code': 400, 'msg': 'Invalid resource id provided.'}).isResourceId();
    var roleChanges = _.keys(changes);
    validator.check(roleChanges.length, {'code': 400, 'msg': 'At least one role change needs to be applied'}).min(1);
    for (var i = 0; i < roleChanges.length; i++) {
        var principalId = roleChanges[i];
        validator.check(principalId, {'code': 400, 'msg': 'Invalid principal id specified: ' + principalId}).isPrincipalId();
        validator.check(changes[principalId], {'code': 400, 'msg': 'Invalid role provided.'}).isValidRoleChange();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _updateRoles(resourceId, changes, callback);
};

/**
 * Assign multiple principals a role on a resource instance. If the user already has a role, it will simply be updated. When
 * false is passed in as a role, the role for that principal will be removed.
 *
 * @param  {String}        resourceId      The resource id.
 * @param  {Object}        changes         JSON object where the keys are principal ids and the values are role values
 * @param  {Function}      callback        Standard callback function
 * @param  {Object}        callback.err    Error object, containing the error message
 * @api private
 */
var _updateRoles = function(resourceId, changes, callback) {
    var queries = [];
    var roleChanges = _.keys(changes);
    for (var i = 0; i < roleChanges.length; i++) {
        var principalId = roleChanges[i];
        if (changes[principalId]) {
            queries.push({
                'query': 'UPDATE AuthzRoles SET ? = ? WHERE principalId = ?',
                'parameters': [resourceId, changes[principalId], principalId]
            });
            queries.push({
                'query': 'UPDATE AuthzMembers SET ? = ? WHERE resourceId = ?',
                'parameters': [principalId, changes[principalId], resourceId]
            });
        } else if (changes[principalId] === false) {
            queries.push({
                'query': 'DELETE ? FROM AuthzRoles WHERE principalId = ?',
                'parameters': [resourceId, principalId]
            });
            queries.push({
                'query': 'DELETE ? FROM AuthzMembers WHERE resourceId = ?',
                'parameters': [principalId, resourceId]
            });
        } else {
            return callback({'code': 400, 'msg': 'An invalid role has been passed in (undefined)'});
        }
    }
    // Invalidate the AuthzMembershipsCache row for each user who's role has just changed and for all of the users that
    // are members of the groups for which the roles have just been changed. We only want to do this when a group
    // memberships are being updated. There's no need to do it when a content membership is updated
    if (AuthzUtil.isGroupId(resourceId)) {
        // Collect the userids that need invalidating
        var invalidatedUsers = [];
        // Collect the groups for which the members need to be invalidated
        var groupsToInvalidate = [];
        // Keep track of the groups that we've already invalidated as we walk through deep membership
        var invalidatedGroups = [resourceId];

        var changeKeys = _.keys(changes);
        for (var c = 0; c < changeKeys.length; c++) {
            // Just invalidate the user
            if (AuthzUtil.isUserId(changeKeys[c])) {
                invalidatedUsers.push(changeKeys[c]);
                queries.push({
                    'query': 'DELETE FROM AuthzMembershipsCache WHERE principalId = ?',
                    'parameters': [changeKeys[c]]
                });
            // Queue the group to invalidate all of its members
            } else if (AuthzUtil.isGroupId(changeKeys[c])) {
                groupsToInvalidate.push(changeKeys[c]);
            }
        }

        var invalidateGroupMembers = function() {
            if (groupsToInvalidate.length === 0) {
                Cassandra.runBatchQuery(queries, 'QUORUM', callback);
            } else {
                var groupId = groupsToInvalidate.shift();
                // Get all of the members of the group, so they can be invalidated
                getAuthzMembers(groupId, null, 10000, function(err, members) {
                    if (err) {
                        return callback(err);
                    }

                    for (var i = 0; i < members.length; i++) {
                        var memberId = members[i].id;
                        // The members can be invalidated
                        if (AuthzUtil.isUserId(memberId) && !_.contains(invalidatedUsers, memberId)) {
                            invalidatedUsers.push(memberId);
                            queries.push({
                                'query': 'DELETE FROM AuthzMembershipsCache WHERE principalId = ?',
                                'parameters': [memberId]
                            });
                        // Group members need to be further exploded. In order to do this, we need to check whether or not the list
                        // of groups that have already been invalidated and the list of groups that are queued up to be invalidated
                        // don't contain this group, otherwise we'll invalidate the group twice.
                        } else if (AuthzUtil.isGroupId(memberId) && !_.contains(invalidatedGroups, memberId) && !_.contains(groupsToInvalidate, memberId)) {
                            groupsToInvalidate.push(memberId);
                            invalidatedGroups.push(memberId);
                        }
                    }
                    invalidateGroupMembers();
                });
            }
        };

        // Get all of the members of the current group
        invalidateGroupMembers();

    } else {
        Cassandra.runBatchQuery(queries, 'QUORUM', callback);
    }
};


///////////////////
// AUTHZ MEMBERS //
///////////////////

/**
 * Get all the direct members of a resource and their role on the resource.
 *
 * @param  {String}      resourceId              A unique identifier for a resource. ex: g:cam-oae-team or c:cam:XCDSasD
 * @param  {String}      start                   The principal id that comes just before the first principal you wish to have in your results.
 * @param  {Number}      limit                   The number of members you wish to retrieve.
 * @param  {Function}    callback                Standard callback function
 * @param  {Object}      callback.err            An error that occurred, if any
 * @param  {Object[]}    callback.members        Array of objects for each of the direct member of the resource. Each object has an 'id' key containing the principal id of the member and a 'role' key containing the role of that principal
 * @param  {String}      callback.nextToken      The value to provide in the `start` parameter to get the next set of results
 */
var getAuthzMembers = module.exports.getAuthzMembers = function(resourceId, start, limit, callback) {
    limit = limit || 10;

    var validator = new Validator();
    validator.check(resourceId, {'code': 400, 'msg': 'Invalid resource id provided'}).isResourceId();
    validator.check(limit, {'code': 400, 'msg': 'The limit parameter needs to be a number'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var members = [];
    Cassandra.runPagedColumnQuery('AuthzMembers', 'resourceId', resourceId, start, limit, null, function(err, row, nextToken) {
        if (err) {
            return callback(err);
        }

        row.forEach(function(name, value) {
            members.push({'id': name, 'role': value});
        });

        return callback(null, members, nextToken);
    });
};

/**
 * Given a list of groups, we check if a user is a direct or indirect member of any of these. This is done by first checking whether or
 * not the user's membership list has been exploded. If so, we do a direct match against that exploded list. If the user's memberships
 * have not yet been exploded, we explode the user's memberships, do a direct match against the retrieved list and then cache the exploded
 * list
 *
 * @param  {String}      userId                 Id of the user for which we're checking whether or not he is a member of a set of groups
 * @param  {String[]}    groupIds               Array of group ids for which we're checking if the user is a member
 * @param  {Function}    callback               Standard callback function
 * @param  {Object}      callback.err           An error that occurred, if any
 * @param  {String[]}    callback.memberships   Array of group ids containing all the groups from the provided list that the user is a member of
 * @api private
 */
var checkGroupMembershipsForUser = function(userId, groupIds, callback) {
    // Check if the exploded list is there
    Cassandra.runQuery('SELECT FIRST 2 * FROM AuthzMembershipsCache USING CONSISTENCY QUORUM WHERE principalId = ?', [userId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        // There are columns in the exploded row
        if (rows[0].count > 1) {
            Cassandra.runQuery('SELECT ? FROM AuthzMembershipsCache USING CONSISTENCY QUORUM WHERE principalId = ?', [groupIds, userId], function(err, rows) {
                if (err) {
                    return callback(err);
                }

                // Return the matching groups
                var memberships = Cassandra.rowToHash(rows[0]);
                return callback(null, _.keys(memberships));
            });
        // There are no columns, we need to explode the user's group memberships
        } else {
            explodeGroupMemberships(userId, function(err, allMemberships) {
                if (err) {
                    return callback(err);
                }

                // Return the matching groups
                var memberships = _.intersection(groupIds, allMemberships);
                return callback(null, memberships);
            });
        }
    });
};

/**
 * Get all the Authz groups of which a principal is a member. This includes all group ancestors to which the user is indirectly a member.
 * Once these have been retrieved, they will be cached inside of Cassandra for fast permission checks
 *
 * @param  {String}      principalId                 Principal id for who we want to explode the group memberships
 * @param  {Function}    callback                    Standard callback function
 * @param  {Object}      callback.err                An error that occurred, if any
 * @param  {String[]}    callback.memberships        Array of group ids that represents the full list of direct and indirect memberships for the provided principal
 * @api private
 */
var explodeGroupMemberships = function(principalId, callback) {
    // Get the full exploded membership list for the user
    _getAuthzGroupMembershipAncestry(principalId, function(err, memberships) {
        if (err) {
            return callback(err);
        }
        // Publish the memberships into Cassandra
        if (_.keys(memberships).length > 0) {
            var publishMemberships = Cassandra.constructUpsertCQL('AuthzMembershipsCache', 'principalId', principalId, memberships, 'QUORUM');
            Cassandra.runQuery(publishMemberships.query, publishMemberships.parameters, function(err) {
                if (err) {
                    return callback(err);
                }
                callback(null, _.keys(memberships));
            });
        } else {
            callback(null, []);
        }
    });
};

/**
 * Gets all the Authz groups of which a principal (either user or group) is a member. This includes all group ancestors to
 * which the user is indirectly a member.
 *
 * @param  {String}         principalId         The principal id for which to retrieve all the group memberships
 * @param  {String}         start               Determines the point at which group memberships members are returned for paging purposes.  If not provided, the first x elements will be returned
 * @param  {Integer}        limit               Number of group memberships to return. Will default to 10 if not provided
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occured, if any
 * @param  {String[]}       callback.groups     An array of group ids representing the groups to which the user belongs, either directly or indirectly
 * @param  {String}         callback.nextToken  The value to provide in the `start` parameter to get the next set of results
 */
var getPrincipalMemberships = module.exports.getPrincipalMemberships = function(principalId, start, limit, callback) {
    limit = limit || 10;

    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'Invalid principal id provided'}).isPrincipalId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    Cassandra.runPagedColumnQuery('AuthzMembershipsCache', 'principalId', principalId, start, limit, null, function(err, row, nextToken, startMatched) {
        if (err) {
            return callback(err);
        }

        var memberships = [];
        if (row.count > 0 || startMatched) {
            // If we retrieved columns or the start matched a column exactly, then we know we had a cache hit
            row.forEach(function(name) {
                memberships.push(name);
            });

            return callback(null, memberships, nextToken);
        } else {
            explodeGroupMemberships(principalId, function(err, allMemberships) {
                if (err) {
                    return callback(err);
                }

                var startIndex = 0;
                if (start) {
                    // We don't want to include the start element, so pick the next element as the start
                    startIndex = _.indexOf(allMemberships, start) + 1;
                }
                var memberships = allMemberships.slice(startIndex, startIndex + limit);

                // Since we're getting the full memberships list, we need to recalculate the nextToken
                nextToken = null;
                if (memberships.length === limit && memberships.length > 0) {
                    nextToken = memberships[memberships.length - 1];
                }
                return callback(null, memberships, nextToken);
            });
        }
    });
};

/**
 * Given some principal, get their entire group membership ancestry. In other words, get all the groups to which they belong,
 * and the groups to all those groups belong, and so on.
 *
 * @param  {String}        principalId         The principal id for which to retrieve the authz group membership ancestry
 * @param  {Function}      callback            Standard callback function
 * @param  {Object}        callback.err        The err that occured, if any
 * @param  {Object}        callback.ancestry   A hash keyed by the group id of each group of which the user is indirectly a member. The value of each entry is `true`.
 * @api private
 */
var _getAuthzGroupMembershipAncestry = function(principalId, callback) {
    var results = {};

    var _multiGetAuthzGroupMembershipAncestry = function(principalIds, results) {
        getRolesForPrincipalsAndResourceType(principalIds, AuthzConstants.resourceTypes.GROUP, 10000, function(err, entries) {
            if (err) {
                return callback(err);
            }

            var nextPrincipalBatch = [];
            var ancestors = _.keys(entries);
            // for each group parent, determine if we've already recorded their membership. if not, we record it, and search it's parents
            for (var i = 0; i < ancestors.length; i++) {
                var ancestorId = ancestors[i];
                if (!results[ancestorId]) {
                    results[ancestorId] = true;
                    nextPrincipalBatch.push(ancestorId);
                }
            }

            // if we found new ancestors, we need to recurse to find their ancestors. Otherwise we're done.
            if (nextPrincipalBatch.length > 0) {
                return _multiGetAuthzGroupMembershipAncestry(nextPrincipalBatch, results);
            } else {
                return callback(null, results);
            }
        });
    };

    _multiGetAuthzGroupMembershipAncestry([principalId], results, callback);
};

/**
 * Get all principal roles associated to the resourceType for all the principals in the array of principal ids. This can be performed on
 * multiple principals at once.
 *
 * The structure of the resulting entries is structured a hash, indicating all resource ids that were returned and what the
 * roles associated to those resources were. For example:
 *
 *     {
 *      'u:cam:simong': { 'member': true },
 *      'g:cam:group-b': { 'member': true }
 *     }
 *
 * or:
 *
 *     {
 *      'c:gat:Foo.docx': { 'viewer': true, 'manager': true},
 *      'c:cam:Bar.pdf':  { 'viewer': true }
 *     }
 *
 * In the latter case, 'c:gat:Foo.docx' has both 'viewer' and 'manager' role associated to it. This indicates that some principal
 * had a role of 'viewer' on the resource, while some other principal had the 'manager' role.
 *
 * @param  {Array}          principalIds        The array of principal ids to query for
 * @param  {String}         resourceType        The resource type of the resources to search for, as determined by Resource.resourceType
 * @param  {Number}         limit               The maximum number of resources to return per user
 * @param  {Function}       callback            A function providing all the {resource id} -> {roles} mappings aggregated for all the provided principals queried
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Object}         callback.entries    A JSON Object representing the roles associated to the users
 */
var getRolesForPrincipalsAndResourceType = module.exports.getRolesForPrincipalsAndResourceType = function(principalIds, resourceType, limit, callback) {
    limit = limit || 1000;
    principalIds = principalIds || [];

    var validator = new Validator();
    validator.check(limit, {'code': 400, 'msg': '"limit" parameter must be a number when searching for active roles'});
    validator.check(resourceType, {'code': 400, 'msg': 'A resourceType needs to be provided'}).notEmpty();
    validator.check(principalIds.length, {'code': 400, 'msg': 'At least one principal Id needs to be passed in'}).min(1);
    for (var i = 0; i < principalIds.length; i++) {
        var principalId = principalIds[i];
        validator.check(principalId, {'code': 400, 'msg': 'Invalid principal id specified: ' + principalId}).isPrincipalId();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // we append a '|' to the "end" range, as | has a high ASCII alphabetical ordering. This may not suffice if resourceIds have
    // multi-byte characters, which is technically possible. Unfortunately, I don't think there is a better way to do this with
    // CQL.
    var start = resourceType + ':';
    var end = start + '|';

    var cql = 'SELECT FIRST ' + limit + ' ? .. ? FROM AuthzRoles USING CONSISTENCY QUORUM WHERE principalId IN (?)';
    Cassandra.runQuery(cql, [start, end, principalIds], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var entries = {};

        // Aggregate all resources from all the rows (principals) into the entries hash
        var expandRow = function(name, value) {
            if (!entries[name]) {
                entries[name] = {};
            }
            entries[name][value] = true;
        };
        for (var i = 0; i < rows.length; i++) {
            rows[i].forEach(expandRow);
        }

        callback(null, entries);
    });
};

/**
 * Determine what the membership of a resource would be after applying the specified permission changes to it.
 *
 * @param  {String}     resourceId              The id of the resource to check
 * @param  {Object}     permissionChanges       An object that describes the permission changes to apply to the resource. The key is the id of the principal to which to apply the change, and the value is the role to apply to the principal. If the value is `false`, the principal will be revoked access.
 * @param  {Function}   callback                Invoked when the test is complete
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Object}     callback.permissions    An object that describes the permissions on the resource after the changes have been applied. The key is the id of the principal, and the value is the role of the principal
 * @param  {String[]}   callback.newMembers     The principal ids that would be new members to the resource
 * @param  {String[]}   callback.updateMembers  The principal ids whose role existed before and will change
 * @param  {String[]}   callback.removedMembers The principal ids whose role existed before and will be removed
 * @api private
 */
var computeMembershipAfterChanges = module.exports.computeMembershipAfterChanges = function(resourceId, permissionChanges, callback) {
    getAuthzMembers(resourceId, null, 10000, function(err, memberIdsWithRolesArray) {
        if (err) {
            return callback(err);
        }

        // Turn the id->role array into a hash, we don't care about order
        var memberIdsWithRoles = {};
        _.each(memberIdsWithRolesArray, function(memberIdWithRole) {
            memberIdsWithRoles[memberIdWithRole.id] = memberIdWithRole.role;
        });

        var newMembers = [];
        var updatedMembers = [];
        var removedMembers = [];

        // Apply all of the permission changes in-memory
        _.each(permissionChanges, function(change, memberId) {
            if (change === false) {
                if (memberIdsWithRoles[memberId]) {
                    // The member `memberId` will be removed
                    delete memberIdsWithRoles[memberId];
                    removedMembers.push(memberId);
                }
            } else {
                if (memberIdsWithRoles[memberId] && memberIdsWithRoles[memberId] !== change) {
                    // The member `memberId` will have a changed role
                    memberIdsWithRoles[memberId] = change;
                    updatedMembers.push(memberId);
                } else if (!memberIdsWithRoles[memberId]) {
                    // The member `memberId` will be added to the item
                    memberIdsWithRoles[memberId] = change;
                    newMembers.push(memberId);
                } else {
                    // This situation is where either a non-member user was removed, or a member was specified with a role
                    // they already had. This is intentionally left empty.
                }
            }
        });

        return callback(null, memberIdsWithRoles, newMembers, updatedMembers, removedMembers);
    });
};

/**
 * Determine the **effective** role a user has in a resource. Though a user can have multiple roles on a resource
 * by virtue of indirect group membership, this determines the highest level of access granted. This check is not only
 * implicit, but includes explicit role membership lookup. Therefore, its output alone can be used as an authoritative
 * source of access information.
 *
 * @param  {Context}    ctx                     The context of the user to check for access
 * @param  {String}     resourceId              The id of the resource against which to check for access
 * @param  {String}     resourceTenantAlias     The tenant alias of tenant to which the resource belongs
 * @param  {String}     resourceVisibility      The visibility of the target resource. One of public, loggedin or private
 * @param  {String[]}   rolesPriority           An array of roles expressing the ordering of roles in order of least powerful to most powerful
 * @param  {Function}   callback                Invoked when the process completes
 * @param  {Object}     callback.err            An error that occured, if any
 * @param  {String}     callback.effectiveRole  The effective role of the user in context, as determined by the rolesPriority
 * @param  {Boolean}    callback.canInteract    Whether or not the user can interact
 * @api private
 */
var resolveEffectiveRole = module.exports.resolveEffectiveRole = function(ctx, resourceId, resourceTenantAlias, resourceVisibility, rolesPriority, callback) {
    var user = ctx.user();

    resolveImplicitRole(ctx, resourceTenantAlias, resourceVisibility, rolesPriority, function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (implicitRole === rolesPriority[rolesPriority.length - 1]) {
            // We already have the highest role, use it
            return callback(null, implicitRole, canInteract);
        } else if (!user) {
            // We are anonymous so cannot have any explicit access or interact. Use only our implicitRole if we have one
            return callback(null, implicitRole, canInteract);
        }

        // If the target resource is actually a user, the only "explicit role" we can have on a user is to actually *be* that user, in which case we
        // actually have the maximum access allowed. Otherwise, since you can't have a role on a user, we simply use the implicit access of the user
        // as the result
        if (AuthzUtil.isUserId(resourceId)) {
            if (user.id === resourceId) {
                return callback(null, rolesPriority[rolesPriority.length - 1], true);
            } else {
                return callback(null, implicitRole, canInteract);
            }
        }

        // If we get here, it would be prudent to check if this user has granted access to the target resource
        getAllRoles(user.id, resourceId, function(err, roles) {
            if (err) {
                return callback(err);
            } else if (roles.length === 0) {
                // We have no explicit role, so we fall back to the implicit access
                return callback(null, implicitRole, canInteract);
            }

            // The resolved role is the one at the highest index of the passed in rolesPriority array.
            var highestIndex = _.indexOf(rolesPriority, implicitRole);
            _.each(roles, function(role) {
                highestIndex = Math.max(highestIndex, _.indexOf(rolesPriority, role));
            });

            // The `canInteract` parameter is true because we can always interact if we have an explicit role
            return callback(null, rolesPriority[highestIndex], true);
        });
    });
};

/**
 * Determine the highest **implicit** role that the user in context has on a resource. Implicit means that the
 * user is granted access based on simple privacy / visibility / tenant rules associated to the context. Some
 * examples:
 *  (In all examples the rolesPriority is defined as ['viewer', 'manager'])
 *
 *  *   If the user in context is an admin, they will implicitly have manager access of the resource, even if they
 *      don't have an explicit manager role membership on the resource;
 *  *   If the resource has visibility "public", all contexts (anonymous or authenticated) have implicit "viewer"
 *      role on a resource
 *  *   If the resource has visibility "private", no user context (except administrator) can have implicit "viewer"
 *      as that can only be determined through an **explicit** role check
 *
 * Therefore, the output from this call is the **minimum** effective permissions the current context has on a resource,
 * since there is no concept of a "deny" permission. If this method returns that there is no implicit role, it is still
 * possible that the user has been explicitly granted a membership role. If this method returns that there is an implicit
 * "viewer" role, it is possible that the user has been explicitly granted a role of "manager".
 *
 * The `canInteract` determines if the user can implicitly "interact" with the resource through potential tenant privacy
 * boundaries (e.g., share it, add it to their library, post a message on it). Like `implicitRole`, it is also a minimal
 * implicit check. So if this results in `false`, it is still possible that a user has an explicit manager role on the
 * resource which grants it ability to interact.
 *
 * To get a context's explicit effective role, please use #resolveEffectiveRole instead.
 *
 * @param  {User}       user                    The user for which to resolve the implicit role
 * @param  {String}     resourceTenantAlias     The tenant alias for the resource that is being accessed
 * @param  {String}     resourceVisibility      The visibility for the resource that is being accessed
 * @param  {String[]}   rolesPriority           An array of roles expressing the ordering of roles in order of least powerful to most powerful
 * @param  {Function}   callback                Invoked when the process completes
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {String}     callback.implicitRole   The implicit (minimum) role the user in context has on the resource. An anonymous user has no role.
 * @param  {Boolean}    callback.canInteract    Determines whether or not the user in context can implicitly interact with the resource
 */
var resolveImplicitRole = module.exports.resolveImplicitRole = function(ctx, resourceTenantAlias, resourceVisibility, rolesPriority, callback) {
    var user = ctx.user();

    // Anonymous cannot interact with anything and get the lowest role if the resource visibility is set to public.
    // Otherwise, they do not get a role.
    if (!user) {
        var implicitRole = null;
        if (resourceVisibility === AuthzConstants.visibility.PUBLIC) {
            implicitRole = rolesPriority[0];
        }
        return callback(null, implicitRole, false);

    // Check admin access
    } else if (user.isGlobalAdmin() || user.isTenantAdmin(resourceTenantAlias)) {
        // The user is an administrator, give them the highest allowable access
        return callback(null, rolesPriority[rolesPriority.length - 1], true);
    }

    // Determine the implicit interaction capabilities between the user and the resource
    var actorTenantAlias = (user) ? user.tenant.alias : ctx.tenant().alias;
    var canInteract = TenantsUtil.canInteract(actorTenantAlias, resourceTenantAlias);

    // Check implicit member access
    if (resourceVisibility === AuthzConstants.visibility.PUBLIC) {
        // Public resources can be seen by anyone
        return callback(null, rolesPriority[0], canInteract);
    } else if (resourceVisibility === AuthzConstants.visibility.LOGGEDIN && TenantsUtil.isLoggedIn(ctx, resourceTenantAlias)) {
        // We are from the same tenant as the "loggedin" resource, so we can view it and interact
        return callback(null, rolesPriority[0], canInteract);
    }

    return callback();
};

/**
 * Checks if:
 *  * the current user's tenant and the tenant where the resource originated from can interact.
 *  * the current user can interact with any of the provided principals.
 *     - Each principal their visibility setting is taken into account
 *
 *
 * @param  {Context}    ctx                             The context of the current request
 * @param  {String}     resourceTenantAlias             The tenant alias of the resource the user is performaning an action upon.
 * @param  {String[]}   principalIds                    The principalIds with which the user wishes to interact with
 * @param  {Function}   callback                        Invoked when the process completes
 * @param  {Object}     callback.err                    An error that occurred, if any
 * @param  {Boolean}    callback.canInteract           `true` if the user in context is allowed to perform this operation. `false` otherwise
 * @param  {String[]}   [callback.illegalPrincipalIds]  If the check failed because of a tenant boundary violation, this will be an array of principalIds that were in violation
 */
var canInteract = module.exports.canInteract = function(ctx, resourceTenantAlias, principalIds, callback) {
    var actorTenantAlias = ctx.user().tenant.alias;

    // Check the tenant violations:
    //  * A direct violation between actorTenantAlias and resourceTenantAlias
    if (!TenantsUtil.canInteract(actorTenantAlias, resourceTenantAlias)) {
        return callback(null, false);
    }

    //  * A direct violation between actorTenantAlias and principalIds[i].tenant
    var illegalPrincipalIds =  _.filter(principalIds, function(principalId) {
        var principalTenantAlias = AuthzUtil.getPrincipalFromId(principalId).tenantAlias;
        // The principalId is invalid if the violates boundaries between the actor and the principal or the resource and the principal
        return (!TenantsUtil.canInteract(actorTenantAlias, principalTenantAlias) || !TenantsUtil.canInteract(resourceTenantAlias, principalTenantAlias));
    });
    if (illegalPrincipalIds.length > 0) {
        return callback(null, false, illegalPrincipalIds);
    }


    // Now check if there are any access violations between the actor and a principal
    PrincipalsUtil.getPrincipals(ctx, principalIds, function(err, principalObjects) {
        if (err) {
            return callback(err);
        }

        var illegalPrincipalIds = [];
        var canInteract = true;

        /*!
         * Checks if the current user can interact with al the
         * principals in an array (recursively).
         *
         * @param  {Principal[]}  The array of principals to check. Will be empty when done.
         */
        var checkPrincipal = function(principals) {
            if (principals.length === 0) {
                // All the principals have been checked.
                // Only fill in the illegalPrincipalIds parameter if there are actually any illegal ones.
                return callback(null, canInteract, (illegalPrincipalIds.length > 0) ? illegalPrincipalIds : null);
            }

            var principal = principals.pop();

            // If the target-principal is a user we need to check tenant permeability and user visibility settings.
            // The resolveImplicitRole function will take care of that.
            if (PrincipalsUtil.isUser(principal.id)) {
                resolveImplicitRole(ctx, principal.tenant.alias, principal.visibility, ['viewer', 'manager'], function(err, implicitRole, canInteractWithUser) {
                    if (err) {
                        return callback(err);
                    }

                    if (!canInteractWithUser) {
                        canInteract = false;
                        illegalPrincipalIds.push(principal.id);
                    }

                    // Move on to the next principal.
                    checkPrincipal(principals);
                });

            // If the target-principal is a group we need to check if the current user can view that group and tenant interactions are allowed.
            // In case the group is not public we'd need to determine our role on that group, re-using resolveEffectiveRole will
            // make sure we can interact with the group and we have a role on it if necessary.
            } else {
                resolveEffectiveRole(ctx, principal.id, principal.tenant.alias, principal.visibility, ['viewer', 'manager'], function(err, effectiveRole, canInteractWithGroup) {
                    if (err) {
                        return callback(err);
                    }

                    if (!canInteractWithGroup) {
                        canInteract = false;
                        illegalPrincipalIds.push(principal.id);
                    }

                    // Move on to the next principal.
                    checkPrincipal(principals);
                });
            }
        };

        var principals = _.values(principalObjects);
        checkPrincipal(principals);
    });
};
