var OAE = require('oae-util/lib/OAE');

/**
 * Determine the role of the principal on the specified resource instance.
 * 
 * @param {String} principalUuid the UUID of the principal
 * @param {String} The UUID of the resource
 * @param {Function} callback A function(role, err) specifying the role of the principal. If the principal
 * has no role or there is an error performing the check, role will be null
 **/
var getRole = module.exports.getRole = function(principalUuid, resourceUuid, callback) {
    var cql = 'select ? from Role where principal = ?';
    OAE.runQuery(cql, [resourceUuid, principalUuid], function(err, rows) {
        if (!err) {
            var value = rows[0].colHash[resourceUuid];
            if (value) {
                callback(value);
            } else {
                callback(null);
            }
        } else {
            callback(null, err);
        }
    });
}

/**
 * Determines whether or not the principal has the specified role on the given resource.
 * 
 * @param {String} principalUuid The UUID of the princpals
 * @param {String} resourceUuid The UUID of the resource
 * @param {String} role The role to check
 * @param {Function} callback A function(hasRole, err) specifying whether or not the user has the role on the resource
 */
var hasRole = module.exports.hasRole = function(principalUuid, resourceUuid, role, callback) {
    getRole(principalUuid, resourceUuid, function(actualRole, err) {
        if (!err) {
            callback(role === actualRole);
        } else {
            callback(false, err);
        }
    });
};


/**
 * Given an resourceType (as determined by Resource.resourceType), return all {resource uuid} => {role} entries that are
 * associated to the principal. The structure of the entries result looks like the following:
 * 
 * [
 *   {
 *      "uuid": "<resource uuid 1>",
 *      "role": "<role 1>"
 *    },
 *    {
 *      "uuid": "<resource uuid 2>"
 *      "role": "<role 2>"
 *    }
 * ]
 * 
 * @param {String} principalUuid The UUID of the principal
 * @param {String} resourceType The resource type to search, as determined by Resource.resourceType
 * @param {String} start The starting entry on which to begin returning results (used for paging). **This is not a number**. If null, then the results will simply begin from the start. If the resource uuid is provided, then results will begin from that resource's location, exclusively.
 * @param {Number} limit The maximum number of entries to return (used for paging; default: 10)
 * @param {Function} callback A function(entries, err), providing the list of role entries that match the search
 */
var getRolesForResourceType = module.exports.getRolesForResourceType = function(principalUuid, resourceType, start, limit, callback) {
    if (limit && isNaN(limit)) {
        callback(null, {why: '"limit" parameter must be a number when searching for active roles'});
        return;
    } else if (!limit) {
        limit = 10;
    } 

    var firstColumnIndex = 0;
    var columnPrefix = resourceType+':';

    if (start === null) {
        start = columnPrefix;    
    } else {
        // increment the limit if the user specified the start point, because we skip the first entry to get the EXCLUSIVE
        // page range
        limit++;
        firstColumnIndex = 1;
    }

    var cql = 'select first '+limit+' ? .. \'\' from Role where principal = ?';
    OAE.runQuery(cql, [start, principalUuid], function(err, rows) {
        if (!err) {
            var entries = [];
            for (var i = firstColumnIndex; i < rows[0]._colCount; i++) {
                var col = rows[0].cols[i];

                // prevents us from overflowing into other resource types
                if (col.name.indexOf(columnPrefix) !== 0) {
                    break;
                }

                entries.push({ 'uuid': col.name, 'role': col.value });
            }
            callback(entries);
        } else {
            callback(null, err);
        }
    });
};

/**
 * Assign the given principal a role on a resource instance. If the user already has a role, it will simply be updated.
 * 
 * @param {String} principalUuid The UUID of the principal
 * @param {String} resourceUuid the UUID of the resource
 * @param {String} role The role to assign to the principal
 * @param {Function} callback A function(err) specifying whether or not the operation was successful
 */
module.exports.setRole = function(principalUuid, resourceUuid, role, callback) {
    var cql = 'update Role set ? = ? where principal = ?';
    OAE.runQuery(cql, [resourceUuid, role, principalUuid], callback);
};

/**
 * Remove the role assignment of the given principal on an resource instance. If the user did not have a role, this will
 * have no effect.
 * 
 * @param {String} principalUuid The UUID of the principal
 * @param {String} resourceUuid The UUID of the resource
 * @param {Function} callback A function(err) specifying whether or not the operation was successful
 */
module.exports.removeRole = function(principalUuid, resourceUuid, callback) {
    var cql = 'delete ? from Role where principal = ?';
    OAE.runQuery(cql, [resourceUuid, principalUuid], callback);
};

/**
 * Get all principal associations to the resourceType for all the principals in the array of principalUuids. This is similar
 * to getRolesForResourceType, except it can be performed on multiple principals at once.
 * 
 * The structure of the resulting entries is simply a hash, indicating all resourceUuids that were returned. For example:
 *
 * {
 *   'g:cam:group-a': true,
 *   'g:cam:group-b': true
 * }
 *
 * The role is not returned to avoid a misleading anomaly where different principals were associated to the same resource in different
 * roles. In which case, the role associated to the resource is rather unpredictable. If you need to get specific roles,
 * consider using getRolesForResourceType instead.
 *
 * @param {Array} principalUuids The array of principalUuds to query for
 * @param {String} resourceType The resource type of the resources to search for, as determined by Resource.resourceType
 * @param {Number} limit The maximum number of resources to return per user
 * @param {Function} callback A function(entries, err) providing all the {resource uuid} -> {role} mappings aggregated
 * for all the provided principals queried
 *
 * @see getRolesForResourceType
 */
module.exports.getAssociationsForPrincipalsAndResourceType = function(principalUuids, resourceType, limit, callback) {
    if (isNaN(limit)) {
        callback(null, {why: '"limit" parameter must be a number when searching for active roles'});
        return;
    }

    // we append a '|' to the "end" range, as | has a high ASCII alphabetical ordering. This may not suffice if resourceIds have
    // multi-byte characters, which is technically possible. Unfortunately, I don't think there is a better way to do this with
    // CQL.
    var columnPrefix = resourceType+':';
    var start = columnPrefix;
    var end = start+'|';

    var cql = 'select first '+limit+' ? .. ? from Role where principal in (?)';
    OAE.runQuery(cql, [start, end, principalUuids], function(err, rows) {
        if (!err) {
            var entries = {};

            // aggregate all resources from all the rows (principals) into the entries hash
            for (var r = 0; r < rows.rowCount(); r++) {
                var row = rows[r];
                for (var c = 0; c < row._colCount; c++) {
                    var col = row.cols[c];
                    entries[col.name] = true;
                }
            }
            
            callback(entries);
        } else {
            callback(null, err);
        }
    });
};

