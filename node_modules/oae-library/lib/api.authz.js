/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzUtil = require('oae-authz/lib/util');
var PrincipalsGroupAPI = require('oae-principals/lib/api.group');
var PrincipalsUtil = require('oae-principals/lib/util');
var TenantsUtil = require('oae-tenants/lib/util');

/**
 * Determine which visibility level of library the user in context should receive from the target library owner. The following
 * table presents a visibility matrix of how a feed would be issued for a group.
 *
 * Assume that Tenant A and B both have enabled tenant permeability and Tenant C has it disabled. The column headers defined the
 * status of the current user (whether he is anonymous, an authenticated user or if he's a member), the rows express the
 * visibility setting of the library owner. Each cell will then express which library stream should be returned. A `/` means
 * the user does not have access to the library
 *
 *
 *                ||                Public Tenant A                  ||                 Public Tenant B                ||      Private Tenant C
 *                ||     Anon    |   Loggedin user   |   Member      ||      Anon    |   Loggedin user   |   Member    ||      Anon    |   Loggedin user   |   Member
 * ------------------------------------------------------------------------------------------------------------------- -------------------------------------------------
 * public group   ||     public  |     logged in     |  private      ||     public   |      public       |   private   ||     public   |      public           private
 *                ||             |                                   ||              |                   |             ||              |
 * loggedin group ||       /     |     logged in     |  private      ||        /     |        /          |   private   ||        /     |        /              private
 *                ||             |                                   ||              |                   |             ||              |
 * private group  ||       /     |        /          |  private      ||        /     |        /          |   private   ||        /     |        /              private
 *
 *
 * @param  {Context}    ctx                     The context of the current request
 * @param  {String}     libraryOwnerId          The authz id of the owner of the library
 * @param  {String}     libraryOwnerVisibility  The visibility of the owner of the library
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Boolean}    callback.hasAccess      A boolean flag that expresses whether the current user has access to the library
 * @param  {String}     callback.visibility     The best visibility (as enumerated in `AuthzConstants.visibility`) of library the user in context can see from the target library owner. If the user has no access, this value will be falsey
 */
var resolveTargetLibraryAccess = module.exports.resolveTargetLibraryAccess = function(ctx, libraryOwnerId, libraryOwnerVisibility, callback) {
    var libraryTenantAlias = AuthzUtil.getResourceFromId(libraryOwnerId).tenantAlias;

    // Admin users always get private libraries
    if (ctx.user() && (ctx.user().isGlobalAdmin() || ctx.user().isTenantAdmin(libraryTenantAlias))) {
        return callback(null, true, AuthzConstants.visibility.PRIVATE);
    }

    // User is not an admin of the target library tenant, so we'll have to do some acrobatics to resolve the visibility
    // Check if we are looking at a user library
    if (PrincipalsUtil.isUser(libraryOwnerId)) {
        // If the current user is requesting his own library we can return the private stream
        if (ctx.user() && ctx.user().id === libraryOwnerId) {
            return callback(null, true, AuthzConstants.visibility.PRIVATE);

        // A non-library owner is requesting the library, we first need to check the owner's visibility setting
        } else if (libraryOwnerVisibility === AuthzConstants.visibility.PRIVATE || (libraryOwnerVisibility === AuthzConstants.visibility.LOGGEDIN && !TenantsUtil.isLoggedIn(ctx, libraryTenantAlias))) {
            return callback(null, false);

        // We give the user the public stream in case the user is not logged in to the user's tenant
        } else if (!TenantsUtil.isLoggedIn(ctx, libraryTenantAlias)) {
            return callback(null, true, AuthzConstants.visibility.PUBLIC);

        // We give the user the logged in stream in case the current user is not the same as the library we're looking at
        } else if (ctx.user().id !== libraryOwnerId) {
            return callback(null, true, AuthzConstants.visibility.LOGGEDIN);
        }

    // If we are looking at another library, we can take into consideration explicit access
    } else {
        // Anonymous user can only access the public stream if the group has been set to public
        if (!ctx.user()) {
            if (libraryOwnerVisibility === AuthzConstants.visibility.PUBLIC) {
                return callback(null, true, AuthzConstants.visibility.PUBLIC);
            } else {
                return callback(null, false);
            }
        }

        // We've established that the user is logged in, so we'll need to determine the role the user has in the group so we
        // can show the correct library
        AuthzAPI.hasAnyRole(ctx.user().id, libraryOwnerId, function(err, hasAnyRole) {
            if (err) {
                return callback(err);
            }

            if (hasAnyRole) {
                return callback(null, true, AuthzConstants.visibility.PRIVATE);
            } else if (!TenantsUtil.isLoggedIn(ctx, libraryTenantAlias)) {
                if (libraryOwnerVisibility === AuthzConstants.visibility.PUBLIC) {
                    return callback(null, true, AuthzConstants.visibility.PUBLIC);
                } else {
                    return callback(null, false);
                }
            } else if (libraryOwnerVisibility === AuthzConstants.visibility.PRIVATE) {
                return callback(null, false);
            } else {
                return callback(null, true, AuthzConstants.visibility.LOGGEDIN);
            }
        });
    }
};

/**
 * Determine for a resource, which library visibility levels in which it should be inserted for the each of the given list
 * of library owners.
 *
 * @param  {String[]}   libraryOwnerIds         The ids of the library owners for which to resolve the library visibilities
 * @param  {Object}     resource                The resource to be inserted into the libraries (e.g., discussion, content)
 * @param  {String}     resource.visibility     The resource visibility (e.g., public, private, loggedin)
 * @param  {Object}     resource.tenant         The light-weight tenant object of the resource to which the resource belongs
 * @param  {String}     resource.tenant.alias   The alias of the tenant to which the resource belongs
 * @return {Object}                             An object keyed by library owner id, whose value is the visibility level in which the resource belongs
 */
var resolveEffectiveLibraryVisibilities = module.exports.resolveEffectiveLibraryVisibilities = function(libraryOwnerIds, resource) {
    // Determine the effective library visibilities for each resource relative to each provided library owner
    var keyVisibilities = {};

    _.each(libraryOwnerIds, function(libraryOwnerId) {
        var effectiveVisibility = resource.visibility;
        if (effectiveVisibility === AuthzConstants.visibility.LOGGEDIN) {
            // If the visibility is loggedin, it only goes into the owner's 'loggedin' library if it is
            // from their *own* tenant. Otherwise, we put it only into the private library
            var libraryOwnerTenantAlias = AuthzUtil.getResourceFromId(libraryOwnerId).tenantAlias;
            if (libraryOwnerTenantAlias !== resource.tenant.alias) {
                effectiveVisibility = AuthzConstants.visibility.PRIVATE;
            }
        }

        keyVisibilities[libraryOwnerId] = effectiveVisibility;
    });

    return keyVisibilities;
};

/**
 * Determines whether or not the user in context can remove an item from the specified library.
 *
 * @param  {Context}    ctx                 The context of the current request
 * @param  {String}     libraryOwnerId      The owner of the library from which we wish to remove item(s)
 * @param  {Function}   callback            Invoked when the check is completed
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.canRemove  Whether or not the user in context can remove an item from the library
 */
var canRemoveFromLibrary = module.exports.canRemoveFromLibrary = function(ctx, libraryOwnerId, callback) {
    var user = ctx.user();

    if (!user) {
        // Anonymous can never remove a discussion from a library
        return callback(null, false);
    }

    // Admin check. Admins can do all the things
    var libraryTenantAlias = AuthzUtil.getPrincipalFromId(libraryOwnerId).tenantAlias;
    if (ctx.user().isGlobalAdmin() || ctx.user().isTenantAdmin(libraryTenantAlias)) {
        return callback(null, true);
    }

    if (PrincipalsUtil.isUser(libraryOwnerId)) {
        if (ctx.user().id === libraryOwnerId) {
            // Only admins and the user themself can delete an item from their discussion library
            return callback(null, true);
        } else {
            return callback (null, false);
        }
    } else if (PrincipalsUtil.isGroup(libraryOwnerId)) {
        // If this is a group, only managers can remove items from its library
        return PrincipalsGroupAPI.canManage(ctx, libraryOwnerId, callback);
    } else {
        return callback({'err': 400, 'code': 'Invalid library owner specified'});
    }
};
