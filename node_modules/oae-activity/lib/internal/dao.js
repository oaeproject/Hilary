/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var _ = require('underscore');

var Cassandra = require('oae-util/lib/cassandra');
var log = require('oae-logger').logger('oae-activity');

// time-to-live for activities is 2 weeks (in seconds)
var TTL = 2 * 7 * 24 * 60 * 60;

/**
 * Get a list of activities from the specified activity stream.
 *
 * @param   {String}        activityStreamId    The ID of the activity stream
 * @param   {Number|String} start               Number of millis since the epoc (stringified or number version) from which to start returning activities. Only activities older than this timestamp will be returned.
 * @param   {Number}        limit               The number of activities to return
 * @param   {Function}      callback            Invoked when the process completes
 * @param   {Object}        callback.err        An error that occurred, if any
 * @param   {Activity[]}    callback.activities The list of activities
 */
var getActivities = module.exports.getActivities = function(activityStreamId, start, limit, callback) {
    limit = limit || 25;
    var paging = Cassandra.getPagingParameters(start, limit);
    var activities = [];
    Cassandra.runQuery('SELECT FIRST ? ? .. \'\' FROM ActivityStreams USING CONSISTENCY ONE WHERE activityStreamId = ?', [paging.limit, paging.start, activityStreamId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        return callback(null, _rowToActivities(rows[0]));
    });
};

/**
 * Save an activity to a list of routes.
 *
 * @param   {Object}    routeActivities A hash, mapping route -> Activity, outlining which activities should be saved to which routes
 * @param   {Function}  [callback]      Invoked when the process completes
 * @param   {Object}    [callback.err]  An error that occurred, if any
 */
var saveActivities = module.exports.saveActivities = function(routeActivities, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Error saving routes to database.');
        }
    };
    
    var queries = [];
    var routes = _.keys(routeActivities);
    for (var i = 0; i < routes.length; i++) {
        var route = routes[i];
        var activity = routeActivities[route];
        var activityStr = JSON.stringify(activity);
        var timestamp = activity.published;
        queries.push({
            'query': 'UPDATE ActivityStreams USING TTL ' + TTL + ' SET ? = ? WHERE activityStreamId = ?',
            'parameters': [timestamp, activityStr, route]
        });
    }

    Cassandra.runBatchQuery(queries, 'ONE', callback);
};

var _rowToActivities = function(row) {
    var activities = [];
    row.forEach(function(name, value) {
        try {
            activities.push(JSON.parse(value));
        } catch (err) {
            log().warn({'err': err}, 'Error parsing activity value.');
        }
    });
    return activities;
}

