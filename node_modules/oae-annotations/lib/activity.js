/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var ActivityAPI = require('oae-activity');
var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;
var ActivityModel = require('oae-activity/lib/model');
var ActivityUtil = require('oae-activity/lib/util');
var ContentDAO = require('oae-content/lib/internal/dao');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var PrincipalsUtil = require('oae-principals/lib/util');
var TenantsUtil = require('oae-tenants/lib/util');

var AnnotationAPI = require('oae-annotations');
var AnnotationConstants = require('oae-annotations/lib/constants').AnnotationConstants;
var AnnotationDAO = require('oae-annotations/lib/internal/dao');
var AnnotationView = require('oae-annotations/lib/view');

///////////////////////
// ANNOTATION-CREATE //
///////////////////////

ActivityAPI.registerActivityType(AnnotationConstants.activity.CREATE, {
    'groupBy': [{'target': true}],
    'streams': {
        'activity': {
            'router': {
                'actor': ['self', 'followers'],
                'target': ['self', 'members']
            }
        },
        'notification': {
            'router': {
                'target': ['members']
            }
        },
        'email': {
            'router': {
                'target': ['members']
            }
        }
    }
});

/*!
 * Post an annotation-create activity when a user creates an annotation
 */
AnnotationAPI.on(AnnotationConstants.events.CREATED, function(ctx, content, revision, annotation) {
    var millis = Date.now();
    var actorResource = new ActivityModel.ActivitySeedResource('user', ctx.user().id, {'user': ctx.user()});
    var objectResource = new ActivityModel.ActivitySeedResource('annotation', annotation.id, {'annotation': annotation, 'contentId': content.id, 'revisionId': revision.revisionId});
    var targetResource = new ActivityModel.ActivitySeedResource('content', content.id, {'content': content, 'revision': revision});
    var activitySeed = new ActivityModel.ActivitySeed(AnnotationConstants.activity.CREATE, millis, ActivityConstants.verbs.CREATE, actorResource, objectResource, targetResource);
    ActivityAPI.postActivity(ctx, activitySeed);
});

///////////////////////
// ANNOTATION-UPDATE //
///////////////////////

ActivityAPI.registerActivityType(AnnotationConstants.activity.UPDATE, {
    'groupBy': [{'target': true}],
    'streams': {
        'activity': {
            'router': {
                'actor': ['self', 'followers'],
                'target': ['self', 'members']
            }
        }
    }
});

/*!
 * Post an annotation-update activity when a user updated an annotation
 */
AnnotationAPI.on(AnnotationConstants.events.UPDATED, function(ctx, content, revision, oldAnnotation, newAnnotation) {
    var millis = Date.now();
    var actorResource = new ActivityModel.ActivitySeedResource('user', ctx.user().id, {'user': ctx.user()});
    var objectResource = new ActivityModel.ActivitySeedResource('annotation', newAnnotation.id, {'annotation': newAnnotation, 'contentId': content.id, 'revisionId': revision.revisionId});
    var targetResource = new ActivityModel.ActivitySeedResource('content', content.id, {'content': content, 'revision': revision});
    var activitySeed = new ActivityModel.ActivitySeed(AnnotationConstants.activity.UPDATE, millis, ActivityConstants.verbs.UPDATE, actorResource, objectResource, targetResource);
    ActivityAPI.postActivity(ctx, activitySeed);
});


///////////////////////
// ANNOTATION-DELETE //
///////////////////////

ActivityAPI.registerActivityType(AnnotationConstants.activity.DELETE, {
    'groupBy': [{'target': true}],
    'streams': {
        'activity': {
            'router': {
                'actor': ['self', 'followers'],
                'target': ['self', 'members']
            }
        }
    }
});

/*!
 * Post an annotation-delete activity when a user deleted an annotation
 */
AnnotationAPI.on(AnnotationConstants.events.DELETED, function(ctx, content, revision, deletedAnnotation) {
    var millis = Date.now();
    var actorResource = new ActivityModel.ActivitySeedResource('user', ctx.user().id, {'user': ctx.user()});
    var objectResource = new ActivityModel.ActivitySeedResource('annotation', deletedAnnotation.id, {'annotation': deletedAnnotation, 'contentId': content.id, 'revisionId': revision.revisionId});
    var targetResource = new ActivityModel.ActivitySeedResource('content', content.id, {'content': content, 'revision': revision});
    var activitySeed = new ActivityModel.ActivitySeed(AnnotationConstants.activity.DELETE, millis, ActivityConstants.verbs.DELETE, actorResource, objectResource, targetResource);
    ActivityAPI.postActivity(ctx, activitySeed);
});


///////////////////////////
// ACTIVITY ENTITY TYPES //
///////////////////////////

/*!
 * Produces a persistent 'annotation' activity entity
 * @see ActivityAPI#registerActivityEntityType
 */
var _annotationProducer = function(resource, callback) {
    // If the annotation was fired with the resource, use it instead of fetching
    if (resource.resourceData && resource.resourceData.annotation) {
        var persistentEntity = _createPersistentAnnotationActivityEntity(resource.resourceData.annotation);
        return callback(null, persistentEntity);
    }

    // Otherwise retrieve the necessary data
    AnnotationDAO.getAnnotation(resource.resourceId, function(err, annotation) {
        if (err) {
            return callback(err);
        }

        // Retrieve the createdBy / updatedBy users
        var principalIds = _.chain([annotation.createdBy, annotation.updatedBy]).uniq().compact().value();
        PrincipalsDAO.getPrincipals(principalIds, function(err, principals) {
            if (err) {
                return callback(err);
            }

            annotation.createdBy = principals[annotation.createdBy];
            if (annotation.updatedBy) {
                annotation.updatedBy = principals[annotation.updatedBy];
            }
            return callback(null, _createPersistentAnnotationActivityEntity(annotation));
        });
    });
};

/**
 * Given an annotation, create an object that can be persisted
 *
 * @param  {Annotation}     annotation      The annotation for which to generate a persistable object
 * @return {Object}                         An object that can be persisted
 * @api private
 */
var _createPersistentAnnotationActivityEntity = function(annotation) {
    var persistentEntity = {
        'objectType': 'annotation',
        'annotation': annotation,
    };
    persistentEntity[ActivityConstants.properties.OAE_ID] = annotation.id;
    return persistentEntity;
};


/*!
 * Transform the persisted annotation activity entities into UI-friendly ones
 * @see ActivityAPI#registerActivityEntityType
 */
var _annotationTransformer = function(ctx, activityEntities, callback) {
    var transformedActivityEntities = {};

    _.each(activityEntities, function(entities, activityId) {
        transformedActivityEntities[activityId] = transformedActivityEntities[activityId] || {};
        _.each(entities, function(entity, entityId) {
            // Transform the persistent entity with its up-to-date preview status
            transformedActivityEntities[activityId][entityId] = _transformPersistentAnnotation(ctx, entity);
        });
    });

    return callback(null, transformedActivityEntities);
};

/**
 * Transform a persistent annotation into something that can be return from the REST apis
 *
 * @param  {Context}            ctx         The context of the current request
 * @param  {ActivityEntity}     entity      The activity entity holding the persisted annotation
 * @return {ActivityEntity}                 An activity entity that can be returned from the REST apis
 * @api private
 */
var _transformPersistentAnnotation = function(ctx, entity) {
    var annotation = entity.annotation;
    var tenant = ctx.tenant();
    var baseUrl = TenantsUtil.getBaseUrl(tenant);
    var globalId = baseUrl + '/api/content/' + annotation.contentId + '/annotations/' + annotation.revisionId + '/' + annotation.id;
    var opts = {};
    opts.published = annotation.created;
    if (_.isObject(annotation.createdBy)) {
        opts.author = PrincipalsUtil.transformPersistentUserActivityEntity(ctx, annotation.createdBy.id, annotation.createdBy);
    }

    opts.ext = {};
    opts.ext[ActivityConstants.properties.OAE_ID] = annotation.id;
    opts.ext[AnnotationConstants.activity.PROP_OAE_ANNOTATION] = annotation;

    if (annotation.updatedBy) {
        opts.updated = annotation.updated;
    }

    return new ActivityModel.ActivityEntity('annotation', globalId, opts);
};

ActivityAPI.registerActivityEntityType('annotation', {
    'producer': _annotationProducer,
    'transformer': {
        'activitystreams': _annotationTransformer,
        'internal': _annotationTransformer
    },
    'propagation': function(associationsCtx, entity, callback) {
        return callback(null, [{'type': ActivityConstants.entityPropagation.ALL}]);
    }
});
