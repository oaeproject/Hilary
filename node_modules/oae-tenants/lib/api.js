/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var EventEmitter = require('events').EventEmitter;
var OAE = require('oae-util/lib/oae');
var Cassandra = require('oae-util/lib/cassandra');
var Pubsub = require('oae-util/lib/pubsub');
var Validator = require('oae-util/lib/validator').Validator;
var log = require('oae-logger').logger('oae-tenants');

var Tenant = require('./model').Tenant;

// An object that holds all the known tenants in the system, keyed by their hostname.
var tenantsByHost = {};
// An object that holds all the known tenants in the system, keyed by their alias.
var tenantsByAlias = {};

/**
 * ### Events
 *
 * The `TenantsAPI` emits the following events:
 *
 * * `start(tenant)`: A request has been received to "start" a tenant.
 * * `stop(tenant)`: A request has been received to "stop" a tenant.
 * * `refresh(tenant)`: A request has been received to "refresh" the metadata of a tenant.
 */
var emitter = module.exports = new EventEmitter();

/*!
 * Listen for cluster wide requests involving tenants.
 *
 * @param  {String}  message  A string that is a brief command. Commands are of the form: `start cam`, `stop cam` or `refresh cam`.
 */
Pubsub.on('oae-tenants', function (message) {
    var args = message.split(' ');
    var cmd = args.shift();
    var alias = args.shift();

    // Get the tenant and emit the event.
    getTenantByAlias(alias, function(err, tenant) {
        if (err) {
            return log().error({err: err}, 'There was an error retrieving the tenant: %s', alias);
        }

        emitter.emit(cmd, tenant);
    });
});

/**
 * Adds or updates a tenant in the cache.
 *
 * @param  {Tenant} tenant The up-to-date tenant object that should be placed in the cache.
 * @api private
 */
var _updateCachedTenants = function(tenant) {
    if (!tenant) {
        return log().error('Missing tenant object.');
    }

    tenantsByHost[tenant.host] = tenant;
    tenantsByAlias[tenant.alias] = tenant;
};

/*!
 * Besides updating the cache with the new tenant information,
 * there is nothing special that should happen on any of these events.
 *
 * There are no servers, connections, timers, .. to shut down in the tenant module.
 * Requests against the tenant server will be checked on the fly.
 */
emitter.on('start', _updateCachedTenants);
emitter.on('stop', _updateCachedTenants);
emitter.on('refresh', _updateCachedTenants);

/**
 * Initialize the middleware that will put the tenant onto the request and cache all of the registered
 * tenants.
 *
 * @param  {Object}         config          JSON object containing configuration values for Cassandra, Redis, logging and telemetry
 * @param  {Function}       callback        Standard callback function
 * @param  {Object}         callback.err    Error object containing the error code and message
 */
var initializeTenantMiddleware = module.exports.initializeTenantMiddleware = function(config, callback) {
    // Add a dummy tenant object that can serve as the global admin tenant object.
    var globalTenant = new Tenant(config.servers.globalAdminAlias, 'Global admin server', config.servers.globalAdminHost, true, false);
    globalTenant.isGlobalAdminServer = true;
    tenantsByHost[globalTenant.host] = globalTenant;
    tenantsByAlias[globalTenant.alias] = globalTenant;

    // This middleware adds the tenant to each request on the global admin server.
    OAE.globalAdminServer.use(function(req, res, next) {
        req.tenant = globalTenant;
        return next();
    });

    // This middleware adds the tenant to each request on the user tenant server.
    OAE.tenantServer.use(function(req, res, next) {
        req.tenant = tenantsByHost[req.headers.host];
        if (!req.tenant) {
            // We stop the request if we can't find a tenant associated to the current hostname
            res.setHeader('Connection', 'Close');
            return res.send(418, 'This hostname is not associated to any tenant');
        }

        // Check whether or not the tenant has been disabled
        if (!req.tenant.active) {
            // If we're disabled, there is no point in keeping connections open.
            res.setHeader('Connection', 'Close');
            return res.send(503, 'This server is currently disabled. Please check back later.');
        }
        next();
    });

    // Get all tenants and cache them by their host and alias key.
    getAllTenants(function(err, tenants) {
        if (err) {
            return callback(err);
        }

        _.each(tenants, function(tenant, tenantAlias) {
            tenantsByHost[tenant.host] = tenant;
            tenantsByAlias[tenant.alias] = tenant;
        });

        callback();
    });
};

/**
 * Get all the tenants for purposes for filling the REST context. Note that the tenant information
 * may be out-dated as the data is not refreshed when tenants are updated.
 *
 * FIXME: This would be better off being covered by `getAllTenants`, however:
 *
 *  a)  `getAllTenants` currently needs to be the most recent data for a tenant; and
 *  b)  the in-memory caching system needs to be improved to update across the cluster; and
 *  c)  fetch from Cassandra each time on `getAllTenants` has unacceptable performance for
 *      accessing on every request to build a context.
 *
 *  Once in-memory storage of tenants is properly managed across the cluster, this method can
 *  be removed in favour of a more performant version of `getAllTenants`.
 *
 * @return {Object}    A hash keyed by tenant alias, whose value is the (possibly outdated) Tenant object.
 */
var getTenantsForContext = module.exports.getTenantsForContext = function() {
    return _.extend({}, tenantsByAlias);
};

/**
 * Publishes a message that a new tenant should be started.
 * Note that the actual server startup will happen asynchronous from this method.
 *
 * @param  {Tenant}     tenant          The tenant object representing the tenant to be started
 * @param  {Function}   callback        A callback method
 * @param  {Object}     callback.err    An error object (if any)
 */
var startTenant = module.exports.startTenant = function(tenant, callback) {
    Pubsub.publish('oae-tenants', 'start ' + tenant.alias, callback);
};

/**
 * Disable or enable a tenant
 *
 * @param  {Context}      ctx             The current context
 * @param  {String[]}     aliases         An array of aliases representing the tenants that should be stopped.
 * @param  {Boolean}      disabled        True if the tenant needs to be disabled
 * @param  {[Function]}   callback        Callback function executed when request is completed.
 * @param  {Object}       callback.err    An error object (if any.)
 */
var disableTenants = module.exports.disableTenants = function(ctx, aliases, disabled, callback) {
    callback = callback || function() {};

    if (!ctx.user() || !ctx.user().isGlobalAdmin()) {
        return callback({'code': 401, 'msg': 'Unauthorized users cannot disable or enable tenants'});
    }

    if (!aliases) {
        return callback({'code': 400, 'msg': 'Please provide at least one tenant alias'});
    }

    if (!Array.isArray(aliases)) {
        aliases = [aliases];
    }

    // Store the activity flag in cassandra.
    var queries = [];
    for (var i = 0; i < aliases.length; i++) {
        queries.push({
            'query': 'UPDATE Tenant SET active = ? WHERE alias = ?',
            'parameters': [!disabled, aliases[i]]
        });
    }
    Cassandra.runBatchQuery(queries, 'QUORUM', function(err) {
        if (err) {
            return callback(err);
        }

        // Broadcast the message accross the cluster
        // so we can start/stop the tenants.
        var cmd = disabled ? 'stop' : 'start';
        for (var i = 0; i < aliases.length; i++) {
            Pubsub.publish('oae-tenants', cmd + ' ' + aliases[i], callback);
        }
    });
};

/**
 * Rather than physically deleting a tenant, we just disable it for now.
 *
 * @param  {Context}   ctx             The current context
 * @param  {String[]}  aliases         An array of aliases representing the tenants that should be deleted.
 * @param  {Function}  callback        Callback function executed when request is completed.
 * @param  {Object}    callback.err    An error object (if any.)
 */
var deleteTenants = module.exports.deleteTenants = function(ctx, aliases, callback) {
    callback = callback || function() {};

    if (!ctx.user() || !ctx.user().isGlobalAdmin()) {
        return callback({'code': 401, 'msg': 'Unauthorized users cannot delete tenants'});
    }

    if (!aliases) {
        return callback({'code': 400, 'msg': 'Please provide a ports array'});
    }
    if (!Array.isArray(aliases)) {
        aliases = [aliases];
    }

    var queries = [];
    for (var i = 0; i < aliases.length; i++) {
        queries.push({
            'query': 'UPDATE Tenant SET active = ?, deleted = ? WHERE alias = ?',
            'parameters': [false, true, aliases[i]]
        });
    }
    Cassandra.runBatchQuery(queries, 'QUORUM', function(err) {
        if (err) {
            return callback(err);
        }
        // Broadcast the message accross the cluster
        // so we can stop the tenants.
        for (var i = 0; i < aliases.length; i++) {
            Pubsub.publish('oae-tenants', 'stop ' + aliases[i], callback);
        }
    });
};

/**
 * Get all the tenants in the datastore.
 *
 * @param  {Function}  callback            Standard callback function
 * @param  {Object}    callback.err        Error object containing the error message
 * @param  {Object}    callback.tenants    An object keyed by tenant alias holding all the (non-deleted) tenants in the data-store
 */
var getAllTenants = module.exports.getAllTenants = function(callback) {
    Cassandra.runQuery('SELECT * FROM Tenant USING CONSISTENCY QUORUM', false, function(err, rows) {
        if (err) {
            return callback(err);
        }

        var tenants = {};
        for (var i = 0; i < rows.length; i++) {
            var tenant = mapToTenant(rows[i], false);
            if (!tenant.deleted) {
                tenants[tenant.alias] = tenant;
            }
        }
        callback(null, tenants);
    });
};

/**
 * Get the unique tenant by their alias.
 *
 * @param  {String}    alias               The alias assigned to the tenant
 * @param  {Function}  callback            A function(err, tenant) specifying the tenant requested
 * @param  {Object}    callback.err        Error object containing the error message and error code
 * @param  {Tenant}    callback.tenant     The tenant object that uses the provided alias
 */
var getTenantByAlias = module.exports.getTenantByAlias = function(alias, callback) {
    Cassandra.runQuery('SELECT * FROM Tenant USING CONSISTENCY QUORUM WHERE alias = ?', [alias], function(err, rows) {
        if (err) {
            return callback(err);
        }

        if (rows[0].count > 1) {
            var tenant = mapToTenant(rows[0]);
            callback(null, tenant);
        } else {
            callback({'code': 404, 'msg': 'There is no tenant with alias ' + alias});
        }
    });
};

/**
 * Gets a tenant which is already cached in local memory.
 * This is useful for those methods that need quick access to a tenant object and can live with
 * some information being out of date for a few seconds.
 *
 * @param  {String} tenantAlias The alias of the tenant you wish to retrieve.
 * @return {Tenant}             The tenant object for this tenant alias.
 */
var getCachedTenantByAlias = module.exports.getCachedTenantByAlias = function(tenantAlias) {
    return tenantsByAlias[tenantAlias];
};

/**
 * Create a tenant using the provided information.
 *
 * @param  {Context}    ctx             The current context
 * @param  {String}     alias           The unique alias assigned to the tenant
 * @param  {String}     displayName     A descriptive short name for the tenant
 * @param  {String}     host            The host on which this tenant is proxying (ie: oae.cam.ac.uk or oae.gatech.edu)
 * @param  {Function}   callback        A function(err, tenant) specifying the tenant information that was persisted.
 * @param  {Object}     callback.err    An error object (if any)
 * @param  {Tenant}     callback.tenant The tenant that was persisted.
 */
var createTenant = module.exports.createTenant = function(ctx, alias, displayName, host, callback) {
    callback = callback || function() {};

    if (!ctx.user() || !ctx.user().isGlobalAdmin()) {
        return callback({'code': 401, 'msg': 'Unauthorized users cannot create tenants'});
    }

    var validator = new Validator();
    validator.check(alias, {'code': 400, 'msg': 'Missing alias'}).notEmpty();
    validator.check(alias, {'code': 400, 'msg': 'The tenant alias should not contain a colon'}).notContains(':');
    validator.check(displayName, {'code': 400, 'msg': 'Missing tenant displayName'}).notEmpty();
    validator.check(host, {'code': 400, 'msg': 'Missing tenant host'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getTenantByAlias(alias, function(err, tenant) {
        if (!tenant) {
            tenant = new Tenant(alias, displayName, host, true, false);
            // no tenant by this alias or port exist, create one
            Cassandra.runQuery('UPDATE Tenant USING CONSISTENCY QUORUM SET displayName = ?, host = ?, active = ? WHERE alias = ?',
                [tenant.displayName, host, tenant.active, tenant.alias], function(err) {
                if (err) {
                    return callback(err);
                }
                // Send a message to all the app servers in the cluster that they
                // should start up the tenant.
                startTenant(tenant, function(err) {
                    // Let the configuration module know that a new tenant has been created and configuration needs to be fetched
                    Pubsub.publish('oae-config', tenant.alias);
                    if (err) {
                        return callback(err);
                    }
                    callback(null, tenant);
                });
            });
        } else {
            callback({'code': 400, 'msg': 'A tenant with the alias ' + alias + ' already exists'});
        }
    });
};

/**
 * Updates the basic information of a tenant
 *
 * @param  {Context}   ctx            The current context.
 * @param  {String}    alias          The alias of the tenant we want to update
 * @param  {String}    displayName    The updated displayName for the tenant
 * @param  {Function}  callback       A function(err) executed after the tenant has been updated
 * @param  {Object}    callback.err   An error object (if any)
 */
var updateTenant = module.exports.updateTenant = function(ctx, alias, displayName, callback) {
    if (!ctx.user() || !ctx.user().isAdmin(ctx.user().tenant.alias)) {
        return callback({'code': 401, 'msg': 'Unauthorized users cannot update tenants'});
    }

    var validator = new Validator();
    validator.check(displayName, {'code': 400, 'msg': 'Missing displayName'}).notEmpty();
    validator.check(alias, {'code': 400, 'msg': 'Missing alias'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    Cassandra.runQuery('UPDATE Tenant USING CONSISTENCY QUORUM SET displayName = ? WHERE alias = ?', [displayName, alias], function(err) {
        if (err) {
            return callback(err);
        }

        // Emit a cluster-wide event to let the app servers re-cache this tenant's metadata.
        Pubsub.publish('oae-tenants', 'refresh ' + alias, callback);
    });
};

/**
 * Get the tenant aliases of all the running tenants.
 *
 * @return {String[]}  The unique tenant aliases of all running tenants
 */
var getRunningTenantAliases = module.exports.getRunningTenantAliases = function() {
    var aliases = [];
    _.each(tenantsByAlias, function(tenant, tenantAlias) {
        if (tenant.active) {
            aliases.push(tenant.alias);
        }
    });
    return aliases;
};

/**
 * Map a cassandra row element to a tenant object.
 *
 * @param  {Row}      row            The row to be mapped
 * @param  {Boolean}  returnDeleted  ignored?
 * @return {Tenant}                  A tenant corresponding to the row
 * @api private
 */
var mapToTenant = function(row, returnDeleted) {
    var hash = Cassandra.rowToHash(row);
    return new Tenant(hash.alias, hash.displayName, hash.host, hash.active, hash.deleted);
};
