/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var log = require('oae-logger').logger('content-dao');
var Validator = require('oae-util/lib/validator').Validator;

///////////////
// Retrieval //
///////////////


/**
 * Get an array of preview items.
 *
 * @param  {String}     revisionId          The ID of a revision for which the preview items should be retrieved.
 * @param  {Function}   callback            Invoked when the process compeletes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Object[]}   callback.previews   The preview objects.
 */
var getContentPreviews = module.exports.getContentPreviews = function(revisionId, callback) {
    Cassandra.runQuery('SELECT * FROM PreviewItems WHERE revisionId = ?', [revisionId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var previews = [];
        var filenames = Cassandra.rowToHash(rows[0]);
        delete filenames.revisionId;
        _.each(filenames, function(value, filename) {
            var data = value.split('#');
            previews.push({
                'size': data[0],
                'uri': data[1],
                'filename': filename
            });
        });
        callback(null, previews);
    });
};

/**
 * Get a specific content preview.
 *
 * @param  {String}     revisionId          The ID of a revision for which a preview item should be retrieved.
 * @param  {String}     previewItem         The name of the preview item that should be retrieved.
 * @param  {Function}   callback            Invoked when the process compeletes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Object}     callback.preview    The preview object.
 */
var getContentPreview = module.exports.getContentPreview = function(revisionId, previewItem, callback) {
    Cassandra.runQuery('SELECT ? FROM PreviewItems WHERE revisionId = ?', [previewItem, revisionId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        // Cassandra always returns a row with the rowKey as a column so there is always at least 1 row.
        // We retrieve a column that has the same name as requested preview item to verify it exists.
        var col = rows[0].get(previewItem);

        // We need to check if it's null as deleted columns are tombstoned and can still return here.
        if (!col || !col.value) {
            return callback({'code': 404, 'msg': 'Couldn\'t find item ' + previewItem + ' for revisionId: ' + revisionId});
        }
        var data = col.value.split('#');
        var preview = {
            'size': data[0],
            'uri': data[1]
        };
        callback(null, preview);
    });
};

/**
 * Gets the preview Uris for a set of revision IDs.
 *
 * @param  {String[]} revisionIds           The revision IDs
 * @param  {Function} callback              Standard callback method.
 * @param  {Object}   callback.err          Standard error object (if any).
 * @param  {Object}   callback.previews     Object where each key is a revision id and the value is another object with the thumbnailUri and wideUri.
 */
var getPreviewUris = module.exports.getPreviewUris = function(revisionIds, callback) {
    revisionIds = _.uniq(revisionIds);
    if (!revisionIds || revisionIds.length === 0) {
        return callback(null, {});
    }

    Cassandra.runQuery('SELECT thumbnailUri, wideUri FROM Revisions WHERE revisionId IN (?)', [revisionIds], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var previews = {};
        rows.forEach(function(row) {
            previews[row.key] = {};

            var thumbnailUri = row.get('thumbnailUri');
            if (thumbnailUri && thumbnailUri.value) {
                previews[row.key].thumbnailUri = thumbnailUri.value;
            }

            var wideUri = row.get('wideUri');
            if (wideUri && wideUri.value) {
                previews[row.key].wideUri = wideUri.value;
            }
        });
        return callback(null, previews);
    });
};


///////////////
// Modifiers //
///////////////


/**
 * Stores preview metadata on the Content object in Cassandra.
 * This method will:
 *  1/ Remove old preview items associated to the piece of content (if any)
 *  2/ Store the new preview URIs (if any)
 *  3/ Update the previews object in the Content CF.
 *  4/ Update the previews object in the Revisions CF.
 *
 * @param  {Content}     contentObj      The ID of the piece of content for which we need to update the preview metadata.
 * @param  {String}      revisionId      The revision ID of the piece of content for which we need to update the preview metadata.
 * @param  {String}      status          The result of the preview processing operation. It should be one of the values of ContentConstants.previews.
 * @param  {String}      thumbnailUri    The uri of a thumbnail
 * @param  {Object}      metadata        Each key corresponds to a string value that should be stored on the content object.
 * @param  {Object}      fileData        Each key corresponds to a filename, the value is of the form 'size#uri'.
 * @param  {Function}    callback        Standard callback method
 * @param  {Object}      callback.err    Standard error object (if any.)
 */
var storeMetadata = module.exports.storeMetadata = function(contentObj, revisionId, status, thumbnailUri, contentMetadata, previewMetadata, fileData, callback) {
    var queries = [];
    // 1. Remove the old previews
    if (contentObj.previews.total && contentObj.previews.total > 0) {
        queries.push({
            'query': 'DELETE FROM PreviewItems WHERE revisionId = ?',
            'parameters': [revisionId]
        });
    }

    // 2. Add in the new preview items (if any.)
    var nrOfFiles = Object.keys(fileData).length;
    if (nrOfFiles > 0) {
        queries.push(Cassandra.constructUpsertCQL('PreviewItems', 'revisionId', revisionId, fileData));
    }

    // 3. Store the previews object.
    var data = {'status': status, 'total': nrOfFiles};
    // Set the thumbnail URI if we have one.
    if (thumbnailUri) {
        data.thumbnailUri = thumbnailUri;
    }

    // Pass in data second, in case previewMetadata contains a status or thumbnailUri key.
    var previews = _.extend({}, previewMetadata, data);
    contentObj.previews = previews;

    previews = JSON.stringify(previews);
    var contentUpdate = _.extend({}, contentMetadata, {'previews': previews});
    queries.push(Cassandra.constructUpsertCQL('Content', 'contentId', contentObj.id, contentUpdate));

    // 4. Store the previews object on the revision.
    var revisionUpdate = {
        'status': status,
        'previews': previews
    };
    if (thumbnailUri) {
        revisionUpdate.thumbnailUri = thumbnailUri;
    }

    // We save the wide and medium URIs on the revision object as well.
    var wideUri = _getUriInFileData(fileData, 'wide');
    if (wideUri) {
        revisionUpdate.wideUri = wideUri;
    }
    var mediumUri = _getUriInFileData(fileData, 'medium');
    if (mediumUri) {
        revisionUpdate.mediumUri = mediumUri;
    }
    queries.push(Cassandra.constructUpsertCQL('Revisions', 'revisionId', revisionId, revisionUpdate));

    // Save the data.
    Cassandra.runBatchQuery(queries, 'QUORUM', callback);
};

/**
 * Copy the preview item metadata from the source revision to the destination revision.
 *
 * @param  {String}     fromRevisionId      The id of the revision from which to copy the preview items
 * @param  {String}     toRevisionId        The id of the destination revision, where the preview items will be copied
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @api private
 */
var copyPreviewItems = module.exports.copyPreviewItems = function(fromRevisionId, toRevisionId, callback) {

    var validator = new Validator();
    validator.check(fromRevisionId, {'code': 400, 'msg': 'Must specify a valid resource id for "fromRevisionId"'}).isResourceId();
    validator.check(toRevisionId, {'code': 400, 'msg': 'Must specify a valid resource id for "toRevisionId"'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Select all the rows from the source revision preview items, then insert them into the destination revision preview items
    Cassandra.runQuery('SELECT * FROM PreviewItems USING CONSISTENCY QUORUM WHERE revisionId = ?', [fromRevisionId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var row = rows[0];
        var columnsHash = Cassandra.rowToHash(row);
        delete columnsHash.revisionId;

        if (_.isEmpty(columnsHash)) {
            // There are no preview items to copy, simply return
            return callback();
        }

        // We have stuff to copy. Do it
        var copyQuery = Cassandra.constructUpsertCQL('PreviewItems', 'revisionId', toRevisionId, columnsHash);
        return Cassandra.runQuery(copyQuery.query, copyQuery.parameters, callback);
    });
};

/**
 * Returns the URI for a file of a given size.
 * If the file could not be found, null will be returned
 *
 * @param  {Object} fileData Each key corresponds to a filename, the value is of the form 'size#uri'.
 * @param  {String} size     The size of the image for which we need to find the URI.
 * @return {String}          The URI for the stored file (or null).
 * @api private
 */
var _getUriInFileData = function(fileData, size) {
    var file = _.find(fileData, function(val, filename) { return val.indexOf(size + '#') === 0; });
    if (file) {
        // Get the uri out of the wide file data string.
        // file data is of the form '<size>#<uri>'.
        // Rather than doing file.split('#')[1], slice of the name and return the rest of string
        // to prevent not getting the full URI if it would ever contain a '#'.
        return file.split('#').slice(1).join('#');
    } else {
        return null;
    }
};
