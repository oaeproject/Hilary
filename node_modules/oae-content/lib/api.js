/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var events = require('events');
var fs = require('fs');
var Path = require('path');
var ShortId = require('shortid');
var util = require('util');

var AuthzAPI = require('oae-authz');
var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var Config = require('oae-config').config('oae-content');
var Context = require('oae-context').Context;
var log = require('oae-logger').logger('oae-content');
var PrincipalsUtil = require('oae-principals/lib/util');
var Signature = require('oae-util/lib/signature');
var TenantsUtil = require('oae-tenants/lib/util');
var Validator = require('oae-util/lib/validator').Validator;

var Comment = require('./model').Comment;
var Content = require('./model').Content;
var ContentConstants = require('./constants').ContentConstants;
var ContentDAO = require('./internal/dao');
var ContentUtil = require('./internal/util');
var Revision = require('./model').Revision;

var _backends = {};

/**
 * ### Events
 *
 * The `ContentAPI`, as enumerated in `ContentConstants.events`, emits the following events:
 *
 * * `createdContent(ctx, content)`: A new content item was created. The `ctx` and the `content` object that was created are both provided.
 * * `updatedContent(ctx, newContentObj, oldContentObj)`: A content item was updated. The `ctx`, the updated content object and the content before was updated are provided.
 * * `updatedContentBody(ctx, content, fileInfo)`: A content item's file body was updated. The `ctx` of the request, the `content` object that was updated and the `fileInfo` of the new file location are all provided.
 * * `deletedContent(ctx, contentId)`: A content item was deleted. The `ctx` and the `contentId` of the deleted item are provided.
 * * `updatedContentMembers(ctx, content, memberUpdates)`: A content's members list was updated. The `ctx`, full `content` object of the updated content, and the hash of principalId -> role that outlines the changes that were made are provided.
 * * `createdComment(ctx, comment)`: A new (top-level) comment was posted for a content item. This does not get fired when a reply to a comment has happened
 */
var ContentAPI = emitter = module.exports = new events.EventEmitter();

///////////////////////////////////
// Retrieving a piece of content //
///////////////////////////////////

/**
 * Get a content's basic profile information based on a pooled content id
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the content object we want to retrieve
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Content}        callback.contentObj Retrieved content object
 */
var getContent = module.exports.getContent = function(ctx, contentId, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    ContentDAO.getContent(contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        _hasAccess(ctx, contentObj, function(err, hasAccess) {
            if (err) {
                return callback(err);
            } else if (!hasAccess) {
                return callback({'code': 401, 'msg': 'You don\'t have access to this piece of content'});
            }

            _augmentContent(ctx, contentObj);
            callback(null, contentObj);
        });
    });
};

/**
 * Get a content item's full content profile. Next to the basic content profile, this will include the created date,
 * the profile of the user who originally created the content, and a isManager property specifying whether or not
 * the current user can manage the content.
 *
 * @param  {Context}        ctx                         Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId                   The id of the content profile we want to retrieve
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                Error object containing the error message
 * @param  {Content}        callback.contentProfile     Retrieved content profile
 */
var getFullContentProfile = module.exports.getFullContentProfile = function(ctx, contentId, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }
        
        // Get the user object for the createdBy property
        PrincipalsUtil.getPrincipal(ctx, contentObj.createdBy, function(err, createdBy) {
            if (err) {
                return callback(err);
            }
            contentObj.createdBy = createdBy;

            // If the current user is an anonymous user, we know he's not a viewer or manager
            if (!ctx.user()) {
                contentObj.isManager = false;
                callback(null, contentObj);
            } else {
                // Add the isManager properties
                _canManage(ctx, contentObj, function(err, isManager) {
                    if (err) {
                        return callback(err);
                    }
                    contentObj.isManager = isManager;
                    callback(null, contentObj);
                });
            }
        });
    });
};

/////////////////////////////////////
// Creating a new piece of content //
/////////////////////////////////////

/**
 * Create a link as a pooled content item
 * 
 * @param  {Context}        ctx                Standard context object containing the current user and the current tenant
 * @param  {String}         displayName        The display name for the link
 * @param  {String}         description        The description of the link [optional]
 * @param  {String}         visibility         The visibility setting for the piece of content. Possible values are "public", "loggedin" and "private" [optional]
 * @param  {String}         link               The URL for the link
 * @param  {Object}         additionalMembers  Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {Function}       callback           Standard callback function takes arguments `err` and `content`
 * @param  {Object}         callback.err       Error object containing the error message
 * @param  {Object}         callback.content   JSON object containing the pool id of the created content
 */
var createLink = module.exports.createLink = function(ctx, displayName, description, visibility, link, additionalMembers, callback) {
    callback = callback || function() {};

    // Setting content to default if no visibility setting is provided
    visibility = visibility || Config.getValue(ctx.tenant().alias, 'visibility', 'links');

    // Check if the link property is present. All other validation will be done in the _createContent function
    var validator = new Validator();
    validator.check(link, {'code': 400, 'msg': 'A valid link must be provided'}).isUrl();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to create a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _createContent(ctx, 'link', displayName, description, visibility, additionalMembers, {'link': link}, function(err, content) {
        if (!err) {
            emitter.emit(ContentConstants.events.CREATED_CONTENT, ctx, content, additionalMembers);
        }
        callback(err, content);
    });
};

/**
 * Create a file as a pooled content item
 *
 * @param  {Context}   ctx                Standard context object containing the current user and the current tenant
 * @param  {String}    displayName        The display name for the file
 * @param  {String}    description        The description of the file [optional]
 * @param  {String}    visibility         The visibility setting for the piece of content. Possible values are "public", "loggedin" and "private" [optional]
 * @param  {Object}    additionalMembers  Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {Object}    file               A file object as returned by express.
 * @param  {Function}  callback           Standard callback function takes arguments `err` and `content`
 * @param  {Object}    callback.err       Error object containing the error message
 * @param  {Content}   callback.content   JSON object containing the pool id of the created content
 */
var createFile = module.exports.createFile = function(ctx, displayName, description, visibility, additionalMembers, file, callback) {
    // Wrap the callback function into a function that cleans up the file in case something went wrong.
    var cleanUpCallback = _getCleanUpCallback({'file': file}, callback);

    // Try to create the file.
    _createFile(ctx, displayName, description, visibility, additionalMembers, file, cleanUpCallback);
};

/**
 * Returns a function that will call the provided callback function.
 * In case the returned function gets called with an error object, the passed in file object will
 * be removed from the file system.
 *
 * @param  {Object}    files                The ExpressJS files object.
 * @param  {Function}  callback             Standard callback function takes arguments `err` and `content`
 * @param  {Object}    callback.err         Error object containing the error message
 * @param  {Content}   callback.content     JSON object containing the pool id of the created content
 * @return {Function}                       A function that removes the file on disk in case something went wrong.
 * @api private
 */
var _getCleanUpCallback = function(files, callback) {
    return function() {
        // Remember the arguments so we can pass them to the callback later.
        var callbackArguments = arguments;

        // The first argument is always the error object.
        var err = callbackArguments[0];

        if (err && files) {
            // Something went wrong with a request that has uploaded files associated to it.
            // In that case we try to remove the files.
            var fileObjects = _.values(files);
            _cleanupUploadedFiles(fileObjects, function() {
                 callback.apply(this, callbackArguments);
            });
        } else {
            // If we get here, the request might have failed, but it didn't contain an uploaded file.
            callback.apply(this, callbackArguments);
        }
    };
};

/**
 * Recursivaly iterates trough an array of uploaded files and removes them.
 *
 * @param  {Object[]}   files       An array of ExpressJS file objects.
 * @param  {Function}   callback    Standard callback method.
 * @api private
 */
var _cleanupUploadedFiles = function(files, callback) {
    if (files.length === 0) {
        return callback();
    }

    var file = files.pop();
    if (file && file.path) {
        fs.exists(file.path, function(exists) {
            if (exists) {
                fs.unlink(file.path, function(unlinkErr) {
                    if (unlinkErr) {
                        log().warn({'err': unlinkErr, 'file': file}, 'Could not remove the uploaded file.');
                    }
                    _cleanupUploadedFiles(files, callback);
                });
            } else {
                _cleanupUploadedFiles(files, callback);
            }
        });
    } else {
        _cleanupUploadedFiles(files, callback);
    }
};

/**
 * Create a file as a pooled content item
 *
 * @param  {Context}   ctx                Standard context object containing the current user and the current tenant
 * @param  {String}    displayName        The display name for the file
 * @param  {String}    description        The description of the file [optional]
 * @param  {String}    visibility         The visibility setting for the piece of content. Possible values are "public", "loggedin" and "private" [optional]
 * @param  {Object}    additionalMembers  Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {Object}    file               A file object as returned by express.
 * @param  {Function}  callback           Standard callback function takes arguments `err` and `content`
 * @param  {Object}    callback.err       Error object containing the error message
 * @param  {Content}   callback.content   JSON object containing the pool id of the created content
 * @api private
 */
var _createFile = function(ctx, displayName, description, visibility, additionalMembers, file, callback) {
    callback = callback || function() {};

    // Setting content to default if no visibility setting is provided
    visibility = visibility || Config.getValue(ctx.tenant().alias, 'visibility', 'files');

    var validator = new Validator();
    validator.check(file, {'code': 400, 'msg': 'Missing file parameter.'}).notNull();
    if (file) {
        validator.check(file.type, {'code': 400, 'msg': 'Missing mimetype on the file object.'}).notEmpty();
        validator.check(file.size, {'code': 400, 'msg': 'Missing size on the file object.'}).notEmpty();
        validator.check(file.size, {'code': 400, 'msg': 'Invalid size on the file object.'}).isInt();
        validator.check(file.size, {'code': 400, 'msg': 'Invalid size on the file object.'}).min(0);
        validator.check(file.name, {'code': 400, 'msg': 'Missing name on the file object.'}).notEmpty();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    // Create the content object.
    var otherValues = {
        'mime': file.type,
        'size': file.size,
        'filename': file.name
    };
    _createContent(ctx, 'file', displayName, description, visibility, additionalMembers, otherValues, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        // Store the actual file.
        contentObj.filename = file.name;
        contentObj.size = file.size;
        contentObj.mime = file.type;
        contentObj.downloadPath = '/api/content/' + contentObj.id + '/download';
        var options = { 'resourceId': contentObj.id };
        getStorageBackend(ctx).store(ctx, file, options, function(err, uri) {
            if (err) {
                return callback(err);
            }

            // Create the revision.
            _createRevision(ctx, contentObj.id, uri, otherValues, function(err) {
                if (err) {
                    return callback(err);
                }

                emitter.emit(ContentConstants.events.CREATED_CONTENT, ctx, contentObj, additionalMembers);
                callback(null, contentObj);
            });
        });
    });
};

/**
 * Create a Sakai document as a pooled content item
 * 
 * @param  {Context}   ctx                Standard context object containing the current user and the current tenant
 * @param  {String}    displayName        The display name for the Sakai Doc
 * @param  {String}    description        The description of the Sakai Doc [optional]
 * @param  {String}    visibility         The visibility setting for the piece of content. Possible values are "public", "loggedin" and "private" [optional]
 * @param  {Object}    additionalMembers  Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {Function}  callback           Standard callback function takes arguments `err` and `content`
 * @param  {Object}    callback.err       Error object containing the error message
 * @param  {Content}   callback.content   JSON object containing the pool id of the created content
 */
var createSakaiDoc = module.exports.createSakaiDoc = function(ctx, displayName, description, visibility, additionalMembers, callback) {
    callback = callback || function() {};

    // Setting content to default if no visibility setting is provided
    visibility = visibility || Config.getValue(ctx.tenant().alias, 'visibility', 'sakaidocs');

    _createContent(ctx, 'sakaidoc', displayName, description, visibility, additionalMembers, {}, function(err, content) {
        if (!err) {
            emitter.emit(ContentConstants.events.CREATED_CONTENT, ctx, content, additionalMembers);
        }
        callback(err, content);
    });
};

/**
 * Create a new piece of pooled content
 * 
 * @param  {Context}        ctx                Standard context object containing the current user and the current tenant
 * @param  {String}         contentType        The content type. Possible values are "file", "sakaidoc" and "link"
 * @param  {String}         displayName        The display name for the piece of content
 * @param  {String}         description        The description of the piece of content [optional]
 * @param  {String}         visibility         The visibility setting for the piece of content. Possible values are "public", "loggedin" and "private" [optional]
 * @param  {Object}         additionalMembers  Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {Object}         otherValues        JSON object where the keys represent other metadata values that need to be stored, and the values represent the metadata values
 * @param  {Function}       callback           Standard callback function takes arguments `err` and `content`
 * @param  {Object}         callback.err       Error object containing the error message
 * @param  {Content}        callback.content   JSON object containing the pool id of the created content
 * @api private
 */
var _createContent = function(ctx, contentType, displayName, description, visibility, additionalMembers, otherValues, callback) {
    callback = callback || function() {};

    // Use an empty description if no description has been provided
    description = description || '';
    // Make sure the otherValues and additionalMembers are valid objects
    additionalMembers = additionalMembers || {};
    otherValues = otherValues || {};

    // Parameter validation
    var validator = new Validator();
    validator.check(displayName, {'code': 400, 'msg': 'A content displayName must be provided'}).notEmpty();
    validator.check(visibility, {'code': 400, 'msg': 'An invalid content visibility option has been provided. This can be "private", "loggedin" or "public"'}).isIn(_.values(ContentConstants.visibility));
    validator.check(contentType, {'code': 400, 'msg': 'A content type must be provided. This can be "file", "sakaidoc" or "link"'}).isIn(ContentConstants.contentTypes);
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to create a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    // Generate the content id
    var contentId = AuthzUtil.toId('c', ctx.tenant().alias, ShortId.generate());

    // Set the created by, created and lastmodified properties
    var parameters = {
        'tenant': ctx.tenant().alias,
        'visibility': visibility,
        'displayName': displayName,
        'description': description,
        'contentType': contentType,
        'createdBy': ctx.user().id,
        'created': Date.now(),
        'previews': JSON.stringify({'status': 'pending'}) // TODO: Once b38dca296231b49709185bae64c80a77e9fb7fbd (Activities PR) gets merged in, the stringify statement can be dropped.
    };
    
    // Add the other values into the query
    parameters = _.extend(parameters, otherValues);
    var q = Cassandra.constructUpsertCQL('Content', 'contentId', contentId, parameters, 'QUORUM');

    // Create the content
    Cassandra.runQuery(q.query, q.parameters, function(err) {
        if (err) {
            return callback(err);
        }
        var contentObj = new Content(ctx.tenant().alias, contentId, visibility, displayName, description, contentType, parameters.createdBy, parameters.created);
        contentObj.previews = {'status': 'pending'};
        // Now make the current user a manager of the content
        additionalMembers[ctx.user().id] = ContentConstants.roles.MANAGER;
        _setContentPermissions(ctx, contentObj, additionalMembers, function(err) {
            if (err) {
                return callback(err);
            }
            callback(null, contentObj);
        });
    });
};

/////////////////////////////////
// Removing a piece of content //
/////////////////////////////////

/**
 * Delete a piece of content from the system
 * 
 * @param  {Context}   ctx               Standard context object containing the current user and the current tenant
 * @param  {String}    contentId         The content id of the content that is being deleted
 * @param  {Function}  callback          Standard callback function takes argument `err`
 * @param  {Object}    callback.err      Error object containing the error message
 */
var deleteContent = module.exports.deleteContent = function(ctx, contentId, callback) {
    callback = callback || function() {};

    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to delete a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Fist check whether or not the current user is a manager of the piece of content
    canManage(ctx, contentId, function(err, canManage, contentObj) {
        if (err) {
            return callback(err);
        } else if (!canManage) {
            return callback({'code': 401, 'msg': 'You are not allowed to manage this piece of content'});
        }
        
        // Delete the content
        Cassandra.runQuery('DELETE FROM Content WHERE contentId = ?', [contentId], function(err, rows) {
            if (err) {
                return callback(err);
            }

            emitter.emit(ContentConstants.events.DELETED_CONTENT, ctx, contentId);

            // Get the members
            _getAllContentMembers(contentId, function(err, members) {
                if (err) {
                    return callback(err);
                // Return if there are no members
                } else if (members.length === 0) {
                    return callback();
                }

                // Remove the roles and delete this from everyone's library
                var updateMembers = {};
                for (var m = 0; m < members.length; m++) {
                    updateMembers[members[m].id] = false;
                }
                // Note: We don't delete the revisions and filebodies in the request.
                // It's left to the maintainer to purge file bodies and revisions himself.
                _setContentPermissions(ctx, contentObj, updateMembers, callback);
            });
        }); 
    });
};

////////////////////////////
// Content access control //
////////////////////////////

/**
 * Share a piece of content with a set of principals. This only be possible when the current user is a manager of the content, or if the current
 * user is logged in and the content item is public or visible to logged in users only. In case that the content is shared with principals that
 * are already content members, no updates to the existing role of those principals will be made
 * 
 * @param  {Context}   ctx               Standard context object containing the current user and the current tenant
 * @param  {String}    contentId         The content id of the content that is being shared
 * @param  {String[]}  principalIds      Array of principal ids with whom the content will be shared. By default, they will all be made members.
 * @param  {Function}  callback          Standard callback function takes arguments `err` and `content`
 * @param  {Object}    callback.err      Error object containing the error message
 */
var shareContent = module.exports.shareContent = function(ctx, contentId, principalIds, callback) {
    callback = callback || function() {};
    
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(principalIds.length, {'code': 400, 'msg': 'The content must at least be shared with 1 user or group'}).min(1);
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to share content'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the user has access to the content
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        // Check if the content is visible to logged in users or public
        if (contentObj.visibility === ContentConstants.visibility.LOGGEDIN || contentObj.visibility === ContentConstants.visibility.PUBLIC) {
            _shareContent(ctx, contentObj, principalIds, callback);
        // Check if the user can manage the content
        } else {
            // It is possible that a content item that is owned by a tenant has been switched from public to private, but a user outside the
            // tenant that was previously manager can still share. However, restrictions inside _shareContent will stop them from sharing with
            // users outside the private tenant.
            _canManage(ctx, contentObj, function(err, canManage) {
                if (err) {
                    return callback(err);
                } else if (!canManage) {
                    return callback({'code': 401, 'msg': 'You are not allowed to share this content'});
                }
                _shareContent(ctx, contentObj, principalIds, callback);
            });
        }
    });
};

/**
 * Internal function used to share a piece of content with a set of principals. This function assume that the current user is allowed
 * to see and share the content. If some of the principals passed into this function are already content members, no updates to the
 * existing role of those principals will be made.
 *
 * @param  {Context}   ctx               The current execution context.
 * @param  {Content}   contentObj        Content object representing the content that is being shared
 * @param  {String[]}  principalIds      Array of principal ids with whom the content will be shared. By default, they will all be made members.
 * @param  {Function}  callback          Standard callback function takes arguments `err` and `content`
 * @param  {Object}    callback.err      Error object containing the error message
 * @api private
 */
var _shareContent = function(ctx, contentObj, principalIds, callback) {
    // Check if any of the passed in principal ids already have a direct role on the piece of content. We
    // filter those out to avoid turning an existing manager into a viewer
    AuthzAPI.getDirectRoles(principalIds, contentObj.id, function(err, roles) {
        if (err) {
            return callback(err);
        }

        var shareObject = {};
        for (var p = 0; p < principalIds.length; p++) {
            // Check if the principal already has a role on the content
            if (!roles[principalIds[p]]) {
                shareObject[principalIds[p]] = ContentConstants.roles.VIEWER;
            }
        }
        
        if (_.keys(shareObject).length === 0) {
            return callback(null);
        } else {
            _setContentPermissions(ctx, contentObj, shareObject, function(err) {
                if (err) {
                    return callback(err);
                }

                emitter.emit(ContentConstants.events.UPDATED_CONTENT_MEMBERS, ctx, contentObj, shareObject);
                return callback();
            });
        }
    });
};

/**
 * Check whether or not the current user can manage a piece of content
 * 
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the content object we want to check
 * @param  {Function}       callback            Standard callback function takes arguments `err`, `canManage`, and `content`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Boolean}        callback.canManage  Whether or not the user can manage the content
 * @param  {Content}        callback.content    The retrieved content object containing its basic profile
 */
var canManage = module.exports.canManage = function(ctx, contentId, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to manage content'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            if (err.code === 401) {
                return callback(null, false);
            } else {
                return callback(err);
            }
        }
        _canManage(ctx, contentObj, function(err, canManage) {
            if (err) {
                return callback(err);
            }
            return callback(null, canManage, contentObj);
        });
    });
};

/**
 * Internal function that checks whether or not the current user can manage a piece of content. This function assumes that
 * the piece of content passed in actually exists
 * 
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {Content}        contentObj          The content object we want to check
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `canManage`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Boolean}        callback.canManage  Whether or not the user can manage the content
 * @api private
 */
var _canManage = function(ctx, contentObj, callback) {
    if (!ctx.user()) {
        return callback(null, false);
    } else if (ctx.user().isAdmin(contentObj.tenant)) {
        return callback(null, true);
    }
    
    return AuthzAPI.hasRole(ctx.user().id, contentObj.id, ContentConstants.roles.MANAGER, callback);
};

/**
 * Check whether or not the current user has access to a piece of content
 * 
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the content object we want to check
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `hasAccess`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Boolean}        callback.hasAccess  Whether or not the user has access to the content
 */
var hasAccess = module.exports.hasAccess = function(ctx, contentId, callback) {
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            // If the user doesn't have access to the content
            if (err.code ===  401) {
                return callback(null, false);
            } else {
                return callback(err);
            }
        }

        return callback(null, true);
    });
};

/**
 * Internal function that checks whether or not the current user has access to a piece of content. This function assumes that
 * the piece of content passed in actually exists
 * 
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {Content}        contentObj          The content object representing the content item we're checking access for
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `canManage`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Boolean}        callback.canManage  Whether or not the user has access to the content
 * @api private
 */
var _hasAccess = function(ctx, contentObj, callback) {
    if (contentObj.visibility === ContentConstants.visibility.PUBLIC) {
        return callback(null, contentObj);
    // If the content is visible to logged in users, I get access if I'm logged in
    } else if (contentObj.visibility === ContentConstants.visibility.LOGGEDIN && TenantsUtil.isLoggedIn(ctx, contentObj.tenant)) {
        return callback(null, contentObj);
    // If the user is admin of the content's tenant, they have access
    } else if (ctx.user() && ctx.user().isAdmin(contentObj.tenant)) {
        return callback(null, contentObj);
    // If the content is private
    } else if (ctx.user()) {
        return AuthzAPI.hasAnyRole(ctx.user().id, contentObj.id, callback);
    }

    return callback({'code': 401, 'msg': "You don't have access to this piece of content."});
};

/**
 * Update, add or remove the role of a set of principals on a piece of content
 * 
 * @param  {Context}         ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}          contentId           The id of the content object we want to set permissions on
 * @param  {Object}          newPermissions      Object where the keys represent the principal ids for which the content permissions should be updated/added/removed. The value is a string representing the new role. If false is passed in, the permissions for that principal will be removed e.g. {'user1': 'manager', 'user2': 'viewer', 'user3': false}
 * @param  {Function}        callback            Standard callback function takes argument `err`
 * @param  {Object}          callback.err        Error object containing the error message
 */
var setContentPermissions = module.exports.setContentPermissions = function(ctx, contentId, newPermissions, callback) {
    callback = callback || {};
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(_.keys(newPermissions).length, {'code': 400, 'msg': 'You should specify at least 1 user/group to set content permissions on'}).min(1);
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to create a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the content exists
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        // Check if the current user can manage the content
        _canManage(ctx, contentObj, function(err, canManage) {
            if (err) {
                return callback(err);
            } else if (!canManage) {
                return callback({'code': 401, 'msg': 'You are not allowed to manage this piece of content'});
            }

            // Add the new permissions to the content. This will then update the libraries as well
            _setContentPermissions(ctx, contentObj, newPermissions, function(err) {
                if (err) {
                    return callback(err);
                }

                emitter.emit(ContentConstants.events.UPDATED_CONTENT_MEMBERS, ctx, contentObj, newPermissions);
                return callback();
            });
        });
    });
};

/**
 * Internal function used to update, add or remove the role of a set of principals on a piece of content. This function will assume that
 * the content object exists and that the current user is a manager of the content
 * 
 * @param  {Context}         ctx                 The current execution context
 * @param  {Content}         contentObj          The content object we want to set permissions on
 * @param  {Object}          newPermissions      Object where the keys represent the principal ids for which the content permissions should be updated/added/removed. The value is a string representing the new role. If false is passed in, the permissions for that principal will be removed e.g. {'user1': 'manager', 'user2': 'viewer', 'user3': false}
 * @param  {Function}        callback            Standard callback function takes argument `err`
 * @param  {Object}          callback.err        Error object containing the error message
 * @api private
 */
var _setContentPermissions = function(ctx, contentObj, newPermissions, callback) {
    // Check if all of the provided principals exist
    var principalIds = _.keys(newPermissions);
    PrincipalsUtil.getPrincipals(ctx, principalIds, function(err, principals) {
        if (err) {
            return callback(err);
        }

        // Extract all of the users that are removed from the content, so the content can be removed from their library
        var removedMembers = [];
        for (var i = 0; i < principalIds.length; i++) {
            var principalId = principalIds[i];
            if (newPermissions[principalId] === false) {
                removedMembers.push(principalId);
            } else if (!TenantsUtil.canInteract(contentObj.tenant, principals[principalId].tenant)) {
                // We shouldn't be sharing this with someone outside of this tenant
                return callback({'code': 401, 'msg': 'This content item cannot be shared with external user "' + principals[principalId].id + '".'});
            }
        }

        // Update the roles CF
        AuthzAPI.updateRoles(contentObj.id, newPermissions, function(err) {
            if (err) {
                return callback(err);
            }

            // Now update all of the libraries this affects
            _updateLibraries(contentObj, removedMembers, function(err) {
                if (err) {
                    // If there was an error updating libraries here, the permissions were still changed, so we should not return an error. Just log it.
                    log().warn({
                        'err': err,
                        'contentObj': contentObj,
                        'removedMembers': removedMembers
                    }, 'Failed to update user libraries after updating content permissions.');
                }

                return callback();
            });
        });
    });
};

/**
 * Get all of the principals that are directly associated to a piece of content.
 * 
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the content object for which we want to get the members
 * @param  {String}         start               Determines the point at which content members are returned for paging purposes.  If not provided, the first x elements will be returned
 * @param  {Integer}        limit               Number of items to return. Will default to 10 if not provided
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `members`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Object[]}       callback.members    Array that contains an object for each member. Each object has a role property that contains the role of the member and a profile property that contains the principal profile of the member
 */
var getContentMembers = module.exports.getContentMembers = function(ctx, contentId, start, limit, callback) {
    limit = limit || 10;

    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        // Get the content members
        AuthzAPI.getAuthzMembers(contentObj.id, start, limit, function(err, members) {
            if (err) {
                return callback(err);
            }

            // Get the basic profiles for all of these principals
            var memberIds = _.map(members, function(member){ return member.id; });
            PrincipalsUtil.getPrincipals(ctx, memberIds, function(err, memberProfiles) {
                if (err) {
                    return callback(err);
                }
                
                // Merge the member profiles and roles into a single object
                var memberList = [];
                for (var m = 0; m < members.length; m++) {
                    if (memberProfiles[members[m].id]) {
                        memberList.push({
                            'profile': memberProfiles[members[m].id],
                            'role': members[m].role
                        });
                    }
                }
                
                return callback(null, memberList);
            });
        });
    });
};

/**
 * Internal function that gets all of the principals that are directly associated to a piece of content. This function assumes
 * that the current user has access to the content
 * 
 * @param  {String}         contentId           The id of the content object for which we want to get the members
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `members`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Object[]}       callback.members    An array of hashes, where the 'id' property of the hash is the principal id, and the 'role' property of the hash is the role of the principal.
 * @api private
 */
var _getAllContentMembers = function(contentId, callback) {
    AuthzAPI.getAuthzMembers(contentId, null, 10000, callback);
};

/////////////////////////////
// Update content metadata //
/////////////////////////////

/**
 * Internal function that updates the lastMofidied date of a piece of content to the current time. This will be called by all functions
 * that update content metadata or when content is shared. This function assume that a valid content object is passed in.
 * 
 * @param  {Content}           contentObj          The content object for which we want to update the lastModified date
 * @param  {Function}          callback            Standard callback function takes argument `err`
 * @param  {Object}            callback.err        Error object containing the error message
 * @api private
 */
var _updateContentLastModified = function(contentObj, callback) {
    contentObj.lastModified = Date.now();
    Cassandra.runQuery('UPDATE Content USING CONSISTENCY QUORUM SET ? = ? WHERE contentId = ?', ['lastModified', contentObj.lastModified, contentObj.id], callback);
};

/**
 * Update the file body that is associated with a Sakai file.
 *
 * @param  {Context}    ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}     contentId           The ID of the content object that should be updated.
 * @param  {File}       file                An expressjs File object that holds the data for the file that needs updating.
 * @param  {Function}   [callback]          Standard callback function takes arguments `err` and `revision`
 * @param  {Object}     [callback.err]      Error object containing the error message
 */
var updateFileBody = module.exports.updateFileBody = function(ctx, contentId, file, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Error updating the filebody for %s', contentId);
        }
    };

    // Wrap the callback function into a function that cleans up the file in case something went wrong.
    var cleanUpCallback = _getCleanUpCallback({'file': file}, callback);

    // Perform the update.
    _updateFileBody(ctx, contentId, file, cleanUpCallback);
};

/**
 * Update the file body that is associated with a Sakai file.
 *
 * @param  {Context}    ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}     contentId           The ID of the content object that should be updated.
 * @param  {File}       file                An expressjs File object that holds the data for the file that needs updating.
 * @param  {Function}   [callback]          Standard callback function takes arguments `err` and `revision`
 * @param  {Object}     [callback.err]      Error object containing the error message
 * @api private
 */
var _updateFileBody = function(ctx, contentId, file, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a content item'}).isLoggedInUser(ctx);
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(file, {'code': 400, 'msg': 'Missing file parameter.'}).notNull();
    if (file) {
        validator.check(file.type, {'code': 400, 'msg': 'Missing mimetype on the file object.'}).notEmpty();
        validator.check(file.size, {'code': 400, 'msg': 'Missing size on the file object.'}).notEmpty();
        validator.check(file.size, {'code': 400, 'msg': 'Invalid size on the file object.'}).isInt();
        validator.check(file.size, {'code': 400, 'msg': 'Invalid size on the file object.'}).min(0);
        validator.check(file.name, {'code': 400, 'msg': 'Missing name on the file object.'}).notEmpty();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    canManage(ctx, contentId, function(err, isManager, contentObj) {
        if (err) {
            return callback(err);
        } else if (!isManager) {
            return callback({'code': 401, 'msg': 'You are not allowed to manage this piece of content'});
        } else if (contentObj.contentType !== 'file') {
            return callback({'code': 400, 'msg': 'This content object is not a file.'});
        }

        // Store the file
        // Use the current time as the "folder name".
        var options = {
            'resourceId': contentObj.id,
            'prefix': Date.now()
        };
        getStorageBackend(ctx).store(ctx, file, options, function(err, uri) {
            if (err) {
                return callback(err);
            }

            // Create the revision.
            var opts = {
                'mime': file.type,
                'size': file.size,
                'filename': file.name
            };
            _createRevision(ctx, contentObj.id, uri, opts, function(err, revision) {
                if (err) {
                    return callback(err);
                }

                // Set the new filesize, filename and mimetype on the Content object so the UI
                // can retrieve all the relevant metadata in 1 Cassandra query.
                var q = Cassandra.constructUpsertCQL('Content', 'contentId', contentId, opts, 'QUORUM');
                Cassandra.runQuery(q.query, q.parameters, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    emitter.emit(ContentConstants.events.UPDATED_CONTENT_BODY, ctx, contentObj, opts);
                    callback();
                });
            });
        });
    });
};

/**
 * Attaches preview items to, or set the status of, a piece of content.
 * This can only be used by a global admin and should technically only be executed by the preview processor.
 *
 * @param {Context}     ctx             Current execution context.
 * @param {String}      contentId       The ID of the content item.
 * @param {String}      status          The result of the preview processing operation. It should be one of the values of ContentConstants.previews.
 * @param {Object}      [files]         An expressjs files object. The keys are the POST parameter under which the file is submitted, the value is an expressjs File object.
 * @param {Object}      [sizes]         Each key maps a filename to a preview size.
 * @param {Object}      [metadata]      An object that holds optional metadata, data like pageCount for example can be passed in here.
 * @param {Function}    callback        Standard callback method
 * @param {Object}      callback.err    Standard error object (if any.)
 */
var setPreviewItems = module.exports.setPreviewItems = function(ctx, contentId, status, files, sizes, metadata, callback) {
    files = files || {};
    sizes = sizes || {};
    metadata = metadata || {};

    // Wrap the callback method, which takes care of cleaning up the files if something goes wrong.
    var cleanUpCallback = _getCleanUpCallback(files, callback);

    // Check for authentication before we do any expensive checks.
    if (!ctx.user() || !ctx.user().isGlobalAdmin()) {
        return cleanUpCallback({'code': 401, 'msg': 'Only administrators can attach preview items to a content item.'});
    }

    var validStatuses = _.values(ContentConstants.previews);
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'Missing or invalid contentId'}).isResourceId();
    validator.check(status, {'code': 400, 'msg': 'The status parameter must be one of: ' + validStatuses.join(', ')}).isIn(validStatuses);
    if (validator.hasErrors()) {
        return cleanUpCallback(validator.getFirstError());
    }

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return cleanUpCallback(err);
        }

        var fileData = {};
        var thumbnailUri = null;
        var fileKeys = Object.keys(files);
        var todo = fileKeys.length;
        // Preview generation failed or no files were uploaded, store that information in the database.
        if (status === ContentConstants.previews.ERROR || todo === 0) {
            return _storePreviewData(ctx, contentObj, status, thumbnailUri, metadata, fileData, cleanUpCallback);
        }

        // Preview generation was successful, store the files.
        var called = false;
        var storePrefix = 'previews/' + Date.now();
        fileKeys.forEach(function(key) {
            var size = sizes[key];
            if (!size) {
                todo--;
                log().warn("Ignoring file %s as it has no size associated to it", key);
                return;
            }

            // Store the file with a regular storage backend.
            var options = {
                'resourceId': contentObj.id,
                'prefix': storePrefix
            };
            getStorageBackend(ctx).store(ctx, files[key], options, function(err, uri) {
                todo--;
                if (err && !called) {
                    called = true;
                    return cleanUpCallback(err);
                }

                // We use the filename as the column name as there is a requirement that the UI can have
                // sequential URLs. It's up to the preview processor to provide these sequential URLs.
                // ie: ../download/page1.png, ../download/page2.png, ...
                // Rather than having an extra columnfamily to store a single piece of metadata (the size),
                // we store it next to the URI.
                fileData[files[key].name] = size + '#' + uri;

                // Remember the thumbnail uri separately so we can stick it on the main content object.
                if (size === 'thumbnail') {
                    thumbnailUri = uri;
                }

                if (todo === 0 && !called) {
                    // All files have been stored.
                    called = true;
                    log().trace({'data': fileData}, 'Storing %d content preview files.', fileKeys.length);
                    _storePreviewData(ctx, contentObj, status, thumbnailUri, metadata, fileData, cleanUpCallback);
                }
            });
        });
    });
};

/**
 * Stores preview metadata on the Content object in Cassandra.
 * This method will:
 *  1/ Remove old preview items associated to the piece of content (if any)
 *  2/ Remove the old thumbnailUri (if one was present), if `thumbnailUri` is not defined.
 *  3/ Store the new preview URIs (if any)
 *  4/ Update the previews object in the Content CF.
 * TODO: This method can be refactored/removed once the DAO is in place.
 *
 * @param {Context}     ctx             Current execution context.
 * @param {Content}     contentObj      The ID of the piece of content for which we need to update the preview metadata.
 * @param {String}      status          The result of the preview processing operation. It should be one of the values of ContentConstants.previews.
 * @param {String}      thumbnailUri    The uri of a thumbnail
 * @param {Object}      metadata        Each key corresponds to a string value that should be stored on the content object.
 * @param {Object}      fileData        Each key corresponds to a filename, the value is of the form 'size#uri'.
 * @param {Function}    callback        Standard callback method
 * @param {Object}      callback.err    Standard error object (if any.)
 */
var _storePreviewData = function(ctx, contentObj, status, thumbnailUri, metadata, fileData, callback) {
    var queries = [];
    // 1. Remove the old previews
    if (contentObj.previews.total && contentObj.previews.total > 0) {
        queries.push({
            'query': 'DELETE FROM ContentPreviews WHERE contentId = ?',
            'parameters': [contentObj.id]
        });
    }

    // 2. Remove the thumbnail URI if we don't add in a new one.
    if (contentObj.thumbnailUri && !thumbnailUri) {
        queries.push({
            'query': 'DELETE thumbnailUri FROM Content WHERE contentId = ?',
            'parameters': [contentObj.id]
        });
    }
    // 3. Add in the new preview items (if any.)
    var nrOfFiles = Object.keys(fileData).length;
    if (nrOfFiles > 0) {
        queries.push(Cassandra.constructUpsertCQL('ContentPreviews', 'contentId', contentObj.id, fileData));
    }

    // 4. Store the previews object.
    var data = {'status': status, 'total': nrOfFiles};
    // Set the thumbnail URI if we have one.
    if (thumbnailUri) {
        data.thumbnailUri = thumbnailUri;
    }
    // Pass in data second, in case metadata contains a status or thumbnailUri key.
    var previews = _.extend({}, metadata, data);
    contentObj.previews = previews;

    previews = JSON.stringify(previews);
    queries.push({
        'query': 'UPDATE Content SET previews = ? WHERE contentId = ?',
        'parameters': [previews, contentObj.id]
    });

    // Save the data.
    Cassandra.runBatchQuery(queries, 'QUORUM', function(err) {
        if (err) {
            return callback(err);
        }

        // Fire an event so we can update the search index.
        emitter.emit(ContentConstants.events.UPDATED_CONTENT_PREVIEW, ctx, contentObj.id, contentObj);

        callback();
    });
};

/**
 * Verifies the signature for a preview item that is associated to a piece of content.
 * If the signature is valid, an object will be returned that the REST handlers can use
 * to redirect the user to the actual file.
 *
 * @param  {Context}    ctx                     The current context.
 * @param  {String}     contentId               The content ID that the preview item is associated with.
 * @param  {String}     previewItem             The preview item that needs to be retrieved.
 * @param  {Object}     signature               A signature that validates this call.
 * @param  {String}     signature.signature     A signature that validates this call.
 * @param  {Number}     signature.expires       When the signature expires (in millis since epoch.)
 * @param  {Number}     signature.lastModified  When the signature expires (in millis since epoch.)
 * @param  {Function}   callback                Standard callback method.
 * @param  {Object}     callback.err            Standard error object (if any)
 * @param  {Object}     callback.link           Object that holds a `code` and `link`.
 */
var verifySignedPreviewItem = module.exports.verifySignedPreviewItem = function(ctx, contentId, previewItem, signature, callback) {
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'Missing content ID'}).notEmpty();
    validator.check(previewItem, {'code': 400, 'msg': 'Missing preview item'}).notEmpty();
    validator.check(null, {'code': 400, 'msg': 'Missing signature object'}).isObject(signature);
    if (_.isObject(signature)) {
        validator.check(signature.signature, {'code': 400, 'msg': 'Missing signature'}).notEmpty();
        validator.check(signature.expires, {'code': 400, 'msg': 'Missing expires'}).notEmpty();
        validator.check(signature.expires, {'code': 400, 'msg': 'Invalid expires parameter'}).isInt();
        validator.check(signature.lastModified, {'code': 400, 'msg': 'Missing lastModified parameter'}).notEmpty();
        validator.check(signature.lastModified, {'code': 400, 'msg': 'Invalid lastModified parameter'}).isInt();
        var tenantAlias = (contentId) ? AuthzUtil.getResourceFromId(contentId).tenantAlias : '';
        var principalId = (ctx.user()) ? ctx.user().id : '';
        var expires = (signature.expires) ? signature.expires : 0;
        var lastModified = (signature.lastModified) ? signature.lastModified : 0;
        var body = principalId + ':' + contentId + ':' + lastModified;
        validator.check(signature.signature, {'code': 401, 'msg': 'Invalid signature.'}).verifyExpiringSignature(tenantAlias, expires, body);
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    Cassandra.runQuery('SELECT ? FROM ContentPreviews WHERE contentId = ?', [previewItem, contentId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        // Cassandra always returns a row with the rowKey as a column so there is always at least 1 row.
        // We retrieve a column that has the same name as requested preview item to verify it exists.
        var col = rows[0].get(previewItem);
        if (!col) {
            return callback({'code': 404, 'msg': "Couldn't find item " + previewItem + " for contentId: " + contentId});
        }

        var data = col.value.split('#');
        var uri = data[1];
        var link = getStorageBackend(ctx, uri).getDownloadLink(ctx, uri);
        var result = {
            'opts': {
                'filename': previewItem
            },
            'link': link
        };
        callback(null, result);
    });
};

/**
 * Get the entire list of preview items that are associated to a content item.
 *
 * @param {Context}     ctx                 The current context.
 * @param {String}      contentId           The ID of the content you wish to retrieve the preview items for
 * @param {Function}    callback            Standard callback method.
 * @param {Object}      callback.err        Standard error object.
 * @param {Object}      callback.results    Object with a key `files` that holds an array of strings that are the filenames for previews and a key `signature` which holds the signature and expires parameters that should be sent when retrieving the preview bodies.
 */
var getPreviewItems = module.exports.getPreviewItems = function(ctx, contentId, callback) {
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        Cassandra.runQuery('SELECT * FROM ContentPreviews WHERE contentId = ?', [contentId], function(err, rows) {
            if (err) {
                return callback(err);
            }

            // If there are no previews we'll return an empty array.
            // Generate an expiring signature.
            var signature = ContentUtil.signContent(ctx, contentId, contentObj.lastModified);

            // Dump the files
            var filenames = Cassandra.rowToHash(rows[0]);
            delete filenames.contentId;
            var files = [];
            _.each(filenames, function(value, filename) {
                var data = value.split('#');
                var size = data[0];
                files.push({
                    'filename': filename,
                    'size': size
                });
            });
            var result = {
                'files': files,
                'signature': signature
            };

            callback(null, result);
        });
    });
};

/**
 * Update a content item's displayName, description or visibility. This can only be done by the manager of that piece of content.
 *
 * @param  {Context}         ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}          contentId           The id of the content object for which we want to update the content profile
 * @param  {Object}          profileFields       Object where the keys represent the profile fields that need to be updated and the values represent the new values for those profile fields e.g. {'displayName': 'New content name', 'description': 'New content description', 'visibility': 'private'}
 * @param  {Function}        callback            Standard callback function takes argument `err`
 * @param  {Object}          callback.err        Error object containing the error message
 */
var updateContentMetadata = module.exports.updateContentMetadata = function(ctx, contentId, profileFields, callback) {
    callback = callback || function() {};
    
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    // Check that at a minimum name or description have been provided
    var fieldNames = profileFields ? _.keys(profileFields) : [];
    validator.check(fieldNames.length, {'code': 400, 'msg': 'You should at least specify a new displayName, description, visibility or link'}).min(1);
    for (var i = 0; i < fieldNames.length; i++) {
        var fieldName = fieldNames[i];
        validator.check(fieldName, {'code': 400, 'msg': fieldName + ' is not a recognized content profile field'}).isIn(['displayName', 'description', 'visibility', 'link']);
    }
    if (profileFields.hasOwnProperty('visibility')) {
        validator.check(profileFields['visibility'], {'code': 400, 'msg': 'An invalid content visibility option has been provided. This can be "private", "loggedin" or "public"'}).isIn(_.values(ContentConstants.visibility));
    }
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Do the actual update
    _updateContentMetadata(ctx, contentId, profileFields, callback);
};

/**
 * Utility function that will be used to update metadata on a piece of content. Once the Content CF has been updated,
 * the libraries in which the content shows will be updated as well. This function will assume that a valid contentId
 * and valid content metadata is passed in
 *
 * @param  {Context}         ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}          contentId           The id of the content object we want to update
 * @param  {Object}          metadata            Object where the keys represent the profile fields that need to be updated and the values represent the new values for those profile fields.
 * @param  {Function}        callback            Standard callback function takes argument `err`
 * @param  {Object}          callback.err        Error object containing the error message
 * @api private
 */
var _updateContentMetadata = function(ctx, contentId, metadata, callback) {
    // Fist check whether or not the current user is a manager of the piece of content
    canManage(ctx, contentId, function(err, canManage, oldContentObj) {
        if (err) {
            return callback(err);
        } else if (!canManage) {
            return callback({'code': 401, 'msg': 'You are not allowed to manage this piece of content'});
        }

        var q = Cassandra.constructUpsertCQL('Content', 'contentId', contentId, metadata, 'QUORUM');
        Cassandra.runQuery(q.query, q.parameters, function(err) {
            if (err) {
                return callback(err);
            }

            // Create the new content object by merging in the metadata changes over the old content object
            var newContentObj = _.extend({}, oldContentObj, metadata);

            emitter.emit(ContentConstants.events.UPDATED_CONTENT, ctx, newContentObj, oldContentObj);

            // Update the last modified date and all associated libraries
            _updateLibraries(newContentObj, [], callback);
        });
    });
};


// TODO: Split this out once we reorganize the content API
///////////////////////////
// Comment functionality //
///////////////////////////

/**
 * Retrieves a single comment from Cassandra and returns a Comment object in the callback function.
 *
 *  TODO: Do not export _getComment once we reorganize the content API. Will be accessible through a DAO method
 *
 * @param  {Context}    ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}     commentId           The ID of the comment
 * @param  {Function}   callback            Standard callback function takes argument `err` and `comment`
 * @param  {Object}     callback.err        Error object containing the error message
 * @param  {Comment}    callback.comment    The retrieved comment object
 * @api private
 */
var _getComment = module.exports._getComment = function(commentId, callback) {
    var validator = new Validator();
    validator.check(commentId, {'code': 400, 'msg': 'A comment id must be provided'}).isResourceId();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    Cassandra.runQuery('SELECT * FROM Comments USING CONSISTENCY QUORUM WHERE commentId = ?', [commentId], function (err, commentRows) {
        if (err) {
            return callback(err);
        }

        callback(err, _rowsToComments(commentRows)[0]);
    });
};

/**
 * Creates a comment on the specified content item. Returns an error if saving the comment goes wrong or the user doesn't have access.
 * Only logged in users who can see the content are able to post comments.
 *
 * @param  {Context}    ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}     contentId           The ID of the content to place the comment on
 * @param  {String}     body                The comment to place on the content item
 * @param  {String}     [replyTo]           The ID of the comment to reply to, optional
 * @param  {Function}   [callback]          Standard callback function takes argument `err`
 * @param  {Object}     [callback.err]      Error object containing the error message
 * @param  {Comment}    [callback.comment]  The created comment
 */
var createComment = module.exports.createComment = function(ctx, contentId, body, replyTo, callback) {
    callback = callback || function() {};

    // Parameter validation
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authorized users can post comments'}).isLoggedInUser(ctx);
    validator.check(contentId, {'code': 400, 'msg': 'Invalid content resource id provided.'}).isResourceId();
    validator.check(body, {'code': 400, 'msg': 'A comment must be provided'}).notEmpty();
    if (replyTo) {
        validator.check(replyTo, {'code': 400, 'msg': 'Invalid replyTo id provided.'}).isResourceId();
    }

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    hasAccess(ctx, contentId, function(err, hasAccess) {
        if (err) {
            return callback(err);
        }

        if (!hasAccess) {
            return callback({'code': 401, 'msg': 'Only authorized users can post comments'});
        }

        // Generate a unique comment ID
        var commentId = AuthzUtil.toId('comm', ctx.tenant().alias, ShortId.generate());

        if (replyTo) {
            _getComment(replyTo, function(err, commentReplyingTo) {
                if (err) {
                    return callback(err);
                }

                if (commentReplyingTo.contentId !== contentId) {
                    return callback({'code': 400, 'msg': 'The specified comment id is not associated to the specified content id'});
                }

                // Add comment to CommentsByContent CF
                // When replying to a comment the `|` needs to be replaced by a `#` to ensure correct ordering of the returned comments (threaded)
                // A reply on a comment looks like timestampA#timestampB| where a top level comment looks like timestampA|
                var created = commentReplyingTo.created.split('|')[0] + '#' + Date.now() + '|';
                var q = 'UPDATE CommentsByContent USING CONSISTENCY QUORUM SET ? = ? WHERE contentId = ?';
                Cassandra.runQuery(q, [created, commentId, contentId], function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Add comment to Comments CF
                    q = 'INSERT INTO Comments (commentId, body, createdBy, replyTo, level, contentId, created) VALUES (?, ?, ?, ?, ?, ?, ?)';
                    Cassandra.runQuery(q, [commentId, body, ctx.user().id, commentReplyingTo.commentId, commentReplyingTo.level + 1, contentId, created], function(err) {
                        if (err) {
                            return callback(err);
                        }

                        var comment = new Comment(commentId, body, contentId, ctx.user(), created, commentReplyingTo.level + 1, commentReplyingTo.commentId, false);
                        emitter.emit(ContentConstants.events.CREATED_COMMENT, ctx, comment);
                        return callback(null, comment);
                    });
                });
            });
        } else {
            // Generate a timestamp, add the `|` for correct sorting of threaded comments
            var created = Date.now() + '|';
            var queries = [{
                'query': 'INSERT INTO Comments (commentId, body, createdBy, created, contentId) VALUES (?, ?, ?, ?, ?)',
                'parameters': [commentId, body, ctx.user().id, created, contentId]
            }, {
                'query': 'UPDATE CommentsByContent SET ? = ? WHERE contentId = ?',
                'parameters': [created, commentId, contentId]
            }];
            Cassandra.runBatchQuery(queries, 'QUORUM', function(err) {
                if (err) {
                    return callback(err);
                }

                var comment = new Comment(commentId, body, contentId, ctx.user(), created, 0, null, false);
                emitter.emit(ContentConstants.events.CREATED_COMMENT, ctx, comment);
                return callback(null, comment);
            });
        }
    });
};

/**
 * Retrieves the comments for a specified content item. Everyone who has access to the content item will be able to retrieve the list of comments.
 *
 * @param  {Context}    ctx                  Standard context object, representing the currently logged in user and its tenant
 * @param  {String}     contentId            The ID of the content to get comments for
 * @param  {String}     start                Determines the point at which content items are returned for paging purposed. If not provided, the first x elements will be returned
 * @param  {Integer}    limit                Number of items to return. Will default to 10 if not provided
 * @param  {Function}   callback             Standard callback function takes argument `err` and `comments`
 * @param  {Object}     callback.err         Error object containing the error message
 * @param  {Comment[]}  callback.comments    An array of Comment objects
 */
var getComments = module.exports.getComments = function(ctx, contentId, start, limit, callback) {
    limit = limit || 10;

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        _getComments(contentId, start, limit, function(err, comments) {
            if (err) {
                return callback(err);
            }

            // Get information on the commenters
            var userIds = {};
            for (var i = 0; i < comments.length; i++) {
                // Filter out duplicates
                if (comments[i].createdBy) {
                    userIds[comments[i].createdBy] = true;
                }
            }
            userIds = _.keys(userIds);

            // Get the basic principal profiles of the commenters to add to the comments as `createdBy`.
            PrincipalsUtil.getPrincipals(ctx, userIds, function(err, principals) {
                if (err) {
                    return callback(err);
                }

                for (var i = 0; i < comments.length; i++) {
                    comments[i].createdBy = principals[comments[i].createdBy];
                }

                return callback(err, comments);
            });
        });
    });
};

/**
 * Retrieves the comments for a specified content item. This does not perform any permission checks
 *
 *  TODO: When ContentAPI is refactored to have a DAO layer, this method should be moved in there so as to not export it from the API.
 *
 * @param  {String}     contentId            The ID of the content to get comments for
 * @param  {String}     start                Determines the point at which content items are returned for paging purposed. If not provided, the first x elements will be returned
 * @param  {Integer}    limit                Number of items to return. Will default to 10 if not provided
 * @param  {Function}   callback             Standard callback function takes argument `err` and `comments`
 * @param  {Object}     callback.err         Error object containing the error message
 * @param  {Comment[]}  callback.comments    The comments starting from the `start`.
 */
var _getComments = module.exports._getComments = function(contentId, start, limit, callback) {
    // Page the query.
    var paging = Cassandra.getPagingParameters(start, limit);

    // Select first X comments from the CommentsByContent CF
    Cassandra.runQuery('SELECT FIRST ' + paging.limit + ' REVERSED ?..\'\' FROM CommentsByContent USING CONSISTENCY QUORUM WHERE contentId = ?', [paging.start, contentId], function (err, rows) {
        if (err) {
            return callback(err);
        }

        var row = rows[0];
        if (!row.count) {
            return callback(null, []);
        }

        // Get detailed comment information
        var commentIds = [];
        for (var i = paging.startIndex; i < row.count; i++) {
            commentIds.push(row[i].value);
        }

        if (commentIds.length === 0) {
            return callback(null, []);
        }

        Cassandra.runQuery('SELECT * FROM Comments USING CONSISTENCY QUORUM WHERE commentId IN (?)', [commentIds], function (err, commentsRows) {
            if (err) {
                return callback(err);
            }

            if (commentsRows.length === 0) {
                return callback(null, []);
            }

            // Add comments to the Array to return
            var comments = _rowsToComments(commentsRows);
            for (var ii = 0; ii < comments.length; ii++) {
                // When a comment is deleted not all data needs to go back to the UI. The level
                // will be used to determine the comment's indentation, and created will be used
                // for paging purposes
                if (comments[ii].deleted === true) {
                    comments[ii] = new Comment(comments[ii].commentId, null, null, null, comments[ii].created, comments[ii].level, comments[ii].replyTo, true);
                }
            }

            return callback(null, comments);
        });
    });
};

/**
 * Deletes a comment from a content item. Managers of the content can delete all comments whilst people that have access
 * to the content can only delete their own comments. Therefore, anonymous users will never be able to delete comments.
 *
 * @param  {Context}    ctx                     Standard context object, representing the currently logged in user and its tenant
 * @param  {String}     contentId               The ID of the content to delete the comment from
 * @param  {String}     commentId               The ID of the comment
 * @param  {Function}   callback                Standard callback function takes argument `err`
 * @param  {Object}     callback.err            Error object containing the error message
 * @param  {Comment}    [callback.softDeleted]  When the comment has been soft deleted (because it has replies), a stripped down comment object representing the deleted comment will be returned, with the `deleted` parameter set to `false`. If the comment has been deleted from Cassandra, no comment object will be returned.
 */
var deleteComment = module.exports.deleteComment = function(ctx, contentId, commentId, callback) {

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authorized users can delete comments'}).isLoggedInUser(ctx);
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(commentId, {'code': 400, 'msg': 'A comment id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        _getComment(commentId, function(err, comment) {
            if (err) {
                return callback(err);
            }

            if (comment.contentId !== contentId) {
                return callback({'code': 400, 'msg': 'The specified comment id is not associated to the specified content id'});
            }

            // Besides having access to the content the comment needs to be authored by the user
            // or the user needs to be a content manager.
            _canManage(ctx, contentObj, function(err, canManage) {
                if (err) {
                    return callback(err);
                }

                var canDelete = (canManage || ctx.user().id === comment.createdBy);
                if (!canDelete) {
                    return callback({'code': 401, 'msg': 'You don\t have the appropriate priviliges to delete this comment'});
                }

                // The content exists and we have access
                // Get the comment and the comment following it to check if there's a reply.
                getComments(ctx, contentId, comment.created, 1, function(err, comments) {
                    if (err) {
                        return callback(err);
                    }

                    if (comments.length > 0 && comments[0].replyTo === commentId) {
                        // If there is a reply, mark the message as deleted but don't delete
                        var q = 'UPDATE Comments USING CONSISTENCY QUORUM SET deleted = ? WHERE commentId = ?';
                        Cassandra.runQuery(q, [true, commentId], function(err) {
                            // Construct the stripped down deleted comment object and set deleted to false
                            var softDeleted = new Comment(comment.commentId, null, comment.contentId, null, comment.created, comment.level, comment.replyTo, false);
                            callback(err, softDeleted);
                        });
                    } else {
                        var queries = [{
                            'query': 'DELETE ? FROM CommentsByContent WHERE contentId = ?',
                            'parameters': [comment.created, comment.contentId]
                        }, {
                            'query': 'DELETE FROM Comments WHERE commentId = ?',
                            'parameters': [comment.commentId]
                        }];
                        Cassandra.runBatchQuery(queries, 'QUORUM', callback);
                    }
                });
            });
        });
    });
};


///////////////////////////
// Library functionality //
///////////////////////////

/**
 * Internal function that updates the libraries of all of the members of a piece of content. This will remove the old entry with
 * the old lastModified date/sorting and add the new one. This function assumes that a valid content item is passed in
 * 
 * @param  {Content}        contentObj          The content object for which we want to update in all libraries
 * @param  {String[]}       removedMembers      Array of principal ids that contains all principal that have been removed as a member of the content, and therefore their libraries should be updated so the content is removed.
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `members`
 * @param  {Object}         callback.err        Error object containing the error message
 * @api private
 */
var _updateLibraries = function(contentObj, removedMembers, callback) {
    // First update the lastmodified date of the content
    var oldLastModified = contentObj.lastModified;
    _updateContentLastModified(contentObj, function(err) {
        if (err) {
            return callback(err);
        }
        // Remove all of the old lastModified from everyone's library and add the new lastModified based one
        removedMembers = removedMembers || [];
        _getAllContentMembers(contentObj.id, function(err, members) {
            if (err) {
                return callback(err);
            }
            var queries = [];
            for (var m = 0; m < members.length; m++) {
                var member = members[m].id;
                // Only remove the old entries if the piece of content existed before and
                // the old lastModified date has been provided
                if (oldLastModified) {
                    // Remove the old entry in the private row
                    queries.push({
                        'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                        'parameters': [oldLastModified + ':' + contentObj.id, member]
                    });
                    // Remove the old entry in the loggedin row
                    queries.push({
                        'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                        'parameters': [oldLastModified + ':' + contentObj.id, member + '#' + ContentConstants.visibility.LOGGEDIN]
                    });
                    // Remove the old entry in the public row
                    queries.push({
                        'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                        'parameters': [oldLastModified + ':' + contentObj.id, member + '#' + ContentConstants.visibility.PUBLIC]
                    });
                }
                // Add it back to the private row
                queries.push({
                    'query': 'UPDATE LibraryByPrincipal SET ? = ? WHERE principalId = ?',
                    'parameters': [contentObj.lastModified + ':' + contentObj.id, contentObj.id, member]
                });
                // Add it back to the logged in row
                if (contentObj.visibility === ContentConstants.visibility.LOGGEDIN || contentObj.visibility === ContentConstants.visibility.PUBLIC) {
                    queries.push({
                        'query': 'UPDATE LibraryByPrincipal SET ? = ? WHERE principalId = ?',
                        'parameters': [contentObj.lastModified + ':' + contentObj.id, contentObj.id, member + '#' + ContentConstants.visibility.LOGGEDIN]
                    });
                }
                // Add it back to the public row
                if (contentObj.visibility === ContentConstants.visibility.PUBLIC) {
                    queries.push({
                        'query': 'UPDATE LibraryByPrincipal SET ? = ? WHERE principalId = ?',
                        'parameters': [contentObj.lastModified + ':' + contentObj.id, contentObj.id, member + '#' + ContentConstants.visibility.PUBLIC]
                    });
                }
            }
            // Remove the content from the libraries of all removed members
            for (var r = 0; r < removedMembers.length; r++) {
                if (oldLastModified) {
                    var removedMember = removedMembers[r];
                    // Remove the old entry in the private row
                    queries.push({
                        'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                        'parameters': [oldLastModified + ':' + contentObj.id, removedMember]
                    });
                    // Remove the old entry in the loggedin row
                    queries.push({
                        'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                        'parameters': [oldLastModified + ':' + contentObj.id, removedMember + '#' + ContentConstants.visibility.LOGGEDIN]
                    });
                    // Remove the old entry in the public row
                    queries.push({
                        'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                        'parameters': [oldLastModified + ':' + contentObj.id, removedMember + '#' + ContentConstants.visibility.PUBLIC]
                    });
                }
            }
            Cassandra.runBatchQuery(queries, 'QUORUM', callback);
        });
    });
};

/**
 * Get the content items inside of an authorizable's library. If the user requests its own library or the library of a group he's a member of,
 * the full list will be returned. If the user is logged in, but not a manager of the library, the :loggedin stream will be returned, containing
 * only content that's visible to logged in people or the public. In case of an anonymous user, the :public stream will be returned, containing
 * only content that is public.
 * 
 * @param  {Context}        ctx               Standard context object containing the current user and the current tenant
 * @param  {String}         principalId       The principal id of the library we're requesting
 * @param  {String}         start             Determines the point at which content items are returned for paging purposed. If not provided, the first x elements will be returned
 * @param  {Integer}        limit             Number of items to return. Will default to 10 if not provided
 * @param  {Function}       callback          Standard callback function takes arguments `err` and `content`
 * @param  {Object}         callback.err      Error object containing the error message
 * @param  {Content[]}      callback.content  Array of basic content profiles representing the requested items in the library
 */
var getLibraryItems = module.exports.getLibraryItems = function(ctx, principalId, start, limit, callback) {
    limit = limit || 10;

    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'A user or group id must be provided'}).notEmpty();
    validator.check(limit, {'code': 400, 'msg': 'A valid limit should be passed in'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    /**
     * Augments passed in content object with a signature and thumbnail URL (if any.)
     *
     * @param  {Object}     err             Standard error object
     * @param  {Object[]}   contentObjects  An array of content objects.
     */
    var augment = function(err, contentObjects) {
        if (err) {
            return callback(err);
        }
        _.each(contentObjects, function(contentObj) {
            _augmentContent(ctx, contentObj);
        });
        callback(null, contentObjects);
    };

    var principal = AuthzUtil.getPrincipalFromId(principalId);
    // Check if we are looking at a user library
    if (PrincipalsUtil.isUser(principalId)) {
        // We give the user the public content stream in case the user is not logged in to the user's tenant
        if (!TenantsUtil.isLoggedIn(ctx, principal.tenantAlias)) {
            principalId = principalId + '#' + ContentConstants.visibility.PUBLIC;
        // We give the user the logged in content stream in case the current user is not
        // the same as the library we're looking at
        } else if (ctx.user().id !== principalId) {
            principalId = principalId + '#' + ContentConstants.visibility.LOGGEDIN;
        }
        
        return ContentDAO.getLibraryItems(principalId, start, limit, augment);
    // Check if we are looking at a group library
    } else if (PrincipalsUtil.isGroup(principalId)) {
        // We give the user the public content stream in case the user is not logged in
        if (!ctx.user()) {
            principalId = principalId + '#' + ContentConstants.visibility.PUBLIC;
            return ContentDAO.getLibraryItems(principalId, start, limit, augment);
        } else {
            // Check if the current user is a member of the group
            AuthzAPI.hasAnyRole(ctx.user().id, principalId, function(err, hasAnyRole) {
                if (err) {
                    return callback(err);
                }

                // If the user is not a member, but is authenticated to the group's tenant, we give him the logged in content stream
                if (!hasAnyRole && TenantsUtil.isLoggedIn(ctx, principal.tenantAlias)) {
                    principalId = principalId + '#' + ContentConstants.visibility.LOGGEDIN;
                // Otherwise, we give them public library
                } else if (!hasAnyRole) {
                    principalId = principalId + '#' + ContentConstants.visibility.PUBLIC;
                }

                return ContentDAO.getLibraryItems(principalId, start, limit, augment);
            });
        }
    // If the passed in principal id is neither a group or user, we return an error
    } else {
        return callback({'code': 400, 'msg': 'An unrecognized principal id (' + principalId + ') has been passed in'});
    }
};

/**
 * Get the storage backend for a uri, if the uri is unspecified it will return the default backend for a tenant.
 * If the backend could not be found, this will throw an error!
 * The uri will be checked before defaulting to the configured tenant backend. This allows for a tenant
 * to switch storage systems yet still serve the old files.
 *
 * @param  {Context}    ctx     The current execution context.
 * @param  {String}     [uri]   An optional URI.
 * @return {Backend}            The appropriate backend.
 */
var getStorageBackend = module.exports.getStorageBackend = function(ctx, uri) {
    var backendName = null;
    if (uri) {
        backendName = uri.split(':')[0];
    } else {
        // Use the tenant's default.
        backendName = Config.getValue(ctx.tenant().alias, 'storage', 'backend');
        if (backendName === null) {
            log().error('There was no storage backend configured, this should not happen.');
            throw new Error('There was no storage backend configured, this should not happen.');
        }
    }
    if (!_backends[backendName]) {
        try {
            _backends[backendName] = require('oae-content/lib/backends/' + backendName);
        } catch (err) {
            log().error({'err': err}, 'Couldn\'t load the backend %s', backendName);
            throw new Error('Could not find storage back-end ' + backendName);
        }
    }

    return _backends[backendName];
};

///////////////
// Revisions //
///////////////

/**
 * Internal method for creating revision.
 * This method assumes that the current user has sufficient rights to create a new revision.
 *
 * @param {Context}     ctx                 Current execution context.
 * @param {String}      contentId           The contentId this revision is for.
 * @param {String}      uri                 A URI for this revision
 * @param {Object}      [opts]              Extra options that should be stored on the revision.
 * @param {Function}    [callback]          An optional callback method.
 * @param {Object}      [callback.err]      An error object (if any)
 * @param {Revision}    [callback.revision] A revision object.
 * @api private
 */
var _createRevision = function(ctx, contentId, uri, opts, callback) {
    // Copy all the options (if any)
    var values = opts || {};

    // Add some more meta data.
    values.contentId = contentId;
    values.created = Date.now();
    values.createdBy = ctx.user().id;
    values.uri = uri;
    var revisionId = AuthzUtil.toId('rev', ctx.tenant().alias, ShortId.generate());

    var q = Cassandra.constructUpsertCQL('Revisions', 'revisionId', revisionId, values, 'QUORUM');
    Cassandra.runQuery(q.query, q.parameters, function(err) {
        if (err) {
            return callback(err);
        }

        // Add the revision to the list.
        Cassandra.runQuery('UPDATE RevisionByContent SET ?=? WHERE contentId=?', [values.created, revisionId, contentId], function(err) {
            if (err) {
                return callback(err);
            }
            var revision = new Revision(contentId, revisionId, values.createdBy, values.created, values.uri, opts);
            callback(null, revision);
        });
    });
};

/**
 * Get the revisions that are associated to a piece of content.
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the object for which we want to get the revisions
 * @param  {String}         start               Determines the point at which revisions are returned for paging purposes.  If not provided, the first x elements will be returned
 * @param  {Integer}        limit               Number of revisions to return. Will default to 10 if not provided
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `revisions`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Revision[]}     callback.revisions  Array that contains an object for each revision.
 */
var getRevisions = module.exports.getRevisions = function(ctx, contentId, start, limit, callback) {
    limit = limit || 10;

    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A contentId must be provided'}).isResourceId();
    validator.check(limit, {'code': 400, 'msg': 'A valid limit should be passed in'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the user has access on this contentId
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        _getRevisions(ctx, contentId, start, limit, callback);
    });
};

/**
 * Internal method that retrieves revisions but performs no authorization checks.
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the object for which we want to get the revisions
 * @param  {String}         start               Determines the point at which revisions are returned for paging purposes.  If not provided, the first x elements will be returned
 * @param  {Integer}        limit               Number of revisions to return. Will default to 10 if not provided
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `revisions`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Revision[]}     callback.revisions  Array that contains an object for each revision.
 * @api private
 */
var _getRevisions = function(ctx, contentId, start, limit, callback) {
    // Page the query.
    var paging = Cassandra.getPagingParameters(start, limit);
    Cassandra.runQuery('SELECT FIRST ' + paging.limit + ' REVERSED ?..\'\' FROM RevisionByContent USING CONSISTENCY QUORUM WHERE contentId = ?', [paging.start, contentId], function (err, rows) {
        if (err) {
            return callback(err);
        }

        var revisionsToRetrieve = [];
        for (var c = paging.startIndex; c < rows[0].count; c++) {
            revisionsToRetrieve.push(rows[0][c].value);
        }
        if (revisionsToRetrieve.length === 0) {
            return callback(null, []);
        }

        Cassandra.runQuery('SELECT * FROM Revisions WHERE revisionId IN (?)', [revisionsToRetrieve], function(err, rows) {
            if (err) {
                return callback(err);
            }

            // Generate the Revision objects.
            var revisions = [];
            for (var i = 0; i < rows.length; i++) {
                var revision = _rowToRevision(rows[i]);
                revisions.push(revision);
            }

            var userIds = _.map(revisions, function(revisions) { return revisions.createdBy; });
            PrincipalsUtil.getPrincipals(ctx, userIds, function(err, users) {
                if (err) {
                    return callback(err);
                }

                // Add the user profiles to the revisions.
                // Do any other tasks (ex: signing of URLs) here.
                for (var r = 0; r < revisions.length; r++) {
                    if (users[revisions[r].createdBy]) {
                        revisions[r].createdBy = users[revisions[r].createdBy];
                        revisions[r].link = '/api/content/' + contentId + '/download/' + revisions[r].revisionId;
                    }
                }
                callback(null, revisions);
            });
        });
    });
};

/**
 * Get a specific revision for a piece of content.
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the content for which we want to get the revision
 * @param  {String}         [revisionId]        The id of the revision that needs to be retrieved, if left null the latest will be retrieved.
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Revision}       callback.revision   The retrieved revision
 */
var getRevision = module.exports.getRevision = function(ctx, contentId, revisionId, callback) {
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A valid contentId must be provided'}).isResourceId();
    if (revisionId) {
        validator.check(revisionId, {'code': 400, 'msg': 'A valid revisionId must be provided'}).isResourceId();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    /**
     * Adds the download link on the revision.
     * @param {Object}      err      Error object containing the error message
     * @param {Revision}    revision The retrieved revision
     */
    var addDownloadLink = function(err, revision) {
        if (err) {
            return callback(err);
        }

        revision.link = getStorageBackend(ctx, revision.uri).getDownloadLink(ctx, revision.uri);
        callback(null, revision);
    };

    if (!revisionId || revisionId === '') {
        // Get the latest one.
        return getLatestRevision(ctx, contentId, addDownloadLink);
    }

    // Get a specific one.
    // Check if the user has access on this contentId
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        Cassandra.runQuery('SELECT * FROM Revisions WHERE RevisionId = ?', [revisionId], function (err, rows) {
            if (err) {
                return callback(err);
            }

            // Cassandra always returns the key as a column so the count property will always be 1.
            if (rows[0].count <= 1) {
                return callback({'code': 404, 'msg': 'Couldn\'t find revision: ' + revisionId});
            }

            var revisionObj = _rowToRevision(rows[0]);
            // Double check that this revision is really attached to the specified contentId.
            // This is to counter that someone tries to get the revision of a piece of content he has no access to.
            // Ex: Alice has access to c:cam:aliceDoc but not to c:cam:bobDoc which has revision rev:cam:foo
            // doing getRevision(ctx, 'c:cam:aliceDoc', 'rev:cam:foo', ..) should return this error.
            if (revisionObj.contentId !== contentId) {
                return callback({'code': 401, 'msg': 'This revision ID is not associated with the specified piece of content.'});
            }

            addDownloadLink(null, revisionObj);
        });
    });
};

/**
 * Gets the most current revision
 *
 * @param  {Context}    ctx                 Current execution context.
 * @param  {String}     contentId           The id of the object for which we want to get the revisions
 * @param  {Function}   callback            Standard callback function takes arguments `err` and `revision`
 * @param  {Object}     callback.err        Error object containing the error message
 * @param  {Revision}   callback.revision   The latest revision
 */
var getLatestRevision = module.exports.getLatestRevision = function(ctx, contentId, callback) {
    getRevisions(ctx, contentId, null, 1, function(err, revisions) {
        if (err) {
            return callback(err);
        }

        if (revisions.length === 0) {
            return callback({'code': 404, 'msg': 'No revision found for ' + contentId});
        }

        callback(null, revisions[0]);
    });
};

/**
 * Verifies if a uri and signature match up and returns an object that the REST handlers can use to redirect users
 * to the actual download page.
 *
 * @param {Context}     ctx                             Current execution context.
 * @param {String}      uri                             The URI of a file.
 * @param {Number}      expires                         When the signature expires, in milliseconds since epoch.
 * @param {String}      signature                       The signature of the uri.
 * @param {Object}      callback.err                    Error object containing the error message
 * @param {Object}      callback.data                   The object that contains the data that the REST handler can use.
 * @param {Object}      callback.data.link              The link object with an http status code and a url
 * @param {Object}      callback.data.link.code         The HTTP status code (usually 204 or 301/302)
 * @param {Object}      callback.data.link.url          The url where the user should be redirected to.
 * @param {Object}      callback.data.opts.filename     The filename of the file that the user wishes to download.
 */
var verifySignedUri = module.exports.verifySignedUri = function(ctx, uri, expires, signature, callback) {
    var validator = new Validator();
    validator.check(uri, {'code': 400, 'msg': 'Missing uri'}).notNull();
    validator.check(expires, {'code': 400, 'msg': 'Missing expires'}).notNull();
    validator.check(expires, {'code': 400, 'msg': 'Invalid expires'}).isInt();
    validator.check(signature, {'code': 400, 'msg': 'Missing signature'}).notNull();
    expires = parseInt(expires, 10);
    var principalId = (ctx.user()) ? ctx.user().principalId : '';
    var body = principalId + ':' + uri;
    validator.check(signature, {'code': 401, 'msg': 'Invalid signature'}).verifyExpiringSignature(ctx.tenant().alias, expires, body);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    var link = getStorageBackend(ctx, uri).getDownloadLink(ctx, uri);
    var data = {
        'link': link,
        'opts': {
            'filename': Path.basename(uri)
        }
    };
    callback(null, data);
};

/**
 * Converts a Cassandra Row to a Revision object.
 *
 * @param  {Row}        row         A Helenus Row
 * @return {Revision}               A revision object or null if the column could not be converted.
 * @api private
 */
var _rowToRevision = function(row) {
    var hash = Cassandra.rowToHash(row);
    var opts = {};
    opts.mime = hash.mime || 'application/octet-stream';
    if (hash.filename) {
        opts.filename = hash.filename;
    }
    if (hash.size) {
        opts.size = hash.size;
    }
    return new Revision(hash.contentId, hash.revisionId, hash.createdBy, hash.created, hash.uri, opts);
};

///////////////////////
// Utility functions //
///////////////////////


/**
 * Creates and returns an array of content comments from an Array of rows retrieved from Cassandra.
 *
 * @param  {Rows}        commentRows    Cassandra rows retrieved from the Comments CF containing comment details and references to the CommentByContentId CF
 * @return {Comment[]}                  Returns a Array of Comment objects.
 * @api private
 */
var _rowsToComments = function(commentRows) {
    var commentsArr = [];
    for (var i = 0; i < commentRows.length; i++) {
        commentRows[i] = Cassandra.rowToHash(commentRows[i]);
        var comment = new Comment(commentRows[i].commentId, commentRows[i].body, commentRows[i].contentId, commentRows[i].createdBy, commentRows[i].created, commentRows[i].level, commentRows[i].replyTo, commentRows[i].deleted);
        commentsArr.push(comment);
    }
    return commentsArr;
};

/**
 * Adds the signature and thumbnail url (if the piece of content has a thumbnail.)
 *
 * @param  {Context}    ctx         Standard context object, representing the currently logged in user and its tenant
 * @param  {Content}    contentObj  The content object that needs augmenting.
 */
var _augmentContent = function(ctx, contentObj) {
    // Generate a signature for this content item.
    // In combination with the previews object, the UI should be able to construct
    // download URLs for the preview items.
    contentObj.signature = ContentUtil.signContent(ctx, contentObj.id, contentObj.lastModified);

    if (contentObj.previews.thumbnailUri) {
        contentObj.previews.thumbnailUrl = ContentUtil.getThumbnailUrl(ctx, contentObj.id, contentObj.lastModified, contentObj.signature);
    }
};
