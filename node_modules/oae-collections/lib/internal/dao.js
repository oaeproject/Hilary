/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var ShortId = require('shortid');

var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var PrincipalsUtil = require('oae-principals/lib/util');
var TenantsAPI = require('oae-tenants');

var Collection = require('oae-collections/lib/model').Collection;

/**
 * Create a collection
 *
 * @param  {String}         createdBy               The id of the user who is creating the collection
 * @param  {String}         displayName             The display name of the collection
 * @param  {String}         description             The description of the collection
 * @param  {String}         visibility              The visibility of the collection
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Collection}     callback.collection     The collection that was created
 */
var createCollection = module.exports.createCollection = function(createdBy, displayName, description, visibility, callback) {
    var tenantAlias = AuthzUtil.getPrincipalFromId(createdBy).tenantAlias;
    var collectionId = _createCollectionId(tenantAlias);
    var groupId = PrincipalsUtil.createGroupId(tenantAlias);
    var created = Date.now();
    var storageHash = {
        'tenantAlias': tenantAlias,
        'groupId': groupId,
        'createdBy': createdBy,
        'displayName': displayName,
        'description': description,
        'visibility': visibility,
        'created': created,
        'lastModified': created
    };

    // Create the queries to insert both the collection and the record that indexes it with its surrogate group id
    var insertGroupIdIndexQuery = Cassandra.constructUpsertCQL('CollectionsGroupId', 'groupId', groupId, {'collectionId': collectionId});
    var insertCollectionQuery = Cassandra.constructUpsertCQL('Collections', 'id', collectionId, storageHash);

    // Insert the surrogate group id index entry
    Cassandra.runBatchQuery([insertGroupIdIndexQuery, insertCollectionQuery], function(err) {
        if (err) {
            return callback(err);
        }

        return callback(null, _storageHashToCollection(collectionId, storageHash));
    });
};

/**
 * Get a list of collections by their ids
 *
 * @param  {String[]}       collectionIds           The ids of the collections to get
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Collection[]}   callback.collections    The collections that are identified by the given ids. The collections will be located in the same order as the given array of ids
 */
var getCollectionsByIds = module.exports.getCollectionsByIds = function(collectionIds, callback) {
    if (_.isEmpty(collectionIds)) {
        return callback(null, []);
    }

    Cassandra.runQuery('SELECT * FROM "Collections" WHERE "id" IN (?)', [collectionIds], function(err, rows) {
        if (err) {
            return callback(err);
        }

        // Assemble the collections array, ensuring it is in the same order as the original ids
        var collectionsById = _.chain(rows).map(_rowToCollection).indexBy('id').value();
        var collections = _.chain(collectionIds)
            .map(function(collectionId) {
                return collectionsById[collectionId];
            })
            .compact()
            .value();

        return callback(null, collections);
    });
};

/**
 * Get a list of collections by their surrogate group ids
 *
 * @param  {String[]}       groupIds                The ids of the groups that identify the collections to get
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Collection[]}   callback.collections    The collections that are identified by the given list of group ids. The collections will be located in the same order as the given array of ids
 */
var getCollectionsByGroupIds = module.exports.getCollectionsByGroupIds = function(groupIds, callback) {
    if (_.isEmpty(groupIds)) {
        return callback(null, []);
    }

    Cassandra.runQuery('SELECT * FROM "CollectionsGroupId" WHERE "groupId" IN (?)', [groupIds], function(err, rows) {
        if (err) {
            return callback(err);
        }

        // Assemble the collection ids, ensuring the original ordering is maintained
        var collectionIdsByGroupIds = _.chain(rows).map(Cassandra.rowToHash).indexBy('groupId').value();
        var collectionIds = _.chain(groupIds)
            .map(function(groupId) {
                return collectionIdsByGroupIds[groupId];
            })
            .compact()
            .pluck('collectionId')
            .value();

        return getCollectionsByIds(collectionIds, callback);
    });
};

/**
 * Update the given collection
 *
 * @param  {Collection}     collection              The collection to update
 * @param  {Object}         profileFields           The profile fields and values with which to update the collection
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Collection}     callback.collection     The updated collection
 */
var updateCollection = module.exports.updateCollection = function(collection, profileFields, callback) {
    var storageHash = _.extend({}, profileFields);
    storageHash.lastModified = storageHash.lastModified || Date.now();

    var query = Cassandra.constructUpsertCQL('Collections', 'id', collection.id, storageHash);
    Cassandra.runQuery(query.query, query.parameters, function(err) {
        if (err) {
            return callback(err);
        }

        return callback(null, _createUpdatedCollectionFromStorageHash(collection, storageHash));
    });
};

/**
 * Iterate through all the collections. This will return just the raw collection properties that are
 * specified in the `properties` parameter, and only `batchSize` collections at a time. On each
 * iteration of `batchSize` collections, the `onEach` callback will be invoked and the next batch
 * will not be fetched until you have invoked the `onEach.done` function parameter. When complete
 * (e.g., there are 0 collections left to iterate through or an error has occurred), the
 * `callback` parameter will be invoked
 *
 * @param  {String[]}   [properties]            The names of the collection properties to return in the collection objects. If not specified (or is empty array), it returns just the `collectionId`s
 * @param  {Number}     [batchSize]             The number of collections to fetch at a time. Defaults to 100
 * @param  {Function}   onEach                  Invoked with each batch of collections that are fetched from storage
 * @param  {Object[]}   onEach.collectionRow    An array of objects holding the raw collection rows that were fetched from storage
 * @param  {Function}   onEach.done             The function to invoke when processing of the current batch is complete
 * @param  {Object}     onEach.done.err         An error that occurred, if any, while processing the current batch. If you specify this error, iteration will finish and the completion callback will be invoked
 * @param  {Function}   [callback]              Invoked when all rows have been iterated, or an error has occurred
 * @param  {Object}     [callback.err]          An error that occurred, while iterating rows, if any
 * @see Cassandra#iterateAll
 */
var iterateAll = module.exports.iterateAll = function(properties, batchSize, onEach, callback) {
    if (_.isEmpty(properties)) {
        properties = ['id'];
    }

    /*!
     * Handles each batch from the cassandra iterateAll method
     *
     * @see Cassandra#iterateAll
     */
    var _iterateAllOnEach = function(rows, done) {
        // Convert the rows to a hash and delegate action to the caller onEach method
        return onEach(_.map(rows, Cassandra.rowToHash), done);
    };

    Cassandra.iterateAll(properties, 'Collections', 'id', {'batchSize': batchSize}, _iterateAllOnEach, callback);
};

/**
 * Given a base collection and an arbitrary key-value pair of updated values, create a version of
 * the collection with the updates applied
 *
 * @param  {Collection}     collection          The base collection to which the updates will be applied
 * @param  {Object}         updatedStorageHash  The updates to apply to the collection
 * @return {Collection}                         The updated collection
 * @api private
 */
var _createUpdatedCollectionFromStorageHash = function(collection, updatedStorageHash) {
    return new Collection(
        collection.tenant,
        collection.id,
        collection.groupId,
        collection.createdBy,
        updatedStorageHash.displayName || collection.displayName,
        updatedStorageHash.description || collection.description,
        updatedStorageHash.visibility || collection.visibility,
        collection.created,
        updatedStorageHash.lastModified || collection.lastModified
    );
};

/**
 * Convert a Helenus Row into a Collection object
 *
 * @param  {Row}            row     The row that was fetched from Cassandra
 * @return {Collection}             The collection represented by the row
 * @api private
 */
var _rowToCollection = function(row) {
    var storageHash = Cassandra.rowToHash(row);
    return _storageHashToCollection(storageHash.id, storageHash);
};

/**
 * Given a simple storage hash, convert it into a Collection object with the provided id
 *
 * @param  {String}         collectionId    The id to apply to the created collection object
 * @param  {Object}         storageHash     The simple key-value pair representing the fields of the collection
 * @return {Collection}                     The collection represented by the provided data
 * @api private
 */
var _storageHashToCollection = function(collectionId, storageHash) {
    return new Collection(
        TenantsAPI.getTenant(storageHash.tenantAlias),
        collectionId,
        storageHash.groupId,
        storageHash.createdBy,
        storageHash.displayName,
        storageHash.description,
        storageHash.visibility,
        storageHash.created,
        storageHash.lastModified
    );
};

/**
 * Generate a collection id for the given tenant alias
 *
 * @param  {String}     tenantAlias     The alias of the tenant for which to generate the collection id
 * @return {String}                     A randomly generated collection id
 * @api private
 */
var _createCollectionId = function(tenantAlias) {
    return AuthzUtil.toId('x', tenantAlias, ShortId.generate());
};
