/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');
var shortid = require('shortid');
var util = require('util');

var AuthzTestUtil = require('oae-authz/lib/test/util');
var AuthzUtil = require('oae-authz/lib/util');
var ContentTestUtil = require('oae-content/lib/test/util');
var Context = require('oae-context').Context;
var LibraryAPI = require('oae-library');
var LibraryTestUtil = require('oae-library/lib/test/util');
var MQTestUtil = require('oae-util/lib/test/mq-util');
var PreviewConstants = require('oae-preview-processor/lib/constants');
var PrincipalsAPI = require('oae-principals');
var RestAPI = require('oae-rest');
var SearchTestUtil = require('oae-search/lib/test/util');
var User = require('oae-principals/lib/model').User;

var FoldersConstants = require('../constants').FoldersConstants;
var FoldersDAO = require('../internal/dao');
var FoldersLibrary = require('oae-folders/lib/library');

/**
 * Generate a number of folders for use in testing
 *
 * @param  {RestContext}    restContext             The REST context to use for making requests
 * @param  {Number}         numFolders              How many folders to generate
 * @param  {Function}       callback                Standard callback function
 * @param  {Folder}         callback.folder...      All folders that were generated as separate callback parameters
 * @throws {AssertionError}                         Thrown if an error occurred generating the folders
 */
var generateTestFolders = module.exports.generateTestFolders = function(restContext, numFolders, callback, _folders) {
    _folders = _folders || [];
    if (numFolders === 0) {
        LibraryAPI.Index.whenUpdatesComplete(function() {
            SearchTestUtil.whenIndexingComplete(function() {
                return callback.apply(this, _folders);
            });
        });
        return;
    }

    RestAPI.Folders.createFolder(restContext, util.format('displayName-%s', shortid.generate()), null, null, null, null, function(err, createdFolder) {
        assert.ok(!err);
        _folders.push(createdFolder);
        return generateTestFolders(restContext, numFolders - 1, callback, _folders);
    });
};

/**
 * Generate a number of folders with the provided visibility for use in testing
 *
 * @param  {RestContext}    restContext             The REST context to use for making requests
 * @param  {Number}         numFolders              How many folders to generate
 * @param  {String}         visibility              The visibility to apply to each folder. One of the options enumerated by `Authz.visibility`
 * @param  {Function}       callback                Standard callback function
 * @param  {Folder}         callback.folder...      All folders that were generated as separate callback parameters
 * @throws {AssertionError}                         Thrown if an error occurred generating the folders
 */
var generateTestFoldersWithVisibility = module.exports.generateTestFoldersWithVisibility = function(restContext, numFolders, visibility, callback, _folders) {
    _folders = _folders || [];
    if (numFolders === 0) {
        LibraryAPI.Index.whenUpdatesComplete(function() {
            SearchTestUtil.whenIndexingComplete(function() {
                return callback.apply(this, _folders);
            });
        });
        return;
    }

    RestAPI.Folders.createFolder(restContext, util.format('displayName-%s', shortid.generate()), null, visibility, null, null, function(err, createdFolder) {
        assert.ok(!err);
        _folders.push(createdFolder);
        return generateTestFoldersWithVisibility(restContext, numFolders - 1, visibility, callback, _folders);
    });
};

/**
 * Set up 2 public tenants and 2 private tenants, each with a public, loggedin, private set of
 * users, groups, content and folders. The resulting model looks like this:
 *
 * ```
 *  {
 *      "publicTenant": {
 *          "tenant": <Tenant>,
 *          "anonymousRestContext": <RestContext>,
 *          "adminRestContext": <RestContext>,
 *          "publicGroup": <Group>,
 *          "loggedinGroup": <Group>,
 *          "privateGroup": <Group>,
 *          "publicContent": <Content>,
 *          "loggedinContent": <Content>,
 *          "privateContent": <Content>,
 *          "publicUser": {
 *              "user": <User>,
 *              "restContext": <RestContext>
 *          },
 *          "loggedinUser": { ... }
 *          "privateUser": { ... }
 *      },
 *      "publicTenant1": { ... },
 *      "privateTenant": { ... },
 *      "privateTenant1": { ... }
 *  }
 * ```
 *
 * @param  {Function}   Invoked when all the entities are set up
 * @throws {Error}      An assertion error is thrown if something does not get created properly
 */
var setupMultiTenantPrivacyEntities = module.exports.setupMultiTenantPrivacyEntities = function(callback) {
    // Base the folders privacy setup on content. We then create folders to go along with them
    ContentTestUtil.setupMultiTenantPrivacyEntities(function(publicTenant, publicTenant1, privateTenant, privateTenant1) {
        // Create the folders
        _setupTenant(publicTenant, function() {
            _setupTenant(publicTenant1, function() {
                _setupTenant(privateTenant, function() {
                    _setupTenant(privateTenant1, function() {
                        return callback(publicTenant, publicTenant1, privateTenant, privateTenant1);
                    });
                });
            });
        });
    });
};

/**
 * Add a set of content items to a folder, ensuring that all items have been added succesfully
 *
 * @param  {RestContext}        restContext     The REST context to use when adding the content items to the folder
 * @param  {String}             folderId        The id of the folder on which to add the content items
 * @param  {String[]}           contentIds      The ids of the content items to add
 * @param  {Function}           callback        Standard callback function
 * @throws {AssertionError}                     Thrown if the content items are not successfully added
 */
var assertAddContentItemsToFolderSucceeds = module.exports.assertAddContentItemsToFolderSucceeds = function(restContext, folderId, contentIds, callback) {
    // First ensure the folder's content library is not stale
    getAllFolderContentItems(restContext, folderId, null, function() {

        // Add the content items to the folder
        RestAPI.Folders.addContentItemsToFolder(restContext, folderId, contentIds, function(err) {
            assert.ok(!err);

            // Ensure that the items we just added to the folder are in fact there
            getAllFolderContentItems(restContext, folderId, null, function(contentItems, responses) {
                _.each(contentIds, function(contentId) {
                    assert.ok(_.findWhere(contentItems, {'id': contentId}));
                });

                // Purge the folder's content library so we can rebuild it from scratch
                _purgeFolderContentLibrary(folderId, function() {

                    // Ensure once again that all content items are in the folder
                    getAllFolderContentItems(restContext, folderId, null, function(contentItems, responses) {
                        _.each(contentIds, function(contentId) {
                            assert.ok(_.findWhere(contentItems, {'id': contentId}));
                        });

                        return callback();
                    });
                });
            });
        });
    });
};

/**
 * Try to add a set of content items to a folder, and ensure it fails in a specified way
 *
 * @param  {RestContext}        restContext     The REST context to use when adding the content items to the folder
 * @param  {String}             folderId        The id of the folder on which to try and add the content items
 * @param  {String[]}           contentIds      The content ids to try and add to the folder
 * @param  {Number}             httpCode        The expected failure HTTP code of the request
 * @param  {Function}           callback        Standard callback function
 * @throws {AssertionError}                     Thrown if the request did not fail in the expected manner
 */
var assertAddContentItemsToFolderFails = module.exports.assertAddContentItemsToFolderFails = function(restContext, folderId, contentIds, httpCode, callback) {
    RestAPI.Folders.addContentItemsToFolder(restContext, folderId, contentIds, function(err) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        return callback();
    });
};

/**
 * Add a content item to all the provided folders, ensuring that all items have been added successfully
 *
 * @param  {RestContext}        restContext     The REST context to use when adding the content item to the folders
 * @param  {String[]}           folderIds       The ids of the folders on which to add the content item
 * @param  {String}             contentId       The id of the content item to add to the folders
 * @param  {Function}           callback        Standard callback function
 * @throws {AssertionError}                     Thrown if the content item is not successfully added to all the folders
 */
var assertAddContentItemToFoldersSucceeds = module.exports.assertAddContentItemToFoldersSucceeds = function(restContext, folderIds, contentId, callback) {
    if (_.isEmpty(folderIds)) {
        return callback();
    }

    // Add the content item to the next folder in the list
    folderIds = folderIds.slice();
    var folderId = folderIds.shift();
    assertAddContentItemsToFolderSucceeds(restContext, folderId, [contentId], function() {

        // Recursively add the content item to the next folder
        return assertAddContentItemToFoldersSucceeds(restContext, folderIds, contentId, callback);
    });
};

/**
 * Remove a set of content items from a folder, ensuring that all items have been removed succesfully
 *
 * @param  {RestContext}        restContext     The REST context to use when removing the content items from the folder
 * @param  {String}             folderId        The id of the folder from which to remove the content items
 * @param  {String[]}           contentIds      The ids of the content items to remove
 * @param  {Function}           callback        Standard callback function
 * @throws {AssertionError}                     Thrown if the content items are not successfully removed
 */
var assertRemoveContentItemsFromFolderSucceeds = module.exports.assertRemoveContentItemsFromFolderSucceeds = function(restContext, folderId, contentIds, callback) {
    // First ensure the folder's content library is not stale
    getAllFolderContentItems(restContext, folderId, null, function(contentItems, responses) {
        // Ensure the items are there in the first place
        _.each(contentIds, function(contentId) {
            assert.ok(_.findWhere(contentItems, {'id': contentId}));
        });

        // Remove the content items from the folder
        RestAPI.Folders.removeContentItemsFromFolder(restContext, folderId, contentIds, function(err) {
            assert.ok(!err);

            LibraryAPI.Index.whenUpdatesComplete(function() {
                // Ensure that the items we just removed from the folder are in fact removed
                getAllFolderContentItems(restContext, folderId, null, function(contentItems, responses) {
                    _.each(contentIds, function(contentId) {
                        assert.ok(!_.findWhere(contentItems, {'id': contentId}));
                    });

                    // Purge the folder's content library so we can rebuild it from scratch
                    _purgeFolderContentLibrary(folderId, function() {
                        // Ensure once again that all content items are no longer in the folder
                        getAllFolderContentItems(restContext, folderId, null, function(contentItems, responses) {
                            _.each(contentIds, function(contentId) {
                                assert.ok(!_.findWhere(contentItems, {'id': contentId}));
                            });

                            return callback();
                        });
                    });
                });
            });
        });
    });
};

/**
 * Try to remove a set of content items from a folder, and ensure it fails in a specified way
 *
 * @param  {RestContext}        restContext     The REST context to use when removing the content items from the folder
 * @param  {String}             folderId        The id of the folder from which to try and remove the content items
 * @param  {String[]}           contentIds      The content ids to try and remove from the folder
 * @param  {Number}             httpCode        The expected failure HTTP code of the request
 * @param  {Function}           callback        Standard callback function
 * @throws {AssertionError}                     Thrown if the request did not fail in the expected manner
 */
var assertRemoveContentItemsFromFolderFails = module.exports.assertRemoveContentItemsFromFolderFails = function(restContext, folderId, contentIds, httpCode, callback) {
    RestAPI.Folders.removeContentItemsFromFolder(restContext, folderId, contentIds, function(err) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        return callback();
    });
};

/**
 * Try to create a folder, ensuring it fails in a specified way
 *
 * @param  {RestContext}        restContext     The REST context to use when creating the folder
 * @param  {String}             displayName     The display name of the folder
 * @param  {String}             description     The description of the folder
 * @param  {String}             visibility      The visibility of the folder
 * @param  {String[]}           managers        The manager principal ids for the folder
 * @param  {String[]}           viewers         The viewer principal ids for the folder
 * @param  {Number}             httpCode        The expected failure HTTP code of the request
 * @param  {Function}           callback        Standard callback function
 * @throws {AssertionError}                     Thrown if the request did not fail in the expected manner
 */
var assertCreateFolderFails = module.exports.assertCreateFolderFails = function(restContext, displayName, description, visibility, managers, viewers, httpCode, callback) {
    RestAPI.Folders.createFolder(restContext, displayName, description, visibility, managers, viewers, function(err, createdFolder) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        assert.ok(!createdFolder);
        return callback();
    });
};

/**
 * Create a folder, ensuring that it is successfully created with the provided properties
 *
 * @param  {RestContext}        restContext             The REST context to use when creating the folder
 * @param  {String}             displayName             The display name of the folder
 * @param  {String}             description             The description of the folder
 * @param  {String}             visibility              The visibility of the folder
 * @param  {Object[]}           managers                The manager principal infos for the folder
 * @param  {Object[]}           viewers                 The viewer principal infos for the folder
 * @param  {Function}           callback                Standard callback function
 * @param  {Folder}             callback.folder         The created folder
 * @throws {AssertionError}                             Thrown if the folder was not successfully created
 */
var assertCreateFolderSucceeds = module.exports.assertCreateFolderSucceeds = function(restContext, displayName, description, visibility, managerInfos, viewerInfos, callback) {
    var managerIds = [];
    var viewerIds = [];
    var allMemberInfos = [];

    // Generalize the potential user and group info objects so that they have a `profile` key
    // instead of `user` or `group`, then collect the parameters needed to create a folder
    _.chain(managerInfos)
        .map(_generalizePrincipalInfoModel)
        .each(function(managerInfo) {
            if (_.isObject(managerInfo)) {
                managerIds.push(managerInfo.profile.id);
                allMemberInfos.push(managerInfo);
            } else {
                managerIds.push(managerInfo);
            }
        });

    _.chain(viewerInfos)
        .map(_generalizePrincipalInfoModel)
        .each(function(viewerInfo) {
            if (_.isObject(viewerInfo)) {
                viewerIds.push(viewerInfo.profile.id);
                allMemberInfos.push(viewerInfo);
            } else {
                viewerIds.push(viewerInfo);
            }
        });

    // Get all the folders libraries to ensure that the library index is populated for all users
    _getAllFoldersInLibraries(allMemberInfos, function(principalFoldersLibrariesBeforeCreate) {

        // Create the folder
        RestAPI.Folders.createFolder(restContext, displayName, description, visibility, managerIds, viewerIds, function(err, createdFolder) {
            assert.ok(!err);
            assert.ok(createdFolder);
            assert.ok(createdFolder.id);
            assert.ok(createdFolder.groupId);
            assert.ok(createdFolder.createdBy);
            assert.equal(createdFolder.displayName, displayName);
            assert.equal(createdFolder.description, description);
            assert.equal(createdFolder.visibility, visibility);
            assert.ok(_.isNumber(createdFolder.created));
            assert.strictEqual(createdFolder.created, createdFolder.lastModified);
            assert.strictEqual(createdFolder.profilePath.indexOf('/folder/'), 0);
            assert.notEqual(createdFolder.profilePath.indexOf(createdFolder.id.split(':').pop()), -1);
            assert.equal(createdFolder.resourceType, 'folder');

            // Determine what the full membership should be, including the current user who created
            // the folder
            RestAPI.User.getMe(restContext, function(err, me) {
                assert.ok(!err);

                var expectedMemberRoles = _.extend(
                    AuthzTestUtil.createRoleChange(viewerIds, 'viewer'),
                    AuthzTestUtil.createRoleChange(managerIds, 'manager')
                );

                // The current user is only made a manager if he can't manage any other managers
                var user = new User(me.tenant.alias, me.id, me.displayName, me.email, me);
                var ctx = new Context(me.tenant, user);
                PrincipalsAPI.canManageAny(ctx, managerIds, function(err, canManage) {
                    assert.ok(!err);
                    if (!canManage) {
                        expectedMemberRoles[me.id] = 'manager';
                        // Add the current user member info to ensure the folder gets added to their library
                        allMemberInfos.push({
                            'restContext': restContext,
                            'profile': me
                        });
                    }

                    // Ensure members and invitation roles are what we expect
                    getAllFolderMembers(restContext, createdFolder.id, null, function(membersAfterCreate) {
                        AuthzTestUtil.assertMemberRolesEquals({}, expectedMemberRoles, AuthzTestUtil.getMemberRolesFromResults(membersAfterCreate));

                        AuthzTestUtil.assertGetInvitationsSucceeds(restContext, 'folder', createdFolder.id, function(result) {
                            AuthzTestUtil.assertEmailRolesEquals({}, expectedMemberRoles, AuthzTestUtil.getEmailRolesFromResults(result.results));

                            // Get the folders libraries after it was created and ensure that the folder is in the libraries
                            _getAllFoldersInLibraries(allMemberInfos, function(principalFoldersLibrariesAfterCreate) {
                                _.each(allMemberInfos, function(memberInfo) {
                                    assert.ok(_.chain(principalFoldersLibrariesAfterCreate[memberInfo.profile.id]).pluck('id').contains(createdFolder.id).value());
                                });

                                var allMemberInfoIds = _.chain(allMemberInfos).pluck('profile').pluck('id').value();

                                // Purge the member folder libraries and check again to ensure they update properly both on-the-fly and when built from scratch
                                _purgeFoldersLibraries(allMemberInfoIds, function() {
                                    _getAllFoldersInLibraries(allMemberInfos, function(principalFoldersLibrariesAfterCreate) {
                                        _.each(allMemberInfos, function(memberInfo) {
                                            assert.ok(_.chain(principalFoldersLibrariesAfterCreate[memberInfo.profile.id]).pluck('id').contains(createdFolder.id).value());
                                        });

                                        return callback(createdFolder);
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });
};

/**
 * Get a folder, ensuring that it fails in a specified way
 *
 * @param  {RestContext}        restContext     The REST context to use when getting the folder
 * @param  {String}             folderId        The id of the folder to get
 * @param  {Number}             httpCode        The expected failure HTTP code of the request
 * @param  {Function}           callback        Standard callback function
 * @throws {AssertionError}                     Thrown if the request did not fail in the expected manner
 */
var assertGetFolderFails = module.exports.assertGetFolderFails = function(restContext, folderId, httpCode, callback) {
    RestAPI.Folders.getFolder(restContext, folderId, function(err, folder) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        assert.ok(!folder);
        return callback();
    });
};

/**
 * Get a folder, ensuring that the request is successful
 *
 * @param  {RestContext}        restContext     The REST context to use when getting the folder
 * @param  {String}             folderId        The id of the folder to get
 * @param  {Function}           callback        Standard callback function
 * @throws {AssertionError}                     Thrown if the request did not succeed
 */
var assertGetFolderSucceeds = module.exports.assertGetFolderSucceeds = function(restContext, folderId, callback) {
    RestAPI.Folders.getFolder(restContext, folderId, function(err, folder) {
        assert.ok(!err);
        assert.ok(folder);
        assert.strictEqual(folder.id, folderId);
        return callback(folder);
    });
};

/**
 * Update a folder, ensuring that it succeeds
 *
 * @param  {RestContext}        restContext         The REST context to use when updating the folder
 * @param  {String}             folderId            The id of the folder to update
 * @param  {Object}             updates             The updates that should be made on the folder
 * @param  {Function}           callback            Invoked when the folder is successfully updated
 * @param  {Folder}             callback.folder     The updated folder
 * @throws {AssertionError}                         Thrown if the request did not fail in the expected manner
 */
var assertUpdateFolderSucceeds = module.exports.assertUpdateFolderSucceeds = function(restContext, folderId, updates, callback) {
    RestAPI.Folders.updateFolder(restContext, folderId, updates, function(err, folder) {
        assert.ok(!err);

        // Wait for library and search to be udpated before continuing
        LibraryAPI.Index.whenUpdatesComplete(function() {
            SearchTestUtil.whenIndexingComplete(function() {
                return callback(folder);
            });
        });
    });
};

/**
 * Update a folder, ensuring that it fails in a specified way
 *
 * @param  {RestContext}        restContext     The REST context to use when updating the folder
 * @param  {String}             folderId        The id of the folder to update
 * @param  {Object}             updates         The updates that should be made on the folder
 * @param  {Number}             httpCode        The expected failure HTTP code of the request
 * @param  {Function}           callback        Standard callback function
 * @throws {AssertionError}                     Thrown if the request did not fail in the expected manner
 */
var assertUpdateFolderFails = module.exports.assertUpdateFolderFails = function(restContext, folderId, updates, httpCode, callback) {
    RestAPI.Folders.updateFolder(restContext, folderId, updates, function(err, folder) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        assert.ok(!folder);
        return callback();
    });
};

/**
 * Update the visibility folder's content items, ensuring that it fails in a specified way
 *
 * @param  {RestContext}        restContext     The REST context to use when updating the folder
 * @param  {String}             folderId        The id of the folder to update
 * @param  {Object}             updates         The updates that should be made on the folder
 * @param  {Number}             httpCode        The expected failure HTTP code of the request
 * @param  {Function}           callback        Standard callback function
 * @throws {AssertionError}                     Thrown if the request did not fail in the expected manner
 */
var assertUpdateFolderContentVisibilityFails = module.exports.assertUpdateFolderContentVisibilityFails = function(restContext, folderId, visibility, httpCode, callback) {
    RestAPI.Folders.updateFolderContentVisibility(restContext, folderId, visibility, function(err, folder) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        assert.ok(!folder);
        return callback();
    });
};

/**
 * Delete a folder, ensuring that it fails in a specified way
 *
 * @param  {RestContext}        restContext     The REST context to use when deleting the folder
 * @param  {String}             folderId        The id of the folder to delete
 * @param  {Number}             httpCode        The expected failure HTTP code of the request
 * @param  {Function}           callback        Standard callback function
 * @throws {AssertionError}                     Thrown if the request did not fail in the expected manner
 */
var assertDeleteFolderFails = module.exports.assertDeleteFolderFails = function(restContext, folderId, httpCode, callback) {
    RestAPI.Folders.deleteFolder(restContext, folderId, false, function(err) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        return callback();
    });
};

/**
 * Delete a folder, ensuring that the request is successful
 *
 * @param  {RestContext}        restContext     The REST context to use when deleting the folder
 * @param  {String}             folderId        The id of the folder to delete
 * @param  {Boolean}            deleteContent   whether or not to delete the content in the folder as well
 * @param  {Function}           callback        Standard callback function
 * @throws {AssertionError}                     Thrown if the request failed
 */
var assertDeleteFolderSucceeds = module.exports.assertDeleteFolderSucceeds = function(restContext, folderId, deleteContent, callback) {
    RestAPI.Folders.deleteFolder(restContext, folderId, deleteContent, function(err) {
        assert.ok(!err);

        // Wait for library and search to be updated before continuing
        LibraryAPI.Index.whenUpdatesComplete(function() {
            SearchTestUtil.whenIndexingComplete(function() {
                return FoldersLibrary.whenAllPurged(callback);
            });
        });
    });
};

/**
 * Get the content library of a folder, ensuring that it fails in the specified manner
 *
 * @param  {RestContext}        restContext     The REST context to use when getting the content library
 * @param  {String}             folderId        The id of the folder whose content library to get
 * @param  {String}             start           The starting point from where to list folders in the library
 * @param  {Number}             limit           The maximum number of content items to fetch
 * @param  {Number}             httpCode        The expected failure HTTP code of the request
 * @param  {Function}           callback        Standard callback function
 * @throws {AssertionError}                     Thrown if the request did not fail in the expected manner
 */
var assertGetFolderContentLibraryFails = module.exports.assertGetFolderContentLibraryFails = function(restContext, folderId, start, limit, httpCode, callback) {
    RestAPI.Folders.getFolderContentLibrary(restContext, folderId, start, limit, function(err, result) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        assert.ok(!result);
        return callback();
    });
};

/**
 * Get the content library of a folder, ensuring that it succeeds
 *
 * @param  {RestContext}        restContext         The REST context to use when getting the content library
 * @param  {String}             folderId            The id of the folder whose content library to get
 * @param  {String}             start               The starting point from where to list folders in the library
 * @param  {Number}             limit               The maximum number of content items to fetch
 * @param  {Function}           callback            Standard callback function
 * @param  {Object}             callback.result     The result object, as per `RestAPI.Folders.getFolderContentLibrary`
 * @throws {AssertionError}                         Thrown if the request did not succeed
 */
var assertGetFolderContentLibrarySucceeds = module.exports.assertGetFolderContentLibrarySucceeds = function(restContext, folderId, start, limit, callback) {
    RestAPI.Folders.getFolderContentLibrary(restContext, folderId, start, limit, function(err, result) {
        assert.ok(!err);
        assert.ok(_.isArray(result.results));
        assert.ok(_.isString(result.nextToken) || _.isNull(result.nextToken));

        // If a valid limit was specified (valid meaning above 0 and less than the maximum amount of
        // 25), ensure the `nextToken` is shown if there were less than the expected amount of
        // results
        if (_.isNumber(limit) && limit > 0 && result.results.length < limit && limit <= 25) {
            assert.strictEqual(result.nextToken, null);
        }

        // Ensure each result has an id
        _.each(result.results, function(result) {
            assert.ok(result.id);
        });

        return callback(result);
    });
};

/**
 * Assert that a folder contains all the expected content items
 *
 * @param  {RestContext}        restContext     The REST context to use when getting the folder library
 * @param  {String}             folderId        The id of the folder to get the content items for
 * @param  {String[]}           contentIds      The content item ids that should be in the folder. Can be empty
 * @param  {Function}           callback        Standard callback function
 * @throws {AssertionError}                     Thrown if the folder contained the wrong or is missing content items
 */
var assertFolderEquals = module.exports.assertFolderEquals = function(restContext, folderId, contentIds, callback) {
    getAllFolderContentItems(restContext, folderId, null, function(contentItems) {
        assert.strictEqual(contentItems.length, contentIds.length);

        _.each(contentIds, function(contentId) {
            assert.ok(_.findWhere(contentItems, {'id': contentId}));
        });
        return callback();
    });
};

/**
 * Try and get the members of a folder, ensuring that the request fails
 *
 * @param  {RestContext}        restContext     The REST context to use when getting the folder members
 * @param  {String}             folderId        The id of the folder whose members to get
 * @param  {String}             start           The starting point from where to list members of the folder
 * @param  {Number}             limit           The maximum number of members to fetch
 * @param  {Number}             httpCode        The expected failure HTTP code of the request
 * @param  {Function}           callback        Standard callback function
 * @throws {AssertionError}                     Thrown if the request did not fail in the expected manner
 */
var assertGetFolderMembersFails = module.exports.assertGetFolderMembersFails = function(restContext, folderId, start, limit, httpCode, callback) {
    RestAPI.Folders.getFolderMembers(restContext, folderId, start, limit, function(err, result) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        assert.ok(!result);
        return callback();
    });
};

var assertGetAllFolderMembersSucceeds = module.exports.assertGetAllFolderMembersSucceeds = function(restContext, folderId, opts, callback, _members, _responses, _nextToken) {
    _members = _members || [];
    _responses = _responses || [];
    if (_nextToken === null) {
        return callback(_members, _responses);
    }

    opts = opts || {};
    opts.batchSize = opts.batchSize || 25;
    assertGetFolderMembersSucceeds(restContext, folderId, _nextToken, opts.batchSize, function(result) {
        _responses.push(result);
        return assertGetAllFolderMembersSucceeds(restContext, folderId, opts, callback, _.union(_members, result.results), _responses, result.nextToken);
    });
};

/**
 * Get the members of a folder, ensuring that the request succeeds
 *
 * @param  {RestContext}        restContext         The REST context to use when getting the folder members
 * @param  {String}             folderId            The id of the folder whose members to get
 * @param  {String}             start               The starting point from where to list members of the folder
 * @param  {Number}             limit               The maximum number of members to fetch
 * @param  {Function}           callback            Standard callback function
 * @param  {Object}             callback.result     The result object, as per `RestAPI.Folders.getFolderMembers`
 * @throws {AssertionError}                         Thrown if the request did not succeed
 */
var assertGetFolderMembersSucceeds = module.exports.assertGetFolderMembersSucceeds = function(restContext, folderId, start, limit, callback) {
    RestAPI.Folders.getFolderMembers(restContext, folderId, start, limit, function(err, result) {
        assert.ok(!err);
        assert.ok(result);
        assert.ok(_.isArray(result.results));
        assert.ok(_.isString(result.nextToken) || _.isNull(result.nextToken));

        // If we specified a valid limit and the result set was smaller, we must have no items left
        if (_.isNumber(limit) && limit > 0 && result.results.length < limit) {
            assert.strictEqual(result.nextToken, null);
        }

        // Ensure each result has a profile and a valid role
        _.each(result.results, function(result) {
            assert.ok(result);
            assert.ok(result.profile);
            assert.ok(result.profile.id);
            assert.ok(_.contains(['manager', 'viewer'], result.role));
        });

        return callback(result);
    });
};

var assertGetAllFoldersLibrarySucceeds = module.exports.assertGetAllFoldersLibrarySucceeds = function(restContext, principalId, opts, callback, _folders, _responses, _nextToken) {
    _folders = _folders || [];
    _responses = _responses || [];
    if (_nextToken === null) {
        return callback(_folders, _responses);
    }

    opts = opts || {};
    opts.batchSize = opts.batchSize || 25;
    assertGetFoldersLibrarySucceeds(restContext, principalId, _nextToken, opts.batchSize, function(result) {
        _responses.push(result);
        return assertGetAllFoldersLibrarySucceeds(restContext, principalId, opts, callback, _.union(_folders, result.results), _responses, result.nextToken);
    });
};

/**
 * Get the folders library of a specified user or group, ensuring that the request succeeds
 *
 * @param  {RestContext}        restContext         The REST context to use when getting the folders library
 * @param  {String}             principalId         The principal id for which to remove the folder from the library
 * @param  {String}             start               The starting point from where to list folders in the library
 * @param  {Number}             limit               The maximum number of folders to fetch
 * @param  {Function}           callback            Standard callback function
 * @param  {Object}             callback.result     The result object, as per `RestAPI.Folders.getFoldersLibrary`
 * @throws {AssertionError}                         Thrown if the request did not succeed
 */
var assertGetFoldersLibrarySucceeds = module.exports.assertGetFoldersLibrarySucceeds = function(restContext, principalId, start, limit, callback) {
    RestAPI.Folders.getFoldersLibrary(restContext, principalId, start, limit, function(err, result) {
        assert.ok(!err);
        assert.ok(result);
        assert.ok(_.isArray(result.results));
        assert.ok(_.isString(result.nextToken) || _.isNull(result.nextToken));

        // If a valid limit was specified (valid meaning above 0 and below the maximum amount of
        // 25), ensure the `nextToken` is shown if there were less than the expected amount of
        // results
        if (_.isNumber(limit) && limit > 0 && result.results.length < limit && limit <= 25) {
            assert.strictEqual(result.nextToken, null);
        }

        // Ensure each result has an id
        _.each(result.results, function(result) {
            assert.ok(result);
            assert.ok(result.id);
        });

        return callback(result);
    });
};

/**
 * Try to get the folders library of a specified user or group, ensuring that the request fails
 * in the specified manner
 *
 * @param  {RestContext}        restContext         The REST context to use when getting the folders library
 * @param  {String}             principalId         The id of the user or group whose folders library to get
 * @param  {String}             start               The starting point from where to list folders in the library
 * @param  {Number}             limit               The maximum number of folders to fetch
 * @param  {Number}             httpCode            The expected failure HTTP code of the request
 * @param  {Function}           callback            Standard callback function
 * @throws {AssertionError}                         Thrown if the request did not fail in the expected manner
 */
var assertGetFoldersLibraryFails = module.exports.assertGetFoldersLibraryFails = function(restContext, principalId, start, limit, httpCode, callback) {
    RestAPI.Folders.getFoldersLibrary(restContext, principalId, start, limit, function(err, result) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        assert.ok(!result);
        return callback();
    });
};

/**
 * Try to remove a folder from a principal's library, ensuring that the request fails
 * in the specified manner
 *
 * @param  {RestContext}        restContext         The REST context to use when removing the folder from the principal library
 * @param  {String}             principalId         The principal id for which to remove the folder from the library
 * @param  {String}             folderId            The id of the folder that should be removed
 * @param  {Number}             httpCode            The expected failure HTTP code of the request
 * @param  {Function}           callback            Standard callback function
 * @throws {AssertionError}                         Thrown if the request did not fail in the expected manner
 */
var assertRemoveFolderFromLibraryFails = module.exports.assertRemoveFolderFromLibraryFails = function(restContext, principalId, folderId, httpCode, callback) {
    RestAPI.Folders.removeFolderFromLibrary(restContext, principalId, folderId, function(err, result) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        assert.ok(!result);
        return callback();
    });
};

/**
 * Remove a folder from a principal's library, ensuring that the folder has been removed
 *
 * @param  {RestContext}        restContext         The REST context to use when removing the folder from the principal library
 * @param  {String}             principalId         The principal id for which to remove the folder from the library
 * @param  {String}             folderId            The id of the folder that should be removed
 * @param  {Function}           callback            Standard callback function
 * @throws {AssertionError}                         Thrown if the request failed
 */
var assertRemoveFolderFromLibrarySucceeds = module.exports.assertRemoveFolderFromLibrarySucceeds = function(restContext, principalId, folderId, callback) {
    RestAPI.Folders.removeFolderFromLibrary(restContext, principalId, folderId, function(err, result) {
        assert.ok(!err);

        // Assert that the folder really was removed
        assertGetFoldersLibrarySucceeds(restContext, principalId, null, null, function(folders) {
            var folder = _.findWhere(folders, {'id': folderId});
            assert.ok(!folder);
            return callback();
        });
    });
};

/**
 * Share a folder with a set of users and groups, ensuring that the request succeeds. The list
 * of viewers provided is a mixed array of strings (target principal ids) or objects:
 *
 *  * String:   If the viewer is a plain string, it should be a simple id of the target principal to
 *              share with. When a string is used, no assertions will be done on the library of the
 *              target principal after the share has completed, as we do not know how to reliably
 *              access the libraries
 *
 *  * Object:   If the viewer is an object, it is assumed to represent either a user or a group,
 *              containing both the profile and rest context with which we can access the
 *              principal's private libraries (e.g., the user themself, or the manager of the
 *              group). Given an object, the assertion will also verify that the library of the
 *              target principal was updated as expected
 *
 * @param  {RestContext}        restContext     The REST context to use when sharing the folder
 * @param  {String}             folderId        The id of the folder to share
 * @param  {Object[]}           viewers         A mixed array of strings and objects. See summary for more info
 * @param  {Function}           callback        Standard callback function
 * @throws {AssertionError}                     Thrown if the request did not succeed
 */
var assertShareFolderSucceeds = module.exports.assertShareFolderSucceeds = function(managerRestContext, actorRestContext, folderId, viewers, callback) {
    var viewersSplit = _.partition(viewers, function(viewer) {
        return (_.isString(viewer));
    });

    // Get the viewer infos from the input while making the object more agnostic to the principal
    // type by changing the "user" / "group" key to just "profile"
    var viewerInfos = _.chain(viewersSplit)
        .last()
        .map(_generalizePrincipalInfoModel)
        .value();
    var viewerInfoIds = _.chain(viewerInfos)
        .pluck('profile')
        .pluck('id')
        .value();

    // Get all the viewer ids, including those extracted from the viewer info objects
    var viewerIds = _.chain(viewersSplit)
        .first()
        .union(viewerInfoIds)
        .value();

    // First get all the folder members so we can ensure the library is fresh and compare the
    // membership before and after the operation
    getAllFolderMembers(managerRestContext, folderId, null, function(results) {
        var memberRolesBefore = AuthzTestUtil.getMemberRolesFromResults(results);

        AuthzTestUtil.assertGetInvitationsSucceeds(managerRestContext, 'folder', folderId, function(result) {
            var emailRolesBefore = AuthzTestUtil.getEmailRolesFromResults(result.results);

            // Determine what role changes should be applied in the share operation
            var roleChanges = {};
            _.each(viewerIds, function(viewerId) {
                if (!memberRolesBefore[viewerId] && !emailRolesBefore[viewerId]) {
                    roleChanges[viewerId] = 'viewer';
                }
            });

            // Get the folders libraries of all principals before adding them as members to ensure
            // they have been built and will be updated on the fly
            _getAllFoldersInLibraries(viewerInfos, function(principalFoldersLibrariesBeforeShare) {

                // Share the folder with all the principals and wait for the library updates to complete
                RestAPI.Folders.shareFolder(actorRestContext, folderId, viewerIds, function(err) {
                    assert.ok(!err);
                    LibraryAPI.Index.whenUpdatesComplete(function() {

                        // Ensure the invitations and members of the folder were udpated as we would expect
                        AuthzTestUtil.assertGetInvitationsSucceeds(managerRestContext, 'folder', folderId, function(result) {
                            AuthzTestUtil.assertEmailRolesEquals(emailRolesBefore, roleChanges, AuthzTestUtil.getEmailRolesFromResults(result.results));

                            getAllFolderMembers(managerRestContext, folderId, null, function(results) {
                                AuthzTestUtil.assertMemberRolesEquals(memberRolesBefore, roleChanges, AuthzTestUtil.getMemberRolesFromResults(results));

                                // Ensure the folder libraries of all the principals we shared with contain the folder
                                _getAllFoldersInLibraries(viewerInfos, function(principalFoldersLibrariesAfterShare) {
                                    _.each(principalFoldersLibrariesAfterShare, function(foldersLibrary, principalId) {
                                        assert.ok(_.chain(foldersLibrary).pluck('id').contains(foldersLibrary, folderId));
                                    });

                                    // Purge the folder libraries of all users to ensure a rebuild will
                                    // still contain the shared folder
                                    _purgeFoldersLibraries(viewerInfoIds, function() {

                                        // Ensure the rebuilt libraries of all the principals we shared with contain the folder
                                        _getAllFoldersInLibraries(viewerInfos, function(principalFoldersLibrariesAfterShare) {
                                            _.each(principalFoldersLibrariesAfterShare, function(foldersLibrary, principalId) {
                                                assert.ok(_.chain(foldersLibrary).pluck('id').contains(foldersLibrary, folderId));
                                            });

                                            return callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });
};

/**
 * Try to share a folder with a set of users and groups, ensuring that the request fails in the
 * specified manner
 *
 * @param  {RestContext}        restContext     The REST context to use when sharing the folder
 * @param  {String}             folderId        The id of the folder to share
 * @param  {String[]}           viewerIds       The ids of the users and groups with which to share
 * @param  {Number}             httpCode        The expected failure HTTP code of the request
 * @param  {Function}           callback        Standard callback function
 * @throws {AssertionError}                     Thrown if the request did not fail in the expected manner
 */
var assertShareFolderFails = module.exports.assertShareFolderFails = function(managerRestContext, actorRestContext, folderId, viewerIds, httpCode, callback) {
    RestAPI.Folders.shareFolder(actorRestContext, folderId, viewerIds, function(err) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        return callback();
    });
};

/**
 * Try to update the members of a folder, ensuring that the request fails in the specified
 * manner
 *
 * @param  {RestContext}        restContext     The REST context to use when updating the folder members
 * @param  {String}             folderId        The id of the folder whose members to udpate
 * @param  {Object}             memberUpdates   The member update object, keyed by principal id whose value is a role to apply to a principal, or `false` if the principal should be removed
 * @param  {Number}             httpCode        The expected failure HTTP code of the request
 * @param  {Function}           callback        Standard callback function
 * @throws {AssertionError}                     Thrown if the request did not fail in the expected manner
 */
var assertUpdateFolderMembersFails = module.exports.assertUpdateFolderMembersFails = function(managerRestContext, actorRestContext, folderId, memberUpdates, httpCode, callback) {
    RestAPI.Folders.updateFolderMembers(actorRestContext, folderId, memberUpdates, function(err) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        return callback();
    });
};

/**
 * Update the members of a folder, ensuring that the request succeeds. The provided member
 * update info is keyed by the principal id whose role should change, and the value should be one
 * of the following:
 *
 *  * String:   A string indicates that it is simply the role to give to the user. In this case, the
 *              principal's library cannot be verified after the operation as we do not have a rest
 *              context to use to request their library
 *
 *  * Boolean:  Only `false` is valid, indicates that the user membership should be removed
 *
 *  * Object:   If an object, it should be the standard principal info object containing the
 *              `restContext` key (A REST context that can be used to have "manager"
 *              access to the user or group's feeds) and either a `user` or `group` key, containing
 *              the profile of the principal, dependent on if it is a user or a group, respectively.
 *              Additionally, there should be a `role` key that is either a String or Boolean,
 *              indicating how to change the principal's membership on the folder. If provided,
 *              further assertions will be performed on the libraries of the target principals using
 *              the provided REST context
 *
 * @param  {RestContext}        restContext         The REST context to use when updating the folder members
 * @param  {String}             folderId            The id of the folder whose members to udpate
 * @param  {Object}             memberUpdateInfos   The member update object. See summary for more information
 * @param  {Function}           callback            Standard callback function
 * @throws {AssertionError}                         Thrown if the request did not succeed
 */
var assertUpdateFolderMembersSucceeds = module.exports.assertUpdateFolderMembersSucceeds = function(managerRestContext, actorRestContext, folderId, memberUpdateInfos, callback) {
    // Determine the roles to actually apply, and those that are the memberInfo objects so we can
    // perform additional assertions on them
    var roleChange = {};
    var memberInfos = [];
    _.each(memberUpdateInfos, function(memberUpdateInfo, principalId) {
        memberUpdateInfo = _generalizePrincipalInfoModel(memberUpdateInfo);
        if (_.isObject(memberUpdateInfo)) {
            // Normalize the member info object to have a generic `profile` key instead of a `user`
            // or `group` key
            memberInfos.push(memberUpdateInfo);
            roleChange[principalId] = memberUpdateInfo.role;
        } else {
            roleChange[principalId] = memberUpdateInfo;
        }
    });

    getAllFolderMembers(managerRestContext, folderId, null, function(results) {
        var memberRolesBefore = AuthzTestUtil.getMemberRolesFromResults(results);

        AuthzTestUtil.assertGetInvitationsSucceeds(managerRestContext, 'folder', folderId, function(result) {
            var emailRolesBefore = AuthzTestUtil.getEmailRolesFromResults(result.results);

            // Get the folder libraries to ensure they are not stale and will be updated on the fly
            _getAllFoldersInLibraries(memberInfos, function(principalFoldersLibrariesBeforeUpdate) {

                RestAPI.Folders.updateFolderMembers(actorRestContext, folderId, roleChange, function(err) {
                    assert.ok(!err);

                    // Ensure the member and email roles are as we expect given the change made
                    AuthzTestUtil.assertGetInvitationsSucceeds(managerRestContext, 'folder', folderId, function(result) {
                        AuthzTestUtil.assertEmailRolesEquals(emailRolesBefore, roleChange, AuthzTestUtil.getEmailRolesFromResults(result.results));
                        getAllFolderMembers(managerRestContext, folderId, null, function(results) {
                            AuthzTestUtil.assertMemberRolesEquals(memberRolesBefore, roleChange, AuthzTestUtil.getMemberRolesFromResults(results));

                            // For all the members we had a rest context for, ensure their libraries are updated
                            // appropriately to contain (or not contain) this folder
                            _getAllFoldersInLibraries(memberInfos, function(principalFoldersLibrariesAfterUpdate) {
                                _.each(roleChange, function(change, memberId) {
                                    var foldersLibrary = principalFoldersLibrariesAfterUpdate[memberId];
                                    if (foldersLibrary) {
                                        var containsFolder = _.chain(foldersLibrary).pluck('id').contains(folderId).value();
                                        if (change === false) {
                                            assert.ok(!containsFolder);
                                        } else {
                                            assert.ok(containsFolder);
                                        }
                                    }
                                });

                                return callback();
                            });
                        });
                    });
                });
            });
        });
    });
};

/**
 * Ensure the folders library of the provided user or group strictly contains just the specified
 * folder ids, and optionally in the same order
 *
 * @param  {RestContext}    restContext             The REST context to use when getting the folders library
 * @param  {String}         principalId             The id of the user or group whose folders library to test
 * @param  {String[]}       expectedFolderIds       The folder ids to ensure are present in the library
 * @param  {Boolean}        ensureOrder             When `true`, ensures that the order of items in the folder library matches the order of folder ids in `expectedFolderIds`
 * @param  {Function}       callback                Standard callback function
 * @throws {AssertionError}                         Thrown if any assertions failed
 */
var assertFullFoldersLibraryEquals = module.exports.assertFullFoldersLibraryEquals = function(restContext, principalId, expectedFolderIds, ensureOrder, callback) {
    getAllFoldersInLibrary(restContext, principalId, null, function(folders) {
        var actualFolderIds = _.pluck(folders, 'id');

        // If we aren't ensuring they are in the correct order, simply force-sort the arrays of ids
        if (!ensureOrder) {
            expectedFolderIds.sort();
            actualFolderIds.sort();
        }

        // Ensure the sets of folder ids are identical
        assert.deepEqual(actualFolderIds, expectedFolderIds);

        return callback();
    });
};

/**
 * Ensure that searching through a folder results in the expected content items
 *
 * @param  {RestContext}        restContext         The REST context to use when searching through the folder
 * @param  {String}             folderId            The id of the folder to search through
 * @param  {String}             q                   The term to search on
 * @param  {Content[]}          expectedContent     The set of content items to be returned
 * @param  {Function}           callback            Standard callback function
 * @throws {AssertionError}                         Thrown if any assertions failed
 */
var assertFolderSearchEquals = module.exports.assertFolderSearchEquals = function(restContext, folderId, q, expectedContent, callback) {
    SearchTestUtil.searchAll(restContext, 'folder-content', [folderId], {'q': q, 'scope': '_network'}, function(err, results) {
        assert.ok(!err);

        // Assert we've got the exact number of results that we expected (in case we want 0 results)
        assert.strictEqual(results.results.length, expectedContent.length);

        // Assert that the results that came back are the ones we expected
        _.each(expectedContent, function(content) {
            assert.ok(_.findWhere(results.results, {'id': content.id}));
        });

        return callback();
    });
};

/**
 * Ensure that searching for folders results in the expected folders
 *
 * @param  {RestContext}        restContext         The REST context to use when searching for folders
 * @param  {String}             q                   The term to search on
 * @param  {Folder[]}           expectedFolders     The set of folders that are supposed to come back
 * @param  {Folder[]}           missingFolders      Folders that should not be included in the result set
 * @param  {Function}           callback            Standard callback function
 * @throws {AssertionError}                         Thrown if any assertions failed
 */
var assertGeneralFolderSearchEquals = module.exports.assertGeneralFolderSearchEquals = function(restContext, q, expectedFolders, missingFolders, callback) {
    SearchTestUtil.searchAll(restContext, 'general', null, {'resourceTypes': 'folder', 'q': q, 'scope': '_network'}, function(err, results) {
        assert.ok(!err);
        _assertSearchResults(results, expectedFolders, missingFolders);
        return callback();
    });
};

/**
 * Ensure that searching for folders inside of a folder library results in the expected folders
 *
 * @param  {RestContext}        restContext         The REST context to use when searching for folders
 * @param  {String}             principalId         The principal id for which to search through the folder library
 * @param  {String}             q                   The term to search on
 * @param  {Folder[]}           expectedFolders     The set of folders that are supposed to come back
 * @param  {Folder[]}           missingFolders      Folders that should not be included in the result set
 * @param  {Function}           callback            Standard callback function
 * @throws {AssertionError}                         Thrown if any assertions failed
 */
var assertFolderLibrarySearch = module.exports.assertFolderLibrarySearch = function(restContext, principalId, q, expectedFolders, missingFolders, callback) {
    SearchTestUtil.searchAll(restContext, 'folder-library', [principalId], {'q': q}, function(err, results) {
        assert.ok(!err);
        _assertSearchResults(results, expectedFolders, missingFolders);
        return callback();
    });
};

/**
 * Assert a set of search results contains the expected items
 *
 * @param  {Object}             results             The search results as returned by the search endpoints
 * @param  {Folder[]}           expectedFolders     A set of folders that should be returned in the search results
 * @param  {Folder[]}           missingFolders      A set of folders that should not be returned in the search results
 * @throws {AssertionError}                         Thrown if any assertions failed
 * @api private
 */
var _assertSearchResults = function(results, expectedFolders, missingFolders) {
    // Assert that the results that came back are the ones we expected
    _.each(expectedFolders, function(folder) {
        var searchResult = _.findWhere(results.results, {'id': folder.id});
        assert.ok(searchResult);

        // Assert all the expected properties are returned
        assert.strictEqual(searchResult.displayName, folder.displayName);
        assert.strictEqual(searchResult.description, folder.description);
        assert.strictEqual(searchResult.visibility, folder.visibility);
        var tenantAlias = folder.tenant.alias;
        var resourceId = AuthzUtil.getResourceFromId(folder.id).resourceId;
        assert.strictEqual(searchResult.profilePath, util.format('/folder/%s/%s', tenantAlias, resourceId));

        // If the folder has a thumbnail, we assert the search result has it as well
        if (folder.previews && folder.previews.thumbnailUri) {
            assert.ok(searchResult.thumbnailUrl);

        // If the folder has no thumbnail, the search result shouldn't have one either
        } else {
            assert.ok(!searchResult.thumbnailUrl);
        }
    });

    // Assert some folders are NOT included in the result set
    _.each(missingFolders, function(folder) {
        assert.ok(!_.findWhere(results.results, {'id': folder.id}));
    });
};

/**
 * Ensure that searching through a folder results in an error
 *
 * @param  {RestContext}        restContext         The REST context to use when searching through the folder
 * @param  {String}             folderId            The id of the folder to search through
 * @param  {Number}             httpCode            The HTTP error code that should be returned
 * @param  {Function}           callback            Standard callback function
 * @throws {AssertionError}                         Thrown if any assertions failed
 */
var assertFolderSearchFails = module.exports.assertFolderSearchFails = function(restContext, folderId, httpCode, callback) {
    SearchTestUtil.searchAll(restContext, 'folder-content', [folderId], null, function(err, results) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        return callback();
    });
};

/**
 * Ensure the members of a specified folder is strictly equal to the provided set of expected
 * members and their roles
 *
 * @param  {RestContext}        restContext             The REST context to use when getting the folder members
 * @param  {String}             folderId                The id of the folder whose members to test
 * @param  {Object}             expectedMemberRoles     An object keyed by principal id whose values are their expected role, indicating the expected members of the folder
 * @param  {Function}           callback                Standard callback function
 * @throws {AssertionError}                             Thrown if any assertions failed
 */
var assertFullFolderMembersEquals = module.exports.assertFullFolderMembersEquals = function(restContext, folderId, expectedMemberRoles, callback) {
    // Remove any roles that contain a role of `false` as they would have been removed
    expectedMemberRoles = _.extend({}, expectedMemberRoles);
    _.each(expectedMemberRoles, function(role, userId) {
        if (role === false) {
            delete expectedMemberRoles[userId];
        }
    });

    // Get the full members set to compare against
    getAllFolderMembers(restContext, folderId, null, function(actualMembers) {
        var actualMemberRoles = {};
        _.each(actualMembers, function(member) {
            actualMemberRoles[member.profile.id] = member.role;
        });

        assert.deepEqual(actualMemberRoles, expectedMemberRoles);

        return callback();
    });
};

/**
 * Page through all the folders in a user or group's folder library and return all
 * folders that were fetched
 *
 * @param  {RestContext}    restContext             The REST context to use when getting the folders library
 * @param  {String}         principalId             The id of the user or group whose folders library to get
 * @param  {Object}         [opts]                  Optional arguments for getting the folders library
 * @param  {Number}         [opts.batchSize]        The size of the batch to use to fetch the folders in the library. Default: 25
 * @param  {Function}       callback                Standard callback function
 * @param  {Folder[]}       callback.folders        A list of all folders in the library
 * @param  {Object[]}       callback.responses      All the raw web responses that were received for each page request
 */
var getAllFoldersInLibrary = module.exports.getAllFoldersInLibrary = function(restContext, principalId, opts, callback, _nextToken, _folders, _responses) {
    opts = opts || {};
    opts.batchSize = opts.batchSize || 25;
    _folders = _folders || [];
    _responses = _responses || [];
    if (_nextToken === null) {
        return callback(_folders, _responses);
    }

    assertGetFoldersLibrarySucceeds(restContext, principalId, _nextToken, opts.batchSize, function(result) {
        _responses.push(result);
        return getAllFoldersInLibrary(restContext, principalId, opts, callback, result.nextToken, _.union(_folders, result.results), _responses);
    });
};

/**
 * Page through all the content items in a folder's content library and return all content items
 * that were fetched
 *
 * @param  {RestContext}    restContext             The REST context to use when getting the content library
 * @param  {String}         folderId                The id of the folder whose content library to get
 * @param  {Object}         [opts]                  Optional arguments for getting the content library
 * @param  {Number}         [opts.batchSize]        The size of the batch to use to fetch the content in the library. Default: 25
 * @param  {Function}       callback                Standard callback function
 * @param  {Folder[]}       callback.contentItems   A list of all content items in the library
 * @param  {Object[]}       callback.responses      All the raw web responses that were received for each page request
 */
var getAllFolderContentItems = module.exports.getAllFolderContentItems = function(restContext, folderId, opts, callback, _nextToken, _contentItems, _responses) {
    opts = opts || {};
    opts.batchSize = opts.batchSize || 25;
    _contentItems = _contentItems || [];
    _responses = _responses || [];
    if (_nextToken === null) {
        return callback(_contentItems, _responses);
    }

    assertGetFolderContentLibrarySucceeds(restContext, folderId, _nextToken, opts.batchSize, function(result) {
        _responses.push(result);
        return getAllFolderContentItems(restContext, folderId, opts, callback, result.nextToken, _.union(_contentItems, result.results), _responses);
    });
};

/**
 * Page through all the members of a folder and return all users and groups that were fetched
 *
 * @param  {RestContext}    restContext             The REST context to use when getting the folder members
 * @param  {String}         folderId                The id of the folder whose members to get
 * @param  {Object}         [opts]                  Optional arguments for getting the folder members
 * @param  {Number}         [opts.batchSize]        The size of the batch to use to fetch the members of the folder. Default: 25
 * @param  {Function}       callback                Standard callback function
 * @param  {Principal[]}    callback.members        A list of all users and groups who are members of the folder
 * @param  {Object[]}       callback.responses      All the raw web responses that were received for each page request
 */
var getAllFolderMembers = module.exports.getAllFolderMembers = function(restContext, folderId, opts, callback, _nextToken, _members, _responses) {
    opts = opts || {};
    opts.batchSize = opts.batchSize || 25;
    _members = _members || [];
    _responses = _responses || [];
    if (_nextToken === null) {
        return callback(_members, _responses);
    }

    assertGetFolderMembersSucceeds(restContext, folderId, _nextToken, opts.batchSize, function(result) {
        _responses.push(result);
        return getAllFolderMembers(restContext, folderId, opts, callback, result.nextToken, _.union(_members, result.results), _responses);
    });
};

/**
 * Try to create a new message on a folder, and ensure it fails in a specified way
 *
 * @param  {RestContext}        restContext     The REST context to use when creating the message
 * @param  {String}             folderId        The id of the folder on which to try and create the message
 * @param  {String}             body            The body of the message to post
 * @param  {String|Number}      [replyTo]       The created time of the message on which this is a reply, if applicable
 * @param  {Number}             httpCode        The expected failure HTTP code of the request
 * @param  {Function}           callback        Standard callback function
 * @throws {AssertionError}                     Thrown if the request did not fail in the expected manner
 */
var assertCreateMessageFails = module.exports.assertCreateMessageFails = function(restContext, folderId, body, replyTo, httpCode, callback) {
    RestAPI.Folders.createMessage(restContext, folderId, body, replyTo, function(err) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        return callback();
    });
};

/**
 * Try to create a new message on a folder, and ensure it does not fail
 *
 * @param  {RestContext}        restContext             The REST context to use when creating the message
 * @param  {String}             folderId                The id of the folder on which to try and create the message
 * @param  {String}             body                    The body of the message to post
 * @param  {String|Number}      [replyTo]               The created time of the message on which this is a reply, if applicable
 * @param  {Function}           callback                Standard callback function
 * @param  {Message}            callback.message        The created message
 * @throws {AssertionError}                             Thrown if the request failed
 */
var assertCreateMessageSucceeds = module.exports.assertCreateMessageSucceeds = function(restContext, folderId, body, replyTo, callback) {
    RestAPI.Folders.createMessage(restContext, folderId, body, replyTo, function(err, message) {
        assert.ok(!err);
        return callback(message);
    });
};

/**
 * Try to get the messages for a folder, and ensure the request fails in a specified way
 *
 * @param  {RestContext}        restContext     The REST context to use when getting the messages
 * @param  {String}             folderId        The id of the folder for which to get the messages
 * @param  {String}             [start]         The starting point from where to list messages on the folder
 * @param  {Number}             [limit]         The number of messages that should be retrieved
 * @param  {Number}             httpCode        The expected failure HTTP code of the request
 * @param  {Function}           callback        Standard callback function
 * @throws {AssertionError}                     Thrown if the request did not fail in the expected manner
 */
var assertGetMessagesFails = module.exports.assertGetMessagesFails = function(restContext, folderId, start, limit, httpCode, callback) {
    RestAPI.Folders.getMessages(restContext, folderId, start, limit, function(err, result) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        return callback();
    });
};

/**
 * Try to get the messages for a folder, and ensure the request doesn't fail
 *
 * @param  {RestContext}        restContext     The REST context to use when getting the messages
 * @param  {String}             folderId        The id of the folder for which to get the messages
 * @param  {String}             [start]         The starting point from where to list messages on the folder
 * @param  {Number}             [limit]         The number of messages that should be retrieved
 * @param  {Function}           callback        Standard callback function
 * @throws {AssertionError}                     Thrown if the request failed
 */
var assertGetMessagesSucceeds = module.exports.assertGetMessagesSucceeds = function(restContext, folderId, start, limit, callback) {
    RestAPI.Folders.getMessages(restContext, folderId, start, limit, function(err, result) {
        assert.ok(!err);
        return callback(result);
    });
};

/**
 * Try to delete a message from a folder, and ensure the request fails in a specified way
 *
 * @param  {RestContext}        restContext         The REST context to use when deleting a message
 * @param  {String}             folderId            The id of the folder for which to delete a message
 * @param  {String}             messageCreated      The timestamp of the message to delete
 * @param  {Number}             httpCode            The expected failure HTTP code of the request
 * @param  {Function}           callback            Standard callback function
 * @throws {AssertionError}                         Thrown if the request did not fail in the expected manner
 */
var assertDeleteMessageFails = module.exports.assertDeleteMessageFails = function(restContext, folderId, messageCreated, httpCode, callback) {
    RestAPI.Folders.deleteMessage(restContext, folderId, messageCreated, function(err, result) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        return callback();
    });
};

/**
 * Try to delete a message from a folder, and ensure it doesn't fail
 *
 * @param  {RestContext}        restContext         The REST context to use when deleting a message
 * @param  {String}             folderId            The id of the folder for which to delete a message
 * @param  {String}             messageCreated      The timestamp of the message to delete
 * @param  {Function}           callback            Standard callback function
 * @param  {Message}            callback.message    If the deleted message had children, the deleted message will be returned
 * @throws {AssertionError}                         Thrown if the request failed
 */
var assertDeleteMessageSucceeds = module.exports.assertDeleteMessageSucceeds = function(restContext, folderId, messageCreated, callback) {
    RestAPI.Folders.deleteMessage(restContext, folderId, messageCreated, function(err, result) {
        assert.ok(!err);
        return callback(result);
    });
};

/**
 * Set up a provided tenant to have a public, loggedin and private folder
 *
 * @param  {Tenant}     tenant      The tenant to set up
 * @param  {Function}   callback    Standard callback function
 * @api private
 */
var _setupTenant = function(tenant, callback) {
    _createMultiPrivacyFolders(tenant.adminRestContext, function(publicFolder, loggedinFolder, privateFolder) {
        tenant.publicFolder = publicFolder;
        tenant.loggedinFolder = loggedinFolder;
        tenant.privateFolder = privateFolder;
        return callback();
    });
};

/**
 * Create a public, loggedin and private folder using the given REST context
 *
 * @param  {RestContext}    restContext     The REST context to use to create the folders
 * @param  {Function}       callback        Standard callback function
 * @api private
 */
var _createMultiPrivacyFolders = function(restContext, callback) {
    _createFolderWithVisibility(restContext, 'public', function(publicFolder) {
        _createFolderWithVisibility(restContext, 'loggedin', function(loggedinFolder) {
            _createFolderWithVisibility(restContext, 'private', function(privateFolder) {
                return callback(publicFolder, loggedinFolder, privateFolder);
            });
        });
    });
};

/**
 * Create a folder with the provided visibility
 *
 * @param  {RestContext}    restContext     The REST context to use to create the folder
 * @param  {String}         visibility      The visibility that should be applied to the folder
 * @param  {Function}       callback        Standard callback function
 * @api private
 */
var _createFolderWithVisibility = function(restContext, visibility, callback) {
    var randomId = util.format('%s-%s', visibility, shortid.generate());
    var randomDisplayName = util.format('displayName-%s', randomId);
    var randomDescription = util.format('description-%s', randomId);
    RestAPI.Folders.createFolder(restContext, randomDisplayName, randomDescription, visibility, null, null, function(err, folder) {
        assert.ok(!err);
        return callback(folder);
    });
};

/**
 * Get all the folders in all the libraries using the provided principal infos
 *
 * @param  {Object[]}   principalInfos                          An array of principal infos, containing the rest context of the user whose folder library to get
 * @param  {Function}   callback                                Standard callback function
 * @param  {Object}     callback.principalFolderLibraries       An object keyed by principal id, whose value is the array of all folders in that principal's folders library
 * @throws {AssertionError}                                     Thrown if there is an error getting all the folder libraries
 * @api private
 */
var _getAllFoldersInLibraries = function(principalInfos, callback, _principalIdFolders) {
    _principalIdFolders = _principalIdFolders || {};
    if (_.isEmpty(principalInfos)) {
        return callback(_principalIdFolders);
    }

    // Copy the input array so we don't destroy it during recursion
    principalInfos = principalInfos.slice();

    // Get the next principal and gather their folders
    var principalInfo = principalInfos.pop();
    getAllFoldersInLibrary(principalInfo.restContext, principalInfo.profile.id, null, function(folders) {
        // Add the folders to the array and recursively continue to the next
        _principalIdFolders[principalInfo.profile.id] = folders;
        return _getAllFoldersInLibraries(principalInfos, callback, _principalIdFolders);
    });
};

/**
 * Purge the folders libraries for the provided principals. @see LibraryTestUtil.assertPurgeFreshLibraries
 * for more information
 *
 * @param  {String[]}           principalIds    The ids of the principals whose folders libraries to purge
 * @param  {Function}           callback        Standard callback function
 * @throws {AssertionError}                     Thrown if there is an error purging the libraries
 * @api private
 */
var _purgeFoldersLibraries = function(principalIds, callback) {
    LibraryTestUtil.assertPurgeFreshLibraries(FoldersConstants.library.FOLDERS_LIBRARY_INDEX_NAME, principalIds, callback);
};

/**
 * Purge the folder content library for the specified folder. @see LibraryTestUtil.assertPurgeFreshLibraries
 * for more information
 *
 * @param  {String}             folderGroupId       The authz group id of the folder whose content library to purge
 * @param  {Function}           callback            Standard callback function
 * @throws {AssertionError}                         Thrown if there is an error purging the library
 * @api private
 */
var _purgeFolderContentLibrary = function(folderId, callback) {
    // Before proceeding, we wait till the folder has been processed by the preview processor. We do this as the PP
    // needs the folder's content library to generate a thumbnail and we clear it out a few lines lower. If we weren't
    // to wait here, the PP might try to generate a thumbnail for a (temporarily) empty folder library. Note that this
    // shouldn't result in slower (non-PP) tests as the PP won't be bound to the folder generate queue thus
    // `whenTasksEmpty` will return immediately
    MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_GENERATE_FOLDER_PREVIEWS, function() {
        FoldersDAO.getFoldersByIds([folderId], function(err, folders) {
            assert.ok(!err);
            return LibraryTestUtil.assertPurgeFreshLibraries(FoldersConstants.library.CONTENT_LIBRARY_INDEX_NAME, [_.first(folders).groupId], callback);
        });
    });
};

/**
 * Convert the standard principal info object model into something more generic to work with. This
 * basically entails converting the `user` or `group` key which points to the user or group profile
 * (depending on the type of principal) to the key name `profile`
 *
 * TODO: We should change the result of both `generateTestGroups` and `generateTestUsers` to return
 * this generic model always, rather than a `user` and `group` key which is difficult to work with.
 * This has been deferred from the folders PR as the impact on the code base would be too big
 *
 * @param  {Object}     principalInfo   The principal info object to convert
 * @return {Object}                     A principal info object with a generic `profile` key instead of `user` or `group` key
 * @api private
 */
var _generalizePrincipalInfoModel = function(principalInfo) {
    if (!_.isObject(principalInfo)) {
        return principalInfo;
    }

    principalInfo = _.clone(principalInfo);

    if (principalInfo.user) {
        principalInfo.profile = principalInfo.user;
        delete principalInfo.user;
    } else if (principalInfo.group) {
        principalInfo.profile = principalInfo.group;
        delete principalInfo.group;
    }

    return principalInfo;
};
