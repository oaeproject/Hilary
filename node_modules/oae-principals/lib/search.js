/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var util = require('util');

var AuthzAPI = require('oae-authz');
var AuthzSearch = require('oae-authz/lib/search');
var AuthzUtil = require('oae-authz/lib/util');
var ContentUtil = require('oae-content/lib/internal/util');
var log = require('oae-logger').logger('principals-search');
var OaeUtil = require('oae-util/lib/util');
var SearchAPI = require('oae-search');
var SearchConstants = require('oae-search/lib/constants').SearchConstants;
var TenantsAPI = require('oae-tenants');

var PrincipalsAPI = require('oae-principals');
var PrincipalsConstants = require('oae-principals/lib/constants').PrincipalsConstants;
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var PrincipalsDelete = require('oae-principals/lib/delete');
var PrincipalsUtil = require('oae-principals/lib/util');

var User = require('oae-principals/lib/model').User;
var Group = require('oae-principals/lib/model').Group;


////////////////////
// INDEXING TASKS //
////////////////////

/*!
 * When a user is created, we must index the user resource document
 */
PrincipalsAPI.on(PrincipalsConstants.events.CREATED_USER, function(ctx, user) {
    SearchAPI.postIndexTask('user', [{'id': user.id}], {
        'resource': true
    });
});

/*!
 * When a user is updated, we must reindex the user resource document
 */
PrincipalsAPI.on(PrincipalsConstants.events.UPDATED_USER, function(ctx, user) {
    SearchAPI.postIndexTask('user', [{'id': user.id}], {
        'resource': true
    });
});

/*!
 * When a user is deleted, we must reindex the user resource document
 */
PrincipalsAPI.on(PrincipalsConstants.events.DELETED_USER, function(ctx, user) {
    SearchAPI.postIndexTask('user', [{'id': user.id}], {
        'resource': true
    });
});

/*!
 * When a user is restored, we must reindex the user resource document
 */
PrincipalsAPI.on(PrincipalsConstants.events.RESTORED_USER, function(ctx, user) {
    SearchAPI.postIndexTask('user', [{'id': user.id}], {
        'resource': true
    });
});

/*!
 * When a user's email is verified, we must reindex the user resource document
 */
PrincipalsAPI.on(PrincipalsConstants.events.VERIFIED_EMAIL, function(ctx, user) {
    SearchAPI.postIndexTask('user', [{'id': user.id}], {
        'resource': true
    });
});

/*!
 * When a group is created, we must index the group resource document and its members child document
 */
PrincipalsAPI.on(PrincipalsConstants.events.CREATED_GROUP, function(ctx, group, memberChangeInfo) {
    SearchAPI.postIndexTask('group', [{'id': group.id}], {
        'resource': true,
        'children': {
            'resource_members': true
        }
    });

    // Fire additional tasks to update the memberships of the members
    AuthzSearch.fireMembershipUpdateTasks(_.keys(memberChangeInfo.changes));
});

/*!
 * When a group is updated, we must reindex the user resource document
 */
PrincipalsAPI.on(PrincipalsConstants.events.UPDATED_GROUP, function(ctx, group) {
    SearchAPI.postIndexTask('group', [{'id': group.id}], {
        'resource': true
    });
});

/*!
 * When group members have been updated, we must both the group's members child document and all the
 * principals' child memberships documents
 */
PrincipalsAPI.on(PrincipalsConstants.events.UPDATED_GROUP_MEMBERS, function(ctx, group, oldGroup, memberChangeInfo, opts) {
    _handleUpdateGroupMembers(ctx, group, _.keys(memberChangeInfo.changes));
});

/*!
 * When someone joins a group, we must both the group's members child document and the user's child
 * memberships documents
 */
PrincipalsAPI.on(PrincipalsConstants.events.JOINED_GROUP, function(ctx, group, oldGroup, memberChangeInfo) {
    _handleUpdateGroupMembers(ctx, group, _.keys(memberChangeInfo.changes));
});

/*!
 * When someone leaves a group, we must both the group's members child document and the user's child
 * memberships documents
 */
PrincipalsAPI.on(PrincipalsConstants.events.LEFT_GROUP, function(ctx, group, memberChangeInfo) {
    _handleUpdateGroupMembers(ctx, group, _.keys(memberChangeInfo.changes));
});

/**
 * Submits the indexing operation required when a group's members have changed.
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {Group}      group           The group object whose membership changed
 * @param  {String[]}   principalIds    The ids of all the members whose status in the group changed
 * @api private
 */
var _handleUpdateGroupMembers = function(ctx, group, principalIds) {
    SearchAPI.postIndexTask('group', [{'id': group.id}], {
        'children': {
            'resource_members': true
        }
    });

    // Fire additional tasks to update the memberships of the members
    AuthzSearch.fireMembershipUpdateTasks(principalIds);
};


////////////////////////
// DOCUMENT PRODUCERS //
////////////////////////

/**
 * Produces search documents for 'user' resources.
 *
 * @see SearchAPI#registerSearchDocumentProducer
 * @api private
 */
var _produceUserSearchDocuments = function(resources, callback, _documents, _errs) {
    _documents = _documents || [];
    if (_.isEmpty(resources)) {
        return callback(_errs, _documents);
    }

    var resource = resources.pop();

    // No need to retrieve the user object if it was provided
    if (resource.user) {
        _documents.push(_produceUserSearchDocument(resource.user));
        return _produceUserSearchDocuments(resources, callback, _documents, _errs);
    }

    // We'll need to retrieve the user if the full object wasn't provided
    PrincipalsDAO.getPrincipal(resource.id, function(err, user) {
        if (err) {
            _errs = _.union(_errs, [err]);
            return _produceUserSearchDocuments(resources, callback, _documents, _errs);
        }

        _documents.push(_produceUserSearchDocument(user));
        return _produceUserSearchDocuments(resources, callback, _documents, _errs);
    });
};

/**
 * Given a user, create a search document based on its information.
 *
 * @param  {User}  user    The user document
 * @return {Object}        The search document that represents the user
 * @api private
 */
var _produceUserSearchDocument = function(user) {
    var searchDoc = {
        'resourceType': user.resourceType,
        'id': user.id,
        'tenantAlias': user.tenant.alias,
        'email': user.email,
        'deleted': user.deleted,
        'displayName': user.displayName,
        'visibility': user.visibility,
        'q_high': user.displayName,
        'sort': user.displayName,
        '_extra': {
            'publicAlias': user.publicAlias,
            'userExtra': user.extra
        }
    };

    if (user.picture.mediumUri) {
        searchDoc.thumbnailUrl = user.picture.mediumUri;
    }

    return searchDoc;
};

/**
 * Produces search documents for 'group' resources.
 *
 * @see SearchAPI#registerSearchDocumentProducer
 * @api private
 */
var _produceGroupSearchDocuments = function(resources, callback, _documents, _errs) {
    _documents = _documents || [];
    if (_.isEmpty(resources)) {
        return callback(_errs, _documents);
    }

    var resource = resources.pop();
    if (resource.group) {
        _documents.push(_produceGroupSearchDocument(resource.group));
        return _produceGroupSearchDocuments(resources, callback, _documents, _errs);
    }

    PrincipalsDAO.getPrincipal(resource.id, function(err, group) {
        if (err) {
            _errs = _.union(_errs, [err]);
            return _produceGroupSearchDocuments(resources, callback, _documents, _errs);
        }

        _documents.push(_produceGroupSearchDocument(group));
        return _produceGroupSearchDocuments(resources, callback, _documents, _errs);
    });
};

/**
 * Given a group, create a search document based on its information.
 *
 * @param  {Group}  group  The group document
 * @return {Object}        The search document that represents the group
 * @api private
 */
var _produceGroupSearchDocument = function(group) {
    // Full text searching is done on the name, alias and description. Though, the displayName is scored higher through `q_high`.
    var fullText = _.compact([group.displayName, group.alias, group.description]).join(' ');

    var searchDoc = {
        'resourceType': group.resourceType,
        'id': group.id,
        'tenantAlias': group.tenant.alias,
        'deleted': group.deleted,
        'displayName': group.displayName,
        'visibility': group.visibility,
        'joinable': group.joinable,
        'q_high': group.displayName,
        'q_low': fullText,
        'sort': group.displayName,
        '_extra': {
            'alias': group.alias
        }
    };

    if (group.picture.mediumUri) {
        searchDoc.thumbnailUrl = group.picture.mediumUri;
    }

    return searchDoc;
};

// Bind the document producers
SearchAPI.registerSearchDocumentProducer('user', _produceUserSearchDocuments);
SearchAPI.registerSearchDocumentProducer('group', _produceGroupSearchDocuments);


///////////////////////////
// DOCUMENT TRANSFORMERS //
///////////////////////////

/**
 * Given an array of user search documents, transform them into search documents suitable to be displayed to the user in context.
 *
 * @param  {Context}   ctx             Standard context object containing the current user and the current tenant
 * @param  {Object}    docs            A hash, keyed by the document id, while the value is the document to transform
 * @param  {Function}  callback        Standard callback function
 * @param  {Object}    callback.err    An error that occurred, if any
 * @param  {Object}    callback.docs   The transformed docs, in the same form as the `docs` parameter.
 * @api private
 */
var _transformUserDocuments = function(ctx, docs, callback) {
    var transformedDocs = {};
    _.each(docs, function(doc, docId) {
        var displayName = _.first(doc.fields.displayName);
        var email = _.first(doc.fields.email);
        var extra = _.first(doc.fields._extra) || {};
        var tenantAlias = _.first(doc.fields.tenantAlias);
        var thumbnailUrl = _.first(doc.fields.thumbnailUrl);
        var visibility = _.first(doc.fields.visibility);

        // First we need to convert the data in this document back into the source user object so that we may use PrincipalsUtil.hideUserData
        // to hide its information. We will then after convert the user *back* to a search document once the user information has been
        // scrubbed
        var user = new User(tenantAlias, docId, displayName, email, {
            'visibility': visibility,
            'publicAlias': extra.publicAlias,
            'mediumPictureUri': thumbnailUrl
        });
        user.extra = extra.userExtra;

        // Hide information that is sensitive to the current session
        PrincipalsUtil.hideUserData(ctx, user);

        // Convert the user object back to a search document using the producer. We use this simply to re-use the logic of turning a user
        // object into a search document
        var result = _produceUserSearchDocument(user);

        // Add the full tenant object and profile path
        _.extend(result, {
            'profilePath': user.profilePath,
            'tenant': user.tenant
        });

        // The UI search model expects the 'extra' parameter if it was not scrubbed
        if (user.extra) {
            result.extra = user.extra;
        }

        // If the mediumPictureUri wasn't scrubbed from the user object that means the current user can see it
        if (user.picture.mediumUri) {
            result.thumbnailUrl = ContentUtil.getSignedDownloadUrl(ctx, user.picture.mediumUri);
        }

        // We need to delete these fields which are added by the producer but aren't supposed to be included in the UI
        delete result.q_high;
        delete result.sort;

        transformedDocs[docId] = result;
    });

    return callback(null, transformedDocs);
};

// Bind the transformer to the search API
SearchAPI.registerSearchDocumentTransformer('user', _transformUserDocuments);


/**
 * Given an array of group search documents, transform them into search documents suitable to be displayed to the user in context.
 *
 * @param  {Context}   ctx             Standard context object containing the current user and the current tenant
 * @param  {Object}    docs            A hash, keyed by the document id, while the value is the document to transform
 * @param  {Function}  callback        Standard callback function
 * @param  {Object}    callback.err    An error that occurred, if any
 * @param  {Object}    callback.docs   The transformed docs, in the same form as the `docs` parameter.
 * @api private
 */
var _transformGroupDocuments = function(ctx, docs, callback) {
    var transformedDocs = {};
    _.each(docs, function(doc, docId) {
        // Extract the extra object from the search document
        var extra = _.first(doc.fields._extra);

        // Build the transformed result document from the ElasticSearch document
        var result = {'id': docId};
        _.each(doc.fields, function(value, name) {
            result[name] = _.first(value);
        });

        // Sign the thumbnail URL so it may be downloaded by the client
        if (result.thumbnailUrl) {
            result.thumbnailUrl = ContentUtil.getSignedDownloadUrl(ctx, result.thumbnailUrl);
        }

        // Add the tenant and public alias
        _.extend(result, _.pick(extra, 'alias'), {
            'tenant': TenantsAPI.getTenant(result.tenantAlias).compact()
        });

        // Add the profile path, only if the group is not deleted
        if (!result.deleted) {
            _.extend(result, {
                'profilePath': util.format('/group/%s/%s', result.tenantAlias, AuthzUtil.getResourceFromId(result.id).resourceId)
            });
        }

        transformedDocs[docId] = result;
    });

    return callback(null, transformedDocs);
};

// Bind the transformer to the search API
SearchAPI.registerSearchDocumentTransformer('group', _transformGroupDocuments);


/////////////////////////
// REINDEX ALL HANDLER //
/////////////////////////

/*!
 * Binds a reindexAll handler that reindexes all rows from the Principals CF (users and groups)
 */
SearchAPI.registerReindexAllHandler('principal', function(callback) {

    /*!
     * Handles each iteration of the PrincipalsDAO iterate all method, firing tasks for all principals to
     * be reindexed.
     *
     * @see PrincipalsDAO#iterateAll
     */
    var _onEach = function(principalRows, done) {
        // Aggregate group and user reindexing task resources
        var groupResources = [];
        var userResources = [];
        _.each(principalRows, function(principal) {
            var principalId = principal.principalId;
            if (principalId) {
                if (AuthzUtil.isGroupId(principalId)) {
                    groupResources.push({'id': principalId});
                } else if (AuthzUtil.isUserId(principalId)) {
                    userResources.push({'id': principalId});
                }
            }
        });

        log().info('Firing re-indexing task for %s users and %s groups', userResources.length, groupResources.length);

        if (!_.isEmpty(userResources)) {
            SearchAPI.postIndexTask('user', userResources, {'resource': true, 'children': true});
        }

        if (!_.isEmpty(groupResources)) {
            SearchAPI.postIndexTask('group', groupResources, {'resource': true, 'children': true});
        }

        return done();
    };

    return PrincipalsDAO.iterateAll(null, 100, _onEach, callback);
});


/////////////////////
// DELETE HANDLERS //
/////////////////////

/**
 * Handler to invoke the search tasks required to invalidate search documents necessary
 *
 * @param  {Group}          group               The group that needs to be invalidated
 * @param  {AuthzGraph}     membershipsGraph    The graph of group memberships of the group
 * @param  {AuthzGraph}     membersGraph        The graph of group members of the group
 * @param  {Function}       callback            Standard callback function
 * @param  {Object[]}       callback.errs       All errs that occurred while trying to fire the search update tasks, if any
 * @api private
 */
var _handleInvalidateSearch = function(group, membershipsGraph, membersGraph, callback) {
    // All members (direct and indirect, users and groups) of the group that was deleted need to
    // have their memberships child search documents invalidated
    var groupAndUserIds = _.chain(membersGraph.getNodes())
        .pluck('id')
        .filter(AuthzUtil.isPrincipalId)
        .without(group.id)
        .partition(AuthzUtil.isGroupId)
        .value();
    var memberGroupIds = groupAndUserIds[0];
    var memberUserIds = groupAndUserIds[1];

    // Create the index task that will tell search to update the deleted group's resource document
    var resourceGroupIndexTask = [{'id': group.id}];

    // Create the index tasks that will tell search which resource's memberships document to update
    var memberGroupIndexTasks = _.map(memberGroupIds, function(groupId) {
        return {'id': groupId};
    });

    var memberUserIndexTasks = _.map(memberUserIds, function(userId) {
        return {'id': userId};
    });

    // The index operation that tells search to update only the resource document of the target
    // resources. This is needed for the group being deleted only
    var resourceIndexOp = {'resource': true};

    // The index operation that tells search to only update the memberships child document of the
    // target resources
    var membershipsIndexOp = {
        'children': {
            'resource_memberships': true
        }
    };

    var allErrs = null;

    // Update the resource document of the group that was deleted so its `deleted` flag may be
    // set/unset for the updated delete date
    SearchAPI.postIndexTask('group', resourceGroupIndexTask, resourceIndexOp, function(err) {
        if (err) {
            allErrs = _.union(allErrs, [err]);
        }

        // If there are group index tasks to invoke, do it
        OaeUtil.invokeIfNecessary(!_.isEmpty(memberGroupIndexTasks), SearchAPI.postIndexTask, 'group', memberGroupIndexTasks, membershipsIndexOp, function(err) {
            if (err) {
                allErrs = _.union(allErrs, [err]);
            }

            // If there are user index tasks to invoke, do it
            OaeUtil.invokeIfNecessary(!_.isEmpty(memberUserIndexTasks), SearchAPI.postIndexTask, 'user', memberUserIndexTasks, membershipsIndexOp, function(err) {
                if (err) {
                    allErrs = _.union(allErrs, [err]);
                }

                return callback(allErrs);
            });
        });
    });
};

/*!
 * When a group is deleted or restored, invalidate the memberships search documents of all members
 * affected by the change
 */
PrincipalsDelete.registerGroupDeleteHandler('search', _handleInvalidateSearch);
PrincipalsDelete.registerGroupRestoreHandler('search', _handleInvalidateSearch);
