// Module dependencies
var _ = require('underscore');
var http = require('http');
var querystring = require('querystring');
var log = require('oae-logger').logger('oae-loodle-api');
var async = require('async');

var FoldersDAO = require('../../oae-folders/lib/internal/dao');
var LoodleDAO = require('./internal/dao').loodles;
var UserDAO = require('./internal/dao').users;
var ContentDAO = require('../../oae-content/lib/internal/dao');

var ContentConstants = require('../../oae-content/lib/constants').ContentConstants;
var PrincipalsConstants = require('../../oae-principals/lib/constants').PrincipalsConstants;
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var FoldersConstants = require('oae-folders/lib/constants').FoldersConstants;

var FoldersAPI = require('oae-folders');
var ContentAPI = require('oae-content');
var userAPI = require('../../oae-principals/lib/api.user');
var groupAPI = require('../../oae-principals/lib/api.group');
var EmitterAPI = require('oae-emitter');
var GroupAPI = require('../../oae-principals/lib/api.group');
var PrincipalsUtil = require('../../oae-principals/lib/util');
var LibraryAPI = require('oae-library');
var AuthzAPI = require('oae-authz');
var ContentMembersLibrary = require('../../oae-content/lib/internal/membersLibrary');
var PrincipalsMembersLibrary = require('../../oae-principals/lib/libraries/members');
var LoodleAPI = new EmitterAPI.EventEmitter();

var PrincipalsEmitter = require('../../oae-principals/lib/internal/emitter');

var util = require('../../oae-authz/lib/util');
var ContentUtil = require('../../oae-content/lib/internal/util');

// EVENT FUNCTIONS

/**
 * Catch when folder members have been updated and create a mirror account for the folder members who need to if the
 * folder contains loodle items
 * @param ctx
 * @param folder
 * @param memberChangeInfo
 * @param something
 * callback
 */
FoldersAPI.when(FoldersConstants.events.UPDATED_FOLDER_MEMBERS, function (ctx, folder, memberChangeInfo, something, callback) {

    // Check if the folder library has some loodles, otherwise we have nothing to do
    getFolderLoodles(ctx, folder, function (err, contents) {
        if (err) return callback(err);
        if (!contents.length) return callback();

        createAccountForFolderMembers(ctx, folder.id, callback);
    });

});

/**
 * Catch when content items have been added to a folder and create a mirror account for the folder members who need to
 * if some of the added content items were loodles
 * @param ctx
 * @param actionContext
 * @param folder
 * @param contentItems
 * @param callback
 */
FoldersAPI.when(FoldersConstants.events.ADDED_CONTENT_ITEMS, function (ctx, actionContext, folder, contentItems, callback) {

    var loodleItems = _.find(contentItems, function (item) {
        return item.resourceSubType === 'loodle';
    });

    if (!hasLoodleItems(contentItems)) {
        return callback();
    }

    createAccountForFolderMembers(ctx, folder.id, function (err) {
        return callback(err);
    });

});

/**
 * Catch when a content is retrieved and get the loodle data associated if the content was a loodle
 * @param ctx
 * @param contentObj
 * @param callback
 */
ContentAPI.when(ContentConstants.events.GET_CONTENT, function (ctx, contentObj, callback) {

    if (!(contentObj.resourceSubType === 'loodle'))
        return callback(null, contentObj);

    getLoodle(ctx, contentObj, function (err, contentObj) {
        if (err) return callback(err);

        return callback(null, contentObj);
    });

});

/**
 * Catch when a content is created and create a mirror loodle if the content sub-type was loodle
 * @param ctx
 * @param content
 * @param revision
 * @param memberChangeInfo
 * @param folders
 * @param callback
 */
ContentAPI.when(ContentConstants.events.CREATED_CONTENT, function (ctx, content, revision, memberChangeInfo, folders, callback) {

    if (!(content.resourceSubType === 'loodle'))
        return callback(null, content);

    create(ctx, ctx.user(), content.id, content.displayName, content.description, content.visibility, memberChangeInfo.changes, folders, function (err) {
        if (err) return callback(err);

        return callback(null, content);
    });

});

/**
 * Catch when a content is deleted and delete the mirror loodle if the content sub-type was loodle
 * @param ctx
 * @param contentObj
 * @param members
 * @param callback
 */
ContentAPI.when(ContentConstants.events.DELETED_CONTENT, function (ctx, contentObj, members, callback) {

    if (!(contentObj.resourceSubType === 'loodle'))
        return callback(null, contentObj);

    deleteLoodle(ctx, ctx.user(), contentObj.id, callback);

});

/**
 * Catch when content members have been updated and update them in the mirror loodle if the content sub-type was loodle
 * @param ctx
 * @param content
 * @param memberChangeInfo
 * @param something
 * @param callback
 */
ContentAPI.when(ContentConstants.events.UPDATED_CONTENT_MEMBERS, function (ctx, content, memberChangeInfo, something, callback) {

    if (!(content.resourceSubType === 'loodle'))
        return callback(null, content);

    updateMembers(ctx, content.id, memberChangeInfo.changes, callback);

});

/**
 * Catch when a content visibility has been updated and update the mirror loodle visibilty if the content sub-type was loodle
 * @param ctx
 * @param newContentObj
 * @param oldContentObj
 * @param callback
 */
ContentAPI.when(ContentConstants.events.UPDATED_CONTENT, function (ctx, newContentObj, oldContentObj, callback) {

    if (!(content.resourceSubType === 'loodle'))
        return callback(null, content);

    updateVisibility(ctx, contentId, newContentObj.visibility, callback);

});

/**
 * Catch when group members have been updated and update the group loodles participants if the group contains some loodle items
 * @param ctx
 * @param group
 * @param oldGroup
 * @param memberChangeInfo
 * @param opts
 * @param callback
 */
PrincipalsEmitter.when(PrincipalsConstants.events.UPDATED_GROUP_MEMBERS, function (ctx, group, oldGroup, memberChangeInfo, opts, callback) {

    // Check if the group library has some loodles, otherwise we have nothing to do
    getGroupLoodles(ctx, group, function (err, contents) {
        if (err) return callback(err);
        if (!contents.length) return callback();

        setGroupMembers(ctx, contents, memberChangeInfo, callback);
    });

});

// API FUNCTIONS

/**
 *
 * Create a loodle in the loodle application
 *
 * @param  {Context}  ctx       		 Standard context object containing the current user and the current tenant
 * @param  {String}   contentId          Id matching the loodle id which will be created
 * @param  {String}   name               Name of the loodle
 * @param  {String}   description        Description of the loodle
 * @param  {Object}   additionalMembers  Members to add to the loodle additionnaly to the current user
 * @param  {Function} callback           Standard callback function
 */
var create = exports.create = function (ctx, currentUser, contentId, name, description, visibility, additionalMembers, folders, callback) {

    var cloneAdditionalMembers = {};
    var loodleId,
        token;

    async.series([
        // Even if members of a folder only have a read only access if the loodle is created inside
        // a folder, we still neeed to create a mirror account for them (if they don't already have
        // one), otheriwe they will not be able to access the loodle data
        function createMirrorAccountForFoldersMembers (end) {
            async.each(folders, function (folderId, finish) {
                createAccountForFolderMembers(ctx, folderId, finish);
            }, end);
        },
        function cloningAdditionalMembers (end) {
            async.forEachOf(additionalMembers, function (value, key, finish) {
                cloneAdditionalMembers[key] = value;
                return finish();
            }, end);
        },
        // Create the current user mirror account in the loodle application if needed
        function createCurrentUserMirrorAccountIfNeeded (end) {
            UserDAO.createUserIfNeeded(ctx, currentUser.id, end);
        },
        // Get the current user token to communicate with the loodle application
        function getCurrentUserToken (end) {
            UserDAO.getToken(currentUser.id, function (err, data) {
                token = data;
                return end(err, data);
            });
        },
        // Call to the loodle api to create the loodle
        function createLoodle (end) {
            LoodleDAO.createLoodle(ctx, token, name, description, visibility, function (err, data) {
                if (err) return end(err);

                // Delete the current user from the additional members as he/she is already associated
                // with the new loodle created
                delete cloneAdditionalMembers[currentUser.id]

                loodleId = data;
                return end();
            });
        },
        // Save in db the matching contentId - loodleId
        function saveMatch (end) {
            LoodleDAO.saveMatch(contentId, loodleId, end);
        },
        function getGroupUsers (end) {
            async.forEachOf(cloneAdditionalMembers, function (role, id, finish) {
                if(!util.isGroupId(id)) {
                    return finish();
                }

                getGroupUserIds(ctx, id, function (err, groupMemberIds) {
                    if (err) return finish(err)

                    groupMemberIds.forEach(function (groupMemberId) {
                        if (!(groupMemberId in cloneAdditionalMembers) && groupMemberId != currentUser.id) {
                            cloneAdditionalMembers[groupMemberId] = 'manager';
                        }
                    });

                    delete cloneAdditionalMembers[id];

                    return finish();
                });
            }, end);
        },
        function addMembers (end) {
            addUsers(ctx, cloneAdditionalMembers, token, loodleId, end);
        }
    ], callback);

};

/**
 * Update a loodle visibility
 * @param ctx
 * @param contentId
 * @param callback
 */
var updateVisibility = exports.updateVisibility = function (ctx, contentId, visibility, callback) {

    var currentUserToken,
        loodleId;

    async.series({
        getToken: function (done) {
            UserDAO.getToken(ctx.user().id, function (err, token) {
                if (err) return done(err);

                currentUserToken = token;
                return done();
            })
        },
        getLoodleId: function (done) {
            LoodleDAO.getLoodleId(contentId, function (err, data) {
                if (err) return done(err);

                loodleId = data;
                return done();
            });
        },
        update: function (done) {
            LoodleDAO.updateVisibility(ctx, currentUserToken, loodleId, visibility.visibility, done);
        }
    }, callback);

}

/**
 * Check if an user participates to a specified loodle
 * @param userId
 * @param loodleId
 * @param callback
 */
var userIsInLoodle = exports.userIsInLoodle = function (ctx, userId, loodleId, callback) {

    UserDAO.hasLoodleAccount(userId, function (err, hasLoodleAccount) {
        if (err) return callback(err);

        // The user does not have a mirror acount in the loodle application
        if (!hasLoodleAccount) return callback(null, false);

        async.waterfall([
            // Get user token
            function getUserToken (done) {
                UserDAO.getToken(userId, done);
            },

            // Check if the user is already in the loodle
            function checkIfInLoodle (token, done) {
                UserDAO.isInLoodle(ctx, userId, loodleId, token, done);
            }
        ], callback);
    });

};

/**
 * Get a user mirror account from an user id in OAE
 * @param ctx
 * @param userId
 * @param callback
 */
var getUser = exports.getUser = function (ctx, userId, callback) {

    async.waterfall([
        // Get user token
        function getUserToken (done) {
            UserDAO.getToken(userId, done);
        },
        // Get user informations from its mirror account in the loodle application
        function getUserInfo (token, done) {
            UserDAO.get(ctx, token, done);
        }
    ], callback);

};

/**
 * Add an user to a loodle if he/she is not participant yet
 * @param ctx
 * @param userId
 * @param callback
 */
var addUserIfNeeded = exports.addUserIfNeeded = function (ctx, contentId, userId, callback) {

    async.parallel({
        loodleId: function (done) {
            LoodleDAO.getLoodleId(contentId, done);
        },
        token: function (done) {
            UserDAO.getToken(userId, done);
        }
    }, function (err, data) {
        if (err) return callback(err);

        LoodleDAO.addUserIfNeeded(ctx, data.loodleId, userId, data.token, callback);
    });

};

/**
 * Get or create a mirror account for an user
 * @param ctx
 * @param userId
 * @param callback
 */
var getOrCreateUser = exports.getOrCreateUser = function (ctx, userId, callback) {

    UserDAO.hasLoodleAccount(userId, function (err, hasLoodleAccount) {
        if (err) return callback(err);

        if (hasLoodleAccount) {
            getUser(ctx, userId, callback);
        }
        else {
            userAPI.getUser(ctx, userId, function (err, user) {
                if (err) return callback(err);

                UserDAO.createLoodleAccount(ctx, user, function (err) {
                    if (err) return callback(err);

                    getUser(ctx, userId, function (err, data) {
                        if (err) return callback(err);
                        return callback(null, data);
                    });
                });
            });
        }
    });

};

/**
 * Get private loodle data from a content id
 * @param ctx
 * @param currentUser
 * @param contentId
 * @param callback
 */
var getFromContentId = exports.getFromContentId = function (ctx, currentUser, contentId, callback) {

    UserDAO.getToken(currentUser.id, function (err, token) {
        if (err) return callback(err);

        async.waterfall([
            // Get loodleId from ContentId
            function (end) {
                LoodleDAO.getLoodleId(contentId, end);
            },
            // Get loodle data using the loodleId
            function (loodleId, end) {
                LoodleDAO.getLoodleData(ctx, token, loodleId, end);
            }
        ], callback);

    });

};

/**
 * Get public loodle data from a content id
 * @param ctx
 * @param contentId
 * @param callback
 */
var getPublicLoodleFromContentId = exports.getPublicLoodleFromContentId = function (ctx, contentId, callback) {

    async.waterfall([
        // Get loodleId from ContentId
        function (end) {
            LoodleDAO.getLoodleId(contentId, end);
        },
        // Get loodle data using the loodleId
        function (loodleId, end) {
            LoodleDAO.getPublicLoodleData(ctx, loodleId, end);
        }
    ], callback);

};

/**
 * Delete a loodle in the loodle application
 * @param  {Object}   currentUser 	Object representing the current user
 * @param  {String}   contentId   	Content identifier
 * @param  {Function} callback    	Standard callback function
 */
var deleteLoodle = exports.deleteLoodle = function (ctx, currentUser, contentId, callback) {

    async.parallel({
        token: 		async.apply(UserDAO.getToken, currentUser.id),
        loodleId: 	async.apply(LoodleDAO.getLoodleId, contentId),
    }, function (err, results) {
        if (err) { return callback(err); }
        LoodleDAO.deleteLoodle(ctx, results.token, results.loodleId, callback);
    });
};

/**
 * Update members in a loodle
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {String}   	contentId 		Content identifier
 * @param  {Object}   	changes   		Object with the user id as key and the role as value
 * @param  {Function} 	callback  		Standard callback function
 */
var updateMembers = exports.updateMembers = function (ctx, loodleId, changes, callback) {

    // No changes
    if (Object.keys(changes).length === 0)
        return callback();

    var currentUser = ctx.user();
    var currentUserToken;

    // parallel
    async.parallel({
        getToken: function (done) {
            UserDAO.getToken(currentUser.id, function (err, token) {
                if (err) return done(err);

                currentUserToken = token;
                return done();
            });

        },
        obtentionGroupsMembers: function (done) {
            var groups = {};

            // We get the group ids and the roles associated
            for(var id in changes) {
                if (util.isGroupId(id)) {
                    groups[id] = changes[id];
                }
            }

            // Purge the changes of the group ids
            for (var id in groups) {
                delete changes[id];
            }

            getGroupsUserIdsWithRoles(ctx, groups, function (err, groupsUsers) {
                if (err) return done(err);

                // Add the groups users to the additional users of the loodle
                for (var id in groupsUsers) {
                    // If a groups user has also been explicitely invited
                    // we keep the "higher" role for him/her
                    if (id in changes) {
                        if (groupsUsers[id] === 'manager' || changes[id] === 'manager') {
                            changes[id] = 'manager';
                        }
                        else {
                            changes[id] = 'viewer';
                        }
                    }
                    else {
                        // We do not include the current user in the groups update
                        if (!(id === currentUser.id)) {
                            changes[id] = groupsUsers[id];
                        }
                    }
                }

                return done();
            });

        }
    }, function (err) {
        if (err) return callback(err);

        async.forEachOf(changes, function (role, userId, done) {
            updateMember(ctx, loodleId, userId, role, currentUserToken, done);
        }, callback);

    });

};

/**
 * Add a schedule to the specified loodle
 * @param 	{Context}   ctx       		Standard context object containing the current user and the current tenant
 * @param 	{String}   	contentId 		Content identifier
 * @param 	{Object}   	schedule  		Schedule object
 * @param 	{Function} 	callback  		Standard callback function
 */
var addSchedule = exports.addSchedule = function (ctx, loodleId, schedule, callback) {

    var currentUser = ctx.user();

    async.waterfall([
        async.apply(UserDAO.getToken, currentUser.id),
        async.apply(LoodleDAO.addSchedule, ctx, loodleId, schedule, currentUser.locale)
    ], callback);

};

/**
 * Remove a schedule from a loodle
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {String}   	loodleId   		Loodle identifier
 * @param  {String}   	scheduleId 		Schedule identifier
 * @param  {Function} 	callback   		Standard callback function
 */
var deleteSchedule = exports.deleteSchedule = function (ctx, loodleId, scheduleId, callback) {

    var currentUser = ctx.user();

    async.waterfall([
        async.apply(UserDAO.getToken, currentUser.id),
        async.apply(LoodleDAO.deleteSchedule, ctx, loodleId, scheduleId)
    ], callback);

};

/**
 * Update the votes of a user in a loodle
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {Object}   	votes    		Vote object : vote id as key, vote as value
 * @param  {Function} callback 			Standard callback function
 */
var updateVotes = exports.updateVotes = function (ctx, votes, loodleId, callback) {

    var currentUser = ctx.user();

    // Public user updating his/her votes
    if (!currentUser) {
        LoodleDAO.updatePublicVotes(ctx, loodleId, votes, callback);
    }
    else {
        UserDAO.getToken(currentUser.id, function (err, token) {
            LoodleDAO.updateVotes(ctx, token, loodleId, votes, callback);
        });
    }

};

/**
 * Emit a notification indicating that the loodle's schedules has been updated
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {String}   	contentId 		Content identifier
 * @param  {Function} 	callback  		Standard callback function
 */
var emitUpdateScheduleNotification = exports.emitUpdateScheduleNotification = function (ctx, contentId, callback) {

    ContentDAO.Content.getContent(contentId, function(err, contentObj) {
        if (err)
            return callback(err);

        ContentAPI.emit(ContentConstants.events.EDITED_LOODLE_SCHEDULES, ctx, contentObj);
        return callback();
    });

};

/**
 * Emit a notification saying that the loodle's votes has been updated
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {String}   	contentId 		Content identifier
 * @param  {Function} 	callback  		Standard callback function
 */
var emitUpdateVoteNotification = exports.emitUpdateVoteNotification = function (ctx, contentId, callback) {

    ContentDAO.Content.getContent(contentId, function(err, contentObj) {
        if (err) return callback(err);

        ContentAPI.emit(ContentConstants.events.EDITED_LOODLE_VOTES, ctx, contentObj);
        return callback();
    });

};

/**
 * Get loodle data
 * @param ctx
 * @param loodleId
 * @param callbacl
 */
var getData = exports.getData = function (ctx, loodleId, callback) {

    var currentUser = ctx.user()

    if (currentUser) {
        async.waterfall([
            async.apply(UserDAO.getToken, currentUser.id),
            async.apply(LoodleDAO.get, ctx, loodleId)
        ], callback);
    }
    else {
        LoodleDAO.getPublicLoodleData(ctx, loodleId, callback);
    }

};

/**
 * Add a new user to a loodle with a set of disponibilities
 * @param ctx
 * @param loodleId
 * @param firstName
 * @param lastName
 * @param votes
 * @param callback
 */
var addMemberWithVotes = exports.addMemberWithVotes = function (ctx, loodleId, firstName, lastName, votes, callback) {

    votes = JSON.parse(votes);
    LoodleDAO.addMemberWithVotes(ctx, loodleId, firstName, lastName, votes, callback);

};

// PRIVATE FUNCTIONS

/**
 * Get folder loodles
 * @param ctx
 * @param folder
 * @param callback
 */
var getFolderLoodles = function (ctx, folder, callback) {

    FoldersAPI.getFolderContentLibrary(ctx, folder.id, 0, 1000, function (err, contentObjects) {
        if (err) return callback(err);

        // Filter only the loodle contents
        contentObjects = _.filter(contentObjects, function (content) {
            return content.resourceSubType === 'loodle';
        });

        return callback(null, contentObjects);
    });

};

/**
 * Check if the content items array contains some loodles
 * @param contentItems
 * @returns {boolean}
 */
var hasLoodleItems = function (contentItems) {

    var loodleItems = _.find(contentItems, function (item) {
        return item.resourceSubType === 'loodle';
    });

    if (loodleItems === undefined)
        return false;
    else
        return true;

};

/**
 * Get the loodle data from the content data
 * @param ctx
 * @param content
 * @param callback
 */
var getLoodle = function (ctx, content, callback) {

    var currentUser = ctx.user();

    if (content.visibility === 'private') {
        getPrivateLoodle(ctx, currentUser, content, callback);
    }
    else if (content.visibility === 'loggedin' || content.visibility === 'public') {
        getPublicLoodle(ctx, currentUser, content, callback);
    }
    else {
        return callback({ code: '500', msg: 'invalid visibility '});
    }

};

/**
 * Get the public loodle data from a loodle content in OAE
 * @param ctx
 * @param currentUser
 * @param content
 * @param callback
 */
var getPublicLoodle = function (ctx, currentUser, content, callback) {

    // An user is connected
    if (currentUser) {
        getPublicLoodleFromContentId(ctx, content.id, function (err, loodle) {
            if (err) return callback(err);

            content.loodleData = loodle;

            // Check if the user is a participant in the loodle or access it in read only mode
            userIsInLoodle(ctx, currentUser.id, loodle.id, function (err, isInLoodle) {
                if (err) return callback(err);
                if (!isInLoodle) return callback(null, content);

                getUser(ctx, currentUser.id, function (err, user) {
                    if (err) return callback(err);

                    content.loodleData.currentUser = user;
                    return callback(null, content);
                });
            });
        });
    }
    // An anonymous user is accessing the loodle, just send back the loodle data
    else {
        getPublicLoodleFromContentId(ctx, content.id, function (err, loodle) {
            if (err) return callback(err);

            content.loodleData = loodle;
            return callback(null, content);
        });
    }

};

/**
 * Get the private loodle data from a loodle content in OAE
 * @param ctx
 * @param currentUser
 * @param content
 * @param callback
 */
var getPrivateLoodle = function (ctx, currentUser, content, callback) {

    getFromContentId(ctx, currentUser, content.id, function (err, loodle) {
        if (err) return callback(err);

        content.loodleData = loodle;

        // Check if the user is a participant in the loodle or access it in read only mode
        userIsInLoodle(ctx, currentUser.id, loodle.id, function (err, isInLoodle) {
            if (err) return callback(err);

            if (!isInLoodle) return callback(null, content);

            getUser(ctx, currentUser.id, function (err, user) {
                if (err) return callback(err);

                content.loodleData.currentUser = user;
                return callback(null, content);
            });
        });
    });

};

/**
 * Get all the loodles inside of a group library
 * @param ctx
 * @param group
 * @param callback
 */
var getGroupLoodles = function (ctx, group, callback) {

    // Determine which library visibility we need to fetch
    LibraryAPI.Authz.resolveTargetLibraryAccess(ctx, group.id, group, function(err, hasAccess, visibility) {
        if (err) return callback(err);
        if (!hasAccess) return callback({'code': 401, 'msg': 'You do not have access to this library'});

        ContentDAO.Content.getContentLibraryItems(group.id, visibility, 0, null, function(err, contentObjects) {
            if (err) return callback(err);

            // Filter only the loodle contents
            contentObjects = _.filter(contentObjects, function (content) {
                return content.resourceSubType === 'loodle';
            });

            return callback(null, contentObjects);
        });
    });

};

/**
 * Apply the updates about the group members to the loodles
 * @param contents
 * @param memberChangeInfo
 * @param callback
 */
var setGroupMembers = function (ctx, contents, memberChangeInfo, callback) {

    // Get the token of the current user
    UserDAO.getToken(ctx.user().id, function (err, token) {
        if (err) return callback(err);

        async.parallel({
            added: function (done) {
                if (memberChangeInfo.members.added.length === 0) return done();

                addMembersToLoodles(ctx, contents, memberChangeInfo, token, done);
            },
            removed: function (done) {
                if (memberChangeInfo.members.removed.length === 0) return done();

                removeMembersFromLoodles(ctx, contents, memberChangeInfo, token, done);
            }
        }, callback);
    });

};

/**
 * Add members to loodles
 * @param contents
 * @param memberChangeInfo
 * @param token
 * @param callback
 */
var addMembersToLoodles = function (ctx, contents, memberChangeInfo, token, callback) {

    // For each member added
    async.each(memberChangeInfo.members.added, function (addedMember, done) {
        addMemberToLoodles(ctx, contents, addedMember, token, done);
    }, callback);

};

/**
 * Add a member to loodles
 * @param ctx
 * @param contents
 * @param addedMember
 * @param token
 * @param callback
 */
var addMemberToLoodles = function (ctx, contents, addedMember, token, callback) {

    if (util.isUserId(addedMember.id)) {
        addUserToLoodles(ctx, contents, addedMember.id, token, callback);
    }
    else if (util.isGroupId(addedMember.id)) {
        addGroupToLoodles(ctx, contents, addedMember.id, token, callback);
    }
    else {
        return callback({code: 500, msg: 'Invalid member id'});
    }

};

/**
 * Add user to loodles
 * @param ctx
 * @param contents
 * @param userId
 * @param token
 * @param callback
 */
var addUserToLoodles = function (ctx, contents, userId, token, callback) {

    // For each loodle content
    async.each(contents, function (content, done) {
        addUserToLoodle(ctx, content, userId, token, done);
    }, callback);

};

/**
 * Add an user to a loodle
 * @param ctx
 * @param content
 * @param userId
 * @param token
 * @param callback
 */
var addUserToLoodle = function (ctx, content, userId, token, callback) {

    UserDAO.createUserIfNeeded(ctx, userId, function (err) {
        if (err) return callback(err);

        async.waterfall([
            async.apply(LoodleDAO.getLoodleId, content.id),
            function (loodleId, done) {
                LoodleDAO.addUserIfNeeded(ctx, loodleId, userId, token, done);
            }
        ], callback);
    });

};

/**
 * Add groups users to loodles
 * @param ctx
 * @param contents
 * @param groupId
 * @param token
 * @param callback
 */
var addGroupToLoodles = function (ctx, contents, groupId, token, callback) {

    async.each(contents, function (content, done) {
        addGroupToLoodle(ctx, content, groupId, token, done);
    }, callback);

};

/**
 * Add group users to a loodle
 * @param ctx
 * @param content
 * @param groupId
 * @param token
 * @param callback
 */
var addGroupToLoodle = function (ctx, content, groupId, token, callback) {

    getGroupUserIds(ctx, groupId, function (err, userIds) {
        if (err) return callback(err);

        async.each(userIds, function (userId, done) {
            addUserToLoodle(ctx, content, userId, token, done);
        }, callback);
    });

};

/**
 * Get the ids of all the users of the group (including sub groups)
 * @param ctx
 * @param groupId
 * @param callback
 */
var getGroupUserIds = function (ctx, groupId, callback) {

    _getGroupUserIds(ctx, groupId, [], callback);

};

/**
 * Recursive function that get the ids of all the group users (including sub groups)
 * @param ctx
 * @param groupId
 * @param processedGroupIds
 * @param callback
 * @private
 */
var _getGroupUserIds = function (ctx, groupId, processedGroupIds, callback) {

    var userIds = [];

    if (_.contains(processedGroupIds, groupId)) return callback(null, userIds);

    // Add the current group id to the processed group so that we don't process it again
    // in a case like the following one :
    // Group A ; members : Branden, Group B
    // Group B ; members : Ian, Group A
    processedGroupIds.push(groupId);

    // Get the members of the group
    PrincipalsMembersLibrary.list({id: groupId}, AuthzConstants.visibility.PRIVATE, {'start': 0, 'limit': 1000}, function(err, groupMembers) {
    // groupAPI.getMembersLibrary(ctx, groupId, 0, 1000, function (err, groupMembers) {
        if (err) return callback(err);

        async.each(groupMembers, function (member, done) {
            // If user id, add to the list of the users
            if  (util.isUserId(member.id)) {
                userIds.push(member.id);
                return done();
            }
            // If group id, call the same function with the group id compute the union of the result with the actul list of users
            else if (util.isGroupId(member.id)) {
                _getGroupUserIds(ctx, member.id, processedGroupIds, function (err, subGroupUserIds) {
                    if (err) return done(err);

                    userIds = _.union(userIds, subGroupUserIds);
                    return done();
                });
            }
            else {
                return done({code: 500, msg: 'Invalid member id'});
            }
        }, function (err) {
            if (err) return callback(err);
            return callback(null, userIds);
        });
    });

};

/**
 * Create a loodle account for every user in the userIds array if they need to
 * @param ctx
 * @param userIds
 * @param callback
 */
var createLoodleAccountsIfNeeded = function (ctx, userIds, callback) {

    async.each(userIds, function (userId, done) {
        UserDAO.createUserIfNeeded(ctx, userId, done);
    }, callback);

};

/**
 * Create a mapped object with the user ids
 * Return a object with the loodle user ids as key and the OAE user ids as value
 * @param ctx
 * @param userIds
 * @param callback
 */
var mapOAEUserIdsWithLoodleUserIds = function (ctx, userIds, callback) {

    var mappedUserIds = {};

    async.each(userIds, function (userId, done) {
        async.waterfall([
            async.apply(UserDAO.getToken, userId),
            async.apply(UserDAO.get, ctx)
        ], function (err, user) {
            if (err) done(err);

            mappedUserIds[user.id] = userId;
            return done();
        });
    }, function (err) {
        if (err) return callback(err);
        return callback(null, mappedUserIds);
    });

};

/**
 * Get the ids of the loodle users (registred in the Loodle application)
 * @param ctx
 * @param loodleId
 * @param callback
 */
var getUserIdsFromLoodle = function (ctx, token, loodleId, callback) {

    async.waterfall([
        async.apply(LoodleDAO.get, ctx, loodleId, token),
        function (loodle, done) { return done(null, _.pluck(loodle.users, 'id')); }
    ], callback);

};

/**
 * Remove members from loodles
 * @param loodles
 * @param users
 * @param callback
 */
var removeMembersFromLoodles = function (ctx, contents, memberChangeInfo, token, callback) {

    // For each member removed
    async.each(memberChangeInfo.members.removed, function (removedMember, done) {

        if (util.isUserId(removedMember.id)) {
            removeUserFromLoodles(ctx, contents, removedMember.id, token, callback);
        }
        else if (util.isGroupId(removedMember.id)) {
            removeGroupFromLoodles(ctx, contents, removedMember.id, token, callback);
        }
        else {
            return callback({code: 500, msg: 'Invalid member id'});
        }

    }, callback);

};

/**
 * Remove an user from loodles
 * @param ctx
 * @param contents
 * @param userId
 * @param token
 * @param callback
 */
var removeUserFromLoodles = function (ctx, contents, userId, token, callback) {

    async.each(contents, function (content, done) {
        removeUserFromLoodle(ctx, content, userId, token, done);
    }, callback);

};

/**
 * Remove an user from a loodle
 * @param ctx
 * @param content
 * @param userId
 * @param token
 * @param callback
 */
var removeUserFromLoodle = function (ctx, content, userId, token, callback) {

    ContentAPI.getContentMembersLibrary(ctx, content.id, 0, 1000, function (err, members) {
        if (err) return callback(err);

        var memberIds = _.pluck(_.pluck(members, 'profile'), 'id');

        // Get user ids of the group members of the loodle
        async.each(memberIds, function (memberId, done) {
            if (!util.isGroupId(memberId)) {
                return done();
            }

            getGroupUserIds(ctx, memberId, function (err, groupMemberIds) {
                if (err) return done(err);

                memberIds = _.union(memberIds, groupMemberIds);
                return done();
            });
        }, function (err) {
            if (err) return callback(err);

            // We don't suppress as participant someone who has another access to the loodle
            if (_.contains(memberIds, userId)) return callback();

            LoodleDAO.getLoodleId(content.id, function (err, loodleId) {
                if (err) return callback(err);

                // The user does not have any access to the loodle anymore, we remove him/her as participant
                LoodleDAO.removeUser(ctx, loodleId, userId, token, callback);
            });
        });

    });

};

/**
 * Remove group users from loodles
 * @param ctx
 * @param contents
 * @param groupId
 * @param token
 * @param callback
 */
var removeGroupFromLoodles = function (ctx, contents, groupId, token, callback) {

    async.each(contents, function (content, done) {
        removeGroupFromLoodle(ctx, content, groupId, token, done);
    }, callback);

};

/**
 * Remove group users from a loodle
 * @param ctx
 * @param content
 * @param groupId
 * @param token
 * @param callback
 */
var removeGroupFromLoodle = function (ctx, content, groupId, token, callback) {

    ContentAPI.getContentMembersLibrary(ctx, content.id, 0, 1000, function (err, members) {
        if (err) return callback(err);

        var memberIds = _.pluck(_.pluck(members, 'profile'), 'id');

        // If the entire group does have another access to the loodle, we don't suppress the group users as participants
        if (_.contains(memberIds, groupId)) return callback();

        async.each(memberIds, function (memberId, done) {
            if (!util.isGroupId(memberId)) {
                return done();
            }

            getGroupUserIds(ctx, memberId, function (err, groupMemberIds) {
                if (err) return done(err);

                memberIds = _.union(memberIds, groupMemberIds);
                return done();
            });
        }, function (err) {
            if (err) return callback(err);

            // The entire group does not have another access, check now every group user
            getGroupUserIds(ctx, groupId, function (err, groupUserIds) {
                async.each(groupUserIds, function (userId, done) {
                    if (_.contains(memberIds, userId)) return done();

                    LoodleDAO.getLoodleId(content.id, function (err, loodleId) {
                        if (err) return done(err);

                        // The user does not have any access to the loodle anymore, we remove him/her as participant
                        LoodleDAO.removeUser(ctx, loodleId, userId, token, done);
                    });
                }, callback);
            });
        });
    });

};

/**
 * Get groups user ids with their roles in the group
 * @param ctx
 * @param groups
 * @param callback
 */
var getGroupsUserIdsWithRoles = function (ctx, groups, callback) {

    var groupsUsers = {};

    async.forEachOf(groups, function (role, groupId, done) {
        getGroupUserIds(ctx, groupId, function (err, groupUsers) {
            if (err) return done(err);

            groupUsers.forEach(function (id) {
                // If the user was already in another group
                if (id in groupsUsers) {
                    if (groupsUsers[id] === 'manager' || role === 'manager') {
                        groupsUsers[id] = 'manager';
                    }
                    else {
                        groupsUsers[id] = 'viewer';
                    }
                }
                else {
                    groupsUsers[id] = role;
                }
            });

            return done();
        });
    }, function (err) {
        if (err) return callback(err);

        return callback(null, groupsUsers);
    });

};

/**
 * Create a loodle account for every member of the folder (if they don't already have one)
 * @param folderId
 * @param callback
 */
var createAccountForFolderMembers = function (ctx, folderId, callback) {

    // Get the folder from storage to use for permission checks
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) return callback(err);

        AuthzAPI.getAuthzMembers(folder.groupId, null, 1000, function(err, members, nextToken) {
            if (err) return callback(err);

            async.each(members, function (member, done) {
                // The member is an user
                if (util.isUserId(member.id)) {
                    UserDAO.createUserIfNeeded(ctx, member.id, done);
                }
                // The member is a group
                else if (util.isGroupId(member.id)) {
                    getGroupUserIds(ctx, member.id, function (err, groupUserIds) {
                        if (err) return done(err);

                        async.each(groupUserIds, function (userId, finish) {
                            UserDAO.createUserIfNeeded(ctx, userId, finish);
                        }, done);
                    });
                }
                // Invalid member id
                else {
                    return done({code: 500, msg: 'Invalid member id'});
                }

            }, callback);
        });

    });

};

/**
 * Add users to a loodle
 * @param ctx
 * @param additionalMembers
 * @param token
 * @param loodleId
 * @param callback
 */
var addUsers = function (ctx, additionalMembers, token, loodleId, callback) {

    async.forEachOf(additionalMembers, function (role, id, done) {
        addUser(ctx, id, token, loodleId, done);
    }, callback);

};

/**
 * Add a user to a loodle
 * @param ctx
 * @param userId
 * @param token
 * @param loodleId
 * @param callback
 */
var addUser = function (ctx, userId, token, loodleId, callback) {

    async.series({
        createUser: function (done) {
            UserDAO.createUserIfNeeded(ctx, userId, done);
        },
        addUserToLoodle: function (done) {
            LoodleDAO.addUserToLoodle(ctx, token, loodleId, userId, done);
        }
    }, callback);

};

/**
 * Update a member of the loodle
 * @param ctx
 * @param contentId
 * @param userId
 * @param currentUserToken
 * @param callback
 */
var updateMember = function (ctx, contentId, userId, role, currentUserToken, callback) {

    var loodleId;

    async.series({
        // Get loodle id from the content id
        getLoodleId: function (done) {
            LoodleDAO.getLoodleId(contentId, function (err, data) {
                loodleId = data;
                return done(err, data);
            });
        },
        updateMember: function (done) {
            _updateMember(ctx, contentId, loodleId, userId, role, currentUserToken, done);
        }
        // OAE handles the rest of the update
    }, callback);

};

/**
 * Update a member of the loodle
 * @param ctx
 * @param contentId
 * @param loodleId
 * @param userId
 * @param role
 * @param currentUserToken
 * @param callback
 * @private
 */
var _updateMember = function (ctx, contentId, loodleId, userId, role, currentUserToken, callback) {

    // The user was removed from the loodle
    if (!role) {
        // Check if the user has another access to the loodle
        userHasAnotherParticipationAccess(ctx, contentId, userId, function (err, hasAnotherParticipationAccess) {
            if (err) return callback(err);
            if (hasAnotherParticipationAccess) return callback();

            LoodleDAO.removeUser(ctx, loodleId, userId, currentUserToken, callback);
        });
    }
    // The user was either added to the loodle or its status has been updated
    else {
        async.series({
            // Create the user mirror account in the loodle application if needed
            createMirrorAccountIfNeeded: async.apply(UserDAO.createUserIfNeeded, ctx, userId),
            // If the user is not already in the loodle, associate him
            associateUserToLoodleIfNeeded: function (done) {
                LoodleDAO.addUserIfNeeded(ctx, loodleId, userId, currentUserToken, done);
            }
        }, callback)
    }

}

/**
 * Check if the user has another participation access
 * @param ctx
 * @param contentId
 * @param userId
 * @param callback
 */
var userHasAnotherParticipationAccess = function (ctx, contentId, userId, callback) {

    var hasAnotherParticipationAccess = false;

    // Check if the user still has access to the document
    ContentAPI.getContent(ctx, contentId, function (err, content) {
        if (err && err.code === 401 && err.msg === 'The current user does not have access to this resource') {
            return callback(null, hasAnotherParticipationAccess);
        }
        else if (err) {
            return callback(err);
        }

        // The user still has an access to the loodle, check if this is through a folder or not
        ContentAPI.getContentMembersLibrary(ctx, contentId, 0, 1000, function (err, members) {
            if (err) return callback(err);

            // Possible improvement : stop the flow at the moment the user id we're looking for is found
            var memberIds = _.pluck(_.pluck(members, 'profile'), 'id');
            async.each(memberIds, function (memberId, done) {
                if (util.isUserId(memberId)) {
                    if (memberId === userId) hasAnotherParticipationAccess = true;
                    return done();
                }
                else if(util.isGroupId(memberId)) {
                    getGroupUserIds(ctx, memberId, function (err, groupMemberIds) {
                        if (_.contains(groupMemberIds, userId)) hasAnotherParticipationAccess = true;
                        return done();
                    });
                }
                else {
                    return callback({ 'code': 400, 'msg': 'A valid member id must be specified' });
                }
            }, function (err) {
                if (err) return callback(err);
                return callback(null, hasAnotherParticipationAccess);
            });
        });
    });

};
