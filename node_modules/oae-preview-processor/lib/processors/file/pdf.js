/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var clone = require('clone');
var exec = require('child_process').exec;
var fs = require('fs');
var Path = require('path');
var util = require('util');

var log = require('oae-logger').logger('oae-preview-processor');
var ImageUtil = require('oae-util/lib/image');
var IO = require('oae-util/lib/io');

var PreviewConstants = require('oae-preview-processor/lib/constants');
var PreviewUtil = require('oae-preview-processor/lib/util');

var _pdftkBinary = null;
var _pdftkTimeout = 120000;

var _pdf2htmlEXBinary = null;
var _pdf2htmlEXTimeout = 120000;

/**
 * Inits the PDF Processor.
 * This method will check if the Libre Office binary can be executed.
 *
 * @param  {Object} config              The config object containing the path to the pdftk binary and the maximum duration for when the process should be killed
 * @param  {String} config.binary       The path to the `pdftk` executable. This should either be a direct path or the filename that's on the `PATH` environment
 * @param  {Number} config.timeout      Specifies the time (in ms) when the process is considered to be hanging and should be killed. By default, the timeout will be 120000ms
 */
var init = module.exports.init = function(config, callback) {
    if (!config || !config.pdf.binary || !config.pdf.timeout || !config.pdf2htmlEX.binary || !config.pdf2htmlEX.timeout) {
        return callback({'code': 400, 'msg': 'Missing configuration for the Office Preview Processor or pdf2htmlEX, required fields are `binary` and `timeout`.'});
    }

    // Try to execute `pdftk --help`
    var cmd = util.format('%s --help', config.pdf.binary);
    log().trace('Executing %s to verify if the path to the pdftk binary is configured correctly.', cmd);
    exec(cmd, {'timeout': 10000}, function (err, stdout, stderr) {
        if (err) {
            log().error({'err': err, 'stdout': stdout, 'stderr': stderr}, 'Could not properly execute the pdftk binary.');
            return callback({'code': 500, 'msg': 'The path for the pdftk binary is misconfigured.'});
        }

        _pdftkBinary = config.pdf.binary;
        _pdftkTimeout = config.pdf.timeout;
        
        _pdf2htmlEXBinary = config.pdf2htmlEX.binary
        _pdf2htmlEXTimeout = config.pdf2htmlEX.timeout        
        
        callback();
    });
};

/**
 * @borrows Interface.test as PDF.test
 */
var test = module.exports.test = function(ctx, contentObj, callback) {
    if (contentObj.resourceSubType === 'file' && PreviewConstants.TYPES.PDF.indexOf(ctx.revision.mime) !== -1) {
        callback(null, 10);
    } else {
        callback(null, -1);
    }
};

/**
 * @borrows Interface.generatePreviews as PDF.generatePreviews
 */
var generatePreviews = module.exports.generatePreviews = function(ctx, contentObj, callback) {
    // Download the file
    ctx.download(function(err, path) {
        if (err) {
            return callback(err);
        }

        // Generate the previews for it
        previewPDF(ctx, path, callback);
    });
};

/**
 * Generates previews for a PDF file.
 * 1 html will be generated for each page.
 *
 * @param  {PreviewContext}      ctx             The preview context associated to this file
 * @param  {String}              path            The path where the PDF file is stored
 * @param  {Function}            callback        Standard callback method
 * @param  {Object}              callback.err    Standard error object (if any)
 */
var previewPDF = module.exports.previewPDF = function(ctx, path, callback) {
    // Create a directory where we can store the files
    var pagesDir = ctx.baseDir + '/pages';
    fs.mkdir(pagesDir, function(err) {
        if (err) {
            log().error({'err': err, 'contentId': ctx.contentId}, 'Could not create a directory %s to store the pages in', pagesDir);
            return callback({'code': 500, 'msg': 'Could not create a directory to store the splitted pages in'});
        }

        // Split the PDF pages
        _splitPDF(ctx, path, pagesDir, function(err, pageFilenames) {
            if (err) {
                return callback(err);
            }

            // The amount of pages should be stored as metadata
            ctx.addPreviewMetadata('pageCount', pageFilenames.length);

            
            /**
             * Call pdf2htmlEX to change the pdf to HTML files. 
             * 1 html file for each of the pages is created with seperate global css and js script
             * the call --page-filename=page..html is named like that because pdf2htmlEX puts the page number
             * before the extension. In this case this will result in file names like 'page.1.html'
             * The call --fit-width=700 makes the width of the file 700px wide.
             */

            var cmd = util.format('%s --split-pages=1 --page-filename=page..html --embed-css=0 --css-filename=lines.css --embed-javascript=0 --fit-width=700 --dest-dir %s %s', _pdf2htmlEXBinary, pagesDir, path);
            exec(cmd, { 'timeout': _pdf2htmlEXTimeout}, function (err, stdout, stderr) {
                if (err) {
                    log().error({'err': err, 'stdout':stdout, 'stderr':stderr}, 'Could not convert page to html.');
                    return callback({'code':500,'msg':'Could not convert page to html'});
                }
                
                // Loop trough all the pages and add them to the preview
                for(var page = 1; page < pageFilenames.length+1; page++){
                    var htmlPath = pagesDir + '/page.' + page.toString() + '.html';
                    ctx.addPreview(htmlPath,'large');
                }
                
                // Add all the CSS to the preview
                // We do not need the JS at this point so we don't pass it on
                // Since the type name doesn't realy do anything we just pass it on as a 'large'.
                var baseCssPath = pagesDir + '/base.css';
                ctx.addPreview(baseCssPath, 'large');

                var fancyCssPath = pagesDir + '/fancy.css';
                ctx.addPreview(fancyCssPath, 'large');

                var linesCssPath = pagesDir + '/lines.css'; 
                ctx.addPreview(linesCssPath, 'large');
                
                var called = false;

                // Pop the first page out of the array so we can use it to make thumbnails
                var page = pageFilenames.shift();

                // The absolute path where the pdf page is stored
                var pagePath = pagesDir + '/' + page;

                // Convert the first page to a PNG
                // It can be used as page.x.large.png
                var pngPath = pagePath.substr(0, pagePath.length - 3) + 'large.png';
                _convertToPNG(ctx, pagePath, pngPath, PreviewConstants.SIZES.PDF.LARGE, function(err) {
                    if (err) {
                        return callback(err);
                    }    
                    // Crop the page.1.large.png for the thumbnail images
                    var pageOneLargePath = pagesDir + '/page.1.large.png';
                    PreviewUtil.generatePreviewsFromImage(ctx, pageOneLargePath, {'cropMode': 'TOP'}, callback);
                });
            });
        });
    });
};

/**
 * Splits one PDF file into a PDF file per page.
 * ie: If a PDF file has 5 pages in it, this method will generate 5 pdf files in a directory.
 * The files will be named 'page.i.pdf'.
 *
 * @param  {PreviewContext}      ctx             The preview context associated to this file
 * @param  {String}              path            The path where the PDF file is stored
 * @param  {String}              pagesDir        The directory where the pages can be stored in
 * @param  {Function}            callback        Standard callback method
 * @param  {Object}              callback.err    Standard error object (if any)
 * @param  {String[]}            callback.files  An array of file names that were generated and stored in `pagesDir`. The array will be sorted from the first page to the last page
 * @api private
 */
var _splitPDF = function(ctx, path, pagesDir, callback) {
    var cmd = util.format('"%s" "%s" burst output %s/page.%d.pdf', _pdftkBinary, path, pagesDir);
     // Execute the command
    log().trace({'contentId': ctx.contentId}, 'Executing %s', cmd);
    exec(cmd, {'timeout': _pdftkTimeout}, function (err, stdout, stderr) {
        if (err) {
            log().error({'err': err, 'contentId': ctx.contentId, 'stdout': stdout, 'stderr': stderr}, 'Could not split the PDF.');
            return callback({'code': 500, 'msg': 'Could not split the PDF file.'});
        }

        // Splitting was succesful, get a list of files we generated
        fs.readdir(pagesDir, function(err, files) {
            if (err) {
                log().error({'err': err, 'contentId': ctx.contentId}, 'Could not read the %s directory to list the files', pagesDir);
                return callback({'code': 500, 'msg': 'Could not read the directory'});
            }

            // Only return files whose extension is 'pdf'
            files = _.filter(files, function(file) {
                return (file.split('.').pop() === 'pdf');
            });

            // Sort the page filenames from first page to last page
            files.sort(function(a, b) {
                // The file name is in the format "page.12.pdf"
                return parseInt(a.split('.')[1], 10) - parseInt(b.split('.')[1], 10);
            });

            callback(null, files);
        });
    });
};

/**
 * Convert a PDF page to a PNG file.
 * The outputted PNG file will have a width of 1000px.
 *
 * @param  {PreviewContext}      ctx             The preview context associated to this file
 * @param  {String}              input           The PDF file to convert
 * @param  {String}              output          The path where the PNG file should be written
 * @param  {Number}              width           The desired width of the PNG file
 * @param  {Function}            callback        Standard callback method
 * @param  {Object}              callback.err    Standard error object (if any)
 * @api private
 */
var _convertToPNG = function(ctx, input, output, width, callback) {
    var cmd = util.format('gm convert +adjoin -define pdf:use-cropbox=true -density 150 -resize %s -quality 100 "%s" "%s"', width, input, output);
     // Execute the command
    log().trace({'contentId': ctx.contentId}, 'Executing %s', cmd);
    var options = {
        'timeout': _pdftkTimeout,
        'env': _.defaults({'OMP_NUM_THREADS': 2}, process.env)
    };
    exec(cmd, options, function (err, stdout, stderr) {
        if (err) {
            log().error({'err': err, 'contentId': ctx.contentId, 'stdout': stdout, 'stderr': stderr}, 'Could not convert a PDF page to a PNG.');
            return callback({'code': 500, 'msg': 'Could not convert a PDF page to a PNG.'});
        }

        return callback(null);
    });
};

/**
 * Scale an image down a to a smaller image.
 *
 * @param  {PreviewContext}      ctx             The preview context associated to this file
 * @param  {String}              input           The image to scale down
 * @param  {String}              outputdir       The directory to store the scaled down image
 * @param  {String}              desiredFilename The desired filename for the new smaller image
 * @param  {String}              width           The width in pixels of the desired size
 * @param  {Function}            callback        Standard callback method
 * @param  {Object}              callback.err    Standard error object (if any)
 * @param  {String}              callback.path   The path where the new image is stored
 * @api private
 */
var _downScale = function(ctx, input, output, width, callback) {
    ImageUtil.downScale(input, width, function(err, file) {
        if (err) {
            log().error({'err': err, 'contentId': ctx.contentId}, 'Could not downscale an image.');
            return callback({'code': 500, 'msg': 'Could not downscale an image.'});
        }

        IO.moveFile(file.path, output, callback);
    });
};
