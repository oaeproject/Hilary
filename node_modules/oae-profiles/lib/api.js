/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * visibilitys and limitations under the License.
 */

var _ = require('underscore');

var Cassandra = require('oae-util/lib/cassandra');
var Validator = require('oae-util/lib/validator').Validator;

var ProfileSection = require('./model').ProfileSection;
var Constants = require('./model').Constants;

/**
 * Create or update a principal's profile section.
 * This method supports partial updates. It will merge the old object with the new one if `overwrite` is set to false.
 *
 * @param {Context}         context             The context
 * @param {String}          principal_id        The principal for who we need to update this section.
 * @param {String}          sectionName         The name of the section that needs updating.
 * @param {String}          sectionVisibility   One of "private", "loggedin" or "public"
 * @param {Object}          sectionData         A JSON object that will be stored in the DB.
 * @param {Boolean}         overwrite           Specifies whether the profile should be completely overwritten. (default: true)
 * @param {Function(err)}   callback            A callback method.
 * @param {Object}          callback.err        An error object (if any)
 */
var setSection = module.exports.setSection = function(context, principal_id, sectionName, sectionVisibility, sectionData, overwrite, callback) {
    sectionData = sectionData || {};
    callback = callback || {};
    var validator = new Validator();
    validator.check(principal_id, {'code': 400, 'msg': 'A principal id must be provided'}).notEmpty();
    validator.check(sectionName, {'code': 400, 'msg': 'A section name must be provided'}).notEmpty();
    validator.check(overwrite, {'code': 400, 'msg': 'The overwrite variable must be a boolean'}).isIn([true, false]);
    validator.check(null, {'code': 400, 'msg': 'Only proper objects are accepted as section data'}).isObject(sectionData);
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to change a profile section.'}).isLoggedInUser(context);
    if (sectionVisibility !== undefined) {
        var visibilities = _.values(Constants.visibility);
        validator.check(sectionVisibility, {'code': 400, 'msg': 'Visibility should be one of: ' + visibilities.join(',')}).isIn(visibilities);
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getSection(context, principal_id, sectionName, function(err, oldProfileSection) {
        if (err && err.code !== 404) {
            return callback(err);
        }

        var profileSection = null;
        if (err.code === 404) {
            // This is a new profile section.
            sectionVisibility = sectionVisibility || Constants.visibility.PUBLIC;
            profileSection = new ProfileSection(principal_id, sectionName, sectionData, sectionVisibility);
        } else {
            // This is an update, merge it with the old section.
            var data = oldProfileSection.data || {};
            if (!overwrite) {
                data = _.extend(data, sectionData);
            } else {
                data = sectionData;
            }
            var visibility = sectionVisibility || oldProfileSection.visibility;
            profileSection = new ProfileSection(principal_id, sectionName, data, visibility);
        }

        if (context.user().id === principal_id) {
            return _setSection(principal_id, profileSection, callback);
        } else {
            context.isAdmin(function(err, isAdmin) {
                if (err) {
                    return callback(err);
                }
                if (isAdmin) {
                    return _setSection(principal_id, profileSection, callback);
                } else {
                    return callback({'code': 403, 'msg': 'You\'re not allowed to change this user\'s profile'});
                }
            });
        }
    });
};

/**
 * Updates a section. This function will not perform any checking on validity of
 * visibility, data, etc.. It's assumed the caller takes care of this.
 *
 * @param  {String}            principal_id     The id of the principal to whom this section belongs.
 * @param  {ProfileSection}    profileSection   The profilesection that contains the (updated) data.
 * @param  {Function}          callback         Callback method.
 * @param  {Object}            callback.err     An error object (if any.)
 * @private
 */
var _setSection = function(principal_id, profileSection, callback) {
    var columnVisibilityName = profileSection.name + '#visibility';
    var columnDataName = profileSection.name + '#data';
    data = JSON.stringify(profileSection.data);
    Cassandra.runQuery("UPDATE Profiles SET ?=?, ?=? WHERE principal_id=?", [columnVisibilityName, profileSection.visibility, columnDataName, data, principal_id], function(err) {
        if (err) {
            return callback({'code': 500, 'msg': err});
        }

        callback(false);
    });
};

/**
 * Gets a section for a principal. If this principal has marked the section as private and is being retrieved by another non-admin user, an error will be passed.
 *
 * @param  {Context}                context         The context
 * @param  {String}                 principal_id    The principal_id for who we need to retrieve a section.
 * @param  {String}                 sectionName     The name of the section that needs retrieving.
 * @param  {Function(err, data)}    callback        A callback method.
 * @param  {Object}                 callback.err    An error object (if any)
 * @param  {ProfileSection}         callback.data   A ProfileSection object.
 */
var getSection = module.exports.getSection = function(context, principal_id, sectionName, callback) {
    var validator = new Validator();
    validator.check(principal_id, {'code': 400, 'msg': 'The anonymous user does not have any profile sections.'}).notNull();
    validator.check(sectionName, {'code': 400, 'msg': 'The sectionName was not provided.'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    var columnVisibilityName = sectionName + '#visibility';
    var columnDataName = sectionName + '#data';
    Cassandra.runQuery("SELECT ?, ? from Profiles WHERE principal_id = ?", [columnVisibilityName, columnDataName, principal_id], function(err, rows) {
        if (err) {
            return callback({'code': 500, 'msg': err});
        }
        if (rows[0].count <= 1) {
            return callback({'code': 404, 'msg': 'Section not found'});
        }

        var visibility = rows[0].get(columnVisibilityName).value;
        // Only actually parse the data when we're sure that the current user can access it.
        var profileSection = new ProfileSection(principal_id, sectionName, {}, visibility);
        _hasAccess(context, profileSection, function(err, hasAccess) {
            if (err) {
                return callback(err);
            }

            if (!hasAccess) {
                return callback({'code': 403, 'msg' : 'You don\' t have access to this profile section'});
            }
            try {
                var data = rows[0].get(columnDataName).value;
                profileSection.data = JSON.parse(data);
            } catch (err) {
                return callback({'code': 500, 'msg': 'Couldn\'t parse the data in the DB.'});
            }

            callback(false, profileSection);
        });
    });
};

/**
 * Gets all the profile sections for a principal.
 *
 * @param  {Context}                context         The current user's context
 * @param  {String}                 principal_id    The id of the principal for whom the profile should be retrieved.
 * @param  {Function(err, data)}    callback        A callback method
 * @param  {Object}                 callback.err    An error object (if any)
 * @param  {Profilesection[]}       callback.data   The sections the user has access to.
 */
var getAllSections = module.exports.getAllSections = function(context, principal_id, callback) {
    var validator = new Validator();
    validator.check(principal_id, {'code': 400, 'msg': 'The anonymous user does not have any profile sections.'}).notNull();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    
    Cassandra.runQuery("SELECT * from Profiles WHERE principal_id = ?", [principal_id], function(err, rows) {
        if (err) {
            return callback({'code': 500, 'msg': err});
        }

        // In case there are no sections.
        if (rows[0].count <= 1) {
            return callback(false, []);
        }

        var retrievedSections = 0;
        var allSections = [];
        var checkAccess = function(profileSection, sectionData) {
            _hasAccess(context, profileSection, function(err, hasAccess) {
                retrievedSections++;
                if (!err && hasAccess) {
                    try {
                        profileSection.data = JSON.parse(sectionData);
                    } catch (err) {
                        return callback({'code': 500, 'msg': 'Couldn\'t parse the data in the DB for ' + profileSection.name + '.'});
                    }
                    allSections.push(profileSection);
                }

                if (retrievedSections === Math.floor(rows[0].count / 2)) {
                    callback(false, allSections);
                }
            });
        };

        rows[0].forEach(function(name, value, ts, ttl) {
            if (name === 'principal_id') {
                return;
            }
            var parts = name.split('#');
            if (parts[1] === 'data') {
                var sectionName = parts[0];
                var visibility = rows[0].get(sectionName + '#visibility').value;
                var profileSection = new ProfileSection(principal_id, sectionName, {}, visibility);
                checkAccess(profileSection, value);
            }
        });
    });
};


/**
 * Checks if the current user has access to this profile section.
 *
 * @param   {Context}                   context             Current user's context
 * @param   {ProfileSection}            profileSection      The section that needs to be checked.
 * @param   {Function(err, hasAccess)}  callback            Callback method
 * @param   {Object}                    callback.err        An error object (if any)
 * @param   {Boolean}                   callback.hasAccess  Whether or not the current user can see this profile section.
 * @private
 */
var _hasAccess = function(context, profileSection, callback) {
    if (profileSection.visibility === Constants.visibility.PUBLIC) {
        return callback(false, true);
    }
    // Anonymous users can't see private or logged in sections.
    if (context.user() === null && (profileSection.visibility !== Constants.visibility.PUBLIC)) {
        return callback({'code': 401, 'msg': 'You don\'t have access to this profile section. Try logging in.'});
    }

    if (context.user().id === profileSection.principal_id || profileSection.visibility !== Constants.visibility.PRIVATE) {
        callback(false, true);
    } else {
        context.isAdmin(function(err, isAdmin) {
            if (isAdmin) {
                return callback(false, true);
            } else {
                return callback({'code': 403, 'msg': 'You don\'t have access to this profile section.'});
            }
        });
    }
};