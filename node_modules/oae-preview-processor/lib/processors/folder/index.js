/*
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var exec = require('child_process').exec;
var fs = require('fs');
var path = require('path');
var util = require('util');

var ContentConstants = require('oae-content/lib/constants').ContentConstants;
var ContentDAO = require('oae-content/lib/internal/dao');
var ContentUtil = require('oae-content/lib/internal/util');
var Context = require('oae-context').Context;
var FoldersAPI = require('oae-folders');
var FoldersConstants = require('oae-folders/lib/constants').FoldersConstants;
var FoldersContentLibrary = require('oae-folders/lib/internal/contentLibrary');
var FoldersDAO = require('oae-folders/lib/internal/dao');
var ImageUtil = require('oae-util/lib/image');
var log = require('oae-logger').logger('folders-previews');
var TempFile = require('oae-util/lib/tempfile');

var PreviewConstants = require('oae-preview-processor/lib/constants');

// The path to a file that only contains white pixels
var SPACER_PATH = path.resolve(__dirname, '../../../static/folder/spacer.png');

/**
 * Generate preview images for a folder
 *
 * @param  {String}     folderId        The id of the folder for which to generate the preview images
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error object, if any
 */
var generatePreviews = module.exports.generatePreviews = function(folderId, callback) {
    _getData(folderId, function(err, folder, contentItems) {
        if (err) {
            return callback(err);

        // If there are no content items in this folder we can't generate a thumbnail for it.
        // However, we should set an empty previews object as we might have removed all the
        // content items that were used in the old thumbnail
        } else if (_.isEmpty(contentItems)) {
            return FoldersDAO.setPreviews(folder, {}, callback);
        }

        // Generate the preview images
        _generatePreviews(folder, contentItems, function(err) {
            if (err) {
                return callback(err);
            }

            FoldersAPI.emit(FoldersConstants.events.UPDATED_FOLDER_PREVIEWS, folder);
            return callback();
        });
    });
};

/**
 * Given a folder id, get the folder object and a set of content items
 * that are in it which have preview items
 *
 * @param  {String}         folderId                    The id of the folder to retrieve
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                Standard error object
 * @param  {Folder}         callback.folder             The folder object for the given folder id
 * @param  {Content[]}      callback.contentItems       A set of (at most 8) content items that are in the folder and have preview items of their own
 * @api private
 */
var _getData = function(folderId, callback) {
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        _getContentWithPreviews(folder, function(err, contentItems) {
            if (err) {
                return callback(err);
            }

            // Sort the content items so the last modified item is first in the list. This will
            // ensure that the last added (or changed) item is in the top left corner of the preview image
            // which will make it more obvious to users when a folder has been updated
            contentItems = contentItems.sort(function(a, b) { return (a.lastModified - b.lastModified); });

            return callback(null, folder, contentItems);
        });
    });
};

/**
 * Get some content items that are part of a folder that have preview items of their own.
 * This function will return as soon as it has found 8 items
 *
 * @param  {Folder}         folder                      The folder for which to retrieve the content items
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error object if any
 * @param  {Content[]}      callback.contentItems       A set of content items that are in the folder and have preview items
 * @api private
 */
var _getContentWithPreviews = function(folder, callback, _contentWithPreviews, _start) {
    _contentWithPreviews = _contentWithPreviews || [];

    // Get a page of content items. We use content items that have the same visibility
    // as the folder (or more open.) This way we do not escalate any content's privileges
    FoldersContentLibrary.list(folder, folder.visibility, {'start': _start, 'limit': 20}, function(err, contentIds, nextToken) {
        if (err) {
            return callback(err);
        }
        ContentDAO.Content.getMultipleContentItems(contentIds, null, function(err, contentItems) {
            if (err) {
                return callback(err);
            }

            // We can only use content items that have a thumbnail
            var contentWithPreviews = _.filter(contentItems, function(contentObj) {
                return (contentObj.previews && contentObj.previews.thumbnailUri);
            });
            _contentWithPreviews = _contentWithPreviews.concat(contentWithPreviews);

            // If we have 8 items or there are no more items we return to the caller
            if (_contentWithPreviews.length >= 8 || !nextToken) {
                return callback(null, _contentWithPreviews.slice(0, 8));

            // Otherwise we fetch the next set of content items
            } else {
                return _getContentWithPreviews(folder, callback, _contentWithPreviews, nextToken);
            }
        });
    });
};

/**
 * Generate the folder preview images given a set of content items that all have thumbnails of their own
 *
 * @param  {Folder}         folder              The folder for which to generate the preview images
 * @param  {Content[]}      contentItems        The content items that can be used to generate the folder's preview images
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @api private
 */
var _generatePreviews = function(folder, contentItems, callback) {
    // Download the thumbnails
    var ctx = new Context(folder.tenant);
    _downloadThumbnails(ctx, contentItems.slice(), function(err, paths) {
        if (err) {
            return callback(err);
        }

        // Construct the montages
        _createMontages(paths, function(err, thumbnail, wide) {
            if (err) {
                return callback(err);
            }

            _removeOldPreviews(ctx, folder, function(err) {
                if (err) {
                    log().error({'err': err, 'folderId': folder.id}, 'Unable to remove the old folder previews');
                    return callback(err);
                }

                _storeNewPreviews(ctx, folder, thumbnail, wide, function(err, thumbnailUri, wideUri) {
                    if (err) {
                        log().error({'err': err, 'folderId': folder.id}, 'Unable to store the new folder previews');
                        return callback(err);
                    }

                    // Store the metadata
                    var previews = {
                        'thumbnailUri': thumbnailUri,
                        'wideUri': wideUri
                    };
                    FoldersDAO.setPreviews(folder, previews, function(err) {
                        // Clean up any temporary files regardless wether there was an error storing the previews.
                        // Depending on which backend was used to store the thumbnail or wide images, those files
                        // may or may not already be removed
                        var allTempPaths = _.union(paths, [thumbnail.path, wide.path]);
                        _removeAll(paths, function() {
                            return callback(err);
                        });
                    });
                });
            });
        });
    });
};

/**
 * Create 2 montages, one for the thumbnail and one for the wide image
 *
 * @param  {String[]}   paths                       An array of paths that point to the images that should be used in the grids
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error object, if any
 * @param  {Object}     callback.thumbnail          A file object representing the thumbnail
 * @param  {String}     callback.thumbnail.path     The path where the thumbnail has been written to
 * @param  {String}     callback.thumbnail.name     The file name of the thumbnail
 * @param  {Number}     callback.thumbnail.size     The size in bytes of the thumbnail
 * @param  {Object}     callback.wide               A file object representing the wide image
 * @param  {String}     callback.wide.path          The path where the wide image has been written to
 * @param  {String}     callback.wide.name          The file name of the wide image
 * @param  {Number}     callback.wide.size          The size in bytes of the wide image
 * @api private
 */
var _createMontages = function(paths, callback) {
    // Generate the thumbnail
    var thumbnailSize = {
        'width': PreviewConstants.SIZES.IMAGE.THUMBNAIL,
        'height': PreviewConstants.SIZES.IMAGE.THUMBNAIL
    };
    _createMontage({'columns': 2, 'rows': 2}, thumbnailSize, paths.slice(), function(err, thumbnail) {
        if (err) {
            return callback(err);
        }

        // Generate the wide image
        var wideSize = {
            'width': PreviewConstants.SIZES.IMAGE.WIDE_WIDTH,
            'height': PreviewConstants.SIZES.IMAGE.WIDE_HEIGHT
        };
        _createMontage({'columns': 4, 'rows': 2}, wideSize, paths.slice(), function(err, wide) {
            if (err) {
                return callback(err);
            }

            return callback(null, thumbnail, wide);
        });
    });
};

/**
 * Create a montage for the folder by placing all the images that are located in the `paths`
 * array in a grid. The grid size can be specified with the `tile` parameter. This function
 * assumes that the images that should be used in the grid are squares of 324px by 324px.
 *
 * @param  {Object}     tile                    The size of the grid
 * @param  {Number}     tile.columns            The number of columns in the grid
 * @param  {Number}     tile.rows               The number of rows in the grid
 * @param  {Object}     size                    The desired size of the resulting image
 * @param  {Number}     size.width              The width of the resulting image
 * @param  {Number}     size.height             The height of the resulting image
 * @param  {String}     paths                   An array of paths that point to the images that should be used in the grid
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error object, if any
 * @param  {Object}     callback.file           A file object representing the resulting file
 * @param  {String}     callback.file.path      The path where the montage has been written to
 * @param  {String}     callback.file.name      The name of the montage
 * @param  {Number}     callback.file.size      The size in bytes of the montage
 * @api private
 */
var _createMontage = function(tile, size, paths, callback) {
    // If we have less images than cells, we add an empty image
    // in each empty cell. Another option could be to use gm's `null:`
    // value, but that is neither documented nor does it support borders
    var total = tile.columns * tile.rows;
    for (var i = paths.length; i < total; i++) {
        paths.push(SPACER_PATH);
    }
    
    var tileStr = util.format('%sx%s', tile.columns, tile.rows);
    var tmpFile = TempFile.createTempFile({'suffix': '.jpg'});
    var cmd = util.format('gm montage -geometry 324x324+0+0 -borderwidth 1 -bordercolor gray89 -fill white -tile %s %s %s', tileStr, paths.join(' '), tmpFile.path);
    exec(cmd, {'timeout': 4000}, function (err, stdout, stderr) {
        if (err) {
            log().error({'err': err}, 'Unable to create folder montage');
            return callback({'code': 500, 'msg': 'Failed to create folder montage'});
        }

        // Resize the image to the desired size
        ImageUtil.resizeImage(tmpFile.path, size, function(err, resizedFile) {
            // Clean up our temporary file regardless of any errors
            tmpFile.remove(function() {
                return callback(err, resizedFile);
            });
        });
    });
};

/**
 * Download the content thumbnails
 *
 * @param  {Context}        ctx                 The context that holds the tenant whose storage strategy was used to store the files
 * @param  {Content[]}      contentItems        The content items whose thumbnails should be retrieved
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {String[]}       callback.paths      The paths where the thumbnails can be found
 * @api private
 */
var _downloadThumbnails = function(ctx, contentItems, callback, _paths) {
    _paths = _paths || [];

    // If there is nothing left to download, we return to the caller
    if (contentItems.length === 0) {
        return callback(null, _paths);
    }

    // Download the thumbnail for the next content item
    var contentItem = contentItems.pop();
    ContentUtil.getStorageBackend(ctx).get(ctx, contentItem.previews.thumbnailUri, function(err, file) {
        if (err) {
            return callback(err);
        }

        _paths.push(file.path);
        return _downloadThumbnails(ctx, contentItems, callback, _paths);
    });
};

/**
 * Removes all the files in the given `paths` array
 *
 * @param  {String[]}   paths       The paths to remove
 * @param  {Function}   callback    Standard callback function
 * @api private
 */
var _removeAll = function(paths, callback) {
    if (paths.length === 0) {
        return callback();
    }

    var path = paths.pop();
    fs.unlink(path, function(err) {
        _removeAll(paths, callback);
    });
};

/**
 * Remove the old preview images for a folder
 *
 * @param  {Context}    ctx             The context that holds the tenant whose storage strategy was used to store the files
 * @param  {Folder}     folder          The folder for which to remove the old preview images
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error object, if any
 * @api private
 */
var _removeOldPreviews = function(ctx, folder, callback) {
    _removeOldPreview(ctx, folder, 'thumbnailUri', function(err) {
        if (err) {
            return callback(err);
        }
        _removeOldPreview(ctx, folder, 'wideUri', callback);
    });
};

/**
 * Remove an old preview for a folder if it exists
 *
 * @param  {Context}    ctx             The context that holds the tenant whose storage strategy was used to store the files
 * @param  {Folder}     folder          The folder for which to remove the old preview image
 * @param  {String}     type            One of `thumbnailUri` or `wideUri`
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error object, if any
 * @api private
 */
var _removeOldPreview = function(ctx, folder, type, callback) {
    if (folder.previews && folder.previews[type]) {
        ContentUtil.getStorageBackend(ctx).remove(ctx, folder.previews[type], callback);
    } else {
        return callback();
    }
};

/**
 * Store the new preview images for a folder
 *
 * @param  {Context}    ctx             The context that holds the tenant whose storage strategy is used to store the files
 * @param  {Folder}     folder          The folder for which to store the preview images
 * @param  {File}       thumbnail       The thumbnail image that should be stored
 * @param  {File}       wide            The wide image that should be stored
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error object, if any
 * @api private
 */
var _storeNewPreviews = function(ctx, folder, thumbnail, wide, callback) {
    // Store the files with a unique filename
    var filename = util.format('thumbnail_%s.jpg', Date.now());
    ContentUtil.getStorageBackend(ctx).store(ctx, thumbnail, {'filename': filename, 'resourceId': folder.id}, function(err, thumbnailUri) {
        if (err) {
            return callback(err);
        }

        filename = util.format('wide_%s.jpg', Date.now());
        ContentUtil.getStorageBackend(ctx).store(ctx, wide, {'filename': filename,'resourceId': folder.id}, function(err, wideUri) {
            if (err) {
                return callback(err);
            }

            return callback(null, thumbnailUri, wideUri);
        });
    });
};
