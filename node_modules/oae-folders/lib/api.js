/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var util = require('util');

var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzInvitations = require('oae-authz/lib/invitations');
var AuthzPermissions = require('oae-authz/lib/permissions');
var ContentAPI = require('oae-content');
var ContentConstants = require('oae-content/lib/constants').ContentConstants;
var ContentDAO = require('oae-content/lib/internal/dao');
var ContentUtil = require('oae-content/lib/internal/util');
var EmitterAPI = require('oae-emitter');
var LibraryAPI = require('oae-library');
var log = require('oae-logger').logger('oae-folders-api');
var MessageBoxAPI = require('oae-messagebox');
var MessageBoxConstants = require('oae-messagebox/lib/constants').MessageBoxConstants;
var OaeUtil = require('oae-util/lib/util');
var PrincipalsAPI = require('oae-principals');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var PrincipalsUtil = require('oae-principals/lib/util');
var ResourceActions = require('oae-resource/lib/actions');
var SearchAPI = require('oae-search');
var Signature = require('oae-util/lib/signature');
var Validator = require('oae-util/lib/validator').Validator;

var FoldersAuthz = require('./authz');
var FoldersFoldersLibrary = require('./internal/foldersLibrary');
var FoldersConfig = require('oae-config').config('oae-folders');
var FoldersConstants = require('./constants').FoldersConstants;
var FoldersContentLibrary = require('./internal/contentLibrary');
var FoldersDAO = require('./internal/dao');

/*!
 * ### Events
 *
 * * `getFolderProfile(ctx, folder)`: A folder profile was retrieved
 * * `createdFolder(ctx, folder, members)`: A new folder was created
 * * `updatedFolder(ctx, oldFolder, newFolder)`: A folder was updated
 * * `deletedFolder(ctx, folder, memberIds)`: A folder was deleted
 * * `updatedFolderMembers(ctx, folder, memberUpdates, addedMemberIds, updatedMemberIds, removedMemberIds)`: The members of a folder have been updated
 * * `updatedFolderVisibility(ctx, folder, visibility, affectedContentItems, failedContentItems)`: The content items in a folder their visibility have been updated
 * * `addedContentItems(ctx, actionContext, folder, contentItems)`: One or more content items were added to a folder
 * * `removedContentItems(ctx, folder, contentIds)`: One or more content items were removed from a folder
 * * `createdComment(ctx, folder, message)`: A comment was placed on a folder
 */
var FoldersAPI = module.exports = new EmitterAPI.EventEmitter();

/**
 * Create a folder
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}         displayName             The display name of the folder
 * @param  {String}         [description]           The description of the folder. By default, a folder will have no description
 * @param  {String}         [visibility]            The visibility of the folder. One of `AuthzConstants.visibility`. This will default to a value configured for the tenant
 * @param  {Object}         [roles]                 An object whose keys are principal ids and values are the role they should have on the folder. By default only the creator of the folder will be a manager
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Folder}         callback.folder         The folder that was created
 */
var createFolder = module.exports.createFolder = function(ctx, displayName, description, visibility, roles, callback) {
    visibility = visibility || FoldersConfig.getValue(ctx.tenant().alias, 'visibility', 'folder');
    roles = roles || {};

    var allVisibilities = _.values(AuthzConstants.visibility);

    // Verify basic properties
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Anonymous users cannot create a folder'}).isLoggedInUser(ctx);
    validator.check(displayName, {'code': 400, 'msg': 'Must provide a display name for the folder'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'A display name can be at most 1000 characters long'}).isShortString();
    if (description) {
        validator.check(description, {'code': 400, 'msg': 'A description can be at most 10000 characters long'}).isMediumString();
    }
    validator.check(visibility, {'code': 400, 'msg': 'An invalid folder visibility option has been provided. Must be one of: ' + allVisibilities.join(', ')}).isIn(allVisibilities);

    // Verify each role is valid
    _.each(roles, function(role) {
        validator.check(role, {'code': 400, 'msg': util.format('The role "%s" is not a valid member role for a folder', role)}).isIn(FoldersConstants.role.ALL_PRIORITY);
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the current user can manage any of the specified managers
    var managerIds = _.chain(roles)
        .keys()
        .filter(function(principalId) {
            return (roles[principalId] === AuthzConstants.role.MANAGER);
        })
        .value();
    PrincipalsAPI.canManageAny(ctx, managerIds, function(err, canManageAny) {
        if (err && err.code !== 404) {
            return callback(err);
        } else if (err) {
            return callback({'code': 400, 'msg': 'One or more target principals could not be found'});
        } else if (!canManageAny) {
            // We only make the current user a manager of the folder if they cannot
            // manage any of the specified managers
            roles[ctx.user().id] = AuthzConstants.role.MANAGER;
        }

        var createFn = _.partial(FoldersDAO.createFolder, ctx.user().id, displayName, description, visibility);
        ResourceActions.create(ctx, roles, createFn, function(err, folder, memberChangeInfo) {
            if (err) {
                return callback(err);
            }

            FoldersAPI.emit(FoldersConstants.events.CREATED_FOLDER, ctx, folder, memberChangeInfo, function(errs) {
                if (errs) {
                    return callback(_.first(errs));
                }

                return callback(null, folder);
            });
        });
    });
};

/**
 * Update a folder's metadata
 *
 * @param  {Context}        ctx                             Standard context object containing the current user and the current tenant
 * @param  {String}         folderId                        The id of the folder to update
 * @param  {Object}         updates                         The updates that should be persisted on the folder
 * @param  {String}         [updates.displayName]           The new display name for the folder
 * @param  {String}         [updates.description]           The new description for the folder
 * @param  {String}         [updates.visibility]            The new visibility for the folder
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Folder}         callback.folder                 The updated folder
 */
var updateFolder = module.exports.updateFolder = function(ctx, folderId, updates, callback) {
    var allVisibilities = _.values(AuthzConstants.visibility);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Anonymous users cannot create a folder'}).isLoggedInUser(ctx);
    validator.check(folderId, {'code': 400, 'msg': util.format('The folder id "%s" is not a valid resource id', folderId)}).isResourceId();
    validator.check(updates, {'code': 400, 'msg': 'Missing update information'}).isObject(updates);

    // Ensure that at least one valid update field was provided
    var updateFields = _.keys(updates);
    var legalUpdateFields = ['displayName', 'description', 'visibility'];
    validator.check(_.intersection(updateFields, legalUpdateFields).length, {'code': 400, 'msg': 'One of ' + legalUpdateFields.join(', ') + ' must be provided'}).min(1);

    _.each(updates, function(val, key) {
        validator.check(key, {'code': 400, 'msg': 'Unknown update field provided'}).isIn(legalUpdateFields);
    });

    if (updates.displayName) {
        validator.check(updates.displayName, {'code': 400, 'msg': 'A display name can be at most 1000 characters long'}).isShortString();
    }
    if (updates.description) {
        validator.check(updates.description, {'code': 400, 'msg': 'A description can be at most 10000 characters long'}).isMediumString();
    }
    if (updates.visibility) {
        validator.check(updates.visibility, {'code': 400, 'msg': 'An invalid folder visibility option has been provided. Must be one of: ' + allVisibilities.join(', ')}).isIn(allVisibilities);
    }

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the folder from storage to use for permission checks
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Ensure the current user can manage the folder
        AuthzPermissions.canManage(ctx, folder, function(err) {
            if (err) {
                return callback(err);
            }

            // Update the folder's metadata
            FoldersDAO.updateFolder(folder, updates, function(err, updatedFolder) {
                if (err) {
                    return callback(err);
                }

                FoldersAPI.emit(FoldersConstants.events.UPDATED_FOLDER, ctx, updatedFolder, folder);

                // Get the full folder profile for the updated folder
                return _getFullFolderProfile(ctx, updatedFolder, callback);
            });
        });
    });
};

/**
 * Update the content items in a folder
 *
 * @param  {Context}        ctx                             Standard context object containing the current user and the current tenant
 * @param  {String}         folderId                        The id of the folder for which to update the visibility of the content items
 * @param  {String}         visibility                      The new visibility for the content items in the folder
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Content[]}      callback.failedContent          The content items that could not be updated
 */
var updateFolderContentVisibility = module.exports.updateFolderContentVisibility = function(ctx, folderId, visibility, callback) {
    var allVisibilities = _.values(AuthzConstants.visibility);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Anonymous users cannot update the visibility of items in a folder'}).isLoggedInUser(ctx);
    validator.check(folderId, {'code': 400, 'msg': util.format('The folder id "%s" is not a valid resource id', folderId)}).isResourceId();
    validator.check(visibility, {'code': 400, 'msg': 'Missing visibility value'}).notEmpty();
    validator.check(visibility, {'code': 400, 'msg': 'An invalid folder visibility option has been provided. Must be one of: ' + allVisibilities.join(', ')}).isIn(allVisibilities);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the folder from storage to use for permission checks
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Ensure the current user can manage the folder
        AuthzPermissions.canManage(ctx, folder, function(err) {
            if (err) {
                return callback(err);
            }

            // Apply the visibility on all the content items in the folder
            _updateFolderContentVisibility(ctx, folder, visibility, callback);
        });
    });
};

/**
 * Set the `newVisibility` visibility on all the content items in the folder. This function
 * assumes that the current user has manager rights on the given folder.
 *
 * Keep in mind that this is *NOT* a lightweight operation. The following actions will take place:
 *   -  The private folder library needs to be listed (to retrieve the content ids)
 *   -  All those content items need to be retrieved
 *   -  All those content items need to be updated
 *       -  Because each content item can have it own set of permissions, we need to check
 *          each content item at a time
 *       -  This means an authz check happens PER content item
 *   -  Each update triggers a search reindex of the content item
 *   -  Purges the folder content library
 *
 * @param  {Context}        ctx                         Standard context object containing the current user and the current tenant
 * @param  {Folder}         folder                      The folder for which to update the visibility of the content items
 * @param  {String}         visibility                  The new visibility for the content items
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error that occurred, if any
 * @param  {Content[]}      callback.failedContent      The content items that could not be updated
 * @api private
 */
var _updateFolderContentVisibility = function(ctx, folder, visibility, callback) {
    // Get all the content items in this folder
    FoldersAuthz.getContentInFolder(folder, function(err, contentIds) {
        if (err) {
            log().error({'err': err, 'folderId': folder.id}, 'Got an error when updating the visibility of content in a folder');
            return callback(err);
        }

        // Get the content objects
        ContentDAO.Content.getMultipleContentItems(contentIds, null, function(err, contentItems) {
            if (err) {
                log().error({'err': err, 'folderId': folder.id}, 'Got an error when updating the visibility of content in a folder');
                return callback(err);
            }

            contentItems = _.chain(contentItems)
                // Remove null content items. This can happen if libraries are in an inconsistent
                // state. For example, if an item was deleted from the system but hasn't been removed
                // from the libraries, a `null` value would be returned by `getMultipleContentItems`
                .compact()

                // Grab those content items that don't have the desired visibility
                .filter(function(content) {
                    return (content.visibility !== visibility);
                })
                .value();

            var failedContent = [];

            /*!
             * Executed once all the content items have been updated
             */
            var done = function() {
                FoldersContentLibrary.purge(folder, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Sign the previews for each content item
                    _.each(failedContent, function(content) {
                        ContentUtil.augmentContent(ctx, content);
                    });

                    FoldersAPI.emit(FoldersConstants.events.UPDATED_FOLDER_VISIBILITY, ctx, folder, visibility, contentItems, failedContent);
                    return callback(null, failedContent);
                });
            };

            /*!
             * Update a batch of content items
             */
            var updateBatch = function() {
                // If there are no items to update, we can move on
                if (_.isEmpty(contentItems)) {
                    return done();
                }

                // Get the next batch of content items that should be updated
                var contentItemsToUpdate = contentItems.splice(0, 20);

                // We move on to the next batch once all content items in the current batch have been updated
                var contentUpdated = _.after(contentItemsToUpdate.length, updateBatch);

                // Try and update each content item
                _.each(contentItemsToUpdate, function(content) {
                    _updateContentVisibility(ctx, content, visibility, function(err) {
                        if (err) {
                            failedContent.push(content);
                        }

                        contentUpdated();
                    });
                });
            };

            // Update the first batch of content items
            updateBatch();
        });
    });
};

/**
 * Update the visibility of a given content item. This function will update
 * the visibility of the content item if, and only if, the current user has
 * manager rights on that item. It will *NOT* trigger any content-update activities
 *
 * @param  {Context}        ctx                         Standard context object containing the current user and the current tenant
 * @param  {Folder}         content                     The content item for which to update the visibility
 * @param  {String}         visibility                  The new visibility of the content item
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error that occurred, if any
 * @api private
 */
var _updateContentVisibility = function(ctx, content, visibility, callback) {
    AuthzPermissions.canManage(ctx, content, function(err) {
        if (err) {
            return callback(err);
        }

        ContentDAO.Content.updateContent(content, {'visibility': visibility}, true, function(err) {
            if (err) {
                return callback(err);
            }

            // Because we updated the visibility with the DAO, we'll need to
            // manually trigger a search reindexing event
            SearchAPI.postIndexTask('content', [{'id': content.id}], {
                'resource': true
            });

            // Return to the caller
            return callback();
        });
    });
};

/**
 * Get a folder by its id
 *
 * @param  {Context}        ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}         folderId            The id of the folder to get
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Folder}         callback.folder     The folder identified by the given id
 */
var getFolder = module.exports.getFolder = function(ctx, folderId, callback) {
    var validator = new Validator();
    validator.check(folderId, {'code': 400, 'msg': util.format('The folder id "%s" is not a valid resource id', folderId)}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the folder from storage to use for permission checks
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Ensure the current user can view the folder
        AuthzPermissions.canView(ctx, folder, function(err) {
            if (err) {
                return callback(err);
            }

            // Sign the folder previews (if any)
            folder = _augmentFolder(ctx, folder);

            // Return the folder to the user
            return callback(null, folder);
        });
    });
};

/**
 * Get the full folder profile, which includes additional information about the relation of the
 * current user to the folder
 *
 * @param  {Context}        ctx                             Standard context object containing the current user and the current tenant
 * @param  {String}         folderId                        The id of the folder whose full profile to get
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Folder}         callback.folder                 The basic profile of the folder, with some additional information provided
 * @param  {Boolean}        callback.folder.canManage       Whether or not the current user can manage the folder
 * @param  {Boolean}        callback.folder.canShare        Whether or not the current user can share the folder
 * @param  {Boolean}        callback.folder.canAddItem      Whether or not the current user can add a content item to the folder
 * @param  {User}           callback.folder.createdBy       The basic profile of the user who created the folder
 */
var getFullFolderProfile = module.exports.getFullFolderProfile = function(ctx, folderId, callback) {
    var validator = new Validator();
    validator.check(folderId, {'code': 400, 'msg': util.format('The folder id "%s" is not a valid resource id', folderId)}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the folder from storage to use for permissions checks
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        _getFullFolderProfile(ctx, folder, callback);
    });
};

/**
 * Get a full folder profile. Next to the basic folder profile, this will include the profile of the user who originally
 * created the profile, a set of properties that determine whether the folder can be managed, shared or content can be
 * added to it by the current user and finally a signature that allows the user to sign up for push notifications relating
 * to the folder
 *
 * @param  {Context}        ctx                             Standard context object containing the current user and the current tenant
 * @param  {Folder}         folder                          The folder whose full profile to get
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Folder}         callback.folder                 The full folder profile
 * @param  {Boolean}        callback.folder.canManage       Whether or not the current user can manage the folder
 * @param  {Boolean}        callback.folder.canShare        Whether or not the current user can share the folder
 * @param  {Boolean}        callback.folder.canAddItem      Whether or not the current user can add a content item to the folder
 * @param  {User}           callback.folder.createdBy       The basic profile of the user who created the folder
 * @api private
 */
var _getFullFolderProfile = function(ctx, folder, callback) {
    AuthzPermissions.resolveEffectivePermissions(ctx, folder, function(err, permissions) {
        if (err) {
            return callback(err);
        } else if (!permissions.canView) {
            return callback({'code': 401, 'msg': 'You are not authorized to view this folder'});
        }

        // Sign the folder previews (if any)
        folder = _augmentFolder(ctx, folder);

        folder.canManage = permissions.canManage;
        folder.canShare = permissions.canShare;
        folder.canAddItem = permissions.canManage;

        if (ctx.user()) {
            // Add a signature that can be used to subscribe to push notifications
            folder.signature = Signature.createExpiringResourceSignature(ctx, folder.id);
        }

        // Populate the creator of the folder
        PrincipalsUtil.getPrincipal(ctx, folder.createdBy, function(err, creator) {
            if (err) {
                log(ctx).warn({
                    'err': err,
                    'userId': folder.createdBy,
                    'folderId': folder.id
                }, 'An error occurred getting the creator of a folder. Proceeding with empty user for full profile');
            }

            if (creator) {
                folder.createdBy = creator;
            }

            FoldersAPI.emit(FoldersConstants.events.GET_FOLDER_PROFILE, ctx, folder);
            return callback(null, folder);
        });
    });
};

/**
 * Delete a folder
 *
 * @param  {Context}        ctx                         Standard context object containing the current user and the current tenant
 * @param  {String}         folderId                    The id of the folder to delete
 * @param  {Boolean}        deleteContent               Whether or not to delete the content that's in the folder
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error that occurred, if any
 * @param  {Content[]}      callback.failedContent      The content items that could not be deleted
 */
var deleteFolder = module.exports.deleteFolder = function(ctx, folderId, deleteContent, callback) {
    var validator = new Validator();
    validator.check(folderId, {'code': 400, 'msg': 'A folder id must be provided'}).isResourceId();
    validator.check(null, {'code': 401, 'msg': 'You must be authenticated to delete a folder'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        AuthzPermissions.canManage(ctx, folder, function(err) {
            if (err) {
                return callback(err);
            }

            _deleteFolder(folder, function(err, memberIds) {
                if (err) {
                    return callback(err);
                }

                FoldersAPI.emit(FoldersConstants.events.DELETED_FOLDER, ctx, folder, memberIds, function(errs) {
                    // Get all the content items that were in this folder so we can either
                    // remove the content items or remove the authz link
                    FoldersAuthz.getContentInFolder(folder, function(err, contentIds) {
                        if (err) {
                            return callback(err);
                        }

                        // Delete the content if we were instructed to do so
                        if (deleteContent) {
                            _deleteContent(ctx, contentIds, function(failedContent) {
                                // Get the content objects that we couldn't delete
                                ContentDAO.Content.getMultipleContentItems(failedContent, null, function(err, contentItems) {
                                    if (err) {
                                        return callback(err);
                                    }

                                    _.chain(contentItems)
                                        // Remove null content items. This can happen if libraries are in an inconsistent
                                        // state. For example, if an item was deleted from the system but hasn't been removed
                                        // from the libraries, a `null` value would be returned by `getMultipleContentItems`
                                        .compact()

                                        // Sign the content items, note that we don't have to do any permission
                                        // checks here, as the user had access to these content items by virtue
                                        // of being a member of the folder
                                        .each(function(contentItem) {
                                            ContentUtil.augmentContent(ctx, contentItem);
                                        });

                                    return callback(null, contentItems);
                                });
                            });

                        // Otherwise remove the folder as an authz member of
                        // all the content items
                        } else {
                            return _removeAuthzFolderFromContentItems(folder, contentIds, callback);
                        }
                    });
                });
            });
        });
    });
};

/**
 * Delete a folder. This function will not perform any access checks.
 *
 * @param  {Folder}         folder                  The folder that should be removed
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error object, if any
 * @param  {String[]}       callback.memberIds      The ids of the principals who were members of this folder
 * @api private
 */
var _deleteFolder = function(folder, callback) {
    // Get all the principal ids who are a member of this folder
    AuthzAPI.getAllAuthzMembers(folder.groupId, function(err, memberRoles) {
        if (err) {
            return callback(err);
        }

        // Remove each principal from this folder
        var memberIds = _.pluck(memberRoles, 'id');
        var roleChanges = {};
        _.each(memberIds, function(memberId) {
            roleChanges[memberId] = false;
        });

        // Update the authz associations
        AuthzAPI.updateRoles(folder.groupId, roleChanges, function(err) {
            if (err) {
                return callback(err);
            }

            // Remove the actual folder
            FoldersDAO.deleteFolder(folder.id, function(err) {
                if (err) {
                    return callback(err);
                }

                return callback(null, memberIds);
            });
        });
    });
};

/**
 * Delete a set of content items
 *
 * @param  {Context}        ctx                         Standard context object containing the current user and the current tenant
 * @param  {String[]}       contentIds                  The ids of the content items to remove
 * @param  {Function}       callback                    Standard callback function
 * @param  {Content[]}      callback.failedContent      The content items that could not be deleted
 * @api private
 */
var _deleteContent = function(ctx, contentIds, callback, _failedContent) {
    _failedContent = _failedContent || [];

    // If there are no items to delete, we can return to the caller
    if (contentIds.length === 0) {
        return callback(_failedContent);
    }

    // In order to not overload the database with a massive amount of queries
    // we delete the content items in batches
    var contentIdsToDelete = contentIds.splice(0, 20);

    // Only proceed to the next batch if all content from this batch has been removed
    var done = _.after(contentIdsToDelete.length, function() {
        _deleteContent(ctx, contentIds, callback, _failedContent);
    });

    // Delete each content item
    _.each(contentIdsToDelete, function(contentId) {
        ContentAPI.deleteContent(ctx, contentId, function(err) {
            // Keep track of the content items that could not be deleted
            if (err) {
                _failedContent.push(contentId);
            }

            done();
        });
    });
};

/**
 * Remove the authz membership between a folder and a set of content items
 *
 * @param  {Folder}     folder          The folder for which to remove the authz membership
 * @param  {String[]}   contentIds      The content ids for which to remove the authz membership
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error object, if any
 * @api private
 */
var _removeAuthzFolderFromContentItems = function(folder, contentIds, callback) {
    if (_.isEmpty(contentIds)) {
        return callback();
    }

    // In order to not overload the database with a massive amount of queries
    // we remove the authz link in batches
    var contentIdsToDelete = contentIds.splice(0, 20);

    // Only proceed to the next batch if all links in this batch have been removed
    var done = _.after(contentIdsToDelete.length, function() {
        _removeAuthzFolderFromContentItems(folder, contentIds, callback);
    });

    // Remove the link between the content items and the folder
    _.each(contentIdsToDelete, function(contentId) {
        // Remove the folder as an authz member
        var roleChange = {};
        roleChange[folder.groupId] = false;
        AuthzAPI.updateRoles(contentId, roleChange, function(err) {
            if (err) {
                log().error({
                    'err': err,
                    'folderId': folder.id,
                    'folderGroupId': folder.groupId,
                    'contentId': contentId
                }, 'Unable to remove the folder from a group');
            }
            done();
        });
    });
};


/**
 * List the members of a folder
 *
 * @param  {Context}        ctx                             Standard context object containing the current user and the current tenant
 * @param  {String}         folderId                        The id of the folder whose members to get
 * @param  {String}         [start]                         A token that indicates where in the list to start returning members. Use the `nextToken` result from this method to determine where to start the next page of members
 * @param  {Number}         [limit]                         The maximum number of members to return
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Object[]}       callback.results                An array of objects indicating the members of the folder and their roles
 * @param  {User|Group}     callback.results[i].profile     The basic profile of the user or group who is a member of the folder
 * @param  {String}         callback.results[i].role        The role of the user or group on the folder
 * @param  {String}         callback.nextToken              The token to use for the next `start` value in order to get the next page of members. If this value is `null`, it indicates that there are no more members to page
 */
var getFolderMembers = module.exports.getFolderMembers = function(ctx, folderId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(folderId, {'code': 400, 'msg': 'A folder id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getFolder(ctx, folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Get the folder members
        AuthzAPI.getAuthzMembers(folder.groupId, start, limit, function(err, memberRoles, nextToken) {
            if (err) {
                return callback(err);
            }

            // Get the basic profiles for all of these principals
            PrincipalsUtil.getPrincipals(ctx, _.pluck(memberRoles, 'id'), function(err, memberProfiles) {
                if (err) {
                    return callback(err);
                }

                // Merge the member profiles and roles into a single object
                var memberList = _.map(memberRoles, function(memberRole) {
                    return {
                        'profile': memberProfiles[memberRole.id],
                        'role': memberRole.role
                    };
                });

                return callback(null, memberList, nextToken);
            });
        });
    });
};

/**
 * Get the invitations for the specified folder
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}         folderId                The id of the folder to get the invitations for
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Invitation[]}   callback.invitations    The invitations
 */
var getFolderInvitations = module.exports.getFolderInvitations = function(ctx, folderId, callback) {
    var validator = new Validator();
    validator.check(folderId, {'code': 400, 'msg': 'A valid resource id must be specified'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        return AuthzInvitations.getAllInvitations(ctx, folder, callback);
    });
};

/**
 * Resend an invitation email for the specified email and folder
 *
 * @param  {Context}        ctx             Standard context object containing the current user and the current tenant
 * @param  {String}         folderId        The id of the folder to which the email was invited
 * @param  {String}         email           The email that was previously invited
 * @param  {Function}       callback        Standard callback function
 * @param  {Object}         callback.err    An error that occurred, if any
 */
var resendFolderInvitation = module.exports.resendFolderInvitation = function(ctx, folderId, email, callback) {
    var validator = new Validator();
    validator.check(folderId, {'code': 400, 'msg': 'A valid resource id must be specified'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        return ResourceActions.resendInvitation(ctx, folder, email, callback);
    });
};

/**
 * Share a folder with a set of users and groups. All users and groups who are shared the
 * folder will be given the `member` role. However, if they already have a different role, the
 * existing role will not be changed
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     folderId        The id of the folder to share
 * @param  {String[]}   principalIds    The ids of the users and groups with whom to share the folder
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var shareFolder = module.exports.shareFolder = function(ctx, folderId, principalIds, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to share a folder'}).isLoggedInUser(ctx);
    validator.check(folderId, {'code': 400, 'msg': 'A valid folder id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure the folder exists
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Perform the share operation
        ResourceActions.share(ctx, folder, principalIds, AuthzConstants.role.VIEWER, function(err, memberChangeInfo) {
            if (err) {
                return callback(err);
            } else if (_.isEmpty(memberChangeInfo.changes)) {
                // If no new members were actually added, we don't have to do anything more
                return callback();
            }

            FoldersAPI.emit(FoldersConstants.events.UPDATED_FOLDER_MEMBERS, ctx, folder, memberChangeInfo, {}, function(errs) {
                if (errs) {
                    return callback(_.first(errs));
                }

                return callback();
            });
        });
    });
};

/**
 * Set permissions to the folder. This is similar to sharing a folder, however rather than
 * only giving users and groups the `member` role, other roles can be applied and also users and
 * groups can be removed from the folder membership
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     folderId        The id of the folder whose permissions to set
 * @param  {Object}     changes         An object whose key is the user or group id to set on the folder, and the value is the role you wish them to have. If the role of a user is set to `false`, then it indicates to remove the user from the folder
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var setFolderPermissions = module.exports.setFolderPermissions = function(ctx, folderId, changes, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to change folder permissions'}).isLoggedInUser(ctx);
    validator.check(folderId, {'code': 400, 'msg': 'A valid folder id must be provided'}).isResourceId();
    _.each(changes, function(role, principalId) {
        validator.check(role, {'code': 400, 'msg': 'The role change: ' + role + ' is not a valid value. Must either be a string, or false'}).isValidRoleChange();
        if (role) {
            validator.check(role, {'code': 400, 'msg': 'The role: "' + role + '" is not a valid value. Must be one of: ' + FoldersConstants.role.ALL_PRIORITY.join(', ') + '; or false'}).isIn(FoldersConstants.role.ALL_PRIORITY);
        }
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the folder object, throwing an error if it doesn't exist, but not applying permissions checks
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Set the folder roles
        ResourceActions.setRoles(ctx, folder, changes, function(err, memberChangeInfo) {
            if (err) {
                return callback(err);
            } else if (_.isEmpty(memberChangeInfo.changes)) {
                return callback();
            }

            FoldersAPI.emit(FoldersConstants.events.UPDATED_FOLDER_MEMBERS, ctx, folder, memberChangeInfo, {}, function(errs) {
                if (errs) {
                    return callback(_.first(errs));
                }

                return callback();
            });
        });
    });
};

/**
 * Add a set of content items to a folder
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     folderId        The id of the folder to which to add the content items
 * @param  {String[]}   contentIds      The ids of the content items to add to the folder
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var addContentItemsToFolder = module.exports.addContentItemsToFolder = function(ctx, folderId, contentIds, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be authenticated to be able to add an item to a folder'}).isLoggedInUser(ctx);
    validator.check(folderId, {'code': 400, 'msg': 'A valid folder id must be provided'}).isResourceId();
    validator.check(null, {'code': 400, 'msg': 'Must specify at least one content item to add'}).isArray(contentIds);
    validator.check(_.values(contentIds).length, {'code': 400, 'msg': 'You must specify at least one content item to add'}).min(1);

    // Ensure each content id is valid
    _.each(contentIds, function(contentId) {
        validator.check(contentId, {'code': 400, 'msg': util.format('The id "%s" is not a valid content id', contentId)}).isResourceId();
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the folder to which we're trying to add the content items
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Get the content profiles of all items being added for permission checks
        ContentDAO.Content.getMultipleContentItems(contentIds, null, function(err, contentItems) {
            if (err) {
                return callback(err);
            }

            // Return an error if one or more content items could not be found
            contentItems = _.compact(contentItems);
            if (contentItems.length !== contentIds.length) {
                return callback({'code': 404, 'msg': 'One or more of the specified content items do not exist'});
            }

            // Determine if the content items can be added to the folder
            FoldersAuthz.canAddItemsToFolder(ctx, folder, contentItems, function(err) {
                if (err && err.code !== 401) {
                    return callback(err);
                } else if (err && !_.isEmpty(err.invalidContentIds)) {
                    return callback({'code': 401, 'msg': util.format('You are not authorized to add the following items to the folder: %s', err.invalidContentIds.join(', '))});
                } else if (err) {
                    return callback(err);
                }

                // Add all the items to the folder
                return _addContentItemsToFolderLibrary(ctx, 'add-to-folder', folder, contentItems.slice(), callback);
            });
        });
    });
};

/**
 * Add content items to a folder. Note that this method does *NOT* perform any
 * permission or validation checks.
 *
 * @param  {String}         actionContext       One of `content-create` or `add-to-folder`
 * @param  {Folder}         folder              The folder to which to add the content items
 * @param  {Content[]}      contentItems        The content items to add
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @api private
 */
var _addContentItemsToFolderLibrary = module.exports._addContentItemsToFolderLibrary = function(ctx, actionContext, folder, contentItems, callback) {
    // First, make the folder a member of all the content items
    _addContentItemsToAuthzFolder(folder, contentItems.slice(), function(err) {
        if (err) {
            return callback(err);
        }

        // Second, add the content items in the folder's library buckets
        FoldersContentLibrary.insert(folder, contentItems, function(err) {
            if (err) {
                log(ctx).warn({
                    'err': err,
                    'folderId': folder.id,
                    'contentIds': _.pluck(contentItems, 'id')
                }, 'An error occurred while inserting content items into a folder library');
            }

            FoldersAPI.emit(FoldersConstants.events.ADDED_CONTENT_ITEMS, ctx, actionContext, folder, contentItems);

            return callback(err);
        });
    });
};

/**
 * Remove a set of content items from a folder
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     folderId        The id of the folder from which to remove the content items
 * @param  {String[]}   contentIds      The ids of the content items to remove from the folder
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var removeContentItemsFromFolder = module.exports.removeContentItemsFromFolder = function(ctx, folderId, contentIds, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be authenticated to be able to remove an item from a folder'}).isLoggedInUser(ctx);
    validator.check(folderId, {'code': 400, 'msg': 'A valid folder id must be provided'}).isResourceId();
    validator.check(null, {'code': 400, 'msg': 'You must specify at least one content item to remove'}).isArray(contentIds);
    validator.check(_.values(contentIds).length, {'code': 400, 'msg': 'You must specify at least one content item to remove'}).min(1);

    // Ensure each content id is valid
    _.each(contentIds, function(contentId) {
        validator.check(contentId, {'code': 400, 'msg': util.format('The id "%s" is not a valid content id', contentId)}).isResourceId();
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the folder from which we're trying to remove the content items
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Ensure that the user is allowed to remove items from this folder
        AuthzPermissions.canManage(ctx, folder, function(err) {
            if (err) {
                return callback(err);
            }

            // Get the content profiles of all items being removed
            ContentDAO.Content.getMultipleContentItems(contentIds, null, function(err, contentItems) {
                if (err) {
                    return callback(err);
                }

                // Return an error if one or more content items could not be found
                contentItems = _.compact(contentItems);
                if (contentItems.length !== contentIds.length) {
                    return callback({'code': 404, 'msg': 'One or more of the specified content items do not exist'});
                }

                // Remove all the items from the folder
                _removeContentItemsFromFolder(folder, contentIds.slice(), function(err) {
                    if (err) {
                        return callback(err);
                    }

                    FoldersContentLibrary.remove(folder, contentItems, function(err) {
                        if (err) {
                            log(ctx).warn({
                                'err': err,
                                'folderId': folder.id,
                                'contentIds': contentIds
                            }, 'An error occurred while removing content items from a folder library');
                        }

                        FoldersAPI.emit(FoldersConstants.events.REMOVED_CONTENT_ITEMS, ctx, folder, contentItems);
                        return callback();
                    });
                });
            });
        });
    });
};

/**
 * List a user or group library of folders
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}         principalId             The id of the user or group whose library of folders to list
 * @param  {String}         [start]                 A token that indicates where in the list to start returning folders. Use the `nextToken` result from this method to determine where to start the next page of folders
 * @param  {Number}         [limit]                 The maximum number of folders to return
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Folder[]}       callback.folders        The list of folders
 * @param  {String}         callback.nextToken      The token to use for the next `start` value in order to get the next page of folders. If this value is `null`, it indicates that there are no more folders to page
 */
var getFoldersLibrary = module.exports.getFoldersLibrary = function(ctx, principalId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'A user or group id must be provided'}).isPrincipalId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the principal
    PrincipalsDAO.getPrincipal(principalId, function(err, principal) {
        if (err) {
            return callback(err);
        }

        // Determine which library visibility the current user should receive
        LibraryAPI.Authz.resolveTargetLibraryAccess(ctx, principal.id, principal, function(err, hasAccess, visibility) {
            if (err) {
                return callback(err);
            } else if (!hasAccess) {
                return callback({'code': 401, 'msg': 'You do not have have access to this library'});
            }

            // Get the folder ids from the library index
            FoldersFoldersLibrary.list(principal, visibility, {'start': start, 'limit': limit}, function(err, folderIds, nextToken) {
                if (err) {
                    return callback(err);
                }

                // Get the folder objects from the folderIds
                FoldersDAO.getFoldersByIds(folderIds, function(err, folders) {
                    if (err) {
                        return callback(err);
                    }

                    folders = _.map(folders, function(folder) {
                        return _augmentFolder(ctx, folder);
                    });

                    // Emit an event indicating that the folder library has been retrieved
                    FoldersAPI.emit(FoldersConstants.events.GET_FOLDERS_LIBRARY, ctx, principalId, visibility, start, limit, folders);

                    return callback(null, folders, nextToken);
                });
            });
        });
    });
};

/**
 * Get the folders that are managed by the current user
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Folder[]}       callback.folders        The folders which the current user can manage
 */
var getManagedFolders = module.exports.getManagedFolders = function(ctx, callback) {
    if (!ctx.user()) {
        return callback({'code': 401, 'msg': 'Anonymous users cannot manage folders'});
    }

    // Get all the groups this user is a member of
    AuthzAPI.getRolesForPrincipalAndResourceType(ctx.user().id, 'g', null, 1000, function(err, roles) {
        if (err) {
            return callback(err);
        }

        // Get all the groups the user manages
        var managedGroupIds = _.chain(roles)
            .filter(function(role) {
                return (role.role === AuthzConstants.role.MANAGER);
            })
            .map(function(role) {
                return role.id;
            })
            .value();

        // Get all the folders that match these groups
        FoldersDAO.getFoldersByGroupIds(managedGroupIds, function(err, folders) {
            if (err) {
                return callback(err);
            }

            folders = _.chain(folders)
                // Because we retrieved all the folders that this user manages
                // we sort them, so they can be displayed immediately
                .sort(function(a, b) {
                    return a.displayName.localeCompare(b.displayName);
                })

                // Augment the folder with the signed preview urls
                .map(function(folder) {
                    return _augmentFolder(ctx, folder);
                })
                .value();

            return callback(null, folders);
        });
    });
};

/**
 * Remove a folder from a principal's library
 *
 * @param  {Context}        ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}         principalId         The principal id of the library from which to remove this folder
 * @param  {String}         folderId            The id of the folder that should be removed
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 */
var removeFolderFromLibrary = module.exports.removeFolderFromLibrary = function(ctx, principalId, folderId, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You must be authenticated to remove a folder from a library'}).isLoggedInUser(ctx);
    validator.check(principalId, {'code': 400, 'msg': 'A user or group id must be provided'}).isPrincipalId();
    validator.check(folderId, {'code': 400, 'msg': 'A valid folder id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Make sure the folder exists
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Make sure the target user exists
        PrincipalsDAO.getPrincipal(principalId, function(err, principal) {
            if (err) {
                return callback(err);
            }

            // Verify the current user has access to remove folders from the target library
            AuthzPermissions.canRemoveRole(ctx, principal, folder, function(err, memberChangeInfo) {
                if (err) {
                    return callback(err);
                }

                // All validation checks have passed, finally persist the role change and update the library
                AuthzAPI.updateRoles(folder.groupId, memberChangeInfo.changes, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    FoldersAPI.emit(FoldersConstants.events.UPDATED_FOLDER_MEMBERS, ctx, folder, memberChangeInfo, {}, function(errs) {
                        if (errs) {
                            return callback(_.first(errs));
                        }

                        return callback();
                    });
                });
            });
        });
    });
};

/**
 * List the library of content items that have been added to a folder
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}         folderId                The id of the folder whose content library to list
 * @param  {String}         [start]                 A token that indicates where in the list to start returning content items. Use the `nextToken` result from this method to determine where to start the next page of content items
 * @param  {Number}         [limit]                 The maximum number of content items to return
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Folder[]}       callback.contentItems   The list of content items in the folder library
 * @param  {String}         callback.nextToken      The token to use for the next `start` value in order to get the next page of content items. If this value is `null`, it indicates that there are no more content items to page
 */
var getFolderContentLibrary = module.exports.getFolderContentLibrary = function(ctx, folderId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(folderId, {'code': 400, 'msg': 'A folder id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the folder
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Determine which library visibility the current user should receive
        LibraryAPI.Authz.resolveTargetLibraryAccess(ctx, folder.groupId, folder, function(err, hasAccess, visibility) {
            if (err) {
                return callback(err);
            } else if (!hasAccess) {
                return callback({'code': 401, 'msg': 'You do not have access to this folder'});
            }

            FoldersContentLibrary.list(folder, visibility, {'start': start, 'limit': limit}, function(err, contentIds, nextToken) {
                if (err) {
                    return callback(err);
                }

                ContentDAO.Content.getMultipleContentItems(contentIds, null, function(err, contentItems) {
                    if (err) {
                        return callback(err);
                    }

                    contentItems = _.chain(contentItems)
                        // Remove null content items. This can happen if libraries are in an inconsistent
                        // state. For example, if an item was deleted from the system but hasn't been removed
                        // from the libraries, a `null` value would be returned by `getMultipleContentItems`
                        .compact()

                        // Augment each content item with its signed preview urls
                        .each(function(contentItem) {
                            ContentUtil.augmentContent(ctx, contentItem);
                        })
                        .value();

                    return callback(null, contentItems, nextToken);
                });
            });
        });
    });
};


//////////////
// Comments //
//////////////

/**
 * Create a new message in a folder. If `replyToCreatedTimestamp` is specified, the message will be
 * a reply to the message in the folder identified by that timestamp.
 *
 * @param  {Context}            ctx                             Standard context object containing the current user and the current tenant
 * @param  {String}             folderId                        The id of the folder to which to post the message
 * @param  {String}             body                            The body of the message
 * @param  {String|Number}      [replyToCreatedTimestamp]       The timestamp of the message to which this message is a reply. Not specifying this will create a top level message
 * @param  {Function}           callback                        Standard callback function
 * @param  {Object}             callback.err                    An error that occurred, if any
 * @param  {Message}            callback.message                The created message
 */
var createMessage = module.exports.createMessage = function(ctx, folderId, body, replyToCreatedTimestamp, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can post to folders'}).isLoggedInUser(ctx);
    validator.check(folderId, {'code': 400, 'msg': 'Invalid folder id provided'}).isResourceId();
    validator.check(body, {'code': 400, 'msg': 'A message body must be provided'}).notEmpty();
    validator.check(body, {'code': 400, 'msg': 'A message body can only be 100000 characters long'}).isLongString();
    if (replyToCreatedTimestamp) {
        validator.check(replyToCreatedTimestamp, {'code': 400, 'msg': 'Invalid reply-to timestamp provided'}).isInt();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the folder from storage to use for permission checks
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Ensure the current user can view the folder
        AuthzPermissions.canInteract(ctx, folder, function(err) {
            if (err) {
                return callback(err);
            }

            // Create the message
            MessageBoxAPI.createMessage(folderId, ctx.user().id, body, {'replyToCreated': replyToCreatedTimestamp}, function(err, message) {
                if (err) {
                    return callback(err);
                }

                // Get a UI-appropriate representation of the current user
                PrincipalsUtil.getPrincipal(ctx, ctx.user().id, function(err, createdBy) {
                    if (err) {
                        return callback(err);
                    }

                    message.createdBy = createdBy;

                    // The message has been created in the database so we can emit the `createdComment` event
                    FoldersAPI.emit(FoldersConstants.events.CREATED_COMMENT, ctx, message, folder, function(errs) {
                        if (errs) {
                            return callback(_.first(errs));
                        }

                        return callback(null, message);
                    });
                });
            });
        });
    });
};

/**
 * Delete a message in a folder. Managers of the folder can delete all messages while people that have access
 * to the folder can only delete their own messages. Therefore, anonymous users will never be able to delete messages.
 *
 * @param  {Context}        ctx                         Standard context object containing the current user and the current tenant
 * @param  {String}         folderId                    The id of the folder from which to delete the message
 * @param  {Number}         messageCreatedDate          The timestamp of the message that should be deleted
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error that occurred, if any
 * @param  {Comment}        [callback.softDeleted]      When the message has been soft deleted (because it has replies), a stripped down message object representing the deleted message will be returned, with the `deleted` parameter set to `false`. If the message has been deleted from the index, no message object will be returned
 */
var deleteMessage = module.exports.deleteMessage = function(ctx, folderId, messageCreatedDate, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can delete messages'}).isLoggedInUser(ctx);
    validator.check(folderId, {'code': 400, 'msg': 'A folder id must be provided'}).isResourceId();
    validator.check(messageCreatedDate, {'code': 400, 'msg': 'A valid integer message created timestamp must be specified'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the folder from storage to use for permission checks
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Ensure that the message exists. We also need it so we can make sure we have access to delete it
        MessageBoxAPI.getMessages(folderId, [messageCreatedDate], {'scrubDeleted': false}, function(err, messages) {
            if (err) {
                return callback(err);
            } else if (!messages[0]) {
                return callback({'code': 404, 'msg': 'The specified message does not exist'});
            }

            var message = messages[0];

            // Determine if we have access to delete the folder message
            AuthzPermissions.canManageMessage(ctx, folder, message, function(err) {
                if (err) {
                    return callback(err);
                }

                // Delete the message using the "leaf" method, which will SOFT delete if the message has replies, or HARD delete if it does not
                MessageBoxAPI.deleteMessage(folderId, messageCreatedDate, {'deleteType': MessageBoxConstants.deleteTypes.LEAF}, function(err, deleteType, deletedMessage) {
                    if (err) {
                        return callback(err);
                    }

                    FoldersAPI.emit(FoldersConstants.events.DELETED_COMMENT, ctx, message, folder, deleteType);

                    // If a soft-delete occurred, we want to inform the consumer of the soft-delete message model
                    if (deleteType === MessageBoxConstants.deleteTypes.SOFT) {
                        return callback(null, deletedMessage);
                    } else {
                        return callback();
                    }
                });
            });
        });
    });
};


/**
 * Get the messages in a folder
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}         folderId                The id of the folder for which to get the messages
 * @param  {String}         [start]                 The `threadKey` of the message from which to start retrieving messages (exclusively). By default, will start fetching from the most recent message
 * @param  {Number}         [limit]                 The maximum number of results to return. Default: 10
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Message[]}      callback.messages       The messages in the folder. Of the type `MessageBoxModel#Message`
 * @param  {String}         callback.nextToken      The value to provide in the `start` parameter to get the next set of results
 */
var getMessages = module.exports.getMessages = function(ctx, folderId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(folderId, {'code': 400, 'msg': 'Must provide a valid folder id'}).isResourceId();
    validator.check(limit, {'code': 400, 'msg': 'Must provide a valid limit'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the folder from storage to use for permission checks
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Ensure the current user can view the folder
        AuthzPermissions.canView(ctx, folder, function(err) {
            if (err) {
                return callback(err);
            }

            // Fetch the messages from the message box
            MessageBoxAPI.getMessagesFromMessageBox(folderId, start, limit, null, function(err, messages, nextToken) {
                if (err) {
                    return callback(err);
                }

                // Get the unique user ids from the messages so we can retrieve their full user objects
                var userIds = _.chain(messages)
                    .map(function(message) {
                        return message.createdBy;
                    })
                    .uniq()
                    .compact()
                    .value();

                // Get the basic principal profiles of the messagers
                PrincipalsUtil.getPrincipals(ctx, userIds, function(err, users) {
                    if (err) {
                        return callback(err);
                    }

                    // Attach the user profiles to the message objects
                    _.each(messages, function(message) {
                        if (users[message.createdBy]) {
                            message.createdBy = users[message.createdBy];
                        }
                    });

                    return callback(err, messages, nextToken);
                });
            });
        });
    });
};

/**
 * Recursively add the given list of content items to the given folder. This method is
 * destructive to the `contentItems` parameter as it iterates
 *
 * @param  {Folder}         folder          The folder to which to add the content items
 * @param  {Content[]}      contentItems    The content items to add to the folder
 * @param  {Function}       callback        Standard callback function
 * @param  {Object}         callback.err    An error that occurred, if any
 * @api private
 */
var _addContentItemsToAuthzFolder = function(folder, contentItems, callback) {
    if (_.isEmpty(contentItems)) {
        return callback();
    }

    var roleChange = {};
    roleChange[folder.groupId] = AuthzConstants.role.VIEWER;

    var contentItem = contentItems.pop();
    AuthzAPI.updateRoles(contentItem.id, roleChange, function(err) {
        if (err) {
            return callback(err);
        }

        return _addContentItemsToAuthzFolder(folder, contentItems, callback);
    });
};

/**
 * Recursively remove the given list of content items from the given folder. This method is
 * destructive to the `contentIds` parameter as it iterates
 *
 * @param  {Folder}         folder          The folder from which to remove the content items
 * @param  {String[]}       contentIds      The ids of the content items to remove from the folder
 * @param  {Function}       callback        Standard callback function
 * @param  {Object}         callback.err    An error that occurred, if any
 * @api private
 */
var _removeContentItemsFromFolder = function(folder, contentIds, callback) {
    if (_.isEmpty(contentIds)) {
        return callback();
    }

    var roleChange = {};
    roleChange[folder.groupId] = false;

    var contentId = contentIds.pop();
    AuthzAPI.updateRoles(contentId, roleChange, function(err) {
        if (err) {
            return callback(err);
        }

        return _removeContentItemsFromFolder(folder, contentIds, callback);
    });
};


/**
 * Augment the folder object by signing the preview uris
 *
 * @param  {Context}    ctx         Standard context object containing the current user and the current tenant
 * @param  {Folder}     folder      The folder object to augment
 * @return {Folder}                 The augmented folder holding the signed urls
 * @api private
 */
var _augmentFolder = function(ctx, folder) {
    if (folder.previews && folder.previews.thumbnailUri) {
        folder.previews.thumbnailUrl = ContentUtil.getSignedDownloadUrl(ctx, folder.previews.thumbnailUri);
    }
    if (folder.previews && folder.previews.wideUri) {
        folder.previews.wideUrl = ContentUtil.getSignedDownloadUrl(ctx, folder.previews.wideUri);
    }
    return folder;
};
