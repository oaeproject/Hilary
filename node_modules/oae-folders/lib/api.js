/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var events = require('events');
var util = require('util');

var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzAPI = require('oae-authz');
var ContentAPI = require('oae-content');
var ContentConstants = require('oae-content/lib/constants').ContentConstants;
var ContentDAO = require('oae-content/lib/internal/dao');
var ContentUtil = require('oae-content/lib/internal/util');
var LibraryAPI = require('oae-library');
var log = require('oae-logger').logger('oae-folders-api');
var OaeUtil = require('oae-util/lib/util');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var PrincipalsUtil = require('oae-principals/lib/util');
var Signature = require('oae-util/lib/signature');
var Validator = require('oae-util/lib/validator').Validator;

var FoldersAuthz = require('./authz');
var FoldersFoldersLibrary = require('./internal/foldersLibrary');
var FoldersConfig = require('oae-config').config('oae-folders');
var FoldersConstants = require('./constants').FoldersConstants;
var FoldersContentLibrary = require('./internal/contentLibrary');
var FoldersDAO = require('./internal/dao');

// When updating folders in a principal folders library, update at most once every hour to
// avoid thrashing the libraries with updates and causing duplicates
var LIBRARY_UPDATE_THRESHOLD_SECONDS = 3600;

/*!
 * ### Events
 *
 * * `createdFolder(ctx, folder, members)`: A new folder was created
 * * `updatedFolder(ctx, oldFolder, newFolder)`: A folder was updated
 * * `deletedFolder(ctx, folder)`: A folder was deleted
 * * `updatedFolderMembers(ctx, folder, memberUpdates, newMemberIds, updatedMemberIds, removedMemberIds)`: The members of a folder have been updated
 * * `addedContentItems(ctx, folder, contentItems)`: One or more content item was added to a folder
 * * `removedContentItems(ctx, folder, contentIds)`: One or more content item was removed from a folder
 */
var FoldersAPI = module.exports = new events.EventEmitter();

/**
 * Create a folder
 *
 * @param  {Context}        ctx                     The context of the current request
 * @param  {String}         displayName             The display name of the folder
 * @param  {String}         [description]           The description of the folder. By default, a folder will have no description
 * @param  {String}         [visibility]            The visibility of the folder. One of `AuthzConstants.visibility`. This will default to a value configured for the tenant
 * @param  {Object}         [members]               An object whose keys are principal ids and values are the role they should have on the folder. By default only the creator of the folder will be a manager
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Folder}         callback.folder         The folder that was created
 */
var createFolder = module.exports.createFolder = function(ctx, displayName, description, visibility, members, callback) {
    visibility = visibility || FoldersConfig.getValue(ctx.tenant().alias, 'visibility', 'folder');
    members = members || {};

    var allVisibilities = _.values(AuthzConstants.visibility);

    // Verify basic properties
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Anonymous users cannot create a folder'}).isLoggedInUser(ctx);
    validator.check(displayName, {'code': 400, 'msg': 'Must provide a display name for the folder'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'A display name can be at most 1000 characters long'}).isShortString();
    if (description) {
        validator.check(description, {'code': 400, 'msg': 'A description can be at most 10000 characters long'}).isMediumString();
    }
    validator.check(visibility, {'code': 400, 'msg': 'An invalid folder visibility option has been provided. Must be one of: ' + allVisibilities.join(', ')}).isIn(allVisibilities);

    // Verify each memberId and role is valid
    _.each(members, function(role, memberId) {
        validator.check(memberId, {'code': 400, 'msg': util.format('The memberId "%s" is not a valid member id', memberId)}).isPrincipalId();
        validator.check(role, {'code': 400, 'msg': util.format('The role "%s" is not a valid member role for a folder', role)}).isIn(FoldersConstants.roles.ALL_PRIORITY);
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Reject the operation if it will violate tenant privacy boundaries
    var principalIds = _.keys(members);
    PrincipalsDAO.getPrincipals(principalIds, null, function(err, principals) {
        if (err) {
            return callback(err);
        } else if (_.keys(principals).length !== principalIds.length) {
            return callback({'code': 400, 'msg': 'One or more target members being granted access do not exist'});
        }

        principals = _.values(principals);
        AuthzAPI.canInteract(ctx, ctx.tenant().alias, principals, function(err, canInteract, illegalPrincipalIds) {
            if (err) {
                return callback(err);
            } else if (!_.isEmpty(illegalPrincipalIds)) {
                return callback({'code': 400, 'msg': 'One or more target members being granted access are not authorized to become members on this folder'});
            }

            // Persist the folder
            FoldersDAO.createFolder(ctx.user().id, displayName, description, visibility, function(err, folder) {
                if (err) {
                    return callback(err);
                }

                // Set the current user as a manager and apply the folder roles
                members[ctx.user().id] = FoldersConstants.roles.MANAGER;
                AuthzAPI.updateRoles(folder.groupId, members, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Insert the folder into the folders library of all the members
                    var principalIds = _.keys(members);
                    FoldersFoldersLibrary.insert(principalIds, folder, function(err) {
                        if (err) {
                            log(ctx).warn({
                                'err': err,
                                'principalIds': principalIds,
                                'folder': folder
                            }, 'An error occurred while inserting a created folder into member libraries');
                        }

                        FoldersAPI.emit(FoldersConstants.events.CREATED_FOLDER, ctx, folder, members);
                        return callback(null, folder);
                    });
                });
            });
        });
    });
};

/**
 * Update a folder's metadata
 *
 * @param  {Context}        ctx                             The context of the current request
 * @param  {String}         folderId                        The id of the folder to update
 * @param  {Object}         updates                         The updates that should be persisted on the folder
 * @param  {String}         [updates.displayName]           The new display name for the folder
 * @param  {String}         [updates.description]           The new description for the folder
 * @param  {String}         [updates.visibility]            The new visibility for the folder
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Folder}         callback.folder                 The updated folder
 */
var updateFolder = module.exports.updateFolder = function(ctx, folderId, updates, callback) {
    var allVisibilities = _.values(AuthzConstants.visibility);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Anonymous users cannot create a folder'}).isLoggedInUser(ctx);
    validator.check(folderId, {'code': 400, 'msg': util.format('The folder id "%s" is not a valid resource id', folderId)}).isResourceId();
    validator.check(updates, {'code': 400, 'msg': 'Missing update information'}).isObject(updates);

    // Ensure that at least one valid update field was provided
    var updateFields = _.keys(updates);
    var legalUpdateFields = ['displayName', 'description', 'visibility'];
    validator.check(_.intersection(updateFields, legalUpdateFields).length, {'code': 400, 'msg': 'One of ' + legalUpdateFields.join(', ') + ' must be provided'}).min(1);

    var profileFields = {};
    if (updates.displayName) {
        validator.check(updates.displayName, {'code': 400, 'msg': 'A display name can be at most 1000 characters long'}).isShortString();
        profileFields.displayName = updates.displayName;
    }
    if (updates.description) {
        validator.check(updates.description, {'code': 400, 'msg': 'A description can be at most 10000 characters long'}).isMediumString();
        profileFields.description = updates.description;
    }
    if (updates.visibility) {
        validator.check(updates.visibility, {'code': 400, 'msg': 'An invalid folder visibility option has been provided. Must be one of: ' + allVisibilities.join(', ')}).isIn(allVisibilities);
        profileFields.visibility = updates.visibility;
    }

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the folder from storage to use for permission checks
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Ensure the current user can manage the folder
        FoldersAuthz.canManageFolder(ctx, folder, function(err, canManage) {
            if (err) {
                return callback(err);
            } else if (!canManage) {
                return callback({'code': 401, 'msg': 'You are not authorized to manage this folder'});
            }

            // Update the folder's metadata
            FoldersDAO.updateFolder(folder, profileFields, function(err, updatedFolder) {
                if (err) {
                    return callback(err);
                }

                // Get the full folder profile for the updated folder
                _getFullFolderProfile(ctx, updatedFolder, function(err, fullFolder) {
                    if (err) {
                        return callback(err);
                    }

                    FoldersAPI.emit(FoldersConstants.events.UPDATED_FOLDER, ctx, folder, fullFolder);

                    return callback(null, fullFolder);
                });
            });
        });
    });
};

/**
 * Update the content items in a folder
 *
 * @param  {Context}        ctx                             The context of the current request
 * @param  {String}         folderId                        The id of the folder whose content items to update
 * @param  {String}         visibility                      The new visibility for the content items in the folder
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Content[]}      callback.failedContent          The content items that could not be updated
 */
var updateFolderContentVisibility = module.exports.updateFolderContentVisibility = function(ctx, folderId, visibility, callback) {
    var allVisibilities = _.values(AuthzConstants.visibility);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Anonymous users cannot update folders their visibility'}).isLoggedInUser(ctx);
    validator.check(folderId, {'code': 400, 'msg': util.format('The folder id "%s" is not a valid resource id', folderId)}).isResourceId();
    validator.check(visibility, {'code': 400, 'msg': 'Missing visibility value'}).notEmpty();
    validator.check(visibility, {'code': 400, 'msg': 'An invalid folder visibility option has been provided. Must be one of: ' + allVisibilities.join(', ')}).isIn(allVisibilities);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the folder from storage to use for permission checks
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Ensure the current user can manage the folder
        FoldersAuthz.canManageFolder(ctx, folder, function(err, canManage) {
            if (err) {
                return callback(err);
            } else if (!canManage) {
                return callback({'code': 401, 'msg': 'You are not authorized to manage this folder'});
            }

            // Apply the visibility on all the content items in the folder
            _applyVisibilityOnContentInFolder(ctx, folder, visibility, callback);
        });
    });
};

/**
 * Set the `newVisibility` visibility on all the content items in the folder. This function
 * assumes that the current user has manager rights on the given folder.
 *
 * Keep in mind that this is *NOT* a lightweight operation. The following actions will take place:
 *   -  The private folder library needs to be listed (to retrieve the content ids)
 *   -  All those content items need to be retrieved
 *   -  All those content items need to be updated
 *       -  Because each content item can have it own set of permissions, we need to check
 *          each content item at a time
 *       -  This means an authz check happens PER content item
 *   -  Each update triggers a search reindex of the content item
 *   -  Each update triggers a library purge of the folder
 *
 * @param  {Context}        ctx                         The context of the current request
 * @param  {Folder}         folder                      The folder whose content items need to be updated
 * @param  {String}         visibility                  The new visibility for the content items
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                Standard error object, if any
 * @param  {Content[]}      callback.failedContent      The content items that couldn't be updated
 * @api private
 */
var _applyVisibilityOnContentInFolder = function(ctx, folder, visibility, callback, _start, _failedContent) {
    _failedContent = _failedContent || [];

    // List all the items in the folder and try to change the visiblity. We can use
    // the `private` library as we assume a canManage check happened earlier
    FoldersContentLibrary.list(folder, 'private', {'start': _start, 'limit': 20}, function(err, contentIds, nextToken) {
        if (err) {
            // This is potentially problematic, we may have only updated half the folder's content items
            log().error({'err': err, 'folderId': folder.id}, 'Got an error when updating the visibility on content in a folder');
            return callback(err);
        }
        ContentDAO.Content.getMultipleContentItems(contentIds, null, function(err, contentItems) {
            if (err) {
                // This is potentially problematic, we may have only updated half the folder's content items
                log().error({'err': err, 'folderId': folder.id}, 'Got an error when updating the visibility on content in a folder');
                return callback(err);
            }

            // Grab those content items that don't have the desired visibility
            contentItems = _.filter(contentItems, function(content) {
                return (content.visibility !== visibility);
            });

            /*!
             * Gets executed once all the content items have been updated
             */
            var done = _.after(contentItems.length, function() {
                // If there is more content in this folder we go to the next page
                if (nextToken) {
                    _applyVisibilityOnContentInFolder(ctx, folder, visibility, callback, nextToken, _failedContent);

                // Otherwise we're done here
                } else {
                    return callback(null, _failedContent);
                }
            });

            // If there are no items to update, we can move on
            if (contentItems.length === 0) {
                return done();
            }

            // Try and update each content item
            _.each(contentItems, function(content) {
                ContentAPI.updateContentMetadata(ctx, content.id, {'visibility': visibility}, function(err) {
                    if (err) {
                        _failedContent.push(content);
                    }

                    return done();
                });
            });
        });
    });
};

/**
 * Get a folder by its id
 *
 * @param  {Context}        ctx                 The context of the current request
 * @param  {String}         folderId            The id of the folder to get
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Folder}         callback.folder     The folder identified by the given id
 */
var getFolder = module.exports.getFolder = function(ctx, folderId, callback) {
    var validator = new Validator();
    validator.check(folderId, {'code': 400, 'msg': util.format('The folder id "%s" is not a valid resource id', folderId)}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the folder from storage to use for permission checks
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Ensure the current user can view the folder
        FoldersAuthz.canViewFolderProfile(ctx, folder, function(err, canView) {
            if (err) {
                return callback(err);
            } else if (!canView) {
                return callback({'code': 401, 'msg': 'You are not authorized to view this folder'});
            }

            // Sign the folder previews (if any)
            folder = _augmentFolder(ctx, folder);

            // Return the folder to the user
            return callback(null, folder);
        });
    });
};

/**
 * Get the full folder profile, which includes additional information about the relation of the
 * current user to the folder
 *
 * @param  {Context}        ctx                             The context of the current request
 * @param  {String}         folderId                        The id of the folder whose full profile to get
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Folder}         callback.folder                 The basic profile of the folder, with some additional information provided
 * @param  {Boolean}        callback.folder.canManage       Whether or not the current user can manage the folder
 * @param  {Boolean}        callback.folder.canShare        Whether or not the current user can share the folder
 * @param  {Boolean}        callback.folder.canAddItem      Whether or not the current user can add a content item to the folder
 * @param  {User}           callback.folder.createdBy       The basic profile of the user who created the folder
 */
var getFullFolderProfile = module.exports.getFullFolderProfile = function(ctx, folderId, callback) {
    var validator = new Validator();
    validator.check(folderId, {'code': 400, 'msg': util.format('The folder id "%s" is not a valid resource id', folderId)}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the folder from storage to use for permissions checks
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        _getFullFolderProfile(ctx, folder, callback);
    });
};

/**
 * Given a folder augment it with the `creator` user object and whether the current user
 * can manage, share or add items.
 *
 * @param  {Context}        ctx                             The context of the current request
 * @param  {Folder}         folder                          The folder whose full profile to get
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Folder}         callback.folder                 The basic profile of the folder, with some additional information provided
 * @param  {Boolean}        callback.folder.canManage       Whether or not the current user can manage the folder
 * @param  {Boolean}        callback.folder.canShare        Whether or not the current user can share the folder
 * @param  {Boolean}        callback.folder.canAddItem      Whether or not the current user can add a content item to the folder
 * @param  {User}           callback.folder.createdBy       The basic profile of the user who created the folder
 * @api private
 */
var _getFullFolderProfile = function(ctx, folder, callback) {
    FoldersAuthz.resolveEffectiveFolderAccess(ctx, folder, function(err, canView, canManage, canShare, canAddItem) {
        if (err) {
            return callback(err);
        } else if (!canView) {
            return callback({'code': 401, 'msg': 'You are not authorized to view this folder'});
        }

        // Sign the folder previews (if any)
        folder = _augmentFolder(ctx, folder);

        folder.canManage = canManage;
        folder.canShare = canShare;
        folder.canAddItem = canAddItem;

        if (ctx.user()) {
            // Add a signature that can be used to subscribe to push notifications
            folder.signature = Signature.createExpiringResourceSignature(ctx, folder.id);
        }

        // Populate the creator of the folder
        PrincipalsUtil.getPrincipal(ctx, folder.createdBy, function(err, creator) {
            if (err) {
                log(ctx).warn({
                    'err': err,
                    'userId': folder.createdBy,
                    'folderId': folder.id
                }, 'An error occurred getting the creator of a folder. Proceeding with empty user for full profile');
            }

            if (creator) {
                folder.createdBy = creator;
            }

            return callback(null, folder);
        });
    });
};

/**
 * Delete a folder
 *
 * @param  {Context}        ctx                 The context of the current request
 * @param  {String}         folderId            The id of the folder to delete
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 */
var deleteFolder = module.exports.deleteFolder = function(ctx, folderId, callback) {
    var validator = new Validator();
    validator.check(folderId, {'code': 400, 'msg': 'A folder id must be provided'}).isResourceId();
    validator.check(null, {'code': 401, 'msg': 'You must be authenticated to delete a folder'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        FoldersAuthz.canManageFolder(ctx, folder, function(err, canManage) {
            if (err) {
                return callback(err);
            } else if (!canManage) {
                return callback({'code': 401, 'msg': 'You are not authorized to delete this folder'});
            }

            // Get all the member ids, we'll need them to remove the folder from the authz lists
            // and the principal libraries
            AuthzAPI.getAuthzMembers(folder.groupId, null, 10000, function(err, memberRoles, nextToken) {
                if (err) {
                    return callback(err);
                }

                var roleChanges = {};
                var memberIds = [];
                _.each(memberRoles, function(member) {
                    roleChanges[member.id] = false;
                    memberIds.push(member.id);
                });

                // Update the authz associations
                AuthzAPI.updateRoles(folder.groupId, roleChanges, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Remove it from the folder libraries
                    FoldersFoldersLibrary.remove(memberIds, folder, function(err) {
                        if (err) {
                            return callback(err);
                        }

                        // Remove the actual folder
                        FoldersDAO.deleteFolder(folder.id, function(err) {
                            if (err) {
                                return callback(err);
                            }

                            FoldersAPI.emit(FoldersConstants.events.DELETED_FOLDER, ctx, folder, memberIds);
                            return callback();
                        });
                    });
                });
            });
        });
    });
};

/**
 * List the members of a folder
 *
 * @param  {Context}        ctx                             The context of the current request
 * @param  {String}         folderId                        The id of the folder whose members to get
 * @param  {String}         [start]                         A token that indicates where in the list to start returning members. Use the `nextToken` result from this method to determine where to start the next page of members
 * @param  {Number}         [limit]                         The maximum number of members to return
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Object[]}       callback.results                An array of objects indicating the members of the folder and their roles
 * @param  {User|Group}     callback.results[i].profile     The basic profile of the user or group who is a member of the folder
 * @param  {String}         callback.results[i].role        The role of the user or group on the folder
 * @param  {String}         callback.nextToken              The token to use for the next `start` value in order to get the next page of members. If this value is `null`, it indicates that there are no more members to page
 */
var getFolderMembers = module.exports.getFolderMembers = function(ctx, folderId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(folderId, {'code': 400, 'msg': 'A folder id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getFolder(ctx, folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Get the discussion members
        AuthzAPI.getAuthzMembers(folder.groupId, start, limit, function(err, memberRoles, nextToken) {
            if (err) {
                return callback(err);
            }

            // Get the basic profiles for all of these principals
            PrincipalsUtil.getPrincipals(ctx, _.pluck(memberRoles, 'id'), function(err, memberProfiles) {
                if (err) {
                    return callback(err);
                }

                // Merge the member profiles and roles into a single object
                var memberList = _.map(memberRoles, function(memberRole) {
                    return {
                        'profile': memberProfiles[memberRole.id],
                        'role': memberRole.role
                    };
                });

                return callback(null, memberList, nextToken);
            });
        });
    });
};

/**
 * Share a folder with a set of users and groups. All users and groups who are shared the
 * folder will be given the `member` role. However, if they already have a different role, the
 * existing role will not be changed
 *
 * @param  {Context}    ctx             The context of the current request
 * @param  {String}     folderId        The id of the folder to share
 * @param  {String[]}   principalIds    The ids of the users and groups with whom to share the folder
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var shareFolder = module.exports.shareFolder = function(ctx, folderId, principalIds, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to share a folder'}).isLoggedInUser(ctx);
    validator.check(folderId, {'code': 400, 'msg': 'A valid folder id must be provided'}).isResourceId();
    validator.check(principalIds.length, {'code': 400, 'msg': 'The folder must at least be shared with 1 user or group'}).min(1);
    _.each(principalIds, function(principalId) {
        validator.check(principalId, {'code': 400, 'msg': 'The member id: ' + principalId + ' is not a valid member id'}).isPrincipalId();
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure the folder exists
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Build what the membership updates would be
        var roleChanges = {};
        _.each(principalIds, function(principalId) {
            roleChanges[principalId] = FoldersConstants.roles.VIEWER;
        });

        // Determine which members are actually newly added to this folder. We can only add those
        AuthzAPI.computeMemberRolesAfterChanges(folder.groupId, roleChanges, function(err, membershipAfterChanges, newMemberIds) {
            if (err) {
                return callback(err);
            } else if (_.isEmpty(newMemberIds)) {
                // If there are no new members being added from this share, we can just
                // short-circuit the process
                return callback();
            }

            // Validate role and tenant boundary permissions for the current user to share the folder with the target users
            var allMemberIdsBeforeShare = _.chain(membershipAfterChanges).keys().difference(newMemberIds).value();
            FoldersAuthz.canShareFolder(ctx, folder, newMemberIds, function(err, canShare, illegalPrincipalIds) {
                if (err) {
                    return callback(err);
                } else if (!_.isEmpty(illegalPrincipalIds)) {
                    return callback({'code': 400, 'msg': 'One or more target members are not authorized to become members on this folder'});
                } else if (!canShare) {
                    return callback({'code': 401, 'msg': 'You are not authorized to share this folder'});
                }

                // Apply the permissions update
                AuthzAPI.updateRoles(folder.groupId, roleChanges, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Update the libraries that contain this folder, but only if we have not already updated it within the threshold. We provide `null` as the old last modified
                    // timestamp to trigger the update function to update the folder timestamp for us
                    OaeUtil.invokeIfNecessary(_testLibraryUpdateThreshold(folder), FoldersFoldersLibrary.update, allMemberIdsBeforeShare, folder, null, function(err, updatedFolder) {
                        if (err) {
                            log(ctx).warn({
                                'err': err,
                                'folderId': folder.id,
                                'numberOfPrincipalIds': allMemberIdsBeforeShare.length
                            }, 'An error occurred while updating folder in member folder libraries after being shared');
                        }

                        // If the folder was updated for user libraries
                        folder = updatedFolder || folder;

                        // Insert the folder into the user libraries that we just shared with
                        FoldersFoldersLibrary.insert(newMemberIds, folder, function(err) {
                            if (err) {
                                log(ctx).warn({
                                    'err': err,
                                    'folderId': folder.id,
                                    'principalIds': newMemberIds
                                }, 'An error occurred while inserting a folder to in member folder libraries after being shared');
                            }

                            FoldersAPI.emit(FoldersConstants.events.UPDATED_FOLDER_MEMBERS, ctx, folder, roleChanges, newMemberIds);
                            return callback();
                        });
                    });
                });
            });
        });
    });
};

/**
 * Set permissions to the folder. This is similar to sharing a folder, however rather than
 * only giving users and groups the `member` role, other roles can be applied and also users and
 * groups can be removed from the folder membership
 *
 * @param  {Context}    ctx                 The context of the current request
 * @param  {String}     folderId            The id of the folder whose permissions to set
 * @param  {Object}     permissionChanges   An object whose key is the user or group id to set on the folder, and the value is the role you wish them to have. If the role of a user is set to `false`, then it indicates to remove the user from the folder
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 */
var setFolderPermissions = module.exports.setFolderPermissions = function(ctx, folderId, permissionChanges, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to change folder permissions'}).isLoggedInUser(ctx);
    validator.check(folderId, {'code': 400, 'msg': 'A valid folder id must be provided'}).isResourceId();
    validator.check(null, {'code': 400, 'msg': 'Must specify at least one permission change to apply'}).isObject(permissionChanges);
    validator.check(_.keys(permissionChanges).length, {'code': 400, 'msg': 'You must specify at least one permission change'}).min(1);
    _.each(permissionChanges, function(role, principalId) {
        validator.check(principalId, {'code': 400, 'msg': 'The member id: ' + principalId + ' is not a valid member id'}).isPrincipalId();
        validator.check(role, {'code': 400, 'msg': 'The role change: ' + role + ' is not a valid value. Must either be a string, or false'}).isValidRoleChange();
        if (role) {
            validator.check(role, {'code': 400, 'msg': 'The role :' + role + ' is not a valid value. Must be one of: ' + FoldersConstants.roles.ALL_PRIORITY.join(', ') + '; or false'}).isIn(FoldersConstants.roles.ALL_PRIORITY);
        }
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the folder object, throwing an error if it doesn't exist, but not applying permissions checks
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Ensure we are allowed to add the new members
        AuthzAPI.computeMemberRolesAfterChanges(folder.groupId, permissionChanges, function(err, membershipAfterChanges, newMemberIds, updatedMemberIds, removedMemberIds) {
            if (err) {
                return callback(err);
            }

            // Ensure the user is allowed to set the folder permissions
            FoldersAuthz.canSetFolderPermissions(ctx, folder, newMemberIds, function(err, canSetPermissions, illegalMemberIds) {
                if (err && err.code === 404) {
                    return callback({'code': 400, 'msg': 'One or more target members being granted access do not exist'});
                } else if (err) {
                    return callback(err);
                } else if (illegalMemberIds) {
                    // Ensures we don't violate tenant privacy boundaries
                    return callback({'code': 400, 'msg': 'One or more target members being granted access are not authorized to become members on this folder'});
                } else if (!canSetPermissions) {
                    // Ensures we have access to the folder
                    return callback({'code': 401, 'msg': 'You are not authorized to update the permissions of this folder'});
                } else if (!_.contains(_.values(membershipAfterChanges), FoldersConstants.roles.MANAGER)) {
                    // If the anticipated membership after these changes has no manager, bail out
                    return callback({'code': 400, 'msg': 'The requested change results in a folder with no managers'});
                }

                // All validation checks have passed, finally persist the role change and update the user libraries
                AuthzAPI.updateRoles(folder.groupId, permissionChanges, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Insert the folder into the libraries of new members
                    FoldersFoldersLibrary.insert(newMemberIds, folder, function(err) {
                        if (err) {
                            log(ctx).warn({
                                'err': err,
                                'folderId': folder.id,
                                'principalIds': newMemberIds
                            }, 'An error occurred while adding folder to member libraries after role assignment');
                        }

                        // Remove the folder from the libraries of removed members
                        FoldersFoldersLibrary.remove(removedMemberIds, folder, function(err) {
                            if (err) {
                                log(ctx).warn({
                                    'err': err,
                                    'folderId': folder.id,
                                    'principalIds': removedMemberIds
                                }, 'An error occurred while removing folder from member libraries after role removal');
                            }

                            // TODO: Test timestamp doesn't update with subsequent set-permissions
                            // For all current members, update the folder in their libraries. This includes
                            // members that were just added which is a bit of a waste, but easier to code
                            var updateMemberIds = _.keys(membershipAfterChanges);
                            OaeUtil.invokeIfNecessary(_testLibraryUpdateThreshold(folder), FoldersFoldersLibrary.update, updateMemberIds, folder, null, function(err) {
                                if (err) {
                                    log(ctx).warn({
                                        'err': err,
                                        'folderId': folder.id,
                                        'principalIds': updateMemberIds
                                    }, 'An error occurred while updating folder in member libraries after having permissions updated');
                                }

                                FoldersAPI.emit(FoldersConstants.events.UPDATED_FOLDER_MEMBERS, ctx, folder, _.pick(permissionChanges, updatedMemberIds), newMemberIds, updatedMemberIds, removedMemberIds);
                                return callback();
                            });
                        });
                    });
                });
            });
        });
    });
};

/**
 * Add a set of content items to a folder
 *
 * @param  {Context}    ctx             The context of the current request
 * @param  {String}     folderId        The id of the folder to which to add the content items
 * @param  {String[]}   contentIds      The ids of the content items to add to the folder
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var addContentItemsToFolder = module.exports.addContentItemsToFolder = function(ctx, folderId, contentIds, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be authenticated to be able to add an item to a folder'}).isLoggedInUser(ctx);
    validator.check(folderId, {'code': 400, 'msg': 'A valid folder id must be provided'}).isResourceId();
    validator.check(null, {'code': 400, 'msg': 'Must specify at least one content item to add'}).isArray(contentIds);
    validator.check(_.values(contentIds).length, {'code': 400, 'msg': 'You must specify at least one content item to add'}).min(1);

    // Ensure each content id is valid
    _.each(contentIds, function(contentId) {
        validator.check(contentId, {'code': 400, 'msg': util.format('The id "%s" is not a valid content id', contentId)}).isResourceId();
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the folder to which we're trying to add the content items
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Get the content profiles of all items being added for permission checks
        ContentDAO.Content.getMultipleContentItems(contentIds, null, function(err, contentItems) {
            if (err) {
                return callback(err);
            }

            // Determine if the content items can be added to the folder
            FoldersAuthz.canAddItemsToFolder(ctx, folder, contentItems, function(err, canAddItem, illegalContentIds) {
                if (err) {
                    return callback(err);
                } else if (!canAddItem && illegalContentIds) {
                    return callback({'code': 400, 'msg': util.format('You are not authorized to add the following items to the folder: %s', illegalContentIds.join(', '))});
                } else if (!canAddItem) {
                    return callback({'code': 401, 'msg': 'You are not authorized to add items to this folder'});
                }

                // Add all the items to the folder
                _addContentItemsToFolder(folder, contentItems.slice(), function(err) {
                    if (err) {
                        return callback(err);
                    }

                    FoldersContentLibrary.insert(folder, contentItems, function(err) {
                        if (err) {
                            log(ctx).warn({
                                'err': err,
                                'folderId': folder.id,
                                'contentIds': _.pluck(contentItems, 'id')
                            }, 'An error occurred while inserting content items into a folder library');
                        }

                        FoldersAPI.emit(FoldersConstants.events.ADDED_CONTENT_ITEMS, ctx, folder, contentItems);
                        return callback();
                    });
                });
            });
        });
    });
};

/**
 * Remove a set of content items from a folder
 *
 * @param  {Context}    ctx             The context of the current request
 * @param  {String}     folderId        The id of the folder from which to remove the content items
 * @param  {String[]}   contentIds      The ids of the content items to remove from the folder
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var removeContentItemsFromFolder = module.exports.removeContentItemsFromFolder = function(ctx, folderId, contentIds, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be authenticated to be able to remove an item from a folder'}).isLoggedInUser(ctx);
    validator.check(folderId, {'code': 400, 'msg': 'A valid folder id must be provided'}).isResourceId();
    validator.check(null, {'code': 400, 'msg': 'You must specify at least one content item to remove'}).isArray(contentIds);
    validator.check(_.values(contentIds).length, {'code': 400, 'msg': 'You must specify at least one content item to remove'}).min(1);

    // Ensure each content id is valid
    _.each(contentIds, function(contentId) {
        validator.check(contentId, {'code': 400, 'msg': util.format('The id "%s" is not a valid content id', contentId)}).isResourceId();
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the folder from which we're trying to remove the content items
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Get the content profiles of all items being removed
        ContentDAO.Content.getMultipleContentItems(contentIds, null, function(err, contentItems) {
            if (err) {
                return callback(err);
            }

            // Ensure that the user is allowed to remove items from this folder
            FoldersAuthz.canRemoveItemsFromFolder(ctx, folder, function(err, canRemoveItems) {
                if (err) {
                    return callback(err);
                } else if (!canRemoveItems) {
                    return callback({'code': 401, 'msg': 'You are not authorized to remove items from this folder'});
                }

                // Remove all the items from the folder
                _removeContentItemsFromFolder(folder, contentIds.slice(), function(err) {
                    if (err) {
                        return callback(err);
                    }

                    FoldersContentLibrary.remove(folder, contentItems, function(err) {
                        if (err) {
                            log(ctx).warn({
                                'err': err,
                                'folderId': folder.id,
                                'contentIds': contentIds
                            }, 'An error occurred while removing content items from a folder library');
                        }

                        FoldersAPI.emit(FoldersConstants.events.REMOVED_CONTENT_ITEMS, ctx, folder, contentItems);
                        return callback();
                    });
                });
            });
        });
    });
};

/**
 * List a user or group library of folders
 *
 * @param  {Context}        ctx                     The context of the current request
 * @param  {String}         principalId             The id of the user or group whose library of folders to list
 * @param  {String}         [start]                 A token that indicates where in the list to start returning folders. Use the `nextToken` result from this method to determine where to start the next page of folders
 * @param  {Number}         [limit]                 The maximum number of folders to return
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Folder[]}       callback.folders        The list of folders
 * @param  {String}         callback.nextToken      The token to use for the next `start` value in order to get the next page of folders. If this value is `null`, it indicates that there are no more folders to page
 */
var getFoldersLibrary = module.exports.getFoldersLibrary = function(ctx, principalId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'A user or group id must be provided'}).isPrincipalId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the principal
    PrincipalsDAO.getPrincipal(principalId, function(err, principal) {
        if (err) {
            return callback(err);
        }

        // Determine which library visibility the current user should receive
        LibraryAPI.Authz.resolveTargetLibraryAccess(ctx, principal.id, principal.visibility, function(err, hasAccess, visibility) {
            if (err) {
                return callback(err);
            } else if (!hasAccess) {
                return callback({'code': 401, 'msg': 'You do not have have access to this library'});
            }

            // Get the folder ids from the library index
            FoldersFoldersLibrary.list(principal, visibility, {'start': start, 'limit': limit}, function(err, folderIds, nextToken) {
                if (err) {
                    return callback(err);
                }

                // Get the folder objects from the folderIds
                FoldersDAO.getFoldersByIds(folderIds, function(err, folders) {
                    if (err) {
                        return callback(err);
                    }

                    folders = _.map(folders, function(folder) {
                        return _augmentFolder(ctx, folder);
                    });

                    return callback(null, folders, nextToken);
                });
            });
        });
    });
};

/**
 * Get the folders that are managed by the current user
 *
 * @param  {Context}        ctx                     The context of the current request
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error object, if any
 * @param  {Folder[]}       callback.folders        The folders which the current user can manage
 */
var getManagedFolders = module.exports.getManagedFolders = function(ctx, callback) {
    if (!ctx.user()) {
        return callback({'code': 401, 'msg': 'Anonymous users cannot manage folders'});
    }

    // Get all the groups this user is a member of
    AuthzAPI.getRolesForPrincipalAndResourceType(ctx.user().id, 'g', null, 1000, function(err, roles) {
        if (err) {
            return callback(err);
        }

        // Get all the groups the user manages
        var managedGroupIds = _.chain(roles)
            .filter(function(role) {
                return (role.role === FoldersConstants.roles.MANAGER);
            })
            .map(function(role) {
                return role.id;
            })
            .value();

        // Get all the folders that match these groups
        FoldersDAO.getFoldersByGroupIds(managedGroupIds, function(err, folders) {
            if (err) {
                return callback(err);
            }

            folders = _.chain(folders)
                // Because we retrieved all the folders that this user manages
                // we sort them, so they can be displayed immediately
                .sort(function(a, b) {
                    return a.displayName.localeCompare(b.displayName);
                })

                // Augment the folder with the signed preview urls
                .map(function(folder) {
                    return _augmentFolder(ctx, folder);
                })
                .value();

            return callback(null, folders);
        });
    });
};

/**
 * Remove a folder from a principal's library
 *
 * @param  {Context}        ctx                 The context of the current request
 * @param  {String}         libraryOwnerId      The id of the principal who owns the library from which the folder should be removed
 * @param  {String}         folderId            The id of the folder that should be removed
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 */
var removeFolderFromLibrary = module.exports.removeFolderFromLibrary = function(ctx, libraryOwnerId, folderId, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You must be authenticated to remove a folder from a library'}).isLoggedInUser(ctx);
    validator.check(libraryOwnerId, {'code': 400, 'msg': 'A user or group id must be provided'}).isPrincipalId();
    validator.check(folderId, {'code': 400, 'msg': 'A valid folder id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Make sure the folder exists
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Verify the current user has access to remove folders from the target library
        LibraryAPI.Authz.canRemoveFromLibrary(ctx, libraryOwnerId, function(err, canRemove) {
            if (err) {
                return callback(err);
            } else if (!canRemove) {
                return callback({'code': 401, 'msg': 'You are not authorized to delete a folder from this library'});
            }

            var permissionChanges = {};
            permissionChanges[libraryOwnerId] = false;

            // Ensure we are actually removing something, and that we'll be left with at least one manager afterward
            AuthzAPI.computeMemberRolesAfterChanges(folder.groupId, permissionChanges, function(err, membershipAfterChanges, newMemberIds, updatedMemberIds, removedMemberIds) {
                if (err) {
                    return callback(err);
                } else if (!_.chain(membershipAfterChanges).values().contains(FoldersConstants.roles.MANAGER).value()) {
                    // If the anticipated membership after these changes has no manager, bail out
                    return callback({'code': 400, 'msg': 'The requested change results in a folder with no managers'});
                } else if (_.isEmpty(removedMemberIds)) {
                    return callback({'code': 400, 'msg': 'The specified folder is not in this library'});
                }

                // All validation checks have passed, finally persist the role change and update the library
                AuthzAPI.updateRoles(folder.groupId, permissionChanges, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    FoldersFoldersLibrary.remove([libraryOwnerId], folder, function(err) {
                        if (err) {
                            log().error({
                                'err': err,
                                'principalIds': [libraryOwnerId],
                                'folderId': folderId
                            }, 'Error removing folder from principal libraries');
                            return callback(err);
                        }

                        FoldersAPI.emit(FoldersConstants.events.UPDATED_FOLDER_MEMBERS, ctx, folder, permissionChanges, []);
                        return callback();
                    });
                });
            });
        });
    });
};

/**
 * List the library of content items that have been added to a folder
 *
 * @param  {Context}        ctx                     The context of the current request
 * @param  {String}         folderId                The id of the folder whose content library to list
 * @param  {String}         [start]                 A token that indicates where in the list to start returning content items. Use the `nextToken` result from this method to determine where to start the next page of content items
 * @param  {Number}         [limit]                 The maximum number of content items to return
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Folder[]}       callback.contentItems   The list of content items in the folder library
 * @param  {String}         callback.nextToken      The token to use for the next `start` value in order to get the next page of content items. If this value is `null`, it indicates that there are no more content items to page
 */
var getFolderContentLibrary = module.exports.getFolderContentLibrary = function(ctx, folderId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(folderId, {'code': 400, 'msg': 'A folder id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the folder
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        // Determine which library visibility the current user should receive
        LibraryAPI.Authz.resolveTargetLibraryAccess(ctx, folder.groupId, folder.visibility, function(err, hasAccess, visibility) {
            if (err) {
                return callback(err);
            } else if (!hasAccess) {
                return callback({'code': 401, 'msg': 'You do not have access to this folder'});
            }

            FoldersContentLibrary.list(folder, visibility, {'start': start, 'limit': limit}, function(err, contentIds, nextToken) {
                if (err) {
                    return callback(err);
                }

                ContentDAO.Content.getMultipleContentItems(contentIds, null, function(err, contentItems) {
                    if (err) {
                        return callback(err);
                    }

                    contentItems = _.chain(contentItems)
                        // Remove null content items. This can happen if an item was deleted from
                        // the system but hasn't been removed from the libraries
                        .compact()

                        // Augment each content item with its signed preview urls
                        .each(function(contentItem) {
                            ContentUtil.augmentContent(ctx, contentItem);
                        })
                        .value();

                    return callback(null, contentItems, nextToken);
                });
            });
        });
    });
};

/**
 * Recursively add the given list of content items to the given folder. This method is
 * destructive to the `contentItems` parameter as it iterates
 *
 * @param  {Folder}         folder          The folder to which to add the content items
 * @param  {Content[]}      contentItems    The content items to add to the folder
 * @param  {Function}       callback        Standard callback function
 * @param  {Object}         callback.err    An error that occurred, if any
 * @api private
 */
var _addContentItemsToFolder = function(folder, contentItems, callback) {
    if (_.isEmpty(contentItems)) {
        return callback();
    }

    var roleChange = {};
    roleChange[folder.groupId] = ContentConstants.roles.VIEWER;

    var contentItem = contentItems.pop();
    AuthzAPI.updateRoles(contentItem.id, roleChange, function(err) {
        if (err) {
            return callback(err);
        }

        return _addContentItemsToFolder(folder, contentItems, callback);
    });
};

/**
 * Recursively remove the given list of content items from the given folder. This method is
 * destructive to the `contentIds` parameter as it iterates
 *
 * @param  {Folder}         folder          The folder from which to tmove the content items
 * @param  {String[]}       contentIds      The ids of the content items to remove from the folder
 * @param  {Function}       callback        Standard callback function
 * @param  {Object}         callback.err    An error that occurred, if any
 * @api private
 */
var _removeContentItemsFromFolder = function(folder, contentIds, callback) {
    if (_.isEmpty(contentIds)) {
        return callback();
    }

    var roleChange = {};
    roleChange[folder.groupId] = false;

    var contentId = contentIds.pop();
    AuthzAPI.updateRoles(contentId, roleChange, function(err) {
        if (err) {
            return callback(err);
        }

        return _removeContentItemsFromFolder(folder, contentIds, callback);
    });
};

/**
 * Given a folder, determine if sufficient time has passed since it's last update to re-order it
 * once again in user and group principal libraries
 *
 * @param  {Folder}     folder      The folder whose last modified date to test
 * @return {Boolean}                `true` if the folder can be updated in user and group libraries
 * @api private
 */
var _testLibraryUpdateThreshold = function(folder) {
    return (!folder.lastModified || (Date.now() - folder.lastModified) > (LIBRARY_UPDATE_THRESHOLD_SECONDS * 1000));
};

/**
 * Augments the folder object by signing the preview uris
 *
 * @param  {Context}    ctx         The context of the current request
 * @param  {Folder}     folder      The folder object to augment
 * @return {Folder}                 The augmented folder holding the signed urls
 * @api private
 */
var _augmentFolder = function(ctx, folder) {
    if (folder.previews && folder.previews.thumbnailUri) {
        folder.previews.thumbnailUrl = ContentUtil.getSignedDownloadUrl(ctx, folder.previews.thumbnailUri);
    }
    if (folder.previews && folder.previews.wideUri) {
        folder.previews.wideUrl = ContentUtil.getSignedDownloadUrl(ctx, folder.previews.wideUri);
    }
    return folder;
};
