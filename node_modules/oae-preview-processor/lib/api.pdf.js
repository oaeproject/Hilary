/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var clone = require('clone');
var exec = require('child_process').exec;
var fs = require('fs');
var Path = require('path');
var util = require('util');

var log = require('oae-logger').logger('oae-preview-processor');
var ImageUtil = require('oae-util/lib/image');
var IO = require('oae-util/lib/io');

var PreviewConstants = require('./constants');
var PreviewImages = require('./api.images');

var _pdftkBinary = null;
var _timeout = 120000;

/**
 * Inits the Office parser.
 * This method will check if the Libre Office binary can be executed.
 *
 * @param  {Object} config                          The main config object.
 * @param  {Object} config.previews                 The namespace for all preview related configuration.
 * @param  {Object} config.previews.pdf             The namespace for all PDF related configuration.
 * @param  {String} config.previews.pdf.binary      The path to the `pdftk` executable. This should either be a direct path or the filename that's on the `PATH` environment.
 * @param  {Number} config.previews.pdf.timeout     Specifies the time (in ms) when the process is considered to be hanging and should be killed. (Default: 120000ms)
 */
var init = module.exports.init = function(config, callback) {
    if (config && config.previews && config.previews.pdf) {
        if (config.previews.pdf.binary) {
            _pdftkBinary = config.previews.pdf.binary;
        }
        if (config.previews.pdf.timeout) {
            _timeout = config.previews.pdf.timeout;
        }
    }

    // Try to execute `pdftk --help`.
    var cmd = util.format('%s --help', _pdftkBinary);
    log().trace('Executing %s to verify if the path to the pdftk binary is configured correctly.', cmd);
    exec(cmd, { 'timeout': 10000 }, function (err, stdout, stderr) {
        if (err) {
            log().error({'err': err, 'stdout': stdout, 'stderr': stderr}, 'Could not properly execute the pdftk binary.');
            return callback({'code': 500, 'msg': 'The path for the pdftk binary is misconfigured.'});
        }
        callback();
    });
};

/**
 * Generates previews for a PDF file.
 * This method will download the file first and then generate previews for the PDF file.
 *
 * @param {PreviewContext}      ctx             The preview context associated to this file.
 * @param {Function}            callback        Standard callback method.
 * @param {Object}              callback.err    Standard error object (if any.)
 */
var generatePreviews = module.exports.generatePreviews = function(ctx, callback) {
    // Download the file.
    ctx.download(function(err, path) {
        if (err) {
            return callback(err);
        }

        // generate the previews for it.
        previewPDF(ctx, path, callback);
    });
};

/**
 * Generates previews for a PDF file.
 * Three images will be generated for each page.
 *
 * @param {PreviewContext}      ctx             The preview context associated to this file.
 * @param {String}              path            The path where the PDF file is stored.
 * @param {Function}            callback        Standard callback method.
 * @param {Object}              callback.err    Standard error object (if any.)
 */
var previewPDF = module.exports.previewPDF = function(ctx, path, callback) {
    // Create a directory where we can store the files.
    var pagesDir = ctx.baseDir + '/pages';
    fs.mkdir(pagesDir, function(err) {
        if (err) {
            log().error({'err': err, 'contentId': ctx.contentId}, 'Could not create a directory %s to store the pages in.', pagesDir);
            return callback({'code': 500, 'msg': 'Could not create a directory to store the splitted pages in.'});
        }

        // Split the PDF pages.
        _splitPDF(ctx, path, pagesDir, function(err, pageFilenames) {
            if (err) {
                return callback(err);
            }

            // The amount of pages should be stored as metadata.
            ctx.addMetadata('pageCount', pageFilenames.length);

            // Convert each page into 3 images.
            var previewedPages = 0;
            var called = false;

            /*!
             * Resizes each page we retrieved from the PDF splitter.
             * Rather than simply iterating over the `pageFilenames` array, we recursively go trough the array
             * as doing (n pages) * (3 images per page) would be too cpu intensive otherwise.
             */
            var resize = function() {
                var page = pageFilenames.shift();

                // The absolute path where the pdf page is stored.
                var pagePath = pagesDir + '/' + page;

                // Remove the 'pdf' extension.
                var name = page.substr(0, page.length - 3);

                // Convert the PDF to a PNG.
                // It can be used as page.x.large.png
                var pngPath = pagePath.substr(0, pagePath.length - 3) + 'large.png';
                _convertToPNG(ctx, pagePath, pngPath, PreviewConstants.SIZES.PDF.LARGE, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    ctx.addPreview(pngPath, 'large');

                    // Downscale the large image to a normal sized version.
                    // We can't use 'medium' here as the documentviewer requires 'normal' as part of the filename.
                    var normalPagePath =  pagesDir + '/' + name + 'normal.png';
                    _downScale(ctx, pngPath, normalPagePath, PreviewConstants.SIZES.PDF.NORMAL, function(err) {
                        if (err) {
                            return callback(err);
                        }
                        ctx.addPreview(normalPagePath, 'normal');

                        // Downscale the normal sized one to a thumbnail.
                        var smallPagePath =  pagesDir + '/' + name + 'small.png';
                        _downScale(ctx, pngPath, smallPagePath, PreviewConstants.SIZES.PDF.SMALL, function(err) {
                            if (err) {
                                return callback(err);
                            }
                            ctx.addPreview(smallPagePath, 'small');

                            // We're done with this page.
                            previewedPages++;
                            if (pageFilenames.length === 0 || previewedPages === 250) {
                                // If the queue is empty, we've resized everything
                                // or if we've resized 250 pages we're done.
                                // Crop the page.1.small.png for the thumbnail image.
                                var pageOneSmallPath = pagesDir + '/page.1.small.png';
                                PreviewImages.cropThumbnail(ctx, pageOneSmallPath, callback);
                            } else {
                                resize();
                            }
                        });
                    });
                });
            };

            // Start resizing.
            resize();
        });
    });
};

/**
 * Splits one PDF file into a PDF file per page.
 * ie: If a PDF file has 5 pages in it, this method will generate 5 pdf files in a directory.
 * The files will be named 'page.i.pdf'.
 *
 * @param {PreviewContext}      ctx             The preview context associated to this file.
 * @param {String}              path            The path where the PDF file is stored.
 * @param {String}              pagesDir        The directory where the pages can be stored in.
 * @param {Function}            callback        Standard callback method.
 * @param {Object}              callback.err    Standard error object (if any.)
 * @param {String[]}            callback.files  An array of file names that were generated and stored in `pagesDir`.
 * @api private
 */
var _splitPDF = function(ctx, path, pagesDir, callback) {
    var cmd = util.format('%s "%s" burst output %s/page.%d.pdf', _pdftkBinary, path, pagesDir);
     // Execute the command.
    log().trace({'contentId': ctx.contentId}, 'Executing %s', cmd);
    var child = exec(cmd, { 'timeout': _timeout }, function (err, stdout, stderr) {
        if (err) {
            log().error({'err': err, 'contentId': ctx.contentId, 'stdout': stdout, 'stderr': stderr}, 'Could not split the PDF.');
            return callback({'code': 500, 'msg': 'Could not split the PDF file.'});
        }

        // Splitting was succesful, get a list of files we generated.
        fs.readdir(pagesDir, function(err, files) {
            if (err) {
                log().error({'err': err, 'contentId': ctx.contentId}, 'Could not read the %s directory to list the files', pagesDir);
                return callback({'code': 500, 'msg': 'Could not read the directory'});
            }
            callback(null, files);
        });
    });
};

/**
 * Convert a PDF page to a PNG file.
 * The outputted PNG file will have a width of 1000px.
 *
 * @param {PreviewContext}      ctx             The preview context associated to this file.
 * @param {String}              input           The PDF file to convert.
 * @param {String}              output          The path where the PNG file should be written
 * @param {Number}              width           The desired width of the PNG file.
 * @param {Function}            callback        Standard callback method.
 * @param {Object}              callback.err    Standard error object (if any.)
 * @api private
 */
var _convertToPNG = function(ctx, input, output, width, callback) {
    var cmd = util.format('OMP_NUM_THREADS=2 gm convert +adjoin -define pdf:use-cropbox=true -density 150 -resize %s -quality 100 "%s" "%s"', width, input, output);
     // Execute the command.
    log().trace({'contentId': ctx.contentId}, 'Executing %s', cmd);
    var child = exec(cmd, { 'timeout': _timeout }, function (err, stdout, stderr) {
        if (err) {
            log().error({'err': err, 'contentId': ctx.contentId, 'stdout': stdout, 'stderr': stderr}, 'Could not convert a PDF page to a PNG.');
            return callback({'code': 500, 'msg': 'Could not convert a PDF page to a PNG.'});
        }

        return callback(null);
    });
};

/**
 * Scale an image down a to a smaller image.
 *
 * @param {PreviewContext}      ctx             The preview context associated to this file.
 * @param {String}              input           The image to scale down.
 * @param {String}              outputdir       The directory to store the scaled down image
 * @param {String}              desiredFilename The desired filename for the new smaller image.
 * @param {String}              width           The width in pixels of the desired size.
 * @param {Function}            callback        Standard callback method.
 * @param {Object}              callback.err    Standard error object (if any.)
 * @param {String}              callback.path   The path where the new image is stored.
 * @api private
 */
var _downScale = function(ctx, input, output, width, callback) {
    ImageUtil.downScale(input, width, function(err, file) {
        if (err) {
            log().error({'err': err, 'contentId': ctx.contentId}, 'Could not downscale an image.');
            return callback({'code': 500, 'msg': 'Could not downscale an image.'});
        }

        IO.moveFile(file.path, output, callback);
    });
};
