/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var cheerio = require('cheerio');
var fs = require('fs');
var Path = require('path');

var ImageUtil = require('oae-util/lib/image');
var IO = require('oae-util/lib/io');
var log = require('oae-logger').logger('oae-preview-processor');
var RestAPI = require('oae-rest');

var LinkProcessorUtil = require('oae-preview-processor/lib/processors/link/util');
var PreviewConstants = require('oae-preview-processor/lib/constants');
var webshot = require('oae-preview-processor/lib/internal/webshot');

var options = {
    'windowSize': {
        'width': PreviewConstants.SIZES.IMAGE.WIDE_WIDTH,
        'height': PreviewConstants.SIZES.IMAGE.WIDE_HEIGHT
    },

    // Since we're dealing with simple static files, there is no need to delay taking a screenshot
    'renderDelay': 0
};

// Variable that will be used to lazy-load the collabdoc.html template
var wrapperHtml = null;

// The absolute path to the html & css files
var basePath = Path.normalize(__dirname + '/../../../static/collabdoc/');
var HTML_FILE = basePath + 'collabdoc.html';
var CSS_FILE = basePath + 'collabdoc.css';

/**
 * @borrows Interface.test as CollabDocProcessor.test
 */
var test = module.exports.test = function(ctx, contentObj, callback) {
    if (contentObj.resourceSubType === 'collabdoc') {
        callback(null, 10);
    } else {
        callback(null, -1);
    }
};

/**
 * @borrows Interface.generatePreviews as CollabDocProcessor.generatePreviews
 */
var generatePreviews = module.exports.generatePreviews = function(ctx, contentObj, callback) {
    // Do a check to see if this document has been published yet.
    // If there is more then 1 revision it has been published.
    RestAPI.Content.getRevisions(ctx.tenantRestContext, contentObj.id, null, 2, function(err, revisions) {
        if (err) {
            return callback(err);
        } else if (revisions.results.length === 1) {
            // Only 1 revision => unpublished document.
            // Ignore it for now.
            return callback(null, true);
        }

        // Write the etherpad HTML to an HTML file, so a screenshot can be generated as the preview
        _writeEtherpadHtml(ctx, contentObj.latestRevision.etherpadHtml, function(err, etherpadFilePath) {
            if (err) {
                return callback(err);
            }

            // Generate a screenshot that is suitable to display in the activity feed.
            var etherpadFileUri = 'file://' + etherpadFilePath;
            var path = ctx.baseDir + '/wide.png';
            webshot.getImage(etherpadFileUri, path, options, function (err) {
                if (err) {
                    log().error({'err': err, 'contentId': ctx.contentId}, 'Could not generate an image');
                    return callback(err);
                }

                ctx.addPreview(path, 'wide');

                // Crop out a thumbnail, manually since we know the image is 1070x500.
                // We'll crop out a top-left box.
                var selectedArea = {
                    'x': 0,
                    'y': 0,
                    'width': PreviewConstants.SIZES.IMAGE.WIDE_HEIGHT,
                    'height': PreviewConstants.SIZES.IMAGE.WIDE_HEIGHT
                };
                ImageUtil.cropAndResize(path, selectedArea, [ {'width': PreviewConstants.SIZES.IMAGE.THUMBNAIL, 'height': PreviewConstants.SIZES.IMAGE.THUMBNAIL} ], function(err, files) {
                    if (err) {
                        log().error({'err': err}, 'Could not crop the image');
                        return callback(err);
                    }

                    // Move the files to the thumbnail path
                    var key = PreviewConstants.SIZES.IMAGE.THUMBNAIL + 'x' + PreviewConstants.SIZES.IMAGE.THUMBNAIL;
                    var thumbnailPath = ctx.baseDir + '/thumbnail.png';
                    IO.moveFile(files[key].path, thumbnailPath, function(err) {
                        if (err) {
                            return callback(err);
                        }

                        ctx.setThumbnail(thumbnailPath);
                        callback();
                    });
                });
            });
        });
    });
};

/**
 * Take the provided Etherpad HTML, wrap into the preview template and store it to disk
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     etherpadHtml    The HTML to wrap into the preview template
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 * @param  {String}     callback.path   The path the file has been written to
 * @api private
 */
var _writeEtherpadHtml = function(ctx, etherpadHtml, callback) {
    _getWrappedEtherpadHtml(ctx, etherpadHtml, function(err, wrappedHtml) {
        if (err) {
            return callback(err);
        }

        // Write the resulting HTML file to a temporary file on disk
        var etherpadFilePath = ctx.baseDir + '/etherpad.html';
        fs.writeFile(etherpadFilePath, wrappedHtml, function(err) {
            if (err) {
                log().error({'err': err, 'contentId': ctx.contentId}, 'Could not write the etherpad HTML to disk');
                return callback({'code': 500, 'msg': 'Could not write the etherpad HTML to disk'});
            }

            return callback(null, etherpadFilePath);
        });
    });
};

/**
 * Wrap provided etherpad HTML into an HTML template
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     etherpadHtml    The HTML as retrieved from the API
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 * @param  {String}     callback.html   Resulting wrapped HTML
 * @api private
 */
var _getWrappedEtherpadHtml = function(ctx, etherpadHtml, callback) {
    var htmlFragment = null;
    // Extract the body from the HTML fragment
    try {
        var $ = cheerio.load(etherpadHtml);
        htmlFragment = $('body').html() || '';
    } catch (err) {
        log().error({'err': err, 'etherpadHtml': etherpadHtml, 'contentId': ctx.contentId}, 'Unable to parse etherpad HTML');
        return callback({'code': 500, 'msg': 'Unable to parse etherpad HTML'});
    }

    // The data that can be used in the collabdoc preview template
    var templateData = {
        'ctx': ctx,
        'htmlFragment': htmlFragment,
        'cssFile': CSS_FILE
    };

    // Check if the wrapper HTML has already been loaded to avoid loading it twice
    if (wrapperHtml) {
        callback(null, _.template(wrapperHtml)(templateData));
    } else {
        fs.readFile(HTML_FILE, 'utf8', function(err, content) {
            if (err) {
                log().error({'err': err, 'contentId': ctx.contentId}, 'Could not read the collabdoc wrapper HTML');
                return callback({'code': 500, 'msg': 'Could not read the collabdoc wrapper HTML'});
            }

            // Cache the wrapped HTML
            wrapperHtml = content;
            callback(null, _.template(wrapperHtml)(templateData));
        });
    }
};
