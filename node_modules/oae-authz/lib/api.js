/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var Cassandra = require('oae-util/lib/cassandra');
var OaeUtil = require('oae-util/lib/util');
var Telemetry = require('oae-telemetry').telemetry('authz');
var TenantsUtil = require('oae-tenants/lib/util');

var AuthzUtil = require('oae-authz/lib/util');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var Validator = require('oae-authz/lib/validator').Validator;


/////////////////////////
// ROLES & PERMISSIONS //
/////////////////////////

/**
 * Determine the direct role assigned to a principal on a specified resource.
 *
 * @param  {String}     principalId     The principal id. This can be a user or a group
 * @param  {String}     resourceId      The resource id. This can be a group as well.
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any.
 * @param  {String}     callback.role   The role of the principal on the resource. If the principal has no role or there is an error performing the check, role will be null.
 * @api private
 */
var _getDirectRole = function(principalId, resourceId, callback) {
    getDirectRoles([principalId], resourceId, function(err, roles) {
        if (err) {
            return callback(err);
        }

        return callback(null, roles[principalId]);
    });
};

/**
 * Determine the role assigned to the given principals directly on the specified resource instance.
 *
 * @param  {String[]}     principalIds    Array of principal ids. These can be user or group ids
 * @param  {String}       resourceId      The resource id. This can be a group as well.
 * @param  {Function}     callback        Standard callback function
 * @param  {Object}       callback.err    An error that occurred, if any.
 * @param  {Object}       callback.roles  A hash keyed by principal id, with value set to the role they have directly on the resource. If the principal has no role or there is an error performing the check, role will be null.
 **/
var getDirectRoles = module.exports.getDirectRoles = function(principalIds, resourceId, callback) {
    var validator = new Validator();
    validator.check(principalIds.length, {'code': 400, 'msg': 'At least one principal id needs to be passed in'}).min(1);
    validator.check(resourceId, {'code': 400, 'msg': 'Invalid resource id provided.'}).isResourceId();
    _.each(principalIds, function(principalId) {
        validator.check(principalId, {'code': 400, 'msg': 'Invalid principal id provided.'}).isPrincipalId();
    });
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    Cassandra.runQuery('SELECT "memberId", "role" FROM "AuthzMembers" WHERE "resourceId" = ? AND "memberId" IN (?)', [resourceId, principalIds], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var roles = {};
        _.each(rows, function(row) {
            row = Cassandra.rowToHash(row);
            roles[row.memberId] = row.role;
        });

        return callback(null, roles);
    });
};

/**
 * Given a principal and a resource, determine all the effective roles that the principal has on the resource, by virtue of direct
 * association and indirect group inheritance.
 *
 * @param  {String}       principalId       The principal id. This can be a user or a group
 * @param  {String}       resourceId        The resource id. This can be a group as well.
 * @param  {Function}     callback          Standard callback function
 * @param  {Object}       callback.err      An error that occurred, if any
 * @param  {String[]}     callback.roles    An array containing all the roles the principal has on the resource.
 */
var getAllRoles = module.exports.getAllRoles = function(principalId, resourceId, callback) {
    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'Invalid principal id provided.'}).isPrincipalId();
    validator.check(resourceId, {'code': 400, 'msg': 'Invalid resource id provided.'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the direct role of the user
    _getDirectRole(principalId, resourceId, function(err, directRole) {
        if (err) {
            return callback(err);
        }

        // Get the indirect roles of the user.
        _getIndirectRoles(principalId, resourceId, function(err, roles) {
            if (err) {
                return callback(err);
            }

            // Add the direct role (if any.)
            if (directRole) {
                roles.push(directRole);
            }
            callback(null, roles);
        });
    });
};

/**
 * Given a principal and a resource, determine all the roles that the principal has on the resource, by virtue of
 * indirect group inheritance.
 *
 * @param  {String}       principalId     The principal id. This can be a user or a group
 * @param  {String}       resourceId      The resource id. This can be a group as well.
 * @param  {Function}     callback        Standard callback function
 * @param  {Object}       callback.err    An error that occurred, if any
 * @param  {String[]}     callback.roles  An array containing all the roles the principal has on the resource by virtue of indirect group inheritance.
 * @api private
 */
var _getIndirectRoles = function(principalId, resourceId, callback) {
    // Get the groups that are directly associated to the resource
    getResourceGroupMembers(resourceId, function(err, groups) {
        if (err) {
            return callback(err);
        } else if (_.isEmpty(groups)) {
            return callback(null, []);
        }

        // Check whether any of these groups are part of the user's direct memberships
        var groupIds = _.keys(groups);

        // Make sure that the user's memberships have been exploded and cached
        _checkGroupMembershipsForUser(principalId, groupIds, function(err, memberships) {
            if (err) {
                return callback(err);
            }

            // Add the roles of the matching groups
            var allRoles = [];
            for (var m = 0; m < memberships.length; m++) {
                if (!_.contains(allRoles, groups[memberships[m]])) {
                    allRoles.push(groups[memberships[m]]);
                }
            }

            return callback(null, allRoles);
        });
    });
};

/**
 * Get all of the groups that are directly associated to a resource.
 *
 * @param  {String}       resourceId      The resource id. This can be a group as well.
 * @param  {Function}     callback        Standard callback function
 * @param  {Object}       callback.err    An error that occurred, if any
 * @param  {Object}       callback.roles  A JSON object where the keys are the group ids of the groups directly associated to the resource and the value is the role of that group
 * @api private
 */
var getResourceGroupMembers = function(resourceId, callback) {
    // Get the groups that are directly associated to the resource
    var start = AuthzConstants.principalTypes.GROUP + ':';
    var end = start + '|';

    Cassandra.runPagedQuery('AuthzMembers', 'resourceId', resourceId, 'memberId', start, 10000, {'end': end}, function(err, rows) {
        if (err) {
            return callback(err);
        }

        // Convert all roles to an object mapping memberId -> role
        var associatedGroups = {};
        _.each(rows, function(row) {
            row = Cassandra.rowToHash(row);
            associatedGroups[row.memberId] = row.role;
        });

        return callback(null, associatedGroups);
    });
};

/**
 * Determines whether or not a principal has the specified role directly or indirectly on a given resource.
 *
 * @param  {String}      principalId         The principal id. This can be a user or a group.
 * @param  {String}      resourceId          The resource id. This can be a group as well
 * @param  {String}      role                The role to check
 * @param  {Function}    callback            A function specifying whether or not the user has the role on the resource
 * @param  {Object}      callback.err        An error that occurred, if any
 * @param  {Boolean}     callback.hasRole    Whether or not the principal has the specified role on the resource
 */
var hasRole = module.exports.hasRole = function(principalId, resourceId, role, callback) {
    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'Invalid principal id provided.'}).isPrincipalId();
    validator.check(resourceId, {'code': 400, 'msg': 'Invalid resource id provided.'}).isResourceId();
    validator.check(role, {'code': 400, 'msg': 'Invalid role provided.'}).isValidRole();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _hasRole(principalId, resourceId, role, callback);
};

/**
 * Determines whether or not a principal has any role directly or indirectly on a given resource.
 *
 * @param  {String}      principalId         The principal id. This can be a user or a group.
 * @param  {String}      resourceId          The resource id. This can be a group as well
 * @param  {Function}    callback            A function specifying whether or not the user has the role on the resource
 * @param  {Object}      callback.err        An error that occurred, if any
 * @param  {Boolean}     callback.hasRole    Whether or not the principal has a role on the resource
 */
var hasAnyRole = module.exports.hasAnyRole = function(principalId, resourceId, callback) {
    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'Invalid principal id provided.'}).isPrincipalId();
    validator.check(resourceId, {'code': 400, 'msg': 'Invalid resource id provided.'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _hasRole(principalId, resourceId, null, callback);
};

/**
 * Determines whether or not a principal has the specified role directly or indirectly on a given resource.
 *
 * @param  {String}       principalId         The principal id. This can be a user or a group.
 * @param  {String}       resourceId          The resource id. This can be a group as well
 * @param  {String}       role                The role to check. If the role is null, we check for any role
 * @param  {Function}     callback            A function specifying whether or not the user has the role on the resource
 * @param  {Object}       callback.err        An error that occurred, if any
 * @param  {Boolean}      callback.hasRole    Whether or not the principal has the specified role on the resource
 * @api private
 */
var _hasRole = function(principalId, resourceId, role, callback) {
    // Check for a direct role first
    _getDirectRole(principalId, resourceId, function(err, directRole) {
        if (err) {
            return callback(err);
        } else if (directRole && (role === null || directRole === role)) {
            return callback(null, true);
        }

        // If no direct role assignment is found, we try to find a role through an indirect membership
        _getIndirectRoles(principalId, resourceId, function(err, roles) {
            if (err) {
                return callback(err);
            }

            // If a role is found and we are just looking for any role
            if (roles.length > 0 && role === null) {
                return callback(null, true);
            // If we are looking for a specific role and that specific role is present
            } else if (_.contains(roles, role)) {
                return callback(null, true);
            // If the specified role cannot be found
            } else {
                callback(null, false);
            }
        });
    });
};

/**
 * Assign one or multiple principals a role on a resource instance. If the user already has a role, it will simply be updated. When
 * false is passed in as a role, the role for that principal will be removed.
 *
 * @param  {String}          resourceId      The resource id.
 * @param  {Object}          changes         JSON object where the keys are principal ids and the values are role values
 * @param  {Function}        callback        Standard callback function
 * @param  {Object}          callback.err    Error object, containing the error message
 */
var updateRoles = module.exports.updateRoles = function(resourceId, changes, callback) {
    var validator = new Validator();
    validator.check(resourceId, {'code': 400, 'msg': 'Invalid resource id provided.'}).isResourceId();
    var roleChanges = _.keys(changes);
    validator.check(roleChanges.length, {'code': 400, 'msg': 'At least one role change needs to be applied'}).min(1);
    for (var i = 0; i < roleChanges.length; i++) {
        var principalId = roleChanges[i];
        validator.check(principalId, {'code': 400, 'msg': 'Invalid principal id specified: ' + principalId}).isPrincipalId();
        validator.check(changes[principalId], {'code': 400, 'msg': 'Invalid role provided.'}).isValidRoleChange();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _updateRoles(resourceId, changes, callback);
};

/**
 * Assign multiple principals a role on a resource instance. If the user already has a role, it will simply be updated. When
 * false is passed in as a role, the role for that principal will be removed.
 *
 * @param  {String}        resourceId      The resource id.
 * @param  {Object}        changes         JSON object where the keys are principal ids and the values are role values
 * @param  {Function}      callback        Standard callback function
 * @param  {Object}        callback.err    Error object, containing the error message
 * @api private
 */
var _updateRoles = function(resourceId, changes, callback) {
    var queries = [];
    var roleChanges = _.keys(changes);
    for (var i = 0; i < roleChanges.length; i++) {
        var principalId = roleChanges[i];
        if (changes[principalId]) {
            queries.push({
                'query': 'UPDATE "AuthzRoles" SET "role" = ? WHERE "principalId" = ? AND "resourceId" = ?',
                'parameters': [changes[principalId], principalId, resourceId]
            });
            queries.push({
                'query': 'UPDATE "AuthzMembers" SET "role" = ? WHERE "resourceId" = ? AND "memberId" = ?',
                'parameters': [changes[principalId], resourceId, principalId]
            });
        } else if (changes[principalId] === false) {
            queries.push({
                'query': 'DELETE FROM "AuthzRoles" WHERE "principalId" = ? AND "resourceId" = ?',
                'parameters': [principalId, resourceId]
            });
            queries.push({
                'query': 'DELETE FROM "AuthzMembers" WHERE "resourceId" = ? AND "memberId" = ?',
                'parameters': [resourceId, principalId]
            });
        } else {
            return callback({'code': 400, 'msg': 'An invalid role has been passed in (undefined)'});
        }
    }
    // Invalidate the AuthzMembershipsCache row for each user who's role has just changed and for all of the users that
    // are members of the groups for which the roles have just been changed. We only want to do this when a group
    // memberships are being updated. There's no need to do it when a content membership is updated
    if (AuthzUtil.isGroupId(resourceId)) {
        // Collect the userids that need invalidating
        var invalidatedUsers = [];
        // Collect the groups for which the members need to be invalidated
        var groupsToInvalidate = [];
        // Keep track of the groups that we've already invalidated as we walk through deep membership
        var invalidatedGroups = [resourceId];

        var changeKeys = _.keys(changes);
        for (var c = 0; c < changeKeys.length; c++) {
            // Just invalidate the user
            if (AuthzUtil.isUserId(changeKeys[c])) {
                invalidatedUsers.push(changeKeys[c]);
                queries.push({
                    'query': 'DELETE FROM "AuthzMembershipsCache" WHERE "principalId" = ?',
                    'parameters': [changeKeys[c]]
                });
            // Queue the group to invalidate all of its members
            } else if (AuthzUtil.isGroupId(changeKeys[c])) {
                groupsToInvalidate.push(changeKeys[c]);
            }
        }

        var invalidateGroupMembers = function() {
            if (_.isEmpty(groupsToInvalidate)) {
                return Cassandra.runBatchQuery(queries, callback);
            }

            var groupId = groupsToInvalidate.shift();

            // Get all of the members of the group, so they can be invalidated
            getAuthzMembers(groupId, null, 10000, function(err, members) {
                if (err) {
                    return callback(err);
                }

                for (var i = 0; i < members.length; i++) {
                    var memberId = members[i].id;
                    // The members can be invalidated
                    if (AuthzUtil.isUserId(memberId) && !_.contains(invalidatedUsers, memberId)) {
                        invalidatedUsers.push(memberId);
                        queries.push({
                            'query': 'DELETE FROM "AuthzMembershipsCache" WHERE "principalId" = ?',
                            'parameters': [memberId]
                        });
                    // Group members need to be further exploded. In order to do this, we need to check whether or not the list
                    // of groups that have already been invalidated and the list of groups that are queued up to be invalidated
                    // don't contain this group, otherwise we'll invalidate the group twice.
                    } else if (AuthzUtil.isGroupId(memberId) && !_.contains(invalidatedGroups, memberId) && !_.contains(groupsToInvalidate, memberId)) {
                        groupsToInvalidate.push(memberId);
                        invalidatedGroups.push(memberId);
                    }
                }

                return invalidateGroupMembers();
            });
        };

        // Get all of the members of the current group
        return invalidateGroupMembers();

    } else {
        Cassandra.runBatchQuery(queries, callback);
    }
};


///////////////////
// AUTHZ MEMBERS //
///////////////////

/**
 * Get all the direct members of a resource and their role on the resource.
 *
 * @param  {String}      resourceId              A unique identifier for a resource. ex: g:cam-oae-team or c:cam:XCDSasD
 * @param  {String}      start                   The principal id that comes just before the first principal you wish to have in your results.
 * @param  {Number}      limit                   The number of members you wish to retrieve.
 * @param  {Function}    callback                Standard callback function
 * @param  {Object}      callback.err            An error that occurred, if any
 * @param  {Object[]}    callback.members        Array of objects for each of the direct member of the resource. Each object has an 'id' key containing the principal id of the member and a 'role' key containing the role of that principal
 * @param  {String}      callback.nextToken      The value to provide in the `start` parameter to get the next set of results
 */
var getAuthzMembers = module.exports.getAuthzMembers = function(resourceId, start, limit, callback) {
    start = start || '';
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(resourceId, {'code': 400, 'msg': 'Invalid resource id provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    Cassandra.runPagedQuery('AuthzMembers', 'resourceId', resourceId, 'memberId', start, limit, null, function(err, rows, nextToken) {
        if (err) {
            return callback(err);
        }

        // Build the members array while resolving the nextToken as the last item
        var members = _.map(rows, function(row) {
            row = Cassandra.rowToHash(row);
            return {'id': row.memberId, 'role': row.role};
        });

        return callback(null, members, nextToken);
    });
};

/**
 * Given a list of groups, we check if a user is a direct or indirect member of any of these. This is done by first checking whether or
 * not the user's membership list has been exploded. If so, we do a direct match against that exploded list. If the user's memberships
 * have not yet been exploded, we explode the user's memberships, do a direct match against the retrieved list and then cache the exploded
 * list
 *
 * @param  {String}      userId                 Id of the user for which we're checking whether or not he is a member of a set of groups
 * @param  {String[]}    groupIds               Array of group ids for which we're checking if the user is a member
 * @param  {Function}    callback               Standard callback function
 * @param  {Object}      callback.err           An error that occurred, if any
 * @param  {String[]}    callback.memberships   Array of group ids containing all the groups from the provided list that the user is a member of
 * @api private
 */
var _checkGroupMembershipsForUser = function(userId, groupIds, callback) {
    // Check if the exploded list is there
    Cassandra.runQuery('SELECT "value" FROM "AuthzMembershipsCache" WHERE "principalId" = ? LIMIT 1', [userId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        // There are columns in the exploded row
        if (rows.length === 1) {
            Cassandra.runQuery('SELECT "groupId" FROM "AuthzMembershipsCache" WHERE "principalId" = ? AND "groupId" IN (?)', [userId, groupIds], function(err, rows) {
                if (err) {
                    return callback(err);
                }

                var memberships = _.map(rows, function(row) {
                    return row.get('groupId').value;
                });

                return callback(null, memberships);
            });

        // There are no columns, we need to explode the user's group memberships
        } else {
            _explodeGroupMemberships(userId, function(err, allMemberships) {
                if (err) {
                    return callback(err);
                }

                // Return the matching groups
                var memberships = _.intersection(groupIds, allMemberships);
                return callback(null, memberships);
            });
        }
    });
};

/**
 * Get all the Authz groups of which a principal is a member. This includes all group ancestors to which the user is indirectly a member.
 * Once these have been retrieved, they will be cached inside of Cassandra for fast permission checks
 *
 * @param  {String}     principalId                     Principal id for whom we want to explode the group memberships
 * @param  {Function}   callback                        Standard callback function
 * @param  {Object}     callback.err                    An error that occurred, if any
 * @param  {String[]}   callback.memberships            An array of group ids that represents the full list of direct and indirect memberships for the provided principal
 * @param  {String[]}   callback.indirectMemberships    An array of group ids that represents only the groups in which the principal is a member indirectly
 * @api private
 */
var _explodeGroupMemberships = function(principalId, callback) {
    // Get the full exploded membership list for the user
    _getAuthzGroupMembershipAncestry(principalId, function(err, membershipsByDepth) {
        if (err) {
            return callback(err);
        }

        var allMemberships = _.flatten(membershipsByDepth).sort();
        if (_.isEmpty(allMemberships)) {
            return callback(null, [], []);
        }

        // The indirect memberships are all memberships that begin at depth 1 or more
        var indirectMemberships = _.flatten(membershipsByDepth.slice(1)).sort();

        // Save the full memberships cache to cassandra for this principal
        var authzMembershipsCacheQueries = _.map(allMemberships, function(groupId) {
            return {
                'query': 'INSERT INTO "AuthzMembershipsCache" ("principalId", "groupId", "value") VALUES (?, ?, ?)',
                'parameters': [principalId, groupId, '1']
            };
        });

        var authzMembershipsIndirectCacheQueries = _.map(indirectMemberships, function(groupId) {
            return {
                'query': 'INSERT INTO "AuthzMembershipsIndirectCache" ("principalId", "groupId", "value") VALUES (?, ?, ?)',
                'parameters': [principalId, groupId, '1']
            };
        });

        // Update both the straight memberships cache and the dedicated indirect cache with the exploded memberships
        Cassandra.runBatchQuery(_.union(authzMembershipsCacheQueries, authzMembershipsIndirectCacheQueries), function(err) {
            if (err) {
                return callback(err);
            }

            return callback(null, allMemberships, indirectMemberships);
        });
    });
};

/**
 * Gets all the Authz groups of which a principal (either user or group) is a member. This includes all group ancestors to
 * which the user is indirectly a member.
 *
 * @param  {String}         principalId         The principal id for which to retrieve all the group memberships
 * @param  {String}         start               Determines the point at which group memberships members are returned for paging purposes.  If not provided, the first x elements will be returned
 * @param  {Number}         limit               Number of group memberships to return. Will default to 10 if not provided
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occured, if any
 * @param  {String[]}       callback.groups     An array of group ids representing the groups to which the user belongs, either directly or indirectly
 * @param  {String}         callback.nextToken  The value to provide in the `start` parameter to get the next set of results
 */
var getPrincipalMemberships = module.exports.getPrincipalMemberships = function(principalId, start, limit, callback) {
    start = start || '';
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'Invalid principal id provided'}).isPrincipalId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    Cassandra.runPagedQuery('AuthzMembershipsCache', 'principalId', principalId, 'groupId', start, limit, null, function(err, rows, nextToken, startMatched) {
        if (err) {
            return callback(err);
        } else if (startMatched || !_.isEmpty(rows)) {
            // If we received some groups from the memberships cache, it means it is valid and we can
            // use the data we have
            var groupIds = _.map(rows, function(row) {
                return row.get('groupId').value;
            });

            return callback(null, groupIds, nextToken);
        }

        // If no rows were fetched, we must populate the cache, and we can use the data we have from the population
        _explodeGroupMemberships(principalId, function(err, allMemberships) {
            if (err) {
                return callback(err);
            }

            var startIndex = 0;
            if (start) {
                // We don't want to include the start element, so pick the next element as the start
                startIndex = _.indexOf(allMemberships, start) + 1;
            }
            var memberships = allMemberships.slice(startIndex, startIndex + limit);

            nextToken = null;
            if (memberships.length === limit && !_.isEmpty(memberships)) {
                nextToken = _.last(memberships);
            }

            return callback(null, memberships, nextToken);
        });
    });
};

var getIndirectPrincipalMemberships = module.exports.getIndirectPrincipalMemberships = function(principalId, start, limit, callback) {
    start = start || '';
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'Invalid principal id provided'}).isPrincipalId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    Cassandra.runPagedQuery('AuthzMembershipsIndirectCache', 'principalId', principalId, 'groupId', start, limit, null, function(err, rows, nextToken, startMatched) {
        if (err) {
            return callback(err);
        } else if (startMatched || !_.isEmpty(rows)) {
            // If we received some groups from the memberships cache, it means it is valid and we
            // can use the data we have
            var groupIds = _.map(rows, function(row) {
                return row.get('groupId').value;
            });

            return callback(null, groupIds, nextToken);
        }

        // If no rows were fetched, we must populate the cache, and we can use the data we have from
        // the population
        _explodeGroupMemberships(principalId, function(err, allMemberships, indirectMemberships) {
            if (err) {
                return callback(err);
            }

            var startIndex = 0;
            if (start) {
                // We don't want to include the start element, so pick the next element as the start
                startIndex = _.indexOf(indirectMemberships, start) + 1;
            }
            var memberships = indirectMemberships.slice(startIndex, startIndex + limit);

            nextToken = null;
            if (memberships.length === limit && !_.isEmpty(memberships)) {
                nextToken = _.last(memberships);
            }

            return callback(null, memberships, nextToken);
        });
    });
};

/**
 * Given some principal, get their entire group membership ancestry. In other words, get all the groups to which they belong,
 * and the groups to all those groups belong, and so on.
 *
 * @param  {String|String[]}    principalId                 The principal id or a list of principal ids for which to retrieve the authz group membership ancestry
 * @param  {Function}           callback                    Standard callback function
 * @param  {Object}             callback.err                The err that occured, if any
 * @param  {String[][]}         callback.ancestryByDepth    An array of arrays. The top-level array represents depth to which the principal is a member, while the nested array represents the group ids to which the principal is a member at that depth
 * @api private
 */
var _getAuthzGroupMembershipAncestry = function(principalIds, callback, _groupIdsCache, _groupIdsByDepth) {
    _groupIdsByDepth = _groupIdsByDepth || [];
    _groupIdsCache = _groupIdsCache || {};
    if (_.isString(principalIds)) {
        return _getAuthzGroupMembershipAncestry([principalIds], callback);
    } else if (_.isEmpty(principalIds)) {
        return callback(null, _groupIdsByDepth);
    }

    getRolesForPrincipalsAndResourceType(principalIds, AuthzConstants.resourceTypes.GROUP, 10000, function(err, entries) {
        if (err) {
            return callback(err);
        }

        // Filter the ancestors by those we haven't seen yet to avoid duplicates under multiple depths
        var newAncestorIds = _.chain(entries)
            .keys()
            .filter(function(ancestorId) {
                return (!_groupIdsCache[ancestorId]);
            })
            .value();

        // Aggregate the ancestor ids into the depth array and the local group id cache
        _groupIdsByDepth.push(newAncestorIds);
        _.each(newAncestorIds, function(ancestorId) {
            _groupIdsCache[ancestorId] = true;
        });

        return _getAuthzGroupMembershipAncestry(newAncestorIds, callback, _groupIdsCache, _groupIdsByDepth);
    });
};

/**
 * Get the roles the provided principal has on resources of the given resource type.
 *
 * @param  {String}     principalId             The principal whose roles to fetch
 * @param  {String}     resourceType            The resource type of the resources to search for, as determined by Resource.resourceType
 * @param  {String}     [start]                 The starting resourceId from which to start fetching roles. Default: Starts from the first resource id
 * @param  {Number}     [limit]                 The maximum number of resources to fetch. Default: 10
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Object[]}   callback.roles          An array of objects that indicate each resource the principal is associated to, and what the role is on that resource
 * @param  {String}     callback.roles[i].id    The id of the resource to which the principal is associated
 * @param  {String}     callback.roles[i].role  The role the principal has on the resource
 * @param  {String}     callback.nextToken      A value that can be used as the `start` parameter for another invokation that will fetch the next page of items
 */
var getRolesForPrincipalAndResourceType = module.exports.getRolesForPrincipalAndResourceType = function(principalId, resourceType, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'Invalid principal id specified: ' + principalId}).isPrincipalId();
    validator.check(resourceType, {'code': 400, 'msg': 'A resourceType needs to be provided'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // We append a '|' to the "end" range, as | has a high ASCII alphabetical ordering. This may not suffice if resourceIds have
    // multi-byte characters, which is technically possible. Unfortunately, I don't think there is a better way to do this with
    // CQL.
    start = start || resourceType;
    start += ':';

    var end = resourceType + ':|';

    Cassandra.runPagedQuery('AuthzRoles', 'principalId', principalId, 'resourceId', start, limit, {'end': end}, function(err, rows, nextToken) {
        if (err) {
            return callback(err);
        }

        // Build the response roles array
        var roles = _.map(rows, function(row) {
            return {
                'id': row.get('resourceId').value,
                'role': row.get('role').value
            };
        });

        return callback(null, roles, nextToken);
    });
};

/**
 * Get all principal roles associated to the resourceType for all the principals in the array of principal ids. This can be performed on
 * multiple principals at once.
 *
 * The structure of the resulting entries is structured a hash, indicating all resource ids that were returned and what the
 * roles associated to those resources were. For example:
 *
 *     {
 *      'u:cam:simong': { 'member': true },
 *      'g:cam:group-b': { 'member': true }
 *     }
 *
 * or:
 *
 *     {
 *      'c:gat:Foo.docx': { 'viewer': true, 'manager': true},
 *      'c:cam:Bar.pdf':  { 'viewer': true }
 *     }
 *
 * In the latter case, 'c:gat:Foo.docx' has both 'viewer' and 'manager' role associated to it. This indicates that some principal
 * had a role of 'viewer' on the resource, while some other principal had the 'manager' role.
 *
 * @param  {Array}          principalIds        The array of principal ids to query for
 * @param  {String}         resourceType        The resource type of the resources to search for, as determined by Resource.resourceType
 * @param  {Number}         limit               The maximum number of resources to return per user. Default: 1000 (because this is typically used for batch collection of memberships)
 * @param  {Function}       callback            A function providing all the {resource id} -> {roles} mappings aggregated for all the provided principals queried
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Object}         callback.entries    A JSON Object representing the roles associated to the users
 */
var getRolesForPrincipalsAndResourceType = module.exports.getRolesForPrincipalsAndResourceType = function(principalIds, resourceType, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 1000, 1);
    principalIds = principalIds || [];

    var validator = new Validator();
    validator.check(resourceType, {'code': 400, 'msg': 'A resourceType needs to be provided'}).notEmpty();
    validator.check(principalIds.length, {'code': 400, 'msg': 'At least one principal Id needs to be passed in'}).min(1);
    for (var i = 0; i < principalIds.length; i++) {
        var principalId = principalIds[i];
        validator.check(principalId, {'code': 400, 'msg': 'Invalid principal id specified: ' + principalId}).isPrincipalId();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // We append a '|' to the "end" range, as | has a high ASCII alphabetical ordering. This may not suffice if resourceIds have
    // multi-byte characters, which is technically possible. Unfortunately, I don't think there is a better way to do this with
    // CQL.
    var start = resourceType + ':';
    var end = start + '|';

    var finished = false;
    var numCompleted = 0;
    var entries = {};
    _.each(principalIds, function(principalId) {
        Cassandra.runPagedQuery('AuthzRoles', 'principalId', principalId, 'resourceId', start, limit, {'end': end}, function(err, rows) {
            if (err) {
                if (!finished) {
                    finished = true;
                    return callback(err);
                }
            }

            numCompleted++;

            // Aggregate all resources from all the resource roles into the entries hash
            _.each(rows, function(row) {
                var resourceId = row.get('resourceId').value;
                var role = row.get('role').value;

                entries[resourceId] = entries[resourceId] || {};
                entries[resourceId][role] = true;
            });

            // If this was the final response we were waiting for, invoke the callback
            if (!finished && numCompleted === principalIds.length) {
                finished = true;
                return callback(null, entries);
            }
        });
    });
};

/**
 * Determine what the membership of a resource would be after applying the specified permission changes to it.
 *
 * @param  {String}     resourceId              The id of the resource to check
 * @param  {Object}     permissionChanges       An object that describes the permission changes to apply to the resource. The key is the id of the principal to which to apply the change, and the value is the role to apply to the principal. If the value is `false`, the principal will be revoked access.
 * @param  {Function}   callback                Invoked when the test is complete
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Object}     callback.permissions    An object that describes the permissions on the resource after the changes have been applied. The key is the id of the principal, and the value is the role of the principal
 * @param  {String[]}   callback.newMembers     The principal ids that would be new members to the resource
 * @param  {String[]}   callback.updateMembers  The principal ids whose role existed before and will change
 * @param  {String[]}   callback.removedMembers The principal ids whose role existed before and will be removed
 * @api private
 */
var computeMemberRolesAfterChanges = module.exports.computeMemberRolesAfterChanges = function(resourceId, permissionChanges, callback) {
    getAuthzMembers(resourceId, null, 10000, function(err, memberIdsWithRolesArray) {
        if (err) {
            return callback(err);
        }

        // Turn the id->role array into a hash, we don't care about order
        var memberIdsWithRoles = {};
        _.each(memberIdsWithRolesArray, function(memberIdWithRole) {
            memberIdsWithRoles[memberIdWithRole.id] = memberIdWithRole.role;
        });

        var newMembers = [];
        var updatedMembers = [];
        var removedMembers = [];

        // Apply all of the permission changes in-memory
        _.each(permissionChanges, function(change, memberId) {
            if (change === false) {
                if (memberIdsWithRoles[memberId]) {
                    // The member `memberId` will be removed
                    delete memberIdsWithRoles[memberId];
                    removedMembers.push(memberId);
                }
            } else {
                if (memberIdsWithRoles[memberId] && memberIdsWithRoles[memberId] !== change) {
                    // The member `memberId` will have a changed role
                    memberIdsWithRoles[memberId] = change;
                    updatedMembers.push(memberId);
                } else if (!memberIdsWithRoles[memberId]) {
                    // The member `memberId` will be added to the item
                    memberIdsWithRoles[memberId] = change;
                    newMembers.push(memberId);
                } else {
                    // This situation is where either a non-member user was removed, or a member was specified with a role
                    // they already had. This is intentionally left empty
                }
            }
        });

        return callback(null, memberIdsWithRoles, newMembers, updatedMembers, removedMembers);
    });
};

/**
 * Determine the **effective** role a user has in a resource. Though a user can have multiple roles on a resource
 * by virtue of indirect group membership, this determines the highest level of access granted. This check is not only
 * implicit, but includes explicit role membership lookup. Therefore, its output alone can be used as an authoritative
 * source of access information.
 *
 * @param  {Context}    ctx                     The context of the user to check for access
 * @param  {String}     resourceId              The id of the resource against which to check for access
 * @param  {String}     resourceTenantAlias     The tenant alias of tenant to which the resource belongs
 * @param  {String}     resourceVisibility      The visibility of the target resource. One of public, loggedin or private
 * @param  {String[]}   rolesPriority           An array of roles expressing the ordering of roles in order of least powerful to most powerful
 * @param  {Function}   callback                Invoked when the process completes
 * @param  {Object}     callback.err            An error that occured, if any
 * @param  {String}     callback.effectiveRole  The effective role of the user in context, as determined by the rolesPriority
 * @param  {Boolean}    callback.canInteract    Whether or not the user can interact
 * @api private
 */
var resolveEffectiveRole = module.exports.resolveEffectiveRole = function(ctx, resourceId, resourceTenantAlias, resourceVisibility, rolesPriority, callback) {
    var user = ctx.user();

    resolveImplicitRole(ctx, resourceId, resourceTenantAlias, resourceVisibility, rolesPriority, function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (implicitRole === _.last(rolesPriority)) {
            // We already have the highest role, use it
            return callback(null, implicitRole, canInteract);
        } else if (!user) {
            // We are anonymous so cannot have any explicit access or interact. Use only our implicitRole if we have one
            return callback(null, implicitRole, canInteract);
        }

        // No explicit association exists from a user to another user, therefor we can use the implicit result
        if (AuthzUtil.isUserId(resourceId)) {
            return callback(null, implicitRole, canInteract);
        }

        // If we get here, it would be prudent to check if this user has granted access to the target resource
        getAllRoles(user.id, resourceId, function(err, roles) {
            if (err) {
                return callback(err);
            } else if (_.isEmpty(roles)) {
                // We have no explicit role, so we fall back to the implicit access
                return callback(null, implicitRole, canInteract);
            }

            // The resolved role is the one at the highest index of the passed in rolesPriority array.
            var highestIndex = _.indexOf(rolesPriority, implicitRole);
            _.each(roles, function(role) {
                highestIndex = Math.max(highestIndex, _.indexOf(rolesPriority, role));
            });

            // The `canInteract` parameter is true because we can always interact if we have an explicit role
            return callback(null, rolesPriority[highestIndex], true);
        });
    });
};

/**
 * Determine the highest **implicit** role that the user in context has on a resource. Implicit means that the
 * user is granted access based on simple privacy / visibility / tenant rules associated to the context. Some
 * examples:
 *  (In all examples the rolesPriority is defined as ['viewer', 'manager'])
 *
 *  *   If the user in context is an admin, they will implicitly have manager access of the resource, even if they
 *      don't have an explicit manager role membership on the resource;
 *  *   If the resource has visibility "public", all contexts (anonymous or authenticated) have implicit "viewer"
 *      role on a resource
 *  *   If the resource has visibility "private", no user context (except administrator) can have implicit "viewer"
 *      as that can only be determined through an **explicit** role check
 *
 * Therefore, the output from this call is the **minimum** effective permissions the current context has on a resource,
 * since there is no concept of a "deny" permission. If this method returns that there is no implicit role, it is still
 * possible that the user has been explicitly granted a membership role. If this method returns that there is an implicit
 * "viewer" role, it is possible that the user has been explicitly granted a role of "manager".
 *
 * The `canInteract` determines if the user can implicitly "interact" with the resource through potential tenant privacy
 * boundaries (e.g., share it, add it to their library, post a message on it). Like `implicitRole`, it is also a minimal
 * implicit check. So if this results in `false`, it is still possible that a user has an explicit manager role on the
 * resource which grants it ability to interact.
 *
 * To get a context's explicit effective role, please use #resolveEffectiveRole instead.
 *
 * @param  {Context}    ctx                     The context of the user to check for access
 * @param  {String}     resourceId              The id of the resource against which to check for access
 * @param  {String}     resourceTenantAlias     The tenant alias for the resource that is being accessed
 * @param  {String}     resourceVisibility      The visibility for the resource that is being accessed
 * @param  {String[]}   rolesPriority           An array of roles expressing the ordering of roles in order of least powerful to most powerful
 * @param  {Function}   callback                Invoked when the process completes
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {String}     callback.implicitRole   The implicit (minimum) role the user in context has on the resource. An anonymous user has no role.
 * @param  {Boolean}    callback.canInteract    Determines whether or not the user in context can implicitly interact with the resource
 */
var resolveImplicitRole = module.exports.resolveImplicitRole = function(ctx, resourceId, resourceTenantAlias, resourceVisibility, rolesPriority, callback) {
    var user = ctx.user();

    // Anonymous cannot interact with anything and get the lowest role if the resource visibility is set to public.
    // Otherwise, they do not get a role.
    if (!user) {
        var implicitRole = null;
        if (resourceVisibility === AuthzConstants.visibility.PUBLIC) {
            implicitRole = _.first(rolesPriority);
        }
        return callback(null, implicitRole, false);

    // The user has maximum access on themself
    } else if (user.id === resourceId) {
        return callback(null, _.last(rolesPriority), true);

    // Check admin access
    } else if (user.isGlobalAdmin() || user.isTenantAdmin(resourceTenantAlias)) {
        // The user is an administrator, give them the highest allowable access
        return callback(null, _.last(rolesPriority), true);
    }

    // Determine the implicit interaction capabilities between the user and the resource
    var actorTenantAlias = (user) ? user.tenant.alias : ctx.tenant().alias;
    var canInteract = TenantsUtil.canInteract(actorTenantAlias, resourceTenantAlias);

    // Check implicit member access
    if (resourceVisibility === AuthzConstants.visibility.PUBLIC) {
        // Public resources can be seen by anyone
        return callback(null, _.first(rolesPriority), canInteract);
    } else if (resourceVisibility === AuthzConstants.visibility.LOGGEDIN && TenantsUtil.isLoggedIn(ctx, resourceTenantAlias)) {
        // We are from the same tenant as the "loggedin" resource, so we can view it and interact
        return callback(null, _.first(rolesPriority), canInteract);
    }

    return callback();
};

/**
 * Checks to see if both the user and the resource's tenant can interact with the given list of resources. This will **not**
 * perform any interaction or permissions checks between the user in context and the resource, that must be performed separately
 *
 * @param  {Context}    ctx                                     The context of the current request
 * @param  {String}     resourceTenantAlias                     The tenant alias of the resource the user is performaning an action upon
 * @param  {Object[]}   targetResources                         The standard resources to which the user is trying to associate the resource (e.g., Adding a user to a group, or adding a content item to a collection)
 * @param  {Function}   callback                                Standard callback function
 * @param  {Object}     callback.err                            An error that occurred, if any
 * @param  {Boolean}    callback.canInteract                    `true` if the user in context is allowed to perform this operation. `false` otherwise
 * @param  {String[]}   [callback.illegalTargetResourceIds]     If the check failed because of a tenant boundary violation, this will be an array of resource ids that were in violation
 */
var canInteract = module.exports.canInteract = function(ctx, resourceTenantAlias, targetResources, callback) {
    var actorTenantAlias = ctx.user().tenant.alias;

    // Collect the principals whose tenant conflicts with the resource tenant
    var illegalTargetResourceIds = _.filter(targetResources, function(targetResource) {
        return !TenantsUtil.canInteract(resourceTenantAlias, targetResource.tenant.alias);
    });

    // If there are any conflicts with the resource, return an error immediately
    if (!_.isEmpty(illegalTargetResourceIds)) {
        return callback(null, false, illegalTargetResourceIds);
    }

    // There are no obvious tenant interaction issues, ensure we don't violate resource visibility boundaries
    _canExplicitlyInteract(ctx, resourceTenantAlias, targetResources.slice(), function(err, illegalTargetResourceIds) {
        if (err) {
            return callback(err);
        } else if (!_.isEmpty(illegalTargetResourceIds)) {
            return callback(null, false, illegalTargetResourceIds);
        }

        // If there were no tenant or visibility violations, we are allowed to interact
        return callback(null, true);
    });
};

var _canExplicitlyInteract = function(ctx, resourceTenantAlias, targetResources, callback, _illegalTargetResourceIds) {
    _illegalTargetResourceIds = _illegalTargetResourceIds || [];
    if (_.isEmpty(targetResources)) {
        return callback(null, _illegalTargetResourceIds);
    }

    var targetResource = targetResources.pop();

    // If the target resource is a user we only check for implicit access as there is no concept of
    // explicit access for users. The role priority list is not really important as we aren't trying
    // to derive an exact role
    if (AuthzUtil.isUserId(targetResource.id)) {
        resolveImplicitRole(ctx, targetResource.id, targetResource.tenant.alias, targetResource.visibility, ['viewer', 'manager'], function(err, implicitRole, canInteract) {
            if (err) {
                return callback(err);
            } else if (!canInteract) {
                _illegalTargetResourceIds.push(targetResource.id);
            }

            return _canExplicitlyInteract(ctx, resourceTenantAlias, targetResources, callback, _illegalTargetResourceIds);
        });

    // If the target resource is not a user we need to ensure the current user can view it and tenant
    // interactions are allowed. In case the resource is not public we'd need to determine our role
    // on that resource, re-using resolveEffectiveRole will make sure we can interact with the resource
    // and we have a role on it if necessary
    } else {
        resolveEffectiveRole(ctx, targetResource.id, targetResource.tenant.alias, targetResource.visibility, ['viewer', 'manager'], function(err, effectiveRole, canInteract) {
            if (err) {
                return callback(err);
            } else if (!canInteract) {
                _illegalTargetResourceIds.push(targetResource.id);
            }

            return _canExplicitlyInteract(ctx, resourceTenantAlias, targetResources, callback, _illegalTargetResourceIds);
        });
    }
};
