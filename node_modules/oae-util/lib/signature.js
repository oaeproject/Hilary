/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var Crypto = require('crypto');
var fs = require('fs');

var log = require('oae-logger').logger('signature');

var Validator = require('oae-util/lib/validator').Validator;

var signKey = null;

/**
 * Initialize the Signature module with the signature key
 * @param  {Object}    keys    The object that holds all the keys in the system.
 * @param  {String}    signing The key that can be used to securely sign messages.
 */
var init = module.exports.init = function(signingConfig) {
    signKey = signingConfig.key;

    if (signKey === 'The default signing key, please change me.') {
        var warningMessage = 'You are using the default key to sign URLs, this is *NOT* secure and should be changed immediately.\n';
        warningMessage += 'The system will continue to function, but it is strongly recommended that you change your key.\n';
        log().warn(warningMessage);
    }
};

/**
 * Sign a string with our key.
 *
 * @param  {String}  tenantAlias    The alias that identifies which tenant this message originates from.
 * @param  {String}  body           The string to sign.
 * @return {String}                 A signature.
 */
var sign = module.exports.sign = function(tenantAlias, body) {
    var msg = tenantAlias + '#' + body;
    var hmac = Crypto.createHmac('sha1', signKey);
    hmac.update(msg);
    return hmac.digest('hex');
};

/**
 * Verify that the passed in signature matches the body.
 *
 * @param  {String}     tenantAlias     The alias that identifies which tenant the message originated from.
 * @param  {String}     body            The body that was originally signed.
 * @param  {String}     signature       The signature that was passed in by the user.
 * @return {Boolean}                    Whether or not the body was untampered with
 */
var verify = module.exports.verify = function(tenantAlias, body, signature) {
    var msg = tenantAlias + '#' + body;
    var hmac = Crypto.createHmac('sha1', signKey);
    hmac.update(msg);
    return hmac.digest('hex') === signature;
};

/**
 * Creates a signature that is valid for `expires` amount of minutes.
 *
 * @param  {String}     tenantAlias     The alias that identifies which tenant this message originates from.
 * @param  {Number}     expires         The number of milliseconds this signature is valid.
 * @param  {String}     body            The body that needs signing
 * @return {Object}                     An object with a `signature` key that holds the signature and a `expires` key which holds the timestamp when the signature will expire.
 */
var createExpiringSignature = module.exports.createExpiringSignature = function(tenantAlias, expires, body) {
    var ts = Date.now() + expires;
    var msg = ts + '#' + body;
    var signature = sign(tenantAlias, msg);
    return {
        'signature': signature,
        'expires' : ts
    };
};



/**
 * Creates a rolling signature. This is useful for creating URLs that are cacheable for a certain period of time.
 * Note: This will *NOT* create a signature that expires in exactly <duration> seconds.
 * You can specify an offset to eliminate the problem of having a signature expire between
 * handing it out to the user and the user using it to access a protected resource.
 *
 * Assume that is Thu Jan 25 2013 11:40:46 in the examples.
 * Examples:
 *   Create a signature that is valid for an interval of 30 seconds, with a 10 sec offset
 *   $ createRollingSignature('cam', 30, 10, 'foo')
 *   Thu Jan 25 2013 11:41:10
 *   Explanation:
 *    -> The current time is 11:40:46
 *    -> The 30 second interval starts at 11:40:30
 *    -> Calculate when it expires: 11:41:00
 *    -> Add the extra 10 second offset: 11:41:10
 *
 *
 *   Create a signature that is valid for an interval of 30 days, with a 1 day offset
 *   $ createRollingSignature('cam', 2592000, 86400, 'foo')
 *   Thu Jan 25 2013 11:41:10
 *   Explanation:
 *    -> The current time is 11:40:46
 *    -> The 30 day interval starts at 15 January 2013
 *    -> Calculate when it expires: 14 February 2013
 *    -> Add the extra 1 day offset: 15 February 2013
 * @param  {String}     tenantAlias     The alias that identifies which tenant this message originates from.
 * @param  {Number}     duration        The maximum duration in seconds that the signature should be valid.
 * @param  {Number}     [offset]        The amount of seconds that should be added to the duration. This allows you to have a grace period between handing out a signature and validating it.
 * @param  {String}     body            The body that needs signing
 * @return {Object}                     An object with a `signature` key that holds the signature and a `expires` key which holds the timestamp when the signature will expire.
 */
var createRollingSignature = module.exports.createRollingSignature = function(tenantAlias, duration, offset, body) {
    offset = offset || 0;

    // Convert the durations to milli seconds.
    duration *= 1000;
    offset *= 1000;

    // Get the beginning of the period.
    var start = Math.floor(Date.now() / duration) * duration;

    // This signature expires at the end of the period (start+duration) plus the extra offset.
    var expiresAt = new Date(start + duration + offset);

    // Create the signature
    return createExpiresAtSignature(tenantAlias, expiresAt, body);
};

/**
 * Verifies if the signature matches a given body.
 * The `expires` value will be taken into account and checked against the current time.
 *
 * @param  {String}     tenantAlias     The alias that identifies which tenant the message originated from.
 * @param  {Number}     expires         A timestamp in ms when this signature expires.
 * @param  {String}     body            The body that the signature was placed on.
 * @param  {String}     signature       The signature as generated by `createExpiringSignature`.
 * @return {Boolean}                    Whether or not the signature is valid.
 */
var verifyExpiringSignature = module.exports.verifyExpiringSignature = function(tenantAlias, expires, body, signature) {
    // Check the expiry date.
    if (Date.now() > expires) {
        return false;
    }

    // Check the signature.
    var msg = expires + '#' + body;
    return verify(tenantAlias, msg, signature);
};



/**
 * Creates a signature that is valid till the `expiresAt` date.
 *
 * @param  {String}     tenantAlias     The alias that identifies which tenant this message originates from.
 * @param  {Date}       expiresAt       The date when the signature should expire.
 * @param  {String}     body            The body that needs signing
 * @return {Object}                     An object with a `signature` key that holds the signature and an `expires` key which holds the timestamp when the signature will expire.
 */
var createExpiresAtSignature = module.exports.createExpiresAtSignature = function(tenantAlias, expiresAt, body) {
    var msg = expiresAt.getTime() + '#' + body;
    var signature = sign(tenantAlias, msg);
    return {
        'signature': signature,
        'expires' : expiresAt.getTime()
    };
};

/**
 * Check whether or not a signature is valid.
 *
 * @param  {String} tenantAlias     The alias that identifies which tenant the message originated from.
 * @param  {String} body            The body that was used to generate the signature.
 * @see verify
 */
Validator.prototype.verifySignature = function(tenantAlias, body) {
    if (!this.str || !verify(tenantAlias, body, this.str)) {
        this.error(this.msg || 'Invalid signature');
    }
    return this;
};

/**
 * Check whether or not an expiring signature is valid.
 *
 * @param  {String} tenantAlias     The alias that identifies which tenant the message originated from.
 * @param  {Number} expires         The timestamp in ms when the signature expires.
 * @param  {String} body            The body that was used to generate the signature.
 * @see verifyExpiringSignature
 */
Validator.prototype.verifyExpiringSignature = function(tenantAlias, expires, body) {
    if (!this.str || !verifyExpiringSignature(tenantAlias, expires, body, this.str)) {
        this.error(this.msg || 'Invalid signature');
    }
    return this;
};
