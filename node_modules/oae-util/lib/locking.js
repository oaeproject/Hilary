/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var ShortId = require('shortid');
var util = require('util');

var log = require('oae-logger').logger('oae-util-locking');
var Redis = require('./redis');
var Validator = require('./validator').Validator;

/**
 * Try and acquire a temporary lock with the specified key. The lock key should be unique to your module, so it
 * would be best to namespace it accordingly. For example:
 *
 *  "oae-activity:bucket:lock"
 *
 * @param  {String}    lockKey         The key of the lock to try and acquire
 * @param  {Number}    expiresIn       Maximum number of seconds for which to hold the lock
 * @param  {Function}  callback        Invoked when the lock has been acquired (or failed to be acquired)
 * @param  {Object}    callback.err    An error that occurred, if any
 * @param  {String}    callback.token  An identifier for the lock that was granted. If unspecified, the lock was already held by someone else
 */
var acquire = module.exports.acquire = function(lockKey, expiresIn, callback) {
    var validator = new Validator();
    validator.check(lockKey, {'code': 400, 'msg': 'The key of the lock to try and acquire needs to be specified'}).notNull();
    validator.check(expiresIn, {'code': 400, 'msg': 'The maximum number of seconds for which to hold the lock needs to be specified'}).notNull();
    validator.check(expiresIn, {'code': 400, 'msg': 'The maximum number of seconds for which to hold the lock needs to be an integer'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    log().trace({'lockKey': lockKey}, 'Trying to acquire lock.');

    Redis.getClient().get(lockKey, function(err, token) {
        if (err) {
            return callback(err);
        } else if (!token) {
            // There is no lock yet, try and acquire one
            return _acquire(lockKey, expiresIn, callback);
        }

        // Make sure this lock has a ttl associated to it. If it doesn't it means that the process
        // that locked it crashed after it locked (setnx) but before it could apply the ttl (setex)
        _ensureTtl(lockKey, token, expiresIn);

        // It was already locked, return empty-handed
        return callback();
    });
};

/**
 * Release a lock
 *
 * @param  {String}     lockKey             The unique key for the lock to release
 * @param  {String}     token               The identifier of the lock that was given when the lock was acquired
 * @param  {Function}   callback            Invoked when the lock has been released
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.hadLock    Specifies whether or not we actually released a lock
 */
var release = module.exports.release = function(lockKey, token, callback) {
    var validator = new Validator();
    validator.check(lockKey, {'code': 400, 'msg': 'The key of the lock to try and release needs to be specified'}).notNull();
    validator.check(token, {'code': 400, 'msg': 'The identifier of the lock that was given when the lock was acquired needs to be specified'}).notNull();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    Redis.getClient().get(lockKey, function(err, lockedToken) {
        if (err) {
            return callback(err);
        } else if (lockedToken !== token) {
            log().trace({'lockKey': lockKey}, 'Attempted to release a lock that we did not have');
            // There is either no lock with this key, or we no longer hold the lock
            return callback(null, false);
        }

        Redis.getClient().del(lockKey, function(err) {
            if (err) {
                return callback(err);
            }

            log().trace({'lockKey': lockKey}, 'Released a lock');
            return callback(null, true);
        });
    });
};

/**
 * Acquire a lock with a given key. This is an internal method which does not check if the lock is already locked.
 *
 * @param  {String}    lockKey         The key of the lock to acquire.
 * @param  {Number}    expiresIn       The maximum amount of time, in seconds, the lock should be alive for.
 * @param  {Function}  callback        Invoked when the lock has been (or has failed to be) acquired.
 * @param  {Object}    callback.err    An error that occurred, if any.
 * @param  {String}    callback.token  The token that was given for this lock. If unspecified, someone else took the lock before we could.
 * @api private
 */
var _acquire = function(lockKey, expiresIn, callback) {
    var token = _createToken();
    // When getting a fresh lock, we use setnx, which is atomic and will tell us if we successfully set the value
    Redis.getClient().setnx(lockKey, token, function(err, wasSet) {
        if (err) {
            return callback(err);
        } else if (wasSet !== 1) {
            // We failed to acquire the lock
            log().trace({'key': lockKey}, 'Tried to acquire a lock when it was already locked');
            return callback();
        }

        log().trace({'key': lockKey, 'token': token}, 'Acquired a lock');

        // We successfully set the lock. Set the key to expire and return
        _ensureTtl(lockKey, token, expiresIn);
        return callback(null, token);
    });
};

/**
 * Ensures that a ttl for the given lock key is set. If it isn't, we will apply the given
 * `expiresIn` seconds for ttl.
 *
 * @param  {String}     lockKey         The key on which to ensure the ttl
 * @param  {String}     val             The value of the entry to set along with the ttl if the ttl was not set
 * @param  {Number}     expiresIn       The ttl (in seconds) to apply to the key if it is not set
 * @api private
 */
var _ensureTtl = function(lockKey, val, expiresIn) {
    // Since `ttl` returns -1 both when "the key does not exist" and "the key exists with no ttl", we need to
    // check that it both exists and has a ttl. This is because the lock may have been released sometime
    // before this _ensureTtl executed, which is completely valid, and we will set a temporary deadlock if we
    // execute `setex` as a result of a -1 ttl
    var multi = Redis.getClient().multi();
    multi.exists(lockKey);
    multi.ttl(lockKey);
    multi.exec(function(err, results) {
        if (err) {
            return callback(err);
        }

        var exists = (results[0] === 1);
        var ttl = results[1];
        if (exists && ttl === -1) {
            // The key exists but does not have a ttl, so we set one
            Redis.getClient().setex(lockKey, expiresIn, val, function(err) {
                if (err) {
                    // This is the best we can do, we don't want to explode or anything
                    return log().warn({
                        'err': err,
                        'lockKey': lockKey,
                        'value': val,
                        'expiresIn': expiresIn
                    }, 'Failed to apply a TTL to a lock.');
                }
            });
        }
    });
};

/**
 * Generate a token that can be used to identify a lock being held.
 *
 * @return {String}    A random unique token that can be used to release a lock later
 * @api private
 */
var _createToken = function() {
    return ShortId.generate();
};
