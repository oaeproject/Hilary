/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var ShortId = require('shortid');
var util = require('util');

var Cassandra = require('oae-util/lib/cassandra');
var log = require('oae-logger').logger('oae-activity');
var OaeUtil = require('oae-util/lib/util');

var ActivitySystemConfig = require('./config');
var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;

/**
 * Get a list of activities from the specified activity stream.
 *
 * @param   {String}        activityStreamId    The ID of the activity stream, which can currently only be a user or group id
 * @param   {Number|String} start               Number of millis since the epoc (stringified or number version) from which to start returning activities. Only activities older than this timestamp will be returned.
 * @param   {Number}        limit               The number of activities to return
 * @param   {Function}      callback            Invoked when the process completes
 * @param   {Object}        callback.err        An error that occurred, if any
 * @param   {Activity[]}    callback.activities The list of activities
 */
var getActivities = module.exports.getActivities = function(activityStreamId, start, limit, callback) {
    limit = OaeUtil.getIntParam(limit, 25);

    var paging = Cassandra.getPagingParameters(start, limit);

    // Selecting with consistency ONE as having great consistency is not critical for activities
    // Using '0' as the low value, can never have a timestamp lower than that
    Cassandra.runQuery('SELECT FIRST ' + paging.limit + ' REVERSED ? .. \'0\' FROM ActivityStreams USING CONSISTENCY ONE WHERE activityStreamId = ?', [paging.start, activityStreamId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        return callback(null, _rowToActivities(rows[0], paging.startIndex));
    });
};

/**
 * Deliver the given routed activities to their specified routes. The routed activities should be given in the format:
 *
 * ```
 * {
 *     '<route id 0>': {
 *         '<activity id 0>': {Activity},
 *         '<activity id 1>': {Activity},
 *         ...
 *     },
 *     '<route id 1>': {
 *         ...
 *     },
 *     ...
 * }
 * ```
 *
 * @param   {Object}    routedActivities    An object keyed by the route id (a.k.a., activity stream id), whose value is an object of activities to be delivered, keyed by their activity id.
 * @param   {Function}  callback            Invoked when the activities have been delivered
 * @param   {Object}    callback.err        An error that occurred, if any
 */
var deliverActivities = module.exports.deliverActivities = function(routedActivities, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Error delivering routed activities.');
        }
    };
    
    var queries = [];
    _.each(routedActivities, function(activities, route) {
        var query = Cassandra.constructUpsertCQL('ActivityStreams', 'activityStreamId', route, activities, null, ActivitySystemConfig.getConfig().activityTtl);
        if (query) {
            queries.push(query);
        } else {
            log().warn({'route': route, 'activities': activities}, 'Failed to create a query while delivering activities. Skipping');
        }
    });

    // Saving activities with consistency ONE because consistency is not critical for activities
    Cassandra.runBatchQuery(queries, 'ONE', callback);
};

/**
 * Delete the specified activities from specific routes.
 *
 * @param   {Object}    routeActivityIds    An object keyed by route, whose value is an array of string activityIds that should be deleted from the route
 * @param   {Function}  callback            Invoked when the activities have been deleted
 * @param   {Object}    callback.err        An error that occurred, if any
 */
var deleteActivities = module.exports.deleteActivities = function(routeActivityIds, callback) {
    var routes = _.keys(routeActivityIds);
    if (routes.length === 0) {
        return callback();
    }

    var queries = [];
    routes.forEach(function(route) {
        var activityIds = routeActivityIds[route];
        if (activityIds.length === 0) {
            return;
        }

        var placeholders = [];
        var params = [];
        activityIds.forEach(function(activityId) {
            placeholders.push('?');
            params.push(activityId);
        });
        params.push(route);

        queries.push({
            'query': 'DELETE ' + placeholders.join(', ') + ' FROM ActivityStreams WHERE activityStreamId = ?',
            'parameters': params
        });
    });

    Cassandra.runBatchQuery(queries, 'ONE', callback);
};

/**
 * Save the given routed activities to the specified queue buckets. A routed activity is essentially an Activity object that
 * is stored along with the route to which it should be delivered:
 *
 * `{ 'route': 'u:oae:mrvisser', 'activity': { <Activity Object> }}`
 *
 * @param   {Object[][]}    activityBuckets     An array whose index represents the bucket number, and whose value represents the array of routed activities to queue into the bucket.
 * @param   {Function}      callback            Invoked when the routed activities have been queued for processing
 * @param   {Object}        callback.err        An error that occurred, if any
 */
var saveQueuedActivities = module.exports.saveQueuedActivities = function(activityBuckets, callback) {
    if (activityBuckets.length === 0) {
        return callback();
    }

    var now = Date.now();
    var queries = [];
    for (var i = 0; i < activityBuckets.length; i++) {
        var activityBucket = activityBuckets[i];
        if (activityBucket && activityBucket.length) {
            var sets = [];
            var params = [];
            activityBucket.forEach(function(routedActivity) {
                sets.push('? = ?');
                // By prefixing with the activity id, activities are ordered such that older activities are collected before newer ones
                // An example column name is: 123456789:PVTjensl:u:oae:mrvisser
                params.push(util.format('%s:%s', routedActivity.activity[ActivityConstants.properties.OAE_ACTIVITY_ID], routedActivity.route));
                params.push(JSON.stringify(routedActivity));
            });

            params.push(i);

            queries.push({
                'query': 'UPDATE ActivityProcessingBuckets SET ' + sets.join(', ') + ' WHERE bucketId = ?',
                'parameters': params
            });
        }
    }

    Cassandra.runBatchQuery(queries, 'QUORUM', callback);
};

/**
 * Get the queued activities from the given bucket number for processing.
 *
 * @param   {Number}    bucketNumber                The bucket from which to fetch the queued activities
 * @param   {Number}    limit                       How many routed activities to fetch from the queue
 * @param   {Function}  callback                    Invoked when the process completes
 * @param   {Object}    callback.err                An error that occurred, if any
 * @param   {Object}    callback.routedActivities   The routed activities that were queued in the bucket. The key is the internally created id of the entry (which can be used to later delete the entry), and value is a routed activity, as documented in #saveQueuedActivities
 */
var getQueuedActivities = module.exports.getQueuedActivities = function(bucketNumber, limit, callback) {
    limit = OaeUtil.getIntParam(limit, ActivitySystemConfig.getConfig().collectionBatchSize);
    Cassandra.runQuery('SELECT FIRST ' + limit + ' * FROM ActivityProcessingBuckets USING CONSISTENCY QUORUM WHERE bucketId = ?', [bucketNumber], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var queuedActivities = {};
        rows[0].forEach(function(name, value) {
            try {
                queuedActivities[name] = JSON.parse(value);
            } catch (err) {
                log().warn({'err': err}, 'Error parsing queued activity from bucket %s', bucketNumber);
                // We still need to return this value as the caller will want to know this key exists for deletion
                queuedActivities[name] = null;
            }
        });

        return callback(null, queuedActivities);
    });
};

/**
 * Delete the queued activities with the given ids.
 *
 * @param   {Number}    bucketNumber        The number of the bucket from which to delete the queued activities
 * @param   {String[]}  queuedActivityIds   An array of activities that should be deleted from the bucket
 * @param   {Function}  callback            Invoked when the routed activities have been deleted
 * @param   {Object}    callback.err        An error that occurred, if any
 */
var deleteQueuedActivities = module.exports.deleteQueuedActivities = function(bucketNumber, queuedActivityIds, callback) {
    if (queuedActivityIds.length === 0) {
        return callback();
    }

    var placeholders = [];
    var params = [];
    queuedActivityIds.forEach(function(queuedActivityId) {
        placeholders.push('?');
        params.push(queuedActivityId);
    });

    params.push(bucketNumber);

    Cassandra.runQuery('DELETE ' + placeholders.join(', ') + ' FROM ActivityProcessingBuckets USING CONSISTENCY QUORUM WHERE bucketId = ?', params, callback);
};

/**
 * Get the aggregation status for the aggregates identified by the given aggregate keys. Can be used to determine if any aggregates
 * are currently aggregating, expired, the id of the last activity delivery, etc... An example status looks like:
 *
 * ```javascript
 *  {
 *      'lastActivity': 'PTeijwe',      // The ID of the last activity that was delivered for the aggregate
 *      'lastUpdated': 123456789,       // The timestamp (millis since epoch) that the last activity matched this aggregate
 *      'lastCollected': 123456780,     // The timestamp (millis since epoch) since the aggregate was last collected
 *      'created': 123448430            // The timestamp (millis since epoch) since the aggregate was created
 *  }
 * ```
 *
 * @param   {String[]}  aggregateKeys               The aggregate keys for which to fetch the aggregate status
 * @param   {Function}  callback                    Invoked when the process completes
 * @param   {Object}    callbcak.err                An error that occurred, if any
 * @param   {Object}    callback.aggregateStatus    An object, keyed by the aggregate key, whose value is the status of the aggregate
 */
var getAggregateStatus = module.exports.getAggregateStatus = function(aggregateKeys, callback) {
    if (aggregateKeys.length === 0) {
        return callback(null, {});
    }

    var aggregateStatus = {};
    Cassandra.runQuery('SELECT * FROM ActivityAggregateStatus USING CONSISTENCY QUORUM WHERE aggregateKey IN (?)', [aggregateKeys], function(err, rows) {
        if (err) {
            return callback(err);
        }

        rows.forEach(function(row) {
            var status = Cassandra.rowToHash(row);
            if (!status.lastUpdated) {
                return;
            }
            aggregateStatus[status.aggregateKey] = status;
        });

        return callback(null, aggregateStatus);
    });
};

/**
 * Update a set of aggregate status with a new status.
 *
 * @param   {Object}    statusUpdates   An object keyed by aggregate key whose values are the new status information for the aggregate
 * @param   {Function}  callback        Invoked when the aggregates have been updated
 * @param   {Object}    callback.err    An error that occurred, if any
 */
var updateAggregateStatus = module.exports.updateAggregateStatus = function(statusUpdates, callback) {
    var aggregateKeys = _.keys(statusUpdates);
    if (aggregateKeys.length === 0) {
        return callback();
    }

    var queries = [];
    aggregateKeys.forEach(function(aggregateKey) {
        var query = Cassandra.constructUpsertCQL('ActivityAggregateStatus', 'aggregateKey', aggregateKey, statusUpdates[aggregateKey], null, ActivitySystemConfig.getConfig().aggregateMaxExpiry);
        if (query) {
            queries.push(query);
        } else {
            log().warn({'statusUpdate': statusUpdates[aggregateKey]}, 'Failed to persist update for aggregate status.');
        }
    });

    Cassandra.runBatchQuery(queries, 'QUORUM', callback);
};

/**
 * Delete all the aggregation data associated to the given aggregate keys. This includes both the status and the aggregated entities.
 *
 * @param   {String[]}  aggregateKeys   The aggregate keys whose history to delete
 * @param   {Function}  callback        Invoked when the aggregation history has been deleted
 * @param   {Object}    callback.err    An error that occurred, if any
 */
var deleteAggregates = module.exports.deleteAggregates = function(aggregateKeys, callback) {
    if (aggregateKeys.length === 0) {
        return callback();
    }

    // Delete both the aggregated entities and the aggregate status
    var queries = [
        {
            'query': 'DELETE FROM ActivityAggregateStatus WHERE aggregateKey IN (?)',
            'parameters': [aggregateKeys]
        },
        {
            'query': 'DELETE FROM ActivityAggregateEntities WHERE aggregateKey IN (?)',
            'parameters': [aggregateKeys]
        }
    ];

    Cassandra.runBatchQuery(queries, 'QUORUM', callback);
};

/**
 * Get all the entities that have been aggregated for the aggregate key. The resulting object holds all the actors, objects and targets
 * that have been aggregated for the aggregate key. This is an example of how the object is represented:
 *
 * ```javascript
 *  {
 *      '<aggregateKey0>': {
 *          'actors': {
 *              '<entityKey0>': { <Entity> },
 *              '<entityKey1>': { <Entity> }
 *          },
 *          'objects': {
 *              '<entityKey2>': { <Entity> },
 *              '<entityKey3>': { <Entity> }
 *          },
 *          'targets': {
 *              '<entityKey4>': { <Entity> }
 *          }
 *      },
 *      '<aggregateKey1>': { ... },
 *      ...
 *  }
 * ```
 *
 * @param   {String[]}  aggregateKeys               The aggregate keys for which to fetch the aggregated entities
 * @param   {Function}  callback                    Invoked when the process completes
 * @param   {Object}    callback.err                An error that occurred, if any
 * @param   {Object}    callback.aggregatedEntities An object holding the entities that have been aggregated for the entities. See summary for more information
 */
var getAggregatedEntities = module.exports.getAggregatedEntities = function(aggregateKeys, callback) {
    if (aggregateKeys.length === 0) {
        return callback(null, {});
    }

    var entityAggregateKeys = [];
    aggregateKeys.forEach(function(aggregateKey) {
        entityAggregateKeys.push(aggregateKey + '#actors', aggregateKey + '#objects', aggregateKey + '#targets');
    });

    var aggregatedEntities = {};
    Cassandra.runQuery('SELECT * FROM ActivityAggregateEntities USING CONSISTENCY QUORUM WHERE aggregateKey IN (?)', [entityAggregateKeys], function(err, rows) {
        if (err) {
            return callback(err);
        }

        rows.forEach(function(row) {

            // The aggregateKey in ActivityAggregateEntities is discriminated by entity type (e.g., <aggregateKey>#actors). Here we
            // split out the entityType (last part) and have just the aggregateKey and the entityType ("actors")
            var aggregateKey = row.key.split('#');
            var entityType = aggregateKey.pop();
            aggregateKey = aggregateKey.join('#');

            aggregatedEntities[aggregateKey] = aggregatedEntities[aggregateKey] || {
                'actors': {},
                'objects': {},
                'targets': {}
            };

            row.forEach(function(name, value) {
                // Don't include the primary key column
                if (name === 'aggregateKey') {
                    return;
                }

                try {
                    // The entityType will be one of actors, objects or targets
                    aggregatedEntities[aggregateKey][entityType][name] = JSON.parse(value);
                } catch (err) {
                    log().warn({
                        'err': err,
                        'aggregateKey': aggregateKey,
                        'entityKey': name
                    }, 'Error parsing entity from aggregated activity entities. Skipping.');
                }
            });
        });

        return callback(null, aggregatedEntities);
    });
};

/**
 * Save the aggregated entities for the specified aggregates.
 *
 * @param   {Object}    aggregates      An object keyed by aggregateKey whose value is an aggregate object containing the `actors`, `objects` and `targets` entities to add to the aggregated entities
 * @param   {Function}  callback        Invoked when the aggregates have been saved
 * @param   {Object}    callback.err    An error that occurred, if any
 */
var saveAggregatedEntities = module.exports.saveAggregatedEntities = function(aggregates, callback) {
    if (_.isEmpty(aggregates)) {
        return callback();
    }

    var queries = [];
    _.each(aggregates, function(aggregate, aggregateKey) {
        queries.push(_getAggregatedEntityQuery(aggregateKey, aggregate, 'actors'));
        queries.push(_getAggregatedEntityQuery(aggregateKey, aggregate, 'objects'));
        queries.push(_getAggregatedEntityQuery(aggregateKey, aggregate, 'targets'));
    });

    // Pluck out the false queries that did not have any objects or targets
    queries = _.compact(queries);
    Cassandra.runBatchQuery(queries, 'QUORUM', callback);
};

/**
 * Create a unique string identifier for an activity that was posted at the given publishing date.
 *
 * @param   {Number}    published   The time (millis since the epoch) that the activity was published.
 * @return  {String}                A unique identifier for the activity.
 */
var createActivityId = module.exports.createActivityId = function(published) {
    // An example activity id is: 123456789:PTewoief
    return util.format('%s:%s', published, ShortId.generate());
};

/**
 * For an aggregate, create the Cassandra query needed to update the aggregate with the new entities of the specified plural form of the
 * `entityType` (i.e., 'actors', 'objects' or 'targets').
 *
 * @param  {String}     aggregateKey    The unique key of the aggregate
 * @param  {Object}     aggregate       The activity aggregate that holds the entities to save
 * @param  {String}     entityType      The (plural) type of entity to create the query for. One of 'actors', 'objects' or 'targets'
 * @return {Object}                     A query that can be added to a list of batch queries that adds/updates the entities for the given aggregate and entityType
 * @api private
 */
var _getAggregatedEntityQuery = function(aggregateKey, aggregate, entityType) {
    // The key for the aggregated entity row will be an aggregate key (<activityType>#<route>#<actorKey>#<objectKey>#<targetKey>)
    // appended by either '#actors', '#objects' or '#targets', denoting which type of aggregate entity it will be holding
    var key = util.format('%s#%s', aggregateKey, entityType);
    return Cassandra.constructUpsertCQL('ActivityAggregateEntities', 'aggregateKey', key, aggregate[entityType], null, ActivitySystemConfig.getConfig().aggregateMaxExpiry);
};

/**
 * Convert a Cassandra row into an array of activities extracted from its columns.
 *
 * @param  {Row}       row                 The Cassandra row from which to extract the activities
 * @param  {Number}    firstColumnIndex    The index of the first column to start returning activities. Used for paging so that the first inclusive activity may be ommitted.
 * @return {Object}                        The activities that were extracted from the rows
 * @api private
 */
var _rowToActivities = function(row, firstColumnIndex) {
    var activities = [];
    var i = 0;
    row.forEach(function(name, value) {
        if (i >= firstColumnIndex) {
            try {
                activities.push(JSON.parse(value));
            } catch (err) {
                log().warn({'err': err}, 'Error parsing activity value.');
            }
        }

        i++;
    });
    return activities;
};


