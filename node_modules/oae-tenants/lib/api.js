/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var EventEmitter = require('events').EventEmitter;
var OAE = require('oae-util/lib/oae');
var Cassandra = require('oae-util/lib/cassandra');
var Pubsub = require('oae-util/lib/pubsub');
var Validator = require('oae-util/lib/validator').Validator;
var log = require('oae-logger').logger('oae-tenants');

var Tenant = require('./model').Tenant;

var runningServers = {};
var tenantAliasByHost = {};

var emitter = module.exports = new EventEmitter();

Pubsub.on('oae-tenants', function (message) {
    // Commands are of the form:
    //     start cam
    //     stop cam
    var args = message.split(' ');
    var cmd = args.shift();
    var alias = args.shift();

    // Get the tenant and emit the event.
    getTenantByAlias(alias, function(err, tenant) {
        if (err) {
            return log().error({err: err}, 'There was an error retrieving the tenant: %s', alias);
        }

        emitter.emit(cmd, tenant);
    });
});

emitter.on('start', function(tenant) {
    _startTenant(tenant, function(err, disabled) {
        if (err) {
            log().error({err: err}, 'Could not initialize tenant %s', tenant.alias);
        } else {
            if (disabled) {
                log().info({tenant: tenant.alias}, 'Tenant (%s) on port %d initialized (disabled)', tenant.alias);
            } else {
                log().info({tenant: tenant.alias}, 'Tenant (%s) initialized.', tenant.alias);
            }
        }
    });
});

emitter.on('stop', function(tenant) {
    _stopTenant(tenant, function(err) {
        if (err) {
            log().error({err: err, tenant: tenant.alias}, 'Error stopping tenant %s', tenant.alias);
        } else {
            log().info({tenant: tenant.alias}, 'Tenant %s stopped.', tenant.alias);
        }
    });
});

/**
 * Initialize the middleware that will put the tenant onto the request and cache all of the registered
 * tenants.
 *
 * @param  {Object}         config          JSON object containing configuration values for Cassandra, Redis, logging and telemetry
 * @param  {Function}       callback        Standard callback function
 * @param  {Object}         callback.err    Error object containing the error code and message
 */
var initializeTenantMiddleware = module.exports.initializeTenantMiddleware = function(config, callback) {
    // This middleware adds the tenant to each request on the global admin server.
    OAE.globalAdminServer.use(function(req, res, next) {
        req.tenant = {
            'isGlobalAdminServer': true,
            'alias': config.servers.globalAdminAlias
        };
        return next();
    });

    // This middleware adds the tenant to each request on the user tenant server.
    OAE.tenantServer.use(function(req, res, next) {
        // Get the tenant alias by the request host
        var tenantAlias = tenantAliasByHost[req.headers.host];
        req.tenant = runningServers[tenantAlias];
        if (!req.tenant) {
            // We stop the request if we can't find a tenant associated to the current hostname
            res.setHeader('Connection', 'Close');
            return res.send(418, 'This hostname is not associated to any tenant');
        }

        // Check whether or not the tenant has been disabled
        if (req.tenant.disabled) {
            // If we're disabled, there is no point in keeping connections open.
            res.setHeader('Connection', 'Close');
            return res.send(503, 'This server is currently disabled. Please check back later.');
        }
        next();
    });

    // Get all tenants and cache them by their host
    getAllTenants(function(err, tenants) {
        if (err) {
            return callback(err);
        }

        _.each(tenants, function(tenant, tenantAlias) {
            runningServers[tenantAlias] = tenant;

            // Hold a tenantHost -> tenantAlias mapping for quick mapping on requests
            tenantAliasByHost[tenant.host] = tenantAlias;
        });

        callback();
    });
};

/**
 * Get all the tenants for purposes for filling the REST context. Note that the tenant information
 * may be out-dated as the data is not refreshed when tenants are updated.
 *
 * FIXME: This would be better off being covered by `getAllTenants`, however:
 *
 *  a)  `getAllTenants` currently needs to be the most recent data for a tenant; and
 *  b)  the in-memory caching system needs to be improved to update across the cluster; and
 *  c)  fetch from Cassandra each time on `getAllTenants` has unacceptable performance for
 *      accessing on every request to build a context.
 *
 *  Once in-memory storage of tenants is properly managed across the cluster, this method can
 *  be removed in favour of a more performant version of `getAllTenants`.
 *
 * @return  {Object}    A hash keyed by tenant alias, whose value is the (possibly outdated) Tenant object.
 */
var getTenantsForContext = module.exports.getTenantsForContext = function() {
    return _.extend({}, runningServers);
};

/**
 * Publishes a message that a new tenant should be started.
 * Note that the actual server startup will happen asynchronous from this method.
 *
 * @param  {Tenant}     tenant          The tenant object representing the tenant to be started
 * @param  {Function}   callback        A callback method
 * @param  {Object}     callback.err    An error object (if any)
 */
var startTenant = module.exports.startTenant = function(tenant, callback) {
    Pubsub.publish('oae-tenants', 'start ' + tenant.alias, callback);
};

/**
 * Start a new tenant by listening on the provided ports.
 *
 * @param  {Tenant}     tenant                      The tenant object representing the tenant to be started
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error object (if any)
 * @param  {Boolean}    callback.disabled           Whether or not this tenant is disabled.
 * @api private
 */
var _startTenant = function(tenant, callback) {
    callback = callback || function() {};
    if (tenant) {
        if (runningServers[tenant.alias]) {
            // We already created the server object.
            // Enable the tenant
            runningServers[tenant.alias].disabled = !tenant.active;
            callback(null, !tenant.active);
        } else {
            // Keep all the servers in memory so we can access them later.
            runningServers[tenant.alias] = tenant;
            runningServers[tenant.alias].disabled = !tenant.active;
            tenantAliasByHost[tenant.host] = tenant.alias;
        }
    } else {
        callback({'code': 400, 'msg': 'No tenant was provided.'});
    }
};

/**
 * Stops a running tenant.
 *
 * @param   {Tenant}    tenant          The tenant object representing the tenant to be stopped
 * @param   {Function}  callback        Standard callback function
 * @param   {Object}    callback.err    An error object (if any.)
 * @api private
 */
var _stopTenant = function(tenant, callback) {
    if (tenant && runningServers[tenant.alias]) {
        // Disable that server
        runningServers[tenant.alias].disabled = true;
        callback();
    } else {
        callback({'code': 404, 'msg': 'No server found on that port.'});
    }
};

/**
 * Disable or enable a tenant
 * 
 * @param  {Context}      ctx             The current context
 * @param  {String[]}     aliases         An array of aliases representing the tenants that should be stopped.
 * @param  {Boolean}      disabled        True if the tenant needs to be disabled
 * @param  {[Function]}   callback        Callback function executed when request is completed.
 * @param  {Object}       callback.err    An error object (if any.)
 */
var disableTenants = module.exports.disableTenants = function(ctx, aliases, disabled, callback) {
    callback = callback || function() {};

    if (!ctx.user() || !ctx.user().isGlobalAdmin()) {
        return callback({'code': 401, 'msg': 'Unauthorized users cannot disable or enable tenants'});
    }

    if (!aliases) {
        return callback({'code': 400, 'msg': 'Please provide at least one tenant alias'});
    }
    
    if (!Array.isArray(aliases)) {
        aliases = [aliases];
    }

    // Store the activity flag in cassandra.
    var queries = [];
    for (var i = 0; i < aliases.length; i++) {
        queries.push({
            'query': 'UPDATE Tenant SET active = ? WHERE alias = ?',
            'parameters': [!disabled, aliases[i]]
        });
    }
    Cassandra.runBatchQuery(queries, 'QUORUM', function(err) {
        if (err) {
            return callback(err);
        }

        // Broadcast the message accross the cluster
        // so we can start/stop the tenants.
        var cmd = disabled ? 'stop' : 'start';
        for (var i = 0; i < aliases.length; i++) {
            Pubsub.publish('oae-tenants', cmd + ' ' + aliases[i], callback);
        }
    });
};

/**
 * Rather than physically deleting a tenant, we just disable it for now.
 *
 * @param  {Context}   ctx             The current context
 * @param  {String[]}  aliases         An array of aliases representing the tenants that should be deleted.
 * @param  {Function}  callback        Callback function executed when request is completed.
 * @param  {Object}    callback.err    An error object (if any.)
 */
var deleteTenants = module.exports.deleteTenants = function(ctx, aliases, callback) {
    callback = callback || function() {};

    if (!ctx.user() || !ctx.user().isGlobalAdmin()) {
        return callback({'code': 401, 'msg': 'Unauthorized users cannot delete tenants'});
    }

    if (!aliases) {
        return callback({'code': 400, 'msg': 'Please provide a ports array'});
    }
    if (!Array.isArray(aliases)) {
        aliases = [aliases];
    }

    var queries = [];
    for (var i = 0; i < aliases.length; i++) {
        queries.push({
            'query': 'UPDATE Tenant SET active = ?, deleted = ? WHERE alias = ?',
            'parameters': [false, true, aliases[i]]
        });
    }
    Cassandra.runBatchQuery(queries, 'QUORUM', function(err) {
        if (err) {
            return callback(err);
        }
        // Broadcast the message accross the cluster
        // so we can stop the tenants.
        for (var i = 0; i < aliases.length; i++) {
            Pubsub.publish('oae-tenants', 'stop ' + aliases[i], callback);
        }
    });
};

/**
 * Get all the tenants in the datastore.
 *
 * @param  {Function}  callback            Standard callback function
 * @param  {Object}    callback.err        Error object containing the error message
 * @param  {Object}    callback.tenants    An object keyed by tenant alias holding all the (non-deleted) tenants in the data-store
 */
var getAllTenants = module.exports.getAllTenants = function(callback) {
    Cassandra.runQuery('SELECT * FROM Tenant USING CONSISTENCY QUORUM', false, function(err, rows) {
        if (err) {
            return callback(err);
        }

        var tenants = {};
        for (var i = 0; i < rows.length; i++) {
            var tenant = mapToTenant(rows[i], false);
            if (!tenant.deleted) {
                tenants[tenant.alias] = tenant;
            }
        }
        callback(null, tenants);
    });
};

/**
 * Get the unique tenant by their alias.
 *
 * @param  {String}    alias               The alias assigned to the tenant
 * @param  {Function}  callback            A function(err, tenant) specifying the tenant requested
 * @param  {Object}    callback.err        Error object containing the error message and error code
 * @param  {Tenant}    callback.tenant     The tenant object that uses the provided alias
 */
var getTenantByAlias = module.exports.getTenantByAlias = function(alias, callback) {
    Cassandra.runQuery('SELECT * FROM Tenant USING CONSISTENCY QUORUM WHERE alias = ?', [alias], function(err, rows) {
        if (err) {
            return callback(err);
        }

        if (rows[0].count > 1) {
            var tenant = mapToTenant(rows[0]);
            callback(null, tenant);
        } else {
            callback({'code': 404, 'msg': 'There is no tenant with alias ' + alias});
        }
    });
};

/**
 * Create a tenant using the provided information.
 *
 * @param  {Context}    ctx             The current context
 * @param  {String}     alias           The unique alias assigned to the tenant
 * @param  {String}     name            A descriptive short name for the tenant
 * @param  {String}     host            The host on which this tenant is proxying (ie: oae.cam.ac.uk or oae.gatech.edu)
 * @param  {Function}   callback        A function(err, tenant) specifying the tenant information that was persisted.
 * @param  {Object}     callback.err    An error object (if any)
 * @param  {Tenant}     callback.tenant The tenant that was persisted.
 */
var createTenant = module.exports.createTenant = function(ctx, alias, name, host, callback) {
    callback = callback || function() {};

    if (!ctx.user() || !ctx.user().isGlobalAdmin()) {
        return callback({'code': 401, 'msg': 'Unauthorized users cannot create tenants'});
    }

    var validator = new Validator();
    validator.check(alias, {'code': 400, 'msg': 'Missing alias'}).notEmpty();
    validator.check(alias, {'code': 400, 'msg': 'The tenant alias should not contain a colon'}).notContains(':');
    validator.check(name, {'code': 400, 'msg': 'Missing tenant name'}).notEmpty();
    validator.check(host, {'code': 400, 'msg': 'Missing tenant host'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getTenantByAlias(alias, function(err, tenant) {
        if (!tenant) {
            tenant = new Tenant(alias, name, host, true, false);
            // no tenant by this alias or port exist, create one
            Cassandra.runQuery('UPDATE Tenant USING CONSISTENCY QUORUM SET name = ?, host = ?, active = ? WHERE alias = ?',
                [tenant.name, host, tenant.active, tenant.alias], function(err) {
                if (err) {
                    return callback(err);
                }
                // Send a message to all the app servers in the cluster that they
                // should start up the tenant.
                module.exports.startTenant(tenant, function(err) {
                    // Let the configuration module know that a new tenant has been created and configuration needs to be fetched
                    Pubsub.publish('oae-config', tenant.alias);
                    if (err) {
                        return callback(err);
                    }
                    callback(null, tenant);
                });
            });
        } else {
            callback({'code': 400, 'msg': 'A tenant with the alias ' + alias + ' already exists'});
        }
    });
};

/**
 * Updates the basic information of a tenant
 *
 * @param  {Context}   ctx            The current context.
 * @param  {String}    alias          The alias of the tenant we want to update
 * @param  {String}    name           The updated name for the tenant
 * @param  {Function}  callback       A function(err) executed after the tenant has been updated
 * @param  {Object}    callback.err   An error object (if any)
 */
var updateTenant = module.exports.updateTenant = function(ctx, alias, name, callback) {
    if (!ctx.user() || !ctx.user().isAdmin(ctx.user().tenant)) {
        return callback({'code': 401, 'msg': 'Unauthorized users cannot update tenants'});
    }

    var validator = new Validator();
    validator.check(name, {'code': 400, 'msg': 'Missing name'}).notEmpty();
    validator.check(alias, {'code': 400, 'msg': 'Missing alias'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    Cassandra.runQuery('UPDATE Tenant USING CONSISTENCY QUORUM SET name = ? WHERE alias = ?', [name, alias], callback);
};

/**
 * Get the tenant aliases of all the running tenants.
 *
 * @return  {String[]}  The unique tenant aliases of all running tenants
 */
var getRunningTenantAliases = module.exports.getRunningTenantAliases = function() {
    return _.keys(runningServers);
};

/**
 * Map a cassandra row element to a tenant object.
 *
 * @param  {Row}      row            The row to be mapped
 * @param  {Boolean}  returnDeleted  ignored?
 * @return {Tenant}                  A tenant corresponding to the row
 * @api private
 */
var mapToTenant = function(row, returnDeleted) {
    var hash = Cassandra.rowToHash(row);
    return new Tenant(hash.alias, hash.name, hash.host, hash.active, hash.deleted);
};
