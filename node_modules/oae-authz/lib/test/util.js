/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');
var url = require('url');

var LibraryAPI = require('oae-library');
var OaeUtil = require('oae-util/lib/util');
var RestAPI = require('oae-rest');
var SearchTestUtil = require('oae-search/lib/test/util');

var AuthzAPI = require('oae-authz');
var AuthzDelete = require('oae-authz/lib/delete');
var AuthzInvitationsDAO = require('oae-authz/lib/invitations/dao');
var AuthzUtil = require('oae-authz/lib/util');

var PrincipalsTestUtil = require('oae-principals/lib/test/util');

/**
 * Delete the given resource by its id and ensure it completes successfully
 *
 * @param  {String}         resourceId      The id of the resource to try and delete
 * @param  {Function}       callback        Invoked when all assertions pass
 * @throws {AssertionError}                 Thrown if any assertions fail
 */
var assertSetDeletedSucceeds = module.exports.assertSetDeletedSucceeds = function(resourceId, callback) {
    // Apply the delete operation
    AuthzDelete.setDeleted(resourceId, function(err) {
        assert.ok(!err);

        // Verify that it shows up being deleted
        return assertIsDeletedSucceeds([resourceId], [resourceId], callback);
    });
};

/**
 * Restore the given resource by its id and ensure it completes successfully
 *
 * @param  {String}         resourceId      The id of the resource to try and restore
 * @param  {Function}       callback        Invoked when all assertions pass
 * @throws {AssertionError}                 Thrown if any assertions fail
 */
var assertUnsetDeletedSucceeds = module.exports.assertUnsetDeletedSucceeds = function(resourceId, callback) {
    // Apply the delete operation
    AuthzDelete.unsetDeleted(resourceId, function(err) {
        assert.ok(!err);

        // Verify that it doesn't show up as being deleted
        return assertIsDeletedSucceeds([resourceId], [], callback);
    });
};

/**
 * Accept the invitation pending for the given email address, ensuring the process succeeds
 *
 * @param  {RestContext}    restContext             The context of the current request
 * @param  {String}         email                   The email for which to accept the invitation
 * @param  {Function}       callback                Invoked when all assertions pass
 * @param  {Object}         callback.result         The result of the accept invitation request
 * @param  {Invitation[]}   callback.invitations    The invitations that were pending for the email
 * @param  {String}         callback.token          The token that was associated to the email
 * @throws {AssertionError}                         Thrown if any assertions fail
 */
var assertAcceptInvitationForEmailSucceeds = module.exports.assertAcceptInvitationForEmailSucceeds = function(restContext, email, callback) {
    email = email.toLowerCase();
    AuthzInvitationsDAO.getTokensByEmails([email], function(err, emailTokens) {
        assert.ok(!err);

        var token = emailTokens[email];
        assertAcceptInvitationSucceeds(restContext, token, function(result, invitations) {
            // Be swell and give the token to the caller so they can try and re-use it if they dare
            return callback(result, invitations, token);
        });
    });
};

/**
 * Accept the invitation pending for the given token, ensuring the process succeeds
 *
 * @param  {RestContext}    restContext             The context of the current request
 * @param  {String}         token                   The invitation token to accept
 * @param  {Function}       callback                Invoked when all assertions pass
 * @param  {Object}         callback.result         The result of the accept invitation request
 * @param  {Invitation[]}   callback.invitations    The invitations that were pending for the token
 * @throws {AssertionError}                         Thrown if any assertions fail
 */
var assertAcceptInvitationSucceeds = module.exports.assertAcceptInvitationSucceeds = function(restContext, token, callback) {
    PrincipalsTestUtil.assertGetMeSucceeds(restContext, function(me) {
        AuthzInvitationsDAO.getEmailByToken(token, function(err, email) {
            assert.ok(!err);

            // Get the invitations before accepting so we can provide them to the caller
            AuthzInvitationsDAO.getAllInvitationsByEmail(email, function(err, invitationsBefore) {
                assert.ok(!err);

                // Perform the accept action
                RestAPI.Invitations.acceptInvitation(restContext, token, function(err, result) {
                    assert.ok(!err);

                    // Get all the invitations again and ensure they're now empty for that email
                    AuthzInvitationsDAO.getAllInvitationsByEmail(email, function(err, invitationsAfter) {
                        assert.ok(!err);
                        assert.strictEqual(invitationsAfter.length, 0);

                        // Ensure libraries and search have time to finish indexing
                        LibraryAPI.Index.whenUpdatesComplete(function() {
                            SearchTestUtil.whenIndexingComplete(function() {
                                // Respond with the invitations
                                return callback(result, invitationsBefore);
                            });
                        });
                    });
                });
            });
        });
    });
};

/**
 * Attempt to accept the invitation pending for the given token, ensuring the process fails in the
 * specified manner
 *
 * @param  {RestContext}    restContext             The context of the current request
 * @param  {String}         token                   The invitation token to accept
 * @param  {Number}         httpCode                The expected HTTP code of the accept invitation request
 * @param  {Function}       callback                Invoked when all assertions pass
 * @param  {Object}         callback.result         The result of the accept invitation request
 * @param  {Invitation[]}   callback.invitations    The invitations that were pending for the token
 * @throws {AssertionError}                         Thrown if any assertions fail
 */
var assertAcceptInvitationFails = module.exports.assertAcceptInvitationFails = function(restContext, token, httpCode, callback) {
    // Get invitations before attempting to accept, if applicable. Since this a failure scenario, it
    // is possible that the token is completely invalid
    OaeUtil.invokeIfNecessary(token, AuthzInvitationsDAO.getEmailByToken, token, function(err, email) {
        OaeUtil.invokeIfNecessary(email, AuthzInvitationsDAO.getAllInvitationsByEmail, email, function(err, invitationsBefore) {

            // Perform the accept
            RestAPI.Invitations.acceptInvitation(restContext, token, function(err) {
                assert.ok(err);
                assert.strictEqual(err.code, httpCode);

                // Ensure we get the same result from querying invitations to ensure that failing to
                // accept the invitation did not trash them
                OaeUtil.invokeIfNecessary(email, AuthzInvitationsDAO.getAllInvitationsByEmail, email, function(err, invitationsAfter) {
                    assert.deepEqual(invitationsBefore, invitationsAfter);
                    return callback();
                });
            });
        });
    });
};

/**
 * Get the invitations associated to the resource id for the specified resource type
 *
 * @param  {RestContext}    restContext             The context of the current request
 * @param  {String}         resourceType            The type of resource for which to get invitations
 * @param  {String}         resourceId              The id of the resource
 * @param  {Function}       callback                Invoked when all assertions pass
 * @param  {Invitation[]}   callback.invitations    The invitations that are pending for the resource
 * @throws {AssertionError}                         Thrown if any assertions fail
 */
var assertGetInvitationsSucceeds = module.exports.assertGetInvitationsSucceeds = function(restContext, resourceType, resourceId, callback) {
    RestAPI.Invitations.getInvitations(restContext, resourceType, resourceId, function(err, result) {
        assert.ok(!err);
        return callback(result);
    });
};

/**
 * Atempt to get the invitations associated to the resource id for the specified resource type,
 * ensuring it fails in the specified manner
 *
 * @param  {RestContext}    restContext             The context of the current request
 * @param  {String}         resourceType            The type of resource for which to get invitations
 * @param  {String}         resourceId              The id of the resource
 * @param  {Number}         httpCode                The expected HTTP code of the get invitation request
 * @param  {Function}       callback                Invoked when all assertions pass
 * @param  {Invitation[]}   callback.invitations    The invitations that are pending for the resource
 * @throws {AssertionError}                         Thrown if any assertions fail
 */
var assertGetInvitationsFails = module.exports.assertGetInvitationsFails = function(restContext, resourceType, resourceId, httpCode, callback) {
    RestAPI.Invitations.getInvitations(restContext, resourceType, resourceId, function(err, result) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        return callback(result);
    });
};

/**
 * Resend the invitations associated to the resource id for the specified resource type and email
 *
 * @param  {RestContext}    restContext             The context of the current request
 * @param  {String}         resourceType            The type of resource for which to resend an invitation
 * @param  {String}         resourceId              The id of the resource
 * @param  {String}         email                   The email of the resource invitation
 * @param  {Function}       callback                Invoked when all assertions pass
 * @throws {AssertionError}                         Thrown if any assertions fail
 */
var assertResendInvitationSucceeds = module.exports.assertResendInvitationSucceeds = function(restContext, resourceType, resourceId, email, callback) {
    RestAPI.Invitations.resendInvitation(restContext, resourceType, resourceId, email, function(err) {
        assert.ok(!err);
        return callback();
    });
};

/**
 * Attempt to resend the invitations associated to the resource id for the specified resource type
 * and email, ensuring it fails in the specified manner
 *
 * @param  {RestContext}    restContext             The context of the current request
 * @param  {String}         resourceType            The type of resource for which to resend an invitation
 * @param  {String}         resourceId              The id of the resource
 * @param  {String}         email                   The email of the resource invitation
 * @param  {Number}         httpCode                The expected HTTP code of the resend invitation request
 * @param  {Function}       callback                Invoked when all assertions pass
 * @throws {AssertionError}                         Thrown if any assertions fail
 */
var assertResendInvitationFails = module.exports.assertResendInvitationFails = function(restContext, resourceType, resourceId, email, httpCode, callback) {
    RestAPI.Invitations.resendInvitation(restContext, resourceType, resourceId, email, function(err) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        return callback();
    });
};

/**
 * Check that the `isDeleted` response is successful and indicates the expected resources are
 * deleted
 *
 * @param  {String[]}       resourceIdsToCheck  The ids of the resources to check for being deleted
 * @param  {String[]}       deletedResourceIds  The only resource ids we expected to be deleted
 * @param  {Function}       callback            Invoked when all assertions pass
 * @throws {AssertionError}                     Thrown if any assertions fail
 */
var assertIsDeletedSucceeds = module.exports.assertIsDeletedSucceeds = function(resourceIdsToCheck, deletedResourceIds, callback) {
    AuthzDelete.isDeleted(resourceIdsToCheck, function(err, deleted) {
        assert.ok(!err);

        // Ensure the expected resource ids and only those ones appear as being deleted
        assert.strictEqual(_.keys(deleted).length, deletedResourceIds.length);
        _.each(deletedResourceIds, function(deletedResourceId) {
            assert.strictEqual(deleted[deletedResourceId], true);
        });

        return callback();
    });
};

/**
 * Check that the resource members graph returns the expected set of members
 *
 * @param  {String[]}       resourceIds     The ids of the resources whose members graph to get
 * @param  {String[][]}     expectedIds     An array of arrays contains the members lists we expect to get from the resource id at the same index in `resourceIds`
 * @param  {Function}       callback        Invoked when the assertions have succeeded on the members graph
 * @param  {AuthzGraph}     callback.graph  The members graph of the provided resource
 * @throws {AssertionError}                 Thrown if the graph wasn't as expected
 */
var assertAuthzMembersGraphIdsEqual = module.exports.assertAuthzMembersGraphIdsEqual = function(resourceIds, expectedIds, callback) {
    AuthzAPI.getAuthzMembersGraph(resourceIds, function(err, graph) {
        assert.ok(!err);

        var actualIds =
            _.chain(resourceIds)
                .map(function(resourceId) {
                    // Ensure all the ids are sorted since there is no contract for traversal order
                    return _.pluck(graph.traverseIn(resourceId), 'id').sort();
                })
                .value();

        // Ensure all the ids are sorted since there is no contract for traversal order
        expectedIds = _.map(expectedIds, function(ids) {
            return ids.slice().sort();
        });

        assert.deepEqual(actualIds, expectedIds);
        return callback(graph);
    });
};

/**
 * Check that the principal memberships graph returns the expected set of memberships
 *
 * @param  {String}         principalId     The id of the principal whose memberships graph to get
 * @param  {String[]}       expectedIds     The expected membership ids
 * @param  {Function}       callback        Invoked when the assertions have succeeded on the memberships graph
 * @param  {AuthzGraph}     callback.graph  The memberships graph of the provided principal
 * @throws {AssertionError}                 Thrown if the graph wasn't as expected
 */
var assertPrincipalMembershipsGraphIdsEqual = module.exports.assertPrincipalMembershipsGraphIdsEqual = function(principalId, expectedIds, callback) {
    AuthzAPI.getPrincipalMembershipsGraph(principalId, function(err, graph) {
        assert.ok(!err);
        assert.deepEqual(_.pluck(graph.traverseOut(principalId), 'id').sort(), expectedIds.slice().sort());
        return callback(graph);
    });
};

/**
 * Ensure that the provided actual membership is equal to the expected membership after the
 * membership delta has been applied to the actual membership. All memberships objects are the
 * standard authz membership representation where the key is the principal id and the value is the
 * role the user has on some resource
 *
 * @param  {Object}     membershipBeforeDelta   The actual membership before any membership updates
 * @param  {Object}     [membershipDelta]       The actual changes that were applied to the membership. If not specified, the actual membership will be compared directly with the expected membership without change
 * @param  {Object}     membershipAfterDelta    The membership after the updates (if any) are applied
 * @throws {AssertionError}                     Thrown if the membership after the delta is not equal to the initial membership with the delta applied
 */
var assertMemberRolesEquals = module.exports.assertMemberRolesEquals = function(before, delta, after) {
    // Narrow down the deltas to only resource roles
    var principalIdDelta = {};
    _.each(delta, function(role, targetId) {
        var target = AuthzUtil.parseShareTarget(targetId);
        if (target.principalId) {
            principalIdDelta[target.principalId] = role;
        }
    });

    _assertDeltaEquals(before, principalIdDelta, after);
};

/**
 * Ensure that the provided actual email roles are equal to the expected email roles after the
 * delta has been applied to the actual email roles. All email roles objects are the standard authz
 * membership representation where the key is the principal id and the value is the role the user
 * has on some resource
 *
 * @param  {Object}     membershipBeforeDelta   The actual membership before any membership updates
 * @param  {Object}     [membershipDelta]       The actual changes that were applied to the membership. If not specified, the actual membership will be compared directly with the expected membership without change
 * @param  {Object}     membershipAfterDelta    The membership after the updates (if any) are applied
 * @throws {AssertionError}                     Thrown if the membership after the delta is not equal to the initial membership with the delta applied
 */
var assertEmailRolesEquals = module.exports.assertEmailRolesEquals = function(before, delta, after) {
    // Narrow down the deltas to only email roles
    var emails = _.chain(delta)
        .keys()
        .map(AuthzUtil.parseShareTarget)
        .filter(function(target) {
            return (!target.principalId);
        })
        .pluck('email')
        .value();
    delta = _.chain(delta)
        .oaeMapKeys(_toLowerCase)
        .pick(emails)
        .value();
    after = _.oaeMapKeys(after, _toLowerCase);
    _assertDeltaEquals(before, delta, after);
};

/**
 * Create a memberships graph based on the one provided
 *
 * @param  {AuthzGraph}     graph       The graph representing the memberships
 * @param  {Function}       callback    Invoked when the memberships graph has been created
 * @throws {AssertionError}             Thrown if there is an error persisting the memberships graph
 */
var assertCreateMembershipsGraphSucceeds = module.exports.assertCreateMembershipsGraphSucceeds = function(graph, callback, _ops) {
    if (!_ops) {
        _ops = _.chain(graph.getNodes())
            .pluck('id')
            .filter(function(parentId) {
                return (!_.isEmpty(graph.getInEdgesOf(parentId)));
            })
            .map(function(parentId) {
                var roles = {};
                _.each(graph.getInEdgesOf(parentId), function(edge) {
                    roles[edge.from.id] = edge.role || 'member';
                });

                return {'id': parentId, 'roles': roles};
            })
            .value();

        return assertCreateMembershipsGraphSucceeds(graph, callback, _ops);
    } else if (_.isEmpty(_ops)) {
        return callback();
    }

    var op = _ops.shift();
    AuthzAPI.updateRoles(op.id, op.roles, function(err) {
        assert.ok(!err);
        return assertCreateMembershipsGraphSucceeds(graph, callback, _ops);
    });
};

/**
 * Create an object that can be used to update resource roles from a list of principal ids and a
 * specified role to apply
 *
 * @param  {String[]}           principalIds    The ids of the principals whose role to change on a resource
 * @param  {String|Boolean}     role            The role to apply, or `false` if the change is to remove the principal from the resource
 * @return {Object}                             The role change object keyed by principal ids, where the value is the role change to apply
 */
var createRoleChange = module.exports.createRoleChange = function(principalIds, role) {
    var roleChange = {};
    _.each(principalIds, function(principalId) {
        roleChange[principalId] = role;
    });
    return roleChange;
};

/**
 * Get a simple `MemberRoles` object from a list of member profiles along with their roles
 *
 * @param  {Object[]}       members     The array of member objects containing `profile` and `role` returned from the content members library
 * @return {MemberRoles}                The member roles in the library result
 */
var getMemberRolesFromResults = module.exports.getMemberRolesFromResults = function(members) {
    var memberRoles = {};
    _.each(members, function(member) {
        memberRoles[member.profile.id] = member.role;
    });
    return memberRoles;
};

/**
 * Get a simple EmailRoles object from a list of invitations
 *
 * @param  {Invitation[]}   invitation  The invitations from which to extract the emails and roles
 * @return {EmailRoles}                 The email roles in the invitation list
 */
var getEmailRolesFromResults = module.exports.getEmailRolesFromResults = function(invitations) {
    var emailRoles = {};
    _.each(invitations, function(invitation) {
        emailRoles[invitation.email] = invitation.role;
    });
    return emailRoles;
};

/**
 * Given an email message, parse the invitation URL out of it, if any. If there is no invitation
 * url, then an assertion error is thrown
 *
 * @param  {Object}         message     The email message
 * @return {String}                     The invitation url
 * @throws {AssertionError}             Thrown if there is no invitation url
 */
var parseInvitationUrlFromMessage = module.exports.parseInvitationUrlFromMessage = function(message) {
    var match = message.html.match(/href="(https?:\/\/[^\/]+\/signup\?url=%2Fme%3FinvitationToken%3D[^"]+)"/);

    assert.ok(match);
    assert.strictEqual(match.length, 2);
    return url.parse(match[1], true);
};

/**
 * Ensure that when the `delta` IdRoles is applied to the `before` IdRoles, the result equals that
 * of the `after` IdRoles
 *
 * @param  {IdRoles}        before  The base id roles
 * @param  {IdRoles}        delta   The id role changes to apply
 * @param  {IdRoles}        after   The expected result from applying the `delta` to the `before`
 * @throws {AssertionError}         Thrown if the  `delta` application does not result in the `after` roles
 * @api private
 */
var _assertDeltaEquals = function(before, delta, after) {
    var expectedAfter = _.extend({}, before);
    _.each(delta, function(role, id) {
        if (role === false) {
            delete expectedAfter[id];
        } else {
            expectedAfter[id] = role;
        }
    });

    assert.deepEqual(after, expectedAfter);
};

/**
 * Lower case the given string
 *
 * @param  {String}     str     The string to lower case
 * @return {String}             The string in lower case
 * @api private
 */
var _toLowerCase = function(str) {
    return str.toLowerCase();
};
