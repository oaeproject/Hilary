/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var events = require('events');
var fs = require('fs');
var less = require('less');
var path = require('path');
var readdirp = require('readdirp');
var util = require('util');
var watch = require('watch');

var ConfigAPI = require('oae-config');
var IO = require('oae-util/lib/io');
var Validator = require('oae-util/lib/validator').Validator;
var log = require('oae-logger').logger('oae-ui');

var UIConstants = require('./constants').UIConstants;

// The Config object for the UI module.
var uiConfig = ConfigAPI.config('oae-ui');

// The cached skin variables
var cachedSkinVariables = null;
// The cached skins per tenant.
var cachedSkins = {};


// Path to the 3akai-ux repository
var uiDirectory = null;

// A mapping object that maps pre-optimized paths to post-optimized paths in the UI
var hashes = null;

// A dictionary that will hold the content for each file. This will be lazy filled. The first
// time a particular file is requested, it will be cached. After that, the cached version will
// be used
var staticFileCache = {};

// A dictionary that will hold the widget manifests for all widgets. This will be filled upon
// initialization.
var widgetManifestCache = {};


/**
 * The UI API.
 *
 * ## Events
 *
 * * `skinParsed` - Invoked when the skin file has been parsed or re-parsed on the application node.
 */
var UIAPI = module.exports = new events.EventEmitter();
var emitter = UIAPI;

////////////////////
// Initialization //
////////////////////

/**
 * This will find all of the widget config files in the UI repository and cache. For development,
 * it will also put watches on the files in the UI repository in order to invalidate the cache
 * when a file has been changed/removed.
 *
 * @param  {String}     uiDirectory     The path to the directory containing the UI repository.
 * @param  {Object}     hashes          A mapping that will map pre-optimized paths to hashed, post-optimized static asset paths
 * @param  {Function}   callback        Standard callback method.
 * @param  {Object}     callback.err    An error object (if any)
 */
var init = module.exports.init = function(_uiDirectory, _hashes, callback) {
    // Cache the ui directory path and make sure we have the absolute path
    uiDirectory = _uiDirectory;
    hashes = _hashes;

    // Cache all of the widget manifest files
    cacheWidgetManifests();

    // Monitor the UI repository for changes and refresh the cache.
    // This will only be done in development mode
    if (process.env['NODE_ENV'] !== 'production') {
        watch.createMonitor(uiDirectory, {'ignoreDotFiles': true}, function(monitor) {
            monitor.on('created', updateFileCaches);
            monitor.on('changed', updateFileCaches);
            monitor.on('removed', updateFileCaches);
        });
    }

    // Cache the base skin file.
    _cacheSkinVariables(function(err) {
        if (err) {
            return callback(err);
        }

        // Ensure the skins are not cached, as they may be invalid now
        cachedSkins = {};
        return callback();
    });
};

ConfigAPI.on('update', function(tenantAlias) {
    // Re-generate the skin.
    // Don't delete it from the cache just yet as we might still be serving requests.
    _generateSkin(tenantAlias, function(err) {
        if (err) {
            log().error({'err': err, 'tenantAlias': tenantAlias}, 'Could not re-cache the tenant skin after a config update.');
        }

        emitter.emit('skinParsed');
    });
});


/////////////
// Caching //
/////////////

/**
 * When a file in the UI repository has changed, we update the static file cache by deleting
 * the record for that file if there is one. The next time the updated/created file will be
 * re-requested, caching will be attempted again. We also check if the changed file is a
 * widget manifest file, and refresh the widget manifest cache if that's the case
 *
 * @param  {String}     filename        The absolute path to the file that has been added/updated/deleted
 * @api private
 */
var updateFileCaches = function(filename) {
    filename = filename.replace(uiDirectory, '');
    // Delete the file from the static file cache, for it to be re-cached
    // when it is requested again
    delete staticFileCache[filename];
    // If the changed file is a widget config file, we re-cache the widget
    // config files
    if (/^\/node_modules\/(.*?)\/manifest.json$/.test(filename)) {
        cacheWidgetManifests();
    // If the changed file is the base skin file, we re-cache it.
    } else if (filename === UIConstants.paths.BASE_SKIN) {
        // The skin file has changed, reset the skin files, they will be lazy loaded.
        cachedSkins = {};

        // Retrieve the skin variables.
        _cacheSkinVariables(function(err) {
            if (err) {
                log().error({'err': err}, 'Could not cache the skin variables after a file update.');
            }
        });
    }
};

///////////////////////////////
// Widget config aggregation //
///////////////////////////////

/**
 * Get the aggregated list of widget manifests.
 *
 * @return {Object}     An object where each key is the widget id and the value is the widget manifest.
 */
var getWidgetManifests = module.exports.getWidgetManifests = function() {
    return widgetManifestCache;
};

/**
 * Cache all widget manifests under the UI's node_modules directory
 *
 * @api private
 */
var cacheWidgetManifests = function() {
    widgetManifestCache = {};
    // Cache all of the widget config files under node_modules
    readdirp({ 'root': uiDirectory + '/node_modules/', 'directoryFilter': ['!.bin'], 'fileFilter': 'manifest.json' })
        .on('data', function (entry) {
            // Extract the widget id from the path, which is expected
            // to be the final part of the path
            var widgetId = entry.parentDir.split(path.sep).pop();
            try {
                var widgetManifest = fs.readFileSync(entry.fullPath, 'utf8');
                widgetManifestCache[widgetId] = JSON.parse(widgetManifest);
            } catch (err) {
                widgetManifestCache[widgetId] = {};
                log().error({'err': err, 'widgetId': widgetId, 'path': entry.fullPath}, 'Could not parse the widget manifest file.');
            }
            widgetManifestCache[widgetId].id = widgetId;
            widgetManifestCache[widgetId].path = entry.parentDir + '/';
        })
        .on('warn', function (err) { log().warn({'err': err}, 'A non-fatal error occured whilst caching the config schema'); })
        .on('error', function (err) { log().error({'err': err}, 'A fatal error occured whilst caching the config schema'); });
};

//////////////////
// Static batch //
//////////////////

/**
 * Get the content of a set of static files. The returned data is an object where the key is the requested URL and
 * the values are the static file contents. In case the file couldn't be found, null will be returned.
 *
 * @param  {String[]}    files           An array of file paths relative to the UI repository.
 * @param  {Function}    callback        Standard callback method.
 * @param  {Object}      callback.err    An error object (if any)
 * @param  {Object}      callback.data   JSON Object representing the retrieved files.
 */
var getStaticBatch = module.exports.getStaticBatch = function(files, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 400, 'msg': 'The files parameter must be an array'}).isArray(files);
    // Filter out the duplicate ones
    files = _.uniq(files);
    // Make sure that all provided filenames are real strings
    for (var i = 0; i < files.length; i++) {
        validator.check(files[i], {'code': 400, 'msg': 'A valid file path needs to be provided'}).notEmpty();
        // Make sure that only absolute paths are allowed. All paths that contain a '../' have the potential of
        // exposing private server files
        validator.check(files[i], {'code': 400, 'msg': 'Only absolute paths are allowed'}).notContains('../');
    }
    validator.check(files.length, {'code': 400, 'msg': 'At least one file must be provided'}).min(1);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var results = {};
    files.forEach(function(file) {
        getStaticFile(file, function(err, data) {
            if (err) {
                results[file] = null;
            } else {
                results[file] = data;
            }

            // Check if all of them have returned
            if (_.keys(results).length === files.length) {
                callback(null, results);
            }
        });
    });
};

/**
 * Get the content of a static file and cache it if it hasn't been cached yet. This will only
 * open the file on disk if the file could not be found in the cache.
 *
 * @param  {String}      path            The path for the static file to open. A path should be relative to the UI repository
 * @param  {Function}    callback        Standard callback method
 * @param  {Object}      callback.err    An error object containing the error code and message
 * @param  {String}      callback.data   The file content for the requested file
 * @api private
 */
var getStaticFile = function(path, callback) {
    // Try to retrieve the file content from cache
    if (staticFileCache[path]) {
        callback(null, staticFileCache[path]);
    } else {
        cacheFile(path, callback);
    }
};

/**
 * Reads a file's content and cache it.
 *
 * @param  {String}      path                The path for the file that needs to be read
 * @param  {Function}    callback            Standard callback function
 * @param  {Object}      callback.err        An error object containing the error code and message
 * @param  {String}      callback.data       The data that sits in the file.
 * @api private
 */
var cacheFile = function(path, callback) {
    IO.readFile(uiDirectory + path, function(err, data) {
        if (err) {
            return callback(err);
        }

        // Cache the file content
        staticFileCache[path] = data;
        callback(null, data);
    });
};


//////////////
// SKINNING //
//////////////

/**
 * Sorts an array of sections, containing subsubsections, to reflect the order in which they appear in the less file.
 * It also removes the `index` property from each section and its subsections.
 *
 * @param  {Section[]}  The array of sections that should be sorted.
 * @return {Section[]}  The sorted array of sections as they appear in the less file.
 * @api private
 */
var sortSections = function(sections) {
    /*!
     * A comparator that can be used to sort an array of sections or subsections.
     *
     * @param  {Section}    sectionA    First section to compare.
     * @param  {Section}    sectionB    Second section to compare.
     * @return {Number}                 An integer that expresses the relative order of the passed in sections.
     */
    var comparator = function(sectionA, sectionB) {
        return (sectionA.index - sectionB.index);
    };

    // Sort the top level sections.
    sections.sort(comparator);

    // Give all of the subsections the same order as the one they have in the LESS file.
    _.each(sections, function(section) {
        section.subsections = _.values(section.subsections).sort(comparator);

        // Remove the unneeded index property of each section.
        delete section.index;
        // Remove the unneeded index property of each subsection
        _.each(section.subsections, function(subsection) {
            delete subsection.index;
        });
    });
    return sections;
};

/**
 * Get the skin file for the current tenant.
 *
 * @param  {Context}    ctx             Standard context object, representing the currently logged in user and its tenant
 * @param  {Function}   callback        Standard callback method.
 * @param  {Object}     callback.err    An error object (if any)
 * @param  {String}     callback.css    The generated CSS.
 */
var getSkin = module.exports.getSkin = function(ctx, callback) {
    var tenantAlias = ctx.tenant().alias;
    if (cachedSkins[tenantAlias]) {
        return callback(null, cachedSkins[tenantAlias]);
    } else {
        _generateSkin(tenantAlias, callback);
    }
};

/**
 * Retrieve the LESS variables that are present in the skin file.
 * Each variable will be annotated with the tenant value.
 *
 * @param  {Context}    ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}     [tenantAlias]       The optional alias of the tenant for which the variables should be retrieved. If no tenant alias is provided, the current tenant will be used.
 * @param  {Function}   callback            Standard callback method.
 * @param  {Object}     callback.err        An error object (if any)
 * @param  {Object[]}   callback.variables  The generated CSS.
 */
var getSkinVariables = module.exports.getSkinVariables = function(ctx, tenantAlias, callback) {
    tenantAlias = tenantAlias || ctx.tenant().alias;

    if (!ctx.user() || !ctx.user().isAdmin(tenantAlias)) {
        return callback({'code': 401, 'msg': 'Only administrators can retrieve the skin variables.'});
    }

    var applyTenantValues = function(err, skinVariables) {
        if (err) {
            return callback(err);
        }
        // Get the values for this tenant.
        var tenantVariables = _getTenantSkinVariableValues(tenantAlias);

        // Extend the skin variables into a new object, so we don't overwrite the global object.
        var variables = _.extend({}, skinVariables);

        // Add in the value.
        _.each(tenantVariables, function(value, key) {
            if (key && variables[key]) {
                variables[key].value = value;
            }
        });

        /*!
         * Morph it to a structure that the UI can use.
         *
         * We'll return an array of sections, which are defined in the LESS file through `@section`.
         * Each section can have a number of subsections, used to subdivide variables inside of a given
         * section.
         *
         * By default, each section will have a `main` subsection that contains all of the variables
         * that are not part of a specific subsection. This will be followed by all of the other subsections,
         * which are defined in the LESS file through @subsection.
         *
         * Each subsection will have one or more CSS variables that will be used for skinning through
         * the Admin UI.
         *
         * ex:
         *   [
         *      {
         *          'name': 'Section name A',
         *          'subsections': [
         *              {
         *                  'name': 'main',
         *                  'variables': [ <var A_V1>, <var A_V2>, ... ]
         *              },
         *              {
         *                  'name': <subsection A_S1>,
         *                  'variables': [ <var A_V3>, <var a_V4>, ... ]
         *              },
         *              ...
         *          ]
         *      },
         *      ...
         *   ]
         */
        var sections = {};
        _.each(variables, function(variable, name) {
            // Make sure that the section exists
            sections[variable.section.name] = sections[variable.section.name] || {
                'name': variable.section.name,
                'index': variable.section.index,
                'subsections': {}
            };
            // Make sure that the subsection exists
            var section = sections[variable.section.name];
            section.subsections[variable.subsection.name] = section.subsections[variable.subsection.name] || {
                'name': variable.subsection.name,
                'index': variable.subsection.index,
                'variables': []
            };
            // Add the variable to subsection's list of variables
            section.subsections[variable.subsection.name].variables.push(variable);
        });

        // Give the section the the same order as the one it has in the LESS file.
        sections = sortSections(_.values(sections));

        callback(null, sections);
    };


    if (cachedSkinVariables) {
        applyTenantValues(null, cachedSkinVariables);
    } else {
        _cacheSkinVariables(applyTenantValues);
    }
};

/**
 * Get the configured UI directory path
 *
 * @return {String}                     The configured UI directory path
 */
var getUIDirectory = module.exports.getUIDirectory = function() {
    return uiDirectory;
};

/**
 * Generates the skin file for a tenant.
 *
 * @param  {String}     tenantAlias     The alias of the tenant for which the skin should be generated.
 * @param  {Function}   callback        Standard callback method.
 * @param  {Object}     callback.err    An error object (if any)
 * @param  {String}     callback.css    The generated CSS.
 * @api private
 */
var _generateSkin = function(tenantAlias, callback) {

    // Get all the default variables in the skin, as well as the tenant overrides
    var allVariables = _getDefaultSkinVariableValues();
    var tenantVariables = _getTenantSkinVariableValues(tenantAlias);

    // Merge the default and tenant variables, tenant variables having precedence
    _.extend(allVariables, tenantVariables);

    // Parse the less file and supply the tenant values.
    _parseLessFile(allVariables, function(err, tree) {
        if (err) {
            return callback(err);
        }

        // Generate some CSS from the parse tree and cache it.
        // See http://lesscss.org/#usage (Configuration) for more information.
        try {
            cachedSkins[tenantAlias] = tree.toCSS({
                'cleancss': true,
                'compress': true
            });
        } catch (error) {
            return callback({'code': 500, 'msg': error.message});
        }

        callback(null, cachedSkins[tenantAlias]);
    });
};

/**
 * Parses a LESS file and return the syntax tree.
 * You can pass in variables with some values that will override any values in the less file.
 * This can be used to set the tenant values and generate a parse tree for a tenant's skin file.
 *
 * @param  {Object}   [variables]       Object where the key is the LESS variable name (without the '@') and the value is the corresponding CSS value.
 * @param  {Object}   callback.err      An error object containing the error code and message.
 * @param  {Object}   callback.tree     The CSS syntax tree.
 * @api private
 */
var _parseLessFile = function(variables, callback) {
    variables = variables || {};

    // Read the skin file.
    getStaticFile(UIConstants.paths.BASE_SKIN, function(err, skin) {
        if (err) {
            log().error({'err': err}, 'Could not read the skin file.');
            return callback(err);
        }

        variables = _replaceOptimizedPaths(variables);

        // Overwrite the default values.
        _.each(variables, function(value, key) {
            var re = new RegExp('^(@' + key + '): (.*);$', 'm');
            skin = skin.replace(re, '$1: ' + value + ';');
        });

        // Parse the less file.
        var parser = less.Parser({});
        parser.parse(skin, function(err, tree) {
            if (err) {
                log().error({'err': err}, 'Could not parse the skin file.');
                return callback({'code': 500, 'msg': err});
            }

            callback(null, tree);
        });
    });
};

/**
 * Parses the skin file and retrieves the annotated LESS variables.
 *
 * @param  {Function}   callback              Standard callback method.
 * @param  {Object}     callback.err          An error object (if any)
 * @param  {String}     callback.variables    The generated CSS.
 * @api private
 */
var _cacheSkinVariables = function(callback) {
    _parseLessFile(null, function(err, tree) {
        if (err) {
            return callback(err);
        }

        var variables = {};

        /*!
         * Get all the variables out of the skin file.
         * Unfortunately we can't use tree.variables() as that doesn't give us the section and subsection names..
         * We loop over each rule in the less file and apply the following checks
         *
         *   1.  Is this rule a section declaration?
         *
         *       Sections are used to logically group skinning variables.
         *       Sections are defined in the following way:
         *
         *       \/************************
         *         ** @section  Branding **
         *         ************************\/
         *
         *   2.  Is this rule a subsection declaration?
         *
         *       Subsections are used to created logical skinning variable groups inside of
         *       a section. Subsections are defined in the following way:
         *
         *       \/* @subsection  Link colors *\/
         *
         *   3.  Is this rule a variable comment?
         *
         *       Variable comments are rules that come right above a variable declaration.
         *       These are used to give each variable a description.
         *
         *   4.  Is this rule a variable declaration?
         *
         *       Variables that can be re-used troughout the skin.
         *       The 'type' of the variable will be determined by looking at the suffix of the variable name.
         *
         *       Looks like:
         *       \/* The background color for the body *\/    --> variable comment
         *       @body-background-color: #ECEAE5;           --> variable declaration, the variable is of type 'color'.
         */

        var section = 'Default';
        var subsection = 'main';

        var sections = [];
        var subsections = [];

        var sectionRegex = new RegExp('[*] [@]section[ ]+([^*]+) [*]');
        var subsectionRegex = new RegExp('[*] [@]subsection[ ]+([^*]+) [*]');

        for (var i = 0; i < tree.rules.length; i++) {

            var rule = tree.rules[i];
            var sectionMatch = null;
            var subsectionMatch = null;

            // Section declaration
            if (rule.value && typeof rule.value === 'string' && (sectionMatch = rule.value.match(sectionRegex))) {
                // Get the name of this section.
                section = sectionMatch[1];
                sections.push(section);
                subsection = 'main';
                subsections = [subsection];

            // Subsection declaration
            } else if (rule.value && typeof rule.value === 'string' && (subsectionMatch = rule.value.match(subsectionRegex))) {
                // Get the name of this subsection.
                subsection = subsectionMatch[1];
                subsections.push(subsection);

            // Variable declaration
            } else if (rule.variable === true) {
                // Each variable should have some CSS documentation on top of it
                // that explains what the variable does.
                // This should be defined in the previous rule.
                var docRule = tree.rules[i-1];
                var description = 'TODO';
                if (docRule && docRule.value && typeof docRule.value === 'string' && docRule.value.substring(0, 2) === '/*') {
                    description = docRule.value.replace('/* ', '').replace('*/', '');
                }

                // Strip out the '@' sign from the token to get the variable name.
                var name = rule.name.substr(1);

                // Less variables don't have any type.
                // We determine the type by looking at the suffix in the variable name.
                var type = UIConstants.variables.types.STRING;
                if (/-color$/.test(name)) {
                    type = UIConstants.variables.types.COLOR;
                }
                if (/-url$/.test(name)) {
                    type = UIConstants.variables.types.URL;
                }

                variables[name] = {
                    'name': name,
                    'defaultValue': rule.value.toCSS({}),
                    'description': description,
                    'type': type,
                    'section': {
                        'name': section,
                        'index': sections.indexOf(section)
                    },
                    'subsection': {
                        'name': subsection,
                        'index': subsections.indexOf(subsection)
                    }
                };
            }
        }

        // Cache the variables.
        cachedSkinVariables = variables;

        callback(null, variables);
    });
};

/**
 * Retrieves the CSS values that a tenant has specified he wishes to use in the skin.
 * If the tenant values could not be parsed an empty object will be returned.
 *
 * @param  {String} tenantAlias The alias of the tenant for which the values should be retrieved.
 * @return {Object}             The CSS values keyed by the LESS variable name (without the '@'.)
 * @api private
 */
var _getTenantSkinVariableValues = function(tenantAlias) {
    var variables = uiConfig.getValue(tenantAlias, 'skin', 'variables');
    if (!variables || !_.isObject(variables)) {
        return {};
    } else {
        return variables;
    }
};

/**
 * Retrieves the default CSS values that are embedded in the skin template. If the skin has not been
 * parsed and cached yet, then this returns `null`.
 *
 * @return {Object}    A simple variableName->variableValue mapping of variables that are embedded in the skin file
 * @api private
 */
var _getDefaultSkinVariableValues = function() {
    if (!cachedSkinVariables) {
        return null;
    }

    var defaultVariableValues = {};
    _.each(cachedSkinVariables, function(variableMetadata, variableName) {
        defaultVariableValues[variableName] = variableMetadata.defaultValue;
    });

    return defaultVariableValues;
};

/**
 * Given an object mapping skin variables to values, replace URL values with static application paths that
 * may have been changed due to build optimization. For example, the static asset:
 *
 * `/shared/oae/img/logo.png`
 *
 * during a build optimization could be hashed, adding the hash of the file contents into the filename:
 *
 * `/shared/oae/img/logo.ac879d8f.png`
 *
 * The reason this is done is to ensure user caches are "busted" when the file changes, and allows "infinite"
 * length caching of the resources.
 *
 * So if a user specifies that they want their logo to be "/shared/oae/img/logo.png" in their skin variables,
 * this method needs to know how to map "/shared/oae/img/logo.png" to "/shared/oae/img/logo.ac879d8f.png". To
 * do this, there is a file `hashes.json` in the root directory of the optimized UI build that specifies a
 * JSON object that the optimizer step needs to generate, to identify what the "optimized" path of the file is.
 *
 * @path   {Object}    skinVariables   An object of variableName->variableValue of skin values that we should try and map to the optimized paths
 * @return {Object}                    An object of variableName->variableValue that contains the remapped URL variable values
 * @api private
 */
var _replaceOptimizedPaths = function(skinVariables) {
    var replacedVariables = _.extend({}, skinVariables);

    // If we have a path hashes mapping, we need to replace all URLs with those that have been optimized at build-time
    if (hashes) {
        var urlRegex = /'(.*)'/;
        _.each(skinVariables, function(value, key) {
            var variableMetadata = cachedSkinVariables[key];

            // Try to apply optimized paths if the variable is a valid URL
            if (variableMetadata && variableMetadata.type === UIConstants.variables.types.URL && urlRegex.test(value)) {
                // Strip out the enclosing quotes
                var url = value.replace(urlRegex, '$1').trim();
                if (hashes[url]) {
                    // If an optimized mapping exists for this URL, replace it with the quotes
                    replacedVariables[key] = util.format('\'%s\'', hashes[url]);
                }
            }
        });
    }

    return replacedVariables;
};
