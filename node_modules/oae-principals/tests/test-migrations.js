/*
 * Copyright 2016 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');
var Chance = require('chance');

var AuthzTestUtil = require('oae-authz/lib/test/util');
var Cassandra = require('oae-util/lib/cassandra');
var ContentTestUtil = require('oae-content/lib/test/util');
var LowerCaseEmailsMigrator = require('../../../etc/migration/12.3-to-12.4/lib/lower-case-emails');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var Redis = require('oae-util/lib/redis');
var RestAPI = require('oae-rest');
var SearchTestUtil = require('oae-search/lib/test/util');
var TestsUtil = require('oae-tests');

var chance = new Chance();

describe('Principals Migration', function() {
  var globalAdminRestContext = null;
  var camAdminRestContext = null;

  before(function(callback) {
    globalAdminRestContext = TestsUtil.createGlobalAdminRestContext();
    camAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.cam.host);
    return callback();
  });

  /*!
     * Randomly mix the case of the given string
     *
     * @param  {String}     toMix   The string whose case to mix
     * @return {String}             The string with its case mixed
     */
  var _mixCase = function(toMix) {
    return _.map(toMix, function(c) {
      if (chance.bool()) {
        return c.toUpperCase();
      } else {
        return c.toLowerCase();
      }
    }).join('');
  };

  /*!
     * Search for the email using email search, ensuring either their
     * presence or absense, depending on the `shouldContain` option
     *
     * @param  {String[]}       emails              The email addresses for which to search
     * @param  {Object}         opts                Execution options
     * @param  {Boolean}        opts.shouldContain  Whether or not the search results should contain an associated user
     * @param  {Function}       callback            Invoked when assertions are complete
     * @throws {AssertionError}                     Thrown if the assertions fail
     */
  var _assertAllEmailsSearch = function(emails, opts, callback) {
    emails = emails.slice();
    if (_.isEmpty(emails)) {
      return callback();
    }

    var email = emails.shift();
    SearchTestUtil.assertSearchSucceeds(camAdminRestContext, 'email', null, { q: email }, function(
      result
    ) {
      if (opts.shouldContain) {
        assert.strictEqual(result.results.length, 1);
        assert.strictEqual(result.results[0].email, email.toLowerCase());
      } else {
        assert.strictEqual(result.results.length, 0);
      }
      return _assertAllEmailsSearch(emails, opts, callback);
    });
  };

  /*!
     * Add the given emails to a content item, ensuring they are either added as
     * invitations or members, depending on if we expect the emails to be
     * found in the PrincipalsByEmail index.
     *
     * @param  {RestContext}    restContext         The REST context with which to share
     * @param  {String[]}       emails              The email addresses with which to share
     * @param  {Object}         opts                Execution options
     * @param  {Boolean}        opts.shouldInvite   Whether we should expect the share to result in email invitations
     * @param  {Function}       callback            Standard callback function
     * @throws {AssertionError}                     Thrown if the assertions fail
     */
  var _assertAllEmailsInvite = function(restContext, emails, opts, callback) {
    ContentTestUtil.assertCreateLinkSucceeds(
      restContext,
      'google',
      'description',
      'public',
      'http://www.google.ca',
      null,
      null,
      null,
      function(link) {
        // In this case, the share targets are the raw emails, so we should
        // expect the share to happen with just the emails. If there are matches
        // in the PrincipalsByEmail table, then they would be used as the target
        // principal and this operation would fail
        RestAPI.Content.shareContent(restContext, link.id, emails, function(err) {
          assert.ok(!err);
          AuthzTestUtil.assertGetInvitationsSucceeds(restContext, 'content', link.id, function(
            invitations
          ) {
            ContentTestUtil.getAllContentMembers(restContext, link.id, null, function(members) {
              // Since invitations will be lower-cased, to compare
              // the arrays we should lower case our mixed-case local
              // copy
              var lowerCased = _.map(emails, function(email) {
                return email.toLowerCase();
              });

              if (opts.shouldInvite) {
                // If we expected to invite them, ensure they are
                // all present in the invitations list
                assert.deepEqual(_.pluck(invitations.results, 'email').sort(), lowerCased.sort());
                assert.strictEqual(members.length, 1);
              } else {
                // If we expected to add them (i.e., their emails
                // were found in the system), then verify they exist
                // as members
                assert.strictEqual(invitations.results.length, 0);
                assert.strictEqual(members.length, emails.length + 1);
              }

              return callback();
            });
          });
        });
      }
    );
  };

  /**
   * Test that verifies emails are made case insensitive
   */
  it('verify emails are made case insensitive', function(callback) {
    TestsUtil.generateTestUsers(camAdminRestContext, 51, function(err, users) {
      assert.ok(!err);

      users = _.values(users);
      var actor = _.first(users);
      var targets = _.rest(users);

      // Mix the case of all emails that were persisted in this group
      var userIds = _.chain(targets)
        .pluck('user')
        .pluck('id')
        .value();
      var userIdEmails = _.chain(targets)
        .map(function(user) {
          return [
            user.user.id,
            {
              before: user.user.email,
              after: _mixCase(user.user.email)
            }
          ];
        })
        .object()
        .value();
      var queries = _.chain(userIdEmails)
        .map(function(email, userId) {
          return [
            {
              query: 'UPDATE "Principals" SET "email" = ? WHERE "principalId" = ?',
              parameters: [email.after, userId]
            },
            {
              query: 'DELETE FROM "PrincipalsByEmail" WHERE "email" = ?',
              parameters: [email.before]
            },
            {
              query: 'INSERT INTO "PrincipalsByEmail" ("email", "principalId") VALUES (?, ?)',
              parameters: [email.after, userId]
            }
          ];
        })
        .flatten()
        .value();

      // Persist the mixed case emails outside the scope of the API to
      // reproduce the migration test conditions (i.e., there were
      // mixed-case emails in the database at time of ugprade)
      Cassandra.runBatchQuery(queries, function(err) {
        assert.ok(!err);
        Cassandra.runQuery(
          'SELECT "principalId", "email" FROM "Principals" WHERE "principalId" IN ?',
          [userIds],
          function(err, rows) {
            assert.ok(!err);

            // Update redis and search since we updated outside the
            // scope of the API
            Redis.flush(function(err) {
              assert.ok(!err);
              SearchTestUtil.reindexAll(globalAdminRestContext, function() {
                // Determine which users we should not be able to find in search
                // because of mixed-cased emails
                var userIdEmailsWithUpperCase = _.chain(userIdEmails)
                  .map(function(emailInfo, userId) {
                    return [userId, emailInfo];
                  })
                  .filter(function(entries) {
                    var userId = entries[0];
                    var emailInfo = entries[1];

                    // Retain all emails that contain an upper-case character
                    // (excluding things that don't have uppercase variants
                    // like '@')
                    return _.some(emailInfo.after, function(c) {
                      return c !== c.toLowerCase() && c === c.toUpperCase();
                    });
                  })
                  .object()
                  .value();
                var emailsWithUpperCase = _.chain(userIdEmailsWithUpperCase)
                  .values()
                  .pluck('after')
                  .value();

                // Ensure that none of the emails can be searched for or linked to when sharing a content
                // item. This is the basis for the migration
                _assertAllEmailsSearch(emailsWithUpperCase, { shouldContain: false }, function() {
                  _assertAllEmailsInvite(
                    actor.restContext,
                    emailsWithUpperCase,
                    { shouldInvite: true },
                    function() {
                      // Run the migration
                      LowerCaseEmailsMigrator.doMigration(function(err, stats) {
                        assert.ok(!err);
                        assert.strictEqual(stats.nUpdated, emailsWithUpperCase.length);
                        assert.strictEqual(stats.nFailed, 0);

                        // Refresh the search index
                        SearchTestUtil.reindexAll(globalAdminRestContext, function() {
                          // Ensure the emails are now all searchable and can be matched
                          // when sharing
                          _assertAllEmailsSearch(
                            emailsWithUpperCase,
                            { shouldContain: true },
                            function() {
                              _assertAllEmailsInvite(
                                actor.restContext,
                                emailsWithUpperCase,
                                { shouldInvite: false },
                                function() {
                                  return callback();
                                }
                              );
                            }
                          );
                        });
                      });
                    }
                  );
                });
              });
            });
          }
        );
      });
    });
  });
});
