/*!
 * Copyright 2015 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var ActivityAPI = require('oae-activity');
var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;
var ActivityModel = require('oae-activity/lib/model');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var ResourceActions = require('oae-resource/lib/actions');
var ResourceConstants = require('oae-resource/lib/constants').ResourceConstants;
var TenantsAPI = require('oae-tenants');

var log = require('oae-logger').logger('oae-authz-activity');


//////////////////
// EMAIL ENTITY //
//////////////////

/*!
 * Register an activity entity type of "email", which represents an external email rather than a
 * resource in the system
 */
ActivityAPI.registerActivityEntityType('email', {
    'transformer': {
        'activitystreams': function(ctx, activityEntities, callback) {
            var currentUserId = (ctx.user() && ctx.user().id);
            var transformedEntities = _.mapObject(activityEntities, function(entities, activityId) {
                return _.mapObject(entities, function(entity) {
                    var email = entity.email.email;
                    var token = entity.email.token;
                    var tenant = TenantsAPI.getTenantByEmail(email);

                    var globalId = null;
                    var opts = {'ext': {}};

                    opts.ext[ActivityConstants.properties.OAE_TENANT] = tenant.compact();
                    if (currentUserId === entity[ActivityConstants.properties.OAE_ID]) {
                        // If the target user is the email address feed itself (i.e., the recipient
                        // of an email), we can keep the email address on the transformed entity
                        globalId = email;
                        opts.ext[ActivityConstants.properties.OAE_ID] = email;
                        opts.ext[ActivityConstants.properties.OAE_EMAIL] = email;
                        opts.ext[ActivityConstants.properties.OAE_TOKEN] = token;
                    }

                    return new ActivityModel.ActivityEntity('email', globalId, null, opts);
                });
            });

            return callback(null, transformedEntities);
        },
        'internal': function(ctx, activityEntities, callback) {
            var currentUserId = (ctx.user() && ctx.user().id);
            var transformedEntities = _.mapObject(activityEntities, function(entities, activityId) {
                return _.mapObject(entities, function(entity) {
                    var email = entity[ActivityConstants.properties.OAE_ID];
                    var tenant = TenantsAPI.getTenantByEmail(email);

                    var transformedEntity = {};
                    if (currentUserId === entity[ActivityConstants.properties.OAE_ID]) {
                        // If the target user is the email address feed itself (i.e., the recipient
                        // of an email), we can keep the email address on the transformed entity
                        _.extend(transformedEntity, {
                            'displayName': displayName,
                            'email': email
                        });
                    }

                    return transformedEntity;
                });
            });

            return callback(null, tarnsformedEntities);
        }
    },
    'propagation': function(associationsCtx, entity, callback) {
        /*!
         * TODO: We say an email entity can only be propagated to itself, due to lack of obfuscation
         * on the email. This is OK currently because email resources are only delivered in "invite"
         * activities, and we do not deliver invite activities to anyone but the recipient of the
         * email. This is an aggressive approach to ensure we don't leak email address to, for
         * example, members of groups.
         *
         * If we want to expand this propagation to allow activities containing email recipients to
         * be routed to larger audiences, the following must happen:
         *
         *  1.  The "id" of the entity (e.g., the entity id and the route id) MUST be changed to
         *      something that is a unique obfuscation of the email. For example, a sha1 hash salted
         *      by the domain would likely work (i.e., "mrvisser@gmail.com" ->
         *      "sha1('mrvisser@gmail.com')@gmail.com" -> "abcdefabcdef1234567890@gmail.com")
         *  2.  The "oae:email" field must always exist on the entity however for any user in
         *      context that is not the recipient of the email itself (or someone who does not have
         *      a verified email that is the email address itself), we use only the first character
         *      of the email username, followed by an ellipses (i.e., "mrvisser@gmail.com" ->
         *      "m...@gmail.com")
         *
         * Once the above 2 obfuscation approaches are taken, we should be able to expand this
         * propagation rule to ALL.
         */
        return callback(null, [{'type': ActivityConstants.entityPropagation.SELF}]);
    }
});

/*!
 * Register the "self" association for the email, which specifies only the email resource itself as
 * a potentital recipient
 */
ActivityAPI.registerActivityEntityAssociation('email', 'self', function(associationsCtx, entity, callback) {
    return callback(null, [entity[ActivityConstants.properties.OAE_ID]]);
});


/////////////////////
// INVITE ACTIVITY //
/////////////////////

/*!
 * Indicates that some user (the actor) has invited some email (the object) into some resource in
 * the system (the target)
 */
ActivityAPI.registerActivityType(AuthzConstants.activity.ACTIVITY_INVITE, {
    'groupBy': [{'actor': true, 'object': true, 'target': 'objectType'}],
    'streams': {
        'email': {
            'router': {
                'object': ['self']
            }
        }
    }
});

/*!
 * When an email has been invited, emit the "invited" activity for each resource to which the email
 * was invited into
 */
ResourceActions.on(ResourceConstants.events.INVITED, function(ctx, invitations, emailTokens) {
    var millis = Date.now();
    var actorResource = new ActivityModel.ActivitySeedResource('user', ctx.user().id, {'user': ctx.user()});
    _.chain(invitations)
        .map(function(invitation) {
            var email = invitation.email;
            var objectResource = new ActivityModel.ActivitySeedResource('email', invitation.email, {
                'email': {
                    'email': email,
                    'token': emailTokens[email]
                }
            });
            var targetResource = ActivityModel.ActivitySeedResource.fromResource(invitation.resource);
            return new ActivityModel.ActivitySeed(AuthzConstants.activity.ACTIVITY_INVITE, millis, ActivityConstants.verbs.INVITE, actorResource, objectResource, targetResource);
        })
        .each(function(activitySeed) {
            ActivityAPI.postActivity(ctx, activitySeed);
        })
        .value();
});


////////////////////////////////
// INVITATION ACCEPT ACTIVITY //
////////////////////////////////

/*!
 * Indicates some user (actor) accepted an invitation from another user (object) into some resource
 * (target). I think idealistically, we would have an "invitation" entity type to place in the
 * object of the activity which would encompass the inviter as well as the role, however the
 * inviter was chosen as the object as it is easier
 */
ActivityAPI.registerActivityType(AuthzConstants.activity.ACTIVITY_INVITATION_ACCEPT, {
    'groupBy': [{'actor': true, 'object': true, 'target': 'objectType'}],
    'streams': {
        'activity': {
            'router': {
                'actor': ['self'],
                'object': ['self'],
                'target': ['self', 'managers']
            }
        },
        'notification': {
            'router': {
                'object': ['self']
            }
        },
        'email': {
            'router': {
                'object': ['self']
            }
        }
    }
});
