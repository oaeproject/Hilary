/*
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');

var TelemetryAPI = require('oae-telemetry');


describe('Telemetry', function() {

    /*!
     * Create an enabled telemetry configuration from the given configuration
     *
     * @param  {Object}     config  The configuration object with which to create an enabled telemetry config
     */
    var _createConfig = function(config) {
        return _.extend({'enabled': true}, config);
    };

    var Telemetry = null;
    beforeEach(function(callback) {
        // Reset the telemetry configuration before each telemetry test
        TelemetryAPI.init(_createConfig(), function() {
            // *Force* a reset of all telemetry values, even if it is not time to do so
            TelemetryAPI.reset(function(err) {
                assert.ok(!err);
                Telemetry = TelemetryAPI.telemetry('tests');
                return callback();
            });
        });
    });

    describe('Publish and Reset', function() {

        /**
         * Test that verifies that when the publisher is invoked, it publishes the set of data that is available, and that when reset is invoked,
         * it resets the data for the next publishing cycle.
         */
        it('verify publish interval publishes the proper data while reset clears the data', function(callback) {
            // Configure the telemetry API such that on the first second we get a publish, then in the second second we
            // get a reset, then in the 3rd we get another publish
            TelemetryAPI.init(_createConfig({'publishInterval': 1, 'resetInterval': 2}), function(err) {
                assert.ok(!err);

                // Note that if this takes longer than one second our test fails intermittently :( I'm not sure we can avoid this
                // without disrupting the test
                Telemetry.incr('incr', 10);
                Telemetry.append('append', 50);
                Telemetry.append('append', 30);

                // Wait 1s for the publish event to verify the published data
                TelemetryAPI.once('publish', function(data) {
                    assert.equal(data['tests']['incr'], 10);
                    assert.equal(data['tests']['append'].length, 2);
                    assert.equal(data['tests']['append'][0], 50);
                    assert.equal(data['tests']['append'][1], 30);

                    // Once we get our reset, wait for the next publish to ensure our counts are reset
                    TelemetryAPI.once('reset', function() {
                        TelemetryAPI.once('publish', function(data) {

                            // Either the top-level tests module object should be gone, or the incr key should either be 0 or falsey
                            assert.ok(!data['tests'] || !data['tests']['incr']);

                            // Either the top-level tests module object should be gone, or the append key histograms should be either falsey or empty
                            assert.ok(!data['tests'] || !data['tests']['append'] || !data['tests']['append'].length);

                            return callback();
                        });
                    });
                });
            });
        });
    });

    describe('#incr()', function() {

        /**
         * Test the verifies Telemetry.incr will increase by 1
         */
        it('verify it increases by one', function(callback) {
            Telemetry.incr('incr', 1);
            TelemetryAPI.getTelemetryData(function(err, data) {
                assert.ok(!err);
                assert.equal(data['tests']['incr'], 1);
                return callback();
            });
        });

        /**
         * Test that verifies Telemetry.incr of 10 will increase by 10
         */
        it('verify multiple increases', function(callback) {
            Telemetry.incr('incr', 10);
            TelemetryAPI.getTelemetryData(function(err, data) {
                assert.ok(!err);
                assert.equal(data['tests']['incr'], 10);
                return callback();
            });
        });

    });

    describe('#append()', function() {

        /**
         * Test that verifies appending data to a telemetry stat will properly hold the data
         */
        it('verify it appends data to a list', function(callback) {
            Telemetry.append('append', 10);

            TelemetryAPI.getTelemetryData(function(err, data) {
                assert.ok(!err);
                assert.equal(data['tests']['append'].length, 1);
                assert.equal(data['tests']['append'][0], 10);

                Telemetry.append('append', 5);
                TelemetryAPI.getTelemetryData(function(err, data) {
                    assert.equal(data['tests']['append'].length, 2);
                    assert.equal(data['tests']['append'][0], 10);
                    assert.equal(data['tests']['append'][1], 5);
                    return callback();
                });
            });
        });
    });
});
