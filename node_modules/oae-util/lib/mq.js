/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var amqp = require('amqp');
var _ = require('underscore');

var log = require('oae-logger').logger('mq');

var connection = null;
var queueExchange = null;
var queues = {};

/**
 * MQ constants.
 *
 *  {String}    DEFAULT_TASK_EXCHANGE_NAME      The name of the AMQP task exchange
 *  {Object}    DEFAULT_TASK_EXCHANGE_OPTS      The default options to specify when creating the AMQP task exchange
 *  {Object}    DEFAULT_TASK_QUEUE_OPTS         The default options to specify when creating the AMQP task queue
 *  {Object}    DEFAULT_TASK_QUEUE_PUBLISH_OPTS The default options to specify when publishing tasks on the AMQP task queue
 *  {Object}    DEFAULT_PREFETCH_COUNT          The default prefetch count for the task workers
 */
var Constants = module.exports.Constants = {
    'DEFAULT_TASK_EXCHANGE_NAME': 'oae-taskexchange',
    'DEFAULT_TASK_EXCHANGE_OPTS': {
        'type': 'direct',
        'durable': true,
        'autoDelete': false
    },
    'DEFAULT_TASK_QUEUE_OPTS': {
        'durable': true,
        'autoDelete': false
    },
    'DEFAULT_TASK_QUEUE_PUBLISH_OPTS': {
        'deliveryMode': 2                   // 2 indicates 'persistent'
    },
    'DEFAULT_PREFETCH_COUNT': 15
};

/*!
 * prefetchCount determines how many jobs will be assigned to this node's queue at a time before getting acknowledgement on other
 * messages. It is configured with `mqConfig.prefetchCount`, but defaults to `Constants.DEFAULT_PREFETCH_COUNT`.
 */
var prefetchCount = Constants.DEFAULT_PREFETCH_COUNT;

/**
 * Initialize the Message Queue system so that it can start sending and receiving messages.
 *
 * @param   {Object}    mqConfig        The MQ Configuration object
 * @param   {Function}  callback        Invoked when initialization completes
 * @param   {Object}    callback.err    An error that occurred, if any
 */
var init = module.exports.init = function(mqConfig, callback) {
    prefetchCount = isNaN(mqConfig.prefetchCount) ? Constants.DEFAULT_PREFETCH_COUNT : mqConfig.prefetchCount;
    if (!connection) {
        log().info('Initializing RabbitMQ connector.');

        connection = amqp.createConnection(mqConfig.connection);

        connection.on('error', function(err) {
            log().error({'err': err}, 'Error connecting to RabbitMQ.');
            return callback(err);
        });

        connection.on('close', function() {
            log().info('Closed connection to RabbitMQ');
        });

        connection.on('ready', function() {
            log().info('Connection to RabbitMQ established.');

            // Initialize the exchange for the job queues
            connection.exchange(Constants.DEFAULT_TASK_EXCHANGE_NAME, Constants.DEFAULT_TASK_EXCHANGE_OPTS, function(exchange) {
                queueExchange = exchange;
                return callback();
            });
        });
    } else {
        log().warn('Attempted to initialize an existing RabbitMQ connector. Ignoring');
        callback();
    }
};

/**
 * Bind a function to listen for a particular type of task. When bound, the node effectively becomes a "worker" for that task,
 * meaning when it receives a particular job, no other node active in the cluster will receive it.
 *
 * @param   {String}    name            The unique label that identifies the type of job this binding is listening to
 * @param   {Function}  listener        The function that will handle tasks of the given type
 * @param   {Object}    listener.data   The data that was sent in the job. This is different depending on the type of job
 * @param   {Function}  [callback]      Invoked after the listener has been bound to the MQ
 * @param   {Object} 
 */
var bind = module.exports.bind = function(name, listener, callback) {
    callback = callback || function(err) { /* error is logged within the implementation */ };

    if (queues[name]) {
        log().warn({
            'queueName': name,
            'listener': listener
        }, 'Attempted to bind duplicate listener for job queue. Aborting.');
        return callback();
    }

    connection.queue(name, Constants.DEFAULT_TASK_QUEUE_OPTS, function(queue) {
        queues[name] = {'queue': queue};
        log().info({'queueName': name}, 'Created a RabbitMQ task queue');

        // Bind the queue to the task exchange. The routing key is the same as the name of the job queue
        queue.bind(Constants.DEFAULT_TASK_EXCHANGE_NAME, name, function() {
            // Bind the listener to the queue, to handle all jobs of the given `name` type
            queue.subscribe({'ack': true, 'prefetchCount': prefetchCount}, function(data, headers, deliveryInfo) {
                log().trace({
                    'queueName': name,
                    'data': data,
                    'headers': headers
                }, 'Received an MQ message.');

                // Pass it to the listener
                try {
                    listener(data);
                } catch (err) {
                    log().error({
                        'err': err,
                        'queueName': name,
                        'data': data
                    }, 'Exception raised while handling job.');
                }

                // Shift the element off the queue.
                queue.shift();
            }).addCallback(function(ok) {
                if (!ok) {
                    log().error({'err': err, 'queueName': name}, 'Error binding worker for task queue.');
                    _destroyQueue(name, function(err) {
                        // Don't overwrite the original error with any binding errors
                        return callback(new Error('Error binding worker for task queue.'));
                    });
                }

                // Keep the consumerTag so we can unsubscribe later.
                queues[name].consumerTag = ok.consumerTag;
                return callback();
            });
        });
    });
}

/**
 * Unbind this node as a worker for the specified type of task.
 * 
 * @param   {String}    name            The name of the task to which to unbind this node
 * @param   {Function}  callback        Invoked when the task has been unbound
 * @param   {Object}    callback.err    An error that occurred, if any
 */
var unbind = module.exports.unbind = function(name, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'queueName': name}, 'Error unbinding task queue handler.');
        }
    }
    _destroyQueue(name, callback);
}

/**
 * Submit a job to the task queue to be picked up by some arbitrary node in the cluster.
 *
 * @param   {String}    name        The type of job to submit
 * @param   {Object}    data        The data to send with the task. This will be received by the worker for this type of task
 * @param   {Function}  callback    Invoked when the job has been submitted
 */
var submit = module.exports.submit = function(name, data, callback) {
    callback = callback || function() {};

    // We publish with the routing key `name`, which routes it to the queue (if any) that is listening on this key
    queueExchange.publish(name, data, Constants.DEFAULT_TASK_QUEUE_PUBLISH_OPTS);
    return callback();
}

/**
 * Destroy the managed task queue with the given name.
 *
 * @param   {String}    name            The type of the job message queue to destroy.
 * @param   {Function}  callback        Invoked when the process completes
 * @param   {Object}    callback.err    An error that occurred, if any
 * @api private
 */
var _destroyQueue = function(name, callback) {
    var queue = queues[name];
    if (!queue || !queue.queue) {
        log().warn({'queueName': name}, 'Attempted to unbind listener from non-existant job queue. Ignoring.');
        return callback();
    }

    var consumerTag = queue.consumerTag
    queue = queue.queue;

    queue.unsubscribe(consumerTag).addCallback(function(ok) {
        var err = null;

        try {
            queue.unbind(Constants.DEFAULT_TASK_EXCHANGE_NAME, name);
            queue.destroy({'ifUnused': true, 'ifEmpty': true});
        } catch (ex) {
            err = ex;
        }

        delete queues[name];

        if (!ok) {
            log().error({'queueName': name}, 'An unknown error occurred unsubscribing a task queue.');
            return callback(new Error('An unknown error occurred unsubscribing a task queue.'));
        } else if (err) {
            log().error({'err': err, 'queueName': name}, 'Error destroying job queue. Ignoring.');
            return callback(err);
        }

        // Looks like either unbind or destroy has an asynchronous nature to it, and we can end up with race conditions if we don't wait.
        // I think a timeout here is fine as it shouldn't impact regular request latency
        return setTimeout(callback, 250);
    });
}
