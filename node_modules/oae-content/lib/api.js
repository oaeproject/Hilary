/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var events = require('events');
var fs = require('fs');
var Path = require('path');
var ShortId = require('shortid');
var util = require('util');

var AuthzAPI = require('oae-authz');
var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var Config = require('oae-config').config('oae-content');
var Context = require('oae-context').Context;
var log = require('oae-logger').logger('oae-content');
var PrincipalsUtil = require('oae-principals/lib/util');
var TenantsUtil = require('oae-tenants/lib/util');
var Validator = require('oae-util/lib/validator').Validator;

var Comment = require('./model').Comment;
var Content = require('./model').Content;
var ContentConstants = require('./constants').ContentConstants;
var Revision = require('./model').Revision;


var _backends = {};

/**
 * ### Events
 *
 * The `ContentAPI`, as enumerated in `ContentConstants.events`, emits the following events:
 *
 * * `createdContent(ctx, content)`: A new content item was created. The `ctx` and the `content` object that was created are both provided.
 * * `updatedContent(ctx, contentId)`: A content item was updated. The `ctx` and the `contentId` of the updated content item are provided.
 * * `deletedContent(ctx, contentId)`: A content item was deleted. The `ctx` and the `contentId` of the deleted item are provided.
 * * `updatedContentMembers(ctx, contentId, memberUpdates)`: A content's members list was updated. The `ctx`, `contentId` of the updated content, and the hash of principalId -> role that outlines the changes that were made are provided.
 */
var ContentAPI = emitter = module.exports = new events.EventEmitter();

///////////////////////////////////
// Retrieving a piece of content //
///////////////////////////////////

/**
 * Get a content's basic profile information based on a pooled content id
 * 
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the content object we want to retrieve
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Content}        callback.contentObj Retrieved content object
 */
var getContent = module.exports.getContent = function(ctx, contentId, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getContent(contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        _hasAccess(ctx, contentObj, function(err, hasAccess) {
            if (err) {
                return callback(err);
            } else if (!hasAccess) {
                return callback({'code': 401, 'msg': 'You don\'t have access to this piece of content'});
            }
            callback(null, contentObj);
        });
    });
};

/**
 * Get a content's basic profile information based on a pooled content id
 * 
 *  TODO:   This is currently exposed publically to provide a way to get content without a permission check. This should actually
 *          live in an ./internal/... file, but that would create a massive conflict with other work that is currently happening.
 *          Once some large sets of features have been merged, we should separate out internal methods into some sort of DAO
 *          pattern and then this does not have to be exposed like this.
 *
 * @param  {String}         contentId           The id of the content object we want to retrieve
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Content}        callback.contentObj Retrieved content object
 * @api private
 */
var _getContent = module.exports._getContent = function(contentId, callback) {
    // Retrieve the content iten from Cassandra
    Cassandra.runQuery('SELECT * FROM Content USING CONSISTENCY QUORUM WHERE contentId = ?', [contentId], function (err, rows) {
        if (err) {
            return callback(err);
        }

        // Cassandra always returns the key as a column so the _colCount will always be 1.
        // TODO: https://github.com/sakaiproject/Hilary/issues/251
        if (rows[0].count <= 2) {
            return callback({'code': 404, 'msg': "Couldn't find content: " + contentId}, null);
        }

        var contentObj = _rowToContent(rows[0]);
        return callback(null, contentObj);
    });
};

/**
 * Get a content item's full content profile. Next to the basic content profile, this will include the created date,
 * the profile of the user who originally created the content, and a isManager property specifying whether or not
 * the current user can manage the content.
 * 
 * @param  {Context}        ctx                         Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId                   The id of the content profile we want to retrieve
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                Error object containing the error message
 * @param  {Content}        callback.contentProfile     Retrieved content profile
 */
var getFullContentProfile = module.exports.getFullContentProfile = function(ctx, contentId, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }
        
        // Get the user object for the createdBy property
        PrincipalsUtil.getPrincipal(ctx, contentObj.createdBy, function(err, createdBy) {
            if (err) {
                return callback(err);
            }
            contentObj.createdBy = createdBy;

            // If the current user is an anonymous user, we know he's not a viewer or manager
            if (!ctx.user()) {
                contentObj.isManager = false;
                callback(null, contentObj);
            } else {
                // Add the isManager properties
                _canManage(ctx, contentObj, function(err, isManager) {
                    if (err) {
                        return callback(err);
                    }
                    contentObj.isManager = isManager;
                    callback(null, contentObj);
                });
            }
        });
    });
};

/**
 * Internal function used to get multiple content basic profiles at the same time based on their content ids.
 * 
 * @param  {String[]}       contentIds          Array of content object ids we want to retrieve. The content profiles will be returned in the same order
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `contentObj`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Content[]}      callback.contentObj Retrieved content objects
 * @api private
 */
var _getMultipleContentItems = function(contentIds, callback) {
    if (contentIds.length) {
        Cassandra.runQuery('SELECT * FROM Content USING CONSISTENCY QUORUM WHERE contentId IN (?)', [contentIds], function(err, rows) {
            if (err) {
                return callback(err);
            }
            // Iterate over the content items.
            for (var i = 0; i < rows.length; i++) {
                var contentObj = _rowToContent(rows[i]);
                contentIds[_.indexOf(contentIds, contentObj.contentId)] = contentObj;
            }
            callback(null, contentIds);
        });
    } else {
        callback(null, []);
    }
};

/////////////////////////////////////
// Creating a new piece of content //
/////////////////////////////////////

/**
 * Create a link as a pooled content item
 * 
 * @param  {Context}        ctx                Standard context object containing the current user and the current tenant
 * @param  {String}         name               The display name for the link
 * @param  {String}         description        The description of the link [optional]
 * @param  {String}         visibility         The visibility setting for the piece of content. Possible values are "public", "loggedin" and "private" [optional]
 * @param  {String}         link               The URL for the link
 * @param  {Object}         additionalMembers  Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {Function}       callback           Standard callback function takes arguments `err` and `content`
 * @param  {Object}         callback.err       Error object containing the error message
 * @param  {Object}         callback.content   JSON object containing the pool id of the created content
 */
var createLink = module.exports.createLink = function(ctx, name, description, visibility, link, additionalMembers, callback) {
    callback = callback || function() {};

    // Setting content to default if no visibility setting is provided
    visibility = visibility || Config.getValue(ctx.tenant().alias, 'visibility', 'links');

    // Check if the link property is present. All other validation will be done in the _createContent function
    var validator = new Validator();
    validator.check(link, {'code': 400, 'msg': 'A valid link must be provided'}).isUrl();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to create a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _createContent(ctx, 'link', name, description, visibility, additionalMembers, {'link': link}, callback);
};

/**
 * Create a file as a pooled content item
 * 
 * @param  {Context}   ctx                Standard context object containing the current user and the current tenant
 * @param  {String}    name               The display name for the file
 * @param  {String}    description        The description of the file [optional]
 * @param  {String}    visibility         The visibility setting for the piece of content. Possible values are "public", "loggedin" and "private" [optional]
 * @param  {Object}    additionalMembers  Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {Object}    file               A file object as returned by express.
 * @param  {Function}  callback           Standard callback function takes arguments `err` and `content`
 * @param  {Object}    callback.err       Error object containing the error message
 * @param  {Content}   callback.content   JSON object containing the pool id of the created content
 */
var createFile = module.exports.createFile = function(ctx, name, description, visibility, additionalMembers, file, callback) {
    callback = callback || function() {};

    // Setting content to default if no visibility setting is provided
    visibility = visibility || Config.getValue(ctx.tenant().alias, 'visibility', 'files');

    var validator = new Validator();
    validator.check(file, {'code': 400, 'msg': 'Missing file parameter.'}).notNull();
    if (file) {
        validator.check(file.type, {'code': 400, 'msg': 'Missing mimetype on the file object.'}).notEmpty();
        validator.check(file.size, {'code': 400, 'msg': 'Missing size on the file object.'}).notEmpty();
        validator.check(file.size, {'code': 400, 'msg': 'Invalid size on the file object.'}).isInt();
        validator.check(file.size, {'code': 400, 'msg': 'Invalid size on the file object.'}).min(0);
        validator.check(file.name, {'code': 400, 'msg': 'Missing name on the file object.'}).notEmpty();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    // Create the content object.
    var otherValues = {
        'mime': file.type,
        'size': file.size,
        'filename': file.name
    };
    _createContent(ctx, 'file', name, description, visibility, additionalMembers, otherValues, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        // Store the actual file.
        contentObj.filename = file.name;
        contentObj.size = file.size;
        contentObj.mime = file.type;
        contentObj.downloadLink = '/api/content/' + contentObj.contentId + '/download';
        getStorageBackend(ctx).store(ctx, file, function(err, uri) {
            if (err) {
                return callback(err);
            }

            // Create the revision.
            _createRevision(ctx, contentObj.contentId, uri, otherValues, function(err) {
                if (err) {
                    return callback(err);
                }

                callback(null, contentObj);
            });
        });
    });
};

/**
 * Create a Sakai document as a pooled content item
 * 
 * @param  {Context}   ctx                Standard context object containing the current user and the current tenant
 * @param  {String}    name               The display name for the Sakai Doc
 * @param  {String}    description        The description of the Sakai Doc [optional]
 * @param  {String}    visibility         The visibility setting for the piece of content. Possible values are "public", "loggedin" and "private" [optional]
 * @param  {Object}    additionalMembers  Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {Function}  callback           Standard callback function takes arguments `err` and `content`
 * @param  {Object}    callback.err       Error object containing the error message
 * @param  {Content}   callback.content   JSON object containing the pool id of the created content
 */
var createSakaiDoc = module.exports.createSakaiDoc = function(ctx, name, description, visibility, additionalMembers, callback) {
    callback = callback || function() {};

    // Setting content to default if no visibility setting is provided
    visibility = visibility || Config.getValue(ctx.tenant().alias, 'visibility', 'sakaidocs');

    _createContent(ctx, 'sakaidoc', name, description, visibility, additionalMembers, {}, callback);
};

/**
 * Create a new piece of pooled content
 * 
 * @param  {Context}        ctx                Standard context object containing the current user and the current tenant
 * @param  {String}         contentType        The content type. Possible values are "file", "sakaidoc" and "link"
 * @param  {String}         name               The display name for the piece of content
 * @param  {String}         description        The description of the piece of content [optional]
 * @param  {String}         visibility         The visibility setting for the piece of content. Possible values are "public", "loggedin" and "private" [optional]
 * @param  {Object}         additionalMembers  Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {Object}         otherValues        JSON object where the keys represent other metadata values that need to be stored, and the values represent the metadata values
 * @param  {Function}       callback           Standard callback function takes arguments `err` and `content`
 * @param  {Object}         callback.err       Error object containing the error message
 * @param  {Content}        callback.content   JSON object containing the pool id of the created content
 * @api private
 */
var _createContent = function(ctx, contentType, name, description, visibility, additionalMembers, otherValues, callback) {
    callback = callback || function() {};

    // Use an empty description if no description has been provided
    description = description || '';
    // Make sure the otherValues and additionalMembers are valid objects
    additionalMembers = additionalMembers || {};
    otherValues = otherValues || {};

    // Parameter validation
    var validator = new Validator();
    validator.check(name, {'code': 400, 'msg': 'A content name must be provided'}).notEmpty();
    validator.check(visibility, {'code': 400, 'msg': 'An invalid content visibility option has been provided. This can be "private", "loggedin" or "public"'}).isIn(_.values(ContentConstants.visibility));
    validator.check(contentType, {'code': 400, 'msg': 'A content type must be provided. This can be "file", "sakaidoc" or "link"'}).isIn(ContentConstants.contentTypes);
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to create a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    // Generate the content id
    var contentId = AuthzUtil.toId('c', ctx.tenant().alias, ShortId.generate());

    // Set the created by, created and lastmodified properties
    var parameters = {
        'tenant': ctx.tenant().alias,
        'visibility': visibility,
        'name': name,
        'description': description,
        'contentType': contentType,
        'createdBy': ctx.user().id,
        'created': Date.now()
    };
    
    // Add the other values into the query
    parameters = _.extend(parameters, otherValues);
    var q = Cassandra.constructUpsertCQL('Content', 'contentId', contentId, parameters, 'QUORUM');

    // Create the content
    Cassandra.runQuery(q.query, q.parameters, function(err) {
        if (err) {
            return callback(err);
        }
        var contentObj = new Content(ctx.tenant().alias, contentId, visibility, name, description, contentType, parameters.createdBy, parameters.created);
        // Now make the current user a manager of the content
        additionalMembers[ctx.user().id] = ContentConstants.roles.MANAGER;
        _setContentPermissions(ctx, contentObj, additionalMembers, function(err) {
            if (err) {
                return callback(err);
            }
            emitter.emit(ContentConstants.events.CREATED_CONTENT, ctx, contentObj, additionalMembers);
            callback(null, contentObj);
        });
    });
};

/////////////////////////////////
// Removing a piece of content //
/////////////////////////////////

/**
 * Delete a piece of content from the system
 * 
 * @param  {Context}   ctx               Standard context object containing the current user and the current tenant
 * @param  {String}    contentId         The content id of the content that is being deleted
 * @param  {Function}  callback          Standard callback function takes argument `err`
 * @param  {Object}    callback.err      Error object containing the error message
 */
var deleteContent = module.exports.deleteContent = function(ctx, contentId, callback) {
    callback = callback || function() {};

    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to delete a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Fist check whether or not the current user is a manager of the piece of content
    canManage(ctx, contentId, function(err, canManage, contentObj) {
        if (err) {
            return callback(err);
        } else if (!canManage) {
            return callback({'code': 401, 'msg': 'You are not allowed to manage this piece of content'});
        }
        
        // Delete the content
        Cassandra.runQuery('DELETE FROM Content WHERE contentId = ?', [contentId], function(err, rows) {
            if (err) {
                return callback(err);
            }

            emitter.emit(ContentConstants.events.DELETED_CONTENT, ctx, contentId);

            // Get the members
            _getAllContentMembers(contentId, function(err, members) {
                if (err) {
                    return callback(err);
                // Return if there are no members
                } else if (members.length === 0) {
                    return callback();
                }

                // Remove the roles and delete this from everyone's library
                var updateMembers = {};
                for (var m = 0; m < members.length; m++) {
                    updateMembers[members[m].id] = false;
                }
                // Note: We don't delete the revisions and filebodies in the request.
                // It's left to the maintainer to purge file bodies and revisions himself.
                _setContentPermissions(ctx, contentObj, updateMembers, callback);
            });
        }); 
    });
};

////////////////////////////
// Content access control //
////////////////////////////

/**
 * Share a piece of content with a set of principals. This only be possible when the current user is a manager of the content, or if the current
 * user is logged in and the content item is public or visible to logged in users only. In case that the content is shared with principals that
 * are already content members, no updates to the existing role of those principals will be made
 * 
 * @param  {Context}   ctx               Standard context object containing the current user and the current tenant
 * @param  {String}    contentId         The content id of the content that is being shared
 * @param  {String[]}  principalIds      Array of principal ids with whom the content will be shared. By default, they will all be made members.
 * @param  {Function}  callback          Standard callback function takes arguments `err` and `content`
 * @param  {Object}    callback.err      Error object containing the error message
 */
var shareContent = module.exports.shareContent = function(ctx, contentId, principalIds, callback) {
    callback = callback || function() {};
    
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(principalIds.length, {'code': 400, 'msg': 'The content must at least be shared with 1 user or group'}).min(1);
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to share content'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the user has access to the content
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        // Check if the content is visible to logged in users or public
        if (contentObj.visibility === ContentConstants.visibility.LOGGEDIN || contentObj.visibility === ContentConstants.visibility.PUBLIC) {
            _shareContent(ctx, contentObj, principalIds, callback);
        // Check if the user can manage the content
        } else {
			// It is a possible that a content item that is owned by a tenant has been switched from public to private, but a user outside the
            // tenant that was previously manager can still share. however, restrictions inside _shareContent will stop them from sharing with
            // users outside the private tenant.
            _canManage(ctx, contentObj, function(err, canManage) {
                if (err) {
                    return callback(err);
                } else if (!canManage) {
                    return callback({'code': 401, 'msg': 'You are not allowed to share this content'});
                }
                _shareContent(ctx, contentObj, principalIds, callback);
            });
        }
    });
};

/**
 * Internal function used to share a piece of content with a set of principals. This function assume that the current user is allowed
 * to see and share the content. If some of the principals passed into this function are already content members, no updates to the 
 * existing role of those principals will be made.
 * 
 * @param  {Context}   ctx               The current execution context.
 * @param  {Content}   contentObj        Content object representing the content that is being shared
 * @param  {String[]}  principalIds      Array of principal ids with whom the content will be shared. By default, they will all be made members.
 * @param  {Function}  callback          Standard callback function takes arguments `err` and `content`
 * @param  {Object}    callback.err      Error object containing the error message
 * @api private
 */
var _shareContent = function(ctx, contentObj, principalIds, callback) {
    // Check if any of the passed in principal ids already have a direct role on the piece of content. We
    // filter those out to avoid turning an existing manager into a viewer
    AuthzAPI.getDirectRoles(principalIds, contentObj.contentId, function(err, roles) {
        if (err) {
            return callback(err);
        }

        var shareObject = {};
        for (var p = 0; p < principalIds.length; p++) {
            // Check if the principal already has a role on the content
            if (!roles[principalIds[p]]) {
                shareObject[principalIds[p]] = ContentConstants.roles.VIEWER;
            }
        }
        
        if (_.keys(shareObject).length === 0) {
            callback(null);
        } else {
            _setContentPermissions(ctx, contentObj, shareObject, function(err) {
                emitter.emit(ContentConstants.events.UPDATED_CONTENT_MEMBERS, ctx, contentObj.contentId);
                callback(err);
            });
        }
    });
};

/**
 * Check whether or not the current user can manage a piece of content
 * 
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the content object we want to check
 * @param  {Function}       callback            Standard callback function takes arguments `err`, `canManage`, and `content`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Boolean}        callback.canManage  Whether or not the user can manage the content
 * @param  {Content}        callback.content    The retrieved content object containing its basic profile
 */
var canManage = module.exports.canManage = function(ctx, contentId, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to manage content'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            if (err.code === 401) {
                return callback(null, false);
            } else {
                return callback(err);
            }
        }
        _canManage(ctx, contentObj, function(err, canManage) {
            if (err) {
                return callback(err);
            }
            callback(null, canManage, contentObj);
        });
    });
};

/**
 * Internal function that checks whether or not the current user can manage a piece of content. This function assumes that
 * the piece of content passed in actually exists
 * 
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentObj          The content object we want to check
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `canManage`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Boolean}        callback.canManage  Whether or not the user can manage the content
 * @api private
 */
var _canManage = function(ctx, contentObj, callback) {
    if (!ctx.user()) {
        return callback(null, false);
    } else if (ctx.user().isAdmin(contentObj.tenant)) {
        return callback(null, true);
    } else {
        AuthzAPI.hasRole(ctx.user().id, contentObj.contentId, ContentConstants.roles.MANAGER, callback);
    }
};

/**
 * Check whether or not the current user has access to a piece of content
 * 
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the content object we want to check
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `hasAccess`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Boolean}        callback.hasAccess  Whether or not the user has access to the content
 */
var hasAccess = module.exports.hasAccess = function(ctx, contentId, callback) {
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            // If the user doesn't have access to the content
            if (err.code ===  401) {
                return callback(null, false);
            } else {
                return callback(err);
            }
        }
        callback(null, true);
    });
};

/**
 * Internal function that checks whether or not the current user has access to a piece of content. This function assumes that
 * the piece of content passed in actually exists
 * 
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {Content}        contentObj          The content object representing the content item we're checking access for
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `canManage`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Boolean}        callback.canManage  Whether or not the user has access to the content
 * @api private
 */
var _hasAccess = function(ctx, contentObj, callback) {
    // If the content is public, I always get access
    if (contentObj.visibility === ContentConstants.visibility.PUBLIC) {
        return callback(null, contentObj);
    // If the content is visible to logged in users, I get access if I'm logged in
    } else if (contentObj.visibility === ContentConstants.visibility.LOGGEDIN && TenantsUtil.isLoggedIn(ctx, contentObj.tenant)) {
        return callback(null, contentObj);
    // if the user is admin of the content's tenant, they have access
    } else if (ctx.user() && ctx.user().isAdmin(contentObj.tenant)) {
        return callback(null, contentObj);
    // If the content is private
    } else if (ctx.user()) {
        return AuthzAPI.hasAnyRole(ctx.user().id, contentObj.contentId, callback);
    }

    return callback({'code': 401, 'msg': "You don't have access to this piece of content."});
};

/**
 * Update, add or remove the role of a set of principals on a piece of content
 * 
 * @param  {Context}         ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}          contentId           The id of the content object we want to set permissions on
 * @param  {Object}          newPermissions      Object where the keys represent the principal ids for which the content permissions should be updated/added/removed. The value is a string representing the new role. If false is passed in, the permissions for that principal will be removed e.g. {'user1': 'manager', 'user2': 'viewer', 'user3': false}
 * @param  {Function}        callback            Standard callback function takes argument `err`
 * @param  {Object}          callback.err        Error object containing the error message
 */
var setContentPermissions = module.exports.setContentPermissions = function(ctx, contentId, newPermissions, callback) {
    callback = callback || {};
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(_.keys(newPermissions).length, {'code': 400, 'msg': 'You should specify at least 1 user/group to set content permissions on'}).min(1);
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to create a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the content exists
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        // Check if the current user can manage the content
        _canManage(ctx, contentObj, function(err, canManage) {
            if (err) {
                return callback(err);
            } else if (!canManage) {
                return callback({'code': 401, 'msg': 'You are not allowed to manage this piece of content'});
            }

            // Add the new permissions to the content. This will then update the libraries as well
            _setContentPermissions(ctx, contentObj, newPermissions, function(err) {
                emitter.emit(ContentConstants.events.UPDATED_CONTENT_MEMBERS, ctx, contentObj.contentId);
                return callback(err);
            });
        });
    });
};

/**
 * Internal function used to update, add or remove the role of a set of principals on a piece of content. This function will assume that
 * the content object exists and that the current user is a manager of the content
 * 
 * @param  {Context}         ctx                 The current execution context
 * @param  {Content}         contentObj          The content object we want to set permissions on
 * @param  {Object}          newPermissions      Object where the keys represent the principal ids for which the content permissions should be updated/added/removed. The value is a string representing the new role. If false is passed in, the permissions for that principal will be removed e.g. {'user1': 'manager', 'user2': 'viewer', 'user3': false}
 * @param  {Function}        callback            Standard callback function takes argument `err`
 * @param  {Object}          callback.err        Error object containing the error message
 * @api private
 */
var _setContentPermissions = function(ctx, contentObj, newPermissions, callback) {
    // Check if all of the provided principals exist
    var principalIds = _.keys(newPermissions);
    PrincipalsUtil.getPrincipals(ctx, principalIds, function(err, principals) {
        if (err) {
            return callback(err);
        }

        // Extract all of the users that are removed from the content, so the content can be removed from their library
        var removedMembers = [];
        for (var i = 0; i < principalIds.length; i++) {
            var principalId = principalIds[i];
            if (newPermissions[principalId] === false) {
                removedMembers.push(principalId);
            } else if (!TenantsUtil.canInteract(contentObj.tenant, principals[principalId].tenant)) {
                // We shouldn't be sharing this with someone outside of this tenant
                return callback({'code': 400, 'msg': 'This content item cannot be shared with external user "' + principals[principalId].id + '".'})
            }
        }

        // Update the roles CF
        AuthzAPI.updateRoles(contentObj.contentId, newPermissions, function(err) {
            if (err) {
                return callback(err);
            }

            // Now update all of the libraries this affects
            _updateLibraries(contentObj, removedMembers, callback);
        });
    });
};

/**
 * Get all of the principals that are directly associated to a piece of content.
 * 
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the content object for which we want to get the members
 * @param  {String}         start               Determines the point at which content members are returned for paging purposes.  If not provided, the first x elements will be returned
 * @param  {Integer}        limit               Number of items to return. Will default to 10 if not provided
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `members`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Object[]}       callback.members    Array that contains an object for each member. Each object has a role property that contains the role of the member and a profile property that contains the principal profile of the member
 */
var getContentMembers = module.exports.getContentMembers = function(ctx, contentId, start, limit, callback) {
    limit = limit || 10;

    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        // Get the content members
        AuthzAPI.getAuthzMembers(contentObj.contentId, start, limit, function(err, members) {
            if (err) {
                return callback(err);
            }

            // Get the basic profiles for all of these principals
            var memberIds = _.map(members, function(member){ return member.id; });
            PrincipalsUtil.getPrincipals(ctx, memberIds, function(err, memberProfiles) {
                if (err) {
                    return callback(err);
                }
                
                // Merge the member profiles and roles into a single object
                var memberList = [];
                for (var m = 0; m < members.length; m++) {
                    if (memberProfiles[members[m].id]) {
                        memberList.push({
                            'profile': memberProfiles[members[m].id],
                            'role': members[m].role
                        });
                    }
                }
                callback(null, memberList);
            });
        });
    });
};

/**
 * Internal function that gets all of the principals that are directly associated to a piece of content. This function assumes
 * that the current user has access to the content
 * 
 * @param  {String}         contentId           The id of the content object for which we want to get the members
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `members`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Object[]}       callback.members    An array of hashes, where the 'id' property of the hash is the principal id, and the 'role' property of the hash is the role of the principal.
 * @api private
 */
var _getAllContentMembers = function(contentId, callback) {
    AuthzAPI.getAuthzMembers(contentId, null, 10000, callback);
};

/////////////////////////////
// Update content metadata //
/////////////////////////////

/**
 * Internal function that updates the lastMofidied date of a piece of content to the current time. This will be called by all functions
 * that update content metadata or when content is shared. This function assume that a valid content object is passed in.
 * 
 * @param  {Content}           contentObj          The content object for which we want to update the lastModified date
 * @param  {Function}          callback            Standard callback function takes argument `err`
 * @param  {Object}            callback.err        Error object containing the error message
 * @api private
 */
var _updateContentLastModified = function(contentObj, callback) {
    contentObj.lastModified = Date.now();
    Cassandra.runQuery('UPDATE Content USING CONSISTENCY QUORUM SET ? = ? WHERE contentId = ?', ['lastModified', contentObj.lastModified, contentObj.contentId], callback);
};

/**
 * Update the file body that is associated with a Sakai file.
 *
 * @param  {Context}    ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}     contentId           The ID of the content object that should be updated.
 * @param  {File}       file                An expressjs File object that holds the data for the file that needs updating.
 * @param  {Function}   [callback]          Standard callback function takes arguments `err` and `revision`
 * @param  {Object}     [callback.err]      Error object containing the error message
 */
var updateFileBody = module.exports.updateFileBody = function(ctx, contentId, file, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Error updating the filebody for %s', contentId);
        }
    };

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a content item'}).isLoggedInUser(ctx);
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(file, {'code': 400, 'msg': 'Missing file parameter.'}).notNull();
    if (file) {
        validator.check(file.type, {'code': 400, 'msg': 'Missing mimetype on the file object.'}).notEmpty();
        validator.check(file.size, {'code': 400, 'msg': 'Missing size on the file object.'}).notEmpty();
        validator.check(file.size, {'code': 400, 'msg': 'Invalid size on the file object.'}).isInt();
        validator.check(file.size, {'code': 400, 'msg': 'Invalid size on the file object.'}).min(0);
        validator.check(file.name, {'code': 400, 'msg': 'Missing name on the file object.'}).notEmpty();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    canManage(ctx, contentId, function(err, isManager, contentObj) {
        if (err) {
            return callback(err);
        } else if (!isManager) {
            return callback({'code': 401, 'msg': 'You are not allowed to manage this piece of content'});
        } else if (contentObj.contentType !== 'file') {
            return callback({'code': 400, 'msg': 'This content object is not a file.'});
        }

        // Store the file
        getStorageBackend(ctx).store(ctx, file, function(err, uri) {
            if (err) {
                return callback(err);
            }

            // Create the revision.
            var opts = {
                'mime': file.type,
                'size': file.size,
                'filename': file.name
            };
            _createRevision(ctx, contentObj.contentId, uri, opts, function(err, revision) {
                if (err) {
                    return callback(err);
                }

                // Set the new filesize, filename and mimetype on the Content object so the UI
                // can retrieve all the relevant metadata in 1 Cassandra query.
                var q = Cassandra.constructUpsertCQL('Content', 'contentId', contentId, opts, 'QUORUM');
                Cassandra.runQuery(q.query, q.parameters, callback);
            });
        });
    });
};

/**
 * Update a content item's name, description or visibility. This can only be done by the manager of that piece of content.
 *
 * @param  {Context}         ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}          contentId           The id of the content object for which we want to update the content profile
 * @param  {Object}          profileFields       Object where the keys represent the profile fields that need to be updated and the values represent the new values for those profile fields e.g. {'name': 'New content name', 'description': 'New content description', 'visibility': 'private'}
 * @param  {Function}        callback            Standard callback function takes argument `err`
 * @param  {Object}          callback.err        Error object containing the error message
 */
var updateContentMetadata = module.exports.updateContentMetadata = function(ctx, contentId, profileFields, callback) {
    callback = callback || function() {};
    
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    // Check that at a minimum name or description have been provided
    var fieldNames = profileFields ? _.keys(profileFields) : [];
    validator.check(fieldNames.length, {'code': 400, 'msg': 'You should at least specify a new name, description, visibility or link'}).min(1);
    for (var i = 0; i < fieldNames.length; i++) {
        var fieldName = fieldNames[i];
        validator.check(fieldName, {'code': 400, 'msg': fieldName + ' is not a recognized content profile field'}).isIn(['name', 'description', 'visibility', 'link']);
    }
    if (profileFields.hasOwnProperty('visibility')) {
        validator.check(profileFields['visibility'], {'code': 400, 'msg': 'An invalid content visibility option has been provided. This can be "private", "loggedin" or "public"'}).isIn(_.values(ContentConstants.visibility));
    }
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Do the actual update
    _updateContentMetadata(ctx, contentId, profileFields, callback);    
};

/**
 * Utility function that will be used to update metadata on a piece of content. Once the Content CF has been updated, 
 * the libraries in which the content shows will be updated as well. This function will assume that a valid contentId 
 * and valid content metadata is passed in
 * 
 * @param  {Context}         ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}          contentId           The id of the content object we want to update
 * @param  {Object}          metadata            Object where the keys represent the profile fields that need to be updated and the values represent the new values for those profile fields.
 * @param  {Function}        callback            Standard callback function takes argument `err`
 * @param  {Object}          callback.err        Error object containing the error message
 * @api private
 */
var _updateContentMetadata = function(ctx, contentId, metadata, callback) {
    // Fist check whether or not the current user is a manager of the piece of content
    canManage(ctx, contentId, function(err, canManage, contentObj) {
        if (err) {
            return callback(err);
        } else if (!canManage) {
            return callback({'code': 401, 'msg': 'You are not allowed to manage this piece of content'});
        }

        var q = Cassandra.constructUpsertCQL('Content', 'contentId', contentId, metadata, 'QUORUM');
        Cassandra.runQuery(q.query, q.parameters, function(err) {
            if (err) {
                return callback(err);
            }

            // Set the new metadata onto the content object
            contentObj = _.extend(contentObj, metadata);

            emitter.emit(ContentConstants.events.UPDATED_CONTENT, ctx, contentId, contentObj);

            // Update the last modified date and all associated libraries
            _updateLibraries(contentObj, [], callback);
        });
    });
};


// TODO: Split this out once we reorganize the content API
///////////////////////////
// Comment functionality //
///////////////////////////

/**
 * Retrieves a single comment from Cassandra and returns a Comment object in the callback function.
 *
 * @param  {Context}    ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}     commentId           The ID of the comment
 * @param  {Function}   callback            Standard callback function takes argument `err` and `comment`
 * @param  {Object}     callback.err        Error object containing the error message
 * @param  {Comment}    callback.comment    The retrieved comment object
 * @api private
 */
var _getComment = function(ctx, commentId, callback) {
    var validator = new Validator();
    validator.check(commentId, {'code': 400, 'msg': 'A comment id must be provided'}).isResourceId();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    Cassandra.runQuery('SELECT * FROM Comments USING CONSISTENCY QUORUM WHERE commentId = ?', [commentId], function (err, commentRows) {
        if (err) {
            return callback(err);
        }

        callback(err, _rowsToComments(commentRows)[0]);
    });
};

/**
 * Creates a comment on the specified content item. Returns an error if saving the comment goes wrong or the user doesn't have access.
 * Only logged in users who can see the content are able to post comments.
 *
 * @param  {Context}    ctx               Standard context object, representing the currently logged in user and its tenant
 * @param  {String}     contentId         The ID of the content to place the comment on
 * @param  {String}     body              The comment to place on the content item
 * @param  {String}     [replyTo]         The ID of the comment to reply to, optional
 * @param  {Function}   [callback]        Standard callback function takes argument `err`
 * @param  {Object}     [callback.err]    Error object containing the error message
 */
var createComment = module.exports.createComment = function(ctx, contentId, body, replyTo, callback) {
    callback = callback || function() {};

    // Parameter validation
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authorized users can post comments'}).isLoggedInUser(ctx);
    validator.check(contentId, {'code': 400, 'msg': 'Invalid content resource id provided.'}).isResourceId();
    validator.check(body, {'code': 400, 'msg': 'A comment must be provided'}).notEmpty();
    if (replyTo) {
        validator.check(replyTo, {'code': 400, 'msg': 'Invalid replyTo id provided.'}).isResourceId();
    }

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    hasAccess(ctx, contentId, function(err, hasAccess) {
        if (err) {
            return callback(err);
        }

        if (!hasAccess) {
            return callback({'code': 401, 'msg': 'Only authorized users can post comments'});
        }

        // Generate a unique comment ID
        var commentId = AuthzUtil.toId('comm', ctx.tenant().alias, ShortId.generate());

        if (replyTo) {
            _getComment(ctx, replyTo, function(err, commentReplyingTo) {
                if (err) {
                    return callback(err);
                }

                if (commentReplyingTo.contentId !== contentId) {
                    return callback({'code': 400, 'msg': 'The specified comment id is not associated to the specified content id'});
                }

                // Add comment to CommentsByContent CF
                // When replying to a comment the `|` needs to be replaced by a `#` to ensure correct ordering of the returned comments (threaded)
                // A reply on a comment looks like timestampA#timestampB| where a top level comment looks like timestampA|
                var created = commentReplyingTo.created.split('|')[0] + '#' + Date.now() + '|';
                var q = 'UPDATE CommentsByContent USING CONSISTENCY QUORUM SET ? = ? WHERE contentId = ?';
                Cassandra.runQuery(q, [created, commentId, contentId], function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Add comment to Comments CF
                    q = 'INSERT INTO Comments (commentId, body, createdBy, replyTo, level, contentId, created) VALUES (?, ?, ?, ?, ?, ?, ?)';
                    Cassandra.runQuery(q, [commentId, body, ctx.user().id, commentReplyingTo.commentId, commentReplyingTo.level + 1, contentId, created], function(err) {
                        if (err) {
                            return callback(err);
                        }

                        var comment = new Comment(commentId, body, contentId, ctx.user(), created, commentReplyingTo.level + 1, commentReplyingTo.commentId, false);
                        callback(null, comment);
                    });
                });
            });
        } else {
            // Generate a timestamp, add the `|` for correct sorting of threaded comments
            var created = Date.now() + '|';
            var queries = [{
                'query': 'INSERT INTO Comments (commentId, body, createdBy, created, contentId) VALUES (?, ?, ?, ?, ?)',
                'parameters': [commentId, body, ctx.user().id, created, contentId]
            }, {
                'query': 'UPDATE CommentsByContent SET ? = ? WHERE contentId = ?',
                'parameters': [created, commentId, contentId]
            }];
            Cassandra.runBatchQuery(queries, 'QUORUM', function(err) {
                if (err) {
                    return callback(err);
                }

                var comment = new Comment(commentId, body, contentId, ctx.user(), created, 0, null, false);
                callback(null, comment);
            });
        }
    });
};

/**
 * Retrieves the comments for a specified content item. Everyone who has access to the content item will be able to retrieve the list of comments.
 *
 * @param  {Context}    ctx                  Standard context object, representing the currently logged in user and its tenant
 * @param  {String}     contentId            The ID of the content to get comments for
 * @param  {String}     start                Determines the point at which content items are returned for paging purposed. If not provided, the first x elements will be returned
 * @param  {Integer}    limit                Number of items to return. Will default to 10 if not provided
 * @param  {Function}   callback             Standard callback function takes argument `err` and `comments`
 * @param  {Object}     callback.err         Error object containing the error message
 * @param  {Comment[]}  callback.comments    An array of Comment objects
 */
var getComments = module.exports.getComments = function(ctx, contentId, start, limit, callback) {
    limit = limit || 10;

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        // Page the query.
        var paging = Cassandra.getPagingParameters(start, limit);

        // Select first X comments from the CommentsByContent CF
        Cassandra.runQuery('SELECT FIRST ' + paging.limit + ' REVERSED ?..\'\' FROM CommentsByContent USING CONSISTENCY QUORUM WHERE contentId = ?', [paging.start, contentId], function (err, rows) {  
            if (err) {
                return callback(err);
            }

            var row = rows[0];
            if (!row.count) {
                return callback(null, []);
            }

            // Get detailed comment information
            var commentIds = [];
            for (var i = paging.startIndex; i < row.count; i++) {
                commentIds.push(row[i].value);
            }

            if (commentIds.length === 0) {
                return callback(null, []);
            }

            Cassandra.runQuery('SELECT * FROM Comments USING CONSISTENCY QUORUM WHERE commentId IN (?)', [commentIds], function (err, commentsRows) {
                if (err) {
                    return callback(err);
                }

                if (commentsRows.length === 0) {
                    return callback(null, []);
                }

                // Add comments to the Array to return
                var comments = _rowsToComments(commentsRows);

                // Get information on the commenters
                var userIds = [];
                for (var ii = 0; ii < comments.length; ii++) {
                    // Filter out duplicates
                    if (_.indexOf(userIds, comments[ii].createdBy) === -1) {
                        userIds.push(comments[ii].createdBy);
                    }

                    // When a comment is deleted not all data needs to go back to the UI. The level
                    // will be used to determine the comment's indentation, and created will be used
                    // for paging purposes
                    if (comments[ii].deleted === true) {
                        comments[ii] = new Comment(comments[ii].commentId, null, null, null, comments[ii].created, comments[ii].level, null, true);
                    }
                }

                // Get the basic principal profiles of the commenters to add to the comments as `createdBy`.
                PrincipalsUtil.getPrincipals(ctx, userIds, function(err, principals) {
                    if (err) {
                        return callback(err);
                    }

                    for (var iii = 0; iii < comments.length; iii++) {
                        comments[iii].createdBy = principals[comments[iii].createdBy];
                    }
                    callback(err, comments);
                });
            });
        });
    });
};

/**
 * Deletes a comment from a content item. Managers of the content can delete all comments whilst people that have access
 * to the content can only delete their own comments. Therefore, anonymous users will never be able to delete comments.
 *
 * @param  {Context}    ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}     contentId           The ID of the content to delete the comment from
 * @param  {String}     commentId           The ID of the comment
 * @param  {Function}   callback            Standard callback function takes argument `err`
 * @param  {Object}     callback.err        Error object containing the error message
 * @param  {Boolean}    callback.deleted    Will be `true` when the comment has been fully deleted, will be `false` when the comment wasn't fully deleted because it still has replies
 */
var deleteComment = module.exports.deleteComment = function(ctx, contentId, commentId, callback) {

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authorized users can post comments'}).isLoggedInUser(ctx);
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(commentId, {'code': 400, 'msg': 'A comment id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        _getComment(ctx, commentId, function(err, comment) {
            if (err) {
                return callback(err);
            }

            if (comment.contentId !== contentId) {
                return callback({'code': 400, 'msg': 'The specified comment id is not associated to the specified content id'});
            }

            // Besides having access to the content the comment needs to be authored by the user
            // or the user needs to be a content manager.
            _canManage(ctx, contentObj, function(err, canManage) {
                if (err) {
                    return callback(err);
                }

                var canDelete = (canManage || ctx.user().id === comment.createdBy);
                if (!canDelete) {
                    return callback({'code': 401, 'msg': 'You don\t have the appropriate priviliges to delete this comment'});
                }

                // The content exists and we have access
                // Get the comment and the comment following it to check if there's a reply.
                getComments(ctx, contentId, comment.created, 1, function(err, comments) {
                    if (err) {
                        return callback(err);
                    }

                    if (comments.length > 0 && comments[0].replyTo === commentId) {
                        // If there is a reply, mark the message as deleted but don't delete
                        var q = 'UPDATE Comments USING CONSISTENCY QUORUM SET deleted = ? WHERE commentId = ?';
                        Cassandra.runQuery(q, [true, commentId], function(err) {
                            callback(err, false);
                        });
                    } else {
                        var queries = [{
                            'query': 'DELETE ? FROM CommentsByContent WHERE contentId = ?',
                            'parameters': [comment.created, comment.contentId]
                        }, {
                            'query': 'DELETE FROM Comments WHERE commentId = ?',
                            'parameters': [comment.commentId]
                        }];
                        Cassandra.runBatchQuery(queries, 'QUORUM', function(err) {
                            callback(err, true);
                        });
                    }
                });
            });
        });
    });
};


///////////////////////////
// Library functionality //
///////////////////////////

/**
 * Internal function that updates the libraries of all of the members of a piece of content. This will remove the old entry with
 * the old lastModified date/sorting and add the new one. This function assumes that a valid content item is passed in
 * 
 * @param  {Content}        contentObj          The content object for which we want to update in all libraries
 * @param  {String[]}       removedMembers      Array of principal ids that contains all principal that have been removed as a member of the content, and therefore their libraries should be updated so the content is removed.
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `members`
 * @param  {Object}         callback.err        Error object containing the error message
 * @api private
 */
var _updateLibraries = function(contentObj, removedMembers, callback) {
    // First update the lastmodified date of the content
    var oldLastModified = contentObj.lastModified;
    _updateContentLastModified(contentObj, function(err) {
        if (err) {
            return callback(err);
        }
        // Remove all of the old lastModified from everyone's library and add the new lastModified based one
        removedMembers = removedMembers || [];
        _getAllContentMembers(contentObj.contentId, function(err, members) {
            if (err) {
                return callback(err);
            }
            var queries = [];
            for (var m = 0; m < members.length; m++) {
                var member = members[m].id;
                // Only remove the old entries if the piece of content existed before and
                // the old lastModified date has been provided
                if (oldLastModified) {
                    // Remove the old entry in the private row
                    queries.push({
                        'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                        'parameters': [oldLastModified + ':' + contentObj.contentId, member]
                    });
                    // Remove the old entry in the loggedin row
                    queries.push({
                        'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                        'parameters': [oldLastModified + ':' + contentObj.contentId, member + '#' + ContentConstants.visibility.LOGGEDIN]
                    });
                    // Remove the old entry in the public row
                    queries.push({
                        'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                        'parameters': [oldLastModified + ':' + contentObj.contentId, member + '#' + ContentConstants.visibility.PUBLIC]
                    });
                }
                // Add it back to the private row
                queries.push({
                    'query': 'UPDATE LibraryByPrincipal SET ? = ? WHERE principalId = ?',
                    'parameters': [contentObj.lastModified + ':' + contentObj.contentId, contentObj.contentId, member]
                });
                // Add it back to the logged in row
                if (contentObj.visibility === ContentConstants.visibility.LOGGEDIN || contentObj.visibility === ContentConstants.visibility.PUBLIC) {
                    queries.push({
                        'query': 'UPDATE LibraryByPrincipal SET ? = ? WHERE principalId = ?',
                        'parameters': [contentObj.lastModified + ':' + contentObj.contentId, contentObj.contentId, member + '#' + ContentConstants.visibility.LOGGEDIN]
                    });
                }
                // Add it back to the public row
                if (contentObj.visibility === ContentConstants.visibility.PUBLIC) {
                    queries.push({
                        'query': 'UPDATE LibraryByPrincipal SET ? = ? WHERE principalId = ?',
                        'parameters': [contentObj.lastModified + ':' + contentObj.contentId, contentObj.contentId, member + '#' + ContentConstants.visibility.PUBLIC]
                    });
                }
            }
            // Remove the content from the libraries of all removed members
            for (var r = 0; r < removedMembers.length; r++) {
                if (oldLastModified) {
                    var removedMember = removedMembers[r];
                    // Remove the old entry in the private row
                    queries.push({
                        'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                        'parameters': [oldLastModified + ':' + contentObj.contentId, removedMember]
                    });
                    // Remove the old entry in the loggedin row
                    queries.push({
                        'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                        'parameters': [oldLastModified + ':' + contentObj.contentId, removedMember + '#' + ContentConstants.visibility.LOGGEDIN]
                    });
                    // Remove the old entry in the public row
                    queries.push({
                        'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                        'parameters': [oldLastModified + ':' + contentObj.contentId, removedMember + '#' + ContentConstants.visibility.PUBLIC]
                    });
                }
            }
            Cassandra.runBatchQuery(queries, 'QUORUM', callback);
        });
    });
};

/**
 * Get the content items inside of an authorizable's library. If the user requests its own library or the library of a group he's a member of,
 * the full list will be returned. If the user is logged in, but not a manager of the library, the :loggedin stream will be returned, containing
 * only content that's visible to logged in people or the public. In case of an anonymous user, the :public stream will be returned, containing
 * only content that is public.
 * 
 * @param  {Context}        ctx               Standard context object containing the current user and the current tenant
 * @param  {String}         principalId       The principal id of the library we're requesting
 * @param  {String}         start             Determines the point at which content items are returned for paging purposed. If not provided, the first x elements will be returned
 * @param  {Integer}        limit             Number of items to return. Will default to 10 if not provided
 * @param  {Function}       callback          Standard callback function takes arguments `err` and `content`
 * @param  {Object}         callback.err      Error object containing the error message
 * @param  {Content[]}      callback.content  Array of basic content profiles representing the requested items in the library
 */
var getLibraryItems = module.exports.getLibraryItems = function(ctx, principalId, start, limit, callback) {
    limit = limit || 10;

    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'A user or group id must be provided'}).notEmpty();
    validator.check(limit, {'code': 400, 'msg': 'A valid limit should be passed in'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var principal = AuthzUtil.getPrincipalFromId(principalId);
    // Check if we are looking at a user library
    if (PrincipalsUtil.isUser(principalId)) {
        // We give the user the public content stream in case the user is not logged in to the user's tenant
        if (!TenantsUtil.isLoggedIn(ctx, principal.tenantAlias)) {
            principalId = principalId + '#' + ContentConstants.visibility.PUBLIC;
        // We give the user the logged in content stream in case the current user is not
        // the same as the library we're looking at
        } else if (ctx.user().id !== principalId) {
            principalId = principalId + '#' + ContentConstants.visibility.LOGGEDIN;
        }
        
        return _getLibraryItems(principalId, start, limit, callback);
    // Check if we are looking at a group library
    } else if (PrincipalsUtil.isGroup(principalId)) {
        // We give the user the public content stream in case the user is not logged in
        if (!ctx.user()) {
            principalId = principalId + '#' + ContentConstants.visibility.PUBLIC;
            return _getLibraryItems(principalId, start, limit, callback);
        } else {
            // Check if the current user is a member of the group
            AuthzAPI.hasAnyRole(ctx.user().id, principalId, function(err, hasAnyRole) {
                if (err) {
                    return callback(err);
                }

                // If the user is not a member, but is authenticated to the group's tenant, we give him the logged in content stream
                if (!hasAnyRole && TenantsUtil.isLoggedIn(ctx, principal.tenantAlias)) {
                    principalId = principalId + '#' + ContentConstants.visibility.LOGGEDIN;
                // otherwise, we give them public library
                } else if (!hasAnyRole) {
                    principalId = principalId + '#' + ContentConstants.visibility.PUBLIC;
                }

                return _getLibraryItems(principalId, start, limit, callback);
            });
        }
    // If the passed in principal id is neither a group or user, we return an error
    } else {
        return callback({'code': 400, 'msg': 'An unrecognized principal id (' + principalId + ') has been passed in'});
    }
};

/**
 * Internal function that will be used to get a user's or group's library. This function assumes that all permission check will have
 * been done and the processed principal id is passed in. It also assumes that a valid start and limit parameter are passed in.
 * 
 * @param  {String}         libraryId         The library id of the library we're requesting. This is the processed library principal id, meaning that it will be the principal id when direct access is allowed, principalId#loggedin if the user is logged to the tenant, or principalId#public for otherwise unprivileged users
 * @param  {String}         start             Determines the point at which content items are returned for paging purposed.  If not provided, the first x elements will be returned
 * @param  {Integer}        limit             Number of items to return. Will default to 10 if not provided
 * @param  {Function}       callback          Standard callback function takes arguments `err` and `content`
 * @param  {Object}         callback.err      Error object containing the error message
 * @param  {Content[]}      callback.content  Array of basic content profiles representing the requested items in the library
 * @api private
 */
var _getLibraryItems = function(principalId, start, limit, callback) {
    // Page the query.
    var paging = Cassandra.getPagingParameters(start, limit);

    Cassandra.runQuery('SELECT FIRST ' + paging.limit + ' REVERSED ?..\'\' FROM LibraryByPrincipal USING CONSISTENCY QUORUM WHERE principalId = ?', [paging.start, principalId], function (err, rows) {
        if (err) {
            return callback(err);
        }

        var items = [];
        for (var r = paging.startIndex; r < rows[0].count; r++) {
            items.push(rows[0][r].value);
        }
        // Get the content profiles of the content items, assuming that
        // we have access to all of the returned items
        _getMultipleContentItems(items, callback);
    });
};

/**
 * Get the storage backend for a uri, if the uri is unspecified it will return the default backend for a tenant.
 * If the backend could not be found, this will throw an error!
 * The uri will be checked before defaulting to the configured tenant backend. This allows for a tenant
 * to switch storage systems yet still serve the old files.
 *
 * @param  {Context}    ctx     The current execution context.
 * @param  {String}     [uri]   An optional URI.
 * @return {Backend}            The appropriate backend.
 */
var getStorageBackend = module.exports.getStorageBackend = function(ctx, uri) {
    var backendName = null;
    if (uri) {
        backendName = uri.split(':')[0];
    } else {
        // Use the tenant's default.
        backendName = Config.getValue(ctx.tenant().alias, 'storage', 'backend');
        if (backendName === null) {
            log().error('There was no storage backend configured, this should not happen.');
            throw new Error('There was no storage backend configured, this should not happen.');
        }
    }
    if (!_backends[backendName]) {
        try {
            _backends[backendName] = require('oae-content/lib/backends/' + backendName);
        } catch (err) {
            log().error({'err': err}, 'Couldn\'t load the backend %s', backendName);
            throw new Error('Could not find storage back-end ' + backendName);
        }
    }

    return _backends[backendName];
};

///////////////
// Revisions //
///////////////

/**
 * Internal method for creating revision.
 * This method assumes that the current user has sufficient rights to create a new revision.
 *
 * @param {Context}     ctx                 Current execution context.
 * @param {String}      contentId           The contentId this revision is for.
 * @param {String}      uri                 A URI for this revision
 * @param {Object}      [opts]              Extra options that should be stored on the revision.
 * @param {Function}    [callback]          An optional callback method.
 * @param {Object}      [callback.err]      An error object (if any)
 * @param {Revision}    [callback.revision] A revision object.
 * @api private
 */
var _createRevision = function(ctx, contentId, uri, opts, callback) {
    // Copy all the options (if any)
    var values = opts || {};

    // Add some more meta data.
    values.contentId = contentId;
    values.created = Date.now();
    values.createdBy = ctx.user().id;
    values.uri = uri;
    var revisionId = AuthzUtil.toId('rev', ctx.tenant().alias, ShortId.generate());
    var q = Cassandra.constructUpsertCQL('Revisions', 'revisionId', revisionId, values, 'QUORUM');
    Cassandra.runQuery(q.query, q.parameters, function(err) {
        if (err) {
            return callback(err);
        }

        // Add the revision to the list.
        Cassandra.runQuery('UPDATE RevisionByContent SET ?=? WHERE contentId=?', [values.created, revisionId, contentId], function(err) {
            if (err) {
                return callback(err);
            }
            var revision = new Revision(contentId, revisionId, values.created, values.createdBy, values.uri, opts);
            callback(null, revision);
        });
    });
};

/**
 * Get the revisions that are associated to a piece of content.
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the object for which we want to get the revisions
 * @param  {String}         start               Determines the point at which revisions are returned for paging purposes.  If not provided, the first x elements will be returned
 * @param  {Integer}        limit               Number of revisions to return. Will default to 10 if not provided
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `revisions`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Revision[]}     callback.revisions  Array that contains an object for each revision.
 */
var getRevisions = module.exports.getRevisions = function(ctx, contentId, start, limit, callback) {
    limit = limit || 10;

    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A contentId must be provided'}).isResourceId();
    validator.check(limit, {'code': 400, 'msg': 'A valid limit should be passed in'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the user has access on this contentId
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        _getRevisions(ctx, contentId, start, limit, callback);
    });
};

/**
 * Internal method that retrieves revisions but performs no authorization checks.
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the object for which we want to get the revisions
 * @param  {String}         start               Determines the point at which revisions are returned for paging purposes.  If not provided, the first x elements will be returned
 * @param  {Integer}        limit               Number of revisions to return. Will default to 10 if not provided
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `revisions`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Revision[]}     callback.revisions  Array that contains an object for each revision.
 * @api private
 */
var _getRevisions = function(ctx, contentId, start, limit, callback) {
    // Page the query.
    var paging = Cassandra.getPagingParameters(start, limit);
    Cassandra.runQuery('SELECT FIRST ' + paging.limit + ' REVERSED ?..\'\' FROM RevisionByContent USING CONSISTENCY QUORUM WHERE contentId = ?', [paging.start, contentId], function (err, rows) {
        if (err) {
            return callback(err);
        }

        var revisionsToRetrieve = [];
        for (var c = paging.startIndex; c < rows[0].count; c++) {
            revisionsToRetrieve.push(rows[0][c].value);
        }
        if (revisionsToRetrieve.length === 0) {
            return callback(null, []);
        }

        Cassandra.runQuery('SELECT * FROM Revisions WHERE revisionId IN (?)', [revisionsToRetrieve], function(err, rows) {
            if (err) {
                return callback(err);
            }

            // Generate the Revision objects.
            var revisions = [];
            for (var i = 0; i < rows.length; i++) {
                var revision = _rowToRevision(rows[i]);
                revisions.push(revision);
            }

            var userIds = _.map(revisions, function(revisions) { return revisions.createdBy; });
            PrincipalsUtil.getPrincipals(ctx, userIds, function(err, users) {
                if (err) {
                    return callback(err);
                }

                // Add the user profiles to the revisions.
                // Do any other tasks (ex: signing of URLs) here.
                for (var r = 0; r < revisions.length; r++) {
                    if (users[revisions[r].createdBy]) {
                        revisions[r].createdBy = users[revisions[r].createdBy];
                        revisions[r].link = '/api/content/' + contentId + '/download/' + revisions[r].revisionId;
                    }
                }
                callback(null, revisions);
            });
        });
    });
};

/**
 * Get a specific revision for a piece of content.
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the content for which we want to get the revision
 * @param  {String}         [revisionId]        The id of the revision that needs to be retrieved, if left null the latest will be retrieved.
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Revision}       callback.revision   The retrieved revision
 */
var getRevision = module.exports.getRevision = function(ctx, contentId, revisionId, callback) {
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A valid contentId must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    /**
     * Adds the download link on the revision.
     * @param {Object}      err      Error object containing the error message
     * @param {Revision}    revision The retrieved revision
     */
    var addDownloadLink = function(err, revision) {
        if (err) {
            return callback(err);
        }

        revision.link = getStorageBackend(ctx, revision.uri).getDownloadLink(ctx, revision.uri);
        callback(null, revision);
    };

    if (!revisionId || revisionId === '') {
        // Get the latest one.
        return getLatestRevision(ctx, contentId, addDownloadLink);
    }

    // Get a specific one.
    // Check if the user has access on this contentId
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        Cassandra.runQuery('SELECT * FROM Revisions WHERE RevisionId = ?', [revisionId], function (err, rows) {
            if (err) {
                return callback(err);
            }

            // Cassandra always returns the key as a column so the _colCount will always be 1.
            if (rows[0].count <= 1) {
                return callback({'code': 404, 'msg': 'Couldn\'t find revision: ' + revisionId});
            }

            var revisionObj = _rowToRevision(rows[0]);
            // Double check that this revision is really attached to the specified contentId.
            // This is to counter that someone tries to get the revision of a piece of content he has no access to.
            // ex: Alice has access to c:cam:aliceDoc but not to c:cam:bobDoc which has revision rev:cam:foo
            // doing getRevision(ctx, 'c:cam:aliceDoc', 'rev:cam:foo', ..) should return this error.
            if (revisionObj.contentId !== contentId) {
                return callback({'code': 401, 'msg': 'This revision ID is not associated with the specified piece of content.'});
            }

            addDownloadLink(null, revisionObj);
        });
    });
};

/**
 * Gets the most current revision
 *
 * @param  {Context}    ctx                 Current execution context.
 * @param  {String}     contentId           The id of the object for which we want to get the revisions
 * @param  {Function}   callback            Standard callback function takes arguments `err` and `revision`
 * @param  {Object}     callback.err        Error object containing the error message
 * @param  {Revision}   callback.revision   The latest revision
 */
var getLatestRevision = module.exports.getLatestRevision = function(ctx, contentId, callback) {
    getRevisions(ctx, contentId, null, 1, function(err, revisions) {
        if (err) {
            return callback(err);
        }

        if (revisions.length === 0) {
            return callback({'code': 404, 'msg': 'No revision found for ' + contentId});
        }

        callback(null, revisions[0]);
    });
};

/**
 * Verifies if a uri and signature match up and returns an object that the REST handlers can use to redirect users
 * to the actual download page.
 *
 * @param {Context}     ctx                             Current execution context.
 * @param {String}      uri                             The URI of a file.
 * @param {String}      expires                         When the signature expires, in milliseconds since epoch.
 * @param {String}      signature                       The signature of the uri.
 * @param {Object}      callback.err                    Error object containing the error message
 * @param {Object}      callback.data                   The object that contains the data that the REST handler can use.
 * @param {Object}      callback.data.link              The link object with an http status code and a url
 * @param {Object}      callback.data.link.code         The HTTP status code (usually 204 or 301/302)
 * @param {Object}      callback.data.link.url          The url where the user should be redirected to.
 * @param {Object}      callback.data.opts.filename     The filename of the file that the user wishes to download.
 */
var verifySignedUri = module.exports.verifySignedUri = function(ctx, uri, expires, signature, callback) {
    var validator = new Validator();
    validator.check(uri, {'code': 400, 'msg': 'Missing uri'}).notNull();
    validator.check(expires, {'code': 400, 'msg': 'Missing expires'}).notNull();
    validator.check(signature, {'code': 400, 'msg': 'Missing signature'}).notNull();
    validator.check(signature, {'code': 401, 'msg': 'Invalid signature'}).verifyExpiringSignature(ctx.tenant().alias, expires, uri);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    var link = getStorageBackend(ctx, uri).getDownloadLink(ctx, uri);
    var data = {
        'link': link,
        'opts': {
            'filename': Path.basename(uri)
        }
    }
    callback(null, data);
};

/**
 * Converts a Cassandra Row to a Revision object.
 *
 * @param  {Row}        row         A Helenus Row
 * @return {Revision}               A revision object or null if the column could not be converted.
 * @api private
 */
var _rowToRevision = function(row) {
    var hash = Cassandra.rowToHash(row);
    var opts = {};
    opts.mime = hash.mime || 'application/octet-stream';
    if (hash.filename) {
        opts.filename = hash.filename;
    }
    if (hash.size) {
        opts.size = hash.size;
    }
    return new Revision(hash.contentId, hash.revisionId, hash.created, hash.createdBy, hash.uri, opts);
};

///////////////////////
// Utility functions //
///////////////////////

/**
 * Creates a Content item from a Cassandra row.
 * 
 * @param  {Row}    row    Cassandra Row
 * @return {Group}         Converted content object
 * @api private
 */
var _rowToContent = function(row) {
    var hash = Cassandra.rowToHash(row);
    var contentObj = new Content(hash.tenant, hash.contentId, hash.visibility, hash.name, hash.description, hash.contentType, hash.createdBy, hash.created, hash.lastModified);
    if (contentObj.contentType === 'file') {
        contentObj.filename = hash.filename;
        contentObj.size = hash.size;
        contentObj.mime = hash.mime;
        contentObj.downloadLink = '/api/content/' + hash.contentId + '/download';
    } else if (contentObj.contentType === 'link') {
        contentObj.link = hash.link;
    }
    return contentObj;
};

/**
 * Creates and returns an array of content comments from an Array of rows retrieved from Cassandra.
 *
 * @param  {Rows}        commentRows    Cassandra rows retrieved from the Comments CF containing comment details and references to the CommentByContentId CF
 * @return {Comment[]}                  Returns a Array of Comment objects.
 * @api private
 */
var _rowsToComments = function(commentRows) {
    var commentsArr = [];
    for (var i = 0; i < commentRows.length; i++) {
        commentRows[i] = Cassandra.rowToHash(commentRows[i]);
        var comment = new Comment(commentRows[i].commentId, commentRows[i].body, commentRows[i].contentId, commentRows[i].createdBy, commentRows[i].created, commentRows[i].level, commentRows[i].replyTo, commentRows[i].deleted);
        commentsArr.push(comment);
    }
    return commentsArr;
}
