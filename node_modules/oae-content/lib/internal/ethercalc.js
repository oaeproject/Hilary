/*!
 * Copyright 2018 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

const _ = require('underscore');
const cheerio = require('cheerio');
const Ethercalc = require('ethercalc-client');
const url = require('url');

const log = require('oae-logger').logger('ethercalc');

const ContentDAO = require('./dao');
let ethercalcConfig = null;
let ethercalc = null;

const SOCIAL_CALC_FORMAT_BEGIN_LINE = 'socialcalc:version:1.0';
const SOCIAL_CALC_FORMAT_END_LINE = '--SocialCalcSpreadsheetControlSave--';

/**
 * Refresh the runtime ethercalc configuration (host, port, etc...) with the one provided. More
 * documentation about the ethercalc configuration may be found in the `config.ethercalc` key of the
 * default config.js file.
 *
 * @param  {Object}   ethercalcConfig    The ethercalc config from config.js
 */
const refreshConfiguration = function(_ethercalcConfig) {
    // Remember this config.
    ethercalcConfig = _ethercalcConfig;
    ethercalc = new Ethercalc(ethercalcConfig.host, ethercalcConfig.port, ethercalcConfig.protocol);
};

/**
 * Get the Ethercalc configuration.
 *
 * @return {Object} The Ethercalc configuration.
 */
const getConfig = function() {
    return ethercalcConfig;
};

/**
 * Creates a new spreadsheet via the Ethercalc API.
 *
 * @param  {Object}     content                         An object containing the data for an Ethercalc room
 * @param  {Function}   callback                        Standard callback function
 * @param  {Object}     callback.err                    An error that occurred, if any
 * @param  {Object}     callback.snapshot               A snapshot containing data for new Ethercalc room
 */
const createRoom = function(content, callback) {
    const contentId = content.contentId;
    log().trace({ contentId: contentId }, 'Creating Ethercalc room');
    ethercalc
        .createRoom()
        .then(data => {
            // Ethercalc returns the relative path so strip out starting /
            const roomId = data.slice(1);
            log().info({ contentId: contentId, ethercalcRoomId: roomId }, 'Created Ethercalc room');
            return callback(null, roomId);
        })
        .catch(err => {
            log().error(
                { err: err, contentId: contentId, ethercalcRoomId: roomId, ethercalc: ethercalcConfig.host },
                'Could not create Ethercalc room'
            );
            return callback(err);
        });
};

/**
 * Deletes an existing Ethercalc room via the Ethercalc API.
 *
 * @param  {String}     roomId          The id of the Ethercalc room that should be deleted
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
const deleteRoom = function(roomId, callback) {
    log().trace({ roomId: roomId, ethercalc: ethercalcConfig.host }, 'Deleting Ethercalc room');
    ethercalc
        .deleteRoom(roomId)
        .then(deleted => {
            if (deleted) {
                log().info('Deleted Ethercalc room');
                return callback(null);
            } else {
                log().error(
                    { code: 500, msg: 'Encountered error while deleting Ethercalc room' },
                    'Encountered error while deleting Ethercalc room'
                );
                return callback({ code: 500, msg: 'Could not delete Ethercalc room' });
            }
        })
        .catch(err => {
            log().error(
                { err: err, roomId: roomId, ethercalc: ethercalcConfig.host },
                'Could not delete Ethercalc room'
            );
            return callback(err);
        });
};

/**
 * Get the HTML for a room
 *
 * @param  {String}     roomId          The id for which the HTML should be retrieved from ethercalc
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 * @param  {String}     callback.html   The HTML for this room
 */
const getHTML = function(roomId, callback) {
    log().trace({ roomId: roomId, ethercalc: ethercalcConfig.host }, 'Getting Ethercalc room as HTML');
    ethercalc
        .getHTML(roomId)
        .then(html => {
            if (!_isHtmlDocument(html)) {
                log().error(
                    { roomId: roomId, ethercalc: ethercalcConfig.host },
                    'Ethercalc sheet contents are not valid HTML'
                );
                return callback({ code: 500, msg: 'Ethercalc sheet contents are not valid HTML' });
            }
            return callback(null, html);
        })
        .catch(err => {
            log().error(
                { err: err, roomId: roomId, ethercalc: ethercalcConfig.host },
                'Could not grab the HTML from ethercalc'
            );
            return callback({ code: 500, msg: 'Could not grab the HTML from ethercalc' });
        });
};

/**
 * Fetch an ethercalc room
 *
 * @param  {String}     roomId          The content id for which the HTML should be retrieved from ethercalc
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 * @param  {String}     callback.data   This room in socialcalc format
 */
const getRoom = function(roomId, callback) {
    log().trace({ roomId: roomId, ethercalc: ethercalcConfig.host }, 'Getting Ethercalc room in socialcalc format');
    ethercalc
        .getRoom(roomId)
        .then(data => {
            if (!_isSCDocument(data)) {
                log().error(
                    { roomId: roomId, ethercalc: ethercalcConfig.host },
                    'Ethercalc sheet contents are not in correct socialcalc format'
                );
                return callback({ code: 500, msg: 'Ethercalc sheet contents are not in correct socialcalc format' });
            }
            log().trace({ roomId: roomId, ethercalc: ethercalcConfig.host }, 'Fetched ethercalc room');
            return callback(null, data);
        })
        .catch(err => {
            log().error(
                { err: err, roomId: roomId, ethercalc: ethercalcConfig.host },
                'Could not fetch Ethercalc room in socialcalc format'
            );
            return callback({ code: 500, msg: 'Could not fetch Ethercalc room in socialcalc format' });
        });
};

/**
 * Set the contents for a room
 *
 * @param  {String}     roomId          The content id for which the HTML should be set in ethercalc
 * @param  {String}     snapshot        The data that should be used for the ethercalc room in SC format
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
const setSheetContents = function(roomId, snapshot, callback) {
    log().trace({ roomId: roomId, snapshot: snapshot, ethercalc: ethercalcConfig.host }, 'Setting Ethercalc contents');

    ethercalc
        .overwrite(roomId, snapshot, 'socialcalc')
        .then(response => {
            return callback(null);
        })
        .catch(err => {
            log().error(
                { err: err, roomId: roomId, ethercalc: ethercalcConfig.host },
                'Could not set sheet contents on the Ethercalc instance'
            );
            return callback({ code: 500, msg: 'Could not set sheet contents on the Ethercalc instance' });
        });
};

/**
 * Joins the current user in an ethercalc room.
 * This assumes that the current user has access to the collaborative spreadsheet.
 *
 * @param  {Context}    ctx                     Standard context object containing the current user and the current tenant
 * @param  {Content}    contentObj              The content object for the room that should be joined
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {String}     callback.url            The URL that can be used to embed the room
 */
const joinRoom = function(ctx, contentObj, callback) {
    const user = ctx.user();
    if (!user) {
        return callback({ code: 401, msg: 'Anonymous users are not allowed to join collaborative spreadsheets' });
    }

    log().trace(`Joining Ethercalc room ${contentObj.ethercalcRoomId} as user ${user}`);

    // Get the language for the current user.
    const language = user.locale ? _.first(user.locale.split('_')) : 'en';
    const url = getRoomUrl(contentObj, user.id, language);
    return callback(null, { url: url });
};

/**
 * Get the URL where users can view the ethercalc room.
 * This can be used to embed in the page via an iframe.
 * The URL will be of the form:
 *     http://<ethercalc host>:<ethercalc port>/<room ID>?contentId=<contentId>&displayName=<content.displayName>&authorId=<authorId>&language=en
 *
 * @param  {Content}    contentObj                  The content object for the room that should be joined
 * @param  {String}     userId                      The ID of the user in OAE
 * @param  {String}     [language]                  The 2 character string that identifies the user's prefered language
 * @return {String}                                 The URL to the room that can be used to embed in a page
 */
const getRoomUrl = function(contentObj, userId, language) {
    return url.format({
        protocol: ethercalcConfig.protocol,
        hostname: ethercalcConfig.host,
        port: ethercalcConfig.port,
        pathname: contentObj.ethercalcRoomId,
        query: {
            author: userId,
            content: contentObj.id
        }
    });
};

/**
 * Determine if the given sheet is empty. Works with both socialcalc and HTML formats.
 *
 * @param  {String}     content             The content of the ethercalc spreadsheet
 * @return {Boolean}                        Whether or not the content is considered empty
 */
const isContentEmpty = function(content) {
    if (!content) {
        return true;
    }

    if (_isHtmlDocument(content)) {
        // Empty sheets only have a single cell
        if (content.match(/cell_[\w][\d]/g).length === 1) {
            // Make sure that cell is empty
            const $ = cheerio.load(content);
            return $('#cell_A1').text();
        }
        return false;
    }
    // Check for existing cell values in social calc format. Cells are in format: `cell:A1:t:test`
    return content.test(/\bcell\:\w\d/g);
};

/**
 * Determine if one set of ethercalc HTML content is equal to another.
 *
 * @param  {String}     one         Content of one ethercalc document
 * @param  {String}     other       Content of another ethercalc document
 * @return {Boolean}                Whether or not the content is equivalent to eachother
 */
var isContentEqual = function(one, other) {
    if (one === other) {
        return true;
    } else if (!one || !other) {
        return false;
    }

    var $one = cheerio.load(one);
    var $other = cheerio.load(other);
    return $one('table').html() === $other('table').html();
};

/**
 * Record which user has edited an Ethercalc room
 *
 * @param  {Object}     data                    An object containing the OAE user ID and content ID
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @api private
 */
const setEditedBy = function(data, callback) {
    if (data.contentId && data.userId) {
        ContentDAO.Ethercalc.setEditedBy(data.contentId, data.userId, function(err) {
            if (err) {
                return callback(err);
            }
            return callback(null);
        });
    }
};

/**
 * Determine if the given content is a valid HTML table
 *
 * @param  {String}     content     The content to check
 * @return {Boolean}                Whether or not the content is a valid HTML spreadsheet
 * @api private
 */
const _isHtmlDocument = function(content) {
    if (!content) {
        return false;
    }

    const $ = cheerio.load(content);
    return $('table').length > 0;
};

/**
 * Determine if the given content is in valid socialcalc format
 *
 * @param  {String}     content     The content to check
 * @return {Boolean}                Whether or not the content is valid socialcalc
 * @api private
 */
const _isSCDocument = function(content) {
    if (!content) {
        return false;
    }
    content = content.trim();

    // FIXME This isn't ideal, consider replacing with regexp which is also not ideal
    return content.startsWith(SOCIAL_CALC_FORMAT_BEGIN_LINE) && content.endsWith(SOCIAL_CALC_FORMAT_END_LINE);
};

module.exports = {
    refreshConfiguration,
    getConfig,
    createRoom,
    deleteRoom,
    getHTML,
    getRoom,
    setSheetContents,
    joinRoom,
    getRoomUrl,
    isContentEmpty,
    isContentEqual,
    setEditedBy
};
