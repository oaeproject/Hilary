/*!
 * Copyright 2017 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var ShortId = require('shortid');
var Validator = require('oae-util/lib/validator').Validator;

var EmailAPI = require('oae-email/lib/api');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var TenantsUtil = require('oae-tenants/lib/util');

var TransferDAO = require('./internal/dao');

/**
 * PUBLIC FUNCTIONS
 */

/**
 * Create a new transfer.
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     originalEmail     Email origin
 * @param  {String}     targetEmail     Email target
 * @param  {String}     originalUserId    The id of the user who create the transfer         
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred
 * @api private
 */
var createTransfer = module.exports.createTransfer = function (ctx, originalUserId, originalEmail, targetEmail, callback) {
    callback = callback || function() {};

    // Verify basic properties
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Anonymous users cannot create a transfer'}).isLoggedInUser(ctx);
    validator.check(targetEmail, {'code': 400, 'msg': 'targetEmail cannot be empty'}).notEmpty();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    TransferDAO.createTransfer(ctx, originalUserId, originalEmail, targetEmail, function(err, transfer) {
        if (err) {
            return callback(err);
        }
        return callback(null, transfer);
    });
};

/**
 * Get a transfer by id.
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {string}     originalUserId    The id of the user who created the transfer               
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred
 * @api private
 */
var getTransferById = module.exports.getTransferById = function (ctx, originalUserId, callback) {
    callback = callback || function() {};

    // Verify basic properties
    var validator = new Validator();
    validator.check(originalUserId, {'code': 400, 'msg': 'Id cannot be empty'}).notEmpty();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    TransferDAO.getTransferById(originalUserId, function(err, transfer) {
        if (err) {
            return callback(err);
        }
        return callback(null, transfer);
    });
};

/**
 * Start the transfer.
 *
 * @param  {Context}    ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}     originalEmail             Email origin
 * @param  {String}     code                    Transfer code
 * @param  {String}     targetEmail             Email target
 * @param  {String}     targetUserId            Id user target
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred
 * @param  {Object}     callback.parsedData     Return array of updated users
 * @api private
 */
var makeTransfer = module.exports.makeTransfer = function (ctx, originalEmail, code, targetEmail, targetUserId, callback) {

    callback = callback || function() {};

    // Verify basic properties
    var validator = new Validator();
    validator.check(originalEmail, {'code': 400, 'msg': 'Email cannot be empty'}).notEmpty();    
    validator.check(code, {'code': 400, 'msg': 'Code cannot be empty'}).notEmpty();
    validator.check(originalEmail, {'code': 400, 'msg': 'Invalid email'}).isEmail();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    
    TransferDAO.makeTransfer(ctx, originalEmail, code, targetEmail, targetUserId, function(err, members) {
        if (err) {
            return callback(err);
        }

        if (_.isEmpty(members)) {Â 
            return callback(null);
        } else {

            // If there is no error, send emails to manager to advice them
            _sendEmail(ctx, members, targetUserId, originalEmail, targetEmail, function(err, parsedData) {
                if (err) {
                    return callback(err);
                }
                return callback(null, parsedData);
            });
        }
    });
};

/**
 * Delete the transfer.
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     originalEmail     The email of the user who create the transfer          
 * @param  {String}     code            The transfer code
 * @param  {string}     originalUserId    The id of the user who created the transfer               
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred
 * @api private
 */
var deleteTransfer = module.exports.deleteTransfer = function (ctx, originalEmail, code, originalUserId, callback) {
    callback = callback || function() {};

    // Verify basic properties
    var validator = new Validator();

    validator.check(originalEmail, {'code': 400, 'msg': 'Email cannot be empty'}).notEmpty();
    validator.check(code, {'code': 400, 'msg': 'Code cannot be empty'}).notEmpty();
    validator.check(originalUserId, {'code': 400, 'msg': 'Id cannot be empty'}).notEmpty();
    validator.check(originalEmail, {'code': 400, 'msg': 'Invalid email'}).isEmail();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    TransferDAO.deleteTransfer(originalEmail, code, originalUserId, function(err) {
        if (err) {
            return callback(err);
        } 
        return callback(null);
    });
};


/**
 * Send an email token to a user that can be used to notify the user transfer
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {Manager}    members         The members
 * @param  {String}     oldUserMail     OldUser email
 * @param  {String}     newUserMail     NewUser email
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred
 * @api private
 */
var _sendEmail = function(ctx, members, targetUserId, oldUserMail, newUserMail, callback) {

    // ParseData from variable informations to make an union on user. Start with members
    _parseData(members, function(err, parsedData) {
        if (err) {
            return callback(err);
        }

        // TODO(claire) make test
        _.each(parsedData, function(hash, i, arrI) {

            // Generate a token
            var token = ShortId.generate();

            // Store the token
            PrincipalsDAO.storeEmailToken(ctx.user().id, hash.profile.email, token, function(err) {
                if (err) {
                    return callback(err);
                }

                var userToEmail = _.extend({}, hash.profile, {'email': hash.profile.email, 'id': hash.profile.principalId,'tenant':{'alias': hash.profile.tenantAlias}});
                
                // Send an email to the specified e-mail address
                var data = {
                    'actor': ctx.user(),
                    'transferringAccount': ctx.user(),
                    'tenant': ctx.tenant().displayName,
                    'user': userToEmail,
                    'baseUrl': TenantsUtil.getBaseUrl(ctx.tenant()),
                    'skinVariables': require('oae-ui').getTenantSkinVariables(ctx.tenant().alias),
                    'token': token,
                    'oldUserMail': oldUserMail,
                    'newUserMail': newUserMail,
                    'resources': hash.resources,
                };

                EmailAPI.sendEmail('oae-transfer', 'notify', userToEmail, data, {'hash': Date.now()});
                
                // If last element, return
                if (i+1 === arrI.length) { 
                    return callback(null, parsedData);                
                }
            });
        });
        
    });
};

/**
 * Send an email token to a user that have a resource shared with the deleted user
 *
 * @param  {Object}     members                         List of the user to send the email token to with the resource concerned
 * @param  {Function}   callback                        Standard callback function
 * @param  {Object}     callback._listElementByMember   List of resources by members
 * @param  {Object}     callback.err                    An error that occurred, if any
 */
var _parseData = function(memberHashes, callback, _listElementByMember) {

    // Return when there are no more folder in the array
    if (!memberHashes || _.isEmpty(memberHashes)) {
        return callback(null, _listElementByMember);
    }
    
    var _listElementByMember = _listElementByMember || [];
    var member = memberHashes.shift();
    member = member[0];

    if (_.isEmpty(_listElementByMember)) {
        _listElementByMember.push({'profile': member.profile, 'resources': []});
    }

    var exist = false;

    // Create another list to sort by user the list of resource
    _.each(_listElementByMember, function(element, j, arrJ) {

        // Add resource to user 
        if ((element.profile.principalId === member.profile.principalId)) {
            exist = true;
            element.resources.push(member.resource);

            // If last element, return
            if (j+1 === arrJ.length) {
                return _parseData(memberHashes, callback, _listElementByMember);
            }
        }

        // If user do not exist in the list, create it
        if (j+1 === arrJ.length) {
            if (exist === false) {
                _listElementByMember.push({'profile': member.profile, 'resources': []});
                _listElementByMember[j+1].resources.push(member.resource);
                return _parseData(memberHashes, callback, _listElementByMember);
            } else {
                return _parseData(memberHashes, callback, _listElementByMember);
            }
        }
    });
};
