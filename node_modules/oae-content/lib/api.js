/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var events = require('events');
var fs = require('fs');
var Path = require('path');
var ShortId = require('shortid');
var util = require('util');

var AuthzAPI = require('oae-authz');
var AuthzUtil = require('oae-authz/lib/util');
var Config = require('oae-config').config('oae-content');
var Context = require('oae-context').Context;
var log = require('oae-logger').logger('oae-content');
var PrincipalsUtil = require('oae-principals/lib/util');
var Signature = require('oae-util/lib/signature');
var TenantsUtil = require('oae-tenants/lib/util');
var Validator = require('oae-util/lib/validator').Validator;

var Comment = require('./model').Comment;
var Content = require('./model').Content;
var ContentConstants = require('./constants').ContentConstants;
var ContentDAO = require('./internal/dao');
var ContentUtil = require('./internal/util');
var Revision = require('./model').Revision;

var _backends = {};

/**
 * ### Events
 *
 * The `ContentAPI`, as enumerated in `ContentConstants.events`, emits the following events:
 *
 * * `createdContent(ctx, content)`: A new content item was created. The `ctx` and the `content` object that was created are both provided.
 * * `updatedContent(ctx, newContentObj, oldContentObj)`: A content item was updated. The `ctx`, the updated content object and the content before was updated are provided.
 * * `updatedContentBody(ctx, content, fileInfo)`: A content item's file body was updated. The `ctx` of the request, the `content` object that was updated and the `fileInfo` of the new file location are all provided.
 * * `deletedContent(ctx, contentId)`: A content item was deleted. The `ctx` and the `contentId` of the deleted item are provided.
 * * `updatedContentMembers(ctx, content, memberUpdates)`: A content's members list was updated. The `ctx`, full `content` object of the updated content, and the hash of principalId -> role that outlines the changes that were made are provided.
 * * `createdComment(ctx, comment)`: A new (top-level) comment was posted for a content item. This does not get fired when a reply to a comment has happened
 */
var ContentAPI = module.exports = new events.EventEmitter();

///////////////////////////////////
// Retrieving a piece of content //
///////////////////////////////////

/**
 * Get a content's basic profile information based on a pooled content id
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the content object we want to retrieve
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Content}        callback.contentObj Retrieved content object
 */
var getContent = module.exports.getContent = function(ctx, contentId, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    ContentDAO.Content.getContent(contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        _hasAccess(ctx, contentObj, function(err, hasAccess) {
            if (err) {
                return callback(err);
            } else if (!hasAccess) {
                return callback({'code': 401, 'msg': 'You don\'t have access to this piece of content'});
            }

            _augmentContent(ctx, contentObj);
            callback(null, contentObj);
        });
    });
};

/**
 * Get a content item's full content profile. Next to the basic content profile, this will include the created date,
 * the profile of the user who originally created the content, and a isManager property specifying whether or not
 * the current user can manage the content.
 *
 * @param  {Context}        ctx                         Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId                   The id of the content profile we want to retrieve
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                Error object containing the error message
 * @param  {Content}        callback.contentProfile     Retrieved content profile
 */
var getFullContentProfile = module.exports.getFullContentProfile = function(ctx, contentId, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }
        
        // Get the user object for the createdBy property
        PrincipalsUtil.getPrincipal(ctx, contentObj.createdBy, function(err, createdBy) {
            if (err) {
                return callback(err);
            }
            contentObj.createdBy = createdBy;

            // If the current user is an anonymous user, we know he's not a viewer or manager
            if (!ctx.user()) {
                contentObj.isManager = false;
                callback(null, contentObj);
            } else {
                // Add the isManager properties
                _canManage(ctx, contentObj, function(err, isManager) {
                    if (err) {
                        return callback(err);
                    }
                    contentObj.isManager = isManager;
                    callback(null, contentObj);
                });
            }
        });
    });
};

/////////////////////////////////////
// Creating a new piece of content //
/////////////////////////////////////

/**
 * Create a link as a pooled content item
 * 
 * @param  {Context}        ctx                Standard context object containing the current user and the current tenant
 * @param  {String}         displayName        The display name for the link
 * @param  {String}         description        The description of the link [optional]
 * @param  {String}         visibility         The visibility setting for the piece of content. Possible values are "public", "loggedin" and "private" [optional]
 * @param  {String}         link               The URL for the link
 * @param  {Object}         additionalMembers  Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {Function}       callback           Standard callback function takes arguments `err` and `content`
 * @param  {Object}         callback.err       Error object containing the error message
 * @param  {Object}         callback.content   JSON object containing the pool id of the created content
 */
var createLink = module.exports.createLink = function(ctx, displayName, description, visibility, link, additionalMembers, callback) {
    callback = callback || function() {};

    // Setting content to default if no visibility setting is provided
    visibility = visibility || Config.getValue(ctx.tenant().alias, 'visibility', 'links');

    // Check if the link property is present. All other validation will be done in the _createContent function
    var validator = new Validator();
    validator.check(link, {'code': 400, 'msg': 'A valid link must be provided'}).isUrl();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to create a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _createContent(ctx, 'link', displayName, description, visibility, additionalMembers, {'link': link}, function(err, content) {
        if (!err) {
            ContentAPI.emit(ContentConstants.events.CREATED_CONTENT, ctx, content, additionalMembers);
        }
        callback(err, content);
    });
};

/**
 * Create a file as a pooled content item
 *
 * @param  {Context}   ctx                Standard context object containing the current user and the current tenant
 * @param  {String}    displayName        The display name for the file
 * @param  {String}    description        The description of the file [optional]
 * @param  {String}    visibility         The visibility setting for the piece of content. Possible values are "public", "loggedin" and "private" [optional]
 * @param  {Object}    additionalMembers  Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {Object}    file               A file object as returned by express.
 * @param  {Function}  callback           Standard callback function takes arguments `err` and `content`
 * @param  {Object}    callback.err       Error object containing the error message
 * @param  {Content}   callback.content   JSON object containing the pool id of the created content
 */
var createFile = module.exports.createFile = function(ctx, displayName, description, visibility, additionalMembers, file, callback) {
    // Wrap the callback function into a function that cleans up the file in case something went wrong.
    var cleanUpCallback = _getCleanUpCallback({'file': file}, callback);

    // Try to create the file.
    _createFile(ctx, displayName, description, visibility, additionalMembers, file, cleanUpCallback);
};

/**
 * Returns a function that will call the provided callback function.
 * In case the returned function gets called with an error object, the passed in file object will
 * be removed from the file system.
 *
 * @param  {Object}    files                The ExpressJS files object.
 * @param  {Function}  callback             Standard callback function takes arguments `err` and `content`
 * @param  {Object}    callback.err         Error object containing the error message
 * @param  {Content}   callback.content     JSON object containing the pool id of the created content
 * @return {Function}                       A function that removes the file on disk in case something went wrong.
 * @api private
 */
var _getCleanUpCallback = function(files, callback) {
    return function() {
        // Remember the arguments so we can pass them to the callback later.
        var callbackArguments = arguments;

        // The first argument is always the error object.
        var err = callbackArguments[0];

        if (err && files) {
            // Something went wrong with a request that has uploaded files associated to it.
            // In that case we try to remove the files.
            var fileObjects = _.values(files);
            _cleanupUploadedFiles(fileObjects, function() {
                 callback.apply(this, callbackArguments);
            });
        } else {
            // If we get here, the request might have failed, but it didn't contain an uploaded file.
            callback.apply(this, callbackArguments);
        }
    };
};

/**
 * Recursively iterates trough an array of uploaded files and removes them.
 *
 * @param  {Object[]}   files       An array of ExpressJS file objects.
 * @param  {Function}   callback    Standard callback method.
 * @api private
 */
var _cleanupUploadedFiles = function(files, callback) {
    if (files.length === 0) {
        return callback();
    }

    var file = files.pop();
    if (file && file.path) {
        fs.exists(file.path, function(exists) {
            if (exists) {
                fs.unlink(file.path, function(unlinkErr) {
                    if (unlinkErr) {
                        log().warn({'err': unlinkErr, 'file': file}, 'Could not remove the uploaded file.');
                    }
                    _cleanupUploadedFiles(files, callback);
                });
            } else {
                _cleanupUploadedFiles(files, callback);
            }
        });
    } else {
        _cleanupUploadedFiles(files, callback);
    }
};

/**
 * Create a file as a pooled content item
 *
 * @param  {Context}   ctx                Standard context object containing the current user and the current tenant
 * @param  {String}    displayName        The display name for the file
 * @param  {String}    description        The description of the file [optional]
 * @param  {String}    visibility         The visibility setting for the piece of content. Possible values are "public", "loggedin" and "private" [optional]
 * @param  {Object}    additionalMembers  Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {Object}    file               A file object as returned by express.
 * @param  {Function}  callback           Standard callback function takes arguments `err` and `content`
 * @param  {Object}    callback.err       Error object containing the error message
 * @param  {Content}   callback.content   JSON object containing the pool id of the created content
 * @api private
 */
var _createFile = function(ctx, displayName, description, visibility, additionalMembers, file, callback) {
    callback = callback || function() {};

    // Setting content to default if no visibility setting is provided
    visibility = visibility || Config.getValue(ctx.tenant().alias, 'visibility', 'files');

    var validator = new Validator();
    validator.check(file, {'code': 400, 'msg': 'Missing file parameter.'}).notNull();
    if (file) {
        validator.check(file.type, {'code': 400, 'msg': 'Missing mimetype on the file object.'}).notEmpty();
        validator.check(file.size, {'code': 400, 'msg': 'Missing size on the file object.'}).notEmpty();
        validator.check(file.size, {'code': 400, 'msg': 'Invalid size on the file object.'}).isInt();
        validator.check(file.size, {'code': 400, 'msg': 'Invalid size on the file object.'}).min(0);
        validator.check(file.name, {'code': 400, 'msg': 'Missing name on the file object.'}).notEmpty();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    // Create the content object.
    var otherValues = {
        'mime': file.type,
        'size': file.size,
        'filename': file.name
    };
    _createContent(ctx, 'file', displayName, description, visibility, additionalMembers, otherValues, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        // Store the actual file.
        contentObj.filename = file.name;
        contentObj.size = file.size;
        contentObj.mime = file.type;
        contentObj.downloadPath = '/api/content/' + contentObj.id + '/download';
        var options = { 'resourceId': contentObj.id };
        getStorageBackend(ctx).store(ctx, file, options, function(err, uri) {
            if (err) {
                return callback(err);
            }

            // Create the revision.
            ContentDAO.Revisions.createRevision(contentObj.id, ctx.tenant().alias, ctx.user().id, uri, otherValues, function(err) {
                if (err) {
                    return callback(err);
                }

                ContentAPI.emit(ContentConstants.events.CREATED_CONTENT, ctx, contentObj, additionalMembers);
                callback(null, contentObj);
            });
        });
    });
};

/**
 * Create a collaborative document as a pooled content item
 *
 * @param  {Context}   ctx                Standard context object containing the current user and the current tenant
 * @param  {String}    displayName        The display name for the collaborative document
 * @param  {String}    [description]      The description for the collaborative document
 * @param  {String}    visibility         The visibility setting for the piece of content. Possible values are "public", "loggedin" and "private" [optional]
 * @param  {Object}    additionalMembers  Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {Function}  callback           Standard callback function takes arguments `err` and `content`
 * @param  {Object}    callback.err       Error object containing the error message
 * @param  {Content}   callback.content   JSON object containing the pool id of the created content
 */
var createCollabDoc = module.exports.createCollabDoc = function(ctx, displayName, description, visibility, additionalMembers, callback) {
    callback = callback || function() {};

    // Setting content to default if no visibility setting is provided
    visibility = visibility || Config.getValue(ctx.tenant().alias, 'visibility', 'collabdocs');

    _createContent(ctx, 'collabdoc', displayName, description, visibility, additionalMembers, {}, function(err, content) {
        if (!err) {
            ContentAPI.emit(ContentConstants.events.CREATED_CONTENT, ctx, content, additionalMembers);
        }
        callback(err, content);
    });
};

/**
 * Create a new piece of pooled content
 *
 * @param  {Context}        ctx                Standard context object containing the current user and the current tenant
 * @param  {String}         resourceSubType    The content type. Possible values are "file", "collabdoc" and "link"
 * @param  {String}         displayName        The display name for the piece of content
 * @param  {String}         description        The description of the piece of content [optional]
 * @param  {String}         visibility         The visibility setting for the piece of content. Possible values are "public", "loggedin" and "private" [optional]
 * @param  {Object}         additionalMembers  Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {Object}         otherValues        JSON object where the keys represent other metadata values that need to be stored, and the values represent the metadata values
 * @param  {Function}       callback           Standard callback function takes arguments `err` and `content`
 * @param  {Object}         callback.err       Error object containing the error message
 * @param  {Content}        callback.content   JSON object containing the pool id of the created content
 * @api private
 */
var _createContent = function(ctx, resourceSubType, displayName, description, visibility, additionalMembers, otherValues, callback) {
    callback = callback || function() {};

    // Use an empty description if no description has been provided
    description = description || '';
    // Make sure the otherValues and additionalMembers are valid objects
    additionalMembers = additionalMembers || {};
    otherValues = otherValues || {};

    // Parameter validation
    var validator = new Validator();
    validator.check(displayName, {'code': 400, 'msg': 'A content displayName must be provided'}).notEmpty();
    validator.check(visibility, {'code': 400, 'msg': 'An invalid content visibility option has been provided. This can be "private", "loggedin" or "public"'}).isIn(_.values(ContentConstants.visibility));
    validator.check(resourceSubType, {'code': 400, 'msg': 'A valid resourceSubType must be provided. This can be "file", "collabdoc" or "link"'}).isIn(ContentConstants.resourceSubTypes);
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to create a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    ContentDAO.Content.createContent(ctx.tenant().alias, ctx.user().id, resourceSubType, displayName, description, visibility, additionalMembers, otherValues, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        // Now make the current user a manager of the content
        additionalMembers[ctx.user().id] = ContentConstants.roles.MANAGER;
        _setContentPermissions(ctx, contentObj, additionalMembers, callback);
    });
};

/////////////////////////////////
// Removing a piece of content //
/////////////////////////////////

/**
 * Delete a piece of content from the system
 *
 * @param  {Context}   ctx               Standard context object containing the current user and the current tenant
 * @param  {String}    contentId         The content id of the content that is being deleted
 * @param  {Function}  callback          Standard callback function takes argument `err`
 * @param  {Object}    callback.err      Error object containing the error message
 */
var deleteContent = module.exports.deleteContent = function(ctx, contentId, callback) {
    callback = callback || function() {};

    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to delete a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Fist check whether or not the current user is a manager of the piece of content
    canManage(ctx, contentId, function(err, canManage, contentObj) {
        if (err) {
            return callback(err);
        } else if (!canManage) {
            return callback({'code': 401, 'msg': 'You are not allowed to manage this piece of content'});
        }
        
        // Delete the content
        ContentDAO.Content.deleteContent(contentObj, function(err) {
            if (err) {
                return callback(err);
            }
            ContentAPI.emit(ContentConstants.events.DELETED_CONTENT, ctx, contentId);
            callback();
        });
    });
};

////////////////////////////
// Content access control //
////////////////////////////

/**
 * Share a piece of content with a set of principals. This only be possible when the current user is a manager of the content, or if the current
 * user is logged in and the content item is public or visible to logged in users only. In case that the content is shared with principals that
 * are already content members, no updates to the existing role of those principals will be made
 * 
 * @param  {Context}   ctx               Standard context object containing the current user and the current tenant
 * @param  {String}    contentId         The content id of the content that is being shared
 * @param  {String[]}  principalIds      Array of principal ids with whom the content will be shared. By default, they will all be made members.
 * @param  {Function}  callback          Standard callback function takes arguments `err` and `content`
 * @param  {Object}    callback.err      Error object containing the error message
 */
var shareContent = module.exports.shareContent = function(ctx, contentId, principalIds, callback) {
    callback = callback || function() {};
    
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(principalIds.length, {'code': 400, 'msg': 'The content must at least be shared with 1 user or group'}).min(1);
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to share content'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the user has access to the content
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        // Check if the content is visible to logged in users or public
        if (contentObj.visibility === ContentConstants.visibility.LOGGEDIN || contentObj.visibility === ContentConstants.visibility.PUBLIC) {
            _shareContent(ctx, contentObj, principalIds, callback);
        // Check if the user can manage the content
        } else {
            // It is possible that a content item that is owned by a tenant has been switched from public to private, but a user outside the
            // tenant that was previously manager can still share. However, restrictions inside _shareContent will stop them from sharing with
            // users outside the private tenant.
            _canManage(ctx, contentObj, function(err, canManage) {
                if (err) {
                    return callback(err);
                } else if (!canManage) {
                    return callback({'code': 401, 'msg': 'You are not allowed to share this content'});
                }
                _shareContent(ctx, contentObj, principalIds, callback);
            });
        }
    });
};

/**
 * Internal function used to share a piece of content with a set of principals. This function assume that the current user is allowed
 * to see and share the content. If some of the principals passed into this function are already content members, no updates to the
 * existing role of those principals will be made.
 *
 * @param  {Context}   ctx               The current execution context.
 * @param  {Content}   contentObj        Content object representing the content that is being shared
 * @param  {String[]}  principalIds      Array of principal ids with whom the content will be shared. By default, they will all be made members.
 * @param  {Function}  callback          Standard callback function takes arguments `err` and `content`
 * @param  {Object}    callback.err      Error object containing the error message
 * @api private
 */
var _shareContent = function(ctx, contentObj, principalIds, callback) {
    // Check if any of the passed in principal ids already have a direct role on the piece of content. We
    // filter those out to avoid turning an existing manager into a viewer
    AuthzAPI.getDirectRoles(principalIds, contentObj.id, function(err, roles) {
        if (err) {
            return callback(err);
        }

        var shareObject = {};
        for (var p = 0; p < principalIds.length; p++) {
            // Check if the principal already has a role on the content
            if (!roles[principalIds[p]]) {
                shareObject[principalIds[p]] = ContentConstants.roles.VIEWER;
            }
        }

        if (_.keys(shareObject).length === 0) {
            return callback(null);
        } else {
            _setContentPermissions(ctx, contentObj, shareObject, function(err) {
                if (err) {
                    return callback(err);
                }

                ContentAPI.emit(ContentConstants.events.UPDATED_CONTENT_MEMBERS, ctx, contentObj, shareObject);
                return callback();
            });
        }
    });
};

/**
 * Check whether or not the current user can manage a piece of content
 * 
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the content object we want to check
 * @param  {Function}       callback            Standard callback function takes arguments `err`, `canManage`, and `content`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Boolean}        callback.canManage  Whether or not the user can manage the content
 * @param  {Content}        callback.content    The retrieved content object containing its basic profile
 */
var canManage = module.exports.canManage = function(ctx, contentId, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to manage content'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            if (err.code === 401) {
                return callback(null, false);
            } else {
                return callback(err);
            }
        }
        _canManage(ctx, contentObj, function(err, canManage) {
            if (err) {
                return callback(err);
            }
            return callback(null, canManage, contentObj);
        });
    });
};

/**
 * Internal function that checks whether or not the current user can manage a piece of content. This function assumes that
 * the piece of content passed in actually exists
 * 
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {Content}        contentObj          The content object we want to check
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `canManage`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Boolean}        callback.canManage  Whether or not the user can manage the content
 * @api private
 */
var _canManage = function(ctx, contentObj, callback) {
    if (!ctx.user()) {
        return callback(null, false);
    } else if (ctx.user().isAdmin(contentObj.tenant)) {
        return callback(null, true);
    }
    
    return AuthzAPI.hasRole(ctx.user().id, contentObj.id, ContentConstants.roles.MANAGER, callback);
};

/**
 * Check whether or not the current user has access to a piece of content
 * 
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the content object we want to check
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `hasAccess`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Boolean}        callback.hasAccess  Whether or not the user has access to the content
 */
var hasAccess = module.exports.hasAccess = function(ctx, contentId, callback) {
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            // If the user doesn't have access to the content
            if (err.code ===  401) {
                return callback(null, false);
            } else {
                return callback(err);
            }
        }

        return callback(null, true);
    });
};

/**
 * Internal function that checks whether or not the current user has access to a piece of content. This function assumes that
 * the piece of content passed in actually exists
 * 
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {Content}        contentObj          The content object representing the content item we're checking access for
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `canManage`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Boolean}        callback.canManage  Whether or not the user has access to the content
 * @api private
 */
var _hasAccess = function(ctx, contentObj, callback) {
    if (contentObj.visibility === ContentConstants.visibility.PUBLIC) {
        return callback(null, contentObj);
    // If the content is visible to logged in users, I get access if I'm logged in
    } else if (contentObj.visibility === ContentConstants.visibility.LOGGEDIN && TenantsUtil.isLoggedIn(ctx, contentObj.tenant)) {
        return callback(null, contentObj);
    // If the user is admin of the content's tenant, they have access
    } else if (ctx.user() && ctx.user().isAdmin(contentObj.tenant)) {
        return callback(null, contentObj);
    // If the content is private
    } else if (ctx.user()) {
        return AuthzAPI.hasAnyRole(ctx.user().id, contentObj.id, callback);
    }

    return callback({'code': 401, 'msg': "You don't have access to this piece of content."});
};

/**
 * Update, add or remove the role of a set of principals on a piece of content
 * 
 * @param  {Context}         ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}          contentId           The id of the content object we want to set permissions on
 * @param  {Object}          newPermissions      Object where the keys represent the principal ids for which the content permissions should be updated/added/removed. The value is a string representing the new role. If false is passed in, the permissions for that principal will be removed e.g. {'user1': 'manager', 'user2': 'viewer', 'user3': false}
 * @param  {Function}        callback            Standard callback function takes argument `err`
 * @param  {Object}          callback.err        Error object containing the error message
 */
var setContentPermissions = module.exports.setContentPermissions = function(ctx, contentId, newPermissions, callback) {
    callback = callback || {};
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(_.keys(newPermissions).length, {'code': 400, 'msg': 'You should specify at least 1 user/group to set content permissions on'}).min(1);
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to create a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the content exists
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        // Check if the current user can manage the content
        _canManage(ctx, contentObj, function(err, canManage) {
            if (err) {
                return callback(err);
            } else if (!canManage) {
                return callback({'code': 401, 'msg': 'You are not allowed to manage this piece of content'});
            }

            // Check that these new content permissions don't result in an entity without managers.
            _checkNewContentPermissions(ctx, contentObj, newPermissions, function(err) {
                if (err) {
                    return callback(err);
                }

                // Add the new permissions to the content. This will then update the libraries as well
                _setContentPermissions(ctx, contentObj, newPermissions, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    ContentAPI.emit(ContentConstants.events.UPDATED_CONTENT_MEMBERS, ctx, contentObj, newPermissions);
                    return callback();
                });
            });
        });
    });
};

/**
 * Internal method that checks if the new permission set for a piece of content doesn't leave the content item without any managers.
 *
 * @param  {Context}    ctx                     The current execution context
 * @param  {Content}    contentObj              The content object we want to set permissions on
 * @param  {Object}     newPermissions          Object where the keys represent the principal ids for which the content permissions should be updated/added/removed. The value is a string representing the new role. If false is passed in, the permissions for that principal will be removed e.g. {'user1': 'manager', 'user2': 'viewer', 'user3': false}
 * @param  {Function}   callback                Standard callback function takes argument `err`
 * @param  {Object}     callback.err            Error object containing the error message
 * @api private
 */
var _checkNewContentPermissions = function(ctx, contentObj, newPermissions, callback) {
    // Check that we don't remove all members.
    AuthzAPI.getAuthzMembers(contentObj.id, null, 10000, function(err, members) {
        if (err) {
            return callback(err);
        }

        // Get the managers that aren't removed by this update.
        var remainingManagers = _.filter(members, function(member) {
            var isManager = member.role === ContentConstants.roles.MANAGER;
            var isRemoved = newPermissions[member.id] === false;
            var hasRoleChange = (newPermissions[member.id] && newPermissions[member.id] !== ContentConstants.roles.MANAGER);

            return (isManager && !isRemoved && !hasRoleChange);
        });

        // Get the extra set of managers.
        var newManagers = _.filter(newPermissions, function(role, id) { return role === ContentConstants.roles.MANAGER; });

        // Combine them and count them. If the total is 0 that means an attempt has been made to remove all direct managers.
        var managers = remainingManagers.concat(newManagers);
        if (managers.length === 0) {
            return callback({'code': 400, 'msg': 'At least one principal should be a manager.'});
        } else {
            callback();
        }
    });
};

/**
 * Internal function used to update, add or remove the role of a set of principals on a piece of content. This function will assume that
 * the content object exists and that the current user is a manager of the content. It will update the lastModified date of the content
 * item as well since the content item should appear newly updated in user libraries. It's assumed that the new content permissions
 * don't cause any inconsistencies such as no managers or members left on the piece of content.
 *
 * @param  {Context}         ctx                    The current execution context
 * @param  {Content}         contentObj             The content object we want to set permissions on
 * @param  {Object}          newPermissions         Object where the keys represent the principal ids for which the content permissions should be updated/added/removed. The value is a string representing the new role. If false is passed in, the permissions for that principal will be removed e.g. {'user1': 'manager', 'user2': 'viewer', 'user3': false}
 * @param  {Function}        callback               Standard callback function takes argument `err`
 * @param  {Object}          callback.err           Error object containing the error message
 * @param  {Content}         callback.newContentObj The content object with the updated `lastModified` timestamp
 * @api private
 */
var _setContentPermissions = function(ctx, contentObj, newPermissions, callback) {
    // Check if all of the provided principals exist
    var principalIds = _.keys(newPermissions);
    PrincipalsUtil.getPrincipals(ctx, principalIds, function(err, principals) {
        if (err) {
            return callback(err);
        }

        // Extract all of the users that are removed from the content, so the content can be removed from their library
        var removedMembers = [];
        for (var i = 0; i < principalIds.length; i++) {
            var principalId = principalIds[i];
            if (newPermissions[principalId] === false) {
                removedMembers.push(principalId);
            } else if (!TenantsUtil.canInteract(contentObj.tenant, principals[principalId].tenant)) {
                // We shouldn't be sharing this with someone outside of this tenant
                return callback({'code': 401, 'msg': 'This content item cannot be shared with external user "' + principals[principalId].id + '".'});
            }
        }

        // Update the roles CF
        AuthzAPI.updateRoles(contentObj.id, newPermissions, function(err) {
            if (err) {
                return callback(err);
            }

            // Now update all of the libraries this affects
            ContentDAO.Content.updateLibraries(contentObj, removedMembers, function(err, newContentObj) {
                if (err) {
                    // If there was an error updating libraries here, the permissions were still changed, so we should not return an error. Just log it.
                    log().warn({
                        'err': err,
                        'contentObj': contentObj,
                        'removedMembers': removedMembers
                    }, 'Failed to update user libraries after updating content permissions.');

                    if (newContentObj) {
                        // We successfully updated the timestamp of the content object, so we return that one
                        return callback(null, newContentObj);
                    } else {
                        // We did not successfully update the timestamp, return the old content object
                        return callback(null, contentObj);
                    }
                }

                return callback(null, newContentObj);
            });
        });
    });
};

/**
 * Get all of the principals that are directly associated to a piece of content.
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the content object for which we want to get the members
 * @param  {String}         start               Determines the point at which content members are returned for paging purposes.  If not provided, the first x elements will be returned
 * @param  {Integer}        limit               Number of items to return. Will default to 10 if not provided
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `members`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Object[]}       callback.members    Array that contains an object for each member. Each object has a role property that contains the role of the member and a profile property that contains the principal profile of the member
 */
var getContentMembers = module.exports.getContentMembers = function(ctx, contentId, start, limit, callback) {
    limit = limit || 10;

    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        // Get the content members
        AuthzAPI.getAuthzMembers(contentObj.id, start, limit, function(err, members) {
            if (err) {
                return callback(err);
            }

            // Get the basic profiles for all of these principals
            var memberIds = _.map(members, function(member){ return member.id; });
            PrincipalsUtil.getPrincipals(ctx, memberIds, function(err, memberProfiles) {
                if (err) {
                    return callback(err);
                }

                // Merge the member profiles and roles into a single object
                var memberList = [];
                for (var m = 0; m < members.length; m++) {
                    if (memberProfiles[members[m].id]) {
                        memberList.push({
                            'profile': memberProfiles[members[m].id],
                            'role': members[m].role
                        });
                    }
                }

                return callback(null, memberList);
            });
        });
    });
};

/////////////////////////////
// Update content metadata //
/////////////////////////////

/**
 * Update the file body that is associated with a file content item.
 *
 * @param  {Context}    ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}     contentId           The ID of the content object that should be updated.
 * @param  {File}       file                An expressjs File object that holds the data for the file that needs updating.
 * @param  {Function}   [callback]          Standard callback function takes arguments `err` and `revision`
 * @param  {Object}     [callback.err]      Error object containing the error message
 */
var updateFileBody = module.exports.updateFileBody = function(ctx, contentId, file, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Error updating the filebody for %s', contentId);
        }
    };

    // Wrap the callback function into a function that cleans up the file in case something went wrong.
    var cleanUpCallback = _getCleanUpCallback({'file': file}, callback);

    // Perform the update.
    _updateFileBody(ctx, contentId, file, cleanUpCallback);
};

/**
 * Update the file body that is associated with an uploaded file.
 *
 * @param  {Context}    ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}     contentId           The ID of the content object that should be updated.
 * @param  {File}       file                An expressjs File object that holds the data for the file that needs updating.
 * @param  {Function}   [callback]          Standard callback function takes arguments `err` and `revision`
 * @param  {Object}     [callback.err]      Error object containing the error message
 * @api private
 */
var _updateFileBody = function(ctx, contentId, file, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a content item'}).isLoggedInUser(ctx);
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(file, {'code': 400, 'msg': 'Missing file parameter.'}).notNull();
    if (file) {
        validator.check(file.type, {'code': 400, 'msg': 'Missing mimetype on the file object.'}).notEmpty();
        validator.check(file.size, {'code': 400, 'msg': 'Missing size on the file object.'}).notEmpty();
        validator.check(file.size, {'code': 400, 'msg': 'Invalid size on the file object.'}).isInt();
        validator.check(file.size, {'code': 400, 'msg': 'Invalid size on the file object.'}).min(0);
        validator.check(file.name, {'code': 400, 'msg': 'Missing name on the file object.'}).notEmpty();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    canManage(ctx, contentId, function(err, isManager, contentObj) {
        if (err) {
            return callback(err);
        } else if (!isManager) {
            return callback({'code': 401, 'msg': 'You are not allowed to manage this piece of content'});
        } else if (contentObj.resourceSubType !== 'file') {
            return callback({'code': 400, 'msg': 'This content object is not a file.'});
        }

        // Store the file
        // Use the current time as the "folder name".
        var options = {
            'resourceId': contentObj.id,
            'prefix': Date.now()
        };
        getStorageBackend(ctx).store(ctx, file, options, function(err, uri) {
            if (err) {
                return callback(err);
            }

            // Create the revision.
            var opts = {
                'mime': file.type,
                'size': file.size,
                'filename': file.name
            };
            ContentDAO.Revisions.createRevision(contentObj.id, ctx.tenant().alias, ctx.user().id, uri, opts, function(err, revision) {
                if (err) {
                    return callback(err);
                }

                // Set the new filesize, filename and mimetype on the Content object so the UI
                // can retrieve all the relevant metadata in 1 Cassandra query.
                ContentDAO.Content.updateContent(contentObj, opts, true, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    ContentAPI.emit(ContentConstants.events.UPDATED_CONTENT_BODY, ctx, contentObj, opts);
                    callback();
                });
            });
        });
    });
};

/**
 * Attaches preview items to, or set the status of, a piece of content.
 * This can only be used by a global admin and should technically only be executed by the preview processor.
 *
 * @param {Context}     ctx             Current execution context.
 * @param {String}      contentId       The ID of the content item.
 * @param {String}      status          The result of the preview processing operation. It should be one of the values of ContentConstants.previews.
 * @param {Object}      [files]         An expressjs files object. The keys are the POST parameter under which the file is submitted, the value is an expressjs File object.
 * @param {Object}      [sizes]         Each key maps a filename to a preview size.
 * @param {Object}      [metadata]      An object that holds optional metadata, data like pageCount for example can be passed in here.
 * @param {Function}    callback        Standard callback method
 * @param {Object}      callback.err    Standard error object (if any.)
 */
var setPreviewItems = module.exports.setPreviewItems = function(ctx, contentId, status, files, sizes, metadata, callback) {
    files = files || {};
    sizes = sizes || {};
    metadata = metadata || {};

    // Wrap the callback method, which takes care of cleaning up the files if something goes wrong.
    var cleanUpCallback = _getCleanUpCallback(files, callback);

    // Check for authentication before we do any expensive checks.
    if (!ctx.user() || !ctx.user().isGlobalAdmin()) {
        return cleanUpCallback({'code': 401, 'msg': 'Only administrators can attach preview items to a content item.'});
    }

    var validStatuses = _.values(ContentConstants.previews);
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'Missing or invalid contentId'}).isResourceId();
    validator.check(status, {'code': 400, 'msg': 'The status parameter must be one of: ' + validStatuses.join(', ')}).isIn(validStatuses);
    if (validator.hasErrors()) {
        return cleanUpCallback(validator.getFirstError());
    }

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return cleanUpCallback(err);
        }

        var fileData = {};
        var thumbnailUri = null;
        var fileKeys = Object.keys(files);
        var todo = fileKeys.length;
        // Preview generation failed or no files were uploaded, store that information in the database.
        if (status === ContentConstants.previews.ERROR || todo === 0) {
            return ContentDAO.Previews.storeMetadata(contentObj, status, thumbnailUri, metadata, fileData, callback);
        }

        // Preview generation was successful, store the files.
        var called = false;
        var storePrefix = 'previews/' + Date.now();
        fileKeys.forEach(function(key) {
            var size = sizes[key];
            if (!size) {
                todo--;
                log().warn("Ignoring file %s as it has no size associated to it", key);
                return;
            }

            // Store the file with a regular storage backend.
            var options = {
                'resourceId': contentObj.id,
                'prefix': storePrefix
            };
            getStorageBackend(ctx).store(ctx, files[key], options, function(err, uri) {
                todo--;
                if (err && !called) {
                    called = true;
                    return cleanUpCallback(err);
                }

                // We use the filename as the column name as there is a requirement that the UI can have
                // sequential URLs. It's up to the preview processor to provide these sequential URLs.
                // ie: ../download/page1.png, ../download/page2.png, ...
                // Rather than having an extra columnfamily to store a single piece of metadata (the size),
                // we store it next to the URI.
                fileData[files[key].name] = size + '#' + uri;

                // Remember the thumbnail uri separately so we can stick it on the main content object.
                if (size === 'thumbnail') {
                    thumbnailUri = uri;
                }

                if (todo === 0 && !called) {
                    // All files have been stored.
                    called = true;
                    log().trace({'data': fileData}, 'Storing %d content preview files.', fileKeys.length);
                    ContentDAO.Previews.storeMetadata(contentObj, status, thumbnailUri, metadata, fileData, function(err) {
                        if (err) {
                            return callback(err);
                        }

                        // Fire an event so we can update the search index.
                        ContentAPI.emit(ContentConstants.events.UPDATED_CONTENT_PREVIEW, ctx, contentObj.id, contentObj);

                        callback();
                    });
                }
            });
        });
    });
};

/**
 * Verifies the signature for a preview item that is associated to a piece of content.
 * If the signature is valid, an object will be returned that the REST handlers can use
 * to redirect the user to the actual file.
 *
 * @param  {Context}    ctx                     The current context.
 * @param  {String}     contentId               The content ID that the preview item is associated with.
 * @param  {String}     previewItem             The preview item that needs to be retrieved.
 * @param  {Object}     signature               A signature that validates this call.
 * @param  {String}     signature.signature     A signature that validates this call.
 * @param  {Number}     signature.expires       When the signature expires (in millis since epoch.)
 * @param  {Number}     signature.lastModified  When the signature expires (in millis since epoch.)
 * @param  {Function}   callback                Standard callback method.
 * @param  {Object}     callback.err            Standard error object (if any)
 * @param  {Object}     callback.link           Object that holds a `code` and `link`.
 */
var verifySignedPreviewItem = module.exports.verifySignedPreviewItem = function(ctx, contentId, previewItem, signature, callback) {
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'Missing content ID'}).notEmpty();
    validator.check(previewItem, {'code': 400, 'msg': 'Missing preview item'}).notEmpty();
    validator.check(null, {'code': 400, 'msg': 'Missing signature object'}).isObject(signature);
    if (_.isObject(signature)) {
        validator.check(signature.signature, {'code': 400, 'msg': 'Missing signature'}).notEmpty();
        validator.check(signature.expires, {'code': 400, 'msg': 'Missing expires'}).notEmpty();
        validator.check(signature.expires, {'code': 400, 'msg': 'Invalid expires parameter'}).isInt();
        validator.check(signature.lastModified, {'code': 400, 'msg': 'Missing lastModified parameter'}).notEmpty();
        validator.check(signature.lastModified, {'code': 400, 'msg': 'Invalid lastModified parameter'}).isInt();
        var tenantAlias = (contentId) ? AuthzUtil.getResourceFromId(contentId).tenantAlias : '';
        var principalId = (ctx.user()) ? ctx.user().id : '';
        var expires = (signature.expires) ? signature.expires : 0;
        var lastModified = (signature.lastModified) ? signature.lastModified : 0;
        var body = principalId + ':' + contentId + ':' + lastModified;
        validator.check(signature.signature, {'code': 401, 'msg': 'Invalid signature.'}).verifyExpiringSignature(tenantAlias, expires, body);
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    ContentDAO.Previews.getContentPreview(contentId, previewItem, function(err, preview) {
        if (err) {
            return callback(err);
        }

        var link = getStorageBackend(ctx, preview.uri).getDownloadLink(ctx, preview.uri);
        var result = {
            'opts': {
                'filename': previewItem
            },
            'link': link
        };
        callback(null, result);
    });
};

/**
 * Get the entire list of preview items that are associated to a content item.
 *
 * @param {Context}     ctx                 The current context.
 * @param {String}      contentId           The ID of the content you wish to retrieve the preview items for
 * @param {Function}    callback            Standard callback method.
 * @param {Object}      callback.err        Standard error object.
 * @param {Object}      callback.results    Object with a key `files` that holds an array of strings that are the filenames for previews and a key `signature` which holds the signature and expires parameters that should be sent when retrieving the preview bodies.
 */
var getPreviewItems = module.exports.getPreviewItems = function(ctx, contentId, callback) {
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        ContentDAO.Previews.getContentPreviews(contentId, function(err, previews) {
            if (err) {
                return callback(err);
            }

            // Generate an expiring signature.
            var signature = ContentUtil.signContent(ctx, contentId, contentObj.lastModified);
            var result = {
                'files': previews,
                'signature': signature
            };

            callback(null, result);
        });
    });
};

/**
 * Update a content item's displayName, description or visibility. This can only be done by the manager of that piece of content.
 *
 * @param  {Context}         ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}          contentId           The id of the content object for which we want to update the content profile
 * @param  {Object}          profileFields       Object where the keys represent the profile fields that need to be updated and the values represent the new values for those profile fields e.g. {'displayName': 'New content name', 'description': 'New content description', 'visibility': 'private'}
 * @param  {Function}        callback            Standard callback function takes argument `err`
 * @param  {Object}          callback.err        Error object containing the error message
 */
var updateContentMetadata = module.exports.updateContentMetadata = function(ctx, contentId, profileFields, callback) {
    callback = callback || function() {};
    
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    // Check that at a minimum name or description have been provided
    var fieldNames = profileFields ? _.keys(profileFields) : [];
    validator.check(fieldNames.length, {'code': 400, 'msg': 'You should at least specify a new displayName, description, visibility or link'}).min(1);
    for (var i = 0; i < fieldNames.length; i++) {
        var fieldName = fieldNames[i];
        validator.check(fieldName, {'code': 400, 'msg': fieldName + ' is not a recognized content profile field'}).isIn(['displayName', 'description', 'visibility', 'link']);
    }
    if (profileFields.hasOwnProperty('visibility')) {
        validator.check(profileFields['visibility'], {'code': 400, 'msg': 'An invalid content visibility option has been provided. This can be "private", "loggedin" or "public"'}).isIn(_.values(ContentConstants.visibility));
    }
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // First check whether or not the current user is a manager of the piece of content
    canManage(ctx, contentId, function(err, canManage, oldContentObj) {
        if (err) {
            return callback(err);
        } else if (!canManage) {
            return callback({'code': 401, 'msg': 'You are not allowed to manage this piece of content'});
        }

        ContentDAO.Content.updateContent(oldContentObj, profileFields, true, function(err, newContentObj) {
            if (err) {
                return callback(err);
            }

            ContentAPI.emit(ContentConstants.events.UPDATED_CONTENT, ctx, newContentObj, oldContentObj);
            callback(null, newContentObj);
        });
    });
};


// TODO: Split this out once we reorganize the content API
///////////////////////////
// Comment functionality //
///////////////////////////

/**
 * Creates a comment on the specified content item. Returns an error if saving the comment goes wrong or the user doesn't have access.
 * Only logged in users who can see the content are able to post comments.
 *
 * @param  {Context}    ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}     contentId           The ID of the content to place the comment on
 * @param  {String}     body                The comment to place on the content item
 * @param  {String}     [replyTo]           The ID of the comment to reply to, optional
 * @param  {Function}   [callback]          Standard callback function takes argument `err`
 * @param  {Object}     [callback.err]      Error object containing the error message
 * @param  {Comment}    [callback.comment]  The created comment
 */
var createComment = module.exports.createComment = function(ctx, contentId, body, replyTo, callback) {
    callback = callback || function() {};

    // Parameter validation
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authorized users can post comments'}).isLoggedInUser(ctx);
    validator.check(contentId, {'code': 400, 'msg': 'Invalid content resource id provided.'}).isResourceId();
    validator.check(body, {'code': 400, 'msg': 'A comment must be provided'}).notEmpty();
    if (replyTo) {
        validator.check(replyTo, {'code': 400, 'msg': 'Invalid replyTo id provided.'}).isResourceId();
    }

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    hasAccess(ctx, contentId, function(err, hasAccess) {
        if (err) {
            return callback(err);
        }

        if (!hasAccess) {
            return callback({'code': 401, 'msg': 'Only authorized users can post comments'});
        }

        if (replyTo) {
            ContentDAO.Comments.getComment(replyTo, function(err, commentReplyingTo) {
                if (err) {
                    return callback(err);
                }

                if (commentReplyingTo.contentId !== contentId) {
                    return callback({'code': 400, 'msg': 'The specified comment id is not associated to the specified content id'});
                }

                ContentDAO.Comments.createReply(contentId, ctx.tenant().alias, commentReplyingTo, ctx.user().id, body, function(err, comment) {
                    if (err) {
                        return callback(err);
                    }

                    comment.createdBy = ctx.user();
                    ContentAPI.emit(ContentConstants.events.CREATED_COMMENT, ctx, comment);
                    return callback(null, comment);
                });
            });
        } else {
            ContentDAO.Comments.createComment(contentId, ctx.tenant().alias, ctx.user().id, body, function(err, comment) {
                if (err) {
                    return callback(err);
                }

                comment.createdBy = ctx.user();
                ContentAPI.emit(ContentConstants.events.CREATED_COMMENT, ctx, comment);
                return callback(null, comment);
            });
        }
    });
};

/**
 * Retrieves the comments for a specified content item. Everyone who has access to the content item will be able to retrieve the list of comments.
 *
 * @param  {Context}    ctx                  Standard context object, representing the currently logged in user and its tenant
 * @param  {String}     contentId            The ID of the content to get comments for
 * @param  {String}     start                Determines the point at which content items are returned for paging purposed. If not provided, the first x elements will be returned
 * @param  {Integer}    limit                Number of items to return. Will default to 10 if not provided
 * @param  {Function}   callback             Standard callback function takes argument `err` and `comments`
 * @param  {Object}     callback.err         Error object containing the error message
 * @param  {Comment[]}  callback.comments    An array of Comment objects
 */
var getComments = module.exports.getComments = function(ctx, contentId, start, limit, callback) {
    limit = limit || 10;

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        ContentDAO.Comments.getComments(contentId, start, limit, function(err, comments) {
            if (err) {
                return callback(err);
            }

            // Get information on the commenters
            var userIds = {};
            for (var i = 0; i < comments.length; i++) {
                // Filter out duplicates
                if (comments[i].createdBy) {
                    userIds[comments[i].createdBy] = true;
                }
            }
            userIds = _.keys(userIds);

            // Get the basic principal profiles of the commenters to add to the comments as `createdBy`.
            PrincipalsUtil.getPrincipals(ctx, userIds, function(err, principals) {
                if (err) {
                    return callback(err);
                }

                for (var i = 0; i < comments.length; i++) {
                    comments[i].createdBy = principals[comments[i].createdBy];
                }

                return callback(err, comments);
            });
        });
    });
};

/**
 * Deletes a comment from a content item. Managers of the content can delete all comments whilst people that have access
 * to the content can only delete their own comments. Therefore, anonymous users will never be able to delete comments.
 *
 * @param  {Context}    ctx                     Standard context object, representing the currently logged in user and its tenant
 * @param  {String}     contentId               The ID of the content to delete the comment from
 * @param  {String}     commentId               The ID of the comment
 * @param  {Function}   callback                Standard callback function takes argument `err`
 * @param  {Object}     callback.err            Error object containing the error message
 * @param  {Comment}    [callback.softDeleted]  When the comment has been soft deleted (because it has replies), a stripped down comment object representing the deleted comment will be returned, with the `deleted` parameter set to `false`. If the comment has been deleted from Cassandra, no comment object will be returned.
 */
var deleteComment = module.exports.deleteComment = function(ctx, contentId, commentId, callback) {

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authorized users can delete comments'}).isLoggedInUser(ctx);
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(commentId, {'code': 400, 'msg': 'A comment id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        ContentDAO.Comments.getComment(commentId, function(err, comment) {
            if (err) {
                return callback(err);
            }

            if (comment.contentId !== contentId) {
                return callback({'code': 400, 'msg': 'The specified comment id is not associated to the specified content id'});
            }

            // Besides having access to the content the comment needs to be authored by the user
            // or the user needs to be a content manager.
            _canManage(ctx, contentObj, function(err, canManage) {
                if (err) {
                    return callback(err);
                }

                var canDelete = (canManage || ctx.user().id === comment.createdBy);
                if (!canDelete) {
                    return callback({'code': 401, 'msg': 'You don\t have the appropriate priviliges to delete this comment'});
                }

                ContentDAO.Comments.deleteComment(comment, callback);
            });
        });
    });
};


///////////////////////////
// Library functionality //
///////////////////////////

/**
 * Get the content items inside of an authorizable's library. If the user requests its own library or the library of a group he's a member of,
 * the full list will be returned. If the user is logged in, but not a manager of the library, the :loggedin stream will be returned, containing
 * only content that's visible to logged in people or the public. In case of an anonymous user, the :public stream will be returned, containing
 * only content that is public.
 * 
 * @param  {Context}        ctx               Standard context object containing the current user and the current tenant
 * @param  {String}         principalId       The principal id of the library we're requesting
 * @param  {String}         start             Determines the point at which content items are returned for paging purposed. If not provided, the first x elements will be returned
 * @param  {Integer}        limit             Number of items to return. Will default to 10 if not provided
 * @param  {Function}       callback          Standard callback function takes arguments `err` and `content`
 * @param  {Object}         callback.err      Error object containing the error message
 * @param  {Content[]}      callback.content  Array of basic content profiles representing the requested items in the library
 */
var getLibraryItems = module.exports.getLibraryItems = function(ctx, principalId, start, limit, callback) {
    limit = limit || 10;

    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'A user or group id must be provided'}).notEmpty();
    validator.check(limit, {'code': 400, 'msg': 'A valid limit should be passed in'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    /**
     * Augments passed in content object with a signature and thumbnail URL (if any.)
     *
     * @param  {Object}     err             Standard error object
     * @param  {Object[]}   contentObjects  An array of content objects.
     */
    var augment = function(err, contentObjects) {
        if (err) {
            return callback(err);
        }
        _.each(contentObjects, function(contentObj) {
            _augmentContent(ctx, contentObj);
        });
        callback(null, contentObjects);
    };

    var principal = AuthzUtil.getPrincipalFromId(principalId);
    var visibility = ContentConstants.visibility.PRIVATE;
    // Check if we are looking at a user library
    if (PrincipalsUtil.isUser(principalId)) {
        // We give the user the public content stream in case the user is not logged in to the user's tenant
        if (!TenantsUtil.isLoggedIn(ctx, principal.tenantAlias)) {
            visibility = ContentConstants.visibility.PUBLIC;
        // We give the user the logged in content stream in case the current user is not
        // the same as the library we're looking at
        } else if (ctx.user().id !== principalId) {
            visibility = ContentConstants.visibility.LOGGEDIN;
        }
        
        return ContentDAO.Content.getLibraryItems(principalId, visibility, start, limit, augment);
    // Check if we are looking at a group library
    } else if (PrincipalsUtil.isGroup(principalId)) {
        // We give the user the public content stream in case the user is not logged in
        if (!ctx.user()) {
            return ContentDAO.Content.getLibraryItems(principalId, ContentConstants.visibility.PUBLIC, start, limit, augment);
        } else {
            // Check if the current user is a member of the group
            AuthzAPI.hasAnyRole(ctx.user().id, principalId, function(err, hasAnyRole) {
                if (err) {
                    return callback(err);
                }

                // If the user is not a member, but is authenticated to the group's tenant, we give him the logged in content stream
                if (!hasAnyRole && TenantsUtil.isLoggedIn(ctx, principal.tenantAlias)) {
                    visibility = ContentConstants.visibility.LOGGEDIN;
                // Otherwise, we give them public library
                } else if (!hasAnyRole) {
                    visibility = ContentConstants.visibility.PUBLIC;
                }

                return ContentDAO.Content.getLibraryItems(principalId, visibility, start, limit, augment);
            });
        }
    // If the passed in principal id is neither a group or user, we return an error
    } else {
        return callback({'code': 400, 'msg': 'An unrecognized principal id (' + principalId + ') has been passed in'});
    }
};

/**
 * Get the storage backend for a uri, if the uri is unspecified it will return the default backend for a tenant.
 * If the backend could not be found, this will throw an error!
 * The uri will be checked before defaulting to the configured tenant backend. This allows for a tenant
 * to switch storage systems yet still serve the old files.
 *
 * @param  {Context}    ctx     The current execution context.
 * @param  {String}     [uri]   An optional URI.
 * @return {Backend}            The appropriate backend.
 */
var getStorageBackend = module.exports.getStorageBackend = function(ctx, uri) {
    var backendName = null;
    if (uri) {
        backendName = uri.split(':')[0];
    } else {
        // Use the tenant's default.
        backendName = Config.getValue(ctx.tenant().alias, 'storage', 'backend');
        if (backendName === null) {
            log().error('There was no storage backend configured, this should not happen.');
            throw new Error('There was no storage backend configured, this should not happen.');
        }
    }
    if (!_backends[backendName]) {
        try {
            _backends[backendName] = require('oae-content/lib/backends/' + backendName);
        } catch (err) {
            log().error({'err': err}, 'Couldn\'t load the backend %s', backendName);
            throw new Error('Could not find storage back-end ' + backendName);
        }
    }

    return _backends[backendName];
};

///////////////
// Revisions //
///////////////

/**
 * Get the revisions that are associated to a piece of content.
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the object for which we want to get the revisions
 * @param  {String}         start               Determines the point at which revisions are returned for paging purposes.  If not provided, the first x elements will be returned
 * @param  {Integer}        limit               Number of revisions to return. Will default to 10 if not provided
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `revisions`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Revision[]}     callback.revisions  Array that contains an object for each revision.
 */
var getRevisions = module.exports.getRevisions = function(ctx, contentId, start, limit, callback) {
    limit = limit || 10;

    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A contentId must be provided'}).isResourceId();
    validator.check(limit, {'code': 400, 'msg': 'A valid limit should be passed in'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the user has access on this contentId
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        _getRevisions(ctx, contentId, start, limit, callback);
    });
};

/**
 * Internal method that retrieves revisions and augments them with the principal profile who created it.
 * This method performs no access checks.
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the object for which we want to get the revisions
 * @param  {String}         start               Determines the point at which revisions are returned for paging purposes.  If not provided, the first x elements will be returned
 * @param  {Integer}        limit               Number of revisions to return. Will default to 10 if not provided
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `revisions`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Revision[]}     callback.revisions  Array that contains an object for each revision.
 * @api private
 */
var _getRevisions = function(ctx, contentId, start, limit, callback) {
    // Page the query.
    ContentDAO.Revisions.getRevisions(contentId, start, limit, function(err, revisions) {
        if (err) {
            return callback(err);
        }

        var userIds = _.map(revisions, function(revisions) { return revisions.createdBy; });
        PrincipalsUtil.getPrincipals(ctx, userIds, function(err, users) {
            if (err) {
                return callback(err);
            }

            // Add the user profiles to the revisions.
            _.each(revisions, function(revision) {
                if (users[revision.createdBy]) {
                    revision.createdBy = users[revision.createdBy];
                }
            });

            callback(null, revisions);
        });
    });
};

/**
 * Get a specific revision for a piece of content.
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         contentId           The id of the content for which we want to get the revision
 * @param  {String}         [revisionId]        The id of the revision that needs to be retrieved, if left null the latest will be retrieved.
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Revision}       callback.revision   The retrieved revision
 */
var getRevision = module.exports.getRevision = function(ctx, contentId, revisionId, callback) {
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A valid contentId must be provided'}).isResourceId();
    if (revisionId) {
        validator.check(revisionId, {'code': 400, 'msg': 'A valid revisionId must be provided'}).isResourceId();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    /**
     * Adds the download link on the revision.
     * @param {Object}      err      Error object containing the error message
     * @param {Revision}    revision The retrieved revision
     */
    var addDownloadLink = function(err, revision) {
        if (err) {
            return callback(err);
        }

        revision.link = getStorageBackend(ctx, revision.uri).getDownloadLink(ctx, revision.uri);
        callback(null, revision);
    };

    if (!revisionId || revisionId === '') {
        // Get the latest one.
        return getLatestRevision(ctx, contentId, addDownloadLink);
    }

    // Get a specific one.
    // Check if the user has access on this contentId
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }

        ContentDAO.Revisions.getRevision(revisionId, function(err, revisionObj) {
            // Double check that this revision is really attached to the specified contentId.
            // This is to counter that someone tries to get the revision of a piece of content he has no access to.
            // Ex: Alice has access to c:cam:aliceDoc but not to c:cam:bobDoc which has revision rev:cam:foo
            // doing getRevision(ctx, 'c:cam:aliceDoc', 'rev:cam:foo', ..) should return this error.
            if (revisionObj.contentId !== contentId) {
                return callback({'code': 401, 'msg': 'This revision ID is not associated with the specified piece of content.'});
            }

            addDownloadLink(null, revisionObj);
        });
    });
};

/**
 * Gets the most current revision
 *
 * @param  {Context}    ctx                 Current execution context.
 * @param  {String}     contentId           The id of the object for which we want to get the revisions
 * @param  {Function}   callback            Standard callback function takes arguments `err` and `revision`
 * @param  {Object}     callback.err        Error object containing the error message
 * @param  {Revision}   callback.revision   The latest revision
 */
var getLatestRevision = module.exports.getLatestRevision = function(ctx, contentId, callback) {
    getRevisions(ctx, contentId, null, 1, function(err, revisions) {
        if (err) {
            return callback(err);
        }

        if (revisions.length === 0) {
            return callback({'code': 404, 'msg': 'No revision found for ' + contentId});
        }

        callback(null, revisions[0]);
    });
};

/**
 * Verifies if a uri and signature match up and returns an object that the REST handlers can use to redirect users
 * to the actual download page.
 *
 * @param {Context}     ctx                             Current execution context.
 * @param {String}      uri                             The URI of a file.
 * @param {Number}      expires                         When the signature expires, in milliseconds since epoch.
 * @param {String}      signature                       The signature of the uri.
 * @param {Object}      callback.err                    Error object containing the error message
 * @param {Object}      callback.data                   The object that contains the data that the REST handler can use.
 * @param {Object}      callback.data.link              The link object with an http status code and a url
 * @param {Object}      callback.data.link.code         The HTTP status code (usually 204 or 301/302)
 * @param {Object}      callback.data.link.url          The url where the user should be redirected to.
 * @param {Object}      callback.data.opts.filename     The filename of the file that the user wishes to download.
 */
var verifySignedUri = module.exports.verifySignedUri = function(ctx, uri, expires, signature, callback) {
    var validator = new Validator();
    validator.check(uri, {'code': 400, 'msg': 'Missing uri'}).notNull();
    validator.check(expires, {'code': 400, 'msg': 'Missing expires'}).notNull();
    validator.check(expires, {'code': 400, 'msg': 'Invalid expires'}).isInt();
    validator.check(signature, {'code': 400, 'msg': 'Missing signature'}).notNull();
    expires = parseInt(expires, 10);
    var principalId = (ctx.user()) ? ctx.user().principalId : '';
    var body = principalId + ':' + uri;
    validator.check(signature, {'code': 401, 'msg': 'Invalid signature'}).verifyExpiringSignature(ctx.tenant().alias, expires, body);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    var link = getStorageBackend(ctx, uri).getDownloadLink(ctx, uri);
    var data = {
        'link': link,
        'opts': {
            'filename': Path.basename(uri)
        }
    };
    callback(null, data);
};

///////////////////////
// Utility functions //
///////////////////////

/**
 * Adds the signature and thumbnail url (if the piece of content has a thumbnail.)
 *
 * @param  {Context}    ctx         Standard context object, representing the currently logged in user and its tenant
 * @param  {Content}    contentObj  The content object that needs augmenting.
 */
var _augmentContent = function(ctx, contentObj) {
    // Generate a signature for this content item.
    // In combination with the previews object, the UI should be able to construct
    // download URLs for the preview items.
    contentObj.signature = ContentUtil.signContent(ctx, contentObj.id, contentObj.lastModified);
    if (contentObj.previews.thumbnailUri) {
        contentObj.previews.thumbnailUrl = ContentUtil.getThumbnailUrl(ctx, contentObj.id, contentObj.lastModified, contentObj.signature);
    }
};
