/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var log = require('oae-logger').logger('oae-search-util');
var OaeUtil = require('oae-util/lib/util');
var TenantsAPI = require('oae-tenants');
var TenantsUtil = require('oae-tenants/lib/util');
var Validator = require('oae-util/lib/validator').Validator;

var SearchConstants = require('oae-search/lib/constants').SearchConstants;
var SearchModel = require('oae-search/lib/model');

var SCOPES_ALL = [SearchConstants.general.SCOPE_ALL, SearchConstants.general.SCOPE_NETWORK, SearchConstants.general.SCOPE_INTERACT,
        SearchConstants.general.SCOPE_TENANT];

/**
 * Get the standard search parameters from the given request.
 *
 * @param  {Request}    req     The express Request object from which to extract the parameters.
 * @return {Object}             The parameters extracted from the request that are relevant for search.
 */
var getSearchParams = module.exports.getSearchParams = function(req) {
    if (!req || !req.query) {
        return {};
    }

    // Note that we do not impose an upper limit on the `limit` parameter. It's up to individual registered search types to do this.
    return {
        'q': req.query.q,
        'start': req.query.start,
        'limit': req.query.limit,
        'sort': req.query.sort
    };
};

/**
 * Determine if the given parameter is a valid query parameter. If so, simply return the `val`, otherwise, return `defaultVal`
 *
 * @param  {String}     val             The value to check
 * @param  {String}     [defaultVal]    The value to return if `val` is not valid. Defaults to `SearchConstants.query.ALL`
 * @return {String}                     `val` if it is valid. `defaultVal` otherwise
 */
var getQueryParam = module.exports.getQueryParam = function(val, defaultVal) {
    defaultVal = defaultVal || SearchConstants.query.ALL;
    return val || defaultVal;
};

/**
 * Determine if the given parameter is a valid scope parameter. If so, simply return the `val`, otherwise, return the
 * `defaultVal` parameter
 *
 * @param  {String}     val             The value to check
 * @param  {String}     [defaultVal]    The value to return if `val` is not a valid scope. If not a valid scope, defaults to `SearchConstants.general.SCOPE_TENANT`
 * @return {String}                     `val` if it is valid, `defaultVal` otherwise
 */
var getScopeParam = module.exports.getScopeParam = function(val, defaultVal) {
    defaultVal = (defaultVal) ? getScopeParam(defaultVal) : SearchConstants.general.SCOPE_TENANT;
    if (_.contains(SCOPES_ALL, val)) {
        // If it is a valid scope type, return the scope as-is
        return val;
    } else if (TenantsAPI.getTenant(val)) {
        // If it is a valid tenant alias, return the scope as-is
        return val;
    } else {
        // Otherwise, we default to limiting to the current tenant
        return defaultVal;
    }
};

/**
 * Determine if the given parameter is a valid sort parameter. If so, simply return the `val`, otherwise, return `defaultVal`
 *
 * @param  {String}     val             The value to check
 * @param  {String}     [defaultVal]    The value to return if `val` is not valid. Defaults to `SearchConstants.sort.ASC`
 * @return {String}                     `val` if it is valid. `defaultVal` otherwise.
 */
var getSortParam = module.exports.getSortParam = function(val, defaultVal) {
    defaultVal = (defaultVal) ? getSortParam(defaultVal) : SearchConstants.sort.ASC;
    return (_.contains(SearchConstants.sort.OPTIONS, val)) ? val : defaultVal;
};

/**
 * Transform the raw search `results` from ElasticSearch into a `SearchResult` that can be returned to the client.
 *
 * @param  {Context}        ctx                 The context of the current request
 * @param  {Object}         transformers        An object keyed by the resource type, and the value is the transformer object that can transform a set of search documents into client-viewable documents
 * @param  {Object}         results             The search results sent back from ElasticSearch
 * @param  {Function}       callback            Invoked when the process completes
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {SearchResult}   callback.results    The search results that can be sent to the client
 */
var transformSearchResults = module.exports.transformSearchResults = function(ctx, transformers, results, callback) {
    var hits = results.hits || {};
    var total = hits.total || 0;
    if (_.isEmpty(hits.hits)) {
        return callback(null, new SearchModel.SearchResult(total, []));
    }

    // Aggregate all the documents to be keyed by type
    var docsByType = {};
    var docIdOrdering = {};
    hits = hits.hits;
    for (var i = 0; i < hits.length; i++) {
        var doc = hits[i];
        var id = doc._id;
        var type = doc.fields.resourceType;

        // If transformer does not exist, pass it through the default "raw" transformer
        if (!transformers[type]) {
            type = '*';
        }

        if (!docsByType[type]) {
            docsByType[type] = {};
        }
        docsByType[type][id] = doc;
        docIdOrdering[id] = i;
    }

    // Run all the documents through the document transformers for their particular type
    var transformersToRun = _.keys(docsByType).length;
    var transformersComplete = 0;
    var transformErr = null;
    var transformedDocs = {};
    var _monitorTransformers = function(err, resourceType, docs) {
        if (transformErr) {
            // Nothing to do, we've already returned because of an error.
        } else if (err) {
            transformErr = err;
            return callback(transformErr);
        } else {

            // If we aren't using the default transformer, ensure the resourceType property by merging it over the doc, it should never change and don't necessarily need to be manually applied by an extension transformer
            if (resourceType !== '*') {
                var docIds = _.keys(docs);
                for (var i = 0; i < docIds.length; i++) {
                    var doc = docs[docIds[i]];
                    doc.resourceType = resourceType;
                }
            }

            // Merge the docs into the transformed docs
            _.extend(transformedDocs, docs);

            transformersComplete++;
            if (transformersComplete >= transformersToRun) {

                // We've done all transformations, reorder the docs into the original search ordering and send back the response
                var orderedDocs = _.values(transformedDocs);

                // Reorder the docs using the ordering hash that was recorded before transformation
                orderedDocs.sort(function(one, other) {
                    return docIdOrdering[one.id] - docIdOrdering[other.id];
                });


                return callback(null, new SearchModel.SearchResult(total, orderedDocs));
            }
        }
    };

    // Execute all transformers asynchronously from one another. _monitorTransformers will keep track fo their completion.
    _.keys(docsByType).forEach(function(type) {
        transformers[type](ctx, docsByType[type], (function(resourceType) {
            // We need to pass the resource type of this iteration on to the monitor
            return function(err, docs) {
                _monitorTransformers(err, resourceType, docs);
            };
        })(type));
    });
};

/**
 * Converts a query and (optionally) a filter into an appropriate ElasticSearch Query DSL object.
 *
 * @param  {Object}     query               The ElasticSearch query representation.
 * @param  {Object}     [filter]            The ElasticSearch filter to apply. If not specified, then the resulting object will be a simple query.
 * @param  {Object}     [opts]              A set of additional options for the query
 * @param  {Number}     [opts.start]        The starting index of the query for paging
 * @param  {Number}     [opts.limit]        The maximum number of documents to return
 * @param  {String}     [opts.sort]         The sort direction (asc or desc)
 * @param  {Number}     [opts.minScore]     The minimum score for a document to be included in the result set.
 * @return {Object}                         A valid ElasticSearch Query object that can be sent as a query.
 * @throws {Error}                          Thrown if the `query` parameter is not an object.
 */
var createQuery = module.exports.createQuery = function(query, filter, opts) {
    opts = opts || {};

    var validator = new Validator();
    validator.check(null, new Error('createQuery expects a query object.')).isObject(query);
    if (validator.hasErrors()) {
        log().error({'err': validator.getFirstError()}, 'Invalid input provided to SearchUtil.createQuery');
        throw validator.getFirstError();
    }

    var data = null;
    if (filter) {
        // If we have filters, we need to create a 'filtered' query
        data = {
            'query': {
                'filtered': {
                    'query': query,
                    'filter': filter
                }
            }
        };
    } else {
        // If it's just a query, we wrap it in a standard query.
        data = {
            'query': query
        };
    }

    // Strip the opts down to the relevant ElasticSearch parameters
    opts = {
        'from': OaeUtil.getNumberParam(opts.start),
        'size': OaeUtil.getNumberParam(opts.limit),
        'sort': [
            {'_score': {'order': 'desc'}},
            {'sort': getSortParam(opts.sort)}
        ],
        'min_score': (_.isNumber(opts.minScore)) ? opts.minScore : SearchConstants.query.MINIMUM_SCORE
    };

    return _.extend(data, opts);
};

/**
 * Create an ElasticSearch bulk index operation from the given array of documents. This splits up the documents automatically into the
 * meta / document sub-parts, and returns the array of documents that can be sent to the elasticsearchclient to be indexed. This does
 * not support bulk delete operations, as it is only for indexing operations.
 *
 * @param  {Object[]}   docs        An array of documents to be indexed
 * @return {Object[]}   operations  The array of index operations that can be sent to ElasticSearch to perform all the indexing
 */
var createBulkIndexOperations = module.exports.createBulkIndexOperations = function(docs) {
    var cmds = [];

    _.each(docs, function(doc) {
        var meta = {
            'index': {
                '_type': doc['_type'] || SearchConstants.search.MAPPING_RESOURCE,
                '_id': doc['id']
            }
        };

        if (doc['_parent']) {
            meta.index['_parent'] = doc['_parent'];
        }

        // These meta attributes have been promoted and shouldn't be on the core doc anymore
        delete doc.id;
        delete doc._type;
        delete doc._parent;

        cmds.push(meta);
        cmds.push(doc);
    });

    return cmds;
};

/**
 * Create an ElasticSearch "ids" filter, from an array of ids.
 *
 * @param  {String[]}   ids     An array of ids to filter on
 * @return {Object}             An ElasticSearch "ids" filter
 */
var filterIds = module.exports.filterIds = function(ids) {
    return {
        'ids': {
            'values': ids
        }
    };
};

/**
 * Create an ElasticSearch "exists" filter, which checks if the document has the specified field on it.
 *
 * @param  {String}     field   The field that should be present on the document
 * @return {Object}             An ElasticSearch "exists" filter
 */
var filterExists = module.exports.filterExists = function(field) {
    return {
        'exists': {
            'field': field
        }
    };
};

/**
 * Create an ElasticSearch 'OR' filter, wrapped around multiple other filters.
 *
 * @param  {Object}     args*   The filter objects to "OR" together
 * @return {Object}             An ElasticSearch "OR" filter.
 */
var filterOr = module.exports.filterOr = function(/* filter0, filter1, filter2, ... */) {
    var filters = _.compact(arguments);
    if (_.isEmpty(filters)) {
        return null;
    } else if (filters.length === 1) {
        // If there is only one filter, no need to wrap it in an `or`
        return filters[0];
    }

    return {'or': filters};
};

/**
 * Create an ElasticSearch 'AND' filter, wrapped around multiple other filters.
 *
 * @param  {Object}     args*   The filter objects to "AND" together
 * @return {Object}             An ElasticSearch "AND" filter.
 */
var filterAnd = module.exports.filterAnd = function(/* filter0, filter1, filter2, ... */) {
    var filters = _.compact(arguments);
    if (_.isEmpty(filters)) {
        return null;
    } else if (filters.length === 1) {
        // If there is only one filter, no need to wrap it in an `and`
        return filters[0];
    }

    return {'and': filters};
};

/**
 * Create an ElasticSearch 'NOT' filter, wrapped around one filter.
 *
 * @param  {Object}     filter  The filter object to negate
 * @return {Object}             An ElasticSearch "NOT" filter
 */
var filterNot = module.exports.filterNot = function(filter) {
    if (!filter) {
        return null;
    }
    return {'not': filter };
};

/**
 * Create an ElasticSearch 'terms' filter, wrapped around an array of values
 *
 * @param  {String}     field   The name of the field this term filters
 * @param  {String[]}   values  The values to filter on
 * @return {Object}             An ElasticSearch 'terms' filter.
 */
var filterTerms = module.exports.filterTerms = function(field, values) {
    var terms = _.compact(values);
    if (_.isEmpty(terms)) {
        return null;
    }

    var filter = {'terms': {}};
    filter.terms[field] = terms;
    return filter;
};

/**
 * Create an ElasticSearch 'term' filter, wrapped around a value
 *
 * @param  {String}     field   The name of the field this term filters
 * @param  {String}     value   The value to match
 * @return {Object}             An ElasticSearch 'term' filter.
 */
var filterTerm = module.exports.filterTerm = function(field, value) {
    if (!value) {
        return null;
    }

    var filter = {'term': {}};
    filter.term[field] = value;
    return filter;
};

/**
 * Create an ElasticSearch filter that will filter to OAE resources by type
 *
 * @param  {String[]}   [resourceTypes]     The types of resources to filter by. If unspecified or empty, no resources will be filtered
 * @return {Object}                         The filter that filters to OAE resources of the specified types
 */
var filterResources = module.exports.filterResources = function(resourceTypes) {
    return filterAnd(
        filterTerm('_type', SearchConstants.search.MAPPING_RESOURCE),
        (!_.isEmpty(resourceTypes)) ? filterTerms('resourceType', resourceTypes) : null
    );
};

/**
 * Create an ElasticSearch filter that will filter to resources of the provided scope to which the
 * current user has access.
 *
 * @param  {Context}    ctx                             The context of the request that needs to be scoped
 * @param  {String}     scope                           The specified scope of the request, as per `SearchConstants.general.SCOPE_*` or the alias of a tenant
 * @param  {Boolean}    needsFilterByExplicitAccess     Whether or not the access filter should take into consideration explicit access
 * @param  {String[]}   includeIndirect                 If including filters for explicit access, this determines if it should only take into consideration direct access or access VIA indirect group membership
 * @param  {Function}   callback                        Standard callback function
 * @param  {Object}     callback.err                    An error that occurred, if any
 * @param  {Object}     callback.filter                 The ElasticSearch filter that can be used in the search query
 */
var filterScopeAndAccess = module.exports.filterScopeAndAccess = function(ctx, scope, needsFilterByExplicitAccess, includeIndirect, callback) {
    scope = getScopeParam(scope);

    var tenant = ctx.tenant();
    var user = ctx.user();
    var interactingTenantAliases = TenantsUtil.getAllTenantsForInteraction(tenant.alias);
    var interactingTenantAliasesFilter = filterTerms('tenantAlias', _.union(tenant.alias, interactingTenantAliases));
    var implicitAccessFilter = filterImplicitAccess(ctx);

    OaeUtil.invokeIfNecessary(needsFilterByExplicitAccess, filterExplicitAccess, ctx, includeIndirect, function(err, explicitAccessFilter) {
        if (err) {
            return callback(err);
        }

        var filter = null;
        if (scope === SearchConstants.general.SCOPE_ALL) {
            // When searching all, we only care about the access
            filter = filterOr(implicitAccessFilter, explicitAccessFilter);
        } else if (scope === SearchConstants.general.SCOPE_NETWORK) {
            // When searching network, we care about access and the scope of the tenant network (i.e.,
            // scope public tenants away from private). All resources outside the network that the
            // user has explicit access to are included as well
            filter = filterOr(
                filterAnd(
                    implicitAccessFilter,
                    interactingTenantAliasesFilter
                ),
                explicitAccessFilter
            );
        } else if (scope === SearchConstants.general.SCOPE_INTERACT) {
            if (!user) {
                // Anonymous users cannot interact with anything, give an authorization error for this scenario
                return callback({'code': 401, 'msg': 'Anonymous users are not authorized to interact with any resources'});
            }

            // When scoping for interaction, we care about access and resources that the user can
            // interact with. This is basically the network scope, minus private joinable resources
            // from the user's own tenant
            filter = filterOr(
                filterAnd(
                    implicitAccessFilter,
                    interactingTenantAliasesFilter,

                    // We cannot implicitly interact with any private resource. So we exclude them
                    // from the implicit scope, but private resources that I have explicit access to
                    // will still be included by virtue of the wrapped `or` filter
                    (!user.isAdmin(user.tenant.alias)) ? filterNot(filterTerm('visibility', 'private')) : null
                ),
                explicitAccessFilter
            );
        } else if (scope === SearchConstants.general.SCOPE_TENANT) {
            // When scoping for the current tenant, we care about access and resources that belong to
            // the current tenant. All resources outside the current tenant that the user has explicit
            // access to are included as well
            filter = filterOr(
                filterAnd(
                    implicitAccessFilter,
                    filterTerm('tenantAlias', tenant.alias)
                ),
                explicitAccessFilter
            );
        } else {
            // Otherwise, a specific tenant has been specified. In this case we search only for
            // resources of that tenant, even if there is explicit access to resources of other
            // tenants
            filter = filterAnd(
                filterOr(
                    implicitAccessFilter,
                    explicitAccessFilter
                ),
                filterTerm('tenantAlias', scope)
            );
        }

        return callback(null, filter);
    });
};

/**
 * Create an ElasticSearch filter that will filter to all resources the provided user has access to
 * implicitly using visibility rules.
 *
 * @param  {Context}    ctx     The context of the request that needs to be filtered to implicit access
 * @return {Object}             The filter that filters the user's access by anything they implicitly have access to in the system. If unspecified, it indicates they have access to everything (i.e., global admin)
 */
var filterImplicitAccess = module.exports.filterImplicitAccess = function(ctx) {
    var user = ctx.user();
    if (user && user.isGlobalAdmin()) {
        // If the user is a global admin, they have implicit access to everything
        return null;
    }

    // Any user can implicitly see any public resource in the system
    var filterPublic = filterTerm('visibility', AuthzConstants.visibility.PUBLIC);

    // If the user is anonymous, short-circuit to only revealing the public content in the system
    if (!user) {
        return filterPublic;
    }

    // The user is authenticated, determine the implicit access for non-public items in the system
    var filterLoggedIn = null;
    if (user.isTenantAdmin(user.tenant.alias)) {
        // Tenant admin can implicitly access all resources in the tenant, but not outside of it
        filterLoggedIn = filterTerm('tenantAlias', user.tenant.alias);
    } else {
        // Regular users can implicitly access all resources in the system that have visibility
        // loggedin, and private groups that are joinable
        filterLoggedIn = filterAnd(
            filterTerm('tenantAlias', user.tenant.alias),
            filterOr(
                filterTerm('visibility', AuthzConstants.visibility.LOGGEDIN),
                filterAnd(
                    filterTerm('resourceType', 'group'),
                    filterTerms('joinable', [AuthzConstants.joinable.YES, AuthzConstants.joinable.REQUEST])
                )
            )
        );
    }

    return filterOr(filterPublic, filterLoggedIn);
};

/**
 * Create an ElasticSearch filter that will filter to just items that the user in context has explicit access
 * to. It is assumed that global administrators and anonymous users have explicit access to nothing. In the
 * case of a global administrator, they have implicit access to everything therefore this does not restrict
 * their access in any way.
 *
 * @param  {Context}    ctx                 The context of the search request for which to build the explicit access filter
 * @param  {Boolean}    includeIndirect     Whether or not to take into consideration group membership when filtering by explicit access. See method summary for more information
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Object}     callback.filter     The ElasticSearch filter that will filter by explicit access. If unspecified, it implies the user has explicit access to *nothing*
 */
var filterExplicitAccess = module.exports.filterExplicitAccess = function(ctx, includeIndirect, callback) {
    var user = ctx.user();
    if (!user) {
        // The anonymous users can't have explicit access
        return callback();
    } else if (user.isGlobalAdmin()) {
        // The global admin has implicit access to everything, so
        // explicit access is unnecessary
        return callback();
    } else if (!includeIndirect) {
        // If we aren't including indirect access, then only include
        // resources where the user is directly a member
        return callback(null, createHasChildQuery(AuthzConstants.search.MAPPING_RESOURCE_MEMBERS, filterTerms('direct_members', [ctx.user().id])));
    }

    // If we are including indirect access, include all resources where any of
    // the user's groups are directly a member
    AuthzAPI.getPrincipalMemberships(ctx.user().id, null, 10000, function(err, groups) {
        if (err) {
            return callback(err);
        }

        return callback(null, createHasChildQuery(AuthzConstants.search.MAPPING_RESOURCE_MEMBERS, filterTerms('direct_members', _.union(ctx.user().id, groups))));
    });
};

/**
 * Create a full-text query object (just the query portion, not filter) for ElasticSearch from the provided
 * user input. This ensures that the query will be a safe keyword search that supports both "everything" (e.g., *)
 * and user-input search terms.
 *
 * @param  {String}         q           The user-input query to search with
 * @param  {String[]}       [fields]    The fields of the documents that should be searched through. Defaults to ['q_high^2.0', 'q_low^0.75']
 * @param  {String|Number}  [boost]     An optional boost to apply to the query. If not specified, no boost will be applied
 * @return {Object}                     A Query object that can be used in the query portion of the ElasticSearch Query DSL
 */
var createQueryStringQuery = module.exports.createQueryStringQuery = function(q, fields, boost) {
    if (_.isEmpty(fields)) {
        fields = ['q_high^2.0', 'q_low^0.75'];
    }

    var query = null;
    q = getQueryParam(q);
    if (q === SearchConstants.query.ALL) {
        // We're searching everything, use query_string syntax
        query = {
            'query_string': {
                'fields': fields,
                'query': SearchConstants.query.ALL
            }
        };

        if (boost) {
            query.query_string.boost = boost;
        }
    } else {
        // Build a query that will do a full-text search on the "q" fields, giving favour to matches on the title
        query = {
            'multi_match': {
                'fields': fields,
                'query': q
            }
        };

        if (boost) {
            query.multi_match.boost = boost;
        }
    }

    return query;
};

/**
 * Creates a has_child query object that can be used to get those resources that have children of
 * type `type` that match the `query`.
 * @see http://www.elasticsearch.org/guide/reference/query-dsl/has-child-query/
 *
 * @param  {String}     type            The type of children.
 * @param  {Object}     childQuery      A Query object that will filter the children.
 * @param  {String}     [scoreType]     The supported score types are max, sum, avg or none. If not specified, the score_type parameter won't be set in the query, so the query can be used in filters. If the score type is set to another value than none, the scores of all the matching child documents are aggregated into the associated parent documents.
 * @return {Object}                     A Query object that can be used in the query portion of the ElasticSearch Query DSL
 */
var createHasChildQuery = module.exports.createHasChildQuery = function(type, childQuery, scoreType) {
    if (!childQuery) {
        return null;
    }

    var query = {
        'has_child': {
            'type': type,
            'query': childQuery
        }
    };

    // Because we can't use a has_child query with a scoreType in a filter,
    // we only add the scoreType when it's been defined, so callers can specify
    // when to add it
    if (scoreType) {
        query.has_child.score_type = scoreType;
    }

    return query;
};

/**
 * Create a more-like-this query object (just the query portion, not filter) for ElasticSearch from the provided
 * user input.
 * @see http://www.elasticsearch.org/guide/reference/query-dsl/mlt-query.html
 *
 * @param  {String}     like_val    The text that should be fuzzified and to match documents against.
 * @param  {String[]}   [fields]    An array of fields that should match the like_val text. If left blank, the "q_high" field will be used.
 * @return {Object}                 A Query object that can be used in the query portion of the ElasticSearch Query DSL
 */
var createMoreLikeThisQuery = module.exports.createMoreLikeThisQuery = function(val, fields) {
    fields = (_.isEmpty(fields)) ? ['q_high'] : fields;
    return {
        'more_like_this' : {
            'fields' : fields,
            'like_text' : val,
            'min_term_freq': 1,
            'min_doc_freq': 1

        }
    };
};

/**
 * Create a search document whose parent is the specified resource document from the given type and fields.
 *
 * @param  {String}     type            The type of the document
 * @param  {String}     resourceId      The id of the resource who is the parent of this document
 * @param  {Object}     fields          The fields to index
 * @param  {String}     [fields.id]     A custom id for the document. If this is not specified, then the empty string is used and it is assumed you probably only want one child of this type per resource. Specifying the id allows you to have many child documents per resource.
 */
var createChildSearchDocument = module.exports.createChildSearchDocument = function(type, resourceId, fields) {
    return _.extend({}, fields, {
        'id': getChildSearchDocumentId(type, resourceId, fields.id),
        '_type': type,
        '_parent': resourceId
    });
};

/**
 * Create the child search document id for the document described by the given information
 *
 * @param  {String}     type        The type of the search document (e.g., 'content_comment', 'resource_members', etc...)
 * @param  {String}     resourceId  The id of the resource that is a parent to this child document
 * @param  {String}     childId     The id of the child item that is unique within the scope of the provided parent resource id
 * @return {String}                 The globally unique id to use for the child document
 * @api private
 */
var getChildSearchDocumentId = module.exports.getChildSearchDocumentId = function(type, resourceId, childId) {
    return util.format('%s#%s#%s', resourceId, type, childId || '');
};

