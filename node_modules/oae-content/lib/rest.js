/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var log = require('oae-logger').logger('content-rest');
var OAE = require('oae-util/lib/oae');
var OaeUtil = require('oae-util/lib/util');
var Util = require('oae-util/lib/util');

var ContentAPI = require('./api');
var ContentConstants = require('./constants').ContentConstants;

/*!
 * Create a new piece of content
 */
OAE.tenantRouter.on('post', '/api/content/create', function(req, res) {

    // Pick the managers and viewers off the request
    var additionalMembers = {};
    if (req.body.managers) {
        if (!Array.isArray(req.body.managers)) {
            req.body.managers = [req.body.managers];
        }
        for (var i = 0; i < req.body.managers.length; i++) {
            additionalMembers[req.body.managers[i]] = 'manager';
        }
    }
    if (req.body.viewers) {
        if (!Array.isArray(req.body.viewers)) {
            req.body.viewers = [req.body.viewers];
        }
        for (var j = 0; j < req.body.viewers.length; j++) {
            additionalMembers[req.body.viewers[j]] = 'viewer';
        }
    }

    // Link creation
    if (req.body.resourceSubType === 'link') {
        ContentAPI.createLink(req.ctx, req.body.displayName, req.body.description, req.body.visibility, req.body.link, additionalMembers, function(err, contentObj) {
            if (err) {
                return res.send(err.code, err.msg);
            }
            res.send(201, contentObj);
        });
    // File creation
    } else if (req.body.resourceSubType === 'file') {
        var uploadedFile = null;
        if (req.files) {
            uploadedFile = req.files.file;
        }
        ContentAPI.createFile(req.ctx, req.body.displayName, req.body.description, req.body.visibility, additionalMembers, uploadedFile, function(err, contentObj) {
            if (err) {
                // At this point we can use regular responses again.
                return res.send(err.code, err.msg);
            }
            // Set the response type to text/plain, as the UI uses an iFrame upload mechanism to support IE9
            // file uploads. If the response type is not set to text/plain, IE9 will try to download the response.
            res.set('Content-Type', 'text/plain');
            res.send(201, contentObj);
        });
    // Collaborative document creation
    } else if (req.body.resourceSubType === 'collabdoc') {
        ContentAPI.createCollabDoc(req.ctx, req.body.displayName, req.body.description, req.body.visibility, additionalMembers, function(err, contentObj) {
            if (err) {
                return res.send(err.code, err.msg);
            }
            res.send(201, contentObj);
        });
    // Not a recognized file type
    } else {
        res.send(400, 'Unrecognized resourceSubType. Accepted values are "link", "file" and "collabdoc"');
    }
});

/*!
 * Delete a piece of content
 */
OAE.tenantRouter.on('del', '/api/content/:contentId', function(req, res) {
    ContentAPI.deleteContent(req.ctx, req.params.contentId, function(err) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200);
    });
});

/*!
 * Get a full content profile for a piece of content
 */
OAE.tenantRouter.on('get', '/api/content/:contentId', function(req, res) {
    ContentAPI.getFullContentProfile(req.ctx, req.params.contentId, function(err, contentProfile) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, contentProfile);
    });
});

/*!
 * Edit content metadata
 */
OAE.tenantRouter.on('post', '/api/content/:contentId', function(req, res) {
    ContentAPI.updateContentMetadata(req.ctx, req.params.contentId, req.body, function(err, newContentObj) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, newContentObj);
    });
});

/*!
 * Download the latest version of a piece of content
 */
OAE.tenantRouter.on('get', '/api/content/:contentId/download', function(req, res) {
    ContentAPI.getRevision(req.ctx, req.params.contentId, null, function(err, revision) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        handleDownload(res, revision);
    });
});

/*!
 * Download a specific version of a piece of content.
 */
OAE.tenantRouter.on('get', '/api/content/:contentId/download/:revisionId', function(req, res) {
    ContentAPI.getRevision(req.ctx, req.params.contentId, req.params.revisionId, function(err, revision) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        handleDownload(res, revision);
    });
});

/*!
 * Upload a new version of a file
 */
OAE.tenantRouter.on('post', '/api/content/:contentId/newversion', function(req, res) {
    if (!req.files || !req.files.file) {
        return res.send(400, 'Missing file parameter');
    }

    ContentAPI.updateFileBody(req.ctx, req.params.contentId, req.files.file, function(err, updatedContentObj) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        // Set the response type to text/plain, as the UI uses an iFrame upload mechanism to support IE9
        // file uploads. If the response type is not set to text/plain, IE9 will try to download the response.
        res.set('Content-Type', 'text/plain');
        res.send(200, updatedContentObj);
    });
});

/*!
 * Publish a collaborative document
 */
OAE.tenantRouter.on('post', '/api/content/:contentId/publish', function(req, res) {
    ContentAPI.publishCollabDoc(req.ctx, req.params.contentId, function(err, newContentObj) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, newContentObj);
    });
});

/*!
 * Join a collaborative document
 */
OAE.tenantRouter.on('post', '/api/content/:contentId/join', function(req, res) {
    ContentAPI.joinCollabDoc(req.ctx, req.params.contentId, function(err, data) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, data);
    });
});

/*!
 * Attach a preview item to a piece of content.
 */
OAE.tenantRouter.on('post', '/api/content/:contentId/revisions/:revisionId/previews', function(req, res) {
    var contentMetadata = null;
    var previewMetadata = null;
    var sizes = null;
    var files = null;
    try {
        contentMetadata = JSON.parse(req.body.contentMetadata);
        previewMetadata = JSON.parse(req.body.previewMetadata);
        sizes = JSON.parse(req.body.sizes);

        if (req.body.links) {
            files = JSON.parse(req.body.links);
        }
    } catch (err) {
        var invalidField = null;
        if (!contentMetadata) {
            invalidField = 'contentMetadata';
        } else if (!previewMetadata) {
            invalidField = 'previewMetadata';
        } else if (!sizes) {
            invalidField = 'sizes';
        } else if (!files) {
            invalidField = 'links';
        }

        return res.send(400, 'Malformed metadata object. Expected proper JSON for: ' + invalidField);
    }

    if (req.files) {
        files = files || {};
        _.extend(files, req.files);
    }

    ContentAPI.setPreviewItems(req.ctx, req.params.contentId, req.params.revisionId, req.body.status, files, sizes, contentMetadata, previewMetadata, function(err) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(201);
    });
});

/*!
 * Get a list of preview items for the latest revision
 */
OAE.tenantRouter.on('get', '/api/content/:contentId/revisions/:revisionId/previews', function(req, res) {
    ContentAPI.getPreviewItems(req.ctx, req.params.contentId, req.params.revisionId, function(err, previews) {
        if (err) {
            return res.send(err.code, err.msg);
        }

        res.send(200, previews);
    });
});

/*!
 * Download a preview item.
 */
OAE.tenantRouter.on('get', '/api/content/:contentId/revisions/:revisionId/previews/:item', function(req, res) {
    var signature = {
        'signature': req.query.signature,
        'expires': req.query.expires,
        'lastModified': req.query.lastmodified
    };
    ContentAPI.getSignedPreviewDownload(req.ctx, req.params.contentId, req.params.revisionId, req.params.item, signature, function(err, download) {
        if (err) {
            return res.send(err.code, err.msg);
        }

        handleDownload(res, download);
    });
});

/*!
 * Content revisions
 */
OAE.tenantRouter.on('get', '/api/content/:contentId/revisions', function(req, res) {
    var limit = OaeUtil.getNumberParam(req.query.limit, 10, 1, 25);
    ContentAPI.getRevisions(req.ctx, req.params.contentId, req.query.start, limit, function(err, revisions, nextToken) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, {'results': revisions, 'nextToken': nextToken});
    });
});

/*!
 * Get a specific content revision
 */
OAE.tenantRouter.on('get', '/api/content/:contentId/revisions/:revisionId', function(req, res) {
    ContentAPI.getRevision(req.ctx, req.params.contentId, req.params.revisionId, function(err, revision) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, revision);
    });
});

/*!
 * Restore a specific content revision
 */
OAE.tenantRouter.on('post', '/api/content/:contentId/revisions/:revisionId/restore', function(req, res) {
    ContentAPI.restoreRevision(req.ctx, req.params.contentId, req.params.revisionId, function(err, newRevision) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, newRevision);
    });
});

/*!
 * Content membership list
 */
OAE.tenantRouter.on('get', '/api/content/:contentId/members', function(req, res) {
    var limit = OaeUtil.getNumberParam(req.query.limit, 10, 1, 25);
    ContentAPI.getContentMembers(req.ctx, req.params.contentId, req.query.start, limit, function(err, members, nextToken) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, {'results': members, 'nextToken': nextToken});
    });
});

/*!
 * Set content permission
 */
OAE.tenantRouter.on('post', '/api/content/:contentId/members', function(req, res) {
    // Parse the incoming false values
    var requestKeys = _.keys(req.body);
    for (var r = 0; r < requestKeys.length; r++) {
        req.body[requestKeys[r]] = Util.castToBoolean(req.body[requestKeys[r]]);
    }
    ContentAPI.setContentPermissions(req.ctx, req.params.contentId, req.body, function(err) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200);
    });
});

/*!
 * Share content
 */
OAE.tenantRouter.on('post', '/api/content/:contentId/share', function(req, res) {
    // Make sure viewer is an array
    if (!Array.isArray(req.body.viewers)) {
        req.body.viewers = [req.body.viewers];
    }
    ContentAPI.shareContent(req.ctx, req.params.contentId, req.body.viewers, function(err) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200);
    });
});

/*!
 * Add a comment to a piece of content
 */
OAE.tenantRouter.on('post', '/api/content/:contentId/messages', function(req, res) {
    ContentAPI.createComment(req.ctx, req.params.contentId, req.body.body, req.body.replyTo, function(err, message) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(201, message);
    });
});

/*!
 * List the comments on a piece of content.
 */
OAE.tenantRouter.on('get', '/api/content/:contentId/messages', function(req, res) {
    var limit = OaeUtil.getNumberParam(req.query.limit, 10, 1, 25);
    ContentAPI.getComments(req.ctx, req.params.contentId, req.query.start, limit, function(err, messages, nextToken) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, {'results': messages, 'nextToken': nextToken});
    });
});

/*!
 * Delete a comment on a piece of content
 */
OAE.tenantRouter.on('del', '/api/content/:contentId/messages/:created', function(req, res) {
    ContentAPI.deleteComment(req.ctx, req.params.contentId, req.params.created, function(err, deleted) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, deleted);
    });
});

/*!
 * List a principal's library
 */
OAE.tenantRouter.on('get', '/api/content/library/:principalId', function(req, res) {
    var limit = OaeUtil.getNumberParam(req.query.limit, 12, 1, 25);
    ContentAPI.getLibraryItems(req.ctx, req.params.principalId, req.query.start, limit, function(err, items, nextToken) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, {'results': items, 'nextToken': nextToken});
    });
});

/*!
 * Delete a piece of content from a library.
 */
OAE.tenantRouter.on('del', '/api/content/library/:principalId/:contentId', function(req, res) {
    ContentAPI.removeContentFromLibrary(req.ctx, req.params.principalId, req.params.contentId, function(err) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200);
    });
});

/*!
 * Download a file, verification happens via a signature in the querystring.
 * By adding a signature an expensive access check is avoided.
 * This should only be used for items that do not have a high security risk attached to them.
 */
OAE.tenantRouter.on('get', '/api/download/signed', function(req, res) {
    ContentAPI.verifySignedUri(req.ctx, req.query.uri, req.query.expires, req.query.signature, function(err, data) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        handleDownload(res, data);
    });
});

/*!
 * Sends the correct HTTP response according to a download strategy. Note that the "direct" download strategy is not being handled here
 * as the direct strategy should not be requested to the application for action, instead its target is delivered to the user verbatim
 * with no signature.
 *
 * @param  {Response}           res                         The Express Response object
 * @param  {Object}             download                    An object that represents an item that can be downloaded from the application
 * @param  {String}             download.filename           The file name of the download
 * @param  {DownloadStrategy}   download.downloadStrategy   How the application should deliver the download
 */
var handleDownload = function(res, download) {
    var downloadStrategy = download.downloadStrategy;

    // A 204 suggest that the LB (nginx, apache, lighthttpd, ..) will be handling the download via the x-sendfile mechanisme.
    if (downloadStrategy.strategy === ContentConstants.backend.DOWNLOAD_STRATEGY_INTERNAL) {
        // Nginx internal download
        res.setHeader('X-Accel-Redirect', downloadStrategy.target);

        // Apache internal download
        res.setHeader('X-Sendfile', downloadStrategy.target);

        // Lighthttpd internal download
        res.setHeader('X-LIGHTTPD-send-file', downloadStrategy.target);

        res.setHeader('Content-Disposition', 'attachment; filename="' + download.filename + '"');
        res.send(204, downloadStrategy.target);

    // A redirect strategy will invoke a redirect to the target
    } else if (downloadStrategy.strategy === ContentConstants.backend.DOWNLOAD_STRATEGY_REDIRECT) {
        // We can't guarantee that the backend won't want to update some details about the target over time. e.g., update some tracking
        // variables over time for analytics or additional security. Therefore, we do a temporary redirect (302)
        res.setHeader('Location', downloadStrategy.target);
        res.send(302);

    // The app server will send the file to the client. This should *NOT* be used in production and is only really here for easier unit
    // testing purposes
    } else if (downloadStrategy.strategy === ContentConstants.backend.DOWNLOAD_STRATEGY_TEST) {
        return res.download(downloadStrategy.target);

    // In all other cases we respond with a 404
    } else {
        res.send(404);
    }
};
