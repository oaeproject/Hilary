/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var events = require('events');
var util = require('util');

var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzAPI = require('oae-authz');
var ContentAPI = require('oae-content');
var ContentConstants = require('oae-content/lib/constants').ContentConstants;
var ContentDAO = require('oae-content/lib/internal/dao');
var LibraryAPI = require('oae-library');
var log = require('oae-logger').logger('oae-collections-api');
var OaeUtil = require('oae-util/lib/util');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var PrincipalsUtil = require('oae-principals/lib/util');
var Validator = require('oae-util/lib/validator').Validator;

var CollectionsAuthz = require('./authz');
var CollectionsCollectionsLibrary = require('./internal/collectionsLibrary');
var CollectionsConfig = require('oae-config').config('oae-collections');
var CollectionsConstants = require('./constants').CollectionsConstants;
var CollectionsContentLibrary = require('./internal/contentLibrary');
var CollectionsDAO = require('./internal/dao');

// When updating collections in a principal collections library, update at most once every hour to
// avoid thrashing the libraries with updates and causing duplicates
var LIBRARY_UPDATE_THRESHOLD_SECONDS = 3600;


// TODO: Search
// TODO: Activity
// TODO: Remove collection from library
// TODO: Test rebuilding library of content item that has groups as members
// TODO: Test getting library of content item that contains groups to ensure nulls are ok
// TODO: Test getting user and collection library of content items who have group memberships to ensure nulls are ok

/*!
 * ### Events
 *
 * * `createdCollection(ctx, collection, members)`: A new collection was created
 * * `updatedCollection(ctx, oldCollection, newCollection)`: A collection was updated
 * * `updatedCollectionMembers(ctx, collection, memberUpdates, newMemberIds, updatedMemberIds, removedMemberIds)`: The members of a collection have been updated
 * * `addedContentItems(ctx, collection, contentItems)`: One or more content item was added to a collection
 */
var CollectionsAPI = module.exports = new events.EventEmitter();

/**
 * Create a collection
 *
 * @param  {Context}        ctx                     The context of the current request
 * @param  {String}         displayName             The display name of the collection
 * @param  {String}         [description]           The description of the collection. By default, a collection will have no description
 * @param  {String}         [visibility]            The visibility of the collection. One of `AuthzConstants.visibility`. This will default to a value configured for the tenant
 * @param  {Object}         [members]               An object whose keys are principal ids and values are the role they should have on the collection. By default only the creator of the collection will be a manager
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Collection}     callback.collection     The collection that was created
 */
var createCollection = module.exports.createCollection = function(ctx, displayName, description, visibility, members, callback) {
    // TODO: test default visibility
    visibility = visibility || CollectionsConfig.getValue(ctx.tenant().alias, 'visibility', 'collection');
    members = members || {};

    var allVisibilities = _.values(AuthzConstants.visibility);

    // Verify basic properties
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Anonymous users cannot create a collection'}).isLoggedInUser(ctx);
    validator.check(displayName, {'code': 400, 'msg': 'Must provide a display name for the collection'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'A display name can be at most 1000 characters long'}).isShortString();
    if (description) {
        validator.check(description, {'code': 400, 'msg': 'A description can be at most 10000 characters long'}).isMediumString();
    }
    validator.check(visibility, {'code': 400, 'msg': 'An invalid collection visibility option has been provided. Must be one of: ' + allVisibilities.join(', ')}).isIn(allVisibilities);

    // Verify each memberId and role is valid
    _.each(members, function(role, memberId) {
        validator.check(memberId, {'code': 400, 'msg': util.format('The memberId "%s" is not a valid member id', memberId)}).isPrincipalId();
        validator.check(role, {'code': 400, 'msg': util.format('The role "%s" is not a valid member role for a collection', role)}).isIn(CollectionsConstants.roles.ALL_PRIORITY);
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Reject the operation if it will violate tenant privacy boundaries
    PrincipalsDAO.getPrincipals(_.keys(members), null, function(err, principals) {
        if (err) {
            return callback(err);
        }

        principals = _.values(principals);
        AuthzAPI.canInteract(ctx, ctx.tenant().alias, principals, function(err, canInteract, illegalPrincipalIds) {
            if (err) {
                return callback(err);
            } else if (!_.isEmpty(illegalPrincipalIds)) {
                return callback({'code': 400, 'msg': 'One or more target members being granted access are not authorized to become members on this collection'});
            }

            // Persist the collection
            CollectionsDAO.createCollection(ctx.user().id, displayName, description, visibility, function(err, collection) {
                if (err) {
                    return callback(err);
                }

                // Set the current user as a manager and apply the collection roles
                members[ctx.user().id] = CollectionsConstants.roles.MANAGER;
                AuthzAPI.updateRoles(collection.groupId, members, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Insert the collection into the collections library of all the members
                    var principalIds = _.keys(members);
                    CollectionsCollectionsLibrary.insert(principalIds, collection, function(err) {
                        if (err) {
                            log(ctx).warn({
                                'err': err,
                                'principalIds': principalIds,
                                'collection': collection
                            }, 'An error occurred while inserting a created collection into member libraries');
                        }

                        CollectionsAPI.emit(CollectionsConstants.events.CREATED_COLLECTION, ctx, collection, members);
                        return callback(null, collection);
                    });
                });
            });
        });
    });
};

/**
 * Get a collection by its id
 *
 * @param  {Context}        ctx                     The context of the current request
 * @param  {String}         collectionId            The id of the collection to get
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Collection}     callback.collection     The collection identified by the given id
 */
var getCollection = module.exports.getCollection = function(ctx, collectionId, callback) {
    var validator = new Validator();
    validator.check(collectionId, {'code': 400, 'msg': util.format('The collection id "%s" is not a valid resource id', collectionId)}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the collection from storage to use for permission checks
    _getCollection(collectionId, function(err, collection) {
        if (err) {
            return callback(err);
        }

        // Ensure the current user can view the collection
        CollectionsAuthz.canViewCollectionProfile(ctx, collection, function(err, canView) {
            if (err) {
                return callback(err);
            } else if (!canView) {
                return callback({'code': 401, 'msg': 'You are not authorized to view this collection'});
            }

            // Return the collection to the user
            return callback(null, collection);
        });
    });
};

/**
 * Get the full collection profile, which includes additional information about the relation of the
 * current user to the collection
 *
 * @param  {Context}        ctx                             The context of the current request
 * @param  {String}         collectionId                    The id of the collection whose full profile to get
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Collection}     callback.collection             The basic profile of the collection, with some additional information provided
 * @param  {Boolean}        callback.collection.canManage   Whether or not the current user can manage the collection
 * @param  {Boolean}        callback.collection.canShare    Whether or not the current user can share the collection
 * @param  {Boolean}        callback.collection.canAddItem  Whether or not the current user can add a content item to the collection
 * @param  {User}           callback.collection.createdBy   The basic profile of the user who created the collection
 */
var getFullCollectionProfile = module.exports.getFullCollectionProfile = function(ctx, collectionId, callback) {
    var validator = new Validator();
    validator.check(collectionId, {'code': 400, 'msg': util.format('The collection id "%s" is not a valid resource id', collectionId)}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the collection from storage to use for permissions checks
    _getCollection(collectionId, function(err, collection) {
        if (err) {
            return callback(err);
        }

        CollectionsAuthz.resolveEffectiveCollectionAccess(ctx, collection, function(err, canView, canManage, canShare, canAddItem) {
            if (err) {
                return callback(err);
            } else if (!canView) {
                return callback({'code': 401, 'msg': 'You are not authorized to view this collection'});
            }

            collection.canManage = canManage;
            collection.canShare = canShare;
            collection.canAddItem = canAddItem;

            // Populate the creator of the collection
            PrincipalsUtil.getPrincipal(ctx, collection.createdBy, function(err, creator) {
                if (err) {
                    log(ctx).warn({
                        'err': err,
                        'userId': collection.createdBy,
                        'collectionId': collection.id
                    }, 'An error occurred getting the creator of a collection. Proceeding with empty user for full profile');
                }

                if (creator) {
                    collection.createdBy = creator;
                }

                return callback(null, collection);
            });
        });
    });
};

/**
 * List the members of a collection
 *
 * @param  {Context}        ctx                             The context of the current request
 * @param  {String}         collectionId                    The id of the collection whose members to get
 * @param  {String}         [start]                         A token that indicates where in the list to start returning members. Use the `nextToken` result from this method to determine where to start the next page of members
 * @param  {Number}         [limit]                         The maximum number of members to return
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Object[]}       callback.results                An array of objects indicating the members of the collection and their roles
 * @param  {User|Group}     callback.results[i].profile     The basic profile of the user or group who is a member of the collection
 * @param  {String}         callback.results[i].role        The role of the user or group on the collection
 * @param  {String}         callback.nextToken              The token to use for the next `start` value in order to get the next page of members. If this value is `null`, it indicates that there are no more members to page
 */
var getCollectionMembers = module.exports.getCollectionMembers = function(ctx, collectionId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(collectionId, {'code': 400, 'msg': 'A collection id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getCollection(ctx, collectionId, function(err, collection) {
        if (err) {
            return callback(err);
        }

        // Get the discussion members
        AuthzAPI.getAuthzMembers(collection.groupId, start, limit, function(err, memberRoles, nextToken) {
            if (err) {
                return callback(err);
            }

            // Get the basic profiles for all of these principals
            PrincipalsUtil.getPrincipals(ctx, _.pluck(memberRoles, 'id'), function(err, memberProfiles) {
                if (err) {
                    return callback(err);
                }

                // Merge the member profiles and roles into a single object
                var memberList = _.map(memberRoles, function(memberRole) {
                    return {
                        'profile': memberProfiles[memberRole.id],
                        'role': memberRole.role
                    };
                });

                return callback(null, memberList, nextToken);
            });
        });
    });
};

/**
 * Share a collection with a set of users and groups. All users and groups who are shared the
 * collection will be given the `member` role. However, if they already have a different role, the
 * existing role will not be changed
 *
 * @param  {Context}    ctx             The context of the current request
 * @param  {String}     collectionId    The id of the collection to share
 * @param  {String[]}   principalIds    The ids of the users and groups with whom to share the collection
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var shareCollection = module.exports.shareCollection = function(ctx, collectionId, principalIds, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to share a collection'}).isLoggedInUser(ctx);
    validator.check(collectionId, {'code': 400, 'msg': 'A valid collection id must be provided'}).isResourceId();
    validator.check(principalIds.length, {'code': 400, 'msg': 'The collection must at least be shared with 1 user or group'}).min(1);
    _.each(principalIds, function(principalId) {
        validator.check(principalId, {'code': 400, 'msg': 'The member id: ' + principalId + ' is not a valid member id'}).isPrincipalId();
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getCollection(collectionId, function(err, collection) {
        if (err) {
            return callback(err);
        }

        AuthzAPI.getDirectRoles(principalIds, collection.groupId, function(err, roles) {
            if (err) {
                return callback(err);
            }

            // Take out the principals who already have a role on this collection and short-circuit
            // if there are no new ones
            principalIds = _.difference(principalIds, _.keys(roles));
            if (_.isEmpty(principalIds)) {
                return callback();
            }

            // Validate role and tenant boundary permissions for the current user to share the collection with the target users
            CollectionsAuthz.canShareCollection(ctx, collection, principalIds, function(err, canShare, illegalPrincipalIds) {
                if (err && err.code === 404) {
                    return callback({'code': 400, 'msg': 'One or more target members do not exist'});
                } else if (err) {
                    return callback(err);
                } else if (illegalPrincipalIds) {
                    return callback({'code': 400, 'msg': 'One or more target members are not authorized to become members on this collection'});
                } else if (!canShare) {
                    return callback({'code': 401, 'msg': 'You are not authorized to share this collection'});
                }

                // Apply the membership updates
                var roleChanges = {};
                _.each(principalIds, function(principalId) {
                    roleChanges[principalId] = CollectionsConstants.roles.VIEWER;
                });

                // Apply the permissions update
                AuthzAPI.updateRoles(collection.groupId, roleChanges, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // TODO: Test timestamp doesn't update with subsequent shares
                    // Update the libraries that contain this collection, but only if we have not already updated it within the threshold
                    OaeUtil.invokeIfNecessary(_testLibraryUpdateThreshold(collection), CollectionsCollectionsLibrary.update, principalIds, collection, null, function(err) {
                        if (err) {
                            log(ctx).warn({
                                'err': err,
                                'collectionId': collection.id,
                                'principalIds': principalIds
                            }, 'An error occurred while updating collection in member libraries after being shared');
                        }

                        CollectionsAPI.emit(CollectionsConstants.events.UPDATED_COLLECTION_MEMBERS, ctx, collection, roleChanges, principalIds);
                        return callback();
                    });
                });
            });
        });
    });
};

/**
 * Set permissions to the collection. This is similar to sharing a collection, however rather than
 * only giving users and groups the `member` role, other roles can be applied and also users and
 * groups can be removed from the collection membership
 *
 * @param  {Context}    ctx                 The context of the current request
 * @param  {String}     collectionId        The id of the collection whose permissions to set
 * @param  {Object}     permissionChanges   An object whose key is the user or group id to set on the collection, and the value is the role you wish them to have. If the role of a user is set to `false`, then it indicates to remove the user from the collection
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 */
var setCollectionPermissions = module.exports.setCollectionPermissions = function(ctx, collectionId, permissionChanges, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to change collection permissions'}).isLoggedInUser(ctx);
    validator.check(collectionId, {'code': 400, 'msg': 'A valid collection id must be provided'}).isResourceId();
    validator.check(null, {'code': 400, 'msg': 'Must specify at least one permission change to apply'}).isObject(permissionChanges);
    validator.check(_.keys(permissionChanges).length, {'code': 400, 'msg': 'You must specify at least one permission change'}).min(1);
    _.each(permissionChanges, function(role, principalId) {
        validator.check(principalId, {'code': 400, 'msg': 'The member id: ' + principalId + ' is not a valid member id'}).isPrincipalId();
        validator.check(role, {'code': 400, 'msg': 'The role change: ' + role + ' is not a valid value. Must either be a string, or false'}).isValidRoleChange();
        if (role) {
            validator.check(role, {'code': 400, 'msg': 'The role :' + role + ' is not a valid value. Must be one of: ' + CollectionsConstants.roles.ALL_PRIORITY.join(', ') + '; or false'}).isIn(CollectionsConstants.roles.ALL_PRIORITY);
        }
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the collection object, throwing an error if it doesn't exist, but not applying permissions checks
    _getCollection(collectionId, function(err, collection) {
        if (err) {
            return callback(err);
        }

        // Ensure we are allowed to add the new members
        AuthzAPI.computeMemberRolesAfterChanges(collection.groupId, permissionChanges, function(err, membershipAfterChanges, newMemberIds, updatedMemberIds, removedMemberIds) {
            if (err) {
                return callback(err);
            }

            // Ensure the user is allowed to set the collection permissions
            CollectionsAuthz.canSetCollectionPermissions(ctx, collection, newMemberIds, function(err, canSetPermissions, illegalMemberIds) {
                if (err && err.code === 404) {
                    return callback({'code': 400, 'msg': 'One or more target members being granted access do not exist'});
                } else if (err) {
                    return callback(err);
                } else if (illegalMemberIds) {
                    // Ensures we don't violate tenant privacy boundaries
                    return callback({'code': 400, 'msg': 'One or more target members being granted access are not authorized to become members on this collection'});
                } else if (!canSetPermissions) {
                    // Ensures we have access to the collection
                    return callback({'code': 401, 'msg': 'You are not authorized to update the permissions of this collection'});
                } else if (!_.contains(_.values(membershipAfterChanges), CollectionsConstants.roles.MANAGER)) {
                    // If the anticipated membership after these changes has no manager, bail out
                    return callback({'code': 400, 'msg': 'The requested change results in a collection with no managers'});
                }

                // All validation checks have passed, finally persist the role change and update the user libraries
                AuthzAPI.updateRoles(collection.groupId, permissionChanges, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Insert the collection into the libraries of new members
                    CollectionsCollectionsLibrary.insert(newMemberIds, collection, function(err) {
                        if (err) {
                            log(ctx).warn({
                                'err': err,
                                'collectionId': collection.id,
                                'principalIds': newMemberIds
                            }, 'An error occurred while adding collection to member libraries after role assignment');
                        }

                        // Remove the collection from the libraries of removed members
                        CollectionsCollectionsLibrary.remove(removedMemberIds, collection, function(err) {
                            if (err) {
                                log(ctx).warn({
                                    'err': err,
                                    'collectionId': collection.id,
                                    'principalIds': removedMemberIds
                                }, 'An error occurred while removing collection from member libraries after role removal');
                            }

                            // TODO: Test timestamp doesn't update with subsequent set-permissions
                            // For all current members, update the collection in their libraries. This includes
                            // members that were just added which is a bit of a waste, but easier to code
                            var updateMemberIds = _.keys(membershipAfterChanges);
                            OaeUtil.invokeIfNecessary(_testLibraryUpdateThreshold(collection), CollectionsCollectionsLibrary.update, updateMemberIds, collection, null, function(err) {
                                if (err) {
                                    log(ctx).warn({
                                        'err': err,
                                        'collectionId': collection.id,
                                        'principalIds': updateMemberIds
                                    }, 'An error occurred while updating collection in member libraries after having permissions updated');
                                }

                                CollectionsAPI.emit(CollectionsConstants.events.UPDATED_COLLECTION_MEMBERS, ctx, collection, _.pick(permissionChanges, updatedMemberIds), newMemberIds, updatedMemberIds, removedMemberIds);
                                return callback();
                            });
                        });
                    });
                });
            });
        });
    });
};

/**
 * Add a set of content items to a collection
 *
 * @param  {Context}    ctx             The context of the current request
 * @param  {String}     collectionId    The id of the collection to which to add the content items
 * @param  {String[]}   contentIds      The ids of the content items to add to the collection
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var addContentItemsToCollection = module.exports.addContentItemsToCollection = function(ctx, collectionId, contentIds, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be authenticated to be able to add an item to a collection'}).isLoggedInUser(ctx);
    validator.check(collectionId, {'code': 400, 'msg': 'A valid collection id must be provided'}).isResourceId();
    validator.check(null, {'code': 400, 'msg': 'Must specify at least one content item to add'}).isArray(contentIds);
    validator.check(_.values(contentIds).length, {'code': 400, 'msg': 'You must specify at least one content item to add'}).min(1);

    // Ensure each content id is valid
    _.each(contentIds, function(contentId) {
        validator.check(contentId, {'code': 400, 'msg': util.format('The id "%s" is not a valid content id', contentId)}).isResourceId();
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the collection to which we're trying to add the content items
    _getCollection(collectionId, function(err, collection) {
        if (err) {
            return callback(err);
        }

        // Get the content profiles of all items being added for permission checks
        ContentDAO.Content.getMultipleContentItems(contentIds, null, function(err, contentItems) {
            if (err) {
                return callback(err);
            }

            // Determine if the content items can be added to the collection
            CollectionsAuthz.canAddItemsToCollection(ctx, collection, contentItems, function(err, canAddItem, illegalContentIds) {
                if (err) {
                    return callback(err);
                } else if (!canAddItem && illegalContentIds) {
                    return callback({'code': 400, 'msg': util.format('You are not authorized to add the following items to the collection: %s', illegalContentIds.join(', '))});
                } else if (!canAddItem) {
                    return callback({'code': 401, 'msg': 'You are not authorized to add items to this collection'});
                }

                // Add all the items to the collection
                _addContentItemsToCollection(collection, contentItems.slice(), function(err) {
                    if (err) {
                        return callback(err);
                    }

                    CollectionsContentLibrary.insert(collection, contentItems, function(err) {
                        if (err) {
                            log(ctx).warn({
                                'err': err,
                                'collectionId': collection.id,
                                'contentIds': _.pluck(contentItems, 'id')
                            }, 'An error occurred while inserting content items into a collection library');
                        }

                        CollectionsAPI.emit(CollectionsConstants.events.ADDED_CONTENT_ITEMS, ctx, collection, contentItems);
                        return callback();
                    });
                });
            });
        });
    });
};

/**
 * List a user or group library of collections
 *
 * @param  {Context}        ctx                     The context of the current request
 * @param  {String}         principalId             The id of the user or group whose library of collections to list
 * @param  {String}         [start]                 A token that indicates where in the list to start returning collections. Use the `nextToken` result from this method to determine where to start the next page of collections
 * @param  {Number}         [limit]                 The maximum number of collections to return
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Collection[]}   callback.collections    The list of collections
 * @param  {String}         callback.nextToken      The token to use for the next `start` value in order to get the next page of collections. If this value is `null`, it indicates that there are no more collections to page
 */
var getCollectionsLibrary = module.exports.getCollectionsLibrary = function(ctx, principalId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'A user or group id must be provided'}).isPrincipalId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the principal
    PrincipalsDAO.getPrincipal(principalId, function(err, principal) {
        if (err) {
            return callback(err);
        }

        // Determine which library visibility the current user should receive
        LibraryAPI.Authz.resolveTargetLibraryAccess(ctx, principal.id, principal.visibility, function(err, hasAccess, visibility) {
            if (err) {
                return callback(err);
            } else if (!hasAccess) {
                return callback({'code': 401, 'msg': 'You do not have have access to this library'});
            }

            // Get the collection ids from the library index
            CollectionsCollectionsLibrary.list(principal, visibility, {'start': start, 'limit': limit}, function(err, collectionIds, nextToken) {
                if (err) {
                    return callback(err);
                }

                // Get the collection objects from the collectionIds
                CollectionsDAO.getCollectionsByIds(collectionIds, function(err, collections) {
                    if (err) {
                        return callback(err);
                    }

                    return callback(null, collections, nextToken);
                });
            });
        });
    });
};

/**
 * List the library of content items that have been added to a collection
 *
 * @param  {Context}        ctx                     The context of the current request
 * @param  {String}         collectionId            The id of the collection whose content library to list
 * @param  {String}         [start]                 A token that indicates where in the list to start returning content items. Use the `nextToken` result from this method to determine where to start the next page of content items
 * @param  {Number}         [limit]                 The maximum number of content items to return
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Collection[]}   callback.contentItems   The list of content items in the collection library
 * @param  {String}         callback.nextToken      The token to use for the next `start` value in order to get the next page of content items. If this value is `null`, it indicates that there are no more content items to page
 */
var getCollectionContentLibrary = module.exports.getCollectionContentLibrary = function(ctx, collectionId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(collectionId, {'code': 400, 'msg': 'A collection id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the collection
    _getCollection(collectionId, function(err, collection) {
        if (err) {
            return callback(err);
        }

        // Determine which library visibility the current user should receive
        LibraryAPI.Authz.resolveTargetLibraryAccess(ctx, collection.groupId, collection.visibility, function(err, hasAccess, visibility) {
            if (err) {
                return callback(err);
            } else if (!hasAccess) {
                return callback({'code': 401, 'msg': 'You do not have access to this collection'});
            }

            CollectionsContentLibrary.list(collection, visibility, {'start': start, 'limit': limit}, function(err, contentIds, nextToken) {
                if (err) {
                    return callback(err);
                }

                ContentDAO.Content.getMultipleContentItems(contentIds, null, function(err, contentItems) {
                    if (err) {
                        return callback(err);
                    }

                    return callback(null, contentItems, nextToken);
                });
            });
        });
    });
};

/**
 * Recursively add the given list of content items to the given collection. This method is
 * destructive to the `contentItems` parameter as it iterates
 *
 * @param  {Collection}     collection      The collection to which to add the content items
 * @param  {Content[]}      contentItems    The content items to add to the collection
 * @param  {Function}       callback        Standard callback function
 * @param  {Object}         callback.err    An error that occurred, if any
 * @api private
 */
var _addContentItemsToCollection = function(collection, contentItems, callback) {
    if (_.isEmpty(contentItems)) {
        return callback();
    }

    var roleChange = {};
    roleChange[collection.groupId] = ContentConstants.roles.VIEWER;

    var contentItem = contentItems.pop();
    AuthzAPI.updateRoles(contentItem.id, roleChange, function(err) {
        if (err) {
            return callback(err);
        }

        return _addContentItemsToCollection(collection, contentItems, callback);
    });
};

/**
 * Get a collection from storage by its id
 *
 * @param  {String}     collectionId    The id of the collection to get
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 * @api private
 */
var _getCollection = function(collectionId, callback) {
    CollectionsDAO.getCollectionsByIds([collectionId], function(err, collections) {
        if (err) {
            return callback(err);
        } else if (_.isEmpty(collections)) {
            return callback({'code': 404, 'msg': util.format('A collection with the id "%s" could not be found', collectionId)});
        }

        return callback(null, collections[0]);
    });
};

/**
 * Given a collection, determine if sufficient time has passed since it's last update to re-order it
 * once again in user and group principal libraries
 *
 * @param  {Collection}     collection      The collection whose last modified date to test
 * @return {Boolean}                        `true` if the collection can be updated in user and group libraries
 * @api private
 */
var _testLibraryUpdateThreshold = function(collection) {
    return (!collection.lastModified || (Date.now() - collection.lastModified) > (LIBRARY_UPDATE_THRESHOLD_SECONDS * 1000));
};
