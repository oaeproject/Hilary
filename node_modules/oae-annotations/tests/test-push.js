/*
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');
var fs = require('fs');

var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;
var ActivityTestsUtil = require('oae-activity/lib/test/util');
var RestAPI = require('oae-rest');
var RestContext = require('oae-rest/lib/model').RestContext;
var TestsUtil = require('oae-tests');

var AnnotationConstants = require('oae-annotations/lib/constants').AnnotationConstants;

describe('Annotations - Push', function() {
    // Rest contexts that can be used performing rest requests
    var localAdminRestContext = null;

    /**
     * Function that will fill up the tenant admin and anymous rest contexts
     */
    before(function(callback) {
        localAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.localhost.host);
        callback();
    });

    /**
     * Utility method that returns a stream that points to an OAE animation thumbnail.
     *
     * @return {Stream}     A stream that points to an OAE animation thumbnail that can be uploaded.
     */
    var getFileStream = function() {
        var file = __dirname + '/data/paper.txt';
        return fs.createReadStream(file);
    };

    /**
     * Creates 2 users: `Branden` and `Simon` who are both managers of a file. A websocket will be created
     * for the `Simon`-user which is both authenticated and registered for push notifications on the file.
     *
     * @param  {Function}   callback            Gets executed once the fixture has been setup
     * @param  {Object}     callback.contexts   An object that holds the context and user info for the created users
     * @param  {Content}    callback.content    The created piece of content
     * @param  {Client}     callback.client     A websocket client that is authenticated for the `Simon`-user and is registered for push notificates on the created piece of content
     * @throws {Error}                          If anything goes wrong, an assertion error will be thrown
     */
    var setupFixture = function(callback) {
        TestsUtil.generateTestUsers(localAdminRestContext, 2, function(err, users, branden, simon) {
            assert.ok(!err);

            var contexts = {
                'branden': branden,
                'simon': simon
            };

            // Get the full profile so we have a signature to authenticate ourselves on the WS
            RestAPI.User.getMe(contexts['simon'].restContext, function(err, simonFull) {
                assert.ok(!err);

                // Create a piece of content and get the full content profile so we have a signature that we can use to register for push notifications
                RestAPI.Content.createFile(contexts['simon'].restContext, 'A file', 'A proper file', 'private', getFileStream, [contexts['branden'].user.id], [], [], function(err, contentObj) {
                    assert.ok(!err);
                    RestAPI.Content.getContent(contexts['simon'].restContext, contentObj.id, function(err, contentObj) {
                        assert.ok(!err);

                        // Route and deliver activities
                        ActivityTestsUtil.collectAndGetActivityStream(contexts['simon'].restContext, null, null, function() {

                            // Register for some streams
                            var data = {
                                'authentication': {
                                    'userId': contexts['simon'].user.id,
                                    'tenantAlias': simonFull.tenant.alias,
                                    'signature': simonFull.signature
                                },
                                'streams': [
                                    {
                                        'resourceId': contentObj.id,
                                        'streamType': 'activity',
                                        'token': contentObj.signature
                                    },
                                    {
                                        'resourceId': contentObj.id,
                                        'streamType': 'message',
                                        'token': contentObj.signature
                                    }
                                ]
                            };

                            ActivityTestsUtil.getFullySetupPushClient(data, function(client) {
                                callback(contexts, contentObj, client);
                            });
                        });
                    });
                });
            });
        });
    };

    /**
     * Test that verifies that annotation-update activities are routed to the content item's activity stream
     */
    it('verify annotation-update activities are routed to the content item activity stream', function(callback) {
        setupFixture(function(contexts, content, client) {

            // Create an annotation
            var ranges = [{
                'start': '/div[1]/div',
                'end': '/div[1]/div',
                'startOffset': 3,
                'endOffset': 9
            }];
            RestAPI.Annotations.createAnnotation(contexts['simon'].restContext, content.id, content.latestRevisionId, 1, 'text', 'quote', ranges, function(err, annotation) {
                assert.ok(!err);

                // Collect the activities so the create activity doesn't appear on our client
                ActivityTestsUtil.collectAndGetActivityStream(contexts['simon'].restContext, contexts['simon'].user.id, null, function(err, activityStream) {
                    assert.ok(!err);

                    // Trigger an update
                    RestAPI.Annotations.updateAnnotation(contexts['simon'].restContext, content.id, content.latestRevisionId, annotation.id, 'updated text', function(err, updatedAnnotation) {
                        assert.ok(!err);
                    });

                    // Listen for a message on the push client
                    client.on('message', function(message) {
                        ActivityTestsUtil.assertActivity(message.activities[0], AnnotationConstants.activity.UPDATE, ActivityConstants.verbs.UPDATE, contexts['simon'].user.id, annotation.id, content.id);

                        // Verify the updated text is present on the activity object
                        assert.equal(message.activities[0].object['oae:annotation'].text, 'updated text');

                        client.close(callback);
                    });
                });
            });
        });
    });

    /**
     * Test that verifies that annotation-delete activities are routed to the content item's activity stream
     */
    it('verify annotation-delete activities are routed to the content item activity stream', function(callback) {
        setupFixture(function(contexts, content, client) {

            // Create an annotation
            var ranges = [{
                'start': '/div[1]/div',
                'end': '/div[1]/div',
                'startOffset': 3,
                'endOffset': 9
            }];
            RestAPI.Annotations.createAnnotation(contexts['simon'].restContext, content.id, content.latestRevisionId, 1, 'text', 'quote', ranges, function(err, annotation) {
                assert.ok(!err);

                // Collect the activities so the create activity doesn't appear on our client
                ActivityTestsUtil.collectAndGetActivityStream(contexts['simon'].restContext, contexts['simon'].user.id, null, function(err, activityStream) {
                    assert.ok(!err);

                    // Trigger an update
                    RestAPI.Annotations.deleteAnnotation(contexts['simon'].restContext, content.id, content.latestRevisionId, annotation.id, function(err) {
                        assert.ok(!err);
                    });

                    // Listen for a message on the push client
                    client.on('message', function(message) {
                        ActivityTestsUtil.assertActivity(message.activities[0], AnnotationConstants.activity.DELETE, ActivityConstants.verbs.DELETE, contexts['simon'].user.id, annotation.id, content.id);
                        client.close(callback);
                    });
                });
            });
        });
    });
});
