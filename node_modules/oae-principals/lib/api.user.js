/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var clone = require('clone');
var csv = require('csv');
var events = require('events');
var fs = require('fs');
var Path = require('path');
var sanitize = require('validator').sanitize;
var ShortId = require('shortid');
var util = require('util');

var AuthenticationConstants = require('oae-authentication/lib/constants').AuthenticationConstants;
var AuthenticationUtil = require('oae-authentication/lib/util');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzUtil = require('oae-authz/lib/util');
var ConfigAPI = require('oae-config');
var Context = require('oae-context').Context;
var EmailAPI = require('oae-email');
var log = require('oae-logger').logger('oae-principals');
var OaeUtil = require('oae-util/lib/util');
var Redis = require('oae-util/lib/redis');
var Validator = require('oae-util/lib/validator').Validator;
var TenantsAPI = require('oae-tenants');
var TenantsUtil = require('oae-tenants/lib/util');
var Signature = require('oae-util/lib/signature');
var Validator = require('oae-util/lib/validator').Validator;

var PrincipalsConfig = ConfigAPI.config('oae-principals');
var PrincipalsConstants = require('./constants').PrincipalsConstants;
var PrincipalsDAO = require('./internal/dao');
var PrincipalsEmitter = require('./internal/emitter');
var PrincipalsTermsAndConditionsAPI = require('./api.termsAndConditions');
var PrincipalsUtil = require('./util');
var User = require('./model').User;

var fullUserProfileDecorators = {};

/**
 * Register a decorator for the full user profile. A decorator will, at read time, provide additional data about the user
 * that will be returned to the client
 *
 * @param  {String}     namespace                   The unique namespace for this decorator. This will be used as the actual property name on the full user profile object. If this namespace collides with an existing user profile property, it will be silently ignored
 * @param  {Function}   decorator                   The function that will provide additional data for the user profile
 * @param  {Context}    decorator.ctx               The context of the current request
 * @param  {User}       decorator.user              The user being decorated
 * @param  {Function}   decorator.callback          This function should be invoked with the decoration object when complete
 * @param  {Object}     decorator.callback.err      An error that occurred during decoration, if any
 * @param  {Object}     decorator.callback.data     The decoration data to bind to the full user profile
 */
var registerFullUserProfileDecorator = module.exports.registerFullUserProfileDecorator = function(namespace, decorator) {
    if (fullUserProfileDecorators[namespace]) {
        throw new Error(util.format('Attempted to register duplicate full user profile decorator with namespace "%s"', namespace));
    } else if (!_.isFunction(decorator)) {
        throw new Error(util.format('Attempted to register full user profile decorator for namespace "%s" without a decorator function', namespace));
    }

    fullUserProfileDecorators[namespace] = decorator;
};

/**
 * Create a new user record on a tenant. If the optional `tenantAlias` is not specified, the user
 * will be created on the current tenant. Note that you will still need to associate an
 * authentication strategy with this user record as the user would otherwise have no means
 * of logging onto the system.
 *
 * If an email address is specified, it's assumed that you have ensured that no other user
 * account with this email address exists.
 *
 * @param  {Context}   ctx                      Standard context object containing the current user and the current tenant
 * @param  {String}    [tenantAlias]            The alias of the tenant on which to create the user. If left undefined, the current tenant's alias will be used
 * @param  {String}    displayName              The display name for the user
 * @param  {Object}    [opts]                   Optional parameters for the user
 * @param  {String}    [opts.visibility]        The visibility of the user. One of AuthzConstants.visibility
 * @param  {String}    [opts.locale]            The locale for the user
 * @param  {String}    [opts.publicAlias]       The name to show when the user is inaccessible to a user
 * @param  {Boolean}   [opts.acceptedTC]        Whether or not the user has accepted the Terms & Conditions
 * @param  {String}    [opts.email]             The email addres for the user
 * @param  {String}    [opts.emailPreference]   The email preference for the user. One of PrincipalsConstants.emailPreference
 * @param  {Boolean}   [opts.emailVerified]     Whether or not the user's email address is verified. Defaults to `false`
 * @param  {Boolean}   [opts.guest]             Whether or not the user is a guest. Defaults to `false`
 * @param  {String}    [opts.smallPictureUri]   The URI for the small picture
 * @param  {String}    [opts.mediumPictureUri]  The URI for the medium picture
 * @param  {String}    [opts.largePictureUri]   The URI for the large picture
 * @param  {Function}  callback                 Standard callback function
 * @param  {Object}    callback.err             An error that occurred, if any
 * @param  {User}      callback.createdUser     The created user
 */
var createUser = module.exports.createUser = function(ctx, tenantAlias, displayName, opts, callback) {
    tenantAlias = tenantAlias || ctx.tenant().alias;
    opts = opts || {};
    callback = callback || function(err) {
        if (err) {
            log().error({
                'err': err,
                'displayName': displayName
            }, 'Error creating user');
        }
    };

    // Resolve the initial locale for the new user
    if (!opts.locale) {
        // If a user is creating an account for themself (i.e., they are currently anonymous) then
        // we try and use the locale suggested by the request context (e.g., browser locale)
        if (!ctx.user()) {
            opts.locale = ctx.locale();
        }

        // If a user is creating a user on behalf of someone else or there was no suggested
        // locale, we fall back to the configured tenant default
        if (!opts.locale) {
            opts.locale = PrincipalsConfig.getValue(tenantAlias, 'user', 'defaultLanguage');
        }
    }

    var isAdmin = (ctx.user() && ctx.user().isAdmin(tenantAlias));
    opts.visibility = opts.visibility || PrincipalsConfig.getValue(tenantAlias, 'user', 'visibility');
    opts.publicAlias = opts.publicAlias || displayName;
    opts.acceptedTC = opts.acceptedTC || false;
    opts.emailPreference = opts.emailPreference || PrincipalsConfig.getValue(tenantAlias, 'user', 'emailPreference');
    opts.emailVerified = (opts.emailVerified === true || isAdmin);

    var validator = new Validator();
    validator.check(displayName, {'code': 400, 'msg': 'A display name must be provided'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'A display name can be at most 1000 characters long'}).isShortString();
    validator.check(opts.visibility, {'code': 400, 'msg': 'The specified visibility setting is unknown'}).isIn(_.values(AuthzConstants.visibility));
    validator.check(opts.emailPreference, {'code': 400, 'msg': 'The specified email preference is invalid'}).isIn(_.values(PrincipalsConstants.emailPreferences));
    if (opts.email) {
        validator.check(opts.email, {'code': 400, 'msg': 'The specified email address is invalid'}).isEmail();
    }

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var id = AuthzUtil.toId('u', tenantAlias, ShortId.generate());
    var user = new User(tenantAlias, id, displayName, {
        'visibility': opts.visibility,
        'email': opts.email,
        'locale': opts.locale,
        'publicAlias': opts.publicAlias,
        'emailPreference': opts.emailPreference,
        'emailVerified': opts.emailVerified,
        'smallPictureUri': opts.smallPictureUri,
        'mediumPictureUri': opts.mediumPictureUri,
        'largePictureUri': opts.lagePictureUri,
        'acceptedTC': 0,
        'guest': opts.guest
    });

    // We store the timestamp at which the user accepted the Terms and Conditions
    // This allows for allowing users to re-accept the Terms and Conditions after they have been updated
    user.needsToAcceptTC = PrincipalsConfig.getValue(tenantAlias, 'termsAndConditions', 'enabled');
    if (user.needsToAcceptTC && opts.acceptedTC) {
        user.acceptedTC = Date.now();
        user.needsToAcceptTC = false;
    }

    PrincipalsDAO.createUser(user, function(err) {
        if (err) {
            return callback(err);
        }

        // Emit an event so the user can be indexed by search
        PrincipalsEmitter.emit(PrincipalsConstants.events.CREATED_USER, ctx, user);

        // Return to the caller
        callback(null, user);

        // If the user information didn't come from an authoritative source
        // we ask the user to verify his email
        if (!isAdmin && user.email && !user.emailVerified) {
            sendEmailToken(ctx, user);
        }
    });
};

/**
 * Create a guest user account for an email address. If an existing (guest) user account
 * was already associated with the email addres, it will be returned. If not, a guest
 * account will be created.
 *
 * @param  {Context}    ctx                         Standard context object containing the current user and the current tenant
 * @param  {String}     email                       The email for the user
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error that occurred, if any
 * @param  {User}       callback.user               The user
 * @param  {Boolean}    callback.isGuest            `true` if the returned user is a guest user
 */
var createGuestUser = module.exports.createGuestUser = function(ctx, email, callback) {
    // 1. Check if the email address is valid
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Anonymous users cannot invite guests'}).isLoggedInUser(ctx);
    validator.check(email, {'code': 400, 'msg': 'A valid email address must be provided'}).isEmail();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // 2. Check if the email is already mapped to a user
    PrincipalsDAO.getUserViaEmail(email, function(err, user) {
        if (err && err.code !== 404) {
            return callback(err);
        } else if (!err && user) {
            return callback(null, user, false);
        }

        // Use the first part of the email address as the display name
        var displayName = email.split('@')[0] + '@...';
        var opts = {
            'email': email,
            'emailPreference': 'daily',
            'emailVerified': true,
            'publicAlias': displayName,

            // Make the user private
            'visibility': 'private',

            // Create a guest account
            'guest': true
        };

        // 3. Get the tenant with whom the email address could be associated
        var emailDomain = email.split('@')[1];
        var tenant = TenantsUtil.getTenantForEmailDomain(emailDomain);
        if (tenant) {
            // If we found a tenant that matched the guests's email domain, we can simply
            // create a user account in that tenant. There's no need to create/associate
            // any loginIds as the loginId will be associated when the user logs in. This
            // all hinges on two things:
            //   1.  We consider the given email address as verified. This is probably not
            //       unreasonable as nobody can log into that user account and trigger any
            //       spam except for the user who owns the email address.
            //   2.  The authentication strategy releases the email address when the invited
            //       user signs into the system.
            log().debug({'tenant': tenant.alias, 'email': email, 'inviter': ctx.user().id}, 'Creating guest user on specific tenant');
            return createUser(ctx, tenant.alias, displayName, opts, callback);
        }

        // We couldn't map an email address to an existing tenant. We'll have to create
        // a user account on the guests tenant
        var guestsTenant = TenantsAPI.getGuestsTenant();
        log().debug({'email': email, 'inviter': ctx.user().id}, 'Creating guest user on guests tenant');
        createUser(ctx, guestsTenant.alias, displayName, opts, function(err, user) {
            if (err) {
                return callback(err);
            }

            // Generate a token that will be sent to the user's email address
            var token = _generateEmailToken();

            // Store the token
            PrincipalsDAO.storeEmailToken(token, user.id, function(err) {
                if (err) {
                    return callback(err);
                }

                // Send an email to the specified e-mail address
                var data = {
                    'tenant': guestsTenant,
                    'invitee': user,
                    'inviter': ctx.user(),
                    'inviterDisplayName': ctx.user().displayName,
                    'baseUrl': TenantsUtil.getBaseUrl(guestsTenant),
                    'skinVariables': require('oae-ui').getTenantSkinVariables(guestsTenant.alias),
                    'token': token
                };
                EmailAPI.sendEmail('oae-principals', 'invite', user, data, {'hash': token, 'ignoreVerification': true}, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    return callback(null, user, true);
                });
            });
        });
    });
};

/**
 * Get a set of principals identified by their principal id or, in case an email address
 * was specified, create a guest user.
 *
 * @param  {Context}        ctx                         Standard context object containing the current user and the current tenant
 * @param  {String[]}       principals                  An array of principal ids to retrieve mixed with email address for which guest accounts should be created
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error that occurred, if any
 * @param  {String[]}       callback.principalIds       The ids of the matching principals and/or created guest accounts
 */
var getOrCreateGuestUsers = module.exports.getOrCreateGuestUsers = function(ctx, principals, callback) {
    var principalIdsOrEmails = _.partition(principals, function(principal) {
        return (AuthzUtil.isUserId(principal) || AuthzUtil.isGroupId(principal));
    });
    var principalIds = principalIdsOrEmails[0];
    var emails = principalIdsOrEmails[1];

    // If no emails were specified, we can simply return the principal ids
    if (_.isEmpty(emails)) {
        return callback(null, principalIds);
    }

    // Validate the non-principal ids are actually emails
    var validator = new Validator();
    _.each(emails,function(email) {
        validator.check(email, {'code': 400, 'msg': 'The specified principal is not a valid email addres'}).isEmail();
    });
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Create the guest user accounts
    _createGuestUsers(ctx, emails, callback, principalIds);
};

/**
 * Create a guest user account for a set of email addresses
 *
 * @param  {Context}        ctx                         Standard context object containing the current user and the current tenant
 * @param  {String[]}       emails                      The email address for which to create guest user accounts
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error that occurred, if any
 * @param  {String[]}       callback.principalIds       The ids of the matching principals and/or created guest accounts
 * @api private
 */
var _createGuestUsers = function(ctx, emails, callback, _principalIds) {
    if (emails.length === 0) {
        return callback(null, _principalIds);
    }

    var email = emails.pop();
    createGuestUser(ctx, email, function(err, user) {
        if (err) {
            return callback(err);
        }

        _principalIds.push(user.id);
        _createGuestUsers(ctx, emails, callback, _principalIds);
    });
};

/**
 * Verify a guest token and associate a local login strategy with the user matching the token.
 *
 * @param  {Context}    ctx                         Standard context object containing the current user and the current tenant
 * @param  {String}     token                       The token to verify
 * @param  {String}     username                    The desired username
 * @param  {String}     password                    The desired password
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error that occurred, if any
 */
var verifyGuestToken = module.exports.verifyGuestToken = function(ctx, token, username, password, callback) {
    var validator = new Validator();
    validator.check(token, {'code': 400, 'msg': 'A token must be provided'}).notEmpty();
    validator.check(username, {'code': 400, 'msg': 'A username must be provided'}).notEmpty();
    validator.check(password, {'code': 400, 'msg': 'A password must be provided'}).notEmpty();
    validator.check(password, {'code': 400, 'msg': 'A password must contain at least 6 characters'}).len(6);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    PrincipalsDAO.getUserViaEmailToken(token, function(err, user) {
        if (err) {
            return callback(err);
        }

        // Associate the user with the new login
        var hashedPassword = require('oae-authentication/lib/util').hashPassword(password);
        var loginId = new require('oae-authentication/lib/model').LoginId(ctx.tenant().alias, 'local', username, {'password': hashedPassword});

        // Fake a context
        var userCtx = new Context(ctx.tenant(), user);
        require('oae-authentication').associateLoginId(userCtx, loginId, user.id, function(err) {
            if (err) {
                return callback(err);
            }

            // Remove the guest email token
            PrincipalsDAO.validateToken(token, user, callback);
        });
    });
};

/**
 * Import users using a CSV file. The CSV file should be formatted in the following way:
 *
 *  `externalId, lastName, firstName, email`
 *
 * When importing a set of users using the local authentication strategy, the CSV format should be the following:
 *
 *  `externalId, password, lastName, firstName, email`
 *
 * When an external id for the provided authentication strategy cannot be found, a new user will be created. When that
 * user can be found, no new user will be created. When that user's display name is the same as their external id and
 * a real display name is available in the CSV file, the user's display name will be updated to be the one in the CSV
 * file. When that user doesn't have an email address set and an email address is available in the CSV file, the user's
 * email address will be updated to be the one in the CSV file. This accounts for the scenario where an external authentication
 * provider that doesn't release the required basic profile attributes was configured and users signed into it before the
 * full user list with appropriate basic profile attributes was imported.
 *
 * When the `forceProfileUpdate` parameter is provided, the user's display name and email address will always be set to the values provided in the CSV file.
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}         [tenantAlias]           The alias of the tenant for which the users should imported
 * @param  {Object}         userCSV                 File object representing the uploaded CSV file as returned by express
 * @param  {String}         authenticationStrategy  The authentication strategy with which the provided external ids should be associated (One of AuthenticationConstants.providers)
 * @param  {Boolean}        [forceProfileUpdate]    Whether or not the user's display name, public alias and email should be updated with the value specified in the CSV file, even when the display name/public alais is different than the external id or an email address has been set. By default, this will be set to `false`
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 */
var importUsers = module.exports.importUsers = function(ctx, tenantAlias, userCSV, authenticationStrategy, forceProfileUpdate, callback) {
    tenantAlias = tenantAlias || ctx.user().tenant.alias;
    forceProfileUpdate = forceProfileUpdate || false;
    callback = callback || function() {};

    var tenant = TenantsAPI.getTenant(tenantAlias);

    // Only global or tenant administrators should be able to import users
    if (!ctx.user() || !ctx.user().isAdmin(tenantAlias)) {
        return _cleanUpCSVFile(userCSV, function() {
            callback({'code': 401, 'msg': 'Only authorized admins can import users'});
        });
    }

    // Parameter validation
    var validator = new Validator();
    validator.check(tenant, {'code': 400, 'msg': 'An existing tenant alias must be provided'}).notNull();
    validator.check(userCSV, {'code': 400, 'msg': 'A CSV file must be provided'}).notNull();
    if (userCSV) {
        validator.check(userCSV.size, {'code': 400, 'msg': 'Missing size on the CSV file'}).notEmpty();
        validator.check(userCSV.size, {'code': 400, 'msg': 'Invalid size on the CSV file'}).isInt();
        validator.check(userCSV.size, {'code': 400, 'msg': 'Invalid size on the CSV file'}).min(0);
        validator.check(userCSV.name, {'code': 400, 'msg': 'Missing name on the CSV file'}).notEmpty();
    }
    validator.check(authenticationStrategy, {'code': 400, 'msg': 'An authentication strategy must be provided'}).notEmpty();
    validator.check(authenticationStrategy, {'code': 400, 'msg': 'The specified authentication strategy is unknown'}).isIn(_.values(AuthenticationConstants.providers));
    if (validator.hasErrors()) {
        return _cleanUpCSVFile(userCSV, function() {
            callback(validator.getFirstError());
        });
    }

    // Create a new context object on the request tenant
    var adminCtx = new Context(tenant, ctx.user());

    // Will contain an entry for each user in the CSV file
    var data = [];

    // The CSV module works with streams, so get a readable stream to the uploaded CSV file
    var input = fs.createReadStream(userCSV.path);

    // Pipe the stream to a CSV parser and keep track of the user records
    var parser = csv.parse({'trim': true});
    input.pipe(parser);
    parser.on('readable', function() {
        var user = parser.read();
        while (user) {
            data.push(user);
            user = parser.read();
        }
    });

    parser.on('finish', function() {
        // If the CSV parse was successful, we call the callback to prevent the request from timing out
        // whilst the users are being loaded
        PrincipalsEmitter.emit('preCSVUserImport');
        callback();

        // Remove the uploaded file
        _cleanUpCSVFile(userCSV, function() {
            log(ctx).info({
                'tenantAlias': tenantAlias,
                'authenticationStrategy': authenticationStrategy
            }, 'Starting user import from CSV');

            /*!
             * Process an invidual user from the CSV file and create a new user if no user exists for the provided
             * external id - authentication strategy combination.
             *
             * @param  {Array.<Array.<String>>}     data        Parsed CSV file
             */
            var processUser = function(data) {
                // Get the next user from the stack
                var user = data.pop();

                // Extract the password in case local authentication is used
                var opts = {};
                var providerProperties = null;
                if (authenticationStrategy === AuthenticationConstants.providers.LOCAL) {
                    providerProperties = {'password': user.splice(1, 1)};
                }

                // Extract the basic profile data
                var externalId = user[0];

                // Construct the first name and last name into a display name
                var displayName = util.format('%s %s', user[2], user[1]).trim();

                // An uploaded CSV file is considered to be an authoritative source
                // so the email address doesn't have to be verified by the user
                opts.email = user[3];
                opts.emailVerified = true;

                /*!
                 * Gets called when the user has been created or updated
                 *
                 * @param  {Object}     err     An error object that can be returned by the updateUser call
                 */
                var finishImportUser = function(err) {
                    if (err) {
                        log().error({'err': err, 'externalId': externalId}, 'Failed to import user');
                    }

                    if (_.isEmpty(data)) {
                        log(ctx).info({
                            'authenticationStrategy': authenticationStrategy,
                            'tenantAlias': tenantAlias
                        }, 'Finished user import from CSV');

                        // Send out an event indicating that the import has finished
                        return PrincipalsEmitter.emit('postCSVUserImport');
                    // Add a progress log statement every 25 imported users
                    } else if (data.length % 25 === 0) {
                        log(ctx).info({
                            'authenticationStrategy': authenticationStrategy,
                            'tenantAlias': tenantAlias
                        }, 'Importing users from CSV. ' + data.length + ' users left to import');
                    }
                    // Process the next user
                    processUser(data);
                };

                // Check if the user already exists and create a new user if it doesn't.
                // If the user already exists but has a different displayName from the one
                // in the CSV file, we update it
                // TODO: Fix cross-dependency between the Authentication API and the Principals API
                require('oae-authentication').getOrCreateUser(adminCtx, authenticationStrategy, externalId, providerProperties, displayName, opts, function(err, user, loginId, created) {
                    if (err) {
                        return finishImportUser(err);

                    // If the user already existed it's possible that we need to update it
                    } else if (!created) {
                        var update = {};

                        if (forceProfileUpdate) {
                            // Only perform the update if there's a difference
                            if (user.displayName !== displayName) {
                                update['displayName'] = displayName;
                            }
                            if (user.publicAlias !== displayName) {
                                update['publicAlias'] = displayName;
                            }
                            if (user.email !== opts.email) {
                                update['email'] = opts.email;
                            }
                        } else {
                            // Only update the user's displayname or email when their is value in doing it
                            if (user.displayName === externalId) {
                                update['displayName'] = displayName;
                            }
                            if (!user.publicAlias || user.publicAlias === externalId) {
                                update['publicAlias'] = displayName;
                            }
                        }

                        if (!_.isEmpty(update)) {
                            log(ctx).info({
                                'externalId': externalId,
                                'user': user,
                                'update': update
                            }, 'Updating display name, public alias and/or email during import from CSV');
                            updateUser(adminCtx, user.id, update, finishImportUser);
                        } else {
                            finishImportUser();
                        }

                    // If the user was created, we can move on to the next one
                    } else {
                        finishImportUser();
                    }
                });
            };

            // Process the first user
            processUser(data);
        });

    // Parsing error
    }).on('error', function(err){
        // Remove the uploaded file
        _cleanUpCSVFile(userCSV, function() {
            callback({'code': 500, 'msg': err.message});
        });
    });
};

/**
 * Remove an uploaded user CSV file
 * TODO: Move this out into a utility as this functionality is needed in a number of places
 *
 * @param  {Object}         userCSV                 File object representing the uploaded CSV file as returned by express
 * @param  {Function}       callback                Standard callback function
 * @api private
 */
var _cleanUpCSVFile = function(userCSV, callback) {
    if (userCSV && userCSV.path) {
        fs.exists(userCSV.path, function(exists) {
            if (exists) {
                fs.unlink(userCSV.path, function(err) {
                    if (err) {
                        log().warn({'err': err, 'file': userCSV}, 'Could not remove the user import CSV file');
                    }
                    callback();
                });
            } else {
                callback();
            }
        });
    } else {
        callback();
    }
};

/**
 * Update a user
 *
 * @param  {Context}        ctx             Standard context object containing the current user and the current tenant
 * @param  {String}         userId          TThe id of the user to update
 * @param  {Object}         profileFields   Object that represent the profile fields that should be updated. Possible keys are `visibility`, `displayName`, `publicAlias`, `locale`, `email` and `emailPreference`
 * @param  {Function}       callback        Standard callback function
 * @param  {Object}         callback.err    An error that occurred, if any
 * @param  {User}           callback.user   The updated user
 */
var updateUser = module.exports.updateUser = function(ctx, userId, profileFields, callback) {
    callback = callback || function() {};
    profileFields = profileFields || {};

    var profileFieldKeys = _.keys(profileFields);

    // Parameter validation
    var validator = new Validator();
    validator.check(userId, {'code': 400, 'msg': 'A valid user id must be provided'}).notEmpty();
    validator.check(userId, {'code': 400, 'msg': 'A valid user id must be provided'}).isUserId();

    // Check that there is at least one updated profile field.≠≠
    validator.check(profileFieldKeys.length, {'code': 400, 'msg': 'At least one basic profile field should be specified'}).min(1);

    // verify that restricted properties aren't set here
    var invalidKeys = _.intersection(PrincipalsDAO.getRestrictedFields(), profileFieldKeys);
    validator.check(invalidKeys.length, {'code': 400, 'msg': 'Restricted property was attempted to be set.'}).max(0);

    if (profileFields['displayName']) {
        validator.check(profileFields['displayName'], {'code': 400, 'msg': 'A display name cannot be empty'}).notEmpty();
        validator.check(profileFields['displayName'], {'code': 400, 'msg': 'A display name can be at most 1000 characters long'}).isShortString();
    }

    // In case a new visibility has been passed in, we check for its validity
    if (profileFields['visibility']) {
        validator.check(profileFields['visibility'], {'code': 400, 'msg': 'An invalid visibility option has been specified'}).isIn(_.values(AuthzConstants.visibility));
    }
    if (profileFields['email']) {
        validator.check(profileFields['email'], {'code': 400, 'msg': 'The specified email address is invalid'}).isEmail();
    }
    if (profileFields['emailPreference']) {
        validator.check(profileFields['emailPreference'], {'code': 400, 'msg': 'The specified emailPreference is invalid'}).isIn(_.values(PrincipalsConstants.emailPreferences));
    }

    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a user'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Only the user themself or an admin can update a user
    var principalResource = AuthzUtil.getResourceFromId(userId);
    if (ctx.user().id !== userId && !ctx.user().isAdmin(principalResource.tenantAlias)) {
        return callback({'code': 401, 'msg': 'You are not authorized to update this user\'s profile.'});
    }

    // Only update existing users
    PrincipalsDAO.getPrincipal(userId, function(err, oldUser) {
        if (err) {
            return callback(err);
        }

        // If the user updated his email address we need to verify it
        if (profileFields.email && oldUser.email !== profileFields.email) {
            profileFields.emailVerified = false;
            // TODO: Remove old email -> user mapping
        }

        // Overlay the correct lastModified date
        profileFields = _.extend({}, profileFields, {'lastModified': Date.now()});
        PrincipalsDAO.updatePrincipal(userId, profileFields, oldUser.email, function(err) {
            if (err) {
                return callback(err);
            }

            // The user record has changed, emit an event
            var newUser = PrincipalsUtil.createUpdatedUser(oldUser, profileFields);
            PrincipalsEmitter.emit(PrincipalsConstants.events.UPDATED_USER, ctx, newUser, oldUser);

            // Get the full user profile and return to the caller
            getUser(ctx, userId, callback);

            // If the email changed, we asynchronously send the user an email token with which he can verify the email
            if (!ctx.user().isAdmin(newUser.tenant.alias) && newUser.email !== oldUser.email) {
                sendEmailToken(ctx, newUser);
            }
        });
    });
};

/**
 * Get a user from the DB
 *
 * @param  {Context}   ctx             Standard context object containing the current user and the current tenant
 * @param  {String}    userId          The userId for the user you wish to retrieve
 * @param  {Function}  callback        Standard callback function
 * @param  {Object}    callback.err    An error that occurred, if any
 * @param  {User}      callback.user   The user object
 */
var getUser = module.exports.getUser = function(ctx, userId, callback) {
    var validator = new Validator();
    validator.check(userId, {'code': 400, 'msg': 'Must provide a user id'}).isValidId();
    validator.check(userId, {'code': 400, 'msg': 'The provided userId is not a user identifier'}).isUserId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    PrincipalsUtil.getPrincipal(ctx, userId, callback);
};

/**
 * Get the full user profile of a user. In addition to the basic profile, this also fetches the
 * decorated properties.
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     userId          The id of the user whose full profile to fetch
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 * @param  {Object}     callback.user   The decorated user object
 */
var getFullUserProfile = module.exports.getFullUserProfile = function(ctx, userId, callback) {

    var validator = new Validator();
    validator.check(userId, {'code': 400, 'msg': 'Must provide a user id'}).isValidId();
    validator.check(userId, {'code': 400, 'msg': 'The provided userId is not a user identifier'}).isUserId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the basic user profile to decorate
    getUser(ctx, userId, function(err, user) {
        if (err) {
            return callback(err);
        }

        // Only add the `isGlobalAdmin` and `isTenantAdmin` if the user's profile is requested by a global admin or the tenant admin
        if (ctx.user() && ctx.user().isAdmin(user.tenant.alias)) {
            user.isGlobalAdmin = user.isGlobalAdmin();
            user.isTenantAdmin = user.isTenantAdmin(user.tenant.alias);
        }

        // Keep track of how many decorators still need to return
        var numDecorators = _.keys(fullUserProfileDecorators).length;
        if (numDecorators === 0) {
            return callback(null, user);
        }

        // Hold all decorations for the user profile until we've collected them all
        var decorations = {};

        /*!
         * Complete one iteration of the decorators loop. Will invoke the method callback when all decorations have completed
         */
        var _finishDecorator = function() {
            numDecorators--;
            if (numDecorators === 0) {
                // Apply all the decorations to the user object
                user = _.extend(user, decorations);
                PrincipalsEmitter.emit(PrincipalsConstants.events.GET_USER_PROFILE, ctx, user);
                return callback(null, user);
            }
        };

        // Concurrently apply all decorators to the user object
        _.each(fullUserProfileDecorators, function(decorator, namespace) {
            if (user[namespace] !== undefined) {
                log().warn('Skipping full user profile decorator "%s" which overwrites an existing user profile value', namespace);
                return _finishDecorator();
            }

            decorator(ctx, clone(user), function(err, decoration) {
                if (err) {
                    log().warn({'err': err}, 'Skipping decorator because of an error in the decoration method');
                    return _finishDecorator();
                } else if (decoration === undefined) {
                    // If the decoration wasn't specified, do not apply it to the decorations. However null is a valid
                    // value
                    return _finishDecorator();
                }

                decorations[namespace] = decoration;
                return _finishDecorator();
            });
        });
    });
};

/**
 * Get the me feed for the current user, if anonymous returns 'anon': true
 * If logged in returns structured me feed object in the callback
 *
 *     {
 *         "profilePath": "/person/u:global:bert",
 *         "id": "u:global:bert",
 *         "displayName": "Bert Pareyn",
 *         "publicAlias": "Bert the Merciful"
 *         "visibility": "private",
 *         "isTenantAdmin": true,
 *         "isGlobalAdmin": false,
 *         "resourceType": "user"
 *         "locale": "en_GB"
 *     }
 *
 * If error returns error object
 *
 * @param  {Context}   ctx            Standard context object containing the current user and the current tenant
 * @param  {Function}  callback       Standard callback function
 * @param  {Object}    callback.err   An error that occurred, if any
 * @param  {Object}    callback.data  The me feed for the current user
 */
var getMe = module.exports.getMe = function(ctx, callback) {
    // Get the compact tenant object for the current tenant
    var tenant = ctx.tenant().compact();

    // Indicate whether the tenant is private or not
    tenant.isPrivate = TenantsUtil.isPrivate(tenant.alias);

    // Handle the anonymous user
    if (!ctx.user()) {
        var anonMe = {
            'anon': true,
            'tenant': tenant
        };

        var locale = ctx.locale();
        if (locale) {
            anonMe.locale = locale;
        }

        return callback(null, anonMe);
    }

    // If the user is authenticated we get their profile
    getUser(ctx, ctx.user().id, function(err, data) {
        if (err) {
            return callback(err);
        }

        // Overwrite the `tenant` value with our object that contains whether the tenant is private
        data.tenant = tenant;

        // If this user is being impostered, we add the information of the user that is doing the impostering
        if (ctx.imposter()) {
            data.imposter = ctx.imposter();
        }

        data.isGlobalAdmin = ctx.user().isGlobalAdmin();
        data.isTenantAdmin = ctx.user().isTenantAdmin(ctx.user().tenant.alias);
        data.locale = ctx.user().locale;

        // Determine if the current user needs to accept terms and conditions
        data.needsToAcceptTC = PrincipalsTermsAndConditionsAPI.needsToAcceptTermsAndConditions(ctx);

        // Generate a signature that can be used to authenticate to one's self for push notifications
        data.signature = Signature.createExpiringResourceSignature(ctx, ctx.user().id);

        // Return the name of the strategy that the user used to log into the system
        data.authenticationStrategy = ctx.authenticationStrategy();

        return callback(null, data);
    });
};

/**
 * Set a flag that indicates whether a user is a tenant admin.
 * The ctx user must be a tenant or global admin to be able to do this.
 *
 * @param  {Context}   ctx             Standard context object containing the current user and the current tenant
 * @param  {String}    userId          The id of the user to update the tenant administrator setting for
 * @param  {Boolean}   isAdmin         Whether or not the user should become a tenant administrator
 * @param  {Function}  callback        Standard callback function
 * @param  {Object}    callback.err    An error that occurred, if any
 */
var setTenantAdmin = module.exports.setTenantAdmin = function(ctx, userId, isAdmin, callback) {
    var user = AuthzUtil.getResourceFromId(userId);
    if (ctx.user() && ctx.user().isAdmin(user.tenantAlias)) {
        _setAdmin(ctx, 'admin:tenant', isAdmin, userId, callback);
    } else {
        return callback({'code': 401, 'msg': 'You do not have sufficient rights to make someone an admin'});
    }
};

/**
 * Set a flag that indicates whether a user is a global admin. The user in context must be a global
 * admin to be able to do this
 *
 * @param  {Context}   ctx              Standard context object containing the current user and the current tenant
 * @param  {String}    userId           The id of the user to update the global administrator setting for
 * @param  {Boolean}   isAdmin          Whether or not the user should become a global administrator
 * @param  {Function}  callback         Standard callback function
 * @param  {Object}    callback.err     An error that occurred, if any
 */
var setGlobalAdmin = module.exports.setGlobalAdmin = function(ctx, userId, isAdmin, callback) {
    if (ctx.user() && _.isFunction(ctx.user().isGlobalAdmin) && ctx.user().isGlobalAdmin()) {
        return _setAdmin(ctx, 'admin:global', isAdmin, userId, callback);
    } else {
        return callback({'code': 401, 'msg': 'You do not have sufficient rights to make someone an admin'});
    }
};

/**
 * Internal method that either promotes or demotes a user to or from being an admin. This method
 * will do all the necessary validation of the user in context and passed in parameters
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     adminType       One of `admin:global` or `admin:tenant`
 * @param  {Boolean}    isAdmin         Flag that indicates whether this user should be an admin or not
 * @param  {String}     userId          The id of the user whose admin status to set or unset
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 * @api private
 */
var _setAdmin = function(ctx, adminType, isAdmin, principalId, callback) {
    if (!PrincipalsUtil.isUser(principalId)) {
        return callback({'code': 400, 'msg': 'The provided principalId is not a user'});
    }

    // Double-check that this user exists
    getUser(ctx, principalId, function(err, user) {
        if (err) {
            return callback(err);
        }

        return PrincipalsDAO.setAdmin(adminType, isAdmin, principalId, callback);
    });
};

/**
 * Send an email token to a user
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {User}       user            The user to send the email token to
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var sendEmailToken = module.exports.sendEmailToken = function(ctx, user, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'userId': user.id}, 'Unable to send a user an email verification email');
        }
    };

    // Generate a token that will be sent to the user's email address
    var token = _generateEmailToken();

    // Store the token
    PrincipalsDAO.storeEmailToken(token, user.id, function(err) {
        if (err) {
            return callback(err);
        }

        // Send an email to the specified e-mail address
        var data = {
            'tenant': ctx.tenant(),
            'user': user,
            'baseUrl': TenantsUtil.getBaseUrl(ctx.tenant()),
            'skinVariables': require('oae-ui').getTenantSkinVariables(ctx.tenant().alias),
            'token': token
        };
        EmailAPI.sendEmail('oae-principals', 'verify', user, data, {'hash': token, 'ignoreVerification': true}, callback);
    });
};

/**
 * Resend an email token
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     userId          The id of the user for who to resend the email token
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var resendEmailToken = module.exports.resendEmailToken = function(ctx, userId, callback) {
    var validator = new Validator();
    validator.check(userId, {'code': 400, 'msg': 'A valid user id must be provided'}).isUserId();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to resend an email token'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure that you need to either be the user for which a token is being sent or a tenant admin
    var principalResource = AuthzUtil.getResourceFromId(userId);
    if (ctx.user().id !== userId && !ctx.user().isAdmin(principalResource.tenantAlias)) {
        return callback({'code': 401, 'msg': 'You are not authorized to resend an email token'});
    }

    // Get the user object
    PrincipalsDAO.getPrincipal(userId, function(err, user) {
        if (err) {
            return callback(err);
        }

        // Send the email token
        return sendEmailToken(ctx, user, callback);
    });
};

/**
 * Verify an email token
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     token           The email token to verify
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var verifyEmailToken = module.exports.verifyEmailToken = function(ctx, token, callback) {
    if (!token) {
        return callback({'code': 400, 'msg': 'Missing token'});
    }

    PrincipalsDAO.getUserViaEmailToken(token, function(err, user) {
        if (err) {
            return callback(err);
        }

        PrincipalsDAO.validateToken(token, user, callback);
    });
};

/**
 * Generate a simple email token
 *
 * @return {String}     A string containing random alpha-numerical characters
 * @api private
 */
var _generateEmailToken = function() {
    var alphabet = 'abcdefghiklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    var token = '';
    for (var i = 0; i < 32; i++) {
        token += alphabet[Math.floor(Math.random() * alphabet.length)];
    }
    return token;
};
