/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the 'License'); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an 'AS IS'
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');

var Cassandra = require('oae-util/lib/cassandra');
var Util = require('oae-util/lib/util');


describe('Utilities', function() {

    describe('Cassandra', function() {

        /**
         * Test that will validate that keyspaces can be created, checked and dropped
         */
        it('verify keyspaces', function(callback) {
            // Create a key space
            var keyspace = 'keyspacetest' + Math.floor(Math.random() * 100000000);
            Cassandra.createKeyspace(keyspace, function(err, created) {
                assert.ok(!err);
                assert.ok(created);

                // Check that the keyspace exists
                Cassandra.keyspaceExists(keyspace, function(err, exists) {
                    assert.ok(!err);
                    assert.ok(exists);

                    // Check that a non-existing keyspace doesn't exist
                    var nonExistingKeyspace = 'keyspacetest' + Math.floor(Math.random() * 100000000);
                    Cassandra.keyspaceExists(nonExistingKeyspace, function(err, exists) {
                        assert.ok(!err);
                        assert.ok(!exists);

                        // Drop the created keyspace
                        Cassandra.dropKeyspace(keyspace, function(err, dropped) {
                            assert.ok(!err);
                            assert.ok(dropped);

                            // Check that a non-existing keyspace can't be dropped
                            Cassandra.dropKeyspace(keyspace, function(err, dropped) {
                                assert.ok(err);
                                callback();
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that it is possible to create, check and drop column families.
         */
        it('verify column family', function(callback) {
            // Create a column family
            var name = 'cf' + Math.floor(Math.random() * 10000000);
            Cassandra.createColumnFamily(name, 'CREATE COLUMNFAMILY ' + name + ' (keyId text PRIMARY KEY)', function(err, created) {
                assert.ok(!err);
                assert.ok(created);

                 // Check if it exists.
                Cassandra.columnFamilyExists(name, function(err, exists) {
                    assert.ok(!err);
                    assert.ok(exists);

                    // Check if a non-existing CF exists
                    var nonExistingCF = 'cf' + Math.floor(Math.random() * 100000000);
                    Cassandra.keyspaceExists(nonExistingCF, function(err, exists) {
                        assert.ok(!err);
                        assert.ok(!exists);

                        // Drop it.
                        Cassandra.dropColumnFamily(name, function(err, dropped) {
                            assert.ok(!err);
                            assert.ok(dropped);

                            // Make sure it's gone.
                            Cassandra.columnFamilyExists(name, function(err, exists) {
                                assert.ok(!err);
                                assert.ok(!exists);

                                // Try to drop a non-existing CF
                                Cassandra.dropColumnFamily(nonExistingCF, function(err, dropped) {
                                    assert.ok(err);
                                    callback();
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that it is possible to create, check and drop multiple columnfamilies at once.
         */
        it('verify multiple column families', function(callback) {
            var name1 = 'cf' + Math.floor(Math.random() * 10000000);
            var name2 = 'cf' + Math.floor(Math.random() * 10000000);

            Cassandra.createColumnFamilies({
                name1: 'CREATE COLUMNFAMILY ' + name1 + ' (keyId text PRIMARY KEY)',
                name2: 'CREATE COLUMNFAMILY ' + name2 + ' (keyId text PRIMARY KEY)'
            }, function(err) {
                assert.ok(!err);
                // Check if it exists.
                Cassandra.columnFamilyExists(name1, function(err, exists) {
                    assert.ok(!err);
                    assert.ok(exists);
                    Cassandra.columnFamilyExists(name2, function(err, exists) {
                        assert.ok(!err);
                        assert.ok(exists);
                        // Remove them
                        Cassandra.dropColumnFamilies([name1, name2], function(err) {
                            assert.ok(!err);
                            // Check if they still exist
                            Cassandra.columnFamilyExists(name1, function(err, exists) {
                                assert.ok(!err);
                                assert.ok(!exists);
                                Cassandra.columnFamilyExists(name2, function(err, exists) {
                                    assert.ok(!err);
                                    assert.ok(!exists);
                                    callback();
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test the runQuery function, making sure that null and undefined values are handled appropriately
         */
        it('verify run query', function(callback) {
            // Create a CF first
            Cassandra.createColumnFamily('testQuery', 'CREATE COLUMNFAMILY testQuery (keyId text PRIMARY KEY)', function(err, created) {
                assert.ok(!err);
                assert.ok(created);
                // Check if the CF exists
                Cassandra.columnFamilyExists('testQuery', function(err, exists) {
                    assert.ok(!err);
                    assert.ok(exists);
                    // Try to run a simple insert
                    Cassandra.runQuery('INSERT INTO testQuery (keyId, c1, c2) VALUES (?, ?, ?) USING CONSISTENCY QUORUM', ['key1', 'value1', 'value2'], function (err) {
                        assert.ok(!err);
                        // Try to run an invalid insert
                        Cassandra.runQuery('INSERT INTO testQuery (keyId, c1, c2) VALUES (?, ?, ?) USING CONSISTENCY QUORUM', ['key2', 'value', null], function (err) {
                            assert.ok(err);
                            // Try to run a simple select
                            Cassandra.runQuery('SELECT * FROM testQuery USING CONSISTENCY QUORUM WHERE keyId = ?', ['key1'], function (err, rows) {
                                assert.ok(!err);
                                assert.equal(rows.length, 1);
                                assert.equal(rows[0].key, 'key1');
                                // Try to run an invalid select
                                Cassandra.runQuery('SELECT * FROM testQuery USING CONSISTENCY QUORUM WHERE keyId = ?', [null], function (err, rows) {
                                    assert.ok(err);
                                    callback();
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies iterateAll on empty CF invokes callback only once
         */
        it('verify iterateAll on empty column family', function(callback) {
            Cassandra.createColumnFamily('testIterateAllEmpty', 'CREATE COLUMNFAMILY testIterateAllEmpty (keyId text PRIMARY KEY, colOne text, colTwo text)', function(err, created) {
                assert.ok(!err);
                assert.ok(created);

                var numInvoked = 0;

                // Verify the callback is only invoked once, and when it does it is marked complete, without an error
                Cassandra.iterateAll(['colOne', 'colTwo'], 'testIterateAllEmpty', 'keyId', null, function(rows, done) {
                    assert.ok(!err, 'Did not expect an error');
                    assert.ok(!rows, 'Expected no rows to be specified');
                    assert.equal(++numInvoked, 1, 'Expected onEach to only be invoked once');
                    done();
                }, function(err) {
                    assert.ok(!err, JSON.stringify(err, null, 4));
                    callback();
                });
            });
        });

        /**
         * Test that verifies iterateAll will return an exception as an error if one is thrown by the onEach
         */
        it('verify iterateAll on exception breaks out of iteration', function(callback) {
            Cassandra.createColumnFamily('testIterateAllException', 'CREATE COLUMNFAMILY testIterateAllException (keyId text PRIMARY KEY, colOne text, colTwo text)', function(err, created) {
                assert.ok(!err);
                assert.ok(created);

                var invoked = false;
                var batch = [];
                batch.push(Cassandra.constructUpsertCQL('testIterateAllException', 'keyId', 'key1', {'colOne': 'one', 'colTwo': 'two'}));
                Cassandra.runBatchQuery(batch, 'QUORUM', function(err) {
                    assert.ok(!err);

                    Cassandra.iterateAll(null, 'testIterateAllException', 'keyId', null, function(rows, done) {
                        // Ensure we return only once, and then throw an error to ensure it gets caught
                        assert.ok(!invoked);
                        assert.ok(rows);

                        invoked = true;

                        throw {'message': 'I\'m an annoying error!'};
                    }, function(err) {
                        // Verify we got the error we threw from the onEach, and that we only invoked once
                        assert.ok(err);
                        assert.equal(err.code, 500);
                        assert.equal(err.msg, 'I\'m an annoying error!');
                        assert.ok(invoked);
                        callback();
                    });
                });
            });
        });

        /**
         * Test that verifies iterateAll with no column names or specified column names
         */
        it('verify iterateAll column names', function(callback) {
            Cassandra.createColumnFamily('testIterateAllAllColumns', 'CREATE COLUMNFAMILY testIterateAllAllColumns (keyId text PRIMARY KEY, colOne text, colTwo text)', function(err, created) {
                assert.ok(!err);
                assert.ok(created);

                var batch = [];
                batch.push(Cassandra.constructUpsertCQL('testIterateAllAllColumns', 'keyId', 'key1', {'colOne': 'one', 'colTwo': 'two'}));
                Cassandra.runBatchQuery(batch, 'QUORUM', function(err) {
                    assert.ok(!err);

                    var numInvoked = 0;

                    /*!
                     * Verifies that the onEach is invoked only once and that only one row is returned
                     */
                    var _onEach = function(rows, done) {
                        assert.strictEqual(++numInvoked, 1, 'Expected onEach to only be invoked once');
                        assert.ok(rows, 'Expected there to be rows provided to the onEach');
                        assert.equal(rows.length, 1, 'Expected there to be exactly one row');

                        // Ensure all columns have been fetched
                        assert.equal(rows[0].get('keyId').value, 'key1', 'Invalid value for keyId');
                        assert.equal(rows[0].get('colOne').value, 'one', 'Invalid value for colOne');
                        assert.equal(rows[0].get('colTwo').value, 'two', 'Invalid value for colTwo');

                        done();
                    };

                    // Verify the callback is only invoked once, and when it does it is marked complete, without an error
                    Cassandra.iterateAll(null, 'testIterateAllAllColumns', 'keyId', null, _onEach, function(err) {
                        assert.ok(!err, JSON.stringify(err, null, 4));

                        numInvoked = 0;

                        /*!
                         * Verifies that the onEach is invoked only once, that only one row is returned and it only contains
                         * the colOne column
                         */
                        var _onEach = function(rows, done) {
                            assert.strictEqual(++numInvoked, 1, 'Expected onEach to only be invoked once');
                            assert.ok(rows, 'Expected a rows object to be specified');
                            assert.equal(rows.length, 1, 'Expected there to be exactly one row');

                            // Verify only colOne is set
                            assert.ok(!rows[0].get('keyId'), 'Expected no keyId to be fetched');
                            assert.ok(!rows[0].get('colTwo'), 'expected no colTwo column to be fetched');
                            assert.equal(rows[0].get('colOne').value, 'one', 'Invalid value for colOne');

                            done();
                        };

                        // Iterate all again with just one column specified and verify only the one column returns
                        Cassandra.iterateAll(['colOne'], 'testIterateAllAllColumns', 'keyId', null, _onEach, function(err) {
                            assert.ok(!err, JSON.stringify(err, null, 4));
                            return callback();
                        });
                    });
                });
            });
        });

        
        /**
         * Test that verifies exclusive paging in iterateAll
         */
        it('verify iterateAll paging', function(callback) {
            Cassandra.createColumnFamily('testIterateAllPaging', 'CREATE COLUMNFAMILY testIterateAllPaging (keyId text PRIMARY KEY, colOne text, colTwo text)', function(err, created) {
                assert.ok(!err);
                assert.ok(created);

                // Create 10 rows to page through
                var batch = [];
                for (var i = 0; i < 10; i++) {
                    batch.push(Cassandra.constructUpsertCQL('testIterateAllPaging', 'keyId', 'key' + i, {'colOne': 'colOne' + i, 'colTwo': 'colTwo' + i}));
                }

                Cassandra.runBatchQuery(batch, 'QUORUM', function(err) {
                    assert.ok(!err);

                    var numInvoked = 0;
                    var allRows = {};

                    /*!
                     * Verifies that we receive exactly one row at a time, and aggregates them so we can inspect their
                     * data when finished.
                     */
                    var _onEach = function(rows, done) {
                        numInvoked++;
                        // Store the row so we can verify them all later
                        assert.equal(rows.length, 1, 'Expected to only get 1 row at a time');
                        allRows[rows[0].get('keyId').value] = rows[0];

                        done();
                    };

                    // Verify paging all 10 items by batches of size 1
                    Cassandra.iterateAll(null, 'testIterateAllPaging', 'keyId', {'batchSize': 1}, _onEach, function(err) {
                        assert.ok(!err, JSON.stringify(err, null, 4));
                        assert.equal(numInvoked, 10, 'Expected to have exactly 10 batches of data');

                        // Verify the contents of all the rows
                        assert.equal(_.keys(allRows).length, 10, 'Expected exactly 10 distinct rows');
                        for (var i = 0;  i < 10; i++) {
                            var key = 'key' + i;
                            assert.ok(allRows[key], 'Expected to get a row with key ' + key);
                            assert.equal(allRows[key].get('colOne').value, 'colOne' + i, 'Invalid colOne value');
                            assert.equal(allRows[key].get('colTwo').value, 'colTwo' + i, 'Invalid colTwo value');
                        }

                        // Verify paging of all 10 items by batches of size 5
                        numInvoked = 0;
                        allRows = {};

                        /*!
                         * Verifies that the onEach is invoked with 5 rows at a time, and aggregates them so we can
                         * inspect their data when finished.
                         */
                        var _onEach = function(rows, done) {
                            numInvoked++;
                            // Record the rows so we can verify their contents at the end
                            assert.equal(rows.length, 5);
                            for (var i = 0; i < 5; i++) {
                                allRows[rows[i].get('keyId').value] = rows[i];
                            }

                            done();
                        };

                        Cassandra.iterateAll(null, 'testIterateAllPaging', 'keyId', {'batchSize': 5}, _onEach, function(err) {
                            assert.ok(!err, JSON.stringify(err, null, 4));
                            assert.equal(numInvoked, 2, 'Expected the onEach to be invoked exactly 2 times');

                            // Verify the contents of all the rows
                            assert.equal(_.keys(allRows).length, 10);
                            for (var i = 0;  i < 10; i++) {
                                var key = 'key' + i;
                                assert.ok(allRows[key]);
                                assert.equal(allRows[key].get('colOne').value, 'colOne' + i);
                                assert.equal(allRows[key].get('colTwo').value, 'colTwo' + i);
                            }

                            // Verify paging of all 10 items by batches of size 7
                            numInvoked = 0;
                            allRows = {};

                            /*!
                             * Verifies that the onEach is called once with 7 rows, and then once with 3 rows, and aggregates
                             * them so we can inspect their data when finished.
                             */
                            var _onEach = function(rows, done) {
                                numInvoked++;
                                if (numInvoked === 1) {
                                    assert.ok(rows);

                                    // The first batch should contain exactly 7 rows. Record them to verify the data when done iterating.
                                    assert.equal(rows.length, 7);
                                    for (var i = 0; i < 7; i++) {
                                        allRows[rows[i].get('keyId').value] = rows[i];
                                    }
                                } else if (numInvoked === 2) {
                                    assert.ok(rows);

                                    // The second batch should contain exactly 3 rows. Record them to verify the data when done iterating.
                                    assert.equal(rows.length, 3);
                                    for (var ii = 0; ii < 3; ii++) {
                                        allRows[rows[ii].get('keyId').value] = rows[ii];
                                    }
                                }

                                done();
                            };

                            Cassandra.iterateAll(null, 'testIterateAllPaging', 'keyId', {'batchSize': 7}, _onEach, function(err) {
                                assert.ok(!err, JSON.stringify(err, null, 4));
                                assert.equal(numInvoked, 2, 'Expected the onEach callback to be invoked exactly twice');

                                // Verify the contents of all the rows
                                assert.equal(_.keys(allRows).length, 10);
                                for (var i = 0;  i < 10; i++) {
                                    var key = 'key' + i;
                                    assert.ok(allRows[key]);
                                    assert.equal(allRows[key].get('colOne').value, 'colOne' + i);
                                    assert.equal(allRows[key].get('colTwo').value, 'colTwo' + i);
                                }

                                // Finally complete
                                return callback();
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies the slug column functionality of row iteration
         */
        it('verifies iterateAll slug columns filter out invalid rows', function(callback) {
            Cassandra.createColumnFamily('testIterateAllSlugColumnName', 'CREATE COLUMNFAMILY testIterateAllSlugColumnName (keyId text PRIMARY KEY, colOne text, colTwo text)', function(err, created) {
                assert.ok(!err);
                assert.ok(created);

                var batch = [];
                batch.push(Cassandra.constructUpsertCQL('testIterateAllSlugColumnName', 'keyId', 'key1', {'colOne': 'one1', 'colTwo': 'two1'}));
                batch.push(Cassandra.constructUpsertCQL('testIterateAllSlugColumnName', 'keyId', 'key2', {'colOne': 'one2', 'colTwo': 'two2'}));
                Cassandra.runBatchQuery(batch, 'QUORUM', function(err) {
                    assert.ok(!err);

                    // Delete the first row
                    Cassandra.runQuery('DELETE FROM testIterateAllSlugColumnName WHERE keyId = ?', ['key1'], function(err) {
                        assert.ok(!err);

                        var numInvoked = 0;

                        /*!
                         * Verifies that we receive the deleted row from the iterateAll by asserting 2 rows (the only 2 rows created in the CF)
                         */
                        var _onEach = function(rows, done) {
                            numInvoked++;
                            assert.ok(rows, 'Expected a rows object to be specified');
                            assert.equal(rows.length, 2, 'Expected there to be exactly two rows');
                            done();
                        };

                        // First sanity check that we get the row when not specifying a slug column
                        Cassandra.iterateAll(null, 'testIterateAllSlugColumnName', 'keyId', {'batchSize': 2}, _onEach, function(err) {
                            assert.ok(!err, JSON.stringify(err, null, 4));
                            assert.equal(numInvoked, 1, 'Expected onEach to be invoked exactly once');

                            numInvoked = 0;

                            /*!
                             * Verifies that we do not receive the deleted row when iterating over with a slug column specified
                             */
                            var _onEach = function(rows, done) {
                                numInvoked++;
                                assert.ok(rows, 'Expected a rows object to be specified');
                                assert.equal(rows.length, 1, 'Expected there to be exactly one row');

                                // Should be all the values from the non-deleted row
                                assert.equal(rows[0].get('keyId').value, 'key2', 'Invalid value for keyId');
                                assert.equal(rows[0].get('colOne').value, 'one2', 'Invalid value for colOne');
                                assert.equal(rows[0].get('colTwo').value, 'two2', 'Invalid value for colTwo');

                                done();
                            };

                            // Verify that when the slug column is specified, it filters out the deleted row
                            Cassandra.iterateAll(null, 'testIterateAllSlugColumnName', 'keyId', {'batchSize': 2, 'slugColumnName': 'colOne'}, _onEach, function(err) {
                                assert.ok(!err, JSON.stringify(err, null, 4));
                                assert.equal(numInvoked, 1, 'Expected to invoked the onEach callback exactly once');

                                numInvoked = 0;

                                /*!
                                 * Verifies that the slug column (`colOne`) is not part of the row results
                                 */
                                var _onEach = function(rows, done) {
                                    numInvoked++;
                                    assert.ok(rows, 'Expected a rows object to be specified');
                                    assert.equal(rows.length, 1, 'Expected there to be exactly one row');

                                    // Should be all the values from the non-deleted row
                                    assert.equal(rows[0].get('keyId').value, 'key2', 'Invalid value for keyId');
                                    assert.ok(!rows[0].get('colOne').value, 'Value for colOne should not have been returned');
                                    assert.equal(rows[0].get('colTwo').value, 'two2', 'Invalid value for colTwo');

                                    done();
                                };

                                // Verify that when the slug column is not part of the fetched columns list, it is not returned as a value in the result
                                Cassandra.iterateAll(['keyId', 'colTwo'], 'testIterateAllSlugColumnName', 'keyId', {'batchSize': 2, 'slugColumnName': 'colOne'}, _onEach, function(err, rows, complete) {
                                    assert.ok(!err, JSON.stringify(err, null, 4));
                                    assert.equal(numInvoked, 1, 'Expected to invoke the onEach callback exactly once');
                                    return callback();
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test the runBatchQuery function, making sure that changes from both queries are persisted
         */
        it('verify run batch query', function(callback) {
            // Create a CF first
            Cassandra.createColumnFamily('testBatchQuery', 'CREATE COLUMNFAMILY testBatchQuery (keyId text PRIMARY KEY)', function(err, created) {
                assert.ok(!err);
                assert.ok(created);
                // Check if the CF exists
                Cassandra.columnFamilyExists('testBatchQuery', function(err, exists) {
                    assert.ok(!err);
                    assert.ok(exists);

                    // Run a batched query.
                    var queries = [
                        {'query': 'INSERT INTO testBatchQuery (keyId, c1, c2) VALUES (?, ?, ?)', 'parameters': ['key1', 'value1', 'value2']},
                        {'query': 'INSERT INTO testBatchQuery (keyId, c1, c2) VALUES (?, ?, ?)', 'parameters': ['key2', 'value3', 'value4']}
                    ];
                    Cassandra.runBatchQuery(queries, 'QUORUM', function(err) {
                        assert.ok(!err);

                        // Retrieve them.
                        Cassandra.runQuery('SELECT * FROM testBatchQuery USING CONSISTENCY QUORUM WHERE keyId IN (?)', [ ['key1', 'key2'] ], function (err, rows) {
                            assert.ok(!err);
                            assert.ok(rows.length, 2);
                            assert.equal(rows[0].count, 3);
                            assert.equal(rows[0].get('c1').value, 'value1');
                            assert.equal(rows[0].get('c2').value, 'value2');
                            assert.equal(rows[1].count, 3);
                            assert.equal(rows[1].get('c1').value, 'value3');
                            assert.equal(rows[1].get('c2').value, 'value4');

                            // Try running it without any queries.
                            Cassandra.runBatchQuery([], 'QUORUM', function(err) {
                                assert.ok(!err);
                                callback();
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test casting to a Boolean
         */
        it('verify casting to a Boolean', function(callback) {
            Cassandra.createColumnFamily('testBooleans', 'CREATE COLUMNFAMILY testBooleans (keyId text PRIMARY KEY)', function(err, created) {
                assert.ok(!err);
                assert.ok(created);
                Cassandra.runQuery('INSERT INTO testBooleans (keyId, testbool, testnumbool, teststring) VALUES (?, ?, ?, ?) USING CONSISTENCY QUORUM', ['testkey', 'true', '0', 'notaboolean'], function (err) {
                    assert.ok(!err);
                    Cassandra.runQuery('SELECT testbool, testnumbool, teststring FROM testBooleans USING CONSISTENCY QUORUM WHERE keyId = ?', ['testkey'], function (err, rows) {
                        assert.ok(!err);
                        assert.equal(typeof Util.castToBoolean(rows[0][0].value), 'boolean');
                        assert.equal(typeof Util.castToBoolean(rows[0][1].value), 'boolean');
                        assert.equal(typeof Util.castToBoolean(rows[0][2].value), 'string');
                        callback();
                    });
                });
            });
        });

        /**
         * Test whether the constructUpsertCQL works as expected, making sure that invalid parameters
         * are handled appropriately
         */
        it('verify construct upsert', function(callback) {
            // Test an invalid call with no provided cf
            var query1 = Cassandra.constructUpsertCQL(null, 'testId', 'testValue', {'key1': 'value1'});
            assert.ok(!query1);
            // Test an invalid call with no provided values
            var query2 = Cassandra.constructUpsertCQL('testCF', 'testId', 'testValue', {});
            assert.ok(!query2);
            // Test a valid update with one key-value pair
            var query3 = Cassandra.constructUpsertCQL('testCF', 'testId', 'testValue', {'key1': 'value1'});
            assert.ok(query3);
            assert.equal(query3.query, 'UPDATE testCF SET ? = ? WHERE testId = ?');
            assert.equal(query3.parameters[0], 'key1');
            assert.equal(query3.parameters[1], 'value1');
            assert.equal(query3.parameters[2], 'testValue');
            // Test a valid update with one key-value pair and consistency
            var query4 = Cassandra.constructUpsertCQL('testCF', 'testId', 'testValue', {'key1': 'value1'}, 'QUORUM');
            assert.ok(query4);
            assert.equal(query4.query, 'UPDATE testCF USING CONSISTENCY QUORUM SET ? = ? WHERE testId = ?');
            assert.equal(query4.parameters[0], 'key1');
            assert.equal(query4.parameters[1], 'value1');
            assert.equal(query4.parameters[2], 'testValue');
            // Test a valid update with multiple key-value pairs
            var query5 = Cassandra.constructUpsertCQL('testCF', 'testId', 'testValue', {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'});
            assert.ok(query5);
            assert.equal(query5.query, 'UPDATE testCF SET ? = ?, ? = ?, ? = ? WHERE testId = ?');
            assert.equal(query5.parameters[0], 'key1');
            assert.equal(query5.parameters[1], 'value1');
            assert.equal(query5.parameters[2], 'key2');
            assert.equal(query5.parameters[3], 'value2');
            assert.equal(query5.parameters[4], 'key3');
            assert.equal(query5.parameters[5], 'value3');
            assert.equal(query5.parameters[6], 'testValue');
            // Test a valid update with multiple key-value pairs and consistency
            var query6 = Cassandra.constructUpsertCQL('testCF', 'testId', 'testValue', {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}, 'QUORUM');
            assert.ok(query6);
            assert.equal(query6.query, 'UPDATE testCF USING CONSISTENCY QUORUM SET ? = ?, ? = ?, ? = ? WHERE testId = ?');
            assert.equal(query6.parameters[0], 'key1');
            assert.equal(query6.parameters[1], 'value1');
            assert.equal(query6.parameters[2], 'key2');
            assert.equal(query6.parameters[3], 'value2');
            assert.equal(query6.parameters[4], 'key3');
            assert.equal(query6.parameters[5], 'value3');
            assert.equal(query6.parameters[6], 'testValue');

            // Verify TTL is added to the query with proper syntax
            var query7 = Cassandra.constructUpsertCQL('testCF', 'testId', 'testValue', {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}, 'QUORUM', 500);
            assert.ok(query7);
            assert.equal(query7.query, 'UPDATE testCF USING CONSISTENCY QUORUM AND TTL 500 SET ? = ?, ? = ?, ? = ? WHERE testId = ?');
            assert.equal(query7.parameters[0], 'key1');
            assert.equal(query7.parameters[1], 'value1');
            assert.equal(query7.parameters[2], 'key2');
            assert.equal(query7.parameters[3], 'value2');
            assert.equal(query7.parameters[4], 'key3');
            assert.equal(query7.parameters[5], 'value3');
            assert.equal(query7.parameters[6], 'testValue');

            // Verify a JSON object and JSON array are stringified
            var query8 = Cassandra.constructUpsertCQL('testCF', 'testId', 'testValue', {'key1': {'anobject': 'a value'}, 'key2': ['index0', 'index1'], 'key3': 'value3'}, 'QUORUM', 500);
            assert.ok(query8);
            assert.equal(query8.query, 'UPDATE testCF USING CONSISTENCY QUORUM AND TTL 500 SET ? = ?, ? = ?, ? = ? WHERE testId = ?');
            assert.equal(query8.parameters[0], 'key1');
            assert.equal(JSON.parse(query8.parameters[1])['anobject'], 'a value');
            assert.equal(query8.parameters[2], 'key2');
            assert.equal(JSON.parse(query8.parameters[3])[0], 'index0');
            assert.equal(JSON.parse(query8.parameters[3])[1], 'index1');
            assert.equal(query8.parameters[4], 'key3');
            assert.equal(query8.parameters[5], 'value3');
            assert.equal(query8.parameters[6], 'testValue');

            callback();
        });

        /**
         * Test that verifies the functionality of `start` and `end` in runPagedColumnQuery both forward and
         * reversed.
         */
        it('verify paged column query start and end', function(callback) {

            // Set up column family and data used for paging
            Cassandra.createColumnFamily('VerifyPagedColumnQueryStartAndEnd', 'CREATE COLUMNFAMILY VerifyPagedColumnQueryStartAndEnd (keyId text PRIMARY KEY)', function(err, created) {
                assert.ok(!err);

                // Need to at least have values beyond 'k' to avoid we overlook 'keyId'
                var query = Cassandra.constructUpsertCQL('VerifyPagedColumnQueryStartAndEnd', 'keyId', 'key', {'a': 1, 'b': 1, 'c': 1, 'd': 1,
                    'e': 1, 'f': 1, 'g': 1, 'h': 1, 'i': 1, 'j': 1, 'k': 1, 'l': 1, 'm': 1});

                Cassandra.runQuery(query.query, query.parameters, function(err) {
                    assert.ok(!err);

                    // Verify inclusive end works with unbounded start (forward)
                    Cassandra.runPagedColumnQuery('VerifyPagedColumnQueryStartAndEnd', 'keyId', 'key', null, 8, {'end': 'a'}, function(err, row, startMatched) {
                        assert.ok(!err);
                        assert.ok(row);
                        assert.strictEqual(startMatched, false);

                        assert.equal(row.count, 1);
                        assert.equal(row[0].name, 'a');
                        assert.ok(!row[1]);

                        // Verify start === end (forward)
                        Cassandra.runPagedColumnQuery('VerifyPagedColumnQueryStartAndEnd', 'keyId', 'key', 'a', 8, {'end': 'a'}, function(err, row, startMatched) {
                            assert.ok(!err);
                            assert.ok(row);
                            assert.strictEqual(startMatched, true);

                            assert.equal(row.count, 0);
                            assert.ok(!row[0]);

                            // Verify inclusive end works with bounded start, one result (forward)
                            Cassandra.runPagedColumnQuery('VerifyPagedColumnQueryStartAndEnd', 'keyId', 'key', 'a', 8, {'end': 'b'}, function(err, row, startMatched) {
                                assert.ok(!err);
                                assert.ok(row);
                                assert.strictEqual(startMatched, true);

                                assert.equal(row.count, 1);
                                assert.equal(row[0].name, 'b');
                                assert.ok(!row[1]);

                                // Verify inclusive end works with bounded start, multiple results full page (forward)
                                Cassandra.runPagedColumnQuery('VerifyPagedColumnQueryStartAndEnd', 'keyId', 'key', null, 8, {'end': 'j'}, function(err, row, startMatched) {
                                    assert.ok(!err);
                                    assert.ok(row);
                                    assert.strictEqual(startMatched, false);

                                    assert.equal(row.count, 8);
                                    assert.equal(row[0].name, 'a');
                                    assert.equal(row[1].name, 'b');
                                    assert.equal(row[2].name, 'c');
                                    assert.equal(row[3].name, 'd');
                                    assert.equal(row[4].name, 'e');
                                    assert.equal(row[5].name, 'f');
                                    assert.equal(row[6].name, 'g');
                                    assert.equal(row[7].name, 'h');
                                    assert.ok(!row[8]);

                                    // Verify inclusive end works with bounded start, multple results partial page (forward)
                                    Cassandra.runPagedColumnQuery('VerifyPagedColumnQueryStartAndEnd', 'keyId', 'key', 'g', 8, {'end': 'j'}, function(err, row, startMatched) {
                                        assert.ok(!err);
                                        assert.ok(row);
                                        assert.strictEqual(startMatched, true);

                                        assert.equal(row.count, 3);
                                        assert.equal(row[0].name, 'h');
                                        assert.equal(row[1].name, 'i');
                                        assert.equal(row[2].name, 'j');
                                        assert.ok(!row[3]);


                                        // Verify inclusive end works with unbounded start (reversed)
                                        Cassandra.runPagedColumnQuery('VerifyPagedColumnQueryStartAndEnd', 'keyId', 'key', null, 8, {'reversed': true, 'end': 'm'}, function(err, row, startMatched) {
                                            assert.ok(!err);
                                            assert.ok(row);
                                            assert.strictEqual(startMatched, false);

                                            assert.equal(row.count, 1);
                                            assert.equal(row[0].name, 'm');
                                            assert.ok(!row[1]);

                                            // Verify start === end (reversed)
                                            Cassandra.runPagedColumnQuery('VerifyPagedColumnQueryStartAndEnd', 'keyId', 'key', 'm', 8, {'reversed': true, 'end': 'm'}, function(err, row, startMatched) {
                                                assert.ok(!err);
                                                assert.ok(row);
                                                assert.strictEqual(startMatched, true);

                                                assert.equal(row.count, 0);
                                                assert.ok(!row[0]);

                                                // Verify inclusive end works with bounded start, one result (reversed)
                                                Cassandra.runPagedColumnQuery('VerifyPagedColumnQueryStartAndEnd', 'keyId', 'key', 'm', 8, {'reversed': true, 'end': 'l'}, function(err, row, startMatched) {
                                                    assert.ok(!err);
                                                    assert.ok(row);
                                                    assert.strictEqual(startMatched, true);

                                                    assert.equal(row.count, 1);
                                                    assert.equal(row[0].name, 'l');
                                                    assert.ok(!row[1]);

                                                    // Verify inclusive end works with bounded start, multiple results full page (forward)
                                                    Cassandra.runPagedColumnQuery('VerifyPagedColumnQueryStartAndEnd', 'keyId', 'key', null, 8, {'reversed': true, 'end': 'c'}, function(err, row, startMatched) {
                                                        assert.ok(!err);
                                                        assert.ok(row);
                                                        assert.strictEqual(startMatched, false);

                                                        assert.equal(row.count, 8);
                                                        assert.equal(row[0].name, 'm');
                                                        assert.equal(row[1].name, 'l');
                                                        assert.equal(row[2].name, 'k');
                                                        assert.equal(row[3].name, 'j');
                                                        assert.equal(row[4].name, 'i');
                                                        assert.equal(row[5].name, 'h');
                                                        assert.equal(row[6].name, 'g');
                                                        assert.equal(row[7].name, 'f');
                                                        assert.ok(!row[8]);

                                                        // Verify inclusive end works with bounded start, multple results partial page (forward)
                                                        Cassandra.runPagedColumnQuery('VerifyPagedColumnQueryStartAndEnd', 'keyId', 'key', 'f', 8, {'reversed': true, 'end': 'c'}, function(err, row, startMatched) {
                                                            assert.ok(!err);
                                                            assert.ok(row);
                                                            assert.strictEqual(startMatched, true);

                                                            assert.equal(row.count, 3);
                                                            assert.equal(row[0].name, 'e');
                                                            assert.equal(row[1].name, 'd');
                                                            assert.equal(row[2].name, 'c');
                                                            assert.ok(!row[3]);

                                                            callback();
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies paging with runPagedColumnQuery works properly both forward and reversed
         */
        it('verify paged column query paging forward and reverse', function(callback) {

            // Set up a column family and data for this test
            Cassandra.createColumnFamily('VerifyPagedColumnQueryPaging', 'CREATE COLUMNFAMILY VerifyPagedColumnQueryPaging (keyId text PRIMARY KEY)', function(err, created) {
                assert.ok(!err);

                // Need to at least have values beyond 'k' to avoid we overlook 'keyId'
                var query = Cassandra.constructUpsertCQL('VerifyPagedColumnQueryPaging', 'keyId', 'key', {'a': 1, 'b': 1, 'c': 1, 'd': 1,
                    'e': 1, 'f': 1, 'g': 1, 'h': 1, 'i': 1, 'j': 1, 'k': 1, 'l': 1, 'm': 1});

                Cassandra.runQuery(query.query, query.parameters, function(err) {
                    assert.ok(!err);
                
                    // Page by 8
                    Cassandra.runPagedColumnQuery('VerifyPagedColumnQueryPaging', 'keyId', 'key', null, 8, null, function(err, row, startMatched) {
                        assert.ok(!err);
                        assert.ok(row);
                        assert.strictEqual(startMatched, false);

                        assert.equal(row.count, 8);
                        assert.equal(row[0].name, 'a');
                        assert.equal(row[1].name, 'b');
                        assert.equal(row[2].name, 'c');
                        assert.equal(row[3].name, 'd');
                        assert.equal(row[4].name, 'e');
                        assert.equal(row[5].name, 'f');
                        assert.equal(row[6].name, 'g');
                        assert.equal(row[7].name, 'h');
                        assert.ok(!row[8]);

                        // Start from 'h'
                        Cassandra.runPagedColumnQuery('VerifyPagedColumnQueryPaging', 'keyId', 'key', 'h', 8, null, function(err, row, startMatched) {
                            assert.ok(!err);
                            assert.ok(row);
                            assert.strictEqual(startMatched, true);

                            assert.equal(row.count, 5);
                            assert.equal(row[0].name, 'i');
                            assert.equal(row[1].name, 'j');
                            assert.equal(row[2].name, 'k');
                            assert.equal(row[3].name, 'l');
                            assert.equal(row[4].name, 'm');
                            assert.ok(!row[5]);

                            // Start from 'm'
                            Cassandra.runPagedColumnQuery('VerifyPagedColumnQueryPaging', 'keyId', 'key', 'm', 8, null, function(err, row, startMatched) {
                                assert.ok(!err);
                                assert.ok(row);
                                assert.strictEqual(startMatched, true);

                                assert.strictEqual(row.count, 0);
                                assert.ok(!row[0]);

                                // Perform the equivalent tests in reverse
                                Cassandra.runPagedColumnQuery('VerifyPagedColumnQueryPaging', 'keyId', 'key', null, 8, {'reversed': true}, function(err, row, startMatched) {
                                    assert.ok(!err);
                                    assert.ok(row);
                                    assert.strictEqual(startMatched, false);

                                    assert.equal(row.count, 8);
                                    assert.equal(row[0].name, 'm');
                                    assert.equal(row[1].name, 'l');
                                    assert.equal(row[2].name, 'k');
                                    assert.equal(row[3].name, 'j');
                                    assert.equal(row[4].name, 'i');
                                    assert.equal(row[5].name, 'h');
                                    assert.equal(row[6].name, 'g');
                                    assert.equal(row[7].name, 'f');
                                    assert.ok(!row[8]);

                                    // Start from 'f'
                                    Cassandra.runPagedColumnQuery('VerifyPagedColumnQueryPaging', 'keyId', 'key', 'f', 8, {'reversed': true}, function(err, row, startMatched) {
                                        assert.ok(!err);
                                        assert.ok(row);
                                        assert.strictEqual(startMatched, true);

                                        assert.equal(row.count, 5);
                                        assert.equal(row[0].name, 'e');
                                        assert.equal(row[1].name, 'd');
                                        assert.equal(row[2].name, 'c');
                                        assert.equal(row[3].name, 'b');
                                        assert.equal(row[4].name, 'a');
                                        assert.ok(!row[5]);

                                        // Start from 'a'
                                        Cassandra.runPagedColumnQuery('VerifyPagedColumnQueryPaging', 'keyId', 'key', 'a', 8, {'reversed': true}, function(err, row, startMatched) {
                                            assert.ok(!err);
                                            assert.ok(row);
                                            assert.strictEqual(startMatched, true);

                                            assert.strictEqual(row.count, 0);
                                            assert.ok(!row[0]);

                                            callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });
});
