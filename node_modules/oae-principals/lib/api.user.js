/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var time = require('time');
var sanitize = require('validator').sanitize;
var time = require('time');

var Resource = require('oae-authz/lib/model').Resource;
var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var Validator = require('oae-util/lib/validator').Validator;

var PrincipalsAPI = require('./api');
var PrincipalsModel = require('./model');
var PrincipalsUtil = require('./util');


/**
 * Creates a new user under this tenant.
 *
 * @param  {Context}       ctx                     The current context
 * @param  {String}        username                The username this user can login with.
 * @param  {String}        password                The password for this user.
 * @param  {String}        visibility              This user his visibility setting. (One of VISIBILITY_OPTIONS)
 * @param  {String}        locale                  The user his locale
 * @param  {String}        timezone                The user his timezone
 * @param  {String}        firstName               This user his first name.
 * @param  {String}        lastName                This user his last name,
 * @param  {String}        displayName             A display name, if this is left undefined the first and last name will be concatenated.
 * @param  {Function}      callback                Callback method.
 * @param  {Object}        callback.err            Error object if something goes wrong.
 * @param  {User}          callback.createdUser    A User object representing the created user
 */
module.exports.createUser = function(ctx, username, password, visibility, locale, timezone, firstName, lastName, displayName, callback) {
    callback = callback || function() {};
    locale = locale || 'en_GB';
    timezone = timezone || time.currentTimezone;
    visibility = visibility || PrincipalsModel.VISIBILITY_OPTIONS.PUBLIC;

    var validator = new Validator();
    validator.check(username, {'code': 400, 'msg': 'A user name must be provided'}).notEmpty();
    validator.check(password, {'code': 400, 'msg': 'A password must be provided'}).notEmpty();
    validator.check(username, {'code': 400, 'msg': 'A user name can\'t contain a colon.'}).notContains(':');
    validator.check(username, {'code': 400, 'msg': 'A user name has an upper limit of 250 characters.'}).max(250);
    validator.check(password, {'code': 400, 'msg': 'Your password is too short (this is the only password requirement.)'}).len(6);
    validator.check(displayName, {'code': 400, 'msg': 'A display name must be provided'}).notEmpty();
    validator.check(visibility, {'code': 400, 'msg': 'The specified visibility setting is unknown.'}).isIn(_.values(PrincipalsModel.VISIBILITY_OPTIONS));
    validator.check(timezone, {'code': 400, 'msg': 'The specified timezone is invalid'}).isValidTimeZone();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    var cleanUserName = PrincipalsUtil.cleanName(username);

    // hash the password and store everything in the DB.
    var id = AuthzUtil.toId('u', ctx.tenant().alias, cleanUserName);
    module.exports.getUser(ctx, id, function(err, user) {
        if (!err && user) {
            return callback({'code': 400, 'msg': 'A user with this user name already exists.'});
        }

        displayName = displayName || firstName + " " + lastName;
        // Hash the password
        var hash = PrincipalsUtil.hashPassword(password);
        // Create the user
        Cassandra.runQuery('INSERT INTO Principals (principalId, tenant, visibility, locale, timezone, username, password, firstName, lastName, displayName) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?) USING CONSISTENCY QUORUM', 
                            [id, ctx.tenant().alias, visibility, locale, timezone, username, hash, firstName, lastName, displayName], function (err) {
            if (err) {
                return callback(err);
            } 
            var createdUser = new PrincipalsModel.User(ctx.tenant().alias, id, username, visibility, locale, timezone, firstName, lastName, displayName);
            callback(false, createdUser);
        });
    });
};

/**
 * Update a user
 *
 * @param  {Context}        ctx             The current context.
 * @param  {String}         userId          The userId of the user you wish to update.
 * @param  {Object}         profileFields   Object that represent the profile fields that should be updated. Possible keys are visibility, firstName, lastName, displayName, locale and timezone
 * @param  {Function}       callback        Callback method takes argument `err`.
 * @param  {Object}         callback.err    Error object if something goes wrong.
 */
module.exports.updateUser = function(ctx, userId, profileFields, callback) {
    callback = callback || function() {};
    profileFields = profileFields || {};
    
    // Parameter validation
    var validator = new Validator();
    validator.check(userId, {'code': 400, 'msg': 'A user id must be provided'}).notEmpty();
    // Check that there is at least one updated profile field.
    validator.check(_.keys(profileFields).length, {'code': 400, 'msg': 'At least one basic profile field should be specified.'}).min(1);
    // In case a new visibility has been passed in, we check for its validity
    if (profileFields['visibility']) {
        validator.check(profileFields['visibility'], {'code': 400, 'msg': 'An invalid visibility option has been passed on'}).isIn(_.values(PrincipalsModel.VISIBILITY_OPTIONS));
    }
    if (profileFields['timezone']) {
        validator.check(profileFields['timezone'], {'code': 400, 'msg': 'The specified timezone is invalid'}).isValidTimeZone();
    }
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a user'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    
    // Only update existing users.
    module.exports.getUser(ctx, userId, function(err, user) {
        if (err) {
            return callback(err);
        }

        // Only the current user or an admin can update a user.
        var principalResource = AuthzUtil.getResourceFromId(userId);
        if (ctx.user().id === userId || ctx.user().isAdmin(principalResource.tenantId)) {
            var q = Cassandra.constructUpsertCQL('Principals', 'principalId', userId, profileFields, 'QUORUM');
            if (!q) {
                return callback({'code': 500, 'msg': 'Unable to store profile fields'});
            }
            Cassandra.runQuery(q.query, q.parameters, callback);
        } else {
            callback({'code': 401, 'msg': 'You cannot update this user his profile.'});
        }
    });
};

/**
 * Get the user within a tenant (determined from the ctx)
 *
 * @param  {Context}    ctx             The current context
 * @param  {String}     username        The username to look on
 * @param  {Function}   callback        Callback method takes `err` and `user`
 * @param  {Object}     callback.err    Error object if something goes wrong.
 * @param  {User}       callback.user   The user object.
 */
module.exports.getTenantUser = function(ctx, username, callback) {
    username = PrincipalsUtil.cleanName(username);
    var userId = AuthzUtil.toId('u', ctx.tenant().alias, username);
    module.exports.getUser(ctx, userId, callback);
};

/**
 * Get a user from the DB
 *
 * @param  {Context}   ctx             The current context
 * @param  {String}    userId          The userId for the user you wish to retrieve.
 * @param  {Function}  callback        Callback method takes arguments `err` and `user`.
 * @param  {Object}    callback.err    Error object if something goes wrong.
 * @param  {User}      callback.user   The user objct.
 */
module.exports.getUser = function(ctx, userId, callback) {
    if (!userId || !PrincipalsUtil.isUser(userId)) {
        return callback({'code': 400, 'msg': 'The provided userId is not a valid user identifier.'});
    }

    PrincipalsUtil.getPrincipal(ctx, userId, callback);
};

/**
 * Gets the basic profile for a user.
 * The user's visibility setting determines what the profile hash will contain.
 *
 *     {
 *       'profilePath': '/person/simong',
 *       'userId': 'u:cam:simong',
 *       'isFollowing': true,
 *       'accountPermissions': 'public',
 *       'proﬁle': {
 *           'ﬁrstName': 'Simon',
 *           'lastName': 'Gaeremynck',
 *           'displayName': 'Simon "simong" Gaeremynck'
 *           'picture': 'pathToCroppedProﬁlePicture'
 *       }
 *     };
 *
 * @param  {Context}  ctx           The current context
 * @param  {String}   userId        The id of the user for which the profile should be retrieved.
 * @param  {Object}   callback.err  Error object if something goes wrong.
 * @param  {Object}   callback.user The user.
 */
module.exports.getBasicProfile = function(ctx, userId, callback) {
    // Anonymous is a bit of a special case.
    module.exports.getUser(ctx, userId, function(err, user) {
        if (err) {
            return callback(err);
        }
        var data = {
            'profilePath': '/person/' + userId,
            'userId': user.id,
            'visibility': user.visibility,
            'profile': {
                'firstName': user.firstName,
                'lastName': user.lastName,
                'displayName': user.displayName
            }
        };

        var keys = _.keys(user.extra);
        for (var i = 0; i < keys.length; i++) {
            data.profile[keys[i]] = user.extra[keys[i]];
        }

        callback(null, data);
    });
};

/**
 * Gets the me feed for the current user, if anonymous returns 'anon': true
 * If logged in returns structured me feed object in the callback
 *
 *     {
 *         "profilePath": "/person/u:global:bert",
 *         "userId": "u:global:bert",
 *         "visibility": "private",
 *         "isTenantAdmin": true,
 *         "isGlobalAdmin": false,
 *         "profile": {
 *             "firstName": "Bert",
 *             "lastName": "Pareyn",
 *             "displayName": "Bert Pareyn"
 *         },
 *         "locale": {
 *             "locale": "en_GB",
 *             "timezone": {
 *                 "name": "Europe/London",
 *                 "offset": 1
 *             }
 *         }
 *     }
 *
 * If error returns error object
 *
 * @param  {Context}   ctx            The current context
 * @param  {String}    user           The user the me feed is for
 * @param  {Function}  callback       Callback method takes arguments `err` and `data`.
 * @param  {Object}    callback.err   Error object if something goes wrong.
 * @param  {Object}    callback.data  The me feed data for the user.
 */
module.exports.getMe = function(ctx, user, callback) {
    if (!ctx.user()) {
        return callback({'code': 200,'msg': {'anon': true}});
    }

    PrincipalsAPI.getBasicProfile(ctx, user.id, function(err, data) {
        if (err) {
            return callback(err);
        }

        // calculate timezone offset in hours.
        var now = new time.Date();
        now.setTimezone(ctx.user().timezone);
        var offset = -1 * now.getTimezoneOffset() / 60;

        data.isTenantAdmin = ctx.user().isTenantAdmin(ctx.user().tenant);
        data.isGlobalAdmin = ctx.user().isGlobalAdmin();

        data.locale = {
            'locale': ctx.user().locale,
            'timezone': {
                'name': ctx.user().timezone,
                'offset': offset
            }
        };

        callback(null, data);
    });
};

/**
 * Checks if a password matches a username within a tenant.
 *
 * @param  {Object}    tenant          The current tenant
 * @param  {String}    username        The username that a user uses to login. (NOT the id.)
 * @param  {String}    password        The plain-text password.
 * @param  {Function}  callback        Callback method takes arguments `err` and `user`.
 * @param  {Object}    callback.err    Error object.
 * @param  {Object}    callback.user   An object that has a key 'id' that holds the full user id. This object will be null if the user was not found or the password didn't match.
 */
module.exports.checkPassword = function(tenant, username, password, callback) {
    var userId = AuthzUtil.toId('u', tenant.alias, username);
    checkPasswordForUserId(userId, password, callback);
};

/**
 * Changes the password of a user.
 *
 * @param  {Context}  ctx         The current context.
 * @param  {String}   userId      The user id of the user whose password that needs to be changed.
 * @param  {String}   oldPassword The old password that can be used to authenticate this change request.
 * @param  {String}   newPassword The new password.
 * @param  {Function} callback    [description]
 */
module.exports.changePassword = function(ctx, userId, oldPassword, newPassword, callback) {

    var changePassword = function() {
        // Hash and store it.
        var hash = PrincipalsUtil.hashPassword(newPassword);
        Cassandra.runQuery('UPDATE Principals USING CONSISTENCY QUORUM SET password = ? WHERE principalId = ?', [hash, userId], function(err, rows) {
            if (err) {
                return callback(err, false);
            }

            callback(null, true);
        });
    };

    // Global admins can change passwords.
    var principalResource = AuthzUtil.getResourceFromId(userId);
    if (ctx.user().isAdmin(principalResource.tenantId)) {
        return changePassword();
    }

    // Otherwise the password must match.
    checkPasswordForUserId(userId, oldPassword, function(err, user) {
        if (!err && user) {
            return changePassword();
        }

        // By this point this user shouldn't be allowed to do anything.
        return callback({'code': 401, 'msg': 'You\'re not authorized to change this user\'s password.'}, false);
    });
};

/**
 * Checks the password for a specified user id.
 *
 * @param  {String}    userId      The id of the user whose password should be checked.
 * @param  {String}    password    The password that can be used to compare with the one in the DB.
 * @param  {Function}  callback    Callback method takes arguments `err` and `id`
 * @param  {Object}    err         Error object
 * @param  {object}    id          The ID of the user if the passwords match. Otherwise false.
 */
var checkPasswordForUserId = function(userId, password, callback) {
    Cassandra.runQuery('SELECT password FROM Principals USING CONSISTENCY QUORUM WHERE principalId = ?', [userId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        if (rows[0].count === 0) {
            // No user found with that username.
            return callback({'code': 401, 'msg': 'No password found for this principal'});
        }

        // Check if the user provided password matches the stored password
        if (PrincipalsUtil.checkPassword(password, rows[0].get('password').value)) {
            callback(false, {'id': userId});
        } else {
            callback({'code': 401, 'msg': 'User name and/or password do not match.'});
        }
    });
};

/**
 * Set a flag that indicates whether a user is a tenant admin.
 * The ctx user must be a tenant or global admin to be able to do this.
 *
 * @param  {Context}   ctx             Context that holds the tenant.
 * @param  {User}      principalId     The user that needs the flag
 * @param  {Boolean}   isAdmin         Flag that indicates whether the provided user should be a tenant admin.
 * @param  {Function}  callback        Callback method
 * @param  {Object}    callback.err    Error object.
 */
module.exports.setTenantAdmin = function(ctx, principalId, isAdmin, callback) {
    var principalResource = AuthzUtil.getResourceFromId(principalId);
    if (ctx.user() && (ctx.user().isTenantAdmin(principalResource.tenantId) || ctx.user().isGlobalAdmin())) {
        _setAdmin(ctx, 'admin:tenant', isAdmin, principalId, callback);
    } else {
        return callback({'code': 401, 'msg': 'You do not have sufficient rights to make someone an admin.'});
    }
};

/**
 * Set a flag that indicates whether a user is a glbal admin.
 * The ctx user must be a global admin to be able to do this.
 *
 * @param  {Context}   ctx             Context that holds the tenant.
 * @param  {User}      user            The user that needs the flag
 * @param  {Boolean}   isAdmin         Flag that indicates whether the provided user should be a global admin.
 * @param  {Function}  callback        Callback method
 * @param  {Object}    callback.err    Error object.
 */
module.exports.setGlobalAdmin = function(ctx, principalId, isAdmin, callback) {
    if (ctx.user() && ctx.user().isGlobalAdmin && ctx.user().isGlobalAdmin()) {
        _setAdmin(ctx, 'admin:global', isAdmin, principalId, callback);
    } else {
        return callback({'code': 401, 'msg': 'You do not have sufficient rights to make someone an admin.'});
    }
};

/**
 * Internal method that makes a user an admin. This method will do all the necessary validation
 * of the user ctx and passed in parameters.
 *
 * @param  {Context}        ctx             Context that holds the current user and tenant.
 * @param  {String}         adminType       One of admin:global` or `admin:tenant`
 * @param  {Boolean}        isAdmin         Flag that indicates whether this user should be an admin or not.
 * @param  {String}         principalId     The uuid of the user that needs to be made an admin.
 * @param  {Function}       callback        Callback method takes argument `err`
 * @param  {Object}         callback.err    Error object.
 * @api private
 */
var _setAdmin = function(ctx, adminType, isAdmin, principalId, callback) {
    if (!PrincipalsUtil.isUser(principalId)) {
        return callback({'code': 400, 'msg': 'The provided principalId is not a user.'});
    }
    // Double-check that this user exists.
    module.exports.getUser(ctx, principalId, function(err, user) {
        // If we get an error, this user does not exist.
        if (err) {
            return callback(err);
        }

        // Sanitize input and store it in cassandra.
        isAdmin = sanitize(isAdmin).toBooleanStrict();
        Cassandra.runQuery("UPDATE Principals USING CONSISTENCY QUORUM SET ?=? WHERE principalId = ?", [adminType, isAdmin, principalId], callback);
    });
};
