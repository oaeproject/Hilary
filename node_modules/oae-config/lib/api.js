/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var clone = require('clone');
var events = require('events');
var util = require('util');

var Cassandra = require('oae-util/lib/cassandra');
var Util = require('oae-util/lib/util');
var IO = require('oae-util/lib/io');
var Modules = require('oae-util/lib/modules');
var OaeUtil = require('oae-util/lib/util');
var Pubsub = require('oae-util/lib/pubsub');
var TenantsAPI = require('oae-tenants');
var Validator = require('oae-util/lib/validator').Validator;
var log = require('oae-logger').logger('oae-config');

// Will be used to cache the global OAE config
var config = null;

// Cached global config schema, will include all configuration options
var cachedGlobalSchema = {};
// Cached tenant config schema, will include all configuration options except for the ones marked as `global admin only`
var cachedTenantSchema = {};
// Cached config values for global admin users, will include all configuration values
var cachedGlobalConfig = {};
// Cached config values for tenant admin users, will include all configuration options except for the ones marked as `global admin only`
var cachedTenantConfig = {};
// Cached config values for non-admin users, will exclude configuration options marked as `suppressed` or `global admin only`
var cachedConfigSuppressed = {};
// Cached last modified timestamps
var cachedLastUpdated = {};

/**
 * The Configuration API.
 *
 * ## Events
 *
 * When the configuration has been updated for a tenant different than the global
 * admin tenant, the tenant alias will be passed into all of the events below.
 *
 * * `cached(tenantAlias)`:         The configuration for a tenant has been re-cached
 * * `cleared(tenantAlias)`:        The configuration for a tenant has been cleared
 * * `update(tenantAlias)`:         The configuration for a tenant has been updated
 * * `preCache(tenantAlias)`:       The configuration for a tenant is about to be re-cached
 * * `preClear(tenantAlias)`:       The configuration for a tenant is about to be cleared
 * * `preUpdate(tenantAlias)`:      The configuration for a tenant is about to be updated
 */
var ConfigAPI = module.exports = new events.EventEmitter();


//////////////////////////
// Pubsub notifications //
//////////////////////////

/*!
 * Catch a published Redis PubSub message from the oae-config module and refreshes the cached configuration for the tenant (in case
 * only a tenant config value was updated) or for all tenants (in case the global admin configuration has been updated)
 *
 * @param  {String}  tenantAlias  The message sent out to the cluster, provides the alias of the tenant for which a config value changed (e.g. `cam`)
 */
Pubsub.on('oae-config', function(tenantAlias) {

    /*!
     * Handle the callback for when the cached configuration is updated
     *
     * @param  {Object}     err     An error that occurred, if any
     */
    var _handleCachedConfig = function(err) {
        if (err) {
            log().error({'err': err, 'tenantAlias': tenantAlias}, 'Error refreshing cached configuration after update');
        } else {
            ConfigAPI.emit('update', tenantAlias);
        }
    };

    // If the global tenant has been updated all tenants need an update
    if (tenantAlias === config.servers.globalAdminAlias) {
        cacheAllTenantConfigs(_handleCachedConfig);
    } else {
        cacheTenantConfig(tenantAlias, _handleCachedConfig);
    }
});


///////////////////
// Tenant events //
///////////////////

/**
 * Re-cache the configuration for a tenant
 *
 * @param  {Tenant}     tenant      The tenant for which to re-cache the configuration
 * @api private
 */
var _handleTenantEvent = function(tenant) {
    cacheTenantConfig(tenant.alias);
};

TenantsAPI.on('created', _handleTenantEvent);
TenantsAPI.on('start', _handleTenantEvent);


//////////////////////
// Get config value //
//////////////////////

/**
 * Get a function that allows retrieving of config values for a given module
 *
 * @param  {String}     moduleId    The ID of the module to get the configuration for
 * @return {Function}   getValue    Function that returns the cached a cached config value from the provided module
 * @throws {Error}                  Error thrown when no module id has been provided
 */
module.exports.config = function(moduleId) {
    // Parameter validation
    if (!moduleId) {
        throw new Error('A module id must be provided');
    }

    return {
        /**
         * Get a configuration value for the current module. This will return a cached value. This internal function will
         * also return suppressed values, as they will be necessary for usage inside of the internal APIs
         *
         * @param  {String}                         tenantAlias             The alias of the tenant for which to get the config value
         * @param  {String}                         feature                 The feature to get the element's value for. e.g., `twitter`
         * @param  {String}                         element                 The element to get the config value for. e.g., `enabled`
         * @return {Boolean|String|Number|Object}   cachedConfiguration     The requested config value e.g. `true`. This will be null if the config element cannot be found
         */
        'getValue': function(tenantAlias, feature, element) {
            // Parameter validation
            if (!tenantAlias || !feature || !element) {
                return null;
            }

            // Validate the existence of the config value
            if (!cachedGlobalConfig[tenantAlias] || !cachedGlobalConfig[tenantAlias][moduleId] ||
                !cachedGlobalConfig[tenantAlias][moduleId][feature] || cachedGlobalConfig[tenantAlias][moduleId][feature][element] === undefined) {
                return null;
            }

            return cachedGlobalConfig[tenantAlias][moduleId][feature][element];
        },

        /**
         * Get the timestamp for when a configuration value was last updated
         *
         * @param  {String}     tenantAlias     The alias of the tenant for which to get the config value's last updated timestamp
         * @param  {String}     feature         The feature to get the element's last updated timestamp for. e.g., `twitter`
         * @param  {String}     element         The element for which to get the config value's last updated timestamp. e.g., `enabled`
         * @return {Date}                       The timestamp when the config value was last updated. If the element could not be found, the epoch date (0 milliseconds) will be returned
         */
        'getLastUpdated': function(tenantAlias, feature, element) {
            // Parameter validation
            if (!tenantAlias || !feature || !element) {
                return new Date(0);
            }

            // Validate the existence of the config value
            if (!cachedLastUpdated[tenantAlias] || !cachedLastUpdated[tenantAlias][moduleId] ||
                !cachedLastUpdated[tenantAlias][moduleId][feature] || !cachedLastUpdated[tenantAlias][moduleId][feature][element]) {
                return new Date(0);
            }

            return cachedLastUpdated[tenantAlias][moduleId][feature][element];
        }
    };
};

/**
 * Get the full cached config schema. This can only be retrieved by either global or tenant
 * admins, as it might contain sensitive data
 *
 * @param  {Context}    ctx                 Standard context object containing the current user and the current tenant
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Object}     callback.schema     The config schema
 */
var getSchema = module.exports.getSchema = function(ctx, callback) {
    if (!ctx.user() || !ctx.user().isAdmin(ctx.tenant().alias)) {
        return callback({'code': 401, 'msg': 'Only global and tenant admin can get the config schema'});
    }

    if (ctx.user().isGlobalAdmin()) {
        return callback(null, cachedGlobalSchema);
    }
    callback(null, cachedTenantSchema);
};

/**
 * Get the full config feed for a tenant from cache, containing all the config values for that tenant. Admin users will receive
 * all config values, including those for suppressed fields. Non-admin users will receive all of the non-suppressed config values
 *
 * @param  {Context}    ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}     tenantAlias         The alias of the tenant for which to get the configuration
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Object}     callback.config     JSON object representing the full cached tenant config
 */
var getTenantConfig = module.exports.getTenantConfig = function(ctx, tenantAlias, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(tenantAlias, {'code': 400, 'msg': 'Missing tenant parameter'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the current user is an admin user. If so, we return all config values, if the user
    // is a tenant admin we only return values accessible to tenant admins, otherwise we return
    // configuration without suppressed or globalAdminOnly values
    if (ctx.user() && ctx.user().isGlobalAdmin()) {
        return callback(null, cachedGlobalConfig[tenantAlias]);
    } else if (ctx.user() && ctx.user().isTenantAdmin(tenantAlias)) {
        return callback(null, cachedTenantConfig[tenantAlias]);
    }

    return callback(null, cachedConfigSuppressed[tenantAlias]);
};


////////////////////
// Initialization //
////////////////////

/**
 * Initialize and cache the configuration schema, as well as the list of config values for all tenants
 *
 * @param  {Object}     config          An object containing the full system configuration (i.e., `config.js`)
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var initConfig = module.exports.initConfig = function(_config, callback) {
    // Default callback
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'An error occured whilst initializing the configuration');
        }
    };

    config = _config;

    // Cache the config schema
    cacheSchema(function() {
        cacheAllTenantConfigs(callback);
    });
};

/**
 * Cache all of the module config descriptors. First of all, all of the available modules are retrieved
 * and modules that don't have a configuration file in the config directory are filtered out. Every file
 * in the /config directory of a module is read and will be added to the globally cached schema object.
 * It's assumed that the files contains valid JSON. If multiple configuration files exist in one module
 * they will be merged together
 *
 * @param  {Function}   callback    Standard callback function
 * @api private
 */
var cacheSchema = function(callback) {
    // Get the available module
    var modules = Modules.getAvailableModules();
    var toDo = modules.length;
    var done = 0;
    var complete = false;

    /*!
     * Get the configuration files for a given module and create the schema for global and tenant administrators
     * when all configuration files have been loaded
     *
     * @param  {String}     module      The module we're getting the configuration for. e.g., `oae-principals`
     */
    var getModuleSchema = function(module) {
        var dir = OaeUtil.getNodeModulesDir() + module + '/config/';
        // Get a list of the available config files
        IO.getFileListForFolder(dir, function(err, configFiles) {
            if (complete) {
                return;
            } else if (err) {
                complete = true;
                return callback(err);
            }

            // Require all of them
            for (var c = 0; c < configFiles.length; c++) {
                var configFile = require(module + '/config/' + configFiles[c]);
                cachedGlobalSchema[module] = _.extend(cachedGlobalSchema[module] || {}, configFile);
            }

            done++;
            if (done === toDo) {
                // Clone the cached global schema and filter out elements that are only visible to the global admin users
                cachedTenantSchema = clone(cachedGlobalSchema);
                // Loop over all modules
                _.each(cachedTenantSchema, function(mod, moduleKey) {
                    // Loop over all features per module
                    _.each(mod, function(feature, featureKey) {
                        // Loop over all elements per feature
                        _.each(feature.elements, function(element, elementKey) {
                            // If the value is only visible to global admins remove it from the object
                            if (element.globalAdminOnly) {
                                delete cachedTenantSchema[moduleKey][featureKey].elements[elementKey];
                            }
                        });
                    });
                });

                complete = true;
                return callback();
            }
        });
    };

    for (var m = 0; m < modules.length; m++) {
        getModuleSchema(modules[m]);
    }
};

/**
 * Cache the config values for the global admin and all of the available tenants. For each of them, this will take the
 * config schema and its default values, overlay it with the value set on the global admin and then overlay it with the
 * value set for that tenant
 *
 * @param  {Function}   [callback]      Standard callback function
 * @param  {Object}     [callback.err]  An error that occurred, if any
 * @api private
 */
var cacheAllTenantConfigs = function(callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'An error occured whilst caching all tenant configs');
        }
    };

    // Indicate that config values are about to be re-cached
    ConfigAPI.emit('preCache');

    // Cache the config values for the global admin server
    var tenantsToCache = [config.servers.globalAdminAlias];
    // Cache the config for each of the tenants
    var tenants = TenantsAPI.getTenants();

    tenantsToCache = tenantsToCache.concat(_.keys(tenants));

    // Go through them one by one
    var cacheNextTenantConfig = function() {
        var tenant = tenantsToCache.shift();
        cacheTenantConfig(tenant, function(err) {
            if (err) {
                return callback(err);
            }

            if (tenantsToCache.length > 0) {
                cacheNextTenantConfig();
            } else {
                // Indicate that all the config values are re-cached
                ConfigAPI.emit('cached');

                return callback();
            }
        });
    };
    cacheNextTenantConfig();
};

/**
 * Get a list of all of the config values that have been set for a tenant, use the global admin defaults for the values for which
 * no tenant values are saved yet and cache them
 *
 * @param  {String}    tenantAlias       The ID of the tenant to get the configuration for
 * @param  {Function}  [callback]        Standard callback function
 * @param  {Object}    [callback.err]    An error that occured, if any
 * @api private
 */
var cacheTenantConfig = function(tenantAlias, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'An error occured whilst constructing the config for ' + tenantAlias);
        }
    };

    // Indicate that config values are about to be re-cached
    ConfigAPI.emit('preCache', tenantAlias);

    Cassandra.runQuery('SELECT "configKey", "value", WRITETIME("value") FROM "Config" WHERE "tenantAlias" = ?', [tenantAlias], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var persistentConfig = {};
        _.each(rows, function(row) {
            persistentConfig[row.get('configKey').value] = {
                'value': row.get('value').value,
                'timestamp': new Date(Math.floor(row.get('writetime(value)').value / 1000))
            };
        });

        cachedGlobalConfig[tenantAlias] = {};
        cachedTenantConfig[tenantAlias] = {};
        cachedConfigSuppressed[tenantAlias] = {};
        cachedLastUpdated[tenantAlias] = {};

        // Get all of the modules in the schema
        _.each(cachedGlobalSchema, function(module, moduleKey) {
            cachedGlobalConfig[tenantAlias][moduleKey] = {};
            cachedTenantConfig[tenantAlias][moduleKey] = {};
            cachedConfigSuppressed[tenantAlias][moduleKey] = {};
            cachedLastUpdated[tenantAlias][moduleKey] = {};

            // Get all of the top level properties of the modules. Only the ones that are object are configuration properties
            _.each(module, function(feature, featureKey) {
                cachedGlobalConfig[tenantAlias][moduleKey][featureKey] = {};
                cachedTenantConfig[tenantAlias][moduleKey][featureKey] = {};
                cachedConfigSuppressed[tenantAlias][moduleKey][featureKey] = {};
                cachedLastUpdated[tenantAlias][moduleKey][featureKey] = {};

                // Run through all of the elements of that feature
                _.each(feature.elements, function(element, elementKey) {
                    // If the current tenant is the global admin, we set the default to the one from the schema
                    if (tenantAlias === config.servers.globalAdminAlias) {
                        cachedGlobalConfig[tenantAlias][moduleKey][featureKey][elementKey] = element.defaultValue;
                    // If the current tenant is a regular tenant, we can take the global admin default as the default value
                    } else {
                        cachedGlobalConfig[tenantAlias][moduleKey][featureKey][elementKey] = cachedGlobalConfig[config.servers.globalAdminAlias][moduleKey][featureKey][elementKey];
                    }

                    // Check if the value has been overridden
                    var key = _generateColumnKey(moduleKey, featureKey, elementKey);
                    var value = (persistentConfig[key] && persistentConfig[key].value);
                    var timestamp = (persistentConfig[key] && persistentConfig[key].timestamp);

                    if (_.isString(value)) {
                        try {
                            // If the value starts with a `{` it's probably an element that has optional keys
                            // Convert it to an object
                            if (value[0] === '{') {
                                try {
                                    value = JSON.parse(value);
                                } catch (err) {
                                    // It's perfectly possible that a value started with a `{` that doesn't use the optional keys
                                }
                            }

                            // Deserialize
                            if (_.isObject(value)) {
                                _.each(value, function(val, optionalKey) {
                                    value[optionalKey] = element.deserialize(val);
                                });
                            } else {
                                value = element.deserialize(value);
                            }

                            // Convert the column value to a value that can be used by the ConfigAPI / UI
                            cachedGlobalConfig[tenantAlias][moduleKey][featureKey][elementKey] = value;
                            cachedLastUpdated[tenantAlias][moduleKey][featureKey][elementKey] = timestamp;
                        } catch (err) {
                            log().warn({'err': err, 'value': value, 'key': key}, 'Could not parse a stored config value');
                        }
                    }

                    // If the config value is available to both global and tenant admins, add it to the cached tenant config
                    if (!element.globalAdminOnly) {
                        cachedTenantConfig[tenantAlias][moduleKey][featureKey][elementKey] = cachedGlobalConfig[tenantAlias][moduleKey][featureKey][elementKey];
                    }

                    // If the value is not suppressed and not globalAdminOnly, we add it to the cached suppressed config object
                    if (!element.suppress && !element.globalAdminOnly) {
                        cachedConfigSuppressed[tenantAlias][moduleKey][featureKey][elementKey] = cachedGlobalConfig[tenantAlias][moduleKey][featureKey][elementKey];
                    }

                    // If an element is valueless, we remove it from the config object
                    if (_.isUndefined(cachedConfigSuppressed[tenantAlias][moduleKey][featureKey][elementKey])) {
                        delete cachedConfigSuppressed[tenantAlias][moduleKey][featureKey][elementKey];
                    }
                });

                // If a feature doesn't contain any elements, we remove it from the config object
                if (_.isEmpty(cachedConfigSuppressed[tenantAlias][moduleKey][featureKey])) {
                    delete cachedConfigSuppressed[tenantAlias][moduleKey][featureKey];
                }
            });

            // If a module doesn't contain any features, we remove it from the config object
            if (_.isEmpty(cachedConfigSuppressed[tenantAlias][moduleKey])) {
                delete cachedConfigSuppressed[tenantAlias][moduleKey];
            }
        });

        // Indicate that config values are re-cached
        ConfigAPI.emit('cached', tenantAlias);
        return callback();
    });
};

/////////////////////////
// Update config value //
/////////////////////////

/**
 * Determine if the specified config value is a known config value
 *
 * @param  {String}     moduleId    The ID of the configuration module to check
 * @param  {String}     feature     The ID of the feature to check
 * @param  {String}     element     The ID of the element to check
 * @return {Boolean}                Returns `true` if the configuration element exists, `false` otherwise
 * @api private
 */
var _configValueExists = function(moduleId, feature, element) {
    if (cachedGlobalSchema[moduleId] &&
            cachedGlobalSchema[moduleId][feature] &&
            cachedGlobalSchema[moduleId][feature].elements &&
            cachedGlobalSchema[moduleId][feature].elements[element]) {
        return true;
    } else {
        return false;
    }
};

/**
 * Determine if the current user is allowed to update the configuration value. This effectively enforces
 * the following rules:
 *
 *  * A tenant administrator cannot update a configuration value whose `tenantOverride` property is set to `true`; and
 *  * A tenant administrator cannot update a configuration value whose `globalAdminOnly` property is set to `true`
 *
 * This method does not ensure that the current context is a tenant administrator. That should be done in prior
 * validation logic.
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     tenantAlias     The alias of the tenant on which to update the configuration value
 * @param  {String}     moduleId        The ID of the configuration module the user wants to update a value of
 * @param  {String}     feature         The ID of the feature the user wants to update a value of
 * @param  {String}     element         The ID of the element the user wants to update a value of
 * @return {Boolean}                    Returns `true` if the user is allowed to update the configuration value, `false` if not allowed
 * @api private
 */
var _canUpdateConfigValue = function(ctx, tenantAlias, moduleId, feature, element) {
    var configElement = cachedGlobalSchema[moduleId][feature].elements[element];

    // If `tenantOverride=false` is specified and the user is a tenant administrator only,
    // the tenant administrator is not allowed to change the configuration option
    if (!configElement.tenantOverride && !ctx.user().isGlobalAdmin()) {
        return false;
    }

    // If `globalAdminOnly` is specified and the user is a not a global admin, the user
    // is not allowed to change the configuration option
    if (configElement.globalAdminOnly && !ctx.user().isGlobalAdmin()) {
        return false;
    }

    return true;
};

/**
 * Update a configuration value for a particular tenant
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     tenantAlias     The alias of the tenant on which to update the configuration value
 * @param  {Object}     configValues    The configuration to store. The keys represent the `module/feature/element/[optionalKey]` combination and the values represent their new config value
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var updateConfig = module.exports.updateConfig = function(ctx, tenantAlias, configValues, callback) {
    if (!ctx.user() || !ctx.user().isAdmin(tenantAlias)) {
        return callback({'code': 401, 'msg': 'Only authorized tenant admins can change config values'});
    }

    var configFieldNames = _.keys(configValues);

    var validator = new Validator();
    validator.check(tenantAlias, {'code': 400, 'msg': 'Missing tenantid'}).notEmpty();
    validator.check(configFieldNames.length, {'code': 400, 'msg': 'Missing configuration. Example configuration: {"oae-authentication/twitter/enabled": false}'}).min(1);

    // Since we can return out of this loop, we use `for` instead of `_.each`
    for (var i = 0; i < configFieldNames.length; i++) {
        var configFieldName = configFieldNames[i];
        var configFieldValue = configValues[configFieldName];

        validator.check(null, {'code': 400, 'msg': util.format('The configuration value for "%s" must be specified', configFieldName)}).isDefined(configFieldValue);

        var parts = configFieldName.split('/');
        if (!_configValueExists(parts[0], parts[1], parts[2])) {
            return callback({'code': 404, 'msg': util.format('Config key "%s" does not exist', configFieldName)});
        } else if (!_canUpdateConfigValue(ctx, tenantAlias, parts[0], parts[1], parts[2])) {
            return callback({'code': 401, 'msg': util.format('User is not allowed to update config value "%s"', configFieldName)});
        }
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Aggregate the values into module/feature/element column keys
    var aggregatedValues = {};
    _.each(configValues, function(value, key) {
        // A key looks like module/feature/element/optionalKey
        var parts = key.split('/');
        var module = parts[0];
        var feature = parts[1];
        var element = parts[2];
        var optionalKey = parts[3];

        // Trim all string values that are input into the API
        if (_.isString(value)) {
            value = value.trim();
        }

        var storageKey = _generateColumnKey(module, feature, element);

        if (optionalKey) {
            // If we specified an optional key, we're only partially updating an element's value
            // We need to merge it with the existing value
            aggregatedValues[storageKey] = aggregatedValues[storageKey] || _.extend({}, cachedTenantConfig[tenantAlias][module][feature][element]) || {};
            aggregatedValues[storageKey][optionalKey] = value;
        } else {
            aggregatedValues[storageKey] = value;
        }
    });

    // Gather all the queries needed to update the config for a batch query
    var queries = [];
    _.each(aggregatedValues, function(value, key) {
        if (_.isObject(value)) {
            value = JSON.stringify(value);
        }

        queries.push({
            'query': 'UPDATE "Config" SET "value" = ? WHERE "tenantAlias" = ? AND "configKey" = ?',
            'parameters': [value, tenantAlias, key]
        });
    });

    // Indicate that configuration is about to be updated
    ConfigAPI.emit('preUpdate', tenantAlias);

    // Perform all the config field updates
    Cassandra.runBatchQuery(queries, function(err) {
        if (err) {
            return callback(err);
        }

        Pubsub.publish('oae-config', tenantAlias);
        return callback();
    });
};

/**
 * Clear a configuration value so that it is no longer set, reverting it back to the default
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     tenantAlias     The alias of the tenant on which the configuration value should be cleared
 * @param  {String[]}   configFields    An array of config elements whose values should be cleared in the form `oae-authentication/twitter/enabled`
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var clearConfig = module.exports.clearConfig = function(ctx, tenantAlias, configFields, callback) {
    if (!ctx.user() || !ctx.user().isAdmin(tenantAlias)) {
        return callback({'code': 401, 'msg': 'Only authorized tenant admins can change config values'});
    }

    var validator = new Validator();
    validator.check(tenantAlias, {'code': 400, 'msg': 'Missing tenant alias'}).notEmpty();
    validator.check(configFields.length, {'code': 400, 'msg': 'Missing configuration. Example configuration: ["oae-authentication/twitter/enabled"]'}).min(1);

    // Sort the config fields alphabetically so we can do the mixed element/optionalKey check
    configFields = configFields.sort();
    for (var i = 0; i < configFields.length; i++) {
        // Check that we're not clearing both the entire element and one if its optional keys
        if (i > 0) {
            validator.check(configFields[i].indexOf(configFields[i - 1] + '/'), {'code': 400, 'msg': 'You cannot mix clearing an entire element and an optionalKey'}).not('0');
        }

        var configField = configFields[i].split('/');
        if (!_configValueExists(configField[0], configField[1], configField[2])) {
            return callback({'code': 404, 'msg': util.format('Config value "%s" does not exist', configFields[i])});
        } else if (!_canUpdateConfigValue(ctx, tenantAlias, configField[0], configField[1], configField[2])) {
            return callback({'code': 401, 'msg': util.format('User is not allowed to update config value "%s"', configFields[i])});
        }
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Keep track of what changes that should happen to the row
    var rowChanges = {};
    _.each(configFields, function(key) {
        var parts = key.split('/');
        var module = parts[0];
        var feature = parts[1];
        var element = parts[2];
        var optionalKey = parts[3];

        var columnKey = _generateColumnKey(module, feature, element);

        // If no optional key was specified, we can delete the entire column
        if (!optionalKey) {
            rowChanges[columnKey] = false;

        // If we're clearing an optional key, we need to delete that key from the hash and store the updated value
        } else {
            // It's possible we've already deleted an optional key within this element
            var value = rowChanges[columnKey] || _.extend({}, cachedTenantConfig[tenantAlias][module][feature][element]);

            // Delete the key
            if (value[optionalKey]) {
                delete value[optionalKey];
            }

            // Keep track of the new value for this element, as the next configField might be an optional key for this element
            rowChanges[columnKey] = value;
        }
    });

    var queries = _.map(rowChanges, function(value, columnName) {
        if (!value) {
            return {
                'query': 'DELETE FROM "Config" WHERE "tenantAlias" = ? AND "configKey" = ?',
                'parameters': [tenantAlias, columnName]
            };
        } else {
            if (_.isObject(value)) {
                value = JSON.stringify(value);
            }

            return {
                'query': 'UPDATE "Config" SET "value" = ? WHERE "tenantAlias" = ? AND "configKey" = ?',
                'parameters': [value, tenantAlias, columnName]
            };
        }
    });

    // Indicate that config values are about to be cleared
    ConfigAPI.emit('preClear', tenantAlias);

    Cassandra.runBatchQuery(queries, function(err) {
        if (err) {
            return callback(err);
        }

        Pubsub.publish('oae-config', tenantAlias);
        return callback();
    });
};

/**
 * Generate a string that can be used as a column name using the given `module`, `feature` and `element` names
 *
 * @param  {String}     module      The name of the module. e.g., `oae-authentication`
 * @param  {String}     feature     The feature to get the element's column name for. e.g., `twitter`
 * @param  {String}     element     The element to get the column name for. e.g., `enabled`
 * @return {String}                 A string that can be used as a column name to store a value for this element in Cassandra
 * @api private
 */
var _generateColumnKey = function(module, feature, element) {
    return util.format('%s/%s/%s', module, feature, element);
};
