/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var Etherpad = require('etherpad-lite-client');

var log = require('oae-logger').logger('etherpad');
var Signature = require('oae-util/lib/signature');
var Validator = require('oae-util/lib/validator').Validator;

var ContentDAO = require('./dao');

var etherpadServers = [];
var etherpadConfig = null;

/**
 * Initializes the etherpad client.
 *
 * @param  {Object}   _etherpadConfig     The etherpad config from config.js.
 */
var refreshConfiguration = module.exports.refreshConfiguration = function(_etherpadConfig) {
    // Remember this config.
    etherpadConfig = _etherpadConfig;

    // Remove the old servers (if any).
    etherpadServers = [];

    // Connect to each server.
    _.each(etherpadConfig.hosts, function(host) {
        var etherpad = {
            'client': Etherpad.connect(host),
            'baseURL': host.protocol + '://' + host.host + ':' + host.port
        };
        etherpadServers.push(etherpad);
    });

    // Sort the etherpad servers based on their hostname.
    // We do this so we have the same "ordered set" of etherpad hosts accross the app node cluster.
    etherpadServers.sort(function(a, b) { return a.host < b.host; });
};

/**
 * @return {Object} The etherpad configuration.
 */
var getConfig = module.exports.getConfig = function() {
    return etherpadConfig;
};

/**
 * Creates a pad via the etherpad API.
 *
 * @param  {Content}        contentObj      The content object representing the collaborative document for which an etherpad pad should be created.
 * @param  {Function}       callback        Standard callback method.
 * @param  {Object}         callback.err    Standard error object (if any.)
 */
var createPad = module.exports.createPad = function(contentObj, callback) {
    // Because etherpad has a slightly weird system of authenticating users
    // we need to create a group *PER* content item and then create a group pad in this group.

    // Get the client that points to the correct etherpad instance.
    var client = getClient(contentObj.id);

    // Create the group.
    var args = {
        'groupMapper': contentObj.id
    };
    log().trace({'contentId': contentObj.id}, 'Creating group.');
    client.createGroupIfNotExistsFor(args, function(err, groupData) {
        if (err) {
            log().error({'err': err, 'contentId': contentObj.id}, 'Could not create a group.');
            return callback({'code': 500, 'msg': err.message});
        }

        // Create the group pad.
        var groupPad = {
            'groupID': groupData.groupID,
            'padName': contentObj.id
        };
        log().trace({'contentId': contentObj.id, 'groupID': groupData.groupID}, 'Creating group pad.');
        client.createGroupPad(groupPad, function(err, padData) {
            if (err) {
                log().error({'err': err, 'contentId': contentObj.id}, 'Could not create a group pad.');
                return callback({'code': 500, 'msg': err.message});
            }

            // Store these IDs in the database.
            var fields = {
                'etherpadGroupID': groupData.groupID,
                'etherpadPadID': padData.padID
            };
            log().trace({'contentId': contentObj.id, 'groupID': groupData.groupID, 'padID': padData.padID}, 'Created an etherpad group and pad.');
            ContentDAO.Content.updateContent(contentObj, fields, true, callback);
        });
    });
};

/**
 * Get the HTML for a pad.
 *
 * @param  {Content}    contentObj      The Content object for which the HTML should be retrieved from etherpad.
 * @param  {Function}   callback        Standard callback method.
 * @param  {Object}     callback.err    Standard error object (if any.)
 * @param  {String}     callback.html   The HTML fragment for this pad.
 */
var getHTML = module.exports.getHTML = function(contentObj, callback) {
    log().trace({'contentId': contentObj.id}, 'Getting HMTL');
    getClient(contentObj.id).getHTML({'padID': contentObj.collabdoc.padID}, function(err, data) {
        if (err) {
            log().error({'err': err, 'padID': contentObj.collabdoc.padID, 'contentId': contentObj.id}, 'Could not grab the HTML from etherpad.');
            return callback({'code': 500, 'msg': 'Could not grab the HTML from etherpad.'});
        }

        callback(null, data.html);
    });
};

/**
 * Set the html for a pad.
 *
 * @param  {Content}    contentObj      The Content object for which the html fragment should be set.
 * @param  {String}     html            The HTML fragment to store in etherpad.
 * @param  {Function}   callback        Standard callback method.
 * @param  {Object}     callback.err    Standard error object (if any.)
 */
var setHTML = module.exports.setHTML = function(contentObj, html, callback) {
    log().trace({'contentId': contentObj.id, 'html': html}, 'Setting html');

    // Although Etherpad exposes an API to set the HTML of a pad, it doesn't accept any HTML fragments.
    // We encapsulate the HTML fragment into a simple page and submit that instead.
    var toSend = '<!doctype html><html lang="en"><head><title></title><meta charset="utf-8"></head><body>' + html + '</body></html>';
    getClient(contentObj.id).setHTML({'padID': contentObj.collabdoc.padID, 'html': toSend}, function(err, data) {
        if (err) {
            log().error({'err': err, 'padID': contentObj.collabdoc.padID, 'contentId': contentObj.id, 'html': html}, 'Could not set the html on the etherpad instance.');
            return callback({'code': 500, 'msg': 'Could not set the html on the etherpad instance.'});
        }

        callback(null);
    });
};

/**
 * Joins the current user in an etherpad.
 *
 * @param  {Context}    ctx             The current context
 * @param  {Content}    contentObj      The content object on which the user should join.
 * @param  {Function}   callback        Standard callback method.
 * @param  {String}     callback.url    The public URL that the UI can use to embed the pad.
 */
var joinPad = module.exports.joinPad = function(ctx, contentObj, callback) {
    if (!ctx.user()) {
        return callback({'code': 401, 'msg': 'Anonymous users are not allowed to join collaborative documents.'});
    }

    // Get the etherpad client that will handle this contentId.
    var client = getClient(contentObj.id);

    /*
     *   Joining a pad consists out of three things:
     *    1/ Mapping the OAE user to an etherpad author.
     *    2/ Creating a session for the etherpad author
     *    3/ Returning a url to the UI. It should contain
     *       * The server etherpad is running on (ex: http://7.etherpad.oae.com/)
     *       * The pad URI (ex: /p/c_cam_abc123)
     *       * The session ID (ex: ?sessionID=s.32b01f91d0e2c9a344)
     *       * A signature of the session ID to prove it hasn't been tampered with (ex: &signature=..)
     */
    var args = {
        'authorMapper': ctx.user().id,
        'name': ctx.user().displayName
    };
    client.createAuthorIfNotExistsFor(args, function(err, author) {
        if (err) {
            log().error({'err': err, 'contentId': contentObj.id, 'principalId': ctx.user().id}, 'Could not create an author.');
            return callback({'code': 500, 'msg': 'Could not create an author in the etherpad system.'});
        }

        var session = {
            'groupID': contentObj.collabdoc.groupID,
            'authorID': author.authorID,
            'validUntil': Math.round(Date.now()/1000) + 60*60*24
        };
        log().trace(session, 'Creating a session');
        client.createSession(session, function(err, data) {
            if (err) {
                log().error({'err': err, 'contentId': contentObj.id, 'principalId': ctx.user().id}, 'Could not create a session.');
                return callback({'code': 500, 'msg': 'Could not create a session for this user.'});
            }

            // Construct the URL.
            var base = getServerBaseURL(contentObj.id);
            var url = base + '/p/' + contentObj.collabdoc.padID;
            url += '?sessionID=' + data.sessionID;
            var tenantAlias = ctx.tenant().alias;
            var signature = Signature.createRollingSignature(tenantAlias, 60*60*24, 60*2, data.sessionID);
            url += '&signature=' + signature.signature;
            url += '&expires=' + signature.expires;
            url += '&tenantAlias=' + tenantAlias;

            return callback(null, {'url': url});
        });
    });
};

/**
 * Get the base URL where users can reach the pads tied to a specific piece of content.
 * This will include the protocol and hostname.
 * ex: https://0.etherpad.oae.com
 *
 * @param  {String} contentId   The ID of the piece of content.
 * @return {String}             The base URL of the server serving the pad for this content.
 */
var getServerBaseURL = module.exports.getServerBaseURL = function(contentId) {
    return _getServer(contentId).baseURL;
};

/**
 * Get an etherpad client that can talk to an etherpad API.
 *
 * @param  {String} contentId The ID of the piece of content for which we need to retrieve an etherpad client.
 * @return {Client}           The request etherpad client.
 */
var getClient = module.exports.getClient = function(contentId) {
    return _getServer(contentId).client;
};

/**
 * Get the server that is tied to a content ID.
 *
 * @param  {String} contentId The content ID for which the server should be retrieved.
 * @return {Object}           The server tied to a collabration document.
 * @api private
 */
var _getServer = function(contentId) {
    var index = _hash(contentId, etherpadServers.length);
    return etherpadServers[index];
};

/**
 * Hashes a string and returns the index.
 *
 * @param  {String}     str     The string to hash.
 * @param  {String}     nr      The upper bound (exclusive) for the index.
 * @return {Number}             The index.
 * @api private
 */
var _hash = function(str, nr) {
    var code = 0;
    for (var i = 0; i < str.length; i++) {
        code += str.charCodeAt(i);
    }
    return code % nr;
};
