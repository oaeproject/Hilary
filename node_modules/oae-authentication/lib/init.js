/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var crypto = require('crypto');
var passport = require('passport');

var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var Context = require('oae-context').Context;
var OAE = require('oae-util/lib/oae');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var User = require('oae-principals/lib/model').User;

var AuthenticationAPI = require('./api');
var AuthenticationUtil = require('./util');

module.exports = function(config, callback) {
    // Attach the Authentication middleware
    AuthenticationUtil.setupAuthMiddleware(OAE.globalAdminServer);
    AuthenticationUtil.setupAuthMiddleware(OAE.tenantServer);

    // Setup the passport serializers
    setupPassportSerializers(config.cookie.secret);

    ensureSchema(function(err) {
        if (err) {
            return callback(err);
        }

        AuthenticationAPI.init(config.servers.globalAdminAlias);

        require('./strategies/cas/init')(config);
        require('./strategies/facebook/init')(config);
        require('./strategies/google/init')(config);
        require('./strategies/ldap/init')(config);
        require('./strategies/local/init')(config);
        require('./strategies/oauth/init')(config);
        require('./strategies/shibboleth/init')(config);
        require('./strategies/signed/init')(config);
        require('./strategies/twitter/init')(config);

        // Add the OAE middleware to the ExpressJS server
        // We do this *AFTER* all the authentication strategies have been initialized
        // so they have a chance to add any middleware that could set the logged in user
        OAE.tenantServer.use(contextMiddleware);
        OAE.globalAdminServer.use(contextMiddleware);

        return callback();
    });
};

/**
 * Express.js middleware that will stick an OAE `Context` object on each request at `req.ctx`.
 * This context object will contain the current tenant and currently authenticated user (if any).
 *
 * @param  {Request}    req     The Express.js request
 * @param  {Response}   res     The express.js response
 * @param  {Function}   next    Standard callback function
 */
var contextMiddleware = function(req, res, next) {
    var user = null;
    var imposter = null;
    var authenticationStrategy = null;

    // If we have an authenticated request, store the user and
    // imposter (if any) in the context
    if (req.oaeAuthInfo && req.oaeAuthInfo.user) {
        user = req.oaeAuthInfo.user;
        imposter = req.oaeAuthInfo.imposter;

        // TODO: This is for backward compatibility in https://github.com/oaeproject/Hilary/pull/959 to ensure
        // we don't get an error for cookies that did not previously contain the `strategyId`. This can be
        // removed on or after the minor or major release after this fix has been released
        if (req.oaeAuthInfo.strategyId) {
            authenticationStrategy = AuthenticationUtil.parseStrategyId(req.oaeAuthInfo.strategyId).strategyName;
        }
    }

    req.ctx = new Context(req.tenant, user, authenticationStrategy, null, imposter);
    return next();
};

/**
 * Sets up the serialization methods for passport.
 * This should only be run once.
 *
 * @api private
 */
var setupPassportSerializers = function(cookieSecret) {
    // Serialize the current user and potential imposter
    // ids into the session cookie
    passport.serializeUser(function(oaeAuthInfo, done) {
        var toSerialize = {};
        if (oaeAuthInfo.user) {
            toSerialize.userId = oaeAuthInfo.user.id;
            if (oaeAuthInfo.imposter) {
                toSerialize.imposterId = oaeAuthInfo.imposter.id;
            }
            if (oaeAuthInfo.strategyId) {
                toSerialize.strategyId = oaeAuthInfo.strategyId;
            }
        }

        return done(null, _encryptCookieData(JSON.stringify(toSerialize), cookieSecret));
    });

    // The user's full session is serialized into a cookie. When passport says "deserialize user", they're
    // actually saying "deserialize user's session". In which we store the user's id and session imposter,
    // if any
    passport.deserializeUser(function(toDeserialize, callback) {
        var sessionData = _decryptCookieData(toDeserialize, cookieSecret);

        try {
            // Parse the cookie data into a JSON object
            sessionData = JSON.parse(sessionData);
        } catch (ex) {
            // If JSON parsing fails, the user cookie has malformed session data (or it was tampered). We'll
            // just continue with an empty session, which means the user is effectively anonymous
            sessionData = {};
        }

        // If there is no user in the session, we short-circuit with an anonymous session
        if (!sessionData.userId) {
            return callback(null, false);
        }

        // Get the effective user of the session
        PrincipalsDAO.getPrincipal(sessionData.userId, function(err, user) {
            if (err && err.code === 404) {
                // If the user does not exist, the session is toast
                return callback(null, false);
            } else if (err) {
                // If an unexpected error occurred, return an error
                return callback(err);
            } else if (!sessionData.imposterId) {
                // There is no impostering happening here, so we just
                // treat this like a normal session
                return callback(null, {'user': user, 'strategyId': sessionData.strategyId});
            }

            // If we get here, the session user is being impostered by someone else
            PrincipalsDAO.getPrincipal(sessionData.imposterId, function(err, imposterUser) {
                if (err && err.code === 404) {
                    // If the user does not exist, the session is toast
                    return callback(null, false);
                } else if (err) {
                    // If an unexpected error occurred, return an error
                    return callback(err);
                }

                // Set the user (and potential imposter) on the request so it can be
                // picked up and set on the API context
                return callback(null, {'user': user, 'imposter': imposterUser, 'strategyId': sessionData.strategyId});
            });
        });
    });
};

/**
 * Encrypt a piece of cookie data to be sent back to the client.
 *
 * @param  {String}     cookieData      The data to encrypt
 * @param  {String}     cookieSecret    The secret string to encrypt the data with
 * @return {String}                     The encrypted data that is safe to return to the client
 * @api private
 */
var _encryptCookieData = function(cookieData, cookieSecret) {
    var cipher = crypto.createCipher('aes-256-cbc', cookieSecret);
    return cipher.update(cookieData, 'utf8', 'base64') + cipher.final('base64');
};

/**
 * Decrypt a piece of cookie data that was provided by the client.
 *
 * @param  {String}     encryptedData   The encrypted data to decrypt
 * @param  {String}     cookieSecret    The secret string to encrypt the data with
 * @return {String}                     The decrypted cookie data
 * @api private
 */
var _decryptCookieData = function(encryptedData, cookieSecret) {
    var decipher = crypto.createDecipher('aes-256-cbc', cookieSecret);
    return decipher.update(encryptedData, 'base64', 'utf8') + decipher.final('utf8');
};

/**
 * Ensure that the all of the authentication-related schemas are created. If they already exist, this method will not do anything.
 *
 * @param  {Function}    callback       Invoked when the process completes
 * @param  {Object}      callback.err   Error object, containing the error message if any
 * @api private
 */
var ensureSchema = function(callback) {
    Cassandra.createColumnFamilies({
        'AuthenticationLoginId': 'CREATE TABLE "AuthenticationLoginId" ("loginId" text PRIMARY KEY, "userId" text, "password" text)',
        'AuthenticationUserLoginId': 'CREATE TABLE "AuthenticationUserLoginId" ("userId" text, "loginId" text, "value" text, PRIMARY KEY ("userId", "loginId")) WITH COMPACT STORAGE',
        'OAuthAccessToken': 'CREATE TABLE "OAuthAccessToken" ("token" text PRIMARY KEY, "userId" text, "clientId" text)',
        'OAuthAccessTokenByUser': 'CREATE TABLE "OAuthAccessTokenByUser" ("userId" text, "clientId" text, "token" text, PRIMARY KEY ("userId", "clientId")) WITH COMPACT STORAGE',
        'OAuthClient': 'CREATE TABLE "OAuthClient" ("id" text PRIMARY KEY, "displayName" text, "secret" text, "userId" text)',
        'OAuthClientsByUser': 'CREATE TABLE "OAuthClientsByUser" ("userId" text, "clientId" text, "value" text, PRIMARY KEY ("userId", "clientId")) WITH COMPACT STORAGE'
    }, callback);
};
