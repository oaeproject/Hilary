/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var fs = require('fs');
var Path = require('path');
var ShortId = require('shortid');

var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var Config = require('oae-config/lib/api').config('oae-principals');
var log = require('oae-logger').logger('oae-principals');
var Redis = require('oae-util/lib/redis');
var Validator = require('oae-util/lib/validator').Validator;
var TZ = require('oae-util/lib/tz');
var Validator = require('oae-util/lib/validator').Validator;

var PrincipalsConstants = require('./constants').PrincipalsConstants;
var PrincipalsDAO = require('./internal/dao');
var PrincipalsEmitter = require('./internal/emitter');
var PrincipalsModel = require('./model');
var PrincipalsUtil = require('./util');

/**
 * Creates a new user under this tenant.
 *
 * @param  {Context}   ctx                     The current context
 * @param  {String}    displayName             A display name to represent the user on the UI
 * @param  {Object}    [opts]                  Optional parameters for the user
 * @param  {String}    [opts.visibility]       This user his visibility setting. (One of PrincipalsConstants.visibility)
 * @param  {String}    [opts.locale]           The user his locale
 * @param  {String}    [opts.timezone]         The user his timezone
 * @param  {String}    [opts.publicAlias]      This name will be what is seen when when the user is displayed to someone who does not have access to the profile
 * @param  {String}    [opts.smallPictureUri]  The URI for the small picture
 * @param  {String}    [opts.mediumPictureUri] The URI for the medium picture
 * @param  {String}    [opts.largePictureUri]  The URI for the large picture
 * @param  {Function}  callback                Callback method
 * @param  {Object}    callback.err            Error object if something goes wrong.
 * @param  {User}      callback.createdUser    A User object representing the created user
 */
var createUser = module.exports.createUser = function(ctx, displayName, opts, callback) {
    opts = opts || {};
    callback = callback || function(err) {
        if (err) {
            log().error({
                'err': err,
                'displayName': displayName
            }, 'Error creating user.');
        }
    };

    var tenantAlias = ctx.tenant().alias;

    opts.locale = opts.locale || Config.getValue(tenantAlias, 'user', 'defaultLanguage');
    opts.timezone = TZ.getClosestSupportedTimezone(opts.timezone);
    opts.visibility = opts.visibility || PrincipalsConstants.visibility.PUBLIC;
    opts.publicAlias = opts.publicAlias || displayName;

    var validator = new Validator();
    validator.check(displayName, {'code': 400, 'msg': 'A display name must be provided'}).notEmpty();
    validator.check(opts.visibility, {'code': 400, 'msg': 'The specified visibility setting is unknown.'}).isIn(_.values(PrincipalsConstants.visibility));
    validator.check(opts.timezone, {'code': 400, 'msg': 'The specified timezone is invalid'}).isValidTimeZone();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var id = AuthzUtil.toId('u', tenantAlias, ShortId.generate());

    var values = {
        'tenantAlias': tenantAlias,
        'displayName': displayName,
        'visibility': opts.visibility,
        'email': opts.email,
        'locale': opts.locale,
        'timezone': opts.timezone,
        'publicAlias': opts.publicAlias,
        'smallPictureUri': opts.smallPictureUri,
        'mediumPictureUri': opts.mediumPictureUri,
        'largePictureUri': opts.lagePictureUri
    };

    var q = Cassandra.constructUpsertCQL('Principals', 'principalId', id, values);
    if (!q) {
        return callback({'code': 500, 'msg': 'Could not create a proper CQL query.'});
    }

    // Create the user
    Cassandra.runQuery(q.query, q.parameters, function (err) {
        if (err) {
            return callback(err);
        }

        var createdUser = new PrincipalsModel.User(tenantAlias, id, displayName, opts);
        PrincipalsEmitter.emit(PrincipalsConstants.events.CREATED_USER, ctx, createdUser);
        return callback(null, createdUser);
    });
};

/**
 * Update a user
 *
 * @param  {Context}        ctx             The current context.
 * @param  {String}         userId          The userId of the user you wish to update.
 * @param  {Object}         profileFields   Object that represent the profile fields that should be updated. Possible keys are visibility, displayName, publicAlias, locale and timezone
 * @param  {Function}       callback        Callback method takes argument `err`.
 * @param  {Object}         callback.err    Error object if something goes wrong.
 * @param  {User}           callback.user   A user object representing the updated profile
 */
var updateUser = module.exports.updateUser = function(ctx, userId, profileFields, callback) {
    callback = callback || function() {};
    profileFields = profileFields || {};

    var profileFieldKeys = _.keys(profileFields);

    // Parameter validation
    var validator = new Validator();
    validator.check(userId, {'code': 400, 'msg': 'A user id must be provided'}).notEmpty();
    // Check that there is at least one updated profile field.
    validator.check(profileFieldKeys.length, {'code': 400, 'msg': 'At least one basic profile field should be specified.'}).min(1);

    // verify that restricted properties aren't set here
    var invalidKeys = _.intersection(PrincipalsDAO.getRestrictedFields(), profileFieldKeys);
    validator.check(invalidKeys.length, {'code': 400, 'msg': 'Restricted property was attempted to be set.'}).max(0);

    // In case a new visibility has been passed in, we check for its validity
    if (profileFields['visibility']) {
        validator.check(profileFields['visibility'], {'code': 400, 'msg': 'An invalid visibility option has been specified'}).isIn(_.values(PrincipalsConstants.visibility));
    }
    if (profileFields['timezone']) {
        validator.check(profileFields['timezone'], {'code': 400, 'msg': 'The specified timezone is invalid'}).isValidTimeZone();
        profileFields.timezone = TZ.getClosestSupportedTimezone(profileFields.timezone);
    }
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a user'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Only update existing users.
    getUser(ctx, userId, function(err, oldUser) {
        if (err) {
            return callback(err);
        }

        // Only the current user or an admin can update a user.
        var principalResource = AuthzUtil.getResourceFromId(userId);
        if (ctx.user().id === userId || ctx.user().isAdmin(principalResource.tenantAlias)) {
            PrincipalsDAO.updatePrincipal(userId, profileFields, function(err) {
                if (err) {
                    return callback(err);
                }

                var newUser = PrincipalsUtil.createUpdatedUser(oldUser, profileFields);
                PrincipalsEmitter.emit(PrincipalsConstants.events.UPDATED_USER, ctx, newUser, oldUser);
                return getUser(ctx, userId, callback);
            });
        } else {
            callback({'code': 401, 'msg': 'You are not authorized to update this user\'s profile.'});
        }
    });
};

/**
 * Get a user from the DB
 *
 * @param  {Context}   ctx             The current context
 * @param  {String}    userId          The userId for the user you wish to retrieve.
 * @param  {Function}  callback        Callback method takes arguments `err` and `user`.
 * @param  {Object}    callback.err    Error object if something goes wrong.
 * @param  {User}      callback.user   The user object.
 */
var getUser = module.exports.getUser = function(ctx, userId, callback) {

    var validator = new Validator();
    validator.check(userId, {'code': 400, 'msg': 'Must provide a user id'}).isValidId();
    validator.check(userId, {'code': 400, 'msg': 'The provided userId is not a user identifier'}).isUserId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    PrincipalsUtil.getPrincipal(ctx, userId, callback);
};

/**
 * Gets the me feed for the current user, if anonymous returns 'anon': true
 * If logged in returns structured me feed object in the callback
 *
 *     {
 *         "profilePath": "/person/u:global:bert",
 *         "id": "u:global:bert",
 *         "displayName": "Bert Pareyn",
 *         "publicAlias": "Bert the Merciful"
 *         "visibility": "private",
 *         "isTenantAdmin": true,
 *         "isGlobalAdmin": false,
 *         "resourceType": "user"
 *         "extra": {
 *             <Extra basic profile fields>
 *         },
 *         "locale": {
 *             "locale": "en_GB",
 *             "timezone": {
 *                 "name": "Europe/London",
 *                 "offset": 1
 *             }
 *         }
 *     }
 *
 * If error returns error object
 *
 * @param  {Context}   ctx            The current context
 * @param  {Function}  callback       Callback method takes arguments `err` and `data`.
 * @param  {Object}    callback.err   Error object if something goes wrong.
 * @param  {Object}    callback.data  The me feed data for the user.
 */
var getMe = module.exports.getMe = function(ctx, callback) {
    if (!ctx.user()) {
        return callback({'code': 200,'msg': {
                'anon': true,
                'tenant': ctx.tenant().compact()
            }
        });
    }

    getUser(ctx, ctx.user().id, function(err, data) {
        if (err) {
            return callback(err);
        }

        // Calculate timezone offset in hours.
        var now = new TZ.Date(ctx.user().timezone);
        var offset = -1 * now.getTimezoneOffset() / 60;

        data.isTenantAdmin = ctx.user().isTenantAdmin(ctx.user().tenant.alias);
        data.isGlobalAdmin = ctx.user().isGlobalAdmin();

        data.locale = {
            'locale': ctx.user().locale,
            'timezone': {
                'name': ctx.user().timezone,
                'offset': offset
            }
        };

        callback(null, data);
    });
};

/**
 * Set a flag that indicates whether a user is a tenant admin.
 * The ctx user must be a tenant or global admin to be able to do this.
 *
 * @param  {Context}   ctx             Context that holds the tenant.
 * @param  {User}      principalId     The user that needs the flag
 * @param  {Boolean}   isAdmin         Flag that indicates whether the provided user should be a tenant admin.
 * @param  {Function}  callback        Callback method
 * @param  {Object}    callback.err    Error object.
 */
var setTenantAdmin = module.exports.setTenantAdmin = function(ctx, principalId, isAdmin, callback) {
    var principalResource = AuthzUtil.getResourceFromId(principalId);
    if (ctx.user() && ctx.user().isAdmin(principalResource.tenantAlias)) {
        _setAdmin(ctx, 'admin:tenant', isAdmin, principalId, callback);
    } else {
        return callback({'code': 401, 'msg': 'You do not have sufficient rights to make someone an admin.'});
    }
};

/**
 * Set a flag that indicates whether a user is a glbal admin.
 * The ctx user must be a global admin to be able to do this.
 *
 * @param  {Context}   ctx             Context that holds the tenant.
 * @param  {User}      user            The user that needs the flag
 * @param  {Boolean}   isAdmin         Flag that indicates whether the provided user should be a global admin.
 * @param  {Function}  callback        Callback method
 * @param  {Object}    callback.err    Error object.
 */
var setGlobalAdmin = module.exports.setGlobalAdmin = function(ctx, principalId, isAdmin, callback) {
    if (ctx.user() && ctx.user().isGlobalAdmin && ctx.user().isGlobalAdmin()) {
        _setAdmin(ctx, 'admin:global', isAdmin, principalId, callback);
    } else {
        return callback({'code': 401, 'msg': 'You do not have sufficient rights to make someone an admin.'});
    }
};

/**
 * Internal method that makes a user an admin. This method will do all the necessary validation
 * of the user ctx and passed in parameters.
 *
 * @param  {Context}        ctx             Context that holds the current user and tenant.
 * @param  {String}         adminType       One of `admin:global` or `admin:tenant`
 * @param  {Boolean}        isAdmin         Flag that indicates whether this user should be an admin or not.
 * @param  {String}         principalId     The uuid of the user that needs to be made an admin.
 * @param  {Function}       callback        Callback method takes argument `err`
 * @param  {Object}         callback.err    Error object.
 * @api private
 */
var _setAdmin = function(ctx, adminType, isAdmin, principalId, callback) {
    if (!PrincipalsUtil.isUser(principalId)) {
        return callback({'code': 400, 'msg': 'The provided principalId is not a user.'});
    }

    // Double-check that this user exists.
    getUser(ctx, principalId, function(err, user) {
        if (err) {
            return callback(err);
        }

        PrincipalsDAO.setAdmin(adminType, isAdmin, principalId, callback);
    });
};
