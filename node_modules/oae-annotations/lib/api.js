var OAE = require('oae-util/lib/oae');
var Cassandra = require('oae-util/lib/cassandra');
var Shortid = require('shortid');
var PrincipalsUtil = require('oae-principals/lib/util');
var _ = require('underscore');

/**
 * A function that delets a specific annotation
 * 
 * @param  {Context}        ctx             Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         revisionID      The revision id of the document the notations are to be placed upon.
 * @param  {String}         annotationID    The id of the annotation that is to be deleted.
 * @param  {Function}       callback        Standard callback function takes arguments 'err'
 * @param  {Object}         callback.err    Standard error object.
 */

var deleteAnnotation = module.exports.deleteAnnotation = function(ctx, revisionId, annotationId, callback){
    Cassandra.runQuery('DELETE ? FROM Annotations WHERE revisionId = ? ',[annotationId, revisionId],function(err){
        if (err) {
            return response.send(err);
        }
    });
    return callback(null);
};

/**
 * A function that updates a specific annotation
 * 
 * @param  {Context}        ctx             Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         revisionID      The revision id of the document the notations are to be placed upon.
 * @param  {String}         page            The page number on wich the annotation wich is to be updated is located.
 * @param  {String}         annotationID    The id of the annotation that is to be deleted.
 * @param  {Object}         Data            The data wich is to be used to replace the annotation.
 * @param  {Function}       callback        Standard callback function takes arguments 'err' and 'data'.
 * @param  {Object}         callback.err    Standard error object.
 * @param  {Sting}          callback.data   A string that represents the location of the annotation
 */

var updateAnnotation = module.exports.updateAnnotation = function(ctx, revisionId, page, annotationId, data, callback){
    // The annotator does not send along the ID in its object so we need to re-append that
    data.id = annotationId;
    data.userId = ctx.user().id;
    Cassandra.runQuery('UPDATE Annotations SET ? = ? WHERE revisionId = ? ',[annotationId, JSON.stringify(data), revisionId],function(err){
        if (err) {
            return callback(err);
        }
        // Annotator asks for a 303 with a link to the location of the annotation
        return callback(null, '/api/annotations/' + revisionId + '/' + page + '/' + annotationId);
    });  
    
};

/**
 * A function that creates an annotation
 * 
 * @param  {Context}        ctx             Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         revisionID      The revision id of the document the notations are to be placed upon.
 * @param  {String}         page            The page number on wich the annotation wich is to be updated is located.
 * @param  {Object}         Data            The data wich is to be used to create the annotation.
 * @param  {Function}       callback        Standard callback function takes arguments 'err' and 'data'.
 * @param  {Object}         callback.err    Standard error object.
 * @param  {Sting}          callback.data   A string that represents the location of the annotation
 */

var createAnnotation = module.exports.createAnnotation = function(ctx, revisionId, page, data, callback){
    // Generate the newId and append it to the data we already have
    data.id = page + '_' + Shortid.generate();
    data.userId = ctx.user().id;
    Cassandra.runQuery('UPDATE Annotations SET ? = ? WHERE revisionId = ?', [data.id, JSON.stringify(data), revisionId], function(err){
        if (err) {
            return callback(err);
        }
        // Annotator asks for a 303 with a link to the location of the annotation
        return callback(null, '/api/annotations/' + revisionId + '/' + page + '/' + data.id);
    });
    
};

/**
 * A function that gets a specific annotation
 * 
 * @param  {Context}        ctx             Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         revisionID      The revision id of the document the notations are to be placed upon.
 * @param  {String}         annotationID    The id of the annotation that is to be returned.
 * @param  {Function}       callback        Standard callback function takes arguments 'err' and 'data'.
 * @param  {Object}         callback.err    Standard error object.
 * @param  {Object}         callback.data   A Json object containing the annotation.
 */

var getAnnotation = module.exports.getAnnotation = function(ctx, revisionId, annotationId, callback){
    Cassandra.runQuery('SELECT ? FROM Annotations WHERE revisionId = ?', [annotationId, revisionId], function(err, rows){
        if (err) {
            return callback(err);
        }
        // We need to clean up the response from cassandra a bit
        var data = JSON.parse(rows[0][0].value);
        PrincipalsUtil.getPrincipal(ctx, data.userId, function(err, user){
           if (err){
               return callback(err);
           } else{
               data.userDisplayName=user.displayName;
               return callback(null, data)
           } 
        });
    });
};

/**
 * A function that gets a all annotations on a page
 * 
 * @param  {Context}        ctx             Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         revisionID      The revision id of the document the notations are to be placed upon.
 * @param  {String}         page            The page number of the annotations that are to be returned.
 * @param  {Function}       callback        Standard callback function takes arguments 'err' and 'data'.
 * @param  {Object}         callback.err    Standard error object.
 * @param  {Object}         callback.data   A Json object containing all the annotations.
 */

var getAnnotations = module.exports.getAnnotations = function(ctx, revisionId, page, callback){
    // Create a int holding the page number so we can manipulate it numericly
    page = parseInt(page, 10);
    var nextPage = page+1;
    /**
     * Query cassandra for all the annotations that are on the page. By
     * asking it to return all the annotations who's id begins with 
     * the current page.
     */ 
    Cassandra.runQuery('SELECT ? .. ? FROM Annotations WHERE revisionId = ?', [page.toString(), nextPage.toString(), revisionId], function(err, rows){
        if (err) {
            return callback(err);
        }
        /**
         * Cassasandra gives a object wich is not completly compatible with 
         * annotator so we need to clean it up a bit.
         */
        parseJson(rows[0], ctx, function(err, data) {
            return callback(null, data);
        });
    });
};

// Strip the un needed information from a string before creating a JSON object from it
var parseJson = function(data, ctx, callback) {
    var userIds = {};
    var parsedData = [];
    _.each(data, function(item) {
        var value = JSON.parse(item.value);
        userIds[value.userId] = 1;
        parsedData.push(value);
    });
    
    // Call getPrincipals to get all the required data.
    PrincipalsUtil.getPrincipals(ctx, _.keys(userIds), function(err, users) {
        if (err){
            return callback(err);
        }
        
        // Safe the users in an array
        var userObjects = {};
        _.each(users, function(user) {
            userObjects[user.id] = user;
        });
        
        // This loop Assigns the pared items to parsedData
        _.each(parsedData, function(item) {
            item.user = userObjects[item.userId];
        });
        
        return callback(null, parsedData);
    });
}
