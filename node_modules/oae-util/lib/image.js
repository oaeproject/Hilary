/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var exec = require('child_process').exec;
var fs = require('fs');
var gm = require('gm');
var path = require('path');
var temp = require('temp');
var util = require('util');

var log = require('oae-logger').logger('oae-util-image');
var Validator = require('oae-util/lib/validator').Validator;

var VALID_EXTENSIONS = ['.jpg', '.jpeg', '.png', '.gif'];

/**
 * Auto orients an image (based on the EXIF Orientation data) and stores it in a temporary file
 *
 * @param  {String}     inputPath               The path to the image to auto orient
 * @param  {Object}     [opts]                  Extra options
 * @param  {String}     [opts.outputPath]       If specified, the oriented image will be written to this location. If left undefined, a temporary path will be generated
 * @param  {Boolean}    [opts.removeInput]      If set to `true`, the input image will be removed
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Object}     callback.file           A file object with some metadata of the oriented file
 * @param  {String}     callback.file.path      The path where the file has been written to
 * @param  {String}     callback.file.name      The name of the file
 * @param  {Number}     callback.file.size      The size of the oriented image (in bytes)
 */
var autoOrient = module.exports.autoOrient = function(inputPath, opts, callback) {
    opts = opts || {};
    var outputPath = opts.outputPath || temp.path({'suffix': getImageExtension(inputPath, '.jpg')});
    gm(inputPath)
    .noProfile()
    .autoOrient()
    .write(outputPath, function(err) {
        if (err) {
            fs.unlink(outputPath, function(err) {
                if (err) {
                    log().warn({'err': err, 'path': outputPath}, 'Could not unlink a file');
                }
            });
            log().error({'err': err}, 'Could not auto orient the image %s', inputPath);
            return callback({'code': 500, 'msg': 'Could not auto orient the image'});
        }
        fs.stat(outputPath, function(err, stat) {
            if (err) {
                fs.unlink(outputPath, function() {
                    if (err) {
                        log().warn({'err': err, 'path': outputPath}, 'Could not unlink a file');
                    }
                });
                log().error({'err': err}, 'Could not get the file system information about %s', outputPath);
                return callback({'code': 500, 'msg': 'Could not retrieve the file information for the cropped file'});
            }
            var file = {
                'path': outputPath,
                'size': stat.size,
                'name': path.basename(outputPath)
            };

            // Return without deleting the file if the caller specified to do so
            if (!opts.removeInput) {
                return callback(null, file);
            }

            // Delete the input file now that we've completed
            fs.unlink(inputPath, function(err) {
                if (err) {
                    log().error({'err': err}, 'Could not unlink the input image');
                    return callback({'code': 500, 'msg': 'Could not unlink the input image'});
                }

                return callback(null, file);
            });
        });
    });
};

/**
 * Crops and resizes an image
 *
 * @param  {String}     imagePath               The path on disk of the image to crop
 * @param  {Number}     selectedArea.x          The x coordinate of the topleft corner to start cropping
 * @param  {Number}     selectedArea.y          The y coordinate of the topleft corner to start cropping
 * @param  {Number}     selectedArea.width      The width of the image that needs to be cropped out
 * @param  {Number}     selectedArea.height     The height of the image that needs to be cropped out
 * @param  {Object[]}   sizes                   An array of image sizes. An image will be generated for each size. Each object needs to specify the width and size for the resized image
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Object}     callback.files          An object where each entry holds a resized file. The keys are of the form `size.width + 'x' + size.height`
 */
var cropAndResize = module.exports.cropAndResize = function(imagePath, selectedArea, sizes, callback) {
    var validator = new Validator();
    validator.check(imagePath, {'code': 400, 'msg': 'A path to the image that you want to crop is missing'}).notNull();
    validator.check(null, {'code': 400, 'msg': 'The coordinates for the area you wish to crop must be specified'}).isObject(selectedArea);
    if (selectedArea) {
        validator.check(selectedArea.x, {'code': 400, 'msg': 'The x-coordinate needs to be a valid integer'}).isInt();
        validator.check(selectedArea.x, {'code': 400, 'msg': 'The x-coordinate needs to be a valid integer'}).min(0);
        validator.check(selectedArea.y, {'code': 400, 'msg': 'The y-coordinate needs to be a valid integer'}).isInt();
        validator.check(selectedArea.y, {'code': 400, 'msg': 'The y-coordinate needs to be a valid integer'}).min(0);
        validator.check(selectedArea.width, {'code': 400, 'msg': 'The width value must be an integer larger than 0'}).isInt();
        validator.check(selectedArea.width, {'code': 400, 'msg': 'The width value must be an integer larger than 0'}).min(1);
        validator.check(selectedArea.height, {'code': 400, 'msg': 'The height value must be an integer larger than 0'}).isInt();
        validator.check(selectedArea.height, {'code': 400, 'msg': 'The height value must be an integer larger than 0'}).min(1);
    }
    validator.check(sizes, {'code': 400, 'msg': 'The desired sizes array is missing'}).notNull();
    if (sizes) {
        validator.check(sizes.length, {'code': 400, 'msg': 'The desired sizes array is empty'}).min(1);
        for (var i = 0; i < sizes.length; i++) {
            validator.check(sizes[i].width, {'code': 400, 'msg': 'The width needs to be a valid integer larger than 0'}).isInt();
            validator.check(sizes[i].width, {'code': 400, 'msg': 'The width needs to be a valid integer larger than 0'}).min(0);
            validator.check(sizes[i].height, {'code': 400, 'msg': 'The width needs to be a valid integer larger than 0'}).isInt();
            validator.check(sizes[i].height, {'code': 400, 'msg': 'The height needs to be a valid integer larger than 0'}).min(0);
        }
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Crop the image
    _cropImage(imagePath, selectedArea, function(err, croppedFile) {
        if (err) {
            return callback(err);
        }
        var files = {};
        var resized = 0;
        var called = false;

        // Use a foreach so that the callback function of resizeImage has the size on the stack
        sizes.forEach(function(size) {

            // Resize the image
            _resizeImage(croppedFile.path, {'width': size.width, 'height': size.height}, function(err, file) {
                resized++;
                if (err && !called) {
                    called = true;
                    return callback(err);
                }

                var key = size.width + 'x' + size.height;
                files[key] = file;
                if (resized === sizes.length && !called) {
                    called = true;

                    // Remove the cropped one before we call the callback
                    fs.unlink(croppedFile.path, function(err) {
                        if (err) {
                            called = true;
                            return callback({'code': 500, 'msg': err});
                        }

                        return callback(null, files);
                    });
                }
            });
        });
    });
};

/**
 * Crops a part out of an image
 *
 * @param  {String}     imagePath               The path on disk of the file that needs to be cropped
 * @param  {Object}     selectedArea            The area that needs to be cropped out
 * @param  {Number}     selectedArea.x          The x coordinate of the topleft corner to start cropping
 * @param  {Number}     selectedArea.y          The y coordinate of the topleft corner to start cropping
 * @param  {Number}     selectedArea.width      The width of the box that needs to be cropped out
 * @param  {Number}     selectedArea.height     The height of the box that needs to be cropped out
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Object}     callback.file           A file object with some metadata of the cropped file
 * @param  {String}     callback.file.path      The path where the file has been written to
 * @param  {String}     callback.file.name      The name of the file
 * @param  {Number}     callback.file.size      The size in bytes of the cropped image
 */
var cropImage = module.exports.cropImage = function(imagePath, selectedArea, callback) {
    var validator = new Validator();
    validator.check(imagePath, {'code': 400, 'msg': 'A path to the image that you want to crop is missing'}).notNull();
    validator.check(null, {'code': 400, 'msg': 'The coordinates for the area you wish to crop must be specified'}).isObject(selectedArea);
    if (selectedArea) {
        validator.check(selectedArea.x, {'code': 400, 'msg': 'The x-coordinate needs to be a valid integer'}).isInt();
        validator.check(selectedArea.x, {'code': 400, 'msg': 'The x-coordinate needs to be a valid integer'}).min(0);
        validator.check(selectedArea.y, {'code': 400, 'msg': 'The y-coordinate needs to be a valid integer'}).isInt();
        validator.check(selectedArea.y, {'code': 400, 'msg': 'The y-coordinate needs to be a valid integer'}).min(0);
        validator.check(selectedArea.width, {'code': 400, 'msg': 'The width value must be an integer larger than 0'}).isInt();
        validator.check(selectedArea.width, {'code': 400, 'msg': 'The width value must be an integer larger than 0'}).min(1);
        validator.check(selectedArea.height, {'code': 400, 'msg': 'The height value must be an integer larger than 0'}).isInt();
        validator.check(selectedArea.height, {'code': 400, 'msg': 'The height value must be an integer larger than 0'}).min(1);
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    _cropImage(imagePath, selectedArea, callback);
};

/**
 * Internal method that performs the actual cropping
 *
 * @param  {String}     imagePath               The path on disk of the file that needs to be cropped
 * @param  {Object}     selectedArea            The area that needs to be cropped out
 * @param  {Number}     selectedArea.x          The x coordinate of the topleft corner to start cropping
 * @param  {Number}     selectedArea.y          The y coordinate of the topleft corner to start cropping
 * @param  {Number}     selectedArea.width      The width of the box that needs to be cropped out
 * @param  {Number}     selectedArea.height     The height of the box that needs to be cropped out
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Object}     callback.file           A file object with some metadata of the cropped file
 * @param  {String}     callback.file.path      The path where the file has been written to
 * @param  {String}     callback.file.name      The name of the file
 * @param  {Number}     callback.file.size      The size in bytes of the cropped image
 * @api private
 */
var _cropImage = function(imagePath, selectedArea, callback) {
    // Make sure that the pic is big enough
    gm(imagePath).size(function (err, size) {
        if (err) {
            log().error({'err': err}, 'Could not get the image size for the large image');
            return callback({'code': 500, 'msg': 'Could not get the image size for the large image'});
        }

        // Ensure we do not try and crop outside of the image size boundaries
        if (selectedArea.x > size.width ||
            selectedArea.y > size.height ||
            selectedArea.width > (size.width - selectedArea.x) ||
            selectedArea.height > (size.height - selectedArea.y)) {
            return callback({'code': 400, 'msg': 'You cannot crop outside of the image'});
        }

        // Crop it and write it to a temporary file
        var tempPath = temp.path({'suffix': getImageExtension(imagePath, '.jpg')});
        gm(imagePath)
        .crop(selectedArea.width, selectedArea.height, selectedArea.x, selectedArea.y)
        .noProfile()
        .write(tempPath, function(err) {
            if (err) {
                fs.unlink(tempPath, function() {
                    if (err) {
                        log().warn({'err': err, 'path': tempPath}, 'Could not unlink a file');
                    }
                });
                log().error({'err': err}, 'Could not crop the image %s', imagePath);
                return callback({'code': 500, 'msg': 'Could not crop the image'});
            }
            fs.stat(tempPath, function(err, stat) {
                if (err) {
                    fs.unlink(tempPath, function() {
                        if (err) {
                            log().warn({'err': err, 'path': tempPath}, 'Could not unlink a file');
                        }
                    });
                    log().error({'err': err}, 'Could not get the file system information about %s', tempPath);
                    return callback({'code': 500, 'msg': 'Could not retrieve the file information for the cropped file'});
                }
                var file = {
                    'path': tempPath,
                    'size': stat.size,
                    'name': path.basename(tempPath)
                };

                return callback(null, file);
            });
        });
    });
};

/**
 * Resizes an image to the specified size
 *
 * @param  {String}     imagePath               The path on disk of the file that needs to be resized
 * @param  {Object}     size                    The new size of the image
 * @param  {Number}     size.width              The width that the image should be resized to
 * @param  {Number}     size.height             The height that the image should be resized to
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Object}     callback.file           A file object with some metadata of the resized file
 * @param  {String}     callback.file.path      The path where the file has been written to
 * @param  {String}     callback.file.name      The name of the file
 * @param  {Number}     callback.file.size      The size in bytes of the resized image
 */
var resizeImage = module.exports.resizeImage = function(imagePath, size, callback) {
    var validator = new Validator();
    validator.check(imagePath, {'code': 400, 'msg': 'A path to the image that you want to resize is missing'}).notNull();
    validator.check(null, {'code': 400, 'msg': 'The size must be specified'}).isObject(size);
    if (size) {
        validator.check(size.width, {'code': 400, 'msg': 'The width needs to be a valid integer larger than 0'}).isInt();
        validator.check(size.width, {'code': 400, 'msg': 'The width needs to be a valid integer larger than 0'}).min(0);
        validator.check(size.height, {'code': 400, 'msg': 'The height needs to be a valid integer larger than 0'}).isInt();
        validator.check(size.height, {'code': 400, 'msg': 'The height needs to be a valid integer larger than 0'}).min(0);
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    _resizeImage(imagePath, size, callback);
};

/**
 * Internal method that resizes an image to the specified size
 *
 * @param  {String}     imagePath               The path on disk of the file that needs to be resized
 * @param  {Object}     size                    The new size of the image
 * @param  {Number}     size.width              The width that the image should be resized to
 * @param  {Number}     size.height             The height that the image should be resized to
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Object}     callback.file           A file object with some metadata of the resized file
 * @param  {String}     callback.file.path      The path where the file has been written to
 * @param  {String}     callback.file.name      The name of the file
 * @param  {Number}     callback.file.size      The size in bytes of the resized image
 * @api private
 */
var _resizeImage = function(imagePath, size, callback) {
    var suffix = size.width + 'x' + size.height + getImageExtension(imagePath, '.jpg');
    var tempPath = temp.path({'suffix': suffix});

    gm(imagePath)
        .resize(size.width, size.height)
        .write(tempPath, function(err) {
            if (err) {
                fs.unlink(tempPath, function() {
                    if (err) {
                        log().warn({'err': err, 'path': tempPath}, 'Could not unlink a file');
                    }
                });
                log().error({'err': err}, 'Could not resize the image %s', imagePath);
                return callback({'code': 500, 'msg': 'Could not resize the image'});
            }
            fs.stat(tempPath, function(err, stat) {
                if (err) {
                    fs.unlink(tempPath, function() {
                        if (err) {
                            log().warn({'err': err, 'path': tempPath}, 'Could not unlink a file');
                        }
                    });
                    log().error({'err': err}, 'Could not get the file system information for %s', tempPath);
                    return callback({'code': 500, 'msg': 'Could not get the file information for the resized file'});
                }
                var file = {
                    'path': tempPath,
                    'size': stat.size,
                    'name': path.basename(tempPath)
                };

                return callback(null, file);
            });
        });
};

/**
 * Get an image extension given a source filename. If the source extension is not a valid extension,
 * the fallback will be used
 *
 * @param  {String}     source      The input file on which to base the extension. e.g., notAnImage.zip
 * @param  {String}     [fallback]  The fallback extension. Defaults to '.jpg'
 * @return {String}                 A proper image extension. e.g., '.jpg'
 */
var getImageExtension = module.exports.getImageExtension = function(source, fallback) {
    fallback = fallback || '.jpg';
    var ext = path.extname(source);
    if (!_.contains(VALID_EXTENSIONS, ext)) {
        ext = fallback;
    }
    return ext;
};


/**
 * Convert an input file to a JPG. The following conversions will take place:
 *
 *  * All animations will be removed, the resulting image will be the very first frame
 *  * All tranparent pixels will be converted to white pixels
 *
 * @param  {String}     inputPath               The path where the image can be found on disk
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Object}     callback.file           A file object with some metadata of the resized file
 * @param  {String}     callback.file.path      The path where the file has been written to
 * @param  {String}     callback.file.name      The name of the file
 * @param  {Number}     callback.file.size      The size of the resized image (in bytes)
 */
var convertToJPG = module.exports.convertToJPG = function(inputPath, callback) {
    var validator = new Validator();
    validator.check(inputPath, {'code': 400, 'msg': 'A path to the image that you want to resize is missing'}).notNull();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var conversionPath = inputPath;
    if (inputPath.lastIndexOf('.gif') === (inputPath.length - 4)) {
        // If we're dealing with a GIF, we use the first frame
        conversionPath  = inputPath + '[0]';
    }
    gm(conversionPath).size(function (err, size) {
        if (err) {
            log().error({'err': err}, 'Unable to get size of the image that should be converted to JPG');
            return callback({'code': 500, 'msg': err});
        }

        /*!
         * The below command is responsible for generating a somewhat decent looking JPG.
         * We superimpose the original image over a white image of the same size to ensure
         * that formats which can contain transparant pixels look reasonably well in a JPG.
         *
         * gm convert -size 220x276 xc:white -compose over img.png -flatten flattened.jpg
         *
         * There doesn't seem to be a good way to execute the proper command with the `gm` module,
         * so we have to do it manually here.
         */
        var outputPath = temp.path({'suffix': '.jpg'});
        var cmd = util.format('gm convert -size %dx%d xc:white -compose over %s -flatten %s', size.width, size.height, conversionPath, outputPath);

        var now = Date.now();
        log().trace({'cmd': cmd}, 'Begin converting image into a JPG');
        exec(cmd, {'timeout': 4000}, function (err, stdout, stderr) {
            var durationMs = Date.now() - now;
            if (err) {
                log().error({'err': err}, 'Unable to convert input image to JPG (Took %sms)', durationMs);
                return callback({'code': 500, 'msg': 'Failed converting input image to JPG'});
            }

            log().trace('Finished converting image into a JPG (Took %sms)', durationMs);

            fs.stat(outputPath, function(err, stat) {
                if (err) {
                    fs.unlink(outputPath, function() {
                        if (err) {
                            log().warn({'err': err, 'path': outputPath}, 'Could not unlink a file');
                        }
                    });
                    log().error({'err': err}, 'Could not get the file system information about %s', outputPath);
                    return callback({'code': 500, 'msg': 'Could not retrieve the file information for the converted file'});
                }
                var file = {
                    'path': outputPath,
                    'size': stat.size,
                    'name': path.basename(outputPath)
                };
                return callback(null, file);
            });
        });
    });
};
