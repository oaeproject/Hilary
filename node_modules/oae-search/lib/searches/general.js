/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var _ = require('underscore');
var AuthzAPI = require('oae-authz');
var log = require('oae-logger').logger('oae-search-general');
var SearchUtil = require('oae-search/lib/util');
var SearchModel = require('oae-search/lib/model');
var client = require('oae-search/lib/elasticsearch');

/**
 * General search that searches a 'general' analyzed field on content, scoping it by user access.
 *
 * @param   {Context}       ctx                 The context of the current request
 * @param   {Object}        transformers        A hash keyed by resource type, and the value is a function that transforms search docs
 *                                              into docs that can be displayed to the current user.
 * @param   {Object}        opts                General search options
 * @param   {Function}      callback            Invoked when the process completes
 * @param   {Object}        callback.err        An error that occurred, if any
 * @param   {SearchResult}  callback.results    An object that represents the results of the query
 */
module.exports = function(ctx, transformers, opts, callback) {
    if (ctx.user() && !ctx.user().isGlobalAdmin() && opts.resourceType !== 'user') {
        // we'll need to know the group membership of this user to scope by content they have access to
        AuthzAPI.getPrincipalMemberships(ctx.user().id, function(err, groups) {
            if (err) {
                return callback(err);
            }

            opts.access = groups;
            _search(ctx, transformers, opts, callback);
        });
    } else {
        _search(ctx, transformers, opts, callback);
    }
}

/**
 * Perform the search that searches a 'general' analyzed field on content, scoping it by user access. This is delegated from the
 * `module.exports` function for convenience, as it will access the members array only if necessary.
 *
 * @param   {Context}       ctx                 The context of the current request
 * @param   {Object}        transformers        A hash keyed by resource type, and the value is a function that transforms search docs
 *                                              into docs that can be displayed to the current user.
 * @param   {Object}        opts                General search options
 * @param   {Function}      callback            Invoked when the process completes
 * @param   {Object}        callback.err        An error that occurred, if any
 * @param   {SearchResult}  callback.results    An object that represents the results of the query
 */
var _search = function(ctx, transformers, opts, callback) {
    var data = {};

    // the query object for the Query DSL
    // if we're search "all", we need to use a query_string query (as it supports the wildcard).
    // if we aren't searching for all, then we should use a match query to avoid errors in invalid query_string syntax
    var query = (opts.q === '*') ? {
        'query_string': {
            'default_field': 'general',
            'query': '*'
        }
    } : {
        'match': {
            'general': {
                'query': opts.q,
                'operator': 'and'
            }
        }
    };

    // the filter object for the Query DSL
    var filter = null;

    // the type filter will filter by a particular document type (content, user, group)
    var typeFilter = (opts.resourceType !== 'all') ? SearchUtil.filterTerm('_type', opts.resourceType) : null;

    // the access filter will filter by the user's group membership
    var accessFilter = SearchUtil.filterTerms('access', opts.access);

    if (ctx.user() && ctx.user().isGlobalAdmin()) {
        // if user is global admin, forget filtering by members and visibility, just query *everything*
        filter = typeFilter;
    } else if (ctx.user() && ctx.user().isTenantAdmin(ctx.tenant().alias)) {
        // if the user is the tenant admin, query everything only for their tenant, and apply regular "logged in user" filters
        // on other content.
        filter = SearchUtil.filterAnd(
            typeFilter,
            SearchUtil.filterOr(
                SearchUtil.filterTerm('tenantId', ctx.tenant().alias),
                SearchUtil.filterTerms('visibility', ['public', 'loggedin']),
                accessFilter
            )
        );
    } else if (ctx.user()) {
        // if user is authenticated, query for public, loggedin, or access-scoped
        filter = SearchUtil.filterAnd(
            typeFilter,
            SearchUtil.filterOr(
                SearchUtil.filterTerms('visibility', ['public', 'loggedin']),
                accessFilter
            )
        );
    } else {
        // for anonymous users, only show public content
        filter = SearchUtil.filterAnd(
            typeFilter,
            SearchUtil.filterTerm('visibility', 'public')
        );
    }

    // wrap the query and filter into the top-level Query DSL "query" object
    data = SearchUtil.createQuery(query, filter, {
        from: opts.from,
        size: opts.size,
        sort: {
            // this sort key is the field name of the document that we're sorting on
            'sort': opts.sort
        }
    });

    client.search(data, null, function(err, results) {
        if (err) {
            return callback(err);
        }

        _transformSearchResults(ctx, transformers, results, callback);
    });
}

/**
 * Transform the raw search result fro ElasticSearch into a `SearchResult` that can be returned to the client.
 *
 * @param   {Context}       ctx                 The context of the current request
 * @param   {Object}        transformers        An object keyed by the resource type, and the value is the transformer object that can
 *                                              transform a set of search documents into client-viewable documents
 * @param   {Object}        results             The search results sent back from ElasticSearch
 * @param   {Function}      callback            Invoked when the process completes
 * @param   {Object}        callback.err        An error that occurred, if any
 * @param   {SearchResult}  callback.results    The search results that can be sent to the client
 */
var _transformSearchResults = function(ctx, transformers, results, callback) {
    var hits = results.hits;
    if (!hits || !hits.hits || hits.hits.length === 0) {
        return callback(null, new SearchModel.SearchResult(0, []));
    } else {

        // aggregate all the documents to be keyed by type
        var total = hits.total;
        var docsByType = {};
        var docIdOrdering = {};
        var hits = hits.hits;
        for (var i = 0; i < hits.length; i++) {
            var doc = hits[i];
            var id = doc._id;
            var type = doc._type;

            // if transformer does not exist, pass it through the default "raw" transformer
            if (!transformers[type]) {
                type = '*';
            }

            if (!docsByType[type]) {
                docsByType[type] = {};
            }
            docsByType[type][id] = doc;
            docIdOrdering[id] = i;
        }

        // run all the documents through the document transformers for their particular type
        var transformersToRun = _.keys(docsByType).length;
        var transformersComplete = 0;
        var transformErr = null;
        var transformedDocs = {};
        var _monitorTransformers = function(err, docs) {
            if (transformErr) {
                // nothing to do, we've already returned because of an error.
            } else if (err) {
                transformErr = err;
                return callback(transformErr);
            } else {

                // merge the docs from this iteration
                _.extend(transformedDocs, docs);

                transformersComplete++;
                if (transformersComplete >= transformersToRun) {

                    // we're done all transformations, reorder the docs and send back the response
                    var orderedDocs = _orderDocs(transformedDocs, docIdOrdering);
                    return callback(null, new SearchModel.SearchResult(total, orderedDocs));
                }
            }
        }

        // execute all transformers asynchronously from one another. _monitorTransformers will keep track fo their completion.
        for (var type in docsByType) {
            transformers[type](ctx, 'general', docsByType[type], _monitorTransformers);
        }
    }
}

/**
 * Order the docs in the given hash according to the given orderSpec.
 *
 * @param   {Object}    docsHash    A hash of search documents, keyed by the document id.
 * @param   {Object}    orderSpec   A hash keyed by the search document id, and the value is the number indicating its position in the
 *                                  result
 * @return  {Object[]}              An array of the search documents in the `docsHash`, in the order specified by the `orderSpec`
 */
var _orderDocs = function(docsHash, orderSpec) {
    var docs = _.values(docsHash);
    docs.sort(function(one, other) {
        return orderSpec[one._id] - orderSpec[other._id];
    });
    return docs;
}
