/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var log = require('oae-logger').logger('oae-publications');
var Validator = require('oae-util/lib/validator').Validator;

var AuthenticationAPI = require('oae-authentication');
var AuthenticationDAO = require('oae-authentication/lib/internal/dao');
var AuthzUtil = require('oae-authz/lib/util');
var ConfigAPI = require('oae-config');
var OaeUtil = require('oae-util/lib/util');
var PrincipalsUtil = require('oae-principals/lib/util');

var PublicationsConfig = ConfigAPI.config('oae-publications');
var PublicationsConstants = require('./constants').PublicationsConstants;
var PublicationsDAO = require('./internal/dao');
var PublicationsUtil = require('./util');


//////////////////
//  INGESTION   //
//////////////////

/**
 * Exposes the ingester API with which ingesters can ingest and/or link publication.
 * The exposed functions on this object will bypass any security checks, so please ensure careful usage.
 */
var IngesterAPI = module.exports.IngesterAPI = {};

/**
 * Ingests a publication without performing any access checks.
 * This method is only intended to be used by Publication ingesters. Any other codepaths should use the `createPublication` method.
 *
 * @param  {Publication}   publication              The publication to ingest
 * @param  {String[]}       sourceIds               An array of source identifiers
 * @param  {Function}       callback                Standard callback method
 * @param  {Object}         callback.err            Standard error object
 * @param  {Object}         callback.publication    The ingested publication
 * @param  {String}         callback.result         The result of the ingestion process. This will be one of `PublicationsConstants.ingestionResult` and will indicate whether the publication has been created, updated or ignored
 */
IngesterAPI.ingestPublication = function(publication, sourceIds, callback) {
    var validator = new Validator();

    // Verify the publication object
    validator.check(null, {'code': 400, 'msg': 'Missing publication'}).isObject(publication);
    if (_.isObject(publication)) {
        // Check the required parameters
        var parameters = ['displayName', 'publicationType', 'date', 'authors'];
        _.each(parameters, function(parameter) {
            validator.check(publication[parameter], {'code': 400, 'msg': 'Missing ' + parameter}).notEmpty();
        });
        validator.check(publication.publicationType, {'code': 400, 'msg': 'Unknown publication type'}).isIn(_.values(PublicationsConstants.publicationTypes));
        validator.check(publication.date, {'code': 400, 'msg': 'The publication date is malformed'}).isInt();

        // Check that at least one author has been provided
        validator.check(null, {'code': 400, 'msg': 'Authors should be provided as an array'}).isArray(publication.authors);
        if (publication.authors) {
            validator.check(publication.authors.length, {'code': 400, 'msg': 'At least one author should be provided'}).min(1);
        }
    }
    // Verify the sources
    validator.check(sourceIds, {'code': 400, 'msg': 'Missing source IDs'}).isArray(sourceIds);
    if (_.isArray(sourceIds)) {
        validator.check(sourceIds.length, {'code': 400, 'msg': 'At least one source ID should be provided'}).min(1);

        _.each(sourceIds, function(sourceId) {
            validator.check(sourceId, {'code': 400, 'msg': 'Empty source IDs are not allowed`'}).notEmpty();
            validator.check(sourceId, {'code': 400, 'msg': 'A source ID should hold the form `<source name>#<id at source>`'}).contains('#');
        });
    }

    if (validator.hasErrors()) {
        log().error({'err': validator.getFirstError(), 'publication': publication, 'sourceIds': sourceIds}, 'Ingest publication validation error');
        return callback(validator.getFirstError());
    }

    // Check if a publication with this source ID already exists
    PublicationsDAO.getPublicationsBySourceIds(sourceIds, function(err, publicationsBySource) {
        if (err) {
            return callback(err);
        }

        // Get the uniq publications
        var publicationsById = {};
        _.each(publicationsBySource, function(publication) {
            publicationsById[publication.id] = publication;
        });
        var publications = _.values(publicationsById);

        // If nothing was found we're dealing with a publication that we've not seen before previously
        if (publications.length === 0) {
            PublicationsDAO.createPublication(publication, sourceIds, function(err, createdPublication) {
                if (err) {
                    return callback(err);
                }
                return callback(null, createdPublication, PublicationsConstants.ingestionResult.CREATED);
            });

        // If we got a hit, we already ingested this publication (possible with another source ID though)
        // We try to update it and add our sources
        } else if (publications.length === 1) {
            PublicationsDAO.updatePublication(publication, publications[0], sourceIds, function(err, updatedPublication) {
                if (err) {
                    return callback(err);
                }
                return callback(null, updatedPublication, PublicationsConstants.ingestionResult.UPDATED);
            });

        /*
         * This situation can ocurr when 2 harvesters ingested publications from different sources previously.
         * For example:
         *     - Harvester 1 ingests a publication harvested from arxiv
         *     - Harvester 2 ingests a publication harvested from pubmed
         *     - Harvester 3 (this one) ingests a publication that it knew was available on arxiv and pubmed (and possibly others)
         *
         * This is obviously a bit annoying. Especially if both publications are linked to different content items.
         * TODO: Check if they are linked to a piece of content.
         * If none of them are, or, if only one of them is, we can probably do a merge.
         * If more than 1 is linked, we have a problem.
         */
        } else if (publications.length > 1) {
            log().warn({'publication': publication, 'existingPublications': publications}, 'Found duplicate publications that could not be resolved automatically');
            return callback(null, publication, PublicationsConstants.ingestionResult.IGNORED);
        }
    });
};

/**
 * Links an OAE user to a publication. The authorname that is used in the set should be provided.
 * This does not necessarily have to be an exact match as some disambiguiation will be attempted.
 *
 * @param  {String}     publicationId   The publication to link the user to
 * @param  {String}     authorName      The name of the user as its stored in the external system/on the publication
 * @param  {String}     userId          The OAE user ID to link
 * @param  {Function}   callback        Standard callback function
 */
IngesterAPI.linkPublicationToUser = function(publicationId, authorName, userId, callback) {
    var validator = new Validator();
    _validatePublicationId(validator, publicationId);
    validator.check(authorName, {'code': 400, 'msg': 'Missing author name'}).notEmpty();
    validator.check(userId, {'code': 400, 'msg': 'Missing or invalid userId'}).isUserId();
    if (validator.hasErrors()) {
        log().error({'err': validator.getFirstError()}, 'Link publication to user validation error');
        return callback(validator.getFirstError());
    }

    PublicationsDAO.getPublication(publicationId, function(err, publication) {
        if (err) {
            return callback(err);
        }

        return _linkPublicationToUser(publication, authorName, userId, callback);
    });
};

/**
 * Links an OAE user to a publication. The authorname that is used in the set should be provided.
 * This does not necessarily have to be an exact match as some disambiguiation will be attempted.
 *
 * @param  {Publication}    publication         The publication to link the user to
 * @param  {String}         authorName          The name of the user as its stored in the external system/on the publication
 * @param  {String}         userId              The OAE user ID to link
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        Standard error object, if any
 * @param  {String}         callback.result     Result of the link operation. One of `PublicationsConstants.linkResult`
 * @api private
 */
var _linkPublicationToUser = function(publication, authorName, userId, callback) {
    // Ensure that is user is not already in the author set
    var isInAuthorSet = _.contains(publication.authors, userId);
    if (isInAuthorSet) {
        return callback(null, PublicationsConstants.linkResult.PRESENT);
    }

    var plainTextAuthors = _.filter(publication.authors, function(author) {
        return (typeof author === 'string' && !AuthzUtil.isUserId(author));
    });

    // Find the best match
    var index = PublicationsUtil.findAuthorInSet(authorName, publication.authors, 0.85);
    if (index === -1) {
        log().warn({'publication': publication, 'authorName': authorName, 'userId': userId}, 'Could not find the provided author in the set of authors linked to the publication, not linking');
        return callback(null, PublicationsConstants.linkResult.NOTFOUND);
    }
    var storedAuthorName = publication.authors[index];

    log().info({'publication': publication, 'authorName': authorName, 'storedAuthorName': storedAuthorName, 'userId': userId}, 'Linking publication to a user');
    PublicationsDAO.linkPublicationToUser(publication, storedAuthorName, userId, function(err) {
        if (err) {
            return callback();
        }

        return callback(null, PublicationsConstants.linkResult.LINKED);
    });
};

////////////////
// Public API //
////////////////

/**
 * Creates a publication if and only if the current user is an administrator on the tenant or users are allowed to
 * create their own publications.
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {Publication}    publication             The publication to create
 * @param  {String[]}       sourceIds               An array of source identifiers
 * @param  {Function}       callback                Standard callback method
 * @param  {Object}         callback.err            Standard error object
 * @param  {Object}         callback.publication    The ingested publication
 * @param  {String}         callback.result         The result of the ingestion process. This will be one of `PublicationsConstants.ingestionResult` and will indicate whether the publication has been created, updated or ignored
 */
var createPublication = module.exports.createPublication = function(ctx, publication, sourceIds, callback) {
    var allowed = _canEnterData(ctx);
    if (!allowed) {
        return callback({'code': 401, 'msg': 'Only administrators are allowed to create publications'});
    }

    sourceIds = _.compact(sourceIds);
    IngesterAPI.ingestPublication(publication, sourceIds, callback);
};


/**
 * Links an OAE user to a publication. The authorname that is used in the set should be provided.
 * This does not necessarily have to be an exact match as some disambiguiation will be attempted.
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     publicationId   The publication to link the user to
 * @param  {String}     authorName      The name of the user as its stored in the external system/on the publication
 * @param  {String}     userId          The OAE user ID to link
 * @param  {Function}   callback        Standard callback function
 */
var linkPublicationToUser = module.exports.linkPublicationToUser = function(ctx, publicationId, authorName, userId, callback) {
    var allowed = _canEnterData(ctx);
    if (!allowed) {
        return callback({'code': 401, 'msg': 'Only administrators are allowed to link publications'});
    }

    if (!ctx.user().isAdmin(ctx.tenant().alias) && ctx.user().id !== userId) {
        return callback({'code': 401, 'msg': 'You can only link your own user account to a publication'});
    }

    IngesterAPI.linkPublicationToUser(publicationId, authorName, userId, callback);
};

//////////////////
//  RETRIEVAL   //
//////////////////

/**
 * Retrieves a set of publications for a user
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}         userId                  The OAE user id for whom the publications should be retrieved
 * @param  {String}         start                   The publication ordering token from which to start fetching publications (see `nextToken` in callback params)
 * @param  {Number}         limit                   The amount of publications that should be retrieved
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object, if any
 * @param  {Publication[]}  callback.publications   The publications for that user. If there are any OAE users in the co-author list, it will list their OAE profile. Otherwise, the plain-text author string will be provided
 * @param  {String}         callback.nextToken      The value to provide in the `start` parameter to get the next set of results
 */
var getPublicationsForUser = module.exports.getPublicationsForUser = function(ctx, userId, start, limit, callback) {
    var validator = new Validator();
    validator.check(userId, {'code': 400, 'msg': 'Missing or invalid userId'}).isUserId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    limit = OaeUtil.getNumberParam(limit, 25, 1);
    PublicationsDAO.getPublicationsForUser(userId, start, limit, function(err, publications, nextToken) {
        if (err) {
            return callback(err);
        }

        if (publications.length === 0) {
            return callback(null, [], null);
        }

        _augmentPublicationsWithUserProfiles(ctx, publications, function(err, publications) {
            if (err) {
                return callback(err);
            }

            return callback(null, publications, nextToken);
        });
    });
};

/**
 * Gets a publication by its ID
 *
 * @param  {Context}        ctx                     The current execution context
 * @param  {String}         publicationId           The ID of the publication to retrieve
 * @param  {Function}       callback                Standard callback method
 * @param  {Object}         callback.err            Standard error object
 * @param  {Publication}    callback.publication    The retrieved publication
 */
var getPublication = module.exports.getPublication = function(ctx, publicationId, callback) {
    var validator = new Validator();
    _validatePublicationId(validator, publicationId);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    PublicationsDAO.getPublication(publicationId, function(err, publication) {
        if (err) {
            return callback(err);
        }

        _augmentPublicationsWithUserProfiles(ctx, [publication], function(err, publications) {
            if (err) {
                return callback(err);
            }

            return callback(null, publications[0]);
        });
    });
};

/**
 * Replaces any user IDs in the set of authors with their full OAE profile
 *
 * @param  {RestContext}        ctx                     The current execution context
 * @param  {Publication[]}      publications            A set of publications
 * @param  {Function}           callback                Standard callback method
 * @param  {Object}             callback.err            Standard error object
 * @param  {Publication[]}      callback.publications   The augmented publications
 * @api private
 */
var _augmentPublicationsWithUserProfiles = function(ctx, publications, callback) {
    // Get the users who co-authored some of these publications
    var userIds = [];
    _.each(publications, function(publication) {
        userIds = userIds.concat(publication.authors);
    });

    userIds = _.chain(userIds).uniq().compact().filter(function(userId) {
        return AuthzUtil.isUserId(userId);
    }).value();

    PrincipalsUtil.getPrincipals(ctx, userIds, function(err, principals) {
        if (err) {
            return callback(err);
        }

        _.each(publications, function(publication) {
            var authors = [];
            _.each(publication.authors, function(authorId) {
                var principal = _.find(principals, function(principal, principalId) { return principalId === authorId; });
                if (principal) {
                    authors.push(principal);
                } else {
                    authors.push(authorId);
                }
            });
            publication.authors = authors;
        });

        return callback(null, publications);
    });
};

/**
 * Because publication IDs aren't tied to a tenant we can't use the typical resource ID validator.
 * This method will validate the given publication ID with the other available methods on the validator object.
 *
 * @param  {Validator}  validator       A validator instance
 * @param  {String}     publicationId   The publication ID to validate
 * @api private
 */
var _validatePublicationId = function(validator, publicationId) {
    validator.check(publicationId, {'code': 400, 'msg': 'Missing publicationId'}).notEmpty();
    if (publicationId) {
        validator.check(publicationId[0], {'code': 400, 'msg': 'Malformed publicationId'}).is('p');
    }
};

/**
 * Checks if a user is allowed to enter any publication related data
 *
 * @param  {Context}    ctx     The current execution context
 * @return {Boolean}            `true` if the user can enter data, `false` otherwise
 * @api private
 */
var _canEnterData = function(ctx) {
    if (!ctx.user()) {
        return false;
    }

    var allowUserEntry = PublicationsConfig.getValue(ctx.tenant().alias, 'publications', 'allowUserEntry');
    if (!allowUserEntry && !ctx.user().isAdmin(ctx.tenant().alias)) {
        return false;
    }

    return true;
};
