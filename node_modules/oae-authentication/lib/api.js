/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var events = require('events');
var passport = require('passport');
var util = require('util');

var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var ConfigAPI = require('oae-config');
var Context = require('oae-context').Context;
var Locking = require('oae-util/lib/locking');
var OaeEmitter = require('oae-util/lib/emitter');
var OaeServer = require('oae-util/lib/server');
var PrincipalsAPI = require('oae-principals');
var TenantsAPI = require('oae-tenants');
var log = require('oae-logger').logger('oae-authentication');
var Validator = require('oae-authz/lib/validator').Validator;

var AuthenticationConfig = ConfigAPI.config('oae-authentication');
var AuthenticationConstants = require('oae-authentication/lib/constants').AuthenticationConstants;
var AuthenticationDAO = require('oae-authentication/lib/internal/dao');
var AuthenticationUtil = require('oae-authentication/lib/util');
var LoginId = require('oae-authentication/lib/model').LoginId;

var globalTenantAlias = null;

// Holds the strategies for each tenant
var strategies = {};

// Setup functions for different strategies, keyed by the strategy name
var strategySetup = {};

// When a tenant starts up, configure it's authentication strategies
TenantsAPI.on('start', function(tenant) {
    refreshStrategies(tenant);
});

// When the server has started up, we enable all the strategies for all the tenants
OaeEmitter.on('ready', function() {
    _refreshAllTenantStrategies();
});

ConfigAPI.on('update', function(tenantAlias) {
    if (tenantAlias === globalTenantAlias) {
        // We updated the global tenant, which means we'll have to update all tenant authentication strategies, as they may have changed transiently
        _refreshAllTenantStrategies();
    } else {
        var tenant = TenantsAPI.getTenant(tenantAlias);
        if (!tenant) {
            return log().error({'tenantAlias': tenantAlias}, 'Error fetching tenant to update authentication configuration.');
        }

        refreshStrategies(tenant);
    }
});

/**
 * ### Events
 *
 * The `AuthenticationAPI`, as enumerated in `AuthenticationConstants.events`, emits the following events:
 *
 * * `refreshedStrategies(tenant)`: The authentication strategies have been refreshed with the current configuration. The tenant that was refreshed is returned as a `Tenant` object.
 */
var AuthenticationAPI = module.exports = new events.EventEmitter();

/**
 * Initializes the configuration of the authentication module.
 *
 * @param  {String} globalTenantAlias   The alias of the global tenant
 */
var init = module.exports.init = function(_globalTenantAlias) {
    globalTenantAlias = _globalTenantAlias;
};



////////////////////////
////////////////////////
// USER ID MANAGEMENT //
////////////////////////
////////////////////////

/**
 * Check whether or not a user with a certain username already exists on a given tenant
 *
 * @param  {Context}   ctx                The current context
 * @param  {String}    username           The username that we want to check existence for
 * @param  {Function}  callback           Standard callback function
 * @param  {Object}    callback.err       An error that occured, if any
 * @param  {Boolean}   callback.exists    Whether or not the username exists on the current tenant
 */
var localUsernameExists = module.exports.localUsernameExists = function(ctx, username, callback) {
    // Create the loginid object first, so it can be passed into the validation
    var loginId = new LoginId(ctx.tenant().alias, AuthenticationConstants.providers.LOCAL, username);

    // Parameter validation
    var validator = new Validator();
    validator.check(username, {'code': 400, 'msg': 'Please specify a username'}).notEmpty();
    _validateLoginIdForLookup(validator, loginId);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    AuthenticationDAO.getUserIdFromLoginId(loginId, function(err, userId) {
        if (err && err.code !== 404) {
            return callback(err);
        } else if (!userId) {
            return callback(null, false);
        } else {
            callback(null, true);
        }
    });
};

/**
 * Create a global administrator user with the given authentication credentials.
 *
 * @param  {Context}    ctx                 The current context, must be authenticated to the global admin tenant with a user with global administrator privileges
 * @param  {String}     username            The local username of the global administrator
 * @param  {String}     password            The password of the global administrator
 * @param  {String}     displayName         The display name of the global administrator
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occured, if any
 * @param  {Boolean}    callback.user       The user object that was created
 */
var createGlobalAdminUser = module.exports.createGlobalAdminUser = function(ctx, username, password, displayName, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You must be authenticated to the global admin tenant to create a global administrator user'}).isLoggedInUser(ctx, globalTenantAlias);
    validator.check(null, {'code': 401, 'msg': 'You must be a global administrator to create a global administraotr user'}).isGlobalAdministratorUser(ctx);
    validator.check(username, {'code': 400, 'msg': 'You must provide a username'}).notEmpty();
    validator.check(password, {'code': 400, 'msg': 'You must provide a password'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'You must provide a display name'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Create the login id and perform secondary validation on the loginId
    var loginId = new LoginId(ctx.tenant().alias, AuthenticationConstants.providers.LOCAL, username, {'password': password});
    _validateLoginIdForPersistence(validator, loginId);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Create the user
    createUser(ctx, loginId, displayName, {'visibility': AuthzConstants.visibility.PRIVATE}, function(err, user) {
        if (err) {
            return callback(err);
        }

        // Make the user a global administrator
        PrincipalsAPI.setGlobalAdmin(ctx, user.id, true, function(err) {
            if (err) {
                return callback(err);
            }

            // Fetch the user again to get the updated version of the user
            return PrincipalsAPI.getUser(ctx, user.id, callback);
        });
    });
};

/**
 * Utility methods that gets a user by the login id. If no user was found it will be created.
 *
 * @param  {Context}      ctx                The current context, used to determine the tenant of the user to get / create
 * @param  {String}       authProvider       The authentication provider of the login id
 * @param  {String}       externalId         The desired externalId/username for this user
 * @param  {String}       displayName        The user's display name
 * @param  {String}       [opts]             Optional user profile parameters
 * @param  {String}       [opts.locale]      The user's locale
 * @param  {String}       [opts.email]       The user's email address
 * @param  {String}       [opts.timezone]    The user's timezone
 * @param  {String}       [opts.visibility]  The user's visibility. One of: @see AuthzConstants.visibility
 * @param  {String}       [opts.publicAlias] The alias to show when the user is private / inaccessible by the current user
 * @param  {Function}     callback           Standard callback function
 * @param  {Object}       callback.err       An error that occured, if any
 * @param  {Boolean}      callback.user      The user object
 */
var getOrCreateUser = module.exports.getOrCreateUser = function(ctx, authProvider, externalId, displayName, opts, callback) {
    opts = opts || {};
    var loginId = new LoginId(ctx.tenant().alias, authProvider, externalId, {'password': opts.password});
    AuthenticationDAO.getUserIdFromLoginId(loginId, function(err, userId) {
        if (err && err.code !== 404) {
            return callback(err);
        } else if (!userId) {
            // No user mapped to this login id so we will create a user for it
            log(ctx).trace({
                'loginId': loginId,
                'displayName': displayName,
                'opts': opts
            }, 'Auto-creating user on login');

            return createUser(ctx, loginId, displayName, opts, callback);
        } else {
            // The user existed
            return PrincipalsAPI.getUser(ctx, userId, callback);
        }
    });
};

/**
 * Create a user in the database with the provided loginId.
 *
 * @param  {Context}   ctx                 The current context
 * @param  {LoginId}   loginId             The login id that will be associated with the user so they may log in
 * @param  {String}    displayName         The user's display name
 * @param  {Object}    [opts]              Optional user profile parameters
 * @param  {String}    [opts.locale]       The user's locale
 * @param  {String}    [opts.email]        The user's email address
 * @param  {String}    [opts.timezone]     The user's timezone
 * @param  {String}    [opts.visibility]   The user's visibility. One of: @see AuthzConstants.visibility
 * @param  {String}    [opts.publicAlias]  The alias to show when the user is private / inaccessible by the current user
 * @param  {Function}  callback            Standard callback function
 * @param  {Object}    callback.err        An error that occurred, if any
 * @param  {Boolean}   callback.user       User object representing the created user
 */
var createUser = module.exports.createUser = function(ctx, loginId, displayName, opts, callback) {
    var validator = new Validator();
    validator.check(displayName, {'code': 400, 'msg': 'Please specify a display name'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'A displayName can only be 1000 characters long'}).isShortString();
    _validateLoginIdForPersistence(validator, loginId);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Lock on externalId to make sure we're not already making an account for this user
    var lockKey = loginId.externalId;
    Locking.acquire(lockKey, 15, function(err, lockToken) {
        if (err) {
            return callback(err);
        } else if (!lockToken) {
            return callback({'code': 400, 'msg': 'This login id already exists and is already associated to a user'});
        }

        // Make sure the loginId is not already associated to a user
        AuthenticationDAO.getUserIdFromLoginId(loginId, function(err, userId) {
            if (userId) {
                return callback({'code': 400, 'msg': 'This login id already exists and is already associated to a user'});
            }

            // Hash the user password
            if (loginId.provider === AuthenticationConstants.providers.LOCAL) {
                loginId.properties.password = AuthenticationUtil.hashPassword(loginId.properties.password);
            }

            // Create the user in the database and immediately associate the login id
            PrincipalsAPI.createUser(ctx, displayName, opts, function(err, user) {
                if (err) {
                    return Locking.release(lockKey, lockToken, function() {
                        callback(err);
                    });
                }

                loginId.userId = user.id;
                AuthenticationDAO.associateLoginId(loginId, user.id, function(err) {
                    if (err) {
                        return Locking.release(lockKey, lockToken, function() {
                            callback(err);
                        });
                    }

                    log(ctx).info({
                        loginId: {
                            tenantAlias: loginId.tenantAlias,
                            provider: loginId.provider,
                            externalId: loginId.externalId
                        },
                        userId: user.id
                    }, 'Created user with a mapped login id.');

                    Locking.release(lockKey, lockToken, function() {
                        return callback(null, user);
                    });
                });
            });
        });
    });
};

/**
 * Associate the given Login ID info to the specified user. This makes it possible for the associated user to login with the provided
 * login credentials.
 *
 * @param  {Context}   ctx             The current context
 * @param  {LoginId}   loginId         The login id to associate to the user
 * @param  {String}    userId          The id of the user in the database
 * @param  {Function}  callback        Invoked when the process completes
 * @param  {Object}    callback.err    An error that occurred, if any
 */
var associateLoginId = module.exports.associateLoginId = function(ctx, loginId, userId, callback) {
    var validator = new Validator();
    _validateLoginIdForPersistence(validator, loginId);
    validator.check(null, {'code': 401, 'msg': 'You must be authenticated to associate a login id to a user'}).isLoggedInUser(ctx);
    validator.check(userId, {'code': 400, 'msg': 'You must specify a user id'}).notEmpty();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var isAdmin = ctx.user().isAdmin(loginId.tenantAlias);
    var isTargetUser = (ctx.user().id === userId);

    if (!isAdmin && !isTargetUser) {
        // Only admin and the user themself can associate a login id to the account
        return callback({'code': 401, 'msg': 'You cannot associate a login id to a user other than your own'});
    }

    AuthenticationDAO.getUserIdFromLoginId(loginId, function(err, existingUserIdMapping) {
        if (err && err.code !== 404) {
            return callback(err);
        } else if (existingUserIdMapping && !isAdmin) {
            // Only admin can re-associate a login id to another user
            return callback({'code': 401, 'msg': 'Login ID is already associated to a user'});
        }

        // Verify we don't assign 2 ids of the same provider to a user
        AuthenticationDAO.getUserLoginIds(userId, function(err, loginIds) {
            if (err) {
                return callback(err);
            } else if (loginIds[loginId.provider]) {
                return  callback({'code': 400, 'msg': 'User already has a login id of type ' + loginId.provider});
            }

            // Ensure that the target user exists
            PrincipalsAPI.getUser(ctx, userId, function(err, user) {
                if (err) {
                    return callback(err);
                }

                AuthenticationDAO.associateLoginId(loginId, userId, function(err) {
                    if (err) {
                        callback(err);
                    } else {
                        log(ctx).info({
                            loginId: {
                                tenantAlias: loginId.tenantAlias,
                                provider: loginId.provider,
                                externalId: loginId.externalId
                            },
                            userId: userId
                        }, 'Mapped login id to user account');
                        callback();
                    }
                });
            });
        });
    });
};

/**
 * Changes the local password of a user.
 *
 * @param  {Context}  ctx           The current context
 * @param  {String}   userId        The user id of the user whose password that needs to be changed
 * @param  {String}   oldPassword   The old password that can be used to authenticate this change request
 * @param  {String}   newPassword   The new password
 * @param  {Function} callback      Invoked when the process completes
 * @param  {Object}   callback.err  An error that occurred, if any
 */
var changePassword = module.exports.changePassword = function(ctx, userId, oldPassword, newPassword, callback) {

    // Parameter validation
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to change a password'}).isLoggedInUser(ctx);
    validator.check(userId, {'code': 400, 'msg': 'A user id must be provided'}).isUserId();
    validator.check(newPassword, {'code': 400, 'msg': 'A new password must be provided'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the local login id for the user
    AuthenticationDAO.getUserLoginIds(userId, function(err, loginIds) {
        if (err) {
            return callback(err);
        }

        // can only change password on the local account type
        var localLoginId = loginIds[AuthenticationConstants.providers.LOCAL];
        if (localLoginId) {

            // determine the current user access
            var isAdmin = ctx.user().isAdmin(localLoginId.tenantAlias);
            var isTargetUser = ctx.user().id === userId;

            if (!isAdmin && !isTargetUser) {
                log().info('Failed attempt to change password for user %s by user %s', userId, ctx.user().id);
                return callback({'code': 401, 'msg': 'You\'re not authorized to change this user\'s password'});
            } else if (isAdmin) {
                // if the user is admin we don't care about the old password
                log().info('User %s is changing the password for user %s', ctx.user().id, userId);
                return _changePassword(localLoginId, newPassword, callback);
            } else {
                // if it's the current user, we need to verify the old password
                checkPassword(localLoginId.tenantAlias, localLoginId.externalId, oldPassword, function(err, checkedUserId) {
                    if (err) {
                        // old password was probably incorrect
                        log().error({'err': err}, 'User %s failed to change password for %s', ctx.user().id, userId);
                        return callback(err);
                    }

                    log().info('User %s is changing the password for user %s', ctx.user().id, userId);
                    return _changePassword(localLoginId, newPassword, callback);
                });
            }
        } else {
            return callback({'code': 400, 'msg': 'User does not have a local account mapping'});
        }
    });
};

/**
 * Checks the password for a specified tenant/username combination
 *
 * @param  {String}    tenantAlias      The alias of the tenant to which the user belongs
 * @param  {String}    username         The local username of the user
 * @param  {String}    password         The password that should be checked
 * @param  {Function}  callback         Standard callback function
 * @param  {Object}    callback.err     If the password check fails, this will be an error with `err.code === 401`. If there is an unexpected internal error, this will be that error
 * @param  {object}    callback.userId  The ID of the user if the passwords match
 */
var checkPassword = module.exports.checkPassword = function(tenantAlias, username, password, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(tenantAlias, {'code': 401, 'msg': 'A tenant must be provided'}).notEmpty();
    validator.check(username, {'code': 400, 'msg': 'A username must be provided'}).notEmpty();
    validator.check(password, {'code': 400, 'msg': 'A password must be provided'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // we can only check password on local authentication
    var loginId = new LoginId(tenantAlias, AuthenticationConstants.providers.LOCAL, username);

    _validateLoginIdForLookup(validator, loginId);
    if (validator.hasErrors()) {
        return new callback(validator.getFirstError());
    }

    AuthenticationDAO.checkPassword(loginId, function(err, result) {
        if (err) {
            return callback(err);
        } else if (!result) {
            return callback({'code': 401, 'msg': 'No password found for this principal'});
        }

        var passwordMatches = result.userId && result.password && AuthenticationUtil.hashAndComparePassword(password, result.password);
        if (passwordMatches) {
            callback(null, result.userId);
        } else {
            log().info('Invalid password check for user %s', username);
            callback({'code': 401, 'msg': 'User name and/or password do not match'});
        }
    });
};

/**
 * Gets the userId that is associated to the provided login ID, if any.
 *
 * @param  {String}    tenantAlias     The tenant of the login id
 * @param  {String}    provider        The provider of the login id (e.g., twitter, local, google...)
 * @param  {String}    externalId      The id of the user in the external authentication service
 * @param  {Function}  callback        Invoked when the process completes
 * @param  {Object}    callback.err    An error that occurred, if any
 * @param  {String}    callback.userId The id of the user that was associated to the login id, if any
 */
var getUserIdFromLoginId = module.exports.getUserIdFromLoginId = function(tenantAlias, provider, externalId, callback) {
    var loginId = new LoginId(tenantAlias, provider, externalId);

    var validator = new Validator();
    _validateLoginIdForLookup(validator, loginId);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    AuthenticationDAO.getUserIdFromLoginId(loginId, callback);
};

/**
 * Hash `newPassword` and store it as the new password for the given `loginId`.
 *
 * @param  {LoginId}   loginId         The login id whose password to change
 * @param  {String}    newPassword     The password to which to change the local login id
 * @param  {Function}  callback        Invoked when the process completes
 * @param  {Object}    callback.err    An error that occurred, if any
 * @api private
 */
var _changePassword = function(loginId, newPassword, callback) {
    var hash = AuthenticationUtil.hashPassword(newPassword);
    AuthenticationDAO.changePassword(loginId, hash, function(err) {
        if (err) {
            log().error({'err': err}, 'Error changing a user password');
            return callback(err);
        }

        return callback();
    });
};

/**
 * Verify that the given login ID is suitable to be used to look up a user id mapping.
 *
 * @param  {Validator}       validator   The validator to use to validate the loginId
 * @param  {LoginId}         loginId     The login id to validate
 * @api private
 */
var _validateLoginIdForLookup = function(validator, loginId) {
    var numErrors = validator.getErrorCount();
    validator.check(null, {'code': 400, 'msg': 'Must specify a login id'}).isObject(loginId);
    if (validator.getErrorCount() === numErrors) {
        // only validate these if loginId is a valid object
        validator.check(loginId.tenantAlias, {'code': 400, 'msg': 'Must specify a tenant id on the login id'}).notEmpty();
        validator.check(loginId.provider, {'code': 400, 'msg': 'Must specify an authentication provider on the login id'}).notEmpty();
        validator.check(loginId.externalId, {'code': 400, 'msg': 'Must specify an external id on the login id'}).notEmpty();
    }
};

/**
 * Verify that the given login ID is suitable to be persisted to storage.
 *
 * @param  {Validator}       validator   The validator to use to validate the loginId
 * @param  {LoginId}         loginId     The login id to validate
 * @api private
 */
var _validateLoginIdForPersistence = function(validator, loginId) {
    var numErrors = validator.getErrorCount();
    _validateLoginIdForLookup(validator, loginId);

    // only continue validating if the login id is valid so far
    if (validator.getErrorCount() === numErrors) {
        loginId.properties = loginId.properties || {};

        // custom handling for local authentication (i.e., username and password)
        if (loginId.provider === AuthenticationConstants.providers.LOCAL) {
            validator.check(loginId.properties.password, {'code': 400, 'msg': 'Must specify a password at least 6 characters long'}).len(6);
        }
    }
};



///////////////////////////////
///////////////////////////////
// AUTHENTICATION STRATEGIES //
///////////////////////////////
///////////////////////////////

/**
 * Register an authentication strategy. A strategy needs to be registered during the start-up phase and will then
 * be made active when the server has fully started up.
 *
 * @param  {String}     strategyName    The name under which this strategy should be registered. This string will be used in the Passport registry mechanism
 * @param  {Strategy}   strategy        The OAE strategy that needs to be registered
 * @throws {Error}                      An error is thrown if another strategy was already registered with the provided strategy name
 */
var registerStrategy = module.exports.registerStrategy = function(strategyName, strategy) {
    if (strategies[strategyName]) {
        throw new Error('Attempted to register duplicate authentication strategy');
    }

    strategies[strategyName] = strategy;
    log().info('Registered authentication strategy "%s"', strategyName);
};

/**
 * Refresh the known passport login strategies for a given tenant. This will be called for all registered tenants upon start-up
 * and when new tenants are being started on the fly.
 *
 * @param  {Tenant} tenant  The tenant for which we want to refresh the authentication capabilities
 */
var refreshStrategies = module.exports.refreshStrategies = function(tenant) {
    _.each(strategies, function(strategy, strategyName) {
        // Get the name we used to register this strategy with passport. This is a combination of the tenant and strategy name
        var passportStrategyName = AuthenticationUtil.getStrategyId(tenant, strategyName);

        // Disable the passport strategy if we registered it previously.
        if (passport._strategy(passportStrategyName)) {
            passport.unuse(passportStrategyName);
        }

        // If the tenant wants the strategy enabled, we enable it. We also create a new instance of the passport strategy so that
        // configuration updates to the strategy are taken into account
        if (strategy.shouldBeEnabled(tenant.alias)) {
            passport.use(passportStrategyName, strategy.getPassportStrategy(tenant));
            log().info({'tenant': tenant.alias, 'strategy': strategyName, 'passportStrategyName': passportStrategyName}, 'Enabling strategy');
        }
    });

    AuthenticationAPI.emit(AuthenticationConstants.events.REFRESHED_STRATEGIES, tenant);

    log().info({'tenant': tenant}, 'Refreshed authentication strategies for tenant');
};

/**
 * Refreshes all the authentication strategies on all the tenants.
 *
 * @api private
 */
var _refreshAllTenantStrategies = function() {
    var tenants = TenantsAPI.getTenants();
    // Refresh all the tenant auth strategies
    _.each(_.values(tenants), refreshStrategies);
};
