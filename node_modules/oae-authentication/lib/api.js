/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var _ = require('underscore');
var crypto = require('crypto');
var events = require('events');
var FacebookStrategy = require('passport-facebook').Strategy;
var GoogleStrategy = require('passport-google-oauth').OAuth2Strategy;
var LocalStrategy = require('passport-local').Strategy;
var OpenIDStrategy = require('passport-openid').Strategy;
var SamlStrategy = require('passport-saml').Strategy;
var passport = require('passport');
var TwitterStrategy = require('passport-twitter').Strategy;
var util = require('util');
var Validator = require('validator').Validator;

var Cassandra = require('oae-util/lib/cassandra');
var ConfigAPI = require('oae-config');
var Context = require('oae-context').Context;
var OaeServer = require('oae-util/lib/server');
var PrincipalsAPI = require('oae-principals');
var Redis = require('oae-util/lib/redis');
var Signature = require('oae-util/lib/signature');
var TenantsAPI = require('oae-tenants');
var TenantsUtil = require('oae-tenants/lib/util');
var TZ = require('oae-util/lib/tz');
var User = require('oae-principals/lib/model').User;
var log = require('oae-logger').logger('oae-authentication');

var AuthenticationConfig = ConfigAPI.config('oae-authentication');
var AuthenticationConstants = require('oae-authentication/lib/constants').AuthenticationConstants;
var AuthenticationUtil = require('oae-authentication/lib/util');
var CasStrategy = require('oae-authentication/lib/strategies/cas');
var LoginId = require('oae-authentication/lib/model').LoginId;
var SignedStrategy = require('oae-authentication/lib/strategies/signed');
var Token = require('oae-authentication/lib/model').Token;

var globalTenantAlias;

// The path to the java JAR that can be used to decrypt SAML messages.
var _SAMLParserJarPath;

// Holds the strategies for each tenant.
var strategies = {};

// Setup functions for different strategies, keyed by the strategy name.
var strategySetup = {};

// When a tenant starts up, configure it's authentication strategies
TenantsAPI.on('start', function(tenant) {
    refreshStrategies(tenant);
});

ConfigAPI.on('update', function(tenantAlias) {
    if (tenantAlias === globalTenantAlias) {
        // We updated the global tenant, which means we'll have to update all tenant authentication strategies, as they may have changed transiently.
        TenantsAPI.getAllTenants(function(err, tenants) {
            if (err) {
                return log().error({'err': err}, 'Error fetching tenants to update authentication configuration.');
            }

            // Refresh all the tenant auth strategies
            _.values(tenants).forEach(refreshStrategies);
        });
    } else {
        TenantsAPI.getTenantByAlias(tenantAlias, function(err, tenant) {
            if (err) {
                return log().error({'err': err, 'tenantAlias': tenantAlias}, 'Error fetching tenant to update authentication configuration.');
            }

            refreshStrategies(tenant);
        });
    }
});

/**
 * ### Events
 *
 * The `AuthenticationAPI`, as enumerated in `AuthenticationConstants.events`, emits the following events:
 *
 * * `refreshedStrategies(tenant)`: The authentication strategies have been refreshed with the current configuration. The tenant that was refreshed is returned as a `Tenant` object.
 */
var AuthenticationAPI = module.exports = new events.EventEmitter();

/**
 * Register the authentication strategies that are always enabled for all tenants.
 */
var initSharedAuthenticationStrategies = module.exports.initSharedAuthenticationStrategies = function() {
    // There is no need to wrap strategies where we can pass the request..
    passport.use('signed', new SignedStrategy());
};

/**
 * Initializes the configuration of the authentication module.
 *
 * @param  {String} globalTenantAlias   The alias of the global tenant
 * @param  {String} [SAMLParserJarPath] The path to the java JAR that can be used to decrypt SAML messages. This is only required if you enable the Shibboleth strategy.
 */
var init = module.exports.init = function(_globalTenantAlias, SAMLParserJarPath) {
    globalTenantAlias = _globalTenantAlias;
    _SAMLParserJarPath = SAMLParserJarPath;

    // Ensure that the saml2 and signed auth URLs bypass CSRF validation. They have their own authenticity handling.
    OaeServer.addSafePathPrefix('/api/auth/shibboleth/callback');
    OaeServer.addSafePathPrefix('/api/auth/signed');

    passport.use(AuthenticationConstants.providers.LOCAL, new LocalStrategy({'passReqToCallback': true}, _passwordCallback));

    // Enable the 'local' authentication strategy for the global tenant
    _enableStrategy({'alias': globalTenantAlias}, AuthenticationConstants.providers.LOCAL);

    TenantsAPI.getAllTenants(function(err, tenants) {
        if (err) {
            return callback(err);
        }

        _.values(tenants).forEach(refreshStrategies);
    });
};



////////////////////////
////////////////////////
// USER ID MANAGEMENT //
////////////////////////
////////////////////////

/**
 * Check whether or not an external user id already exists on a given tenant.
 *
 * @param  {Context}   ctx                The current context
 * @param  {String}    externalId         The login id that we want to check existence for
 * @param  {Function}  callback           Standard callback function
 * @param  {Object}    callback.err       An error that occured, if any
 * @param  {Boolean}   callback.exists    Whether or not the user id exists on the current tenant
 */
var loginIdExists = module.exports.loginIdExists = function(ctx, externalId, callback) {
    // Create the loginid object first, so it can be passed into the validation
    var loginId = new LoginId(ctx.tenant().alias, AuthenticationConstants.providers.LOCAL, externalId);

    // Parameter validation
    var validator = new Validator();
    validator.check(externalId, {'code': 400, 'msg': 'Please specify a login id.'}).notEmpty();
    _validateLoginIdForLookup(validator, loginId);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getUserIdFromLoginId(loginId, function(err, userId) {
        if (err) {
            return callback(err);
        }

        if (!userId) {
            callback(null, false);
        } else {
            callback(null, true);
        }
    });
};

/**
 * Utility methods that gets a user by the login id. If no user was found it will be created.
 *
 * @param  {Context}      ctx                The current context, used to determine the tenant of the user to get / create
 * @param  {String}       authProvider       The authentication provider of the id.
 * @param  {String}       externalId         The desired externalId/username for this user.
 * @param  {String}       displayName        The display name of this user
 * @param  {String}       [opts]             Optional user profile parameters.
 * @param  {String}       [opts.locale]      The locale of this user.
 * @param  {String}       [opts.timezone]    The timezone of this user.
 * @param  {String}       [opts.visibility]  The visibility of the user. One of: @see PrincipalsConstants.visibility
 * @param  {String}       [opts.publicAlias] The alias to show when the user is private / inaccessible by the current user
 * @param  {Function}     callback           A function returning the user.
 * @param  {Object}       callback.err       An error that occured, if any
 * @param  {Boolean}      callback.user      The user object
 */
var getOrCreateUser = module.exports.getOrCreateUser = function(ctx, authProvider, externalId, displayName, opts, callback) {
    var loginId = new LoginId(ctx.tenant().alias, authProvider, externalId);
    _getUserIdFromLoginId(loginId, function(err, userId) {
        if (err) {
            return callback(err);
        }

        if (!userId) {

            // No user mapped to this login id. Create it.
            log(ctx).trace({
                'loginId': loginId,
                'displayName': displayName,
                'opts': opts
            }, 'Auto-creating user on login.');

            return createUser(ctx, loginId, displayName, opts, callback);
        } else {
            // The user existed
            return PrincipalsAPI.getUser(ctx, userId, callback);
        }
    });
};

/**
 * Create a user in the database with the provided loginId.
 *
 * @param  {Context}   ctx                 The current context
 * @param  {LoginId}   loginId             The login id that will be associated with the user so they may log in
 * @param  {String}    displayName         The display name of the user
 * @param  {Object}    [opts]              Optional parameters that can be assigned to a user
 * @param  {String}    [opts.locale]       The locale of this user.
 * @param  {String}    [opts.timezone]     The timezone of this user.
 * @param  {String}    [opts.visibility]   The visibility of the user. One of: @see PrincipalsConstants.visibility
 * @param  {String}    [opts.publicAlias]  The alias to show when the user is private / inaccessible by the current user
 * @param  {Function}  callback            Invoked when the process completes
 * @param  {Object}    callback.err        An error that occurred, if any
 * @param  {Boolean}   callback.user       The user that was created
 */
var createUser = module.exports.createUser = function(ctx, loginId, displayName, opts, callback) {
    var validator = new Validator();
    validator.check(displayName, {'code': 400, 'msg': 'Please specify a display name.'}).notEmpty();
    _validateLoginIdForPersistence(validator, loginId);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // make sure the loginId is not already associated to a user
    _getUserIdFromLoginId(loginId, function(err, userId) {
        if (userId) {
            return callback({'code': 400, 'msg': 'This login id already exists and is already associated to a user.'});
        }

        // hash the user password
        if (loginId.provider === AuthenticationConstants.providers.LOCAL) {
            loginId.properties.password = AuthenticationUtil.hashPassword(loginId.properties.password);
        }

        // create the user in the database and immediately associate the login id
        PrincipalsAPI.createUser(ctx, displayName, opts, function(err, user) {
            if (err) {
                return callback(err);
            }

            loginId.userId = user.id;
            _associateLoginId(loginId, user.id, function(err) {
                if (err) {
                    return callback(err);
                }

                log(ctx).info({
                    loginId: {
                        tenantAlias: loginId.tenantAlias,
                        provider: loginId.provider,
                        externalId: loginId.externalId
                    },
                    userId: user.id
                }, 'Created user with a mapped login id.');

                return callback(null, user);
            });
        });
    });
};

/**
 * Associate the given Login ID info to the specified user. This makes it possible for the associated user to login with the provided
 * login credentials.
 *
 * @param  {Context}   ctx             The current context
 * @param  {LoginId}   loginId         The login id to associate to the user
 * @param  {String}    userId          The id of the user in the database
 * @param  {Function}  callback        Invoked when the process completes
 * @param  {Object}    callback.err    An error that occurred, if any
 */
var associateLoginId = module.exports.associateLoginId = function(ctx, loginId, userId, callback) {
    var validator = new Validator();
    _validateLoginIdForPersistence(validator, loginId);
    validator.check(null, {'code': 401, 'msg': 'You must be authenticated to associate a login id to a user.'}).isLoggedInUser(ctx);
    validator.check(userId, {'code': 400, 'msg': 'Must specify a user id'}).notEmpty();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var isAdmin = ctx.user().isAdmin(loginId.tenantAlias);
    var isTargetUser = (ctx.user().id === userId);

    if (!isAdmin && !isTargetUser) {
        // only admin and the user themself can associate a login id to the account
        return callback({'code': 401, 'msg': 'You cannot associate a login id to a user other than your own.'});
    }

    _getUserIdFromLoginId(loginId, function(err, existingUserIdMapping) {
        if (err) {
            return callback(err);
        } else if (existingUserIdMapping && !isAdmin) {
            // only admin can re-associate a login id to another user
            return callback({'code': 401, 'msg': 'Login ID is already associated to a user.'});
        }

        // verify we don't assign 2 ids of the same provider to a user
        _getUserLoginIds(userId, function(err, loginIds) {
            if (err) {
                return callback(err);
            } else if (loginIds[loginId.provider]) {
                return  callback({'code': 400, 'msg': 'User already has a login id of type ' + loginId.provider});
            }

            // ensure that the target user exists
            PrincipalsAPI.getUser(ctx, userId, function(err, user) {
                if (err) {
                    return callback(err);
                }

                _associateLoginId(loginId, userId, function(err) {
                    if (err) {
                        callback(err);
                    } else {
                        log(ctx).info({
                            loginId: {
                                tenantAlias: loginId.tenantAlias,
                                provider: loginId.provider,
                                externalId: loginId.externalId
                            },
                            userId: userId
                        }, 'Mapped login id to user account.');
                        callback();
                    }
                });
            });
        });
    });
};

/**
 * Changes the local password of a user.
 *
 * @param  {Context}  ctx           The current context.
 * @param  {String}   userId        The user id of the user whose password that needs to be changed.
 * @param  {String}   oldPassword   The old password that can be used to authenticate this change request.
 * @param  {String}   newPassword   The new password.
 * @param  {Function} callback      Invoked when the process completes
 * @param  {Object}   callback.err  An error that occurred, if any
 */
var changePassword = module.exports.changePassword = function(ctx, userId, oldPassword, newPassword, callback) {

    // Parameter validation
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to change a password'}).isLoggedInUser(ctx);
    validator.check(userId, {'code': 400, 'msg': 'A user id must be provided'}).notEmpty();
    validator.check(newPassword, {'code': 400, 'msg': 'A new password must be provided'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // get the local login id for the user
    _getUserLoginIds(userId, function(err, loginIds) {
        if (err) {
            return callback(err);
        }

        // can only change password on the local account type
        var localLoginId = loginIds[AuthenticationConstants.providers.LOCAL];
        if (localLoginId) {

            // determine the current user access
            var isAdmin = ctx.user().isAdmin(localLoginId.tenantAlias);
            var isTargetUser = ctx.user().id === userId;

            if (!isAdmin && !isTargetUser) {
                log().info('Failed attempt to change password for user %s by user %s.', userId, ctx.user().id);
                return callback({'code': 401, 'msg': 'You\'re not authorized to change this user\'s password.'});
            } else if (isAdmin) {
                // if the user is admin we don't care about the old password
                log().info('User %s is changing the password for user %s', ctx.user().id, userId);
                return _changePassword(localLoginId, newPassword, callback);
            } else {
                // if it's the current user, we need to verify the old password
                checkPassword(localLoginId.tenantAlias, localLoginId.externalId, oldPassword, function(err, checkedUserId) {
                    if (err) {
                        // old password was probably incorrect
                        log().error({'err': err}, 'User %s failed to change password for %s', ctx.user().id, userId);
                        return callback(err);
                    }

                    log().info('User %s is changing the password for user %s', ctx.user().id, userId);
                    return _changePassword(localLoginId, newPassword, callback);
                });
            }
        } else {
            return callback({'code': 400, 'msg': 'User does not have a local account mapping.'});
        }
    });
};

/**
 * Checks the password for a specified login id
 *
 * @param  {String}    tenantAlias      The alias of the tenant to which the user belongs
 * @param  {String}    username         The local username of the user
 * @param  {String}    password         The password that can be used to compare with the one in the DB.
 * @param  {Function}  callback         Invoked when the process completes
 * @param  {Object}    callback.err     If the password check fails, this will be an error with `err.code === 401`. If there is an unexpected internal error, this will be that error.
 * @param  {object}    callback.userId  The ID of the user if the passwords match
 */
var checkPassword = module.exports.checkPassword = function(tenantAlias, username, password, callback) {
    // we can only check password on local authentication
    var loginId = new LoginId(tenantAlias, AuthenticationConstants.providers.LOCAL, username);

    var validator = new Validator();
    _validateLoginIdForLookup(validator, loginId);
    if (validator.hasErrors()) {
        return new callback(validator.getFirstError());
    }

    Cassandra.runQuery('SELECT userId, password FROM AuthenticationLoginId USING CONSISTENCY QUORUM WHERE loginId = ?', [_flattenLoginId(loginId)], function(err, rows) {
        if (err) {
            return callback(err);
        }

        if (rows[0].count === 0) {
            // No user found with that username.
            return callback({'code': 401, 'msg': 'No password found for this principal'});
        }

        // Check if the user provided password matches the stored password
        var result = Cassandra.rowToHash(rows[0]);
        var passwordMatches = result.userId && result.password && AuthenticationUtil.hashAndComparePassword(password, result.password);
        if (passwordMatches) {
            callback(null, result.userId);
        } else {
            log().info('Invalid password check for user %s', username);
            callback({'code': 401, 'msg': 'User name and/or password do not match.'});
        }
    });
};

/**
 * Gets the userId that is associated to the provided login ID, if any.
 *
 * @param  {String}    tenantAlias     The tenant of the login id
 * @param  {String}    provider        The provider of the login id (e.g., twitter, local, google...)
 * @param  {String}    externalId      The id of the user in the external authentication service
 * @param  {Function}  callback        Invoked when the process completes
 * @param  {Object}    callback.err    An error that occurred, if any
 * @param  {String}    callback.userId The id of the user that was associated to the login id, if any
 */
var getUserIdFromLoginId = module.exports.getUserIdFromLoginId = function(tenantAlias, provider, externalId, callback) {
    var loginId = new LoginId(tenantAlias, provider, externalId);

    var validator = new Validator();
    _validateLoginIdForLookup(validator, loginId);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getUserIdFromLoginId(loginId, callback);
};

/**
 * Hash `newPassword` and store it as the new password for the given `loginId`.
 *
 * @param  {LoginId}   loginId         The login id whose password to change
 * @param  {String}    newPassword     The password to which to change the local login id
 * @param  {Function}  callback        Invoked when the process completes
 * @param  {Object}    callback.err    An error that occurred, if any
 * @api private
 */
var _changePassword = function(loginId, newPassword, callback) {
    var hash = AuthenticationUtil.hashPassword(newPassword);
    Cassandra.runQuery('UPDATE AuthenticationLoginId USING CONSISTENCY QUORUM SET password = ? WHERE loginId = ?', [hash, _flattenLoginId(loginId)], function(err) {
        if (err) {
            log().error({'err': err}, 'Error changing a user password.');
            return callback(err);
        }

        return callback();
    });
};

/**
 * Associate the given Login ID info to the specified user. This makes it possible for the associated user to login with the provided
 * login credentials.
 *
 * @param  {LoginId}   loginId         The login id to associate
 * @param  {String}    userId          The id of the user in the database
 * @param  {Function}  callback        Invoked when the process completes
 * @param  {Object}    callback.err    An error that occurred, if any
 * @api private
 */
var _associateLoginId = function(loginId, userId, callback) {
    loginId.properties = loginId.properties || {};
    var flattenedLoginId = _flattenLoginId(loginId);

    // sanitize and prepare the columns for the upsert
    delete loginId.properties.loginId;
    loginId.properties.userId = userId;

    var query = Cassandra.constructUpsertCQL('AuthenticationLoginId', 'loginId', flattenedLoginId, loginId.properties);
    if (query) {
        var queries = [];
        queries.push(query);
        queries.push({
            'query': 'UPDATE AuthenticationUserLoginId SET ? = ? WHERE userId = ?',
            'parameters': [flattenedLoginId, '1', userId]
        });
        return Cassandra.runBatchQuery(queries, 'QUORUM', callback);
    } else {
        log().error({
            loginId: loginId,
            userId: userId
        }, 'Error constructing query to associate login id to user.');
        return callback({'code': 500, 'msg': 'Error associating login id to user ' + userId});
    }
};

/**
 * Get the login ids that are mapped to a user.
 *
 * @param  {String}      userId              The id of the user
 * @param  {Function}    callback            Invoked when the prcess completes
 * @param  {Object}      callback.err        An error that occurred, fi any
 * @param  {Object}      callback.loginIds   A hash whose keys are the authentication providers, and values are the LoginId objects that are mapped to the user
 * @api private
 */
var _getUserLoginIds = function(userId, callback) {
    if (!userId) {
        return callback(null, {});
    }

    Cassandra.runQuery('SELECT * FROM AuthenticationUserLoginId USING CONSISTENCY QUORUM WHERE userId = ?', [userId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var loginIds = {};
        var row = rows[0];
        for (var i = 0; i < row.count; i++) {
            var name = row[i].name;
            if (name !== 'userId') {
                var loginId = _expandLoginId(name);
                loginIds[loginId.provider] = loginId;
            }
        }

        return callback(null, loginIds);
    });
};

/**
 * Gets the userId that is associated to the provided login ID, if any.
 *
 * @param  {LoginId}   loginId         The login id to search
 * @param  {Function}  callback        Invoked when the process completes
 * @param  {Object}    callback.err    An error that occurred, if any
 * @param  {String}    callback.userId The id of the user that was associated to the login id, if any
 * @api private
 */
var _getUserIdFromLoginId = function(loginId, callback) {
    Cassandra.runQuery('SELECT userId FROM AuthenticationLoginId USING CONSISTENCY QUORUM WHERE loginId = ?', [_flattenLoginId(loginId)], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var row = rows[0];
        if (row) {
            var result = Cassandra.rowToHash(row);
            return callback(null, result.userId);
        } else {
            return callback();
        }
    });
};

/**
 * Flatten a LoginId object into a string representation that can be used for a storage key. This is in the following format:
 *
 * `<tenantAlias>:<authentication provider>:<external id>`
 *
 * @param  {LoginId}   loginId     The login id to flatten
 * @return {String}                The flattened string key representation of the login id
 * @api private
 */
var _flattenLoginId = function(loginId) {
    if (!loginId || !loginId.tenantAlias || !loginId.provider || !loginId.externalId) {
        return null;
    }
    return loginId.tenantAlias + ':' + loginId.provider + ':' + loginId.externalId;
};

/**
 * Expand a flattened key representation of a login id into a LoginId object. This is the opposite of #_flattenLoginId.
 *
 * @param  {String}    loginIdStr  The flat string key representation of the login id
 * @return {LoginId}               The LoginId object that is represented by the flat string
 * @api private
 */
var _expandLoginId = function(loginIdStr) {
    if (!loginIdStr) {
        return null;
    }

    var loginIdSplit = loginIdStr.split(':');
    if (loginIdSplit.length < 3) {
        return null;
    }

    // the externalId can contain *anything*, including colons. keep that in-tact with a slice-and-join.
    return new LoginId(loginIdSplit[0], loginIdSplit[1], loginIdSplit.slice(2).join(':'));
};

/**
 * Verify that the given login ID is suitable to be used to look up a user id mapping.
 *
 * @param  {Validator}       validator   The validator to use to validate the loginId
 * @param  {LoginId}         loginId     The login id to validate
 * @api private
 */
var _validateLoginIdForLookup = function(validator, loginId) {
    var numErrors = validator.getErrorCount();
    validator.check(null, {'code': 400, 'msg': 'Must specify a login id.'}).isObject(loginId);
    if (validator.getErrorCount() === numErrors) {
        // only validate these if loginId is a valid object
        validator.check(loginId.tenantAlias, {'code': 400, 'msg': 'Must specify a tenant id on the login id'}).notEmpty();
        validator.check(loginId.provider, {'code': 400, 'msg': 'Must specify an authentication provider on the login id'}).notEmpty();
        validator.check(loginId.externalId, {'code': 400, 'msg': 'Must specify an external id on the login id'}).notEmpty();
    }
};

/**
 * Verify that the given login ID is suitable to be persisted to storage.
 *
 * @param  {Validator}       validator   The validator to use to validate the loginId
 * @param  {LoginId}         loginId     The login id to validate
 * @api private
 */
var _validateLoginIdForPersistence = function(validator, loginId) {
    var numErrors = validator.getErrorCount();
    _validateLoginIdForLookup(validator, loginId);

    // only continue validating if the login id is valid so far
    if (validator.getErrorCount() === numErrors) {
        loginId.properties = loginId.properties || {};

        // custom handling for local authentication (i.e., username and password)
        if (loginId.provider === AuthenticationConstants.providers.LOCAL) {
            validator.check(loginId.properties.password, {'code': 400, 'msg': 'Must specify a password at least 6 characters long.'}).len(6);
        }
    }
};



///////////////////////////////
///////////////////////////////
// AUTHENTICATION STRATEGIES //
///////////////////////////////
///////////////////////////////

/**
 * Register the known passport login strategies for a given tenant. This will be called for all registered tenants upon start-up
 * and new tenants that are being started on the fly.
 *
 * @param  {Tenant} tenant  The tenant for which we want to register the authentication capabilities
 */
var refreshStrategies = module.exports.refreshStrategies = function(tenant) {
    var tenantAlias = tenant.alias;

    // This is a user tenant, enable the configured providers
    _.values(AuthenticationConstants.providers).forEach(function(strategyName) {
        var enabled = AuthenticationConfig.getValue(tenantAlias, strategyName, 'enabled');
        if (enabled) {
            _enableStrategy(tenant, strategyName);
        } else {
            _disableStrategy(tenant, strategyName);
        }
    });

    AuthenticationAPI.emit(AuthenticationConstants.events.REFRESHED_STRATEGIES, tenant);

    log().trace({
        'tenantAlias': tenant.alias,
        'strategies': strategies[tenantAlias]
    }, 'Refreshed authentication strategies for tenant.');
};

/**
 * Enable the authentication strategy with the strategyName for the given tenant. If the strategy is already
 * enabled for the tenant, this does effectively nothing.
 *
 * @param  {Tenant}     tenant          The tenant for which to enable the strategy
 * @param  {String}     strategyName    The name of the strategy to enable
 * @api private
 */
var _enableStrategy = function(tenant, strategyName) {
    strategies[tenant.alias] = strategies[tenant.alias] || {};
    if (!strategies[tenant.alias][strategyName]) {
        log().info('Enabling strategy "%s" for tenant "%s"', strategyName, tenant.alias);
        var strategyId = AuthenticationUtil.getStrategyId(tenant, strategyName);
        if (strategyName !== AuthenticationConstants.providers.LOCAL) {
            strategySetup[strategyName](tenant, strategyId);
        }
        strategies[tenant.alias][strategyName] = strategyId;
    }
};

/**
 * Disable the authentication strategy with the strategyName for the given tenant. If the strategy is already
 * enabled for the tenant, this does effectively nothing.
 *
 * @param  {Tenant}     tenant          The tenant for which to disable the strategy
 * @param  {String}     strategyName    The name of the strategy to disable
 * @api private
 */
var _disableStrategy = function(tenant, strategyName) {
    if (strategies[tenant.alias]) {
        var strategyId = strategies[tenant.alias][strategyName];
        if (strategyId) {
            log().info('Disabling strategy "%s" for tenant "%s"', strategyName, tenant.alias);

            if (strategyName !== AuthenticationConstants.providers.LOCAL) {
                passport.unuse(strategyId);
            }

            delete strategies[tenant.alias][strategyName];
        }
    }
};

/**
 * Contructs the callback URL for a given strategy by doing a look-up whether or not the tenant is using https.
 * ex: Suppose the passed in tenant uses https and the passed in strategy is 'google', the returned url will be:
 *     https://<tenant host>/api/auth/google/callback
 *
 * @param  {Tenant} tenant      The tenant object.
 * @param  {String} strategy    The strategy for this callback url.
 * @return {String}             An authentication callback url.
 * @api private
 */
var _constructCallbackUrl = function(tenant, strategy) {
    var baseUrl = TenantsUtil.getBaseUrl(tenant);
    return baseUrl + '/api/auth/' + strategy + '/callback';
};


/////////////
//  LOCAL  //
/////////////

/**
 * Handle the local authentication password callback and verify the user authentication.
 *
 * @param  {Request}        req         The express request object
 * @param  {String}         username    The username provided by the user
 * @param  {String}         password    The password provided by the user
 * @param  {Function}       done        Invoked when the password has been verified or denied
 * @param  {Object}         done.err    An error occurred, if any
 * @param  {User|Boolean}   done.user   The user who was validated if the authentication was successful, `false` if the username / password is unsuccessful
 * @api private
 */
var _passwordCallback = function(req, username, password, done) {
    var tenant = req.tenant;
    if (strategies[tenant.alias] && strategies[tenant.alias][AuthenticationConstants.providers.LOCAL]) {
        checkPassword(tenant.alias, username, password, function(err, userId) {
            if (err && err.code === 401) {
                // password incorrect
                return done(null, false);
            } else if (err) {
                // some internal error occurred
                return done(err);
            }

            // By this point we know that we were succesfully logged in.
            // Retrieve the user account and stick it in the context.
            var ctx = new Context(tenant, new User(tenant.alias, userId));
            PrincipalsAPI.getUser(ctx, userId, function(err, user) {
                if (err) {
                    return done(err);
                }
                AuthenticationUtil.logAuthnSuccess(req, user, AuthenticationConstants.providers.LOCAL);
                return done(null, user);
            });
        });
    } else {
        return done(null, false);
    }
};

////////////
// SIGNED //
////////////

/**
 * Returns a signed token that global administrators can use to login on a tenant without creating an account.
 * This method is only useful to global administrators.
 *
 * @param  {Context}    ctx                         The current context.
 * @param  {String}     tenantAlias                 The alias of the tenant on which they wish to log on.
 * @param  {Function}   callback                    Standard callback method.
 * @param  {Object}     callback.err                Standard error object (if any.)
 * @param  {Token}      callback.token              A token object that contains all the data to sign in.
 */
var getSignedToken = module.exports.getSignedToken = function(ctx, tenantAlias, callback) {
    if (!ctx.user() || !ctx.user().isGlobalAdmin()) {
        return callback({'code': 401, 'msg': 'Only global administrators are allowed to log onto other tenants.'});
    }

    var validator = new Validator();
    validator.check(tenantAlias, {'code': 400, 'msg': 'Missing tenant alias'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    TenantsAPI.getTenantByAlias(tenantAlias, function(err, tenant) {
        if (err) {
            return callback(err);
        }

        // Create a signature that's valid for 2 minutes and can be used to log on the tenant.
        var userId = ctx.user().id;
        var expires = parseInt(AuthenticationConfig.getValue(tenantAlias, 'signed', 'expires'), 10);
        var signature = Signature.createExpiringSignature(tenantAlias, expires, userId);

        // Return an object that the clients can use to construct an URL to redirect the user to.
        var token = new Token(signature.expires, tenant.host, signature.signature, userId);
        callback(null, token);
    });
};

//////////////
//  GOOGLE  //
//////////////

/*!
 * Register a new Google passport login strategy for a tenant
 *
 * @param  {Tenant}     tenant      Tenant for which we want to register the strategy
 * @param  {String}     strategyId  The tenant-discriminated ID of the strategy to bind
 * @api private
 */
strategySetup[AuthenticationConstants.providers.GOOGLE] = function(tenant, strategyId) {
    var key = AuthenticationConfig.getValue(tenant.alias, 'google', 'key');
    var secret = AuthenticationConfig.getValue(tenant.alias, 'google', 'secret');

    var strategy = new GoogleStrategy({
        'clientID': key,
        'clientSecret': secret,
        'scope': [
            'https://www.googleapis.com/auth/userinfo.profile',
            'https://www.googleapis.com/auth/userinfo.email'
        ],
        'callbackURL': _constructCallbackUrl(tenant, AuthenticationConstants.providers.GOOGLE)
    },  function(accessToken, refreshToken, profile, done) {

        log().trace({
            'tenant': tenant,
            'profile': profile
        }, 'Received Google authentication callback.');

        var email = profile.emails[0].value;

        // Re-use the email address as the externalId.
        var externalId = email;
        var displayName = profile.displayName;

        // The locale returned by google only specifies the language, but not the region which
        // isn't very useful.
        var opts = {
            'email': email
        };
        var picture = profile['_json'].picture;
        if (picture) {
            opts.smallPictureUri = 'remote:' + picture;
            opts.mediumPictureUri = 'remote:' + picture;
        }

        var context = new Context(tenant, null);
        getOrCreateUser(context, AuthenticationConstants.providers.GOOGLE, externalId, displayName, opts, done);
    });

    passport.use(strategyId, strategy);
};

///////////////
//  TWITTER  //
///////////////

/*!
 * Register a new Twitter passport login strategy for a tenant
 *
 * @param  {Tenant}     tenant      Tenant for which we want to register the strategy
 * @param  {String}     strategyId  The tenant-discriminated ID of the strategy to bind
 * @api private
 */
strategySetup[AuthenticationConstants.providers.TWITTER] = function(tenant, strategyId) {
    var consumerKey = AuthenticationConfig.getValue(tenant.alias, 'twitter', 'key');
    var consumerSecret = AuthenticationConfig.getValue(tenant.alias, 'twitter', 'secret');

    var strategy = new TwitterStrategy({
        'consumerKey': consumerKey,
        'consumerSecret': consumerSecret,
        'callbackURL': _constructCallbackUrl(tenant, AuthenticationConstants.providers.TWITTER)
    }, function(token, tokenSecret, profile, done) {

        log().trace({
            'tenant': tenant,
            'profile': profile
        }, 'Received Twitter authentication callback.');

        // Use the Twitter handle to register this user.
        // Unfortunately Twitter doesn't hand out the e-mail address.
        // See: https://dev.twitter.com/discussions/4019
        var username = profile.username;
        var displayName = profile.displayName;
        var opts = {
            // Twitter uses Ruby on Rails timezone names, use a mapper to map them to TZInfo timezones
            timezone: TZ.getTimezoneFromRails(profile._json.time_zone)
        };
        var picture = profile['_json']['profile_image_url_https'];
        if (picture) {
            opts.smallPictureUri = 'remote:' + picture;
            opts.mediumPictureUri = 'remote:' + picture;
        }

        var context = new Context(tenant, null);
        getOrCreateUser(context, AuthenticationConstants.providers.TWITTER, username, displayName, opts, done);
    });
    passport.use(strategyId, strategy);
};


////////////////
//  FACEBOOK  //
////////////////

/*!
 * Register a new Facebook passport login strategy for a tenant
 *
 * @param  {Tenant}     tenant      Tenant for which we want to register the strategy
 * @param  {String}     strategyId  The tenant-discriminated ID of the strategy to bind
 * @api private
 */
strategySetup[AuthenticationConstants.providers.FACEBOOK] = function(tenant, strategyId) {
    var clientID = AuthenticationConfig.getValue(tenant.alias, 'facebook', 'appid');
    var clientSecret = AuthenticationConfig.getValue(tenant.alias, 'facebook', 'secret');

    var strategy = new FacebookStrategy({
        'clientID': clientID,
        'clientSecret': clientSecret,
        'profileFields': ['id', 'username', 'displayName', 'photos', 'emails'],
        'callbackURL': _constructCallbackUrl(tenant, AuthenticationConstants.providers.FACEBOOK)
    }, function(accessToken, refreshToken, profile, done) {

        log().trace({
            'tenant': tenant,
            'profile': profile
        }, 'Received Facebook authentication callback.');

        var externalId = profile.username;
        var displayName = profile.displayName;
        var opts = {
            locale: profile._json.locale
        };

        var picture = profile['_json']['picture'];
        if (picture && picture.data && picture.data.url && !picture.data.is_silhouette) {
            opts.smallPictureUri = 'remote:' + picture.data.url;
            opts.mediumPictureUri = 'remote:' + picture.data.url;
        }

        // Not all facebook users have an e-mail address.
        if (profile.emails.length > 0 && profile.emails[0].value) {
            opts.email = profile.emails[0].value;
        }

        var context = new Context(tenant, null);
        getOrCreateUser(context, AuthenticationConstants.providers.FACEBOOK, externalId, displayName, opts, done);
    });
    passport.use(strategyId, strategy);
};


//////////////////
//  SHIBBOLETH  //
//////////////////

/*!
 * Register a new Shibboleth passport login strategy for a tenant
 *
 * @param  {Tenant}     tenant      Tenant for which we want to register the strategy
 * @param  {String}     strategyId  The tenant-discriminated ID of the strategy to bind
 * @api private
 */
strategySetup[AuthenticationConstants.providers.SHIBBOLETH] = function(tenant, strategyId) {
    // The endpoint we should redirect to.
    var idpUrl = AuthenticationConfig.getValue(tenant.alias, 'shibboleth', 'idpUrl');

    // The IdP's public key
    var idpCert = AuthenticationConfig.getValue(tenant.alias, 'shibboleth', 'idpPublicKey');

    // The entity ID we registered our Service Provider with.
    var entityID = AuthenticationConfig.getValue(tenant.alias, 'shibboleth', 'spEntityID');

    // The private/public keypair for our SP.
    var privateKey = AuthenticationConfig.getValue(tenant.alias, 'shibboleth', 'spPrivateKey');
    var cert = AuthenticationConfig.getValue(tenant.alias, 'shibboleth', 'spCertificate');
    var certSubjectName = AuthenticationConfig.getValue(tenant.alias, 'shibboleth', 'spCertificateSubjectName');

    var strategy = new SamlStrategy({
        'isShibboleth': true,
        // Although it's technically possible to run a Shibboleth SP on http, we enforce that it's running behind https.
        // This is to avoid re-registering the SP metadata when the tenant switches to https.
        'callbackUrl': 'https://' + tenant.host + '/api/auth/shibboleth/callback',
        'entryPoint': idpUrl,
        'issuer': entityID,
        'cert': idpCert,
        'converter': _SAMLParserJarPath,
        'publicCert': cert,
        'publicCertSubjectName': certSubjectName,
        'privateCert': privateKey,
        'identifierFormat': null,

        // The anti-replay store is designed to thwart replay attack.
        // It allows for detection of messages that got somehow intercepted and replayed.
        // The SamlStrategy's default anti-replay attack mechanism doesn't work in a cluster (it uses a local cache.)
        // We implement a Redis based anti-replay mechanism. This works because all app nodes talk to the same Redis instance.
        // A key might look like:
        //     shibboleth:cam-shibboleth:0ebec0b63b3732b3e3bd
        // The Redis keys will expire after 5 minutes.
        'antiReplayStore': {
            'get': function(id, callback) {
                var key = util.format('shibboleth:%s:%s', strategyId, id);
                Redis.getClient().get(key, callback);
            },
            'set': function(id, data, callback) {
                var key = util.format('shibboleth:%s:%s', strategyId, id);
                Redis.getClient().setex(key, 5 * 60, data, callback);
            },
            'del': function(id, callback) {
                var key = util.format('shibboleth:%s:%s', strategyId, id);
                Redis.getClient().del(key, callback);
            }
        }
    }, function(profile, done) {

        log().trace({
            'tenant': tenant,
            'profile': profile
        }, 'Received SHIBBOLETH authentication callback.');

        // See https://wiki.umn.edu/ShibAuth/AttributeList for a full attribute list.
        var username = getSamlAttributeValue('eduPersonPrincipalName', profile);
        var displayName = getSamlAttributeValue('displayName', profile) || getSamlAttributeValue('eduPersonNickname', profile) || getSamlAttributeValue('cn', profile) || getSamlAttributeValue('eduPersonPrincipalName', profile);
        var opts = {};
        var context = new Context(tenant, null);
        getOrCreateUser(context, AuthenticationConstants.providers.SHIBBOLETH, username, displayName, opts, done);
    });
    passport.use(strategyId, strategy);
};

/**
 * Get the value for a SAML attribute.
 * This will look up the readable `key` as the SAML2 URI in the `profile` hash.
 * If it couldn't be found the SAML1 URI will be tried.
 * If that couldn't be found either, null will be returned.
 *
 * @param  {String}     key     The human readable key as defined in the `AuthenticationConstants.SAML` hash.
 * @param  {Object}     data    The hash where the value can be found.
 * @return {String}             The value
 * @api private
 */
var getSamlAttributeValue = function(key, data) {
    if (AuthenticationConstants.SAML[key]) {
        if (data[AuthenticationConstants.SAML[key].saml2]) {
            return data[AuthenticationConstants.SAML[key].saml2];
        } else if (data[AuthenticationConstants.SAML[key].saml1]) {
            return data[AuthenticationConstants.SAML[key].saml1];
        } else {
            return null;
        }
    } else {
        return null;
    }
};

/**
 * Returns the Shibboleth metadata in XML format that can be used to register this app
 * as a Service Provider with an Identity Provider.
 *
 * @param  {Context}    ctx                 The current execution context
 * @param  {Function}   callback            Standard callback method
 * @param  {Object}     callback.err        Standard error object (if any.)
 * @param  {String}     callback.metadata   The SP metadata (in XML format.)
 */
var getShibbolethSPMetadata = module.exports.getShibbolethSPMetadata = function(ctx, callback) {
    // Check if this tenant even has Shibboleth enabled.
    var isEnabled = AuthenticationConfig.getValue(ctx.tenant().alias, 'shibboleth', 'enabled');
    if (!isEnabled) {
        return callback({'code': 400, 'msg': 'Shibboleth is not enabled on this tenant.'});
    }

    // Get the SamlStrategy.
    var strategyId = AuthenticationUtil.getStrategyId(ctx.tenant(), 'shibboleth');
    var samlStrategy = passport._strategy(strategyId);
    var metadata = samlStrategy.getShibbolethMetadata();
    callback(null, metadata);
};

///////////
//  CAS  //
///////////

/*!
 * Register a new CAS passport login strategy for a tenant
 *
 * @param  {Tenant}     tenant      Tenant for which we want to register the strategy
 * @param  {String}     strategyId  The tenant-discriminated ID of the strategy to bind
 * @api private
 */
strategySetup[AuthenticationConstants.providers.CAS] = function(tenant, strategyId) {
    var casHost = AuthenticationConfig.getValue(tenant.alias, 'cas', 'host');
    var basePath = AuthenticationConfig.getValue(tenant.alias, 'cas', 'basepath');
    var loginPath = AuthenticationConfig.getValue(tenant.alias, 'cas', 'loginpath');
    var logoutPath = AuthenticationConfig.getValue(tenant.alias, 'cas', 'logoutpath');
    var validatePath = AuthenticationConfig.getValue(tenant.alias, 'cas', 'validatepath');

    var serverBase = TenantsUtil.getBaseUrl(tenant);

    var strategy = new CasStrategy({
        'serverBase': serverBase,
        'allow': '',
        'service': serverBase + '/api/auth/cas/callback',
        'casHost': casHost,
        'casBasePath': basePath,
        'loginPath': loginPath,
        'logoutPath': logoutPath,
        'validatePath': validatePath,
        'appLogoutPath': '/api/auth/logout'
    }, function(id, done) {

        log().trace({
            'tenant': tenant,
            'id': id
        }, 'Received CAS authentication callback.');

        var username = id;
        var displayName = id;
        var opts = {};

        var context = new Context(tenant, null);
        getOrCreateUser(context, AuthenticationConstants.providers.CAS, username, displayName, opts, done);
    });
    passport.use(strategyId, strategy);
};
