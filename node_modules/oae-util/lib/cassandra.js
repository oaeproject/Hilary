/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var Helenus = require('helenus');

var OAE = require('oae-util/lib/oae');
var IO  = require('oae-util/lib/io');
var Telemetry = require('oae-telemetry').telemetry('cassandra');
var log = require('oae-logger').logger('cassandra');

var CONFIG = null;
var pool = null;

/**
 * Initializes the keyspace in config.keyspace with the CF's in all the modules their schema.js code.
 *
 * @param  {Object}    config          A Configuration object that can be used as the Cassandra client config.
 * @param  {Function}  callback        Standard callback method
 * @param  {Object}    callback.err    Error object, containing the error message
 */
module.exports.init = function(config, callback) {
    callback = callback || function(){};
    CONFIG = config;

    var keyspace = CONFIG.keyspace;

    // first connect to the system keyspace to ensure the specified keyspace exists
    CONFIG.keyspace = 'system';
    pool = _createPool(CONFIG);
    pool.connect(function(err) {

        // immediately switch the CONFIG keyspace back to the desired keyspace
        CONFIG.keyspace = keyspace;

        if (err) {
            return callback(err);
        }

        keyspaceExists(keyspace, function(err, exists) {
            if (err) {
                // ensure the pool is closed
                return close(function() {
                    callback(err);
                });
            }

            if (!exists) {
                createKeyspace(keyspace, function(err) {
                    if (err) {
                        return close(function() {
                            callback(err);
                        });
                    }

                    // reconnect the pool now with the desired keyspace
                    _reloadPool(callback);
                });
            } else {
                // reconnect the pool now with the desired keyspace
                _reloadPool(callback);
            }
        });
    });
};

/**
 * Close all the connections in the connection pool.
 *
 * @param  {Function}  callback  A standard callback function, invoked when all the connections are closed.
 */
var close = module.exports.close = function(callback) {
    pool.on('close', callback);
    pool.close();
};

/**
 * Create a keyspace if it does not exist. If it does, then this will have no effect.
 * 
 * @param  {String}    name                The name of your keyspace
 * @param  {Function}  callback            Callback method
 * @param  {Object}    callback.err        An error that occurred, if any
 * @param  {Boolean}   callback.created    Specifies whether or not a keyspace was actually created.
 */
var createKeyspace = module.exports.createKeyspace = function(name, callback) {
    callback = callback || function() {};

    var options = {
        name: name,
        strategyClass: CONFIG.strategyClass || 'SimpleStrategy',
        strategyOptions: CONFIG.strategyOptions,
        replication: CONFIG.replication || 1,
        durable: CONFIG.durable
    };

    // only create it if it exists.
    keyspaceExists(name, function(err, exists) {
        if (err) {
            return callback(err);
        }
        if (!exists) {
            pool.createKeyspace(name, options, function(err) {
                if (err) {
                    return callback(err);
                }
                // pause for a second to ensure the keyspace gets agreed upon across the cluster.
                setTimeout(callback, 1000, null, true);
            });
        } else {
            return callback(null, false);
        }
    });
};

/**
 * Drops a keyspace
 * 
 * @param  {String}    name                The keyspace that should be dropped.
 * @param  {Function}  callback            Standard callback function
 * @param  {Object}    callback.err        An error that occurred, if any
 * @param  {Boolean}   callback.dropped    Whether or not the keyspace was dropped
 */
var dropKeyspace = module.exports.dropKeyspace = function(name, callback) {
    callback = callback || function() {};
    runQuery('DROP KEYSPACE ' + name, false, function(err) {
        if (err) {
            return callback(err);
        } 
        callback(false, true);
    });
};

/**
 * Checks if a keyspace exists or not.
 * 
 * @param  {String}     name            The name of the keyspace to check
 * @param  {Function}   callback        Gets called with an error object (if any) and a boolean whether or not the keyspace exists.
 * @param  {Object}     callback.err    An error that occurred, if any
 * @param  {Boolean}    callback.exists Whether or not the keyspace existed
 */
var keyspaceExists = module.exports.keyspaceExists = function(name, callback) {
    _describeKeyspace(name, function(err, def) {
        callback(err, def !== null);
    });
};

/**
 * Checks if a CF exists or not.
 * 
 * @param  {String}   name     The name of the CF to check.
 * @param  {Function} callback Gets called with an error object (if any) and a boolean whether or not the CF exists.
 */
var columnFamilyExists = module.exports.columnFamilyExists = function(name, callback) {
    _describeKeyspace(CONFIG.keyspace, function(err, definition) {
        if (err) {
            return callback(err);
        }
        var exists = false;
        for (var i = 0; i < definition.cf_defs.length;i++) {
            if (definition.cf_defs[i].name === name) {
                exists = true;
                break;
            }
        }
        callback(false, exists);
    });
};


/**
 * Drops a Column family. A query will only be performed if the CF exists.
 * 
 * @param  {String}   name     The name of CF you wish to drop.
 * @param  {Function} callback Gets called with an error object (if any) and a boolean whether or not the CF was dropped.
 */
var dropColumnFamily = module.exports.dropColumnFamily = function(name, callback) {
    // Only drop if it exists.
    columnFamilyExists(name, function(err, exists) {
        if (err) {
            return callback(err);
        } else if (!exists) {
            return callback({'code': 400, 'msg': 'The CF ' + name + ' could not be dropped as it does not exist'});
        }
        runQuery('DROP COLUMNFAMILY ?', [name], function(err) {
            if (err) {
                return callback(err);
            } 
            // Helenus caches the CF schema internally.
            // there is no way of refreshing that (synchronously)
            // We close the pool and create a new connection.
            // This makes using this method not suitable for production use!
            _reloadPool(function(err) {
                if (err) {
                    return callback(err);
                }
                callback(false, true);
            });
        });
    });
};

/**
 * Drop a batch of column families. This is a helper method that will be
 * used by various OAE modules when they are initialized. The column families
 * will only be created when they don't exist yet
 * 
 * @param  {Array}         families        Array containing the names of all column families that should be dropped
 * @param  {Function}      callback        Standard callback function. Gets called when the process is complete
 * @param  {Object}        callback.err    An error that occurred, if any
 */
var dropColumnFamilies = module.exports.dropColumnFamilies = function(families, callback) {
    callback = callback || function() {};
    _dropColumnFamilies(families.slice(0), callback);
};

/**
 * Synchronously drop a batch of column families. The array passed in here will be altered in order to recursively
 * drop the column families.
 *
 * @param  {Array}      families        Array containing the names of all column families that should be dropped.
 * @param  {Function}   callback        Standard callback function. Gets executed when the process is complete
 * @param  {Object}     callback.err    An error that occurred, if any
 * @api private
 */
var _dropColumnFamilies = function(families, callback) {
    if (families.length === 0) {
        return callback();
    }

    var family = families.pop();
    dropColumnFamily(family, function(err) {
        if (err) {
            return callback(err);
        }
        _dropColumnFamilies(families, callback);
    })
}

/**
 * Creates a CF if it doesn't exist yet. This is basically a helper method
 * that allows for quick creation of CF if nescecary.
 * Do NOT use this in a concurrent way as the pooled connection will be shut down!
 *
 * @param  {String}                  name               CF name
 * @param  {String}    cql                The CQL that can be used to create the CF if it doesn't exist.
 * @param  {Function}  callback           Gets called when the CF has been created (or it failed.)
 * @param  {Object)}   callback.err       Error object containing the error message
 * @param  {Boolean)}  callback.created   Whether or not the column family has actually been created
 */
var createColumnFamily = module.exports.createColumnFamily = function(name, cql, callback) {
    callback = callback || function() {};
    columnFamilyExists(name, function(err, exists) {
        if (err) {
            return callback(err);
        }

        if (!exists) {
            runQuery(cql, false, function(err) {
                if (err) {
                    return callback(err);
                }

                // Helenus caches the CF schema internally.
                // there is no way of refreshing that (synchronously)
                // We close the pool and create a new connection.
                // This makes using this method not suitable for production use!
                _reloadPool(function(err) {
                    if (err) {
                        return callback(err);
                    }
                    callback(false, true);
                });
            });
        } else {
            callback(false, false);
        }
    });
};

/**
 * Create a batch of column families. This is a helper method that will be
 * used by various OAE modules when they are initialized. The column families
 * will only be created when they don't exist yet
 * 
 * @param  {Object}        families        JSON object representing the column families that need to be created. The keys are the names of the CFs, the values are the CQL statements required to create them
 * @param  {Function}      callback        Standard callback functionGets called when the CFs have been created.
 * @param  {Object}        callback.err    An error that occured, if any.
 */
var createColumnFamilies = module.exports.createColumnFamilies = function(families, callback) {
    callback = callback || function() {};
    var keys = _.keys(families).slice(0);
    _createColumnFamilies(keys, families, callback);
};

/**
 * Internal version of createColumnFamilies that is equiped to create a set of column families synchronously.
 *
 * @param  {String[]}      keys            The key array (keys of the families JSON object) identifying the CF's to create
 * @param  {Object}        families        JSON object representing the column families that need to be created. The keys are the names of the CFs, the values are the CQL statements required to create them
 * @param  {Function}      callback        Standard callback functionGets called when the CFs have been created.
 * @param  {Object}        callback.err    An error that occurred, if any
 * @api private
 */
var _createColumnFamilies = function(keys, families, callback) {
    if (keys.length === 0 ) {
        return callback();
    }

    var cfKey = keys.pop();
    createColumnFamily(cfKey, families[cfKey], function(err) {
        if (err) {
            return callback(err);
        }
        _createColumnFamilies(keys, families, callback);
    });
};

/**
 * Run a single Cassandra query.
 * 
 * @param  {String}   query      The CQL query
 * @param  {array}    parameters An array of values that can be interpreted by cassandra. If an element is detected as an array the query and parameters will be fixed.
 * @param  {Function} callback   Callback method.
 */
var runQuery = module.exports.runQuery = function(query, parameters, callback) {
    if (/SELECT/.test(query)) {
        Telemetry.incr('read');
    } else {
        Telemetry.incr('write');
    }
    executeQuery(query, parameters, callback);
};

/**
 * Run a batched Cassandra query.
 * 
 * @param  {Object[]}   queries     An array of simple hashes. Each hash should contain a query key and parameters key.
 * @param  {String}     consistency The consistency to apply to the batch request. Should be one of QUORUM, ONE or ANY.
 * @param  {Function}   callback    Callback method
 */
var runBatchQuery = module.exports.runBatchQuery = function(queries, consistency, callback) {
    if (queries.length === 0) {
        return callback();
    }

    Telemetry.incr('write');

    consistency = consistency || 'QUORUM';

    var query = 'BEGIN BATCH USING CONSISTENCY ' + consistency + ' \n';
    var parameters = [];
    for (var i = 0; i < queries.length;i++) {
        query += queries[i].query + '; \n';
        parameters = parameters.concat(queries[i].parameters);
    }
    query += 'APPLY BATCH;';
    executeQuery(query, parameters, callback);
};

/**
 * Convert to given cassandra row to a column hash. Keyed by the column name, with value being the column value.
 *
 * @param   {Row}       row     The cassandra Row to convert to a hash
 * @return  {Object}            Return an Object, keyed by the column name, with values being the column value.
 */
var rowToHash = module.exports.rowToHash = function(row) {
    var result = {};
    row.forEach(function(name, value) {
        // We filter out null values, as Cassandra will return these when a query term has not matched
        // against an existing column
        if (value !== null) {
            result[name] = value;
        }
    });
    return result;
};

/**
 * Utility method that returns proper paging variables that can be used to run a paged query. 
 * 
 * The returned object holds 3 keys:
 * 
 * - `start`: The column name to start selecting from
 * - `limit`: The number of columns that should be retrieved. If the `start` value is specified it will increase the `limit` value by one.
 * - `startIndex`: From what index you should start reading as the `start` column will be in the results.
 *
 * @param  {String} start           The column name to start from. Can be null. If it is not null this column will be included and the startIndex will be incremented by one. (ie: you can start from the *next* column.)
 * @param  {Number} limit           The amount of columns that should be retrieved. If this value is null/undefined, `25` will be used.
 * @param  {String} startIfEmpty    If the `start` parameter is null or undefined this value will be used. If this is left null or undefined an empty string will be used.
 * @return {Object}                 The paging parameters as specified in the description
 *                                   
 */
var getPagingParameters = module.exports.getPagingParameters = function(start, limit, startIfEmpty) {
    var limit = limit || 25;
    var startIndex = 0;
    startIfEmpty = startIfEmpty || '';
    if (start) {
        limit++;
        startIndex = 1;
    } else {
        start = startIfEmpty;
    }
    return {
        'start': start,
        'limit': limit,
        'startIndex': startIndex
    };
};

/**
 * Utility method that constructs an update CQL query with a flexible number of columns, that can both
 * be used for inserts and updates.
 * This creates a query with the following form: UPDATE testCF SET ? = ?, ? = ?, ? = ? WHERE testId = ?
 * 
 * @param  {String}     cf              The name of the column family in which we're doing an update/insert
 * @param  {String}     rowKey          The row key that will be used in the WHERE clause
 * @param  {String}     rowValue        The value of the row key to use in the WHERE clause
 * @param  {Object}     values          JSON object where the keys represent the column names of the columns that need to be updated/inserted and the values represent the new column values
 * @param  {String}     consistency     The consistency level that should be used for the query (e.g. QUORUM). This is optional in case this function would be used to construct the segments of a batch query
 * @return {Object}                     Returns a JSON object with a query key that contains the generated CQL query and a parameters key that contains the generated parameter array {query: CQLQuery, parameters: [parameterArray]}
 */
var constructUpsertCQL = module.exports.constructUpsertCQL = function(cf, rowKey, rowValue, values, consistency) {
    // Check that cf, whereColumn and whereValue have been provided 
    // Also check that values has at least 1 key-value pair
    if (!cf || !rowKey || !rowValue || _.keys(values).length === 0) {
        return false;
    }
    // Construct the query
    var q = {
        'query': '',
        'parameters': []
    };
    var tempQuery = [];
    for (var i in values) {
        tempQuery.push('? = ?');
        q.parameters.push(i, values[i]);
    }
    q.query = 'UPDATE ' + cf;
    // Only add the consistency if it has been provided
    if (consistency) {
        q.query += ' USING CONSISTENCY ' + consistency;
    }
    q.query += ' SET ' + tempQuery.join(', ') + ' WHERE ' + rowKey + ' = ?';
    q.parameters.push(rowValue);
    return q;
};

/**
 * Actually executes a query
 * 
 * @param  {String}    query       The query
 * @param  {Object[]}  parameters  The parameters that match this query
 * @param  {Function}  callback    Callback
 * @api private
 */
var executeQuery = function(query, parameters, callback) {
    callback = callback || function() {};
    // Check for null parameters that have been passed in. We have to intercept this
    // because otherwise the query will fail and an "All connections are unhealty"
    // error will start coming back for each Cassandra query
    for (var p = 0; p < parameters.length; p++) {
        if (parameters[p] === null || parameters[p] === undefined) {
            return callback({
                'code': 400,
                'msg': 'An incorrect query has been attempted. The query was "' + query + '" and the parameters that have been passed in were "[' + parameters + ']"'
            });
        }
    };

    // copy the parameters if they were specified so we can log on them if there is an error.
    var logParams = parameters ? parameters.slice(0) : null;

    pool.cql(query, parameters, function(err, results) {
        if (err) {
            log().error({
                err: err,
                query: query,
                parameters: logParams
            }, 'An error occurred executing a cassandra query.');
            return callback({'code': 500, 'msg': err});
        }
        callback(err, results);
    });
};

/**
 * Describes the keyspace identified by 'keyspace'.
 * 
 * @param  {String}     keyspace            The keyspace to describe
 * @param  {Function}   callback            Standard callback method
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Object}     callback.definition The keyspace definition. If null, then the keyspace does not exist.
 * @api private
 */
var _describeKeyspace = function(keyspace, callback) {
    pool.getConnection()._client.describe_keyspace(keyspace, function(err, definition) {
        if (err && err.name) {
            if (err.name === 'NotFoundException') {
                callback(null, null);
            } else {
                callback(err);
            }
        } else {
            callback(null, definition);
        }
    });
};

/**
 * Close and re-open the cassandra connection pool.
 *
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 * @api private
 */
var _reloadPool = function(callback) {
    close(function() {
        // Initialize the pooled connections immediately.
        pool = _createPool(CONFIG);
        pool.connect(callback);
    });
};

/**
 * Create a cassandra connection pool.
 * 
 * @api private
 */
var _createPool = function(config) {
    var _pool = new Helenus.ConnectionPool(config);
    _pool.on('error', function(err) {
        log().error({err: err}, 'Error emmitted from the connection pool');
    });
    return _pool;
};


