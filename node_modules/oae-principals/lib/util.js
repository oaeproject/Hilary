/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var clone = require('clone');
var sanitize = require('validator').sanitize;

var AuthzAPI = require('oae-authz');
var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var Redis = require('oae-util/lib/redis');
var TZ = require('oae-util/lib/tz');

var Group = require('./model').Group;
var User = require('./model').User;
var VISIBILITY_OPTIONS = require('./model').VISIBILITY_OPTIONS;

/**
 * Gets a principal.
 * In case the principalId is a userId, Redis will be checked first. If it could not be
 * found there or if Redis failed to respond to the request, Cassandra will be checked.
 * 
 * @param  {Context}    ctx                 The current context
 * @param  {String}     principalId         The ID of the principal that should be retrieved.
 * @param  {Function}   callback            A callback method.
 * @param  {Object}     callback.err        An error object (if any)
 * @param  {Group|User} callback.principal  The asked for principal.
 */
var getPrincipal = module.exports.getPrincipal = function(ctx, principalId, callback) {
     if (isUser(principalId)) {
        // Get user from Redis.
        getUserFromRedis(ctx, principalId, function(err, user) {
            // If an error occurs (like redis being down, corrupt, ..)
            if (err && err.code !== 404) {
                log().error({'err': err}, 'Error occurred when trying to get a user from Redis.');
            // If we find something, immediately return.
            } else if (user) {
                return callback(null, user);
            // If we don't find anything, grab it from Cassandra.
            } else {
                getPrincipalFromCassandra(ctx, principalId, callback);
            }
        });
    } else {
        // Get groups from the DB.
        getPrincipalFromCassandra(ctx, principalId, callback);
    }
};

/**
 * Get a principal from Cassandra.
 *
 * @param  {Context}        ctx                 The current context
 * @param  {String}         principalId         The ID of the principal that should be retrieved.
 * @param  {Function}       callback            A callback method.
 * @param  {Object}         callback.err        An error object (if any)
 * @param  {Group|User}     callback.principal  The asked for principal.
 * @api private
 */
var getPrincipalFromCassandra = function(ctx, principalId, callback) {
    Cassandra.runQuery('SELECT * FROM Principals USING CONSISTENCY QUORUM WHERE principalId = ?', [principalId], function (err, rows) {
        if (err) {
            return callback(err);
        }

        // check if no users were returned
        if (rows[0].count === 1) {
            return callback({'code': 404, 'msg': "Couldn't find principal: " + principalId});
        }

        var principal = getPrincipalFromRow(ctx, rows[0]);

        if (isGroup(principal.id)) {
            callback(null, principal);
        } else {
            // Deep-copy the User object *before* we apply the visibility settings.
            // this allows us to retrieve a full object from redis later.
            var hash = clone(principal);
            applyVisibility(ctx, principal);

            // Immediately callback, storing something in redis can happen async.
            callback(null, principal);

            // Redis takes only strings as hash field values so convert non-strings.
            // Convert or remove values that shouldn't be in redis.
            delete hash.isAdmin;
            hash.isGlobalAdmin = '' + principal.isGlobalAdmin();
            hash.isTenantAdmin = '' + principal.isTenantAdmin(principal.tenant);

            // Convert the extra object.
            if (hash.extra) {
                try {
                    hash.extra = JSON.stringify(hash.extra);
                } catch (err) {
                    log().error({'err': err}, "Failed to stringify the extra object for %s", principalId);
                }
            }

            // Store it in redis
            Redis.getClient().hmset(principalId, hash);
        }
    });
};

/**
 * Get a user from Redis. If the user can't be found an error object with code 404 will be returned.
 *
 * @param  {Context}    ctx                 The current context
 * @param  {String}     userId              The ID of the user that should be retrieved.
 * @param  {Function}   callback            A callback method.
 * @param  {Object}     callback.err        Standard error object. If the user could not be found, a 404 code will be used.
 * @param  {User}       callback.principal  The asked for user (or null).
 * @api private
 */
var getUserFromRedis = function(ctx, userId, callback) {
    Redis.getClient().hgetall(userId, function(err, hash) {
        if (err) {
            return callback({'code': 500, 'msg': err});
        } else if (!hash) {
            return callback({'code': 404, 'msg': 'Principal not found in redis'});
        }

        // We don't need to do validation as that has already happened.
        hash.isGlobalAdmin = (hash.isGlobalAdmin === 'true');
        hash.isTenantAdmin = (hash.isTenantAdmin === 'true');
        hash.principalId = userId;

        var user = hashToUser(hash);

        // Any potential extra fields.
        if (hash.extra) {
            try {
                user.extra = JSON.parse(hash.extra);
            } catch (err) {
                log().error({'err': err}, "Failed to parse the stringified extra object for %s", userId);
            }
        }

        // In case this user has some information on his User object
        // that should not be exposed.
        applyVisibility(ctx, user);

        return callback(null, user);
    });
};

/**
 * Retrieves a principal from a row object. This does not perform any visibility
 * checks.
 *
 * @param  {Context}       ctx     The current context
 * @param  {Row}           row     A Helenus row object.
 * @return {User|Group}            A user or group object.
 * @api private
 */
var getPrincipalFromRow = function(ctx, row) {
    if (isGroup(row.get('principalId').value)) {
        // The data that sits on the group object is always visible.
        return rowToGroup(row);
    } else {
        return rowToUser(row);
    }
};

/**
 * Hides sensitive user information in case the visibility has been set to
 * `loggedin` or `private`.
 *
 * @param {Context}     ctx     The current context
 * @param {User}        user    A user object,
 * @api private
 */
var applyVisibility = function(ctx, user) {
    var isAnon = !ctx.user();
    var isTargetUser = (!isAnon && ctx.user().id === user.id);
    var isAdmin = (!isAnon && ctx.user().isAdmin && ctx.user().isAdmin(user.tenant));

    if (isAdmin || isTargetUser) {
        return user;
    }

    // Hide the sensitive profile information if needed
    if ((user.visibility === VISIBILITY_OPTIONS.LOGGEDIN && isAnon) ||
        (user.visibility === VISIBILITY_OPTIONS.PRIVATE && !isTargetUser)) {
        // the user does not have access to see the 'private' portion of this user's info
        user.displayName = user.publicAlias;
        delete user.publicAlias;
        delete user.timezone;
        delete user.locale;
        delete user.extra;
    } else {
        // they have access to see private but are not the target user, avoid exposing the public alias unnecessarily
        delete user.publicAlias;
    }
};

/**
 * Gets a set of principals (user or groups). This method *will* return an error if some of the principals
 * don't exist.
 *
 * @param  {Context}   ctx                         The current context
 * @param  {String[]}  principalIds                The ID of the principal that should be retrieved.
 * @param  {Function}  callback                    Standard callback function
 * @param  {Object}    callback.err                Error object containing the error message.
 * @param  {Object}    callback.principals         Object representing the retrieved principals. The keys will be the principal ids and the values will be the principal basic profiles
 */
var getPrincipals = module.exports.getPrincipals = function(ctx, principalIds, callback) {
    // No need to do anything if the requested array of principal IDs is empty.
    if (principalIds.length === 0) {
        return callback(null, {});
    }

    // If we're only requesting 1 principal we can hand it off to the getPrincipal method.
    // This will try looking in the cache first, which might be faster.
    if (principalIds.length === 1) {
        return getPrincipal(ctx, principalIds[0], function(err, user) {
            if (err) {
                return callback(err);
            }
            var users = {};
            users[user.id] = user;
            return callback(null, users);
        });
    }

    // Go to cassandra if we're requesting more than 1 principal.
    Cassandra.runQuery("SELECT * FROM Principals USING CONSISTENCY QUORUM WHERE principalId IN (?)", [principalIds], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var isMissingPrincipals = false;
        var principals = {};
        for (var i = 0; i < rows.length; i++) {
            // An empty row will come back for non-existing principals
            if (rows[i].count > 1) {
                var principal = getPrincipalFromRow(ctx, rows[i]);
                if (isUser(principal.id)) {
                    applyVisibility(ctx, principal);
                }
                principals[principal.id] = principal;
            } else {
                isMissingPrincipals = true;
            }
        }

        if (isMissingPrincipals) {
            return callback({'code': 400, 'msg': 'These principals could not be found: ' + _.difference(principalIds, _.keys(principals))});
        }

        callback(null, principals);
    });
};

/**
 * Check if an identifier really is a group identifier.
 * 
 * @param  {String}  groupId    An identifier
 * @return {Boolean}            Whether or not the provided identifier is a group identifier.
 */
var isGroup = module.exports.isGroup = function(groupId) {
    var principal = AuthzUtil.getPrincipalFromId(groupId);
    return (principal.principalType === "g");
};

/**
 * Check if an identifier really is a user identifier.
 * 
 * @param  {String}  userId     An identifier
 * @return {Boolean}            Whether or not the provided identifier is a user identifier.
 */
var isUser = module.exports.isUser = function(userId) {
    var principal = AuthzUtil.getPrincipalFromId(userId);
    return (principal.principalType === "u");
};

/**
 * Creates a Group from a Cassandra row.
 * 
 * @param  {Row}    row     Cassandra Row
 * @return {Group}          A group object.
 * @api private
 */
var rowToGroup = function (row) {
    var hash = Cassandra.rowToHash(row);
    return new Group(hash.tenant, hash.principalId, hash.alias, hash.name, hash.description, hash.visibility, hash.joinable);
};

/**
 * Creates a User from a Cassandra row.
 * 
 * @param  {Row}    row     Cassandra Row
 * @return {User}           A User object.
 * @api private
 */
var rowToUser = function(row) {
    var hash = Cassandra.rowToHash(row);
    hash.isGlobalAdmin = (row.get('admin:global') && sanitize(row.get('admin:global').value).toBooleanStrict());
    hash.isTenantAdmin = (row.get('admin:tenant') && sanitize(row.get('admin:tenant').value).toBooleanStrict());
    var user = hashToUser(hash);

    // The row might contain extra data that we wish to pass back.
    user.extra = {};
    var keys = _.keys(hash);
    var blacklist = ['tenant', 'principalId', 'displayName', 'visibility', 'locale', 'timezone', 'publicAlias', 'admin:global', 'admin:tenant'];
    for (var i = 0; i < keys.length; i++) {
        if (blacklist.indexOf(keys[i]) === -1 && typeof user[keys[i]] !== 'function') {
            user.extra[keys[i]] = hash[keys[i]];
        }
    }

    return user;
};

/**
 * Creates a User from a hash.
 * 
 * @param  {Object} hash Hash that has the required keys and values.
 * @return {User}        A User object.
 * @api private
 */
var hashToUser = function(hash) {
    // Ensure that the timezone we're setting is something the app
    // can deal with.
    var timezone = hash.timezone;
    if (timezone === 'UTC') {
        timezone = 'Etc/UTC';
    }
    try {
        var date = new TZ.Date(null, timezone);
        if (date.getTimezone === null) {
            throw new Error();
        }
    } catch (err) {
        // We can't deal with this timezone.
        // default to UTC
        timezone = 'Etc/UTC';
    }

    return new User(hash.tenant, hash.principalId, hash.displayName, {
        'visibility': hash.visibility,
        'locale': hash.locale,
        'timezone': timezone,
        'publicAlias': hash.publicAlias,
        'isGlobalAdmin': hash.isGlobalAdmin,
        'isTenantAdmin': hash.isTenantAdmin
    });
};
