var CassandraSystem = require('cassandra-client').System;
var PooledConnection = require('cassandra-client').PooledConnection;
var Connection = require('cassandra-client').Connection;
var CassandraTypes = require('cassandra-client/lib/gen-nodejs/cassandra_types');

var OAE = require('oae-util/lib/OAE');
var IO  = require('oae-util/lib/IO');

var CONFIG = null;
var sys = null;
var oaeConn = null;


/**
 * The PooledConnection and Connection interfaces are not the same.
 * As the unittests can't properly make use of the PooledConnection objects
 * we create a small abstraction facade that can perform the required logic
 * depending if we're using a Pooled- or regular Connection.
 *
 * @param {Object} config A config that can be used with PooledConnection or Connection. 
 *                        This should follow the config format for node-cassandra-client and provide an extra key
 *                        'type' which equals either 'pool' or 'simple'.
 */
var OaeConnection = function(config) {

    var that = {};
    that.type = config.type;
    if (that.type === 'pool') {
        that.con = new PooledConnection(config);
    } else {
        that.con = new Connection(config);
    }


    /**
     * Only connects in case we're using the simple connection.
     * 
     * @param  {Function(err)} callback callback method.
     */
    that.connect = function(callback) {
        if (that.type === 'pool') {
            // Pooled connections don't need connect.
            callback();
        }
        else {
            that.con.connect(function(err) {
                if (err) {
                    return callback(err);
                }
                callback(false);
            });
        }
    };

    /**
     * This method is the same on Connection and PooledConnection
     * 
     * @param  {String}     query        Query string
     * @param  {Object[]}   parameters   An array of parameters
     * @param  {Function(err, rows)}   callback     Callback method.
     */
    that.execute = function(query, parameters, callback) {
        that.con.execute(query, parameters, callback);
    };

    /**
     * Closes the connection if it needs to be closed.
     * 
     * @param  {Function(err)} callback Callback method
     */
    that.close = function(callback) {
        if (that.type === 'pool') {
            // Pooled connections don't need close.
            callback();
        }
        else {
            that.con.close(callback);
        }
    };

    /**
     * Shuts down the pooled connections.
     * 
     * @param  {Function(err)} callback Callback method
     */
    that.shutdown = function(callback) {
        if (that.type === 'pool') {
            that.con.shutdown(callback);
        } else {
            callback(false);
        }
    };

    return that;
};

var getSys = function() {
    if (sys === null) {
        sys = new CassandraSystem(CONFIG.system);
    }
    return sys;
};

/**
 * Initializes the keyspace in config.keyspace with the CF's in all the modules their install.js code.
 */
module.exports.init = function(config) {
    CONFIG = config;
    // Initialize the System connnector immediately.
    sys = new CassandraSystem(CONFIG.system);

    // Initialize the pooled connections immediately.
    if (config.type === 'pool') {
        oaeConn = new OaeConnection(config);
    }

    var keyspace = CONFIG.keyspace;

    module.exports.keyspaceExists(keyspace, function(err, exists) {
        if (!exists) {
            module.exports.createKeyspace(keyspace, function(err, created) {
                if (!created) {
                    throw "Couldn't create the keyspace. Aborting startup.";
                }

                console.log("Created keyspace: " + keyspace);

                OAE.getAvailableModules(function(modules) {
                    var installModule = function(module) {
                        var path = "node_modules/" + module + "/install/install.js";
                        IO.pathExists(path, function(exists) {
                            if (exists) {
                                console.log("installed " + module);
                                require("../../../" + path);
                            }
                        });
                    };


                    for (var i = 0; i < modules.length;i++) {
                        installModule(modules[i]);
                    }

                });
            });
        }
    });
};


/**
 * Get a connection to Cassandra.
 * @return {OaeConnection}
 */
module.exports.getConnection = function() {
    // If we're using simple connections we simply create a new instance each time.
    if (CONFIG.type === 'simple') {
        oaeConn = new OaeConnection(CONFIG);
    }

    return oaeConn;
};

module.exports.close = function(callback) {
    sys.close(function() {
        oaeConn.shutdown(function() {
            oaeConn = null;
            sys.removeAllListeners();
            sys = null;
            callback();
        });
    });
};

/**
 * Create a keyspace
 * @param  {String}   name     The name of your keyspace
 * @param  {Function(err, created)} callback Callback method
 */
module.exports.createKeyspace = function(name, callback) {
    var ksDef = new CassandraTypes.KsDef({
        name: name, 
        strategy_class: 'org.apache.cassandra.locator.SimpleStrategy',
        strategy_options: {
            'replication_factor': '1'
        },
        cf_defs: []
    });
    getSys().addKeyspace(ksDef, function(err) {
        if (err) {
            callback(err, false);
        }
        else {
            callback(null, true);
        }
    });
};

/**
 * Drops a keyspace
 * @param  {String}   name     The keyspace that should be dropped.
 * @param  {Function(err, dropped)} callback dropped is a boolean that states whether or not a keyspace was dropped.
 * @return {[type]}
 */
module.exports.dropKeyspace = function(name, callback) {
    module.exports.runQuery("drop keyspace " + name, false, function(err) {
        if (err) {
            callback(err, false);
        }
        else {
            callback(false, true);
        }
    });
};

/**
 * Checks if a keyspace exists or not.
 * @param  {String}   name     The name of the keyspace to check.
 * @param  {Function(err, exists)} callback Gets called with an error object (if any) and a boolean whether or not the keyspace exists.
 */
module.exports.keyspaceExists = function(name, callback) {
    getSys().describeKeyspace(name, function(err, definition) {
        if (err) {
            callback(err, false);
        }
        else {
            callback(false, true);
        }
    });
};

/**
 * Checks if a CF exists or not.
 * @param  {String}   name     The name of the CF to check.
 * @param  {Function(err, exists)} callback Gets called with an error object (if any) and a boolean whether or not the CF exists.
 */
module.exports.columnFamilyExists = function(name, callback) {
    getSys().describeKeyspace(CONFIG.keyspace, function(err, definition) {
        if (err) {
            callback(err, false);
        }
        else {
            var exists = false;
            for (var i = 0; i < definition.cf_defs.length;i++) {
                if (definition.cf_defs[i].name === name) {
                    exists = true;
                    break;
                }
            }

            callback(false, exists);
        }
    });
};


/**
 * Drops a Column family. A query will only be performed if the CF exists.
 * @param  {String}   name     The name of CF you wish to drop.
 * @param  {Function(err, dropped)} callback Gets called with an error object (if any) and a boolean whether or not the CF was dropped.
 */
module.exports.dropColumnFamily = function(name, callback) {
    // Only drop if it exists.
    module.exports.columnFamilyExists(name, function(err, exists) {
        if (err) {
            callback(err, false);
        }
        else {
            if (exists) {
                module.exports.runQuery('drop columnfamily ?', [name], function(err) {
                    if (err) {
                        callback(err, false);
                    }
                    else {
                        callback(false, true);
                    }
                });
            } else {
                callback(false, false);
            }
        }
    });
};

/**
 * Creates a CF if it doesn't exist. This is basically a helper method
 * that allows for quick creation of CF if nescecary.
 * 
 * @param  {String}   name     CF name
 * @param  {String}   cql      The CQL that can be used to create the CF if it doesn't exist.
 * @param  {Function(err, created)} callback Gets called when the CF has been created (or it failed.)
 */
module.exports.createColumnFamilyIfNotExists = function(name, cql, callback) {
    module.exports.columnFamilyExists(name, function(err, exists) {
        if (err) {
            return callback(err, false);
        }

        if (!exists) {
            module.exports.runQuery(cql, false, function() {
                if (err) {
                    return callback(err, false);
                }

                if (callback) {
                    callback(false, true);
                }
            });
        }
    });
};

/**
 * Run a single Cassandra query.
 * @param  {String}   query      The CQL query
 * @param  {array}    parameters An array of values that can be interpreted by node-cassandra-client. If an element is detected as an array the query and parameters will be fixed.
 * @param  {Function} callback   Callback method.
 */
module.exports.runQuery = function(query, parameters, callback) {
    var fixed = fixQuery(query, parameters);
    executeQuery(fixed.query, fixed.parameters, callback);
};

/**
 * Run a batched Cassandra query.
 * @param  {Object[]}   queries  An array of simple hashes. Each hash should contain a query key and parameters key.
 * @param  {Function}   callback Callback method
 */
module.exports.runBatchQuery = function(queries, callback) {
    var query = 'BEGIN BATCH USING CONSISTENCY ONE \n';
    var parameters = [];
    for (var i = 0; i < queries.length;i++) {
        var fixed = fixQuery(queries[i].query, queries[i].parameters);
        query += fixed.query + "; \n";
        parameters = parameters.concat(fixed.parameters);
    }
    query += 'APPLY BATCH;';
    executeQuery(query, parameters, callback);
};

/**
 * Adds the ability to pass in array parameters. If you pass in a parameter that is an array, the apropriate number of question marks will be added in the query.
 * @param  {String}    query      The query
 * @param  {Object[]}  parameters The parameters for this query.
 */
var fixQuery = function(query, parameters) {
    var fixedQuery = "";
    var fixedParameters = [];
    var q = query.indexOf('?');
    var from = 0;
    var i = 0;
    while (q >= 0) {
        fixedQuery += query.slice(from, q);

        // If we passed in an array add n-1 more question marks.
        if (Array.isArray(parameters[i])) {
            for (var c = 0; c < parameters[i].length - 1;c++) {
                fixedQuery += "?, ";
                fixedParameters.push(parameters[i][c]);
            }
            fixedParameters.push(parameters[i][parameters[i].length - 1]);
        }
        else {
            fixedParameters.push(parameters[i]);
        }
        fixedQuery += '?';


        // Next one.
        from = q+1;
        q = query.indexOf('?', from);
        i++;
    }

    // Append the request of the query.
    fixedQuery += query.slice(from);
    return {'query': fixedQuery, 'parameters': fixedParameters};
};

/**
 * Actually executes a query
 * @param  {String}    query       The query
 * @param  {Object[]}  parameters  The parameters that match this query
 * @param  {Function}  callback    Callback
 */
var executeQuery = function(query, parameters, callback) {
    var con = module.exports.getConnection();
    con.connect(function(err){
        if (err) {
            return callback(err, null);
        }

        con.execute(query, parameters, function(err, rows) {
            con.close(function() {
                callback(err, rows);
            });
        });
    });
};