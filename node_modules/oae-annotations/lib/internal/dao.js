/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var Cassandra = require('oae-util/lib/cassandra');
var log = require('oae-logger').logger('oae-annotations');

var Annotation = require('oae-annotations/lib/model').Annotation;

/**
 * Create a new annotation
 *
 * @param  {Annotation}     annotation      The annotation to persist
 * @param  {Function}       callback        Standard callback function
 * @param  {Object}         callback.err    An error that occurred, if any
 */
var createAnnotation = module.exports.createAnnotation = function(annotation, callback) {
    var values = _.extend({}, annotation);
    values.ranges = JSON.stringify(values.ranges);
    delete values.id;

    var queries = [];
    queries.push(Cassandra.constructUpsertCQL('Annotations', 'annotationId', annotation.id, values));
    queries.push({
        'query': 'INSERT INTO "AnnotationsByRevision" ("revisionId", "annotationId") VALUES (?, ?)',
        'parameters': [annotation.revisionId, annotation.id]
    });
    Cassandra.runBatchQuery(queries, callback);
};

/**
 * Update an existing annotation
 *
 * @param  {Annotation}     annotation              The annotation to update
 * @param  {String}         text                    The new text for the annotation
 * @param  {String}         updatedBy               The ID of the user to update
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Annotation}     callback.annotation     The updated annotation object
 */
var updateAnnotation = module.exports.updateAnnotation = function(annotation, text, updatedBy, callback) {
    var values = {
        'text': text,
        'updatedBy': updatedBy,
        'updated': Date.now()
    };
    var q = Cassandra.constructUpsertCQL('Annotations', 'annotationId', annotation.id, values);
    Cassandra.runQuery(q.query, q.parameters, function(err) {
        if (err) {
            return callback(err);
        }

        var updatedAnnotation = _.extend({}, annotation);
        updatedAnnotation.text = text;
        updatedAnnotation.updated = Date.now();
        updatedAnnotation.updatedBy = updatedBy;
        return callback(null, updatedAnnotation);
    });
};

/**
 * Delete an annotation
 *
 * @param  {Annotation}     annotation      The annotation to delete
 * @param  {Function}       callback        Standard callback function
 * @param  {Object}         callback.err    An error that occurred, if any
 */
var deleteAnnotation = module.exports.deleteAnnotation = function(annotation, callback) {
    var queries = [];

    // Delete the actual annotation
    queries.push({
        'query': 'DELETE FROM "Annotations" WHERE "annotationId" = ?',
        'parameters': [annotation.id]
    });

    // Delete the relationship between the annotation and the revision
    queries.push({
        'query': 'DELETE FROM "AnnotationsByRevision" WHERE "revisionId" = ? AND "annotationId" = ?',
        'parameters': [annotation.revisionId, annotation.id]
    });
    Cassandra.runBatchQuery(queries, callback);
};

/**
 * Get an annotation by its ID
 *
 * @param  {String}         annotationId            The id of the annotation to retrieve
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Annotation}     callback.annotation     The retrieved annotation
 */
var getAnnotation = module.exports.getAnnotation = function(annotationId, callback) {
    Cassandra.runQuery('SELECT * FROM "Annotations" WHERE "annotationId" = ?', [annotationId], function(err, rows) {
        if (err) {
            return callback(err);
        } else if (rows.length === 0) {
            return callback({'code': 404, 'msg': 'No annotation by that ID found'});
        }

        var annotation = _rowToAnnotation(rows[0]);
        return callback(null, annotation);
    });
};

/**
 * Get a set of annotations for a given revision and page
 *
 * @param  {String}         revisionId              The id of the revision for which to retrieve the annotations
 * @param  {Number}         pageNumber              The number of the page for which to retrieve the annotations
 * @param  {Number}         limit                   The number of annotations to retrieve
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Annotation[]}   callback.annotations    The retrieved annotations
 */
var getAnnotations = module.exports.getAnnotations = function(revisionId, pageNumber, limit, callback) {
    pageNumber = pageNumber || 1;
    var start = (pageNumber) + '#';
    var end = (pageNumber + 1) + '#';
    Cassandra.runPagedQuery('AnnotationsByRevision', 'revisionId', revisionId, 'annotationId', start, limit, {'end': end}, function(err, rows) {
        if (err) {
            return callback(err);
        }

        var annotationIds = [];
        _.each(rows, function(row) {
            if (row.get('annotationId')) {
                annotationIds.push(row.get('annotationId').value);
            }
        });
        if (annotationIds.length === 0) {
            return callback(null, []);
        }

        Cassandra.runQuery('SELECT * FROM "Annotations" WHERE "annotationId" IN (?)', [annotationIds], function(err, rows) {
            if (err) {
                return callback(err);
            }

            var annotations = _.map(rows, _rowToAnnotation);
            return callback(null, annotations);
        });
    });
};

/**
 * Get an annotation from a Cassandra row
 *
 * @param  {Row}            row     The cassandra row to convert
 * @return {Annotation}             The annotation for the given row
 * @api private
 */
var _rowToAnnotation = function(row) {
    var hash = Cassandra.rowToHash(row);
    try {
        hash.ranges = JSON.parse(hash.ranges);
    } catch (err) {
        log().warn({'err': err, 'hash': hash}, 'Failed to parse hash ranges');
        hash.ranges = [];
    }
    return new Annotation(hash.annotationId, hash.contentId, hash.revisionId, hash.created, hash.createdBy, hash.updated, hash.updatedBy, hash.pageNumber, hash.text, hash.quote, hash.ranges);
};
