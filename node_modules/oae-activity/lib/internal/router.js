/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var crypto = require('crypto');

var log = require('oae-logger').logger('oae-activity-router');
var Telemetry = require('oae-telemetry').telemetry('activity');

var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;
var ActivityDAO = require('./dao');
var ActivityRegistry = require('./registry');
var ActivitySystemConfig = require('./config');

/**
 * Produce, route and queue an activity from an activity seed.
 *
 * @param  {ActivitySeed}  activitySeed        The activity seed that was used to post the activity
 * @param  {Function}      [callback]          Invoked when the process completes
 * @param  {Object}        [callback.err]      An error that occurred, if any
 */
var routeActivity = module.exports.routeActivity = function(activitySeed, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'activitySeed': activitySeed}, 'Error handling activity.');
        }
    };

    log().trace({'activitySeed': activitySeed}, 'Routing activity seed.');

    // Record the amount of time the activity sat in the message queue before routing began
    Telemetry.appendDuration('mq.time', activitySeed.published);
    var routingStartTime = Date.now();

    // Will aggregate all the activityStreamId (i.e., route) -> activity pairings that will be delivered
    var routedActivities = {};
    var activityId = ActivityDAO.createActivityId(activitySeed.published);

    // Produce all of the activity entities
    _produceAllEntities(activitySeed, function(err, actor, object, target) {
        if (err) {
            return callback(err);
        }

        // Produce the routes for the actor, object and target entities
        _produceAllRoutes(activitySeed, actor, object, target, function(err, actorRoutes, actorPropagation, objectRoutes, objectPropagation, targetRoutes, targetPropagation) {
            if (err) {
                return callback(err);
            }

            /*!
             * Only routes that are included in the propagation specification of each of the actor, object and target are allowed
             * to be routed an activity. Some examples:
             *
             *  1.  If I follow User A, and they add a private content item to which I don't have access to their library, I will
             *      not be on the propagation specification of that content item, therefore I should not ever receive the activity
             *
             *  2.  If I commented on Content A, and it has since become private and I do not have access, and then User A comments
             *      on the content item, I will not receive the activity because I am not in the propagation specification of the
             *      content item (or the comment, for that matter!)
             *
             * Users always have propagation specification of "all" (as they are scrubbed in the transformation phase, therefore
             * private users performing actions does not imply that the activities are not delivered anywhere.
             *
             * Joinable private groups have a propagation of "all" as well, therefore their existence in an activity does not limit
             * the activity routes.
             */

            var allowedRoutes = null;

            if (object && objectPropagation.type === ActivityConstants.entityPropagation.ROUTES) {
                allowedRoutes = objectRoutes.activity.slice();
            } else if (object && objectPropagation.type === ActivityConstants.entityPropagation.SPECIFY) {
                allowedRoutes = objectPropagation.specify.slice();
            }

            if (target && targetPropagation.type === ActivityConstants.entityPropagation.ROUTES) {
                allowedRoutes = allowedRoutes || [];
                allowedRoutes = _.union(allowedRoutes, targetRoutes.activity);
            } else if (target && targetPropagation.type === ActivityConstants.entityPropagation.SPECIFY) {
                allowedRoutes = allowedRoutes || [];
                allowedRoutes = _.union(allowedRoutes, targetPropagation.specify);
            }

            var allActivityRoutes = _.compact(_.union(actorRoutes.activity, objectRoutes.activity, targetRoutes.activity));
            var allNotificationRoutes = _.compact(_.union(actorRoutes.notification, objectRoutes.notification, targetRoutes.notification));

            if (allowedRoutes) {
                // If we have route restrictions, apply them
                allActivityRoutes = _.intersection(allActivityRoutes, allowedRoutes);
                allNotificationRoutes = _.intersection(allNotificationRoutes, allowedRoutes);
            }

            // Create the routed activities for the activity routes
            _.each(allActivityRoutes, function(route) {
                // Create the activity metadata
                var activity = routedActivities[route] = {};
                activity[ActivityConstants.properties.OAE_ACTIVITY_TYPE] = activitySeed.activityType;
                activity[ActivityConstants.properties.OAE_ACTIVITY_ID] = activityId;
                activity.verb = activitySeed.verb;
                activity.published = activitySeed.published;

                if (actor) {
                    activity.actor = actor;
                }

                if (object) {
                    activity.object = object;
                }

                if (target) {
                    activity.target = target;
                }
            });

            // Create the routed activities for the notification routes
            _.each(allNotificationRoutes, function(route) {
                if (route === actor[ActivityConstants.properties.OAE_ID]) {
                    // Never deliver a notification to the actor themself
                    return;
                }

                // Create the activity metadata
                var activity = routedActivities[route + '#notification'] = {};
                activity[ActivityConstants.properties.OAE_ACTIVITY_TYPE] = activitySeed.activityType;
                activity[ActivityConstants.properties.OAE_ACTIVITY_ID] = activityId;
                activity.verb = activitySeed.verb;
                activity.published = activitySeed.published;

                if (actor) {
                    activity.actor = actor;
                }

                if (object) {
                    activity.object = object;
                }

                if (target) {
                    activity.target = target;
                }
            });

            log().trace({
                'activitySeed': activitySeed,
                'routedActivities': routedActivities
            }, 'Queueing activities to be routed.');

            // Queue the activity entities to be collected and aggregated
            _queueActivities(activitySeed, routedActivities, function(err, buckets) {
                if (err) {
                    return callback(err);
                }

                // The number of activities that were handled
                Telemetry.incr('count');

                // How many routed activities are created and how long it took
                Telemetry.incr('routed.count', _.keys(routedActivities).length);
                Telemetry.appendDuration('routing.time', routingStartTime);
                return callback();
            });
        });
    });
};


/**
 * Produce activity entities based on the actor, object and target resources of the given activity seed.
 *
 * @param  {ActivitySeed}      activitySeed                The activity seed from which to extract the actor, object and target resource information
 * @param  {Function}          callback                    Invoked when the process completes
 * @param  {Object}            callback.err                An error that occurred, if any
 * @param  {ActivityEntity}    callback.actor              The actor activity entity
 * @param  {ActivityEntity}    [callback.object]           The object activity entity, if one was specified
 * @param  {ActivityEntity}    [callback.target]           The actor activity entity, if one was specified
 * @api private
 */
var _produceAllEntities = function(activitySeed, callback) {
    _produceEntity(activitySeed.activityType, ActivityConstants.entityTypes.ACTOR, activitySeed.actorResource, function(err, actor) {
        if (err) {
            return callback(err);
        }

        _produceEntity(activitySeed.activityType, ActivityConstants.entityTypes.OBJECT, activitySeed.objectResource, function(err, object) {
            if (err) {
                return callback(err);
            }

            _produceEntity(activitySeed.activityType, ActivityConstants.entityTypes.TARGET, activitySeed.targetResource, function(err, target) {
                if (err) {
                    return callback(err);
                }

                return callback(null, actor, object, target);
            });
        });
    });
};

/**
 * Produce an activity entity with the given seed resource information.
 *
 * @param  {String}                activityType            The type of activity for which the entity is being produced
 * @param  {String}                entityType              The type of entity for which the entity is being produced (i.e., actor, object or target)
 * @param  {ActivitySeedResource}  resource                The activity resource that was used to seed the activity
 * @param  {Function}              callback                Invoked when the process completes
 * @param  {Object}                callback.err            An error that occurred, if any
 * @param  {ActivityEntity}        callback.activityEntity The activity entity that was produced
 * @api private
 */
var _produceEntity = function(activityType, entityType, resource, callback) {
    if (!resource) {
        return callback();
    }

    // Find the producer for this resource type. If there isn't one registered, we fall back to the default producer
    var activityEntityProducers = ActivityRegistry.getRegisteredActivityEntityProducers();
    var producer = activityEntityProducers[resource.resourceType] || _defaultActivityEntityProducer;

    producer(activityType, entityType, resource, function(err, entity) {
        if (err) {
            return callback(err);
        }

        // Ensure a valid resource id and resource type
        entity = entity || {};
        entity.objectType = resource.resourceType;
        entity[ActivityConstants.properties.OAE_ID] = resource.resourceId;

        log().trace({
            'activityType': activityType,
            'entityType': entityType,
            'resource': resource,
            'entity': entity
        }, 'Produced activity entity.');

        return callback(null, entity);
    });
};

/**
 * Produce the routes for the given actor, object and target activity entities.
 *
 * @param  {ActivitySeed}      activitySeed                The activity seed that was used to post the activity
 * @param  {ActivityEntity}    actor                       The actor entity that was produced for the activity
 * @param  {ActivityEntity}    [object]                    The object entity that was produced for the activity
 * @param  {ActivityEntity}    [target]                    The target entity that was produced for the activity
 * @param  {Function}          callback                    Invoked when the process completes
 * @param  {Object}            callback.err                An error that occurred, if any
 * @param  {String[]}          callback.actorRoutes        The routes to which to route the activity for the actor
 * @param  {Object}            callback.actorPropagation   How to propagate the actor entity among activity routes
 * @param  {String[]}          callback.objectRoutes       The routes to which to route the activity for the object
 * @param  {Object}            callback.objectPropagation  How to propagate the object entity among activity routes
 * @param  {String[]}          callback.targetRoutes       The routes to which to route the activity for the target
 * @param  {Object}            callback.targetPropagation  How to propagate the target entity among activity routes
 * @api private
 */
var _produceAllRoutes = function(activitySeed, actor, object, target, callback) {
    log().trace({
        'activitySeed': activitySeed,
        'actorEntity': actor,
        'objectEntity': object,
        'targetEntity': target
    }, 'Producing routes for activity entities.');

    _produceRoutes(activitySeed.activityType, ActivityConstants.entityTypes.ACTOR, actor, function(err, actorRoutes, actorPropagation) {
        if (err) {
            return callback(err);
        }

        _produceRoutes(activitySeed.activityType, ActivityConstants.entityTypes.OBJECT, object, function(err, objectRoutes, objectPropagation) {
            if (err) {
                return callback(err);
            }

            _produceRoutes(activitySeed.activityType, ActivityConstants.entityTypes.TARGET, target, function(err, targetRoutes, targetPropagation) {
                if (err) {
                    return callback(err);
                }

                return callback(null, actorRoutes, actorPropagation, objectRoutes, objectPropagation, targetRoutes, targetPropagation);
            });
        });
    });
};

/**
 * Produce the routes for the activity entity.
 *
 * @param  {String}            activityType            The type of activity being routed
 * @param  {String}            entityType              The type of entity for which activities are being routed (e.g., actor, object, target)
 * @param  {ActivityEntity}    entity                  The entity for which to produce the routes
 * @param  {Function}          callback                Invoked when the process completes
 * @param  {Object}            callback.err            An error that occurred, if any
 * @param  {String[]}          callback.routes         The routes to which to route the activity
 * @param  {Object}            callback.propagation    How to propagate the entity among the activity routes
 * @api private
 */
var _produceRoutes = function(activityType, entityType, entity, callback) {
    if (!entity) {
        return callback(null, []);
    }

    var activityRouters = ActivityRegistry.getRegisteredActivityRouters();
    var router = activityRouters[entity.objectType];
    if (!router) {
        log().trace({
            'activityType': activityType,
            'entityType': entityType,
            'entity': entity
        }, 'No router found for object type.');
        return callback();
    }

    router(activityType, entityType, entity, function(err, routes, propagation) {
        if (err) {
            return callback(err);
        }

        // Apply some defaults
        routes = routes || {};
        routes.activity = routes.activity || [];
        routes.notification = routes.notification || [];

        log().trace({
            'activityType': activityType,
            'entityType': entityType,
            'entity': entity,
            'routes': routes,
            'propagation': propagation
        }, 'Generated routes for activity entity.');

        propagation = propagation || {'type': ActivityConstants.entityPropagation.ROUTES};

        return callback(null, routes, propagation);
    });
};

/**
 * An entity producer that simply returns the resource data as the persistent entity.
 *
 * @see #registerActivityEntityProducer for parameter details.
 * @api private
 */
var _defaultActivityEntityProducer = function(activityType, entityType, resource, callback) {
    // Simply return the resourceData. If no resource data was specified, the router will just default to an empty object.
    return callback(null, _.extend({}, resource.resourceData));
};

/**
 * Queue the given set of routed activities for collection.
 *
 * @param  {ActivitySeed}  activitySeed        The activity seed from which the activities were generated.
 * @param  {Object}        routedActivities    An object whose value is the activity to deliver, where the key is the route to which the activity should be delivered.
 * @param  {Function}      callback            Invoked when the routed activities have been queued
 * @param  {Object}        callback.err        An error that occurred, if any
 * @param  {Number[]}      callback.buckets    The collection buckets that received activities as a result of this invocation
 * @api private
 */
var _queueActivities = function(activitySeed, routedActivities, callback) {
    var allRoutes = _.keys(routedActivities);
    var activityBuckets = [];

    allRoutes.forEach(function(route) {
        // Assign all activities to their processing buckets to support safe concurrency
        var bucketNumber = _getBucketNumber(route, activitySeed);
        activityBuckets[bucketNumber] = activityBuckets[bucketNumber] || [];
        activityBuckets[bucketNumber].push({'route': route, 'activity': routedActivities[route]});
    });

    // Queue the aggregates into their associated buckets to indicate they need to be collected and delivered
    ActivityDAO.saveQueuedActivities(activityBuckets, function(err) {
        if (err) {
            return callback(err);
        }

        // Log telemetry for each bucket. Important to monitor for "hot buckets"
        _.each(activityBuckets, function(bucket, bucketNumber) {
            if (bucket && bucket.length) {
                Telemetry.incr('routed.' + bucketNumber + '.count', bucket.length);
            }
        });

        return callback(null, _.keys(activityBuckets));
    });
};


/**
 * Get the bucket number in which a routed activity should be queued. Bucket numbers are chosen to ensure that routed activities
 * that need to be collected in serial (e.g., only one process should collect them at a time) always land in the same bucket (i.e.,
 * because buckets are only collected by one process at one time).
 *
 * The selection is based on a hash of the route and activity type, since all routed activities of the same route and activity type
 * exhert race conditions when aggregating and replacing activities in feeds. When taking into consideration global "public" and
 * "loggedin" routes (not implemented yet, but likely implemented later), it's important to ensure we don't have "hot buckets".
 * Currently it is expected that the bucket that holds the most common activity (e.g., "content-share") of the public route will be
 * the most common bucket, so if that one fills faster than can be collected by a single process, it may be necessary to further
 * discriminate based on other factors, such as characteristics of the aggregate keys.
 *
 * By "characteristics of the aggregate keys", it should be possible to find one identifier that is common in all potential pivot
 * points of the activity. For "content-share", it is the actor, so we could include the ID of the actor in the hash for those
 * types of activities, which should further distribute activities such as "content-share" in the public route. This is not
 * implemented yet as it is not known to be necessary, especially as global public / loggedin routes are not implemented.
 *
 * More information about the race conditions in aggregating activities, please see the documentation in
 * `oae-activity/lib/internal/aggregator.js`.
 *
 * @param  {String}        route           The string of the route.
 * @param  {ActivitySeed}  activitySeed    The activity seed from which the activity seed is being generated.
 * @return {Number}                        The bucket number in which to queue the activity for processing.
 * @api private
 */
var _getBucketNumber = function(route, activitySeed) {
    var sum = crypto.createHash('md5');
    sum.update(route);
    sum.update(activitySeed.activityType);

    // Slice the last 4 characters of the hex to avoid integer overflow. This will give max 2^16 buckets
    var hex = sum.digest('hex').slice(-4);
    return parseInt(hex, 16) % ActivitySystemConfig.getConfig().numberOfProcessingBuckets;
};

