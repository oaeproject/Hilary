/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var fs = require('fs');
var gm = require('gm');
var Path = require('path');
var temp = require('temp');

var log = require('oae-logger').logger('Image');
var Validator = require('oae-util/lib/validator').Validator;


var VALID_EXTENSIONS = ['.jpg', '.jpeg', '.png', '.gif'];

/**
 * Auto orients an image (based on the EXIF Orientation data) and stores it
 * in a temporary file.
 *
 * @param  {String}     inputPath               The path to the image to auto orient.
 * @param  {Object}     [opts]                  Extra options.
 * @param  {String}     [opts.outputPath]       If specified, the oriented image will be written to this location. If left undefined, a temporary path will be generated.
 * @param  {Boolean}    [opts.removeInput]      If set to `true`, the input image will be removed.
 * @param  {Function}   callback                Standard callback method.
 * @param  {Object}     callback.err            An error object (if any).
 * @param  {Object}     callback.file           A file object with some metadata of the oriented file.
 * @param  {Object}     callback.file.path      The path where the file has been written to.
 * @param  {Object}     callback.file.name      The name of the file.
 * @param  {Object}     callback.file.size      The size of the oriented image (in bytes).
 */
var autoOrient = module.exports.autoOrient = function(inputPath, opts, callback) {
    opts = opts || {};
    var outputPath = opts.outputPath || temp.path({'suffix': _getImageExtension(inputPath, '.jpg')});
    gm(inputPath)
    .noProfile()
    .autoOrient()
    .write(outputPath, function(err) {
        if (err) {
            fs.unlink(outputPath);
            log().error({'err': err}, 'Could not crop the image %s', inputPath);
            return callback({'code': 500, 'msg': 'Could not crop the image.'});
        }
        fs.stat(outputPath, function(err, stat) {
            if (err) {
                fs.unlink(outputPath);
                log().error({'err': err}, 'Could not get the file system information about %s', outputPath);
                return callback({'code': 500, 'msg': 'Could not retrieve the file information for the cropped file.'});
            }
            var file = {
                'path': outputPath,
                'size': stat.size,
                'name': Path.basename(outputPath)
            };

            if (opts.removeInput) {
                fs.unlink(inputPath, function(err) {
                    if (err) {
                        log().error({'err': err}, 'Could not unlink the input image.');
                        return callback({'code': 500, 'msg': 'Could not unlink the input image.'});
                    }
                    callback(null, file);
                });
            } else {
                callback(null, file);
            }
        });
    });
};

/**
 * Crops and resizes an image.
 *
 * @param  {String}     path                    The path on disk of the image to crop.
 * @param  {Number}     selectedArea.x          The x coordinate of the topleft corner to start cropping
 * @param  {Number}     selectedArea.y          The y coordinate of the topleft corner to start cropping
 * @param  {Number}     selectedArea.width      The width of the image that needs to be cropped out.
 * @param  {Number}     selectedArea.height     The height of the image that needs to be cropped out.
 * @param  {Object[]}   sizes                   An array of image sizes. An image will be generated for each size. Each object needs to specify the width and size for the resized image.
 * @param  {Function}   callback                Standard callback function.
 * @param  {Object}     callback.err            An error object (if any.)
 * @param  {Object}     callback.files          An object where each entry holds a resized file. The keys are of the form size.width + 'x' + size.height.
 */
var cropAndResize = module.exports.cropAndResize = function(path, selectedArea, sizes, callback) {
    var validator = new Validator();
    validator.check(path, {'code': 400, 'msg': 'A path to the image that you want to crop is missing'}).notNull();
    validator.check(null, {'code': 400, 'msg': 'The coordinates for the area you wish to crop must be specified'}).isObject(selectedArea);
    if (selectedArea) {
        validator.check(selectedArea.x, {'code': 400, 'msg': 'The x-coordinate needs to be a valid integer'}).isInt();
        validator.check(selectedArea.x, {'code': 400, 'msg': 'The x-coordinate needs to be a valid integer'}).min(0);
        validator.check(selectedArea.y, {'code': 400, 'msg': 'The y-coordinate needs to be a valid integer'}).isInt();
        validator.check(selectedArea.y, {'code': 400, 'msg': 'The y-coordinate needs to be a valid integer'}).min(0);
        validator.check(selectedArea.width, {'code': 400, 'msg': 'The width value must be an integer larger than 0'}).isInt();
        validator.check(selectedArea.width, {'code': 400, 'msg': 'The width value must be an integer larger than 0'}).min(1);
        validator.check(selectedArea.height, {'code': 400, 'msg': 'The height value must be an integer larger than 0'}).isInt();
        validator.check(selectedArea.height, {'code': 400, 'msg': 'The height value must be an integer larger than 0'}).min(1);
    }
    validator.check(sizes, {'code': 400, 'msg': 'The desired sizes array is missing'}).notNull();
    if (sizes) {
        validator.check(sizes.length, {'code': 400, 'msg': 'The desired sizes array is empty'}).min(1);
        for (var i = 0; i < sizes.length; i++) {
            validator.check(sizes[i].width, {'code': 400, 'msg': 'The width needs to be a valid integer larger than 0'}).isInt();
            validator.check(sizes[i].width, {'code': 400, 'msg': 'The width needs to be a valid integer larger than 0'}).min(0);
            validator.check(sizes[i].height, {'code': 400, 'msg': 'The width needs to be a valid integer larger than 0'}).isInt();
            validator.check(sizes[i].height, {'code': 400, 'msg': 'The height needs to be a valid integer larger than 0'}).min(0);
        }
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Crop the image.
    _cropImage(path, selectedArea, function(err, croppedFile) {
        if (err) {
            return callback(err);
        }
        var files = {};
        var resized = 0;
        var called = false;

        // Use a foreach so that the callback function of resizeImage has the size on the stack.
        sizes.forEach(function(size) {

            // Resize the image.
            _resizeImage(croppedFile.path, {'width': size.width, 'height': size.height}, function(err, file) {
                resized++;
                if (err && !called) {
                    called = true;
                    return callback(err);
                }

                var key = size.width + 'x' + size.height;
                files[key] = file;
                if (resized === sizes.length && !called) {
                    called = true;

                    // Remove the cropped one before we call the callback.
                    fs.unlink(croppedFile.path, function(err) {
                        if (err) {
                            called = true;
                            return callback({'code': 500, 'msg': err});
                        }
                        callback(null, files);
                    });
                }
            });
        });
    });
};

/**
 * Crops a part out of an image.
 *
 * @param  {String}      path                    The path on disk of the file that needs to be cropped.
 * @param  {Object}      selectedArea            The area that needs to be cropped out.
 * @param  {Number}      selectedArea.x          The x coordinate of the topleft corner to start cropping
 * @param  {Number}      selectedArea.y          The y coordinate of the topleft corner to start cropping
 * @param  {Number}      selectedArea.width      The width of the box that needs to be cropped out.
 * @param  {Number}      selectedArea.height     The height of the box that needs to be cropped out.
 * @param  {Function}    callback                Standard callback function.
 * @param  {Object}      callback.err            An error object (if any.)
 * @param  {Object}      callback.file           A file object with some metadata of the cropped file.
 * @param  {Object}      callback.file.path      The path where the file has been written to.
 * @param  {Object}      callback.file.name      The name of the file
 * @param  {Object}      callback.file.size      The size of the cropped image (in bytes).
 */
var cropImage = module.exports.cropImage = function(path, selectedArea, callback) {
    var validator = new Validator();
    validator.check(path, {'code': 400, 'msg': 'A path to the image that you want to crop is missing'}).notNull();
    validator.check(null, {'code': 400, 'msg': 'The coordinates for the area you wish to crop must be specified'}).isObject(selectedArea);
    if (selectedArea) {
        validator.check(selectedArea.x, {'code': 400, 'msg': 'The x-coordinate needs to be a valid integer'}).isInt();
        validator.check(selectedArea.x, {'code': 400, 'msg': 'The x-coordinate needs to be a valid integer'}).min(0);
        validator.check(selectedArea.y, {'code': 400, 'msg': 'The y-coordinate needs to be a valid integer'}).isInt();
        validator.check(selectedArea.y, {'code': 400, 'msg': 'The y-coordinate needs to be a valid integer'}).min(0);
        validator.check(selectedArea.width, {'code': 400, 'msg': 'The width value must be an integer larger than 0'}).isInt();
        validator.check(selectedArea.width, {'code': 400, 'msg': 'The width value must be an integer larger than 0'}).min(1);
        validator.check(selectedArea.height, {'code': 400, 'msg': 'The height value must be an integer larger than 0'}).isInt();
        validator.check(selectedArea.height, {'code': 400, 'msg': 'The height value must be an integer larger than 0'}).min(1);
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    _cropImage(path, selectedArea, callback);
};

/**
 * Internal method that performs the actual cropping.
 * This does no validation of the parameters.
 *
 * @param  {String}      path                    The path on disk of the file that needs to be cropped.
 * @param  {Object}      selectedArea            The area that needs to be cropped out.
 * @param  {Number}      selectedArea.x          The x coordinate of the topleft corner to start cropping
 * @param  {Number}      selectedArea.y          The y coordinate of the topleft corner to start cropping
 * @param  {Number}      selectedArea.width      The width of the box that needs to be cropped out.
 * @param  {Number}      selectedArea.height     The height of the box that needs to be cropped out.
 * @param  {Function}    callback                Standard callback function.
 * @param  {Object}      callback.err            An error object (if any.)
 * @param  {Object}      callback.file           A file object with some metadata of the cropped file.
 * @param  {Object}      callback.file.path      The path where the file has been written to.
 * @param  {Object}      callback.file.name      The name of the file
 * @param  {Object}      callback.file.size      The size of the cropped image (in bytes).
 * @api private
 */
var _cropImage = function(path, selectedArea, callback) {
    // Make sure that the pic is big enough.
    gm(path).size(function (err, size) {
        if (err) {
            log().error({'err': err}, 'Could not get the image size for the large image.');
            return callback({'code': 500, 'msg': 'Could not get the image size for the large image.'});
        }

        // Ensure we do not try and crop outside of the image size boundaries.
        if (selectedArea.x > size.width ||
            selectedArea.y > size.height ||
            selectedArea.width > (size.width - selectedArea.x) ||
            selectedArea.height > (size.height - selectedArea.y)) {
            return callback({'code': 400, 'msg': 'You cannot crop outside of the image.'});
        }

        // Crop it and write it to a temporary file.
        var tempPath = temp.path({'suffix': _getImageExtension(path, '.jpg')});
        gm(path)
        .crop(selectedArea.width, selectedArea.height, selectedArea.x, selectedArea.y)
        .noProfile()
        .write(tempPath, function(err) {
            if (err) {
                fs.unlink(tempPath);
                log().error({'err': err}, 'Could not crop the image %s', path);
                return callback({'code': 500, 'msg': 'Could not crop the image.'});
            }
            fs.stat(tempPath, function(err, stat) {
                if (err) {
                    fs.unlink(tempPath);
                    log().error({'err': err}, 'Could not get the file system information about %s', tempPath);
                    return callback({'code': 500, 'msg': 'Could not retrieve the file information for the cropped file.'});
                }
                var file = {
                    'path': tempPath,
                    'size': stat.size,
                    'name': Path.basename(tempPath)
                };
                callback(null, file);
            });
        });
    });
};

/**
 * Resizes an image to the specified size.
 *
 * @param  {String}      path                    The path on disk of the file that needs to be resized.
 * @param  {Object}      size                    The new size of the image.
 * @param  {Number}      size.width              The width that the image should be resized to.
 * @param  {Number}      size.height             The height that the image should be resized to.
 * @param  {Function}    callback                Standard callback method.
 * @param  {Object}      callback.err            An error object (if any.)
 * @param  {Object}      callback.file           A file object with some metadata of the resized file.
 * @param  {Object}      callback.file.path      The path where the file has been written to.
 * @param  {Object}      callback.file.name      The name of the file
 * @param  {Object}      callback.file.size      The size of the resized image (in bytes).
 */
var resizeImage = module.exports.resizeImage = function(path, size, callback) {
    var validator = new Validator();
    validator.check(path, {'code': 400, 'msg': 'A path to the image that you want to resize is missing'}).notNull();
    validator.check(null, {'code': 400, 'msg': 'The size must be specified'}).isObject(size);
    if (size) {
        validator.check(size.width, {'code': 400, 'msg': 'The width needs to be a valid integer larger than 0'}).isInt();
        validator.check(size.width, {'code': 400, 'msg': 'The width needs to be a valid integer larger than 0'}).min(0);
        validator.check(size.height, {'code': 400, 'msg': 'The height needs to be a valid integer larger than 0'}).isInt();
        validator.check(size.height, {'code': 400, 'msg': 'The height needs to be a valid integer larger than 0'}).min(0);
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    _resizeImage(path, size, callback);
};

/**
 * Internal method that resizes an image to the specified size.
 * This performs no validation.
 *
 * @param  {String}      path                    The path on disk of the file that needs to be resized.
 * @param  {Object}      size                    The new size of the image.
 * @param  {Number}      size.width              The width that the image should be resized to.
 * @param  {Number}      size.height             The height that the image should be resized to.
 * @param  {Function}    callback                Standard callback method.
 * @param  {Object}      callback.err            An error object (if any.)
 * @param  {Object}      callback.file           A file object with some metadata of the resized file.
 * @param  {Object}      callback.file.path      The path where the file has been written to.
 * @param  {Object}      callback.file.name      The name of the file
 * @param  {Object}      callback.file.size      The size of the resized image (in bytes).
 * @api private
 */
var _resizeImage = function(path, size, callback) {
    var suffix = size.width + 'x' + size.height + _getImageExtension(path, '.jpg');
    var tempPath = temp.path({'suffix': suffix});

    gm(path)
        .resize(size.width, size.height)
        .write(tempPath, function(err) {
            if (err) {
                fs.unlink(tempPath);
                log().error({'err': err}, 'Could not resize the image %s', path);
                return callback({'code': 500, 'msg': 'Could not resize the image'});
            }
            fs.stat(tempPath, function(err, stat) {
                if (err) {
                    fs.unlink(tempPath);
                    log().error({'err': err}, 'Could not get the file system information for %s', tempPath);
                    return callback({'code': 500, 'msg': 'Could not get the file information for the resized file..'});
                }
                var file = {
                    'path': tempPath,
                    'size': stat.size,
                    'name': Path.basename(tempPath)
                };
                callback(null, file);
            });
        });
};

/**
 * Scale an image down a to a smaller image.
 * Note that this will only result in good quality images if the width of the imput
 * image is larger than the width you're resizing to.
 *
 * @param  {String}     input                   The image to scale down.
 * @param  {String}     width                   The width in pixels of the desired size.
 * @param  {Function}   callback                Standard callback method.
 * @param  {Object}     callback.err            Standard error object (if any.)
 * @param  {Object}     callback.file           A file object with some metadata of the resized file.
 * @param  {Object}     callback.file.path      The path where the file has been written to.
 * @param  {Object}     callback.file.name      The name of the file
 * @param  {Object}     callback.file.size      The size of the resized image (in bytes).
 */
var downScale = module.exports.downScale = function(path, width, callback) {
    var validator = new Validator();
    validator.check(path, {'code': 400, 'msg': 'A path to the image that you want to downscale is missing'}).notNull();
    validator.check(width, {'code': 400, 'msg': 'The width must be specified'}).isInt();
    validator.check(width, {'code': 400, 'msg': 'The width must be specified'}).min(0);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    _downScale(path, width, callback);
};

/**
 * Scale an image down a to a smaller image.
 *
 * @param  {String}     input                   The image to scale down.
 * @param  {String}     width                   The width in pixels of the desired size.
 * @param  {Function}   callback                Standard callback method.
 * @param  {Object}     callback.err            Standard error object (if any.)
 * @param  {Object}     callback.file           A file object with some metadata of the resized file.
 * @param  {Object}     callback.file.path      The path where the file has been written to.
 * @param  {Object}     callback.file.name      The name of the file
 * @param  {Object}     callback.file.size      The size of the resized image (in bytes).
 * @api private
 */
var _downScale = function(path, width, callback) {
    var tempPath = temp.path({'suffix': '_' + width});

    gm(path)
        .density(150, 150)
        .resize(width, ' ') // Pass in a space for width so the argument to gm is '-resize 300x' (note the trailing x)
        .unsharp(0, 0.5, 0.75)
        .write(tempPath, function(err) {
            if (err) {
                fs.unlink(tempPath);
                log().error({'err': err}, 'Could not downscale the image %s', path);
                return callback({'code': 500, 'msg': 'Could not downscale the image'});
            }
            fs.stat(tempPath, function(err, stat) {
                if (err) {
                    fs.unlink(tempPath);
                    log().error({'err': err}, 'Could not get the file system information for %s', tempPath);
                    return callback({'code': 500, 'msg': 'Could not get the file information for the resized file..'});
                }
                var file = {
                    'path': tempPath,
                    'size': stat.size,
                    'name': Path.basename(tempPath)
                };
                callback(null, file);
            });
        });
};

/**
 * Get an image extension given a source filename.
 * If the source extension is not a valid extension, the fallback will be used.
 *
 * @param  {String} source   The input file on which to base the extension. ex: notAnImage.zip
 * @param  {String} fallback The fallback extension. ex: .jpg
 * @return {String}          A proper image extension. ex: '.jpg'
 * @api private
 */
var _getImageExtension = function(source, fallback) {
    var ext = Path.extname(source);
    if (!_.contains(VALID_EXTENSIONS, ext)) {
        ext = fallback;
    }
    return ext;
};
