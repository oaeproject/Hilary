/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var util = require('util');

var Cassandra = require('oae-util/lib/cassandra');
var log = require('oae-logger').logger('oae-messagebox-api');
var OaeUtil = require('oae-util/lib/util');

var MessageBoxModel = require('./model');
var MessageBoxConstants = require('./constants').MessageBoxConstants;

// A contribution will be considered "recent" for 30 days after it occurs
var DURATION_RECENT_CONTRIBUTIONS_SECONDS = 30 * 24 * 60 * 60;

/**
 * Create a new message in a message box. The message can be either its own "top-level" message, or a reply to
 * another message in this message box. To specify a message is a reply of another, you must supply the
 * `opts.replyToThreadKey` parameter to indicate the threadKey of the parent message which establishes its
 * hierarchy and ordering in the message box. The threadKey of a message can be found on the parent message
 * itself when using `getMessage`.
 *
 * @param  {String}     messageBoxId            The id of the message box that holds the message
 * @param  {String}     createdBy               The id of the user who sent the message
 * @param  {String}     body                    The body of the message
 * @param  {Object}     [opts]                  Additional optional message attributes
 * @param  {Number}     [opts.created]          The timestamp (millis since the epoch) that the message was created
 * @param  {String}     [opts.replyToCreated]   The timestamp (millis since the epoch) that the message to which this is a reply (if applicable) was created
 * @param  {Function}   [callback]              Invoked when the process completes
 * @param  {Object}     [callback.err]          An error that occurred, if any
 * @param  {Message}    [callback.message]      The message model object that was persisted
 */
var createMessage = module.exports.createMessage = function(messageBoxId, createdBy, body, opts, callback) {
    opts = opts || {};

    var replyToMessageId = (opts.replyToCreated) ? _createMessageId(messageBoxId, opts.replyToCreated) : null;

    // Fetch the threadKey of the parent so we can nest under it
    _getMessageThreadKey(replyToMessageId, function(err, replyToThreadKey) {
        if (err) {
            return callback(err);
        }

        var created = opts.created || Date.now();

        // Data that will be output in diagnostic error messages
        var diagnosticData = {
            'messageBoxId': messageBoxId,
            'createdBy': createdBy,
            'createdParam': opts.created,
            'createdActual': created,
            'replyToMessageId': replyToMessageId
        };

        if (replyToMessageId && !replyToThreadKey) {
            // We specified a message that doesn't actually exist in our message box, don't let that happen
            log().error(diagnosticData, 'Reply-to message does not exist');
            return callback({'code': 400, 'msg': 'Reply-to message does not exist'});
        }

        // Derive this message's thread key by appending it to the parent, if applicable. Otherwise, it is a top-level key
        var threadKey = (replyToThreadKey) ? _appendToThreadKey(replyToThreadKey, created) : created + '|';

        // A low-level storage hash that represents this item stored in Cassandra or Redis
        var messageId = _createMessageId(messageBoxId, created);
        var messageStorageHash = {
            'createdBy': createdBy,
            'body': body,
            'threadKey': threadKey
        };

        // Create the query that creates the message object
        var createMessageQuery = Cassandra.constructUpsertCQL('Messages', 'id', messageId, messageStorageHash, 'QUORUM');
        if (!createMessageQuery) {
            log().error(diagnosticData, 'Failed to create a new message query.');
            return callback({'code': 500, 'msg': 'Failed to create a new message'});
        }

        // Create the query that indexes the message object with the messagebox
        var indexMessageQuery = {
            'query': 'UPDATE MessageBoxMessages SET ? = ? WHERE messageBoxId = ?',
            'parameters': [threadKey, '1', messageBoxId]
        };

        // Create the query that updates the "recent contributors" to a message box
        // Discriminate the user id by the timestamp, so we can actually order these results by the **most** recent of those that are still considered recent
        var recentContributionColumnName = util.format('%s#%s', created, createdBy);
        var recentContributionsQuery = {
            'query': 'UPDATE MessageBoxRecentContributions USING TTL ' + DURATION_RECENT_CONTRIBUTIONS_SECONDS + ' SET ? = \'1\' WHERE messageBoxId = ?',
            'parameters': [recentContributionColumnName, messageBoxId]
        };

        // First insert the new message object, if this fails we do not want to update the messagebox index
        Cassandra.runQuery(createMessageQuery.query, createMessageQuery.parameters, function(err) {
            if (err) {
                return callback(err);
            }

            // Update the messagebox index, so this message will turn up in queries for all messages in the messagebox
            Cassandra.runQuery(indexMessageQuery.query, indexMessageQuery.parameters, function(err) {
                if (err) {
                    return callback(err);
                }

                // Asynchronously update the recent contributions
                Cassandra.runQuery(recentContributionsQuery.query, recentContributionsQuery.parameters);

                // Return the expanded Message object to the caller
                return callback(null, _storageHashToMessage(messageId, messageStorageHash));
            });
        });
    });
};

/**
 * Update the content body of a message.
 *
 * @param  {String}         messageBoxId    The id message whose body we will update
 * @param  {String|Number}  created         The created timestamp (in millis since epoch) that we wish to update
 * @param  {String}         newBody         The new message content to push to the body
 * @param  {Function}       callback        Invoked when the process completes
 * @param  {Object}         callback.err    An error that occurred, if any
 */
var updateMessageBody = module.exports.updateMessageBody = function(messageBoxId, created, newBody, callback) {
    Cassandra.runQuery('UPDATE Messages USING CONSISTENCY QUORUM SET body = ? WHERE id = ?', [newBody, messageId], callback);
};

/**
 * Get a list of messages from a message box.
 *
 * @param  {String}     messageBoxId        The id of the message box from which to fetch messages
 * @param  {String}     start               The threadKey (exclusive) of the message from which to start fetching. If not specified, will start from the most recent message
 * @param  {Number}     limit               The maximum number of messages to fetch, starting from the start point
 * @param  {Object}     [opts]              Optional parameters for the method
 * @param  {Boolean}    [opts.scrubDeleted] Whether or not the deleted messages from this messagebox should be scrubbed
 */
var getMessagesFromMessageBox = module.exports.getMessagesFromMessageBox = function(messageBoxId, start, limit, opts, callback) {
    // FIXME: This needs to be updated to provide an upper-bound limit. If it doesn't get done, it is a logical merge conflict
    // with https://github.com/sakaiproject/Hilary/pull/426
    limit = OaeUtil.getNumberParam(limit, 10);

    opts = opts || {};
    opts.scrubDeleted = (opts.scrubDeleted === false) ? false : true;

    _getThreadKeysFromMessageBox(messageBoxId, start, limit, function(err, threadKeys) {
        if (err) {
            return callback(err);
        }

        // Will maintain the output order of the messages according to their threadkey
        var createdTimestamps = [];

        // Will keep a mapping of timestamp->threadKey so we can later log the associated threadkey if there is an issue
        // finding the associated message
        var threadKeysByCreatedTimestamps = {};
        _.each(threadKeys, function(threadKey) {
            var createdTimestamp = _getCreatedFromThreadKey(threadKey);
            createdTimestamps.push(createdTimestamp);
            threadKeysByCreatedTimestamps[createdTimestamp] = threadKey;
        });

        getMessages(messageBoxId, createdTimestamps, {'scrubDeleted': opts.scrubDeleted}, function(err, messagesByTimestamp) {
            if (err) {
                return callback(err);
            }

            // Aggregate the fetched messages in the same order we received the thread keys
            var messages = [];
            _.each(createdTimestamps, function(createdTimestamp) {
                var message = messagesByTimestamp[createdTimestamp];
                if (message) {
                    messages.push(message);
                } else {
                    // An index entry existed that did not refer to a message that actually exists. Log this case, because
                    // we will probably want to diagnose this and do some data maintenance
                    log().warn({
                        'messageBoxId': messageBoxId,
                        'threadKey': threadKeysByCreatedTimestamps[createdTimestamp]
                    }, 'Found a message indexed in the MessageBoxMessages index that does not refer to an existing message. Ignoring the message.');
                }
            });

            return callback(null, messages);
        });
    });
};

/**
 * This is very similar to @see MessageBoxAPI#getMessagesById. The differences are:
 *
 *  * You can fetch by the `messageBoxId` and a list of `createdTimestamps` for convenience; and
 *  * The resulting object is keyed by `createdTimestamp` instead of by `messageId`
 *
 * The scrubbing logic is the same for deleted messages
 *
 * @param  {String}             messageBoxId        The id of the message box that contains the messages
 * @param  {String[]|Number[]}  createdTimestamps   The timestamps (millis since the epoch) that identify the messages to fetch within the message box
 * @param  {Object}             [opts]              @see MessageBoxAPI#getMessagesById
 * @param  {Function}           callback            @see MessageBoxAPI#getMessagesById
 * @param  {Object}             callback.err        @see MessageBoxAPI#getMessagesById
 * @param  {Object}             callback.messages   An object, keyed by timestamp, whose value is the Message object identified in the messagebox at that timestamp
 */
var getMessages = module.exports.getMessages = function(messageBoxId, createdTimestamps, opts, callback) {
    opts = opts || {};
    opts.scrubDeleted = (opts.scrubDeleted === false) ? false : true;

    // Convert messagebox + createdTimestamps into the compound key containing the two
    var messageIds = _.map(createdTimestamps, function(created) {
        return _createMessageId(messageBoxId, created);
    });

    // Delegate to getMessagesById to fetch by the actual message ids
    getMessagesById(messageIds, {'scrubDeleted': opts.scrubDeleted}, function(err, messages) {
        if (err) {
            return callback(err);
        }

        // Re-key the returned messages so they are by created timestamp instead of messageId. This is acceptable
        // since the timestamp is considered unique for messages within a specific messagebox.
        var messagesByTimestamp = {};
        _.each(messages, function(message, messageId) {
            var createdTimestamp = _getCreatedFromMessageId(messageId);
            messagesByTimestamp[createdTimestamp] = message;
        });

        return callback(null, messagesByTimestamp);
    });
};

/**
 * Get a set of messages from storage, based on its message box and the created timestamp. If the message has been deleted
 * and you have specified to scrub deleted messages (default), then only the following data of a message is returned:
 *
 *  * `id`
 *  * `messageBoxId`
 *  * `created`
 *  * `threadKey`
 *  * `deleted`
 *  * `level`
 *
 * @param  {Object}             [opts]              Optional parameters for the method
 * @param  {Boolean}            [opts.scrubDeleted] Whether or not to scrub the details of the deleted messages. If `false`, the full content of deleted messages will be returned. Otherwise, the message will be scrubbed as described in the summary.
 * @param  {Function}           callback            Invoked when the process completes
 * @param  {Object}             callback.err        An error that occurred, if any
 * @param  {Object}             callback.messages   A hash mapping messageId -> Message for each requested message
 */
var getMessagesById = module.exports.getMessagesById = function(messageIds, opts, callback) {
    opts = opts || {};
    opts.scrubDeleted = (opts.scrubDeleted === false) ? false : true;

    if (messageIds.length === 0) {
        return callback(null, {});
    }

    Cassandra.runQuery('SELECT * FROM Messages USING CONSISTENCY QUORUM WHERE id IN (?)', [messageIds], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var messages = {};
        rows.forEach(function(row) {
            var message = _storageHashToMessage(row.key, Cassandra.rowToHash(row));

            // The message will be null here if it didn't actually exist, or had recently been deleted
            if (message) {
                // Scrub the message if we have specified to do so
                if (opts.scrubDeleted && message.deleted) {
                    message = _scrubMessage(message);
                }

                messages[message.id] = message;
            }
        });

        return callback(null, messages);
    });
};

/**
 * Delete a message from storage.
 *
 * ## Delete Type
 *
 *  It is possible to specify the type of delete to perform. These are:
 *
 *      * `hard`: Delete the record from the database. It will no longer appear in the message box index
 *      * `soft`: Simply mark that the message is deleted. When a soft delete occurs, the message still appears in the message box index, and counts as a message when paging
 *      * `leaf`: Performs a `hard` delete, **only** if this message doesn't have any children. Otherwise, performs a soft delete. The actual delete that took place will be evident with the `callback.deleteType` parameter
 *
 * @param  {String}         messageBoxId        The id of the message box that holds the message to delete
 * @param  {String|Number}  createdTimestamp    The timestamp (millis since the epoch) of the message to delete
 * @param  {Object}         [opts]              Optional arguments for the method
 * @param  {String}         [opts.deleteType]   The type of delete to perform, as enumerated in the method summary. Default: "soft"
 * @param  {Function}       callback            Invoked when the process completes
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {String}         callback.deleteType A value indicating what type of delete finally took place. If it was a hard delete, it will be `MessageBoxConstants.deleteTypes.HARD`, if soft-deleted it will be `MessageBoxConstants.deleteTypes.SOFT`
 * @param  {String}         [callback.message]  If a soft-delete took place, this parameter will be the new representation of the deleted message object
 */
var deleteMessage = module.exports.deleteMessage = function(messageBoxId, createdTimestamp, opts, callback) {
    opts = opts || {};

    getMessages(messageBoxId, [createdTimestamp], {'scrubDeleted': false}, function(err, message) {
        if (err) {
            return callback(err);
        }

        message = message[createdTimestamp];

        if (message) {
            if (opts.deleteType === MessageBoxConstants.deleteTypes.HARD) {
                return _hardDelete(message, callback);
            } else if (opts.deleteType === MessageBoxConstants.deleteTypes.LEAF) {
                return _leafDelete(message, callback);
            } else {
                return _softDelete(message, callback);
            }
        } else {
            return callback({'code': 404, 'msg': 'The specified message did not exist'});
        }
    });
};

/**
 * Get the recent contributions to a message box. The result of this method is an array of objects describing contributions that occurred
 * within a specified period of time. The objects are sorted in order of most recent to least recent. The contributions expire from this
 * listing after 30 days.
 *
 * @param  {String}     messageBoxId                    The id of the message from which to fetch the recent contributions
 * @param  {Object}     start                           An OBJECT with properties "userId" (specifying the id of the user at which to start) and "created" (specifying the timestamp in millis since epoch of the user's contribution)
 * @param  {Number}     [limit]                         The maximum number of user ids to fetch. Default: 100
 * @param  {Function}   callback                        Invoked when the process completes
 * @param  {Object}     callback.err                    An error that occurred, if any
 * @param  {Object[]}   callback.recentContributions    An array of objects specifying the recent contributions, ordered from most recent to least recent. See method summary for the spec of the object.
 */
var getRecentContributions = module.exports.getRecentContributions = function(messageBoxId, start, limit, callback) {
    // FIXME: This needs to be updated to provide an upper-bound limit. If it doesn't get done, it is a logical merge conflict
    // with https://github.com/sakaiproject/Hilary/pull/426 . For this use-case, we want the limit to be quite large since it
    // will fuel things like activity routing. Maybe 100, or more?
    limit = OaeUtil.getNumberParam(limit, 100);
    start = (start) ? util.format('%s:%s', start.userId, start.created) : null;

    var opts = {
        'reversed': true,
        'consistency': 'ONE'
    };

    Cassandra.runPagedColumnQuery('MessageBoxRecentContributions', 'messageBoxId', messageBoxId, start, limit, opts, function(err, row) {
        if (err) {
            return callback(err);
        }

        var recentContributions = [];
        row.forEach(function(key) {
            // Convert 123456789#u:cam:simong into "123456789" and "u:cam:simong"
            var parts = key.split('#');
            var created = parts[0];
            var userId = parts.slice(1).join('#');
            recentContributions.push({'userId': userId, 'created': created});
        });

        return callback(null, recentContributions);
    });
};

/**
 * Given a message id, fetch just its threadKey from storage.
 *
 * @param  {String}     messageId               The id of the message whose threadKey to fetch
 * @param  {Function}   callback                Invoked when the process completes
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {String}     [callback.threadKey]    The threadKey of the message. If the message did not exist, will be undefined.
 * @api private
 */
var _getMessageThreadKey = function(messageId, callback) {
    // The message id is not specified, simply return with nothing.
    if (!messageId) {
        return callback();
    }

    Cassandra.runQuery('SELECT threadKey FROM Messages USING CONSISTENCY QUORUM WHERE id = ?', [messageId], function(err, row) {
        if (err) {
            return callback(err);
        } else if (row[0].count === 0) {
            // A message by that id may not have existed, simply return undefined
            return callback();
        }

        return callback(null, row[0].get('threadKey').value);
    });
};

/**
 * Perform a "leaf" delete. This delete method will perform a "hard" delete if the specified message has no replies (i.e., it
 * is a leaf node), or perform a "soft" delete if it has replies.
 *
 * @param  {Message}    message             The message to delete
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {String}     callback.deleteType The type of delete that eventually occurred. Either 'soft' or 'hard'
 * @param  {Message}    [callback.message]  If the delete was a "soft" delete, returns the scrubbed message model of the now-deleted message
 * @api private
 */
var _leafDelete = function(message, callback) {
    var threadKeyWithoutPipe = message.threadKey.split('|')[0];

    //Check to see if this message has a reply. If so, we will soft delete, if not we hard delete
    _getThreadKeysFromMessageBox(message.messageBoxId, message.threadKey, 1, function(err, threadKeys) {
        if (err) {
            return callback(err);
        }

        var hasReply = false;
        var replyKey = threadKeys[0];
        if (replyKey) {
            // If the next message's threadKey is a descendant of the message being deleted, it is a reply.
            hasReply = (replyKey.indexOf(threadKeyWithoutPipe) === 0);
        }

        // Perform the appropriate delete operation based on whether or not there is a reply
        if (hasReply) {
            return _softDelete(message, function(err, message) {
                if (err) {
                    return callback(err);
                }

                return callback(null, MessageBoxConstants.deleteTypes.SOFT, message);
            });
        } else {
            return _hardDelete(message, function(err) {
                if (err) {
                    return callback(err);
                }

                return callback(null, MessageBoxConstants.deleteTypes.HARD);
            });
        }
    });
};

/**
 * Perform a hard delete of a message in storage. This delete operation does the following:
 *
 *  * Soft delete the message in the Messages CF; and
 *  * Log an entry in the MessageBoxMessagesDeleted CF to indicate that this message was unlinked from the message box; and
 *  * Unlink the message from the messagebox, by removing it from the MessageBoxMessages index
 *
 * After this is performed, the message will no longer return when paging through messages of a message box, and so will appear
 * permanently deleted.
 *
 * @param  {Message}    message             The message to hard-delete
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @api private
 */
var _hardDelete = function(message, callback) {
    var messageBoxId = message.messageBoxId;
    var createdTimestamp = message.created;
    var threadKey = message.threadKey;

    // First move the created timestamp of the message in a CF that can help us find and recover the message for a messagebox
    Cassandra.runQuery('UPDATE MessageBoxMessagesDeleted USING CONSISTENCY QUORUM SET ? = \'1\' WHERE messageBoxId = ?', [createdTimestamp, messageBoxId], function(err) {
        if (err) {
            return callback(err);
        }

        // Delete the index entry from the messagebox. This fixes things like paging so this comment does not get returned in feeds anymore
        Cassandra.runQuery('DELETE ? FROM MessageBoxMessages USING CONSISTENCY QUORUM WHERE messageBoxId = ?', [threadKey, messageBoxId], function(err) {
            if (err) {
                return callback(err);
            }

            // Proceed to flag the message as deleted, but we still don't hard-delete its contents
            _softDelete(message, function(err) {
                if (err) {
                    return callback(err);
                }

                return callback();
            });
        });
    });
};

/**
 * Perform a soft delete of a message. The basically marks a `deleted` flag to the current time (millis since the epoch) so
 * so that the consumer may determine how to handle soft-deleted messages in the message box. The message will still appear
 * when listing messages in the message box.
 *
 * @param  {Message}    message             The message to hard-delete
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @api private
 */
var _softDelete = function(message, callback) {
    var messageId = _createMessageId(message.messageBoxId, message.created);
    var deletedTimestamp = Date.now();

    // Set the deleted flag to the current timestamp
    Cassandra.runQuery('UPDATE Messages USING CONSISTENCY QUORUM SET deleted = ? WHERE id = ?', [deletedTimestamp, messageId], function(err) {
        if (err) {
            return callback(err);
        }

        message.deleted = deletedTimestamp;
        message = _scrubMessage(message);

        return callback(null, message);
    });
};

/**
 * List the threadKeys from the messagebox index.
 *
 * @param  {String}         messageBoxId        The id of the message box whose message threadKeys to fetch
 * @param  {String}         start               The first threadKey from which to start fetching threadKeys (exclusive)
 * @param  {String|Number}  limit               The maximum number of threadKeys to fetch
 * @param  {Function}       callback            Invoked when the process completes
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {String[]}       callback.threadKeys The threadKeys requested
 * @api private
 */
var _getThreadKeysFromMessageBox = function(messageBoxId, start, limit, callback) {
    // Fetch `limit` number of message ids from the message box
    Cassandra.runPagedColumnQuery('MessageBoxMessages', 'messageBoxId', messageBoxId, start, limit, {'reversed': true}, function(err, row) {
        if (err) {
            return callback(err);
        }

        var threadKeys = [];
        row.forEach(function(threadKey) {
            threadKeys.push(threadKey);
        });

        return callback(null, threadKeys);
    });
};

/**
 * Convert a simple storage hash model to a Message object.
 *
 * @param  {String}     messageId       The id of the message being converted
 * @param  {Object}     hash            The simple key-value storage model of the message
 * @return {Message}                    The message model object the storage hash represents
 * @api private
 */
var _storageHashToMessage = function(messageId, hash) {
    var message = null;

    // Use threadKey as a slug column to ensure that this hash was an existing message
    if (hash.threadKey) {
        var messageBoxId = _getMessageBoxIdFromMessageId(messageId);
        var threadKey = hash.threadKey;
        var body = hash.body;
        var createdBy = hash.createdBy;
        var created = _getCreatedFromThreadKey(threadKey);
        var level = _getLevelFromThreadKey(threadKey);
        var replyTo = _getReplyToIdFromThreadKey(messageBoxId, threadKey);
        var deleted = hash.deleted;
        message = new MessageBoxModel.Message(messageId, messageBoxId, threadKey, body, createdBy, created, level, replyTo, deleted);
    }

    return message;
};

var _createMessageId = function(messageBoxId, created) {
    return util.format('%s#%s', messageBoxId, created);
};

var _getMessageBoxIdFromMessageId = function(messageId) {
    // The id of the messagebox is everything up to the last '#' of the message id
    return messageId.split('#').slice(0, -1).join('#');
};

var _appendToThreadKey = function(parentThreadKey, childCreated) {
    var parentThreadKeyWithoutPipe = parentThreadKey.split('|')[0];
    return util.format('%s#%s|', parentThreadKeyWithoutPipe, childCreated);
};

var _getCreatedFromMessageId = function(messageId) {
    return messageId.split('#').pop();
};

var _getCreatedFromThreadKey = function(threadKey) {
    // The created timestamp is the timestamp of the deepest message in the threadKey hierarchy
    var timestampWithPipe = threadKey.split('#').pop();
    return timestampWithPipe.split('|')[0];
};

var _getLevelFromThreadKey = function(threadKey) {
    // Extract the depth of this message from the threadKey hierarchy. Top-level messages are depth 0
    return threadKey.split('#').length - 1;
};

var _scrubMessage = function(message) {
    return _.pick(message, 'id', 'messageBoxId', 'threadKey', 'created', 'replyTo', 'deleted', 'level');
};

var _getMessageIdFromThreadKey = function(messageBoxId, threadKey) {
    var deepestMessagePart = threadKey.split('#').pop();
    var createdTimestamp = deepestMessagePart.split('|')[0];
    return _createMessageId(messageBoxId, createdTimestamp);
};

var _getReplyToIdFromThreadKey = function(messageBoxId, threadKey) {
    // Converts: "timestamp1#timestamp2#timestamp3|" -> [ "timestamp1", "timestamp2", "timestamp3" ]
    var hierarchy = threadKey.split('|')[0].split('#');
    if (hierarchy.length > 1) {
        // "timestamp3" is a reply to "timestamp2", so we pick out the second last one in the hierarchy
        var createdTimestamp = hierarchy[hierarchy.length - 2];
        return _createMessageId(messageBoxId, createdTimestamp);
    } else {
        // If we only had 1 element, then this is not a reply at all
        return null;
    }
};
