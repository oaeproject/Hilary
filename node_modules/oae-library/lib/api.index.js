/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var events = require('events');
var util = require('util');

var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var Cassandra = require('oae-util/lib/cassandra');
var Counter = require('oae-util/lib/counter');
var log = require('oae-logger').logger('library-index');
var OaeUtil = require('oae-util/lib/util');

var LibraryAuthz = require('./api.authz');
var LibraryRegistry = require('./internal/registry');

// We need a slug column name to denote a fresh library index at both the lower
// bound and upper bound to determine if an index is fresh or invalidated
var SLUG_LOW = '#';
var SLUG_HIGH = '|';

/*!
 * The visibility masks define the visibility groups that each visibility bucket contains. The
 * key is the name of the bucket, and the array of values are the visibilities of resources that
 * belong in that bucket.
 */
var visibilityMasks = {
    'private': [AuthzConstants.visibility.PUBLIC, AuthzConstants.visibility.LOGGEDIN, AuthzConstants.visibility.PRIVATE],
    'loggedin': [AuthzConstants.visibility.PUBLIC, AuthzConstants.visibility.LOGGEDIN],
    'public': [AuthzConstants.visibility.PUBLIC]
};

var updateCounter = new Counter();

/**
 * The `LibraryIndexer` index is built to manage "ranked" libraries of items that are grouped according to a
 * "visibility mask". It should be used in the following way:
 *
 *  *   Multiple different modules may have multiple different types of libraries. It is expected that
 *      `indexName` namespaces the library across the whole application, and also namespaces this particular
 *      type of library within the module (e.g., For oae-principals, you may have: "Group Members" library and
 *      "Group Memberships" library)
 *  *   For a library index, there is a group of ordered lists for each visibility. When `insert`ing a public resource
 *      for a user's content library, you would specify the pair {"<principalId>": "public"} as an item in the
 *      `keyVisibilities` hash. This item would then be available in the private, loggedin and public lists
 *      for the principal's library, as specified by the `visibilityMasks`
 *  *   The libraries order the resources (largest to smallest) by a `rank`. When inserting or updating a resource
 *      in the libraries, the index needs to know the `rank` of the item to insert, and if it is an update, it
 *      needs to know the previous rank to remove the old version
 *  *   There is potential for race-conditions in the index, most of which would result in duplicate items. Since
 *      these cases will result in items being closely ranked in the index, the index detects duplicates while
 *      paging and automatically repairs them. As a result, it is possible if you `list` 25 items from the index, you
 *      may receive 24 (or less). Therefore, pay close attention to the `nextToken` variable to determine if the
 *      index has more items, **don't** determine if the list is empty by checking if the number of items received is
 *      less than the requested number of items!
 *  *   Untimely losses of servers may result in inserts to work and deletes to fail when replacing items. This may
 *      result in duplicates that are not very close in rank, and therefore may never be automatically repaired. Either
 *      these items would have to be manually removed from the database, a sufficiently large `list` request to the
 *      library would trigger the indexer to auto-repair it, or the library can be deleted and it will be rebuilt
 *      on the next request for the library
 */
var LibraryIndex = module.exports;

/**
 * Register a library index with the library module. This provides custom pluggable functionality for different
 * library indexes.
 *
 * ## options.pageResources
 *
 * When rebuilding a library from scratch, it is necessary for the library index to request all the resources
 * that should exist in a library. This pageResources option is the functionality required by all library
 * indexes in order to have its items rebuilt.
 *
 * @param  {String}     name                                                        The name of the library index. Should be the same unique name used to reference the index in the insert, update and remove functions of the module
 * @param  {Object}     options                                                     The options specifying the library index behaviour
 * @param  {Function}   options.pageResources                                       A function that can iterate over all the expected resources that belong to a particular library index of this type
 * @param  {String}     options.pageResources.libraryId                             The id of the library that is being paged through
 * @param  {String}     options.pageResources.start                                 The starting point of the requested page of resources
 * @param  {String}     options.pageResources.limit                                 The maximum number of items to return
 * @param  {Function}   options.pageResources.callback                              Standard callback function that should be invoked when the page of resources has been fetched
 * @param  {Object}     options.pageResources.callback.err                          An error that occurred while fetching the page of resources, if any
 * @param  {Object[]}   options.pageResources.callback.resources                    The library resources that represent the requested page of items
 * @param  {String}     options.pageResources.callback.resources[i].id              The id of this library resource
 * @param  {String}     options.pageResources.callback.resources[i].rank            The rank for this library resource in the library index
 * @param  {Object}     options.pageResources.callback.resources[i].tenant.alias    The tenant to which the library resource belongs
 * @param  {String}     options.pageResources.callback.resources[i].visibility      The visibility of the library resource
 * @param  {String}     [options.pageResources.callback.nextToken]                  The value to use as the `start` parameter in the next invokation to get the next page of items. If unspecified, it indicates there are no more pages of resources
 */
var registerLibraryIndex = module.exports.registerLibraryIndex = function(name, options) {
    LibraryRegistry.registerLibraryIndex(name, options);
};

/**
 * Insert a resource into a library index. This is different than `update` in that it makes no attempt
 * to delete a previously-ranked item from the index.
 *
 * @param  {String}         indexName           The name of the index to insert into. Should be namespaced to the module using it.
 * @param  {Object}         libraryVisibilities An object whose key is a unique identifier for the library in the index (i.e., group of buckets), and the value is the visibility of the bucket in which to perform the insert
 * @param  {String}         resourceId          The id of the resource to insert
 * @param  {String}         [rank]              The **string-ordered** rank of the resource to insert. Since this is string ordered, a rank of 11 for example is LOWER than 2. If not specified, defaults to 0
 * @param  {Function}       callback            Invoked when the process completes
 * @param  {Object}         callback.err        An error that occurred, if any
 */
var insert = module.exports.insert = function(indexName, libraryVisibilities, resourceId, rank, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({
                'err': err,
                'indexName': indexName,
                'libraryVisibilities': libraryVisibilities,
                'resourceId': resourceId,
                'rank': rank
            }, 'Error inserting library update');
        }
    };

    updateCounter.incr();

    var indexEntries = _.map(libraryVisibilities, function(visibility, libraryId) {
        return {
            'libraryId': libraryId,
            'rank': rank,
            'resourceId': resourceId,
            'visibility': visibility
        };
    });

    _insert(indexName, indexEntries, function(err) {
        updateCounter.decr();
        return callback(err);
    });
};

/**
 * Update a resource in a library index. This will attempt to delete an old item according to an `oldRank`, and insert a
 * new item according to the `newRank`. Items will be aggressively deleted from all visibility buckets, so only the current
 * visibility is needed to determine the buckets of the insert.
 *
 * @param  {String}         indexName           The name of the index to insert into. Should be namespaced to the module using it.
 * @param  {Object}         libraryVisibilities An object whose key is a unique identifier for the library (i.e., group of buckets), and the value is the visibility of the bucket in which to perform the insert
 * @param  {String}         resourceId          The id of the resource to update
 * @param  {String|Number}  [newRank]           The rank of the resource to update. If not specified, defaults to 0
 * @param  {String|Number}  [oldRank]           The rank of the previous entry of the resource. If not specified, defaults to 0
 * @param  {Function}       callback            Invoked when the process completes
 * @param  {Object}         callback.err        An error that occurred, if any
 */
var update = module.exports.update = function(indexName, libraryVisibilities, resourceId, newRank, oldRank, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({
                'err': err,
                'indexName': indexName,
                'libraryVisibilities': libraryVisibilities,
                'resourceId': resourceId,
                'newRank': newRank,
                'oldRank': oldRank
            }, 'Error inserting library update');
        }
    };

    updateCounter.incr();

    // What we will insert into the index
    var oldValueKey = _createValueKey(resourceId, oldRank);
    var newValueKey = _createValueKey(resourceId, newRank);
    var value = '1';

    // If the old ranked key is the same as the new one, don't do any updates as the batch mutation
    // containing both deletes and updates will result as the entries being deleted
    if (oldValueKey === newValueKey) {
        log().warn({
            'indexName': indexName,
            'valueKey': oldValueKey
        }, 'Aborting library index update because old and new value keys are identical');
        return callback();
    }

    // Either we had an error or successfully set the latest last modified, so we will perform the
    // necessary index updates
    var queries = [];

    // First delete the old version of this resource for all buckets
    _.each(visibilityMasks, function(mask, bucketName) {
        _.each(libraryVisibilities, function(visibility, libraryId) {
            queries.push({
                'query': 'DELETE FROM "LibraryIndex" WHERE "bucketKey" = ? AND "rankedResourceId" = ?',
                'parameters': [_createBucketKey(indexName, libraryId, bucketName), oldValueKey]
            });
        });
    });

    // Insert the new version of this resource for the buckets associated to the specified visibility
    _.each(libraryVisibilities, function(visibility, libraryId) {
        _.each(visibilityMasks, function(mask, bucketName) {
            if (_.contains(mask, visibility)) {
                // If this bucket's mask accepts this visibility, we update it with the content item
                queries.push({
                    'query': 'UPDATE "LibraryIndex" SET "value" = ? WHERE "bucketKey" = ? AND "rankedResourceId" = ?',
                    'parameters': [value, _createBucketKey(indexName, libraryId, bucketName), newValueKey]
                });
            }
        });
    });

    Cassandra.runBatchQuery(queries, function(err) {
        updateCounter.decr();
        return callback(err);
    });
};

/**
 * Remove a resource from the library index.
 *
 * @param  {String}         indexName           The name of the index to insert into. Should be namespaced to the module using it.
 * @param  {String[]}       libraryIds          An array of ids that identify buckets groups from which to remove the resource
 * @param  {String}         resourceId          The id of the resource to delete
 * @param  {String|Number}  [rank]              The rank of the resource to delete. If not specified, defaults to 0
 * @param  {Function}       callback            Invoked when the process completes
 * @param  {Object}         callback.err        An error that occurred, if any
 */
var remove = module.exports.remove = function(indexName, libraryIds, resourceId, rank, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({
                'err': err,
                'indexName': indexName,
                'libraryIds': libraryIds,
                'resourceId': resourceId,
                'visibility': visibility,
                'newRank': newRank,
                'oldRank': oldRank
            }, 'Error removing resource from library');
        }
    };

    updateCounter.incr();

    // Delete this resource for all visibility buckets
    var valueKey = _createValueKey(resourceId, rank);
    var queries = [];
    _.each(visibilityMasks, function(mask, bucketName) {
        _.each(libraryIds, function(libraryId) {
            queries.push({
                'query': 'DELETE FROM "LibraryIndex" WHERE "bucketKey" = ? AND "rankedResourceId" = ?',
                'parameters': [_createBucketKey(indexName, libraryId, bucketName), valueKey]
            });
        });
    });

    Cassandra.runBatchQuery(queries, function(err) {
        updateCounter.decr();
        return callback(err);
    });
};

/**
 * Fires a handler when all in-progress index updates (inserts, updates and removals) have been
 * completed. This is useful in tests to synchronize with library index updates that are otherwise
 * asynchronous, so library indexes know when to check the impact of updates in the library
 *
 * @param  {Function}   callback    Invoked when all current library updates have completed
 */
var whenUpdatesComplete = module.exports.whenUpdatesComplete = function(callback) {
    updateCounter.whenZero(callback);
};

/**
 * Retrieve an ordered list of items from the index
 *
 * @param  {String}     indexName               The name of the index to list. Should be namespaced to the module using it
 * @param  {String}     libraryId               An id that identifies the bucket group that should be listed
 * @param  {String}     visibility              The visibility of the bucket that should be listed
 * @param  {Object}     [opts]                  Optional parameters
 * @param  {String}     [opts.start]            Determines the rank at which items are returned for paging purposed. If not provided, will start from the highest ranked item
 * @param  {Number}     [opts.limit]            Number of items to return. Default: 10
 * @param  {Function}   callback                Invoked when the process completes
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Object}     callback.resourceIds    The ids of the retrieved resources
 * @param  {Object}     callback.nextToken      The value to use for the `opts.start` parameter to get the next set of results
 */
var list = module.exports.list = function(indexName, libraryId, visibility, opts, callback) {
    opts = opts || {};
    opts.limit = OaeUtil.getNumberParam(opts.limit, 10, 1);
    opts.start = opts.start || '';

    // Query the library index, and lazily build it if it is not seeded, or if it has been purged for maintenance
    _query(indexName, libraryId, visibility, {'start': opts.start, 'limit': opts.limit, 'rebuildIfNecessary': true}, function(err, valueKeys, nextToken) {
        if (err) {
            return callback(err);
        }

        var numResults = 0;

        // For repair-on-read, we will keep track of duplicate resourceIds and delete duplicates after
        var valueKeysToDelete = [];

        // Because of the repair-on-read the nextToken might now be invalid so we need to recalculate it
        var newNextToken = null;

        var resourceIds = [];
        _.each(valueKeys, function(valueKey) {
            numResults++;
            _splitValueKey(valueKey, function(resourceId, timestamp) {
                if (!_.contains(resourceIds, resourceId)) {
                    resourceIds.push(resourceId);
                    newNextToken = valueKey;
                } else {
                    valueKeysToDelete.push(valueKey);
                }
            });
        });

        // If the runPagedColumnQuery method didn't return a next token, it means there are no more items to retrieve
        if (!nextToken) {
            newNextToken = null;
        }

        if (!_.isEmpty(valueKeysToDelete)) {
            // There were duplicates, delete them asynchronously
            var bucketKey = _createBucketKey(indexName, libraryId, visibility);
            var deleteQueries = _.map(valueKeysToDelete, function(valueKey) {
                return {
                    'query': 'DELETE FROM "LibraryIndex" WHERE "bucketKey" = ? AND "rankedResourceId" = ?',
                    'parameters': [bucketKey, valueKey]
                };
            });

            Cassandra.runBatchQuery(deleteQueries);
        }

        return callback(null, resourceIds, newNextToken);
    });
};

/**
 * Purge all the items out of a given library index. This will force the library index to be rebuilt the next time the library is queried
 *
 * @param  {String}     indexName       The name of the library index to purge
 * @param  {String}     libraryId       The id of the library of this type to purge
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var purge = module.exports.purge = function(indexName, libraryId, callback) {
    // Build the queries that will purge all the index buckets to start fresh
    var purgeIndexQueries = _.map(visibilityMasks, function(mask, visibility) {
        return {
            'query': 'DELETE FROM "LibraryIndex" WHERE "bucketKey" = ?',
            'parameters': [_createBucketKey(indexName, libraryId, visibility)]
        };
    });

    Cassandra.runBatchQuery(purgeIndexQueries, callback);
};

/**
 * Determine if the given library index is stale, in other words it has not been built since the last time it was purged
 *
 * @param  {String}     indexName           The name of the library index to check
 * @param  {String}     libraryId           The id of the library of this type to check
 * @param  {String}     visibility          The visibility of the library bucket to check
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.isStale    Whether or not the specified library index is currently stale
 */
var isStale = module.exports.isStale = function(indexName, libraryId, visibility, callback) {
    // Select both the high and low slug column from the library
    var cql = 'SELECT "value" FROM "LibraryIndex" WHERE "bucketKey" = ? AND "rankedResourceId" IN (?)';
    Cassandra.runQuery(cql, [_createBucketKey(indexName, libraryId, visibility), [SLUG_HIGH, SLUG_LOW]], function(err, rows) {
        if (err) {
            return callback(err);
        }

        // If we got exactly 2 rows, it means that both the high and low slug were there, so the
        // library index is recent
        return callback(null, (rows.length !== 2));
    });
};

/**
 * List items from a library index
 *
 * @param  {String}     indexName                   The name of the index whose items to fetch
 * @param  {String}     libraryId                   The id of the library whose items to fetch for this index type
 * @param  {String}     visibility                  The visibility of the library to fetch
 * @param  {Object}     opts                        Additional parameters for the query
 * @param  {String}     opts.start                  The starting point from which to start fetching library items. To start from the highest-ranked item, this should be the empty string
 * @param  {Number}     opts.limit                  The maximum number of library items to return
 * @param  {Boolean}    [opts.rebuildIfNecessary]   Whether or not to rebuild the library index if it is detected that it is not "fresh" (i.e., it has not been rebuilt since the last purge). Default: `false`
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error that occurred if any
 * @param  {String[]}   callback.keys               The library value keys that were found in this query
 * @param  {String}     callback.nextToken          The value that can be used as the `opts.start` parameter for the next query to get the next page of items
 * @api private
 */
var _query = function(indexName, libraryId, visibility, opts, callback) {
    // Select one additional entry to account for the slug that we will select if we have not specified a start parameter
    var internalLimit = opts.limit;
    if (!opts.start) {
        internalLimit++;
    }

    log().trace({
        'indexName': indexName,
        'libraryId': libraryId,
        'visibility': visibility,
        'opts': opts
    }, 'Querying library index');

    // Query the items from cassandra
    var bucketKey = _createBucketKey(indexName, libraryId, visibility);
    Cassandra.runPagedQuery('LibraryIndex', 'bucketKey', bucketKey, 'rankedResourceId', opts.start, internalLimit, {'reversed': true}, function(err, rows, nextToken) {
        if (err) {
            return callback(err);
        } else if (_isStaleLibraryIndex(opts.start, internalLimit, rows)) {
            if (opts.rebuildIfNecessary) {
                // If we've specified to rebuild a stale index, rebuild it and try to query again
                return _rebuildAndQuery(indexName, libraryId, visibility, opts, callback);
            } else {
                // If we have not specified to rebuild and this index is stale, then warn that something funny is going on
                log().warn({
                    'indexName': indexName,
                    'libraryId': libraryId,
                    'visibility': visibility,
                    'opts': opts,
                    'entries': rows
                }, 'Attempted to query a stale library without trying to rebuild the index');
            }
        }

        var result = _adjustColumnsForSlugs(opts.start, opts.limit, rows, nextToken);
        return callback(null, result.keys, result.nextToken);
    });
};

/**
 * Purge, build, and query the specified library
 *
 * @param  {String}     indexName               The name of the index whose items to fetch
 * @param  {String}     libraryId               The id of the library whose items to fetch for this index type
 * @param  {String}     visibility              The visibility of the library to fetch
 * @param  {Object}     opts                    Additional parameters for the query
 * @param  {String}     opts.start              The starting point from which to start fetching library items. To start from the highest-ranked item, this should be the empty string
 * @param  {Number}     opts.limit              The maximum number of library items to return
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred if any
 * @param  {String[]}   callback.keys           The library value keys that were found in this query
 * @param  {String}     callback.nextToken      The value that can be used as the `opts.start` parameter for the next query to get the next page of items
 * @api private
 */
var _rebuildAndQuery = function(indexName, libraryId, visibility, opts, callback) {
    // Completely delete and rebuild the library index
    _rebuild(indexName, libraryId, function(err) {
        if (err) {
            return callback(err);
        }

        // We've just rebuilt. Query, but *do not* rebuild again if it still looks like we aren't
        // rebuilt -- this would probably be a bug. We don't want any potential bugs to result in an
        // infinite loop of rebuilding and querying. Ouch!
        _query(indexName, libraryId, visibility, {'start': opts.start, 'limit': opts.limit}, callback);
    });
};

/**
 * Purge and build the specified library
 *
 * @param  {String}     indexName       The name of the index whose items to rebuild
 * @param  {String}     libraryId       The id of the library whose items to rebuild
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred if any
 * @api private
 */
var _rebuild = function(indexName, libraryId, callback) {
    purge(indexName, libraryId, function(err) {
        if (err) {
            return callback(err);
        }

        // Build the queries to seed all of the visibility buckets with the low and high slugs
        var seedLibraryQueries = [];
        _.each(visibilityMasks, function(mask, visibility) {
            var bucketKey = _createBucketKey(indexName, libraryId, visibility);
            seedLibraryQueries.push(
                {
                    'query': 'INSERT INTO "LibraryIndex" ("bucketKey", "rankedResourceId", "value") VALUES (?, ?, ?)',
                    'parameters': [bucketKey, SLUG_HIGH, '1']
                },
                {
                    'query': 'INSERT INTO "LibraryIndex" ("bucketKey", "rankedResourceId", "value") VALUES (?, ?, ?)',
                    'parameters': [bucketKey, SLUG_LOW, '1']
                }
            );
        });

        // Add the slugs into the library index so we don't thrash it with rebuilds. The index will temporarily be empty
        // or incomplete while the rebuild process takes place
        Cassandra.runBatchQuery(seedLibraryQueries, function(err) {
            if (err) {
                return callback(err);
            }

            // Build the index after it has been destroyed and seeded
            return _build(indexName, libraryId, callback);
        });
    });
};

/**
 * Build the specified library using the pageResources method of the registered index
 *
 * @param  {String}     indexName       The name of the index whose items to build
 * @param  {String}     libraryId       The id of the library whose items to build
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred if any
 * @api private
 */
var _build = function(indexName, libraryId, callback, _nextToken) {
    if (_nextToken === null) {
        return callback();
    }

    var registeredIndex = LibraryRegistry.getRegisteredLibraryIndex(indexName);
    if (!registeredIndex) {
        return callback();
    }

    registeredIndex.pageResources(libraryId, _nextToken, 100, function(err, resources, nextToken) {
        if (err) {
            return callback(err);
        }

        nextToken = nextToken || null;

        // Resolve the index entries from the list of resources provided
        var indexEntries = _.map(resources, function(resource) {
            var keyVisibility = LibraryAuthz.resolveEffectiveLibraryVisibilities([libraryId], resource);
            return {
                'libraryId': libraryId,
                'rank': resource.rank || 0,
                'resourceId': resource.id,
                'visibility': keyVisibility[libraryId]
            };
        });

        // Insert all the index entries
        _insert(indexName, indexEntries, function(err) {
            if (err) {
                log().warn({
                    'err': err,
                    'indexName': indexName,
                    'libraryId': libraryId
                }, 'Error trying to index a batch of resources');
            }

            // Recursively repeat with the nextToken to get the next batch
            return _build(indexName, libraryId, callback, nextToken);
        });
    });
};

/**
 * Insert a list of index entries into a library index
 *
 * @param  {String}     indexName                   The name of the index into which to insert the entries
 * @param  {Object[]}   indexEntries                The entries to insert into the index
 * @param  {String}     indexEntries[i].libraryId   The id the library in which to insert this item
 * @param  {String}     indexEntries[i].resourceId  The id of the resource to insert into the library with the specified id
 * @param  {String}     indexEntries[i].rank        The rank of the resource in the specified library
 * @param  {String}     indexEntries[i].visibility  The visibility bucket in which to insert the item into the library (i.e., **not** the resource visibility, the **target bucket**, which is not always the same)
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error that occurred, if any
 * @api private
 */
var _insert = function(indexName, indexEntries, callback) {
    var queries = [];
    _.each(indexEntries, function(indexEntry) {
        var valueKey = _createValueKey(indexEntry.resourceId, indexEntry.rank);

        // Allowing the caller to specify the data may prove to be a useful performance tool where there is
        // a "light-weight" version of an item desired, which could be achieved without having to follow with
        // a multi-get (e.g., store a denormalized version of library items for light-weight view). For now
        // we just store a '1' since it would be premature optimization to implement that at this time
        var value = '1';

        _.each(visibilityMasks, function(mask, visibility) {
            if (_.contains(mask, indexEntry.visibility)) {
                queries.push({
                    'query': 'INSERT INTO "LibraryIndex" ("bucketKey", "rankedResourceId", "value") VALUES (?, ?, ?)',
                    'parameters': [_createBucketKey(indexName, indexEntry.libraryId, visibility), valueKey, value]
                });
            }
        });
    });

    log().trace({
        'indexName': indexName,
        'indexEntries': indexEntries
    }, 'Inserting index entries into library index');

    Cassandra.runBatchQuery(queries, callback);
};

/**
 * Determine if the library query (provided by the cassandra `columns`) is deemed to be stale.
 *
 * @param  {String}     start       The start parameter that was specified to result in this `rows` result
 * @param  {Number}     limit       The limit that was used for this `rows` result
 * @param  {Row[]}      rows        The cassandra rows that represents the result of the library index query
 * @return {Boolean}                `true` if the rows indicate that the library index is stale, `false` otherwise
 * @api private
 */
var _isStaleLibraryIndex = function(start, limit, rows) {
    var slugHighColumn = _.find(rows, function(row) {
        return (row.get('rankedResourceId').value === SLUG_HIGH);
    });

    var slugLowColumn = _.find(rows, function(row) {
        return (row.get('rankedResourceId').value === SLUG_LOW);
    });

    if (!start && !slugHighColumn) {
        // If we didn't supply a start parameter and did not get the upper bound limiter, we need to
        // refresh the index because it indicates this index has been purged and not yet rebuilt
        return true;
    } else if (rows.length < limit && !slugLowColumn) {
        // If we exhausted the entries and the last entry wasn't the low-bound slug, then we have a
        // purged index and need to rebuild it
        return true;
    }

    // Otherwise, this library index is deemed to be fresh
    return false;
};

/**
 * Given a list of rows that were queried from a library index, adjust it for the fact that:
 *
 *  * The query had slugs (i.e., SLUG_HIGH, SLUG_LOW) to determine the "freshness" of the library; and
 *  * The query incremented the limit by 1 to account for potentially selecting the SLUG_HIGH value; and
 *  * The last item may be a SLUG_LOW, in which case we've exhausted the items in the library
 *
 * The result is an object with keys:
 *
 *  * `keys`:       The column keys that were selected in the row, representing the entries that were queried from the library
 *  * `nextToken`:  The value to use as the `start` parameter for the next query to get the next set of entries from this library
 *
 * @param  {String}     start       The value that was used as the `start` when querying the library that produced this row
 * @param  {Number}     limit       The **actual** limit that we wanted, not the potentially incremented limit to account for slugs
 * @param  {Row[]}      rows        The list of cassandra rows that were returned from the query
 * @param  {String}     nextToken   The nextToken that was returned by the cassandra query
 * @return {Object}                 An object holding the selected value keys and the real nextToken. See method summary for more information
 * @api private
 */
var _adjustColumnsForSlugs = function(start, limit, rows, nextToken) {
    var result = {
        'keys': [],
        'nextToken': nextToken
    };

    _.each(rows, function(row) {
        var rankedResourceId = row.get('rankedResourceId').value;
        var value = row.get('value').value;
        if (value === '1') {
            if (rankedResourceId === SLUG_LOW) {
                // If we hit the low slug, it means we actually exhausted our list. Simply ignore this entry,
                // but we can set nextToken to `null` to indicate we have exhausted the entries
                result.nextToken = null;
            } else if (rankedResourceId !== SLUG_HIGH) {
                // We have found an actual ranked resource id, push it into the results
                result.keys.push(rankedResourceId);
            }
        }
    });

    // If there were additional items selected, knock them off the end according to the limit
    if (result.keys.length > limit) {
        result.keys = result.keys.slice(0, limit);
        if (result.nextToken) {
            // If the nextToken was previously specified, adjust it to the new nextToken as a result of this slice
            result.nextToken = _.last(result.keys);
        }
    }

    return result;
};

/**
 * Create the storage key that tracks the items in the index with key `indexKey` and name `bucketName`
 *
 * It is of the format: <indexKey>#<bucketName>
 *
 * @param  {String}     indexName   The name of the index
 * @param  {String}     indexKey    The key of the index under this name
 * @param  {String}     bucketName  The name of the bucket in the bucket key
 * @return {String}                 The bucket key
 * @api private
 */
var _createBucketKey = function(indexName, indexKey, bucketName) {
    return util.format('%s#%s#%s', indexName, indexKey, bucketName);
};

/**
 * Create the value key (i.e., key of column name which stores the index value) for the given
 * resource and rank.
 *
 * @param  {String}         resourceId  The id of the resource
 * @param  {String|Number}  [rank]      The rank of the resource in the library. If unspecified, will default to 0
 * @return {String}                     The key to use as the column name in the index
 * @api private
 */
var _createValueKey = function(resourceId, rank) {
    rank = rank || 0;
    return util.format('%s#%s', rank, resourceId);
};

/**
 * Given a value key (as created form `_createValueKey`) into its rank and resourceId.
 *
 * @param  {String}     valueKey            The valueKey to split
 * @param  {Function}   callback            Invoked when the key has been split
 * @param  {String}     callback.resourceId The id of the resource in the valueKey
 * @param  {String}     callback.rank       The rank (string representation of the number if it was a number) of the resourceKey in the index
 * @api private
 */
var _splitValueKey = function(valueKey, callback) {
    var parts = valueKey.split('#');
    return callback(parts.slice(1).join('#'), parts[0]);
};
