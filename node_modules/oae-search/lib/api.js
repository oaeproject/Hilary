/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzUtil = require('oae-authz/lib/util');
var FollowingDAO = require('oae-following/lib/internal/dao');
var log = require('oae-logger').logger('oae-search');
var MQ = require('oae-util/lib/mq');
var Telemetry = require('oae-telemetry').telemetry('search');

var client = require('./internal/elasticsearch');
var SearchConstants = require('oae-search/lib/constants').SearchConstants;
var SearchResult = require('oae-search/lib/model').SearchResult;
var SearchUtil = require('oae-search/lib/util');

// Indicates whether or not the search indexing handler has been bound to the task queue
var boundIndexWorkers = false;

var reindexAllHandlers = {};
var searches = {};
var searchDocumentProducers = {};
var searchDocumentTransformers = {
    /*!
     * A default document transformer that simply returns the stored fields of the document, plus the id.
     * @see registerSearchDocumentTransformer
     */
    '*': function(ctx, docs, callback) {
        var result = _.map(docs, function(doc) {
            return _.extend({}, doc.fields, { 'id': doc['_id'] });
        });
        return callback(null, result);
    }
};

/**
 * Refresh the search configuration with the given options.
 *
 * @param  {String}    index                   The index to use
 * @param  {Object}    serverOpts              The server opts with which to configure the client
 * @param  {Boolean}   processIndexJobs        Whether or not this node should process indexing jobs sent through the task queue
 * @param  {Function}  callback                Invoked when configuration has been refreshed
 */
var refreshSearchConfiguration = module.exports.refreshSearchConfiguration = function(indexName, serverOpts, processIndexJobs, callback) {
    client.refreshSearchConfiguration(indexName, serverOpts);

    if (processIndexJobs && !boundIndexWorkers) {
        boundIndexWorkers = true;
        MQ.bind(SearchConstants.mq.TASK_INDEX_DOCUMENT, _handleIndexDocumentTask, null, function() {
            MQ.bind(SearchConstants.mq.TASK_DELETE_DOCUMENT, _handleDeleteDocumentTask, null, function() {
                MQ.bind(SearchConstants.mq.TASK_REINDEX_ALL, _handleReindexAllTask, null, callback);
            });
        });
    } else if (!processIndexJobs && boundIndexWorkers) {
        boundIndexWorkers = false;
        MQ.unbind(SearchConstants.mq.TASK_INDEX_DOCUMENT, function() {
            MQ.unbind(SearchConstants.mq.TASK_DELETE_DOCUMENT, function() {
                MQ.unbind(SearchConstants.mq.TASK_REINDEX_ALL, callback);
            });
        });
    } else {
        // If we get here, there was no state change in handling indexing, so we don't need to do anything.
        callback();
    }
};

/**
 * Register a transformer with the search API that will transform search documents into a model that can be returned to the
 * UI for the user. There can only be one transformer per resource type. The document transformers are given the search documents
 * after they have been retrieved from ElasticSearch. Once transformed, the final search results are sent back to the client.
 *
 * @param  {String}    typeName                    The type of document this transformer acts upon
 * @param  {Function}  transformer                 The function that will transform an array of search documents into an array of view objects
 * @param  {Context}   transformer.ctx             The context of the currently authenticated user
 * @param  {Object}    transformer.docs            The raw search documents, keyed by document 'id', that were returned in the search
 * @param  {Function}  transformer.callback        The callback function the transformer should execute to indicate it has completed processing
 * @param  {Object}    transformer.callback.err    An error that occurred while transforming the docs, if any
 * @param  {Object}    transformer.callback.docs   The view model, keyed by document _id, that were translated from the hash of search documents
 * @throws {Error}                                 An error that is thrown if there is already a transformer registered for the given type
 */
var registerSearchDocumentTransformer = module.exports.registerSearchDocumentTransformer = function(typeName, transformer) {
    if (searchDocumentTransformers[typeName]) {
        throw new Error('Document transformer for type ' + typeName + ' already exists.');
    }
    searchDocumentTransformers[typeName] = transformer;
};

/**
 * Register a producer with the search API that will produce search documents to be added to the search index. There can only be one
 * producer per resource type. When a new indexing task is submitted for a resource that is of `typeName` resource type, then this
 * producer will have an opportunity to produce documents to be indexed.
 *
 * By default each document will have its `_type` set to `SearchConstants.resourceMappingName`.
 * If you've added a mapping for a new type, you can specify it on a search document by
 * giving it the appropriate value for the `_type` key.
 *
 * You can also specify a `_parent` value which can point to any search document in the index.
 *
 * @param  {String}    typeName                The resource type that this indexer indexes
 * @param  {Function}  producer                A function that will produce documents to be indexed
 * @param  {Object[]}  producer.resourceData   An array of objects that represent the data that drives the producer. The format of the actual data object will generally be different for different resource types
 * @param  {Function}  producer.callback       The callback function that should be invoked when the indexer has produced the documents
 * @param  {Object}    producer.callback.err   An error that occurred while creating the documents, if any
 * @param  {Object[]}  producer.callback.docs  The documents to be indexed
 * @throws {Error}                             An error that is thrown if there is already a producer registered for the given type
 */
var registerSearchDocumentProducer = module.exports.registerSearchDocumentProducer = function(typeName, producer) {
    if (searchDocumentProducers[typeName]) {
        throw new Error('Document producer for type ' + typeName + ' already exists.');
    }
    searchDocumentProducers[typeName] = producer;
};

/**
 * Register a search with the Search API that will process search input and produce a query to run against elastic search. Once the query
 * is created by the search registered here, the search will be sent to ElasticSearch and and all results will be passed through the
 * document transformers. @see #registerSearchDocumentTransformer for more information.
 *
 * @param  {String}    typeName                            The name of the search. Once registered, this search can be invoked by using this `typeName` in the `search` method.
 * @param  {Function}  queryBuilder                        The search function that will be invoked when a search is performed. This function is responsible for generating a query as per the ElasticSearch Query DSL and returning it in the callback.
 * @param  {Context}   queryBuilder.ctx                    The context of the search being performed
 * @param  {Object}    queryBuilder.opts                   The search opts that are specific to the search
 * @param  {String[]}  [queryBuilder.opts.params]          An array of search parameters that are specific to the search (i.e., for ordered path parameters)
 * @param  {Function}  queryBuilder.callback               The callback function that should be invoked when the search has created the query
 * @param  {Object}    queryBuilder.callback.err           An error that occurred while creating the query. Pass an error parameter to indicate an error occurred, if it was successful, this parameter should be left `null`
 * @param  {Object}    queryBuilder.callback.queryData     The Query DSL object representing the query, as per the ElasticSearch documentation; If not specified, short-circuits the process to return 0 results.
 * @throws {Error}                                         An error that is thrown if there is already a search registered by the given name
 */
var registerSearch = module.exports.registerSearch = function(typeName, queryBuilder) {
    if (searches[typeName]) {
        throw new Error('Search type ' + typeName + ' already exists.');
    }
    searches[typeName] = queryBuilder;
};

/**
 * Register a handler for a reindex all operation. When a full re-index has been triggered, this handler will be invoked.
 *
 * @param  {String}     handlerId               The id of the handler invoked
 * @param  {Function}   handler                 The handler function that will be invoked when a full re-index has been triggered
 * @param  {Function}   handler.callback        The callback function that should be invoked when reindexing has been completed
 * @param  {Object}     handler.callback.err    An error that occurred during reindexing, if any
 */
var registerReindexAllHandler = module.exports.registerReindexAllHandler = function(handlerId, handler) {
    if (reindexAllHandlers[handlerId]) {
        throw new Error('Reindex-all handler with id ' + handlerId + ' already exists.');
    }
    reindexAllHandlers[handlerId] = handler;
};

/**
 * Perform a search of a given type.
 *
 * @param  {Context}        ctx                 The current context of the request
 * @param  {String}         searchType          The type of search to perform (e.g., 'general')
 * @param  {Object}         opts                A hash describing the search parameters
 * @param  {String[]}       [opts.pathParams]   An array of path parameters for the search. The requirements of the path parameters are specific to the type of search being performed.
 * @param  {String}         [opts.q]            A full-text search query to apply to search with
 * @param  {Number}         [opts.limit]        The maximum number of search documents to return
 * @param  {Number}         [opts.start]        The document index from which to start
 * @param  {String}         [opts.sort]         The direction to sort the results. One of 'asc' or 'desc'
 * @param  {Function}       callback            Invoked when the process completes
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Object}         callback.result     The search result object
 */
var search = module.exports.search = function(ctx, searchType, opts, callback) {
    var registeredSearch = searches[searchType];
    if (!registeredSearch) {
        return callback({'code': 400, 'msg': 'Search "' + searchType + '" is not a valid search type.'});
    }

    // Invoke the search plugin to get the query object
    registeredSearch(ctx, opts, function(err, queryData) {
        if (err) {
            return callback(err);
        } else if (!queryData) {
            return callback(null, new SearchResult(0, []));
        }

        // Query only the document fields in the index, and not the _source and others
        queryData.fields = '*';

        // Perform the search with the query data
        client.search(queryData, null, function(err, results) {
            if (err) {
                log().error({'err': err}, 'An unexpected error occurred performing a search');
                return callback({'code': 500, 'msg': 'An unexpected error occurred performing the search'});
            }

            // We pull the '_extra' field out and parse it into JSON
            var hits = results.hits.hits;
            for (var i = 0; i < hits.length; i++) {
                var hit = hits[i];
                if (hit.fields._extra) {
                    try {
                        hit.fields._extra = JSON.parse(hit.fields._extra);
                    } catch (parseErr) {
                        log().warn({'err': parseErr, 'hit': hit}, 'Failed to parse _extra field of search document into JSON. Ignoring.');
                    }
                }
            }

            SearchUtil.transformSearchResults(ctx, searchDocumentTransformers, results, function(err, results) {
                if (err) {
                    return callback(err);
                }

                // Scrub the _extra field from all results
                var docs = results.results;
                if (docs && docs.length > 0) {
                    for (var i = 0; i < docs.length; i++) {
                        delete docs[i]._extra;
                    }
                }

                return callback(null, results);
            });
        });
    });
};

/**
 * Submits a task that will re-index all search documents in storage.
 *
 * @param  {Context}    ctx             The processing context in which the reindexAll task was executed
 * @param  {Function}   callback        Invoked when the task has been submitted. Note that actual reindexing will happen asynchronously despite this callback.
 * @param  {Object}     callback.err    An error that occurred while invoking the task, if any
 */
var reindexAll = module.exports.reindexAll = function(ctx, callback) {
    if (!ctx.user() || !ctx.user().isGlobalAdmin()) {
        return callback({'code': 401, 'msg': 'Only global administrator can trigger a full reindex.'});
    }

    MQ.submit(SearchConstants.mq.TASK_REINDEX_ALL, null, callback);
};

/**
 * When bound to an MQ reindex-all task, this method will reindex all resource in the search engine.
 *
 * @param  {Object}     data            The task data
 * @param  {Function}   callback        Invoked when all re-indexing has completed
 * @param  {Object}     callback.err    An error that occurred during re-indexing, if any
 * @api private
 */
var _handleReindexAllTask = function(data, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'data': data}, 'Error handling reindex-all task.');
        }
    };

    var numToProcess = _.keys(reindexAllHandlers).length;
    if (numToProcess === 0) {
        // No handlers for reindexing, nothing to do
        return callback();
    }

    // Invoke all handlers and return to the caller when they have all completed (or we get an error)
    var complete = false;
    _.each(reindexAllHandlers, function(handler, handlerId) {
        handler(function(err) {
            if (complete) {
                // Do nothing, we've already returned to the caller
                return;
            } else if (err) {
                complete = true;
                return callback(err);
            }

            numToProcess--;
            if (numToProcess === 0) {
                log().info({'handlers': _.keys(reindexAllHandlers)}, 'Finished re-indexing all items.');
                complete = true;
                return callback();
            }
        });
    });
};

/**
 * When bound to an MQ delete document task, this method will delete the resource from the search engine.
 *
 * @param  {Object}    data            The task data
 * @param  {String}    data.id         The _id of the document to delete
 * @param  {Function}  callback        Invoked when indexing has completed
 * @param  {Object}    callback.err    An error that occurred, if any
 * @api private
 */
var _handleDeleteDocumentTask = function(data, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'data': data}, 'Error handling search document delete task.');
        }
    };

    // Delete the resource document, plus all its children
    var errs = [];
    client.del(SearchConstants.resourceMembersMappingName, SearchUtil.getResourceMembersDocumentId(data.id), function(err) {
        if (err) {
            errs.push(err);
        }

        client.del(SearchConstants.resourceMembershipsMappingName, SearchUtil.getResourceMembershipsDocumentId(data.id), function(err) {
            if (err) {
                errs.push(err);
            }

            client.del(SearchConstants.resourceMappingName, data.id, function(err) {
                if (err) {
                    errs.push(err);
                }

                return callback(errs[0]);
            });
        });
    });
};

/**
 * When bound to am MQ index document task, this method will index the resource document(s) as described by the
 * task data.
 *
 * @param  {Object}    data                The task data
 * @param  {String}    data.resourceType   The type of the resource being indexed
 * @param  {Object[]}  data.resources      An array of resources that are to be indexed. This should be in the format depended on in the resource type's custom document producer
 * @param  {Function}  callback            Invoked when indexing has completed
 * @param  {Object}    callback.err        An error that occurred, if any
 * @api private
 */
var _handleIndexDocumentTask = function(data, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'data': data}, 'Error handling search indexing task.');
        }
    };

    var resourceType = data.resourceType;

    // The array of top-level resources that need to be updated, filter only those that specify that the resource needs to be re-indexed
    var resourceUpdates = _.filter(data.resources, function(resource) {
        return (!resource.opts || resource.opts.indexResource !== false);
    });

    // Array of member updates that need to be performed
    var memberUpdates = _.filter(data.resources, function(resource) {
        return (resource.opts && resource.opts.indexMembers === true);
    });

    // Array of membership updates that need to be performed
    var membershipUpdates = _.filter(data.resources, function(resource) {
        return (resource.opts && resource.opts.indexMemberships === true);
    });

    var searchDocumentProducer = searchDocumentProducers[resourceType];
    if (searchDocumentProducer) {

        // Pass the resource updates to the document producers to provide the resource meta-data updates
        searchDocumentProducer(resourceUpdates, function(err, resourceDocs) {
            if (err) {
                log().error({'err': err, 'data': data}, 'Error processing task data into search documents.');
                return callback(err);
            }

            resourceDocs = _.map(resourceDocs, function(doc) {
                // Allow people to create their own mappings but re-use the normal document producer mechanisme.
                var resourceMappingName = doc['_type'] ? doc['_type'] : SearchConstants.resourceMappingName;

                // Add some type information
                var newDoc = _.extend({}, doc, {
                    '_type': resourceMappingName,
                    'resourceType': resourceType
                });

                // Stringify the _extra field, it gets parsed on the way back out
                if (newDoc._extra) {
                    try {
                        newDoc._extra = JSON.stringify(newDoc._extra);
                    } catch (err) {
                        log().warn({'err': err, 'doc': doc}, 'Error stringifying _extra content for document. Suppressing data.');
                        delete newDoc._extra;
                    }
                }

                log().trace({'before': doc, 'after': newDoc}, 'Converted resource document.');

                return newDoc;
            });

            // Update the members and memberships, where appropriate
            _aggregateMembersDocuments(memberUpdates, function(err, memberDocs) {
                if (err) {
                    log().error({'err': err, 'memberUpdates': memberUpdates}, 'Error processing resource member updates.');
                    return callback(err);
                }

                _aggregateMembershipsDocuments(membershipUpdates, function(err, membershipsDocs) {
                    if (err) {
                        log().error({'err': err, 'membershipUpdates': membershipUpdates}, 'Error processing resource membership updates.');
                        return callback(err);
                    }

                    // Aggregate all documents into one bulk update
                    allDocs = _.union(resourceDocs, memberDocs, membershipsDocs);
                    if (allDocs.length > 1) {
                        var ops = SearchUtil.createBulkIndexOperations(allDocs);
                        client.bulk(ops, function(err) {
                            if (!err) {
                                log().info('Successfully indexed %s documents.', allDocs.length);
                            }
                            return callback(err);
                        });
                    } else if (allDocs.length === 1) {
                        var doc = allDocs[0];
                        var opts = {'parent': doc['_parent']};
                        var id = doc.id;

                        delete doc['_parent'];
                        delete doc.id;

                        client.index(doc['_type'], id, doc, opts, callback);
                    } else {
                        callback();
                    }
                });
            });
        });
    } else {
        log().warn('Ignoring %s documents of type "%s", which do not have an associated document producer.', data.resources.length, resourceType);
        callback();
    }
};

/**
 * Create the resource members documents for the given array of principals.
 *
 * @param  {Object[]}  principalIds        An array of principal ids whose members list document should be aggregated
 * @param  {Function}  callback            Invoked when the process completes
 * @param  {Object}    callback.err        An error that occurred, if any
 * @param  {Object[]}  callback.docs       The array of member documents to index
 */
var _aggregateMembersDocuments = function(principalIds, callback, memberDocs) {
    memberDocs = memberDocs || [];
    if (principalIds.length === 0) {
        return callback(null, memberDocs);
    }

    var memberUpdate = principalIds.shift();
    var resourceId = memberUpdate.id;
    var members = memberUpdate.members;
    if (members) {
        memberDocs.push(_createMembersDocument(resourceId, _.keys(members)));
        return _aggregateMembersDocuments(principalIds, callback, memberDocs);
    } else if (AuthzUtil.isUserId(resourceId)) {
        // If the resource whose members to reindex is a user, then the index is the user followers list
        FollowingDAO.getFollowers(resourceId, null, 10000, function(err, followerUserIds) {
            if (err) {
                return callback(err);
            }

            memberDocs.push(_createMembersDocument(resourceId, followerUserIds));
            return _aggregateMembersDocuments(principalIds, callback, memberDocs);
        });
    } else {
        // If the resource whose members to reindex is not a user, we get their members list
        AuthzAPI.getAuthzMembers(resourceId, null, 10000, function(err, members) {
            if (err) {
                return callback(err);
            }

            members = _.map(members, function(member) { return member.id; });
            memberDocs.push(_createMembersDocument(resourceId, members));
            return _aggregateMembersDocuments(principalIds, callback, memberDocs);
        });
    }
};

/**
 * Create the resource (direct) memberships documents that coincide with the given array of principals.
 *
 * @param  {Object[]}  principalIds        An array of principal ids whose membership list document should be aggregated
 * @param  {Function}  callback            Invoked when the process completes
 * @param  {Object}    callback.err        An error that occurred, if any
 * @param  {Object[]}  callback.docs       The array of membership documents to index
 */
var _aggregateMembershipsDocuments = function(membershipUpdates, callback, _membershipsDocs) {
    _membershipsDocs = _membershipsDocs || [];
    if (membershipUpdates.length === 0) {
        return callback(null, _membershipsDocs);
    }

    var membershipUpdate = membershipUpdates.shift();
    var resourceId = membershipUpdate.id;

    // Get all the direct group memberships of the given resource. Here we are filtering the memberships to "group" types. This
    // means that we will only be able to search through group memberships. If we want to search through a content item's
    // members list, we could change this to include both group memberships and content memberships. This is not currently a
    // requirement though.
    AuthzAPI.getRolesForPrincipalsAndResourceType([resourceId], AuthzConstants.resourceTypes.GROUP, 10000, function(err, memberships) {
        if (err) {
            return callback(err);
        }

        var membershipIds = _.keys(memberships);

        // If the resource is not a user, we don't need to include the followed user ids
        if (!AuthzUtil.isUserId(resourceId)) {
            _membershipsDocs.push(_createMembershipsDocument(resourceId, membershipIds));
            return _aggregateMembershipsDocuments(membershipUpdates, callback, _membershipsDocs);
        }

        // If the resource is a user, we'll need to also include the users they are following as "memberships"
        FollowingDAO.getFollowing(resourceId, null, 10000, function(err, followingUserIds) {
            if (err) {
                return callback(err);
            }

            // Include the followingUserIds in the membership ids
            membershipIds = _.compact(membershipIds.concat(followingUserIds));

            _membershipsDocs.push(_createMembershipsDocument(resourceId, membershipIds));
            return _aggregateMembershipsDocuments(membershipUpdates, callback, _membershipsDocs);
        });
    });
};

/**
 * Create a resource members document that can be indexed.
 *
 * @param  {String}    resourceId      The id of the resource whose members are being indexed
 * @param  {String[]}  memberIds       The array of principal ids that represent the members of the resource
 * @return {Object}                    A search document that can be indexed for the given resource
 */
var _createMembersDocument = function(resourceId, memberIds) {
    return {
        '_parent': resourceId,
        '_type': SearchConstants.resourceMembersMappingName,
        'id': SearchUtil.getResourceMembersDocumentId(resourceId),
        'direct_members': memberIds
    };
};

/**
 * Create a principal memberships document that can be indexed.
 *
 * @param  {String}    principalId     The id of the principal whose memberships are being indexed
 * @param  {String[]}  groupIds        The array of group ids that represent the groups of which the principal is a direct member
 * @return {Object}                    A search document that can be indexed for the given principal
 */
var _createMembershipsDocument = function(principalId, groupIds) {
    return {
        '_parent': principalId,
        '_type': SearchConstants.resourceMembershipsMappingName,
        'id': SearchUtil.getResourceMembershipsDocumentId(principalId),
        'direct_memberships': groupIds
    };
};


