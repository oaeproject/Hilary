/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * visibilitys and limitations under the License.
 */

var _ = require('underscore');

var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var PrincipalsAPI = require('oae-principals');
var TenantsUtil = require('oae-tenants/lib/util');
var Validator = require('oae-util/lib/validator').Validator;

var ProfileSection = require('./model').ProfileSection;
var Constants = require('./model').Constants;

/**
 * Create or update a principal's profile section.
 * This method supports partial updates. It will merge the old object with the new one if `overwrite` is set to false.
 *
 * @param  {Context}         ctx                 The context
 * @param  {String}          principalId         The principal for who we need to update this section.
 * @param  {String}          sectionName         The name of the section that needs updating.
 * @param  {String}          sectionVisibility   One of "private", "loggedin" or "public"
 * @param  {Object}          sectionData         A JSON object that will be stored in the DB.
 * @param  {Boolean}         overwrite           Specifies whether the profile should be completely overwritten. (default: true)
 * @param  {Function}        callback            A callback method takes argument `err`
 * @param  {Object}          callback.err        An error object (if any)
 */
var setSection = module.exports.setSection = function(ctx, principalId, sectionName, sectionVisibility, sectionData, overwrite, callback) {
    sectionData = sectionData || {};
    callback = callback || {};
    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'A principal id must be provided'}).notEmpty();
    validator.check(sectionName, {'code': 400, 'msg': 'A section name must be provided'}).notEmpty();
    validator.check(null, {'code': 400, 'msg': 'The overwrite variable must be a boolean'}).isBoolean(overwrite);
    validator.check(null, {'code': 400, 'msg': 'Only proper objects are accepted as section data'}).isObject(sectionData);
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to change a profile section.'}).isLoggedInUser(ctx);
    if (sectionVisibility !== undefined) {
        var visibilities = _.values(Constants.visibility);
        validator.check(sectionVisibility, {'code': 400, 'msg': 'Visibility should be one of: ' + visibilities.join(',')}).isIn(visibilities);
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Only the user owner or an admin has access
    var principalResource = AuthzUtil.getResourceFromId(principalId);
    if (ctx.user().id === principalId || ctx.user().isAdmin(principalResource.tenantAlias)) {

        // Get the section in case we're updating
        getSection(ctx, principalId, sectionName, function(err, oldProfileSection) {
            if (err && err.code !== 404) {
                return callback(err);
            }

            // Create a new  section or update the old one
            var profileSection = null;
            if (err && err.code === 404) {
                // This is a new profile section
                sectionVisibility = sectionVisibility || Constants.visibility.PUBLIC;
                profileSection = new ProfileSection(principalId, sectionName, sectionData, sectionVisibility);
            } else {
                // This is an update, merge it with the old section
                var data = oldProfileSection.data || {};
                if (!overwrite) {
                    data = _.extend(data, sectionData);
                } else {
                    data = sectionData;
                }
                var visibility = sectionVisibility || oldProfileSection.visibility;
                profileSection = new ProfileSection(principalId, sectionName, data, visibility);
            }

            // Store the profile section
            _setSection(principalId, profileSection, callback);
        });
    } else {
        return callback({'code': 401, 'msg': 'You\'re not allowed to change this user\'s profile'});
    }
};

/**
 * Updates a section. This function will not perform any checking on validity of
 * visibility, data, etc.. It's assumed the caller takes care of this.
 *
 * @param  {String}            principalId      The id of the principal to whom this section belongs.
 * @param  {ProfileSection}    profileSection   The profilesection that contains the (updated) data.
 * @param  {Function}          callback         Callback method.
 * @param  {Object}            callback.err     An error object (if any.)
 * @api private
 */
var _setSection = function(principalId, profileSection, callback) {
    var columnVisibilityName = profileSection.name + '#visibility';
    var columnDataName = profileSection.name + '#data';
    data = JSON.stringify(profileSection.data);
    Cassandra.runQuery('UPDATE Profiles USING CONSISTENCY QUORUM SET ?=?, ?=? WHERE principalId=?', [columnVisibilityName, profileSection.visibility, columnDataName, data, principalId], callback);
};

/**
 * Gets a section for a principal. If this principal has marked the section as private and is being retrieved by another non-admin user, an error will be passed.
 *
 * @param  {Context}                ctx             The context
 * @param  {String}                 principalId     The principalId for who we need to retrieve a section.
 * @param  {String}                 sectionName     The name of the section that needs retrieving.
 * @param  {Function}               callback        A callback method takes arguments `err` and `data`
 * @param  {Object}                 callback.err    An error object (if any)
 * @param  {ProfileSection}         callback.data   A ProfileSection object.
 */
var getSection = module.exports.getSection = function(ctx, principalId, sectionName, callback) {
    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'The anonymous user does not have any profile sections.'}).notNull();
    validator.check(sectionName, {'code': 400, 'msg': 'The sectionName was not provided.'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var columnVisibilityName = sectionName + '#visibility';
    var columnDataName = sectionName + '#data';
    Cassandra.runQuery('SELECT ?, ? FROM Profiles USING CONSISTENCY QUORUM WHERE principalId = ?', [columnVisibilityName, columnDataName, principalId], function(err, rows) {
        if (err) {
            return callback(err);
        } else if (rows[0].count <= 1) {
            return callback({'code': 404, 'msg': 'Section not found'});
        }

        var visibility = rows[0].get(columnVisibilityName).value;

        // Only actually parse the data when we're sure that the current user can access it
        PrincipalsAPI.getUser(ctx, principalId, function(err, user) {
            if (err) {
                return callback(err);
            }

            var profileSection = new ProfileSection(principalId, sectionName, {}, visibility);
            if (!_hasAccessToSection(ctx, user, profileSection)) {
                return callback({'code': 401, 'msg': 'You don\' t have access to this profile section'});
            }

            try {
                var data = rows[0].get(columnDataName).value;
                profileSection.data = JSON.parse(data);
            } catch (err) {
                return callback({'code': 500, 'msg': 'Couldn\'t parse the data for section "' + profileSection.name + '".'});
            }

            callback(null, profileSection);
        });
    });
};

/**
 * Gets all the profile sections for a principal. Lists only the sections the requesting user can access along with their visibility
 *
 * @param  {Context}                ctx             The current user's context
 * @param  {String}                 principalId     The id of the principal for whom the profile should be retrieved.
 * @param  {Function}               callback        A callback method takes arguments `err` and `data`
 * @param  {Object}                 callback.err    An error object (if any)
 * @param  {Object}                 callback.data   Object where keys are section ids and values are visibility of the section.
 */
var getSectionOverview = module.exports.getSectionOverview = function(ctx, principalId, callback) {
    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'The anonymous user does not have any profile sections.'}).notNull();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    PrincipalsAPI.getUser(ctx, principalId, function(err, user) {
        if (err) {
            return callback(err);
        } else if (!_hasAccessToOverview(ctx, user)) {
            // if we don't have profile access to this user at all, we short-circuit with a 401
            return callback({'code': 401, 'msg': 'You are not authorized to view this user\'s profile sections'});
        }

        Cassandra.runQuery('SELECT * FROM Profiles USING CONSISTENCY QUORUM WHERE principalId = ?', [principalId], function(err, rows) {
            if (err) {
                return callback(err);
            } else if (rows[0].count <= 1) {
                return callback(null, []);
            }

            var visibilities = {};

            rows[0].forEach(function(name, value, ts, ttl) {
                if (name === 'principalId') {
                    return;
                }
                var parts = name.split('#');
                if (parts[1] === 'data') {
                    var sectionName = parts[0];
                    var visibility = rows[0].get(sectionName + '#visibility').value;
                    var profileSection = new ProfileSection(principalId, sectionName, {}, visibility);
                    if (_hasAccessToSection(ctx, user, profileSection)) {
                        visibilities[sectionName] = visibility;
                    }
                }
            });
            callback(null, visibilities);
        });
    });
};

/**
 * Determine whether or not the current user has access to the section profile overview of the current user.
 *
 * @param  {Context}   ctx         The current user context
 * @param  {User}      user        The user to check against
 * @return {Boolean}               Whether or not the user in context has access to view the provided user's profile section overview
 */
var _hasAccessToOverview = function(ctx, user) {
    var userTenantAlias = user.tenant.alias;

    if (user.visibility === Constants.visibility.PUBLIC) {
        return true;
    } else if (user.visibility === Constants.visibility.LOGGEDIN && TenantsUtil.isLoggedIn(ctx, userTenantAlias)) {
        return true;
    } else if (ctx.user() && (ctx.user().id === user.id || ctx.user().isAdmin(userTenantAlias))) {
        // Assuming private, it must be the user themself or an admin to view the user
        return true;
    }

    // If we get here, there is no access
    return false;
};

/**
 * Checks if the current user has access to this profile section.
 *
 * @param  {Context}                   ctx                 Current user's context
 * @param  {User}                      user                The user the profile section is related to
 * @param  {ProfileSection}            profileSection      The section that needs to be checked. If not specified, the check will be limited to if the user in context has access to *any* profile section of the given user
 * @return {Boolean}                                       Whether or not the current user can see this profile section.
 * @api private
 */
var _hasAccessToSection = function(ctx, user, profileSection) {
    var userTenantAlias = user.tenant.alias;

    if (!_hasAccessToOverview(ctx, user)) {
        // If we cannot see the overview, we cannot see any profile sections regardless of their visibility
        return false;
    } else if (profileSection.visibility === Constants.visibility.PUBLIC) {
        // Public profile sections can always be seen
        return true;
    } else if (profileSection.visibility === Constants.visibility.LOGGEDIN && TenantsUtil.isLoggedIn(ctx, userTenantAlias)) {
        // If the section is restricted to logged in users, ensure the current user is authenticated and belongs to the profile's tenant
        return true;
    } else if (ctx.user() && (ctx.user().id === user.id || ctx.user().isAdmin(userTenantAlias))) {
        // We are the user or an admin, therefore we can always see
        return true;
    }

    // If we get here, it's a failed check
    return false;
};

