/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var _ = require('underscore');
var AuthzAPI = require('oae-authz');
var AuthzUtil = require('oae-authz/lib/util');
var log = require('oae-logger').logger('oae-activity');
var MQ = require('oae-util/lib/mq');
var Validator = require('oae-authz/lib/validator').Validator;

var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;
var ActivityDAO = require('./internal/dao');
var ActivityStream = require('oae-activity/lib/model').ActivityStream;

var activityProducers = {};
var activityRouters = {};
var boundWorker = false;

/**
 * Refresh the activities configuration.
 *
 * @param   {Boolean}       processActivityJobs     Whether or not this server node should produce and route activities
 * @param   {Function}      [callback]              Invoked when the configuration has been refreshed
 * @param   {Object}        [callback.err]          An error that occurred, if any
 */
var refreshConfiguration = module.exports.refreshConfiguration = function(processActivityJobs, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Error refreshing activities configuration.');
        }
    };

    if (processActivityJobs && !boundWorker) {
        boundWorker = true;
        MQ.bind(ActivityConstants.mq.TASK_ACTIVITY, _handleActivityTask, callback);
    } else if (!processActivityJobs && boundWorker) {
        boundWorker = false;
        MQ.unbind(ActivityConstants.mq.TASK_ACTIVITY, callback);
    } else {
        callback();
    }
};

/**
 * Register an activity producer. The activity producer is responsible for taking a single resource object from the activity seed
 * and converting it into an ActivityObject that can be used in an activity.
 *
 * @param   {String}         resourceType                     The type of resource this producer is meant to produce activity objects for (e.g., content, comment, user...)
 * @param   {Function}       producer                         The function that will convert the resource object into an activity object
 * @param   {String}         producer.activityType            The type of activity being generated
 * @param   {String}         producer.entityType              The entity type for which this object is being produced. One of actor, object, target
 * @param   {String}         producer.resource                The resource seed object that describes the resource to use to generate the activity object
 * @param   {Function}       producer.callback                The function to invoke when the object has been produced
 * @param   {Object}         producer.callback.err            An error that occurred, if any
 * @param   {ActivityObject} producer.callback.activityObject The activity object that was produced
 */
var registerActivityObjectProducer = module.exports.registerActivityObjectProducer = function(resourceType, producer) {
    if (activityProducers[resourceType]) {
        throw new Error('Attempted to register duplicate activity producer');
    }
    activityProducers[resourceType] = producer;
};

/**
 * Register an activity router. The activity producer is responsible for taking a single resource object from the activity seed
 * and converting it into an ActivityObject that can be used in an activity.
 *
 * @param   {String}         resourceType               The type of resource this router is meant to route (e.g., content, comment, user...)
 * @param   {Function}       router                     The function that will convert the resource object into an activity object
 * @param   {String}         router.activityType        The type of activity being routed
 * @param   {String}         router.entityType          The entity type for which this object is being routed. One of actor, object, target
 * @param   {ActivityObject} router.activityObject      The activity object model that was produced for the resource
 * @param   {Function}       router.callback            The function to invoke when the object has been produced
 * @param   {Object}         router.callback.err        An error that occurred, if any
 * @param   {ActivityObject} router.callback.routes     The routes to which the activity should be delivered
 */
var registerActivityRouter = module.exports.registerActivityRouter = function(resourceType, router) {
    if (activityRouters[resourceType]) {
        throw new Error('Attempted to register duplicate activity router');
    }
    activityRouters[resourceType] = router;
};

/**
 * Get the activity stream by the specified id.
 *
 * @param   {Context}       ctx                 The context of the current session
 * @param   {Number|String} start               Number of millis since the epoc (stringified or number version) from which to start returning activities. Only activities older than this timestamp will be returned.
 * @param   {Number}        limit               The number of activities to return
 * @param   {Function}      callback            Invoked when the process completes
 * @param   {Object}        callback.err        An error that occurred, if any
 * @param   {Activity[]}    callback.activities The list of activities
 */
var getActivityStream = module.exports.getActivityStream = function(ctx, activityStreamId, start, limit, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 400, 'msg': 'Must be logged in to see an activity stream'}).isLoggedInUser(ctx);
    validator.check(activityStreamId, {'code': 400, 'msg': 'Must specify an activity stream'}).notEmpty();
    validator.check(activityStreamId, {'code': 400, 'msg': 'You can only view activity streams for a principal'}).isPrincipalId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var userId = ctx.user().id;
    var targetAuthzPrincipal = AuthzUtil.getPrincipalFromId(activityStreamId);
    if (ctx.user().isAdmin(targetAuthzPrincipal.tenantAlias)) {
        // Admin of the target tenant can always see the stream
        return _getActivityStream(activityStreamId, start, limit, callback);
    } else if (AuthzUtil.isGroupId(activityStreamId)) {
        // You can only view a group's activity stream if you are a member of that group
        return AuthzAPI.hasAnyRole(userId, activityStreamId, function(err, hasAnyRole) {
            if (err) {
                return callback(err);
            } else if (!hasAnyRole) {
                return callback({'code': 401, 'msg': 'Must be a member of a group to see its activity stream'});
            }

            return _getActivityStream(activityStreamId, start, limit, callback);
        });
    } else if (activityStreamId === userId) {
        // You can only view a user's activity stream if it is yourself. No peeking at other user streams.
        return _getActivityStream(activityStreamId, start, limit, callback);
    }

    // if we're here, we were trying to view another user's activity stream, not allowed!
    return callback({'code': 401, 'msg': 'You are not authorized to see this user\'s activity stream'});
};

/**
 * Post an activity in the system to be routed.
 *
 * @param   {ActivitySeed}  activitySeed        The activity "seed" object, which represents the smallest amount of information necessary to generate an activity
 * @param   {Function}      callback            Invoked when the activity has been posted (but has not been routed yet)
 * @param   {Object}        callback.err        An error that occurred, if any
 */
var postActivity = module.exports.postActivity = function(activitySeed, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'activitySeed': activitySeed}, 'Error posting activity.');
        }
    };

    var validator = new Validator();

    // validate top-level activity properties
    validator.check(null, {'code': 400, 'msg': 'No activity seed provided.'}).isObject(activitySeed);
    validator.check(activitySeed.activityType, {'code': 400, 'msg': 'Activity seed did not have an activity type.'}).notEmpty();
    validator.check(activitySeed.verb, {'code': 400, 'msg': 'Activity seed did not have a verb.'}).notEmpty();

    // validate the actor resource
    validator.check(null, {'code': 400, 'msg': 'Activity seed did not have an actor resource'}).isObject(activitySeed.actorResource);
    validator.check(activitySeed.actorResource.resourceId, {'code': 400, 'msg': 'Actor of activity seed did not have a resourceId'}).notEmpty();
    validator.check(activitySeed.actorResource.resourceType, {'code': 400, 'msg': 'Actor of activity seed did not have a resourceType'}).notEmpty();

    // validate the object resource
    if (activitySeed.objectResource) {
        validator.check(activitySeed.objectResource.resourceId, {'code': 400, 'msg': 'Object of activity seed was specified and did not have a resourceId'}).notEmpty();
        validator.check(activitySeed.objectResource.resourceType, {'code': 400, 'msg': 'Object of activity seed was specified and did not have a resourceType'}).notEmpty();
    }

    // validate the target resource
    if (activitySeed.targetResource) {
        validator.check(activitySeed.targetResource.resourceId, {'code': 400, 'msg': 'Target of activity seed was specified and did not have a resourceId'}).notEmpty();
        validator.check(activitySeed.targetResource.resourceType, {'code': 400, 'msg': 'Target of activity seed was specified and did not have a resourceType'}).notEmpty();
    }

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    MQ.submit(ActivityConstants.mq.TASK_ACTIVITY, activitySeed, callback);
};

var _getActivityStream = function(activityStreamId, start, limit, callback) {
    ActivityDAO.getActivities(activityStreamId, start, limit, function(err, activities) {
        if (err) {
            return callback(err);
        }

        // wrap the activities into an activity stream
        return callback(null, new ActivityStream(activities));
    });
};

var _handleActivityTask = function(activitySeed, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Error handling activity.');
        }
    };

    var activityStreamUpdates = {};

    // produce the activity objects
    var activityType = activitySeed.activityType;
    var published = activitySeed.published;
    var verb = activitySeed.verb;

    _produceAllEntities(activitySeed, function(err, actor, object, target) {
        if (err) {
            return callback(err);
        }

        _produceAllRoutes(activitySeed, actor, object, target, function(err, actorRoutes, objectRoutes, targetRoutes) {
            if (err) {
                return callback(err);
            }

            // 1. Create all routes and apply the "OWN" propagation entities. this is how private entities get delivered to feeds
            for (var i = 0; i < actorRoutes.length; i++) {
                var actorRoute = actorRoutes[i];
                activityStreamUpdates[actorRoute] = activityStreamUpdates[actorRoute] || {};
                if (actor[ActivityConstants.properties.OAE_PROPAGATION] === ActivityConstants.entityPropagation.OWN) {
                    activityStreamUpdates[actorRoute].actor = activityStreamUpdates[actorRoute].actor || actor;
                }
            }

            for (var i = 0; i < objectRoutes.length; i++) {
                var objectRoute = objectRoutes[i];
                activityStreamUpdates[objectRoute] = activityStreamUpdates[objectRoute] || {};
                // actor is applied to all routes, regardless. it should properly hide its information if necessary
                if (object[ActivityConstants.properties.OAE_PROPAGATION] === ActivityConstants.entityPropagation.OWN) {
                    activityStreamUpdates[objectRoute].object = activityStreamUpdates[objectRoute].object || object;
                }
            }

            for (var i = 0; i < targetRoutes.length; i++) {
                var targetRoute = targetRoutes[i];
                activityStreamUpdates[targetRoute] = activityStreamUpdates[targetRoute] || {};
                // actor is applied to all routes, regardless. it should properly hide its information if necessary
                if (target[ActivityConstants.properties.OAE_PROPAGATION] === ActivityConstants.entityPropagation.OWN) {
                    activityStreamUpdates[targetRoute].target = activityStreamUpdates[targetRoute].target || target;
                }
            }

            // 2. Back-fill all entities that are set to propagate on "all". Also apply the minimum data (i.e., the resource type and id) where necessary.
            _.values(activityStreamUpdates).forEach(function(activity) {
                activity[ActivityConstants.properties.OAE_ACTIVITY_TYPE] = activityType;
                activity.verb = verb;
                activity.published = published;

                // backfill the appropriate actor data
                if (activitySeed.actorResource) {
                    if (!activity.actor && actor[ActivityConstants.properties.OAE_PROPAGATION] === ActivityConstants.entityPropagation.ALL) {
                        activity.actor = actor;
                    } else if (!activity.actor) {
                        activity.actor = {};
                        activity.actor.objectType = activitySeed.actorResource.resourceType;
                        activity.actor[ActivityConstants.properties.OAE_ID] = activitySeed.actorResource.resourceId;
                    }
                }

                // backfill the appropriate object data
                if (activitySeed.objectResource) {
                    if (!activity.object && object[ActivityConstants.properties.OAE_PROPAGATION] === ActivityConstants.entityPropagation.ALL) {
                        activity.object = object;
                    } else if (!activity.object) {
                        activity.object = {};
                        activity.object.objectType = activitySeed.objectResource.resourceType;
                        activity.object[ActivityConstants.properties.OAE_ID] = activitySeed.objectResource.resourceId;
                    }
                }

                // backfill the appropriate target data
                if (activitySeed.targetResource) {
                    if (!activity.target && target[ActivityConstants.properties.OAE_PROPAGATION] === ActivityConstants.entityPropagation.ALL) {
                        activity.target = target;
                    } else if (!activity.target) {
                        activity.target = {};
                        activity.target.objectType = activitySeed.targetResource.targetType;
                        activity.target[ActivityConstants.properties.OAE_ID] = activitySeed.targetResource.resourceId;
                    }
                }
            });

            log().trace({
                'activitySeed': activitySeed,
                'activityStreamUpdates': activityStreamUpdates
            }, 'Applying updates to activity streams.');

            ActivityDAO.saveActivities(activityStreamUpdates);
        });
    });
};

var _produceAllEntities = function(activitySeed, callback) {
    _produceEntity(activitySeed.activityType, ActivityConstants.entityTypes.ACTOR, activitySeed.actorResource, function(err, actor) {
        if (err) {
            return callback(err);
        }

        _produceEntity(activitySeed.activityType, ActivityConstants.entityTypes.OBJECT, activitySeed.objectResource, function(err, object) {
            if (err) {
                return callback(err);
            }

            _produceEntity(activitySeed.activityType, ActivityConstants.entityTypes.TARGET, activitySeed.targetResource, function(err, target) {
                if (err) {
                    return callback(err);
                }

                return callback(null, actor, object, target);
            });
        });
    });
};

var _produceAllRoutes = function(activitySeed, actor, object, target, callback) {
    log().trace({
        'activitySeed': activitySeed,
        'actor': actor,
        'object': object,
        'target': target
    }, 'Producing routes for activity entities.');

    _produceRoutes(activitySeed.activityType, ActivityConstants.entityTypes.ACTOR, activitySeed.actorResource, actor, function(err, actorRoutes) {
        if (err) {
            return callback(err);
        }
        actorRoutes = actorRoutes || [];

        _produceRoutes(activitySeed.activityType, ActivityConstants.entityTypes.OBJECT, activitySeed.objectResource, object, function(err, objectRoutes) {
            if (err) {
                return callback(err);
            }
            objectRoutes = objectRoutes || [];

            _produceRoutes(activitySeed.activityType, ActivityConstants.entityTypes.TARGET, activitySeed.targetResource, target, function(err, targetRoutes) {
                if (err) {
                    return callback(err);
                }
                targetRoutes = targetRoutes || [];

                return callback(null, actorRoutes, objectRoutes, targetRoutes);
            });
        });
    });
};

var _produceRoutes = function(activityType, entityType, resource, activityObject, callback) {
    if (!resource || !activityObject) {
        return callback();
    }

    var router = activityRouters[resource.resourceType];
    if (!router) {
        log().trace({
            'activityType': activityType,
            'entityType': entityType,
            'resource': resource,
            'activityObject': activityObject 
        }, 'No router found for object type.');
        return callback();
    }

    router(activityType, entityType, activityObject, function(err, routes) {
        if (err) {
            return callback(err);
        }

        log().trace({
            'activityType': activityType,
            'entityType': entityType,
            'resource': resource,
            'activityObject': activityObject,
            'routes': routes
        }, 'Generated routes for activity entity.');
        
        return callback(null, routes);
    });
};

var _produceEntity = function(activityType, entityType, resource, callback) {
    if (!resource) {
        return callback();
    }

    var producer = activityProducers[resource.resourceType];
    if (!producer) {
        log().warn({
            'activityType': activityType,
            'entityType': entityType,
            'resource': resource
        }, 'No activity producer found for activity task.');
        return callback();
    }

    producer(activityType, entityType, resource, function(err, entity) {
        if (err) {
            return callback(err);
        }

        // ensure a valid propagation, resource id and resource type
        entity = entity || {};
        entity.objectType = resource.resourceType;
        entity[ActivityConstants.properties.OAE_ID] = resource.resourceId;
        entity[ActivityConstants.properties.OAE_PROPAGATION] = entity[ActivityConstants.properties.OAE_PROPAGATION] || ActivityConstants.entityPropagation.DEFAULT;

        log().trace({
            'activityType': activityType,
            'entityType': entityType,
            'resource': resource,
            'entity': entity
        }, 'Produced activity entity.');

        return callback(null, entity);
    });
};

