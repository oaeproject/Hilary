/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var Cassandra = require('oae-util/lib/cassandra');

var LoginId = require('oae-authentication/lib/model').LoginId;

/**
 * Gets the userId that is associated to the provided login ID, if any.
 *
 * @param  {LoginId}   loginId         The login id to search
 * @param  {Function}  callback        Invoked when the process completes
 * @param  {Object}    callback.err    An error that occurred, if any
 * @param  {String}    callback.userId The id of the user that was associated to the login id, if any
 */
var getUserIdFromLoginId = module.exports.getUserIdFromLoginId = function(loginId, callback) {
    getUserIdsFromLoginIds([loginId], function(err, userIds) {
        if (err) {
            return callback(err);
        } else if (userIds.length !== 1 || !userIds[0]) {
            return callback({'code': 404, 'msg': 'No user could be found with the provided login id'});
        }

        return callback(null, userIds[0]);
    });
};

/**
 * Gets the userIds that are associated to the provided login IDs, if any.
 *
 * @param  {LoginId[]}  loginIds            The login ids to search
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {String[]}   callback.userIds    The ids of the users that are associated to the login ids, if any
 */
var getUserIdsFromLoginIds = module.exports.getUserIdsFromLoginIds = function(loginIds, callback) {
    var flatLoginIds = _.map(loginIds, function(loginId) {
        return _flattenLoginId(loginId);
    });

    Cassandra.runQuery('SELECT loginId, userId FROM AuthenticationLoginId USING CONSISTENCY QUORUM WHERE loginId IN (?)', [flatLoginIds], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var userIds = [];
        _.each(rows, function(row) {
            var result = Cassandra.rowToHash(row);
            if (result && result.userId) {
                userIds[flatLoginIds.indexOf(result.loginId)] = result.userId;
            }
        });
        return callback(null, userIds);
    });
};

/**
 * Get the login ids that are mapped to a user.
 *
 * @param  {String}      userId              The id of the user
 * @param  {Function}    callback            Invoked when the prcess completes
 * @param  {Object}      callback.err        An error that occurred, fi any
 * @param  {Object}      callback.loginIds   A hash whose keys are the authentication providers, and values are the LoginId objects that are mapped to the user
 */
var getUserLoginIds = module.exports.getUserLoginIds = function(userId, callback) {
    if (!userId) {
        return callback(null, {});
    }

    Cassandra.runQuery('SELECT * FROM AuthenticationUserLoginId USING CONSISTENCY QUORUM WHERE userId = ?', [userId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var loginIds = {};
        var row = rows[0];
        for (var i = 0; i < row.count; i++) {
            var name = row[i].name;
            if (name !== 'userId') {
                var loginId = _expandLoginId(name);
                loginIds[loginId.provider] = loginId;
            }
        }

        return callback(null, loginIds);
    });
};

/**
 * Get the login ids that are mapped to users.
 *
 * @param  {String[]}    userIds             The ids of the users
 * @param  {Function}    callback            Invoked when the prcess completes
 * @param  {Object}      callback.err        An error that occurred, fi any
 * @param  {Object}      callback.loginIds   A hash whose keys are the userIds and values are secondary hashes. A secondary hash contains keys who are the authentication providers, and values are the LoginId objects that are mapped to the user
 */
var getUsersLoginIds = module.exports.getUsersLoginIds = function(userIds, callback) {
    if (_.isEmpty(userIds)) {
        return callback(null, {});
    }

    Cassandra.runQuery('SELECT * FROM AuthenticationUserLoginId USING CONSISTENCY QUORUM WHERE userId IN (?)', [userIds], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var loginIds = {};
        _.each(rows, function(row) {
            var userId = row.get('userId').value;
            loginIds[userId] = {};
            row.forEach(function(name, value) {
                if (name !== 'userId') {
                    var loginId = _expandLoginId(name);
                    loginIds[userId][loginId.provider] = loginId;
                }
            });
        });

        return callback(null, loginIds);
    });
};

/**
 * Associate the given Login ID info to the specified user. This makes it possible for the associated user to login with the provided
 * login credentials.
 *
 * @param  {LoginId}   loginId         The login id to associate
 * @param  {String}    userId          The id of the user in the database
 * @param  {Function}  callback        Invoked when the process completes
 * @param  {Object}    callback.err    An error that occurred, if any
 */
var associateLoginId = module.exports.associateLoginId = function(loginId, userId, callback) {
    loginId.properties = loginId.properties || {};
    var flattenedLoginId = _flattenLoginId(loginId);

    // sanitize and prepare the columns for the upsert
    delete loginId.properties.loginId;
    loginId.properties.userId = userId;

    var query = Cassandra.constructUpsertCQL('AuthenticationLoginId', 'loginId', flattenedLoginId, loginId.properties);
    if (query) {
        var queries = [];
        queries.push(query);
        queries.push({
            'query': 'UPDATE AuthenticationUserLoginId SET ? = ? WHERE userId = ?',
            'parameters': [flattenedLoginId, '1', userId]
        });
        return Cassandra.runBatchQuery(queries, 'QUORUM', callback);
    } else {
        log().error({
            loginId: loginId,
            userId: userId
        }, 'Error constructing query to associate login id to user.');
        return callback({'code': 500, 'msg': 'Error associating login id to user ' + userId});
    }
};

/**
 * Gets the userId and password for a give loginId
 *
 * @param  {LoginId}    loginId             The login id for which to retrieve the userId and password
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Object}     callback.result     Contains the `userId` and the `password` for the given loginId. If no user was found for the given loginId, null will be returned
 */
var checkPassword = module.exports.checkPassword = function(loginId, callback) {
    Cassandra.runQuery('SELECT userId, password FROM AuthenticationLoginId USING CONSISTENCY QUORUM WHERE loginId = ?', [_flattenLoginId(loginId)], function(err, rows) {
        if (err) {
            return callback(err);
        } else if (rows[0].count === 0) {
            // No user found for this loginId
            return callback(null, null);
        }

        // Check if the user provided password matches the stored password
        var result = Cassandra.rowToHash(rows[0]);
        return callback(null, result);
    });
};

/**
 * Stores `newPassword` for the given `loginId`
 *
 * @param  {LoginId}    loginId         The login id whose password to change
 * @param  {String}     newPassword     The password to store
 * @param  {Function}   callback        Invoked when the process completes
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var changePassword = module.exports.changePassword = function(loginId, newPassword, callback) {
    Cassandra.runQuery('UPDATE AuthenticationLoginId USING CONSISTENCY QUORUM SET password = ? WHERE loginId = ?', [newPassword, _flattenLoginId(loginId)], callback);
};


///////////////
// UTILITIES //
///////////////

/**
 * Flatten a LoginId object into a string representation that can be used for a storage key. This is in the following format:
 *
 * `<tenantAlias>:<authentication provider>:<external id>`
 *
 * @param  {LoginId}   loginId     The login id to flatten
 * @return {String}                The flattened string key representation of the login id
 * @api private
 */
var _flattenLoginId = function(loginId) {
    if (!loginId || !loginId.tenantAlias || !loginId.provider || !loginId.externalId) {
        return null;
    }
    return loginId.tenantAlias + ':' + loginId.provider + ':' + loginId.externalId;
};

/**
 * Expand a flattened key representation of a login id into a LoginId object. This is the opposite of #_flattenLoginId.
 *
 * @param  {String}    loginIdStr  The flat string key representation of the login id
 * @return {LoginId}               The LoginId object that is represented by the flat string
 * @api private
 */
var _expandLoginId = function(loginIdStr) {
    if (!loginIdStr) {
        return null;
    }

    var loginIdSplit = loginIdStr.split(':');
    if (loginIdSplit.length < 3) {
        return null;
    }

    // the externalId can contain *anything*, including colons. keep that in-tact with a slice-and-join.
    return new LoginId(loginIdSplit[0], loginIdSplit[1], loginIdSplit.slice(2).join(':'));
};