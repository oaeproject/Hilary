/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * visibilitys and limitations under the License.
 */

var _ = require('underscore');

var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var TenantsUtil = require('oae-tenants/lib/util');
var Validator = require('oae-util/lib/validator').Validator;

var ProfileSection = require('./model').ProfileSection;
var Constants = require('./model').Constants;

/**
 * Create or update a principal's profile section.
 * This method supports partial updates. It will merge the old object with the new one if `overwrite` is set to false.
 *
 * @param  {Context}         ctx                 The context
 * @param  {String}          principalId         The principal for who we need to update this section.
 * @param  {String}          sectionName         The name of the section that needs updating.
 * @param  {String}          sectionVisibility   One of "private", "loggedin" or "public"
 * @param  {Object}          sectionData         A JSON object that will be stored in the DB.
 * @param  {Boolean}         overwrite           Specifies whether the profile should be completely overwritten. (default: true)
 * @param  {Function}        callback            A callback method takes argument `err`
 * @param  {Object}          callback.err        An error object (if any)
 */
var setSection = module.exports.setSection = function(ctx, principalId, sectionName, sectionVisibility, sectionData, overwrite, callback) {
    sectionData = sectionData || {};
    callback = callback || {};
    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'A principal id must be provided'}).notEmpty();
    validator.check(sectionName, {'code': 400, 'msg': 'A section name must be provided'}).notEmpty();
    validator.check(overwrite, {'code': 400, 'msg': 'The overwrite variable must be a boolean'}).isIn([true, false]);
    validator.check(null, {'code': 400, 'msg': 'Only proper objects are accepted as section data'}).isObject(sectionData);
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to change a profile section.'}).isLoggedInUser(ctx);
    if (sectionVisibility !== undefined) {
        var visibilities = _.values(Constants.visibility);
        validator.check(sectionVisibility, {'code': 400, 'msg': 'Visibility should be one of: ' + visibilities.join(',')}).isIn(visibilities);
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Only the user owner or an admin has access.
    var principalResource = AuthzUtil.getResourceFromId(principalId);
    if (ctx.user().id === principalId || ctx.user().isAdmin(principalResource.tenantAlias)) {

        // Get the section in case we're updating.
        getSection(ctx, principalId, sectionName, function(err, oldProfileSection) {
            if (err && err.code !== 404) {
                return callback(err);
            }

            // Create a new  section or update the old one.
            var profileSection = null;
            if (err && err.code === 404) {
                // This is a new profile section.
                sectionVisibility = sectionVisibility || Constants.visibility.PUBLIC;
                profileSection = new ProfileSection(principalId, sectionName, sectionData, sectionVisibility);
            } else {
                // This is an update, merge it with the old section.
                var data = oldProfileSection.data || {};
                if (!overwrite) {
                    data = _.extend(data, sectionData);
                } else {
                    data = sectionData;
                }
                var visibility = sectionVisibility || oldProfileSection.visibility;
                profileSection = new ProfileSection(principalId, sectionName, data, visibility);
            }

            // Store the profile section.
            _setSection(principalId, profileSection, callback);
        });
    } else {
        return callback({'code': 403, 'msg': 'You\'re not allowed to change this user\'s profile'});
    }
};

/**
 * Updates a section. This function will not perform any checking on validity of
 * visibility, data, etc.. It's assumed the caller takes care of this.
 *
 * @param  {String}            principalId      The id of the principal to whom this section belongs.
 * @param  {ProfileSection}    profileSection   The profilesection that contains the (updated) data.
 * @param  {Function}          callback         Callback method.
 * @param  {Object}            callback.err     An error object (if any.)
 * @api private
 */
var _setSection = function(principalId, profileSection, callback) {
    var columnVisibilityName = profileSection.name + '#visibility';
    var columnDataName = profileSection.name + '#data';
    data = JSON.stringify(profileSection.data);
    Cassandra.runQuery("UPDATE Profiles USING CONSISTENCY QUORUM SET ?=?, ?=? WHERE principalId=?", [columnVisibilityName, profileSection.visibility, columnDataName, data, principalId], callback);
};

/**
 * Gets a section for a principal. If this principal has marked the section as private and is being retrieved by another non-admin user, an error will be passed.
 *
 * @param  {Context}                ctx             The context
 * @param  {String}                 principalId     The principalId for who we need to retrieve a section.
 * @param  {String}                 sectionName     The name of the section that needs retrieving.
 * @param  {Function}               callback        A callback method takes arguments `err` and `data`
 * @param  {Object}                 callback.err    An error object (if any)
 * @param  {ProfileSection}         callback.data   A ProfileSection object.
 */
var getSection = module.exports.getSection = function(ctx, principalId, sectionName, callback) {
    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'The anonymous user does not have any profile sections.'}).notNull();
    validator.check(sectionName, {'code': 400, 'msg': 'The sectionName was not provided.'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var columnVisibilityName = sectionName + '#visibility';
    var columnDataName = sectionName + '#data';
    Cassandra.runQuery("SELECT ?, ? FROM Profiles USING CONSISTENCY QUORUM WHERE principalId = ?", [columnVisibilityName, columnDataName, principalId], function(err, rows) {
        if (err) {
            return callback(err);
        } else if (rows[0].count <= 1) {
            return callback({'code': 404, 'msg': 'Section not found'});
        }

        var visibility = rows[0].get(columnVisibilityName).value;
        
        // Only actually parse the data when we're sure that the current user can access it.
        var profileSection = new ProfileSection(principalId, sectionName, {}, visibility);
        if (!_hasAccess(ctx, profileSection)) {
            return callback({'code': 403, 'msg': 'You don\' t have access to this profile section'});
        }

        try {
            var data = rows[0].get(columnDataName).value;
            profileSection.data = JSON.parse(data);
        } catch (err) {
            return callback({'code': 500, 'msg': 'Couldn\'t parse the data for section "' + profileSection.name + '".'});
        }

        callback(null, profileSection);
    });
};

/**
 * Gets all the profile sections for a principal.
 *
 * @param  {Context}                ctx             The current user's context
 * @param  {String}                 principalId     The id of the principal for whom the profile should be retrieved.
 * @param  {Function}               callback        A callback method takes arguments `err` and `data`
 * @param  {Object}                 callback.err    An error object (if any)
 * @param  {Object}                 callback.data   Object where keys are section ids and values are sections the user has access to.
 */
var getAllSections = module.exports.getAllSections = function(ctx, principalId, callback) {
    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'The anonymous user does not have any profile sections.'}).notNull();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    
    Cassandra.runQuery("SELECT * FROM Profiles USING CONSISTENCY QUORUM WHERE principalId = ?", [principalId], function(err, rows) {
        if (err) {
            return callback(err);
        } else if (rows[0].count <= 1) {
            return callback(null, []);
        }

        var retrievedSections = 0;
        var allSections = [];
        var checkAccess = function(profileSection, sectionData) {
            retrievedSections++;
            if (_hasAccess(ctx, profileSection)) {
                try {
                    profileSection.data = JSON.parse(sectionData);
                } catch (err) {
                    return callback({'code': 500, 'msg': 'Couldn\'t parse the data for section "' + profileSection.name + '".'});
                }
                allSections.push(profileSection);
            }

            if (retrievedSections === Math.floor(rows[0].count / 2)) {
                callback(null, allSections);
            }
        };

        rows[0].forEach(function(name, value, ts, ttl) {
            if (name === 'principalId') {
                return;
            }
            var parts = name.split('#');
            if (parts[1] === 'data') {
                var sectionName = parts[0];
                var visibility = rows[0].get(sectionName + '#visibility').value;
                var profileSection = new ProfileSection(principalId, sectionName, {}, visibility);
                checkAccess(profileSection, value);
            }
        });
    });
};

/**
 * Checks if the current user has access to this profile section.
 *
 * @param   {Context}                   ctx                 Current user's context
 * @param   {User}                      user                The user to which the profile belongs
 * @param   {ProfileSection}            profileSection      The section that needs to be checked.
 * @return  {Boolean}                                       Whether or not the current user can see this profile section.
 * @api private
 */
var _hasAccess = function(ctx, profileSection) {
    var profileTenantAlias = AuthzUtil.getResourceFromId(profileSection.principalId).tenantAlias;
    if (profileSection.visibility === Constants.visibility.PUBLIC) {
        // public profile sections can always be seen
        return true;
    } else if (profileSection.visibility === Constants.visibility.LOGGEDIN && TenantsUtil.isLoggedIn(ctx, profileTenantAlias)) {
        // if the section is restricted to logged in users, ensure the current user is authenticated and belongs to the profile's tenant
        return true;
    } else if (ctx.user() && (ctx.user().id === profileSection.principalId || ctx.user().isAdmin(profileTenantAlias))) {
        // the profile is private, only the user and admins can see it
        return true;
    }

    // if we get here, the section is not accessible
    return false;
};
