/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');

var Tenant = require('oae-tenants/lib/model').Tenant;
var AuthzAPI = require('oae-authz');
var Context = require('oae-context').Context;
var RestAPI = require('oae-tests/rest');
var User = require('oae-principals/lib/model').User;
var LoginId = require('oae-principals/lib/model').LoginId;

var PrincipalsAPI = require('oae-principals');


describe('Principals', function() {

    var loginId = function(externalId) {
        return new LoginId('local', externalId);
    }

    describe('Groups', function() {

        var r = null;
        var tenant = null;
        var anonymousContext = null;

        beforeEach(function(callback) {
            r = Math.floor(Math.random()*100000);
            tenant = new Tenant('cam' + r, 'Cambridge', 3000);
            anonymousContext = new Context(tenant, null);
            callback();
         });

        /**
         * Utility function that will create a number of groups and users that will be used inside of the test.
         * @param  {Context}        ctx                 Standard context object, representing the currently logged user and its tenant
         * @param  {Function(r)}    callback            Standard callback function executed when all checks have finished
         * @param  {Integer}        callback.r          Random number that is appended to user and groupids to ensure unique users and 
         *                                              groups for the test
         * @param  {Object}         callback.loginIds   An object keyed by user loginId that specifies the internal id of the users
         *                                              created
         */
        var createPrincipals = function(ctx, callback) {
            var r = Math.floor(Math.random()*100000);
            var principals = 0;
            var loginIds = {};

            var createPrincipalDone = function(err, principalId, loginId) {
                if (err) {
                    assert.fail("ERROR: " + err.code + ", msg: " + err.msg);
                    return callback();
                }

                if (loginId) {
                    loginIds[loginId] = principalId;
                }

                principals++;
                if (principals === 12) {
                    callback(r, loginIds);
                }
            };

            var tenantAlias = ctx.tenant().alias;

            PrincipalsAPI.createGroup(ctx, 'oae-team-' + r, 'OAE Team', 'The OAE team', 'public', 'yes', [], {}, createPrincipalDone);
            PrincipalsAPI.createGroup(ctx, 'backend-team-' + r, 'Backend Team', 'The Backend team', 'public', 'yes', [], {}, createPrincipalDone);
            PrincipalsAPI.createGroup(ctx, 'ui-team-' + r, 'UI Team', 'The UI team', 'public', 'yes', [], {}, createPrincipalDone);
            PrincipalsAPI.createGroup(ctx, 'canadian-' + r, 'Canadian Team', 'The Canadian team', 'public', 'yes', [], {}, createPrincipalDone);
            PrincipalsAPI.createGroup(ctx, 'not-canadian-' + r, 'Not Canadian Team', 'The not Canadian team', 'public', 'yes', [], {}, createPrincipalDone);
            PrincipalsAPI.createGroup(ctx, 'belgian-' + r, 'Belgian Team', 'The Belgian team', 'public', 'yes', [], {}, createPrincipalDone);
            PrincipalsAPI.createGroup(ctx, 'west-flemish-' + r, 'West Flemish Team', 'The West Flemish team', 'public', 'yes', [], {}, createPrincipalDone);
            PrincipalsAPI.createGroup(ctx, 'east-flemish-' + r, 'East Flemish Team', 'The East Flemish team', 'public', 'yes', [], {}, createPrincipalDone);

            PrincipalsAPI.createUser(ctx, loginId('bert-' + r), 'password', 'bp323', {}, function(err, userId) {
                createPrincipalDone(err, userId, 'bert-' + r);
            });

            PrincipalsAPI.createUser(ctx, loginId('branden-' + r), 'password', 'mrvisser', {}, function(err, userId) {
                createPrincipalDone(err, userId, 'branden-' + r);
            });

            PrincipalsAPI.createUser(ctx, loginId('nicolaas-' + r), 'password', 'nicolaas', {}, function(err, userId) {
                createPrincipalDone(err, userId, 'nicolaas-' + r);
            });

            PrincipalsAPI.createUser(ctx, loginId('simon-' + r), 'password', 'simong', {}, function(err, userId) {
                createPrincipalDone(err, userId, 'simon-' + r);
            });

        };

        /**
         * Get a full group uuid.
         * @param  {Context}    ctx         The execution context that holds a tenant.
         * @param  {String}     groupId     The id of the group
         * @return {String}                 The full group uuid. ex: g:cam:oae-team
         */
        var getGroupUuid = function(ctx, groupId) {
            return 'g:' + ctx.tenant().alias + ':' + groupId;
        };

        /**
         * Utility function that will be used to create a 4-level deep group structure that will be used
         * inside of the tests
         * @param  {Context}        ctx                 Standard context object, representing the currently logged user and its tenant
         * @param  {Function(id)}   callback            Standard callback function executed when all checks have finished
         * @param  {Integer}        callback.id         Random number that is appended to user and groupids to ensure unique users and 
         *                                              groups for the test
         * @param  {Object}         callback.loginIds   An object mapping the loginIds of users created to their internal user ids
         */
        var createOAEStructure = function(ctx, callback) {
            createPrincipals(ctx, function(id, loginIds) {
                var checks = 0;
                var principalsAdded = function(err) {
                    if (err) {
                        assert.fail("ERROR: " + err.code + ", msg: " + err.msg);
                        return callback();
                    }
                    checks++;
                    if (checks === 8) {
                        callback(id, loginIds);
                    }
                };

                var toObj = function(ctx, id, isGroup, role) {
                    if (isGroup) {
                        id = getGroupUuid(ctx, id);
                    } else {
                        id = loginIds[id];
                    }
                    var obj = {};
                    obj[id] = role
                    return obj;
                };

                PrincipalsAPI.setGroupMembers(ctx, getGroupUuid(ctx, 'canadian-' + id), toObj(ctx, 'branden-' + id, false, 'member'), principalsAdded);
                PrincipalsAPI.setGroupMembers(ctx, getGroupUuid(ctx, 'not-canadian-' + id), toObj(ctx, 'simon-' + id, false, 'member'), principalsAdded);
                var belgianMembers = {};
                belgianMembers[getGroupUuid(ctx, 'west-flemish-' + id)] = 'member';
                belgianMembers[getGroupUuid(ctx, 'east-flemish-' + id)] = 'member';
                PrincipalsAPI.setGroupMembers(ctx, getGroupUuid(ctx, 'belgian-' + id), belgianMembers, principalsAdded);
                PrincipalsAPI.setGroupMembers(ctx, getGroupUuid(ctx, 'west-flemish-' + id), toObj(ctx, 'bert-' + id, false, 'member'), principalsAdded);
                PrincipalsAPI.setGroupMembers(ctx, getGroupUuid(ctx, 'east-flemish-' + id), toObj(ctx, 'nicolaas-' + id, false, 'member'), principalsAdded);
                var oaeMembers = {};
                oaeMembers[getGroupUuid(ctx, 'backend-team-' + id)] = 'member';
                oaeMembers[getGroupUuid(ctx, 'ui-team-' + id)] = 'member';
                PrincipalsAPI.setGroupMembers(ctx, getGroupUuid(ctx, 'oae-team-' + id), oaeMembers, principalsAdded);
                var backendMembers = {};
                backendMembers[getGroupUuid(ctx, 'canadian-' + id)] = 'member';
                backendMembers[getGroupUuid(ctx, 'not-canadian-' + id)] = 'member';
                PrincipalsAPI.setGroupMembers(ctx, getGroupUuid(ctx, 'backend-team-' + id), backendMembers, principalsAdded);
                PrincipalsAPI.setGroupMembers(ctx, getGroupUuid(ctx, 'ui-team-' + id), toObj(ctx, 'belgian-' + id, true, 'member'), principalsAdded);
            });
        };

        /**
         * Utility function that will create a new user and will fetch it straight away to check successful creation
         * @param  {Context}               ctx             Standard context object, representing the currently logged user and its tenant
         * @param  {String}                username        The created user's username
         * @param  {String}                password        The created user's password
         * @param  {String}                visibility      The created user's account visibility. This can be public, loggedin or private
         * @param  {String}                firstName       The created user's first name
         * @param  {String}                lastName        The created user's last name
         * @param  {String}                displayName     The created user's last display name
         * @param  {Function(err, user)}   callback        Standard callback function executed when all checks have finished
         * @param  {Object}                callback.err    Error object containing error message
         * @param  {User}                  callback.user   User object representing the created user
         */
        var createAndGetUser = function(ctx, username, password, visibility, displayName, callback) {
            PrincipalsAPI.createUser(ctx, loginId(username), password, displayName, { visibility: visibility }, function(err, id) {
                assert.ok(!err);
                PrincipalsAPI.getUser(ctx, id, callback);
            });
        };

        /**
         * Utility function that will make sure that a particular group has the expected
         * set of group members
         *  @param  {String}           groupId          Group id for the group we want to check the members for
         *  @param  {Array<String>}    expectedMembers  Array of user and group ids representing the expected members
         *  @param  {Function}         callback         Standard callback function
         */
        assertGroupMembers = function(ctx, groupId, expectedMembers, callback) {
            PrincipalsAPI.getGroupMembers(ctx, groupId, null, 1000, function(err, members) {
                assert.equal(members.length, expectedMembers.length, "Expected group '" + groupId + "' to have '" + expectedMembers.length + "' members.");
                var memberHash = _.groupBy(members, function(principal) { return principal.profile.id; });
                for (var i = 0; i < expectedMembers.length; i++) {
                    assert.equal(memberHash[expectedMembers[i]].length, 1, "Group '" + groupId + "' does not contain: " + expectedMembers[i]);
                }
                callback();
            });
        };

        /**
         * Utility function that will make sure that a principal is a member of the expected
         * set of groups
         *  @param  {Context}          ctx              Standard context object, representing the currently logged user and its tenant
         *  @param  {Array<String>}    expectedGroups   Array of group ids representing the expected memberships
         *  @param  {Function}         callback         Standard callback function
         */
        assertMemberOf = function(ctx, expectedGroups, callback) {
            PrincipalsAPI.memberOf(ctx, ctx.user().id, 0, 1000, function(err, groups) {
                assert.ok(!err);
                assert.equal(_.keys(groups).length, expectedGroups.length, "Expected principal '" + ctx.user().id + "' to have '" + expectedGroups.length + "' memberships.");
                var groupsHash = _.groupBy(groups, function(group) { return group.id; });
                for (var i = 0; i < expectedGroups.length; i++) {
                    assert.equal(groupsHash[expectedGroups[i]].length, 1, "Principal '" + ctx.user().id + "' does not contain: " + expectedGroups[i]);
                }
                callback();
            });
        };

        /**
         * Small wrapper so we're able to set group members on a single line.
         * @param  {String} id   Principal ID
         * @param  {String} role The role for the principal (manager, member or false)
         */
        var toRoleObj = function(id, role) {
            var roleObj = {};
            roleObj[id] = role;
            return roleObj;
        };

        /**
         * Test that will create a simple group structure and will validate
         * memberships
         */
        it('Test simple group structure', function(callback) {
            createAndGetUser(anonymousContext, 'test-runner' + r, 'password', 'public', 'tr123', function(err, user) {
                var ctx = new Context(tenant, user);
                createOAEStructure(ctx, function(id, loginIds) {
                    var asUser = ctx.user().id;

                    // Create the oae-team tree in a way that is NOT topdown or bottomup.
                    var memberships = 0;
                    var checks = 0;
                    var done = function() {
                        checks++;
                        if (checks === 11) {
                            callback();
                        }
                    };

                    var bertCtx = new Context(tenant, new User('cam', loginIds['bert-' + id]));
                    var nicoCtx = new Context(tenant, new User('cam', loginIds['nicolaas-' + id]));
                    var brandenCtx = new Context(tenant, new User('cam', loginIds['branden-' + id]));
                    var simonCtx = new Context(tenant, new User('cam', loginIds['simon-' + id]));

                    // The group members should only return the direct children.
                    assertGroupMembers(ctx, getGroupUuid(ctx, 'oae-team-' + id), [asUser, getGroupUuid(ctx, 'backend-team-' + id), getGroupUuid(ctx, 'ui-team-' + id)], done);
                    assertGroupMembers(ctx, getGroupUuid(ctx, 'backend-team-' + id), [asUser, getGroupUuid(ctx, 'canadian-' + id), getGroupUuid(ctx, 'not-canadian-' + id)], done);
                    assertGroupMembers(ctx, getGroupUuid(ctx, 'canadian-' + id), [asUser, loginIds['branden-' + id]], done);
                    assertGroupMembers(ctx, getGroupUuid(ctx, 'not-canadian-' + id), [asUser, loginIds['simon-' + id]], done);
                    assertGroupMembers(ctx, getGroupUuid(ctx, 'belgian-' + id), [asUser, getGroupUuid(ctx, 'west-flemish-' + id), getGroupUuid(ctx, 'east-flemish-' + id)], done);
                    assertGroupMembers(ctx, getGroupUuid(ctx, 'west-flemish-' + id), [asUser, loginIds['bert-' + id]], done);
                    assertGroupMembers(ctx, getGroupUuid(ctx, 'east-flemish-' + id), [asUser, loginIds['nicolaas-' + id]], done);

                    // ALL groups should be listed against a principal.
                    assertMemberOf(bertCtx, [getGroupUuid(ctx, 'oae-team-' + id), getGroupUuid(ctx, 'ui-team-' + id), getGroupUuid(ctx, 'belgian-' + id), getGroupUuid(ctx, 'west-flemish-' + id)], done);
                    assertMemberOf(nicoCtx, [getGroupUuid(ctx, 'oae-team-' + id), getGroupUuid(ctx, 'ui-team-' + id), getGroupUuid(ctx, 'belgian-' + id), getGroupUuid(ctx, 'east-flemish-' + id)], done);
                    assertMemberOf(brandenCtx, [getGroupUuid(ctx, 'oae-team-' + id), getGroupUuid(ctx, 'backend-team-' + id), getGroupUuid(ctx, 'canadian-' + id)], done);
                    assertMemberOf(simonCtx, [getGroupUuid(ctx, 'oae-team-' + id), getGroupUuid(ctx, 'backend-team-' + id), getGroupUuid(ctx, 'not-canadian-' + id)], done);
                    assertMemberOf(ctx, [getGroupUuid(ctx, 'oae-team-' + id), getGroupUuid(ctx, 'ui-team-' + id), getGroupUuid(ctx, 'backend-team-' + id), getGroupUuid(ctx, 'belgian-' + id),
                        getGroupUuid(ctx, 'west-flemish-' + id), getGroupUuid(ctx, 'east-flemish-' + id), getGroupUuid(ctx, 'not-canadian-' + id), getGroupUuid(ctx, 'not-canadian-' + id)], done);
                });

            });
        });

        /**
         * Test that a non-existing group identifier returns a 400
         */
        it('Test non-existing group', function(callback) {
            var ctx = new Context(tenant, null);
            PrincipalsAPI.getGroup(ctx, "non-existing-group", function(err, group) {
                assert.equal(err.code, 400);
                callback();
            });
        });

        /**
         * Test that a group can be created
         */
        it('Test create group', function(callback) {
            createAndGetUser(anonymousContext, 'test-runner', 'password', 'public', 'tr123', function(err, user) {
                var ctx = new Context(tenant, user);
                PrincipalsAPI.createGroup(ctx, "test-group-" + r, "A test group", "This is a test group", 'public', 'yes', [], {}, function(err, group) {
                    if (err) {
                        assert.fail("Should be able to create a simple group.");
                    }

                    // Should be created.
                    assert.equal(group, getGroupUuid(ctx, 'test-group-' + r));

                    // Create the same one again, should fail.
                    PrincipalsAPI.createGroup(ctx, "test-group-" + r, "A test group", "This is a test group", 'public', 'yes', [], {}, function(err, group) {
                        assert.equal(err.code, 400, "Creating a group with the same name as an existing group should fail!");
                        callback();
                    });
                });
            });
        });

        /**
         * Test to verify that members can be added in a secure way
         */
        it('Test add members', function(callback) {
            // 1. create the users
            createAndGetUser(anonymousContext, 'mrvisser', 'password', 'public', 'tr123', function(err, mrvisser) {
                assert.ok(!err);

                var mrvisserCtx = new Context(tenant, mrvisser);
                createAndGetUser(anonymousContext, 'nicolaas', 'password', 'public', 'nicolaas', function(err, nico) {
                    assert.ok(!err);

                    var nicoCtx = new Context(tenant, nico);
                    createAndGetUser(anonymousContext, 'simong', 'password', 'public', 'simong', function(err, simong) {
                        assert.ok(!err);

                        var simongCtx = new Context(tenant, simong);
                        PrincipalsAPI.createGroup(mrvisserCtx, 'managed-by-canadians', "Managed by Canadians", "Group", 'public', 'yes', [], {}, function(err, groupUuid) {
                            assert.ok(!err);
                
                            // 2. try and add simong to it with an unprivileged user
                            PrincipalsAPI.setGroupMembers(simongCtx, groupUuid, toRoleObj(simong.id, 'member'), function(err) {
                                assert.ok(err);
                                assert.equal(err.code, 401);
                
                                // verify simong was not added
                                PrincipalsAPI.memberOf(nicoCtx, nicoCtx.user().id, null, null, function(err, groups) {
                                    assert.ok(!err);
                                    assert.equal(_.keys(groups).length, 0);
                
                                    // 3. add nico as member, then ensure he still cannot add
                                    PrincipalsAPI.setGroupMembers(mrvisserCtx, groupUuid, toRoleObj(nico.id, 'member'), function(err) {
                                        assert.ok(!err);
                
                                        PrincipalsAPI.setGroupMembers(nicoCtx, groupUuid, toRoleObj(simong.id, 'member'), function(err) {
                                            assert.ok(err);
                                            assert.ok(err.code, 401);
                
                                            PrincipalsAPI.memberOf(simongCtx, simongCtx.user().id, null, null, function(err, groups) {
                                                assert.ok(!err);
                                                assert.equal(_.keys(groups).length, 0);
                
                                                // 4. add Nico as manager, ensure he can now add
                                                PrincipalsAPI.setGroupMembers(mrvisserCtx, groupUuid, toRoleObj(nico.id, 'manager'), function(err) {
                                                    assert.ok(!err);
                
                                                    PrincipalsAPI.setGroupMembers(nicoCtx, groupUuid, toRoleObj(simong.id, 'member'), function(err) {
                                                        assert.ok(!err);
                
                                                        PrincipalsAPI.memberOf(simongCtx, simongCtx.user().id, null, null, function(err, groups) {
                                                            assert.ok(!err);
                                                            assert.equal(_.keys(groups).length, 1);
                                                            callback();
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });

            });
        });

        /**
         * Test to verify that it should not be possible to add members as an unprivileged user
         */
        it('Test add members no access', function(callback) {
            // 1. create the users
            createAndGetUser(anonymousContext, 'mrvisser', 'password', 'public', 'tr123', function(err, mrvisser) {
                assert.ok(!err);

                var mrvisserCtx = new Context(tenant, mrvisser);
                createAndGetUser(anonymousContext, 'nicolaas', 'password', 'public', 'nicolaas', function(err, nico) {
                    assert.ok(!err);

                    var nicoCtx = new Context(tenant, nico);
                    createAndGetUser(anonymousContext, 'simong', 'password', 'public', 'simong', function(err, simong) {
                        assert.ok(!err);

                        var simongCtx = new Context(tenant, simong);
                        PrincipalsAPI.createGroup(mrvisserCtx, 'managed-by-canadians', "Managed by Canadians", "Group", 'public', 'yes', [], {}, function(err, groupUuid) {
                            assert.ok(!err);

                            // 2. try and add simong to it with an unprivileged user
                            PrincipalsAPI.setGroupMembers(nicoCtx, groupUuid, toRoleObj(simong.id, 'member'), function(err) {
                                assert.ok(err);
                                assert.equal(err.code, 401);

                                // verify simong was not added
                                PrincipalsAPI.memberOf(simongCtx, simongCtx.user().id, null, null, function(err, groups) {
                                    assert.ok(!err);
                                    assert.equal(_.keys(groups).length, 0);

                                    // 3. add nico as member, then ensure he still cannot add
                                    PrincipalsAPI.setGroupMembers(mrvisserCtx, groupUuid, toRoleObj(nico.id, 'member'), function(err) {
                                        assert.ok(!err);

                                        PrincipalsAPI.setGroupMembers(nicoCtx, groupUuid, toRoleObj(simong.id, 'member'), function(err) {
                                            assert.ok(err);
                                            assert.ok(err.code, 401);

                                            PrincipalsAPI.memberOf(simongCtx, simongCtx.user().id, null, null, function(err, groups) {
                                                assert.ok(!err);
                                                assert.equal(_.keys(groups).length, 0);

                                                // 4. add Nico as manager, ensure he can now add
                                                PrincipalsAPI.setGroupMembers(mrvisserCtx, groupUuid, toRoleObj(nico.id, 'manager'), function(err) {
                                                    assert.ok(!err);

                                                    PrincipalsAPI.setGroupMembers(nicoCtx, groupUuid, toRoleObj(simong.id, 'member'), function(err) {
                                                        assert.ok(!err);

                                                        PrincipalsAPI.memberOf(simongCtx, simongCtx.user().id, null, null, function(err, groups) {
                                                            assert.ok(!err);
                                                            assert.equal(_.keys(groups).length, 1);
                                                            callback();
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test to verify that it should be possible to add members by an indirect user
         */
        it('Test add members indirect access', function(callback) {
            // 1. create the users
            createAndGetUser(anonymousContext, 'mrvisser', 'password', 'public', 'tr123', function(err, mrvisser) {
                assert.ok(!err);

                var mrvisserCtx = new Context(tenant, mrvisser);
                createAndGetUser(anonymousContext, 'nicolaas', 'password', 'public', 'nicolaas', function(err, nico) {
                    assert.ok(!err);

                    var nicoCtx = new Context(tenant, nico);
                    createAndGetUser(anonymousContext, 'simong', 'password', 'public', 'simong', function(err, simong) {
                        assert.ok(!err);

                        var simongCtx = new Context(tenant, simong);
                        PrincipalsAPI.createGroup(mrvisserCtx, 'managed-by-canadians', "Managed by Canadians", "Group", 'public', 'yes', [], {}, function(err, managedByCanadiansGroupUuid) {
                            assert.ok(!err);

                            // 2. Create and assign a group that will manage the managed-by-canadians group
                            PrincipalsAPI.createGroup(mrvisserCtx, 'canadians', "Canadians", "Group", 'public', 'yes', [], {}, function(err, canadiansGroupUuid) {
                                assert.ok(!err);

                                PrincipalsAPI.setGroupMembers(mrvisserCtx, managedByCanadiansGroupUuid, toRoleObj(canadiansGroupUuid, 'manager'), function(err) {
                                    assert.ok(!err);

                                    // 3. make nico a member of the 'canadians' group, then verify he can manage managed-by-canadians
                                    PrincipalsAPI.setGroupMembers(mrvisserCtx, canadiansGroupUuid, toRoleObj(nico.id, 'member'), function(err) {
                                        assert.ok(!err);

                                        // quick sanity check on the permission itself
                                        
                                        AuthzAPI.isAllowed(nico.id, 'manager', managedByCanadiansGroupUuid, function(err, isAllowed) {
                                            assert.ok(!err);
                                            assert.ok(isAllowed === true);

                                            // verify he can add someone
                                            PrincipalsAPI.setGroupMembers(nicoCtx, managedByCanadiansGroupUuid, toRoleObj(simong.id, 'member'), function(err) {
                                                assert.ok(!err);

                                                // verify it worked
                                                PrincipalsAPI.memberOf(simongCtx, simongCtx.user().id, null, null, function(err, groups) {
                                                    assert.ok(!err);
                                                    assert.ok(_.keys(groups).length, 1);
                                                    callback();
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
        
        /**
         * mrvisser will create a group and change the group's visibility.
         * simong will try to get the group and it's members each time
         * He should be able to retrieve the group info each time, but the members should
         * only be accessible when the group is not private.
         */
        it('Test group visibility', function(callback) {
            var assertGroupVisibility = function(ctx, groupId, expectedErrorCode, expectedMemberLength, callback) {
                PrincipalsAPI.getGroup(ctx, groupId, function(err, group) {
                    assert.ok(!err);

                    PrincipalsAPI.getGroupMembers(ctx, groupId, null, null, function(err, members) {
                        if (expectedErrorCode) {
                            assert.equal(err.code, expectedErrorCode)
                        } else {
                            assert.ok(!err);
                            assert.equal(members.length, expectedMemberLength);
                        }
                        callback();
                    });
                });
            };

            // 1. create the users
            createAndGetUser(anonymousContext, 'mrvisser', 'password', 'public', 'tr123', function(err, mrvisser) {
                assert.ok(!err);
                var mrvisserCtx = new Context(tenant, mrvisser);

                createAndGetUser(anonymousContext, 'simong', 'password', 'public', 'simong', function(err, simong) {
                    assert.ok(!err);
                    var simongCtx = new Context(tenant, simong);

                    // 2. Create a group and make it private.
                    PrincipalsAPI.createGroup(mrvisserCtx, 'canadians', "Canadians", "Group", 'public', 'yes', [], {}, function(err, canadiansGroupUuid) {
                        assert.ok(!err);

                        // simong and anonymous should still be able to retrieve it at this point.
                        assertGroupVisibility(mrvisserCtx, canadiansGroupUuid, null, 1, function() {
                            assertGroupVisibility(simongCtx, canadiansGroupUuid, null, 1, function() {
                                assertGroupVisibility(anonymousContext, canadiansGroupUuid, null, 1, function() {

                                    // Now only mrvisser can see the members
                                    PrincipalsAPI.updateGroup(mrvisserCtx, canadiansGroupUuid, {'visibility': 'private'}, function(err) {
                                        assert.ok(!err);
                                        assertGroupVisibility(mrvisserCtx, canadiansGroupUuid, null, 1, function() {
                                            assertGroupVisibility(simongCtx, canadiansGroupUuid, 401, null, function() {
                                                assertGroupVisibility(anonymousContext, canadiansGroupUuid, 401, null, function() {

                                                    // Now only simong & mrvisser should be able to see the members.
                                                    PrincipalsAPI.updateGroup(mrvisserCtx, canadiansGroupUuid, {'visibility': 'loggedin'}, function(err) {
                                                        assert.ok(!err);
                                                        assertGroupVisibility(mrvisserCtx, canadiansGroupUuid, null, 1, function() {
                                                            assertGroupVisibility(simongCtx, canadiansGroupUuid, null, 1, function() {
                                                                assertGroupVisibility(anonymousContext, canadiansGroupUuid, 401, null, function() {
                                                                    callback();
                                                                });
                                                            });
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        it('Test memberOf only returns user context groups', function(callback) {
            // 1. create the users
            createAndGetUser(anonymousContext, 'mrvisser', 'password', 'public', 'tr123', function(err, mrvisser) {
                assert.ok(!err);
                var mrvisserCtx = new Context(tenant, mrvisser);

                createAndGetUser(anonymousContext, 'simong', 'password', 'public', 'simong', function(err, simong) {
                    assert.ok(!err);
                    var simongCtx = new Context(tenant, simong);

                    // 2. Create a group
                    PrincipalsAPI.createGroup(mrvisserCtx, 'canadians', "Canadians", "Group", 'private', 'yes', [], {}, function(err, canadiansGroupUuid) {
                        assert.ok(!err);

                        // mrvisser should have 1 group in his memberof list.
                        PrincipalsAPI.memberOf(mrvisserCtx, mrvisserCtx.user().id, null, null, function(err, groups) {
                            assert.ok(!err);
                            assert.equal(_.keys(groups).length, 1);
                            assert.equal(_.values(groups)[0].name, 'Canadians');

                            // simong should have 0 group in his memberof list.
                            PrincipalsAPI.memberOf(simongCtx, simongCtx.user().id, null, null, function(err, groups) {
                                assert.ok(!err);
                                assert.equal(_.keys(groups).length, 0);
                                callback();
                            });
                        });
                    });
                });
            });
        });

        it('Test if getGroupMembers respects visibility', function(callback) {
            // 1. create the users
            createAndGetUser(anonymousContext, 'mrvisser', 'password', 'public', 'tr123', function(err, mrvisser) {
                assert.ok(!err);
                var mrvisserCtx = new Context(tenant, mrvisser);

                createAndGetUser(anonymousContext, 'simong', 'password', 'public', 'simong', function(err, simong) {
                    assert.ok(!err);
                    var simongCtx = new Context(tenant, simong);

                    // 2. Create a group
                    PrincipalsAPI.createGroup(mrvisserCtx, 'canadians', "Canadians", "Group", 'private', 'yes', [], {}, function(err, canadiansGroupUuid) {
                        assert.ok(!err);

                        // if simong tries to get the members it should fail.
                        PrincipalsAPI.getGroupMembers(simongCtx, canadiansGroupUuid, null, null, function(err, members) {
                            assert.equal(401, err.code);
                            assert.ok(!members);
                            callback();
                        });
                    });
                });
            });
        });

        it('Test that a group cannot be made a member of itself', function(callback) {
            createAndGetUser(anonymousContext, 'nico', 'password', 'private', 'nico', function(err, nico) {
                assert.ok(!err);
                var nicoCtx = new Context(tenant, nico);

                PrincipalsAPI.createGroup(nicoCtx, "public-group", "Public group", "This is a test group", 'public', 'yes', [], {}, function(err, publicGroup) {
                    assert.ok(!err);

                    PrincipalsAPI.setGroupMembers(nicoCtx, publicGroup, toRoleObj(publicGroup.id, 'member'), function(err) {
                        assert.equal(err.code, 400);
                        callback();
                    });
                });
            });
        });

        it('Test that non-existing principals cannot be added to a group', function(callback) {
            createAndGetUser(anonymousContext, 'nico', 'password', 'private', 'nico', function(err, nico) {
                assert.ok(!err);
                var nicoCtx = new Context(tenant, nico);
                createAndGetUser(anonymousContext, 'mrvsser', 'password', 'private', 'mrvisser', function(err, branden) {
                    assert.ok(!err);
                    var brandenCtx = new Context(tenant, branden);

                    PrincipalsAPI.createGroup(nicoCtx, "public-group", "Public Group", "This is a test group", 'public', 'yes', [], {}, function(err, publicGroup) {
                        assert.ok(!err);

                        var members = {'u:camtest:non-existing': 'member'};
                        members[branden.id] = 'member';
                        PrincipalsAPI.setGroupMembers(nicoCtx, publicGroup, members, function(err) {
                            assert.equal(err.code, 400);

                            // Assert that those principals were not added.
                            PrincipalsAPI.getGroupMembers(nicoCtx, publicGroup, null, null, function(err, members) {
                                assert.ok(!err);
                                assert.equal(members.length, 1);
                                callback();
                            });
                        });
                    });
                });
            });
        });

        it('Test that anonymous users cannot update a group', function(callback) {
            createAndGetUser(anonymousContext, 'nico', 'password', 'private', 'nico', function(err, nico) {
                assert.ok(!err);
                var nicoCtx = new Context(tenant, nico);

                PrincipalsAPI.createGroup(nicoCtx, "public-group", "Public Group", "This is a test group", 'public', 'yes', [], {}, function(err, publicGroup) {
                    assert.ok(!err);

                    PrincipalsAPI.updateGroup(anonymousContext, publicGroup, {'visibility': 'private'}, function(err) {
                        assert.equal(401, err.code);
                        callback();
                    });
                });
            });
        });
    });
});
