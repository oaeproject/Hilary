/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var fs = require('fs');
var watch = require('watch');

var log = require('oae-logger').logger('static-files');
var Validator = require('oae-util/lib/validator').Validator



var uiDirectory = null;

// A dictionary that will hold the data for each file.
var fileCache = {};

// A filter for the files we want to cache.
var filter = /(.*\.css$)|(.*\.js$)|(.*\.json$)|(.*\.html$)|(.*\.htm$)|(.*\.properties$)/;

// A dictionary that maps a widget name on its config file.
var widgetConfigs = {};

// A filter that allows us to determine if a file is a widget config.
var widgetConfigFilter = /^\/devwidgets\/(.*?)\/config.json$/;


/**
 * Will walk the entire ui directory and cache all the relevant files.
 * It will also place watches on the necessary files so if anything changes
 * the backend will know about it. (This is mostly a developer convenience.)
 * @param  {String} uiDir The absolute path to the UI directory.
 */
var init = module.exports.init = function(uiDir) {
    // Remember the ui directory
    uiDirectory = uiDir;

    // Walk the subtree and cache those files that might get requested in a batch request.
    walk(uiDirectory, filter, function(err, path) {
        if (err) {
            return log().error(err);
        }

        cacheFile(path, true);
    });


    // Monitor the entire subtree for changes.
    watch.createMonitor(uiDirectory, {'ignoreDotFiles': true}, function(monitor) {

        monitor.on('created', function(file, stat) {
            if (filter.test(file)) {
                cacheFile(file);
            }
        });

        monitor.on('changed', function(file, currStat, prevStat) {
            if (filter.test(file)) {
                cacheFile(file);
            }
        });

        monitor.on('removed', function(file, stat) {
            // Remove file from cache.
            var url = file.replace(uiDirectory, '');
            if (fileCache[url]) {
                delete fileCache[url];
            }

            // In case it's a widget, remove it from the cache.
            var m = url.match(/^\/devwidgets\/(.*?)$/);
            if (m !== null && widgetConfigs[m[1]]) {
                log().info('Removing widget: %s', m[1]);
                delete widgetConfigs[m[1]];
            }
        });

    });
};

/**
 * Get the content of a file. This will only open the file on disk
 * if the file could not be found in the cache.
 * @param {String}      url             The url for the file
 * @param {Function}    callback        A callback method.
 * @param {Object}      callback.err    An error object (if any)
 * @param {String}      callback.data   The data for this url.
 * @private
 */
var getFile = function(url, callback) {
    if (fileCache[url]) {
        callback(null, fileCache[url]);
    } else {
        cacheFile(uiDirectory + url, false, function(err, data) {
            if (err) {
                return callback(err);
            }

            callback(null, data);
        });
    }
};

/**
 * Get the content of multiple files.
 * The returned data is an array with objects of the form:
 * ```
 * {
 *   'url': '/devwidgets/entity/config.json',
 *   'succes': true,
 *   'body': '.. config.json body ..'
 * }
 * If the file could not be found/read the success key will be set to false and there will
 * not be a body key present.
 * 
 * @param  {String[]}   files           An array of file paths.
 * @param {Function}    callback        A callback method.
 * @param {Object}      callback.err    An error object (if any)
 * @param {Object[]}      callback.data   An array of result objects.
 */
var getFiles = module.exports.getFiles = function(files, callback) {
    var validator = new Validator();
    validator.check(files, {'code': 400, 'msg': 'The files parameter must be an array'}).isArray();
    validator.check(files, {'code': 400, 'msg': 'At least one file must be provided'}).min(1);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var results = [];
    files.forEach(function(file) {
        getFile(file, function(err, data) {
            if (err) {
                results.push({
                    'url': file,
                    'success': false
                });
            } else {
                results.push({
                    'url': file,
                    'success': true,
                    'body': data
                });
            }

            if (results.length === files.length) {
                callback(null, results);
            }
        });
    });
};

/**
 * @return {Object} An object where each key is the widget name and the value is the widget config.
 */
var getWidgetConfigs = module.exports.getWidgetConfigs = function() {
    return widgetConfigs;
};

/**
 * @return {Object} The config object for the specific widget or null if no config was found for that widget.
 */
var getWidgetConfig = module.exports.getWidgetConfig = function(widget) {
    return widgetConfigs[widget] || null;
};

/**
 * Reads a file at the specified path and caches it.
 * It will also check if the specified path is a widget config and
 * cache the parsed config file.
 * This will happen *async* from caching the data (as a string)
 *
 * @param {String}      path                The path for the file that needs to be read.
 * @param {Boolean}     doSynchronous       Whether or not the file should be read synchronously (default = async)
 * @param {Function}    [callback]          An optional callback that gets executed when the file is read.
 * @param {Object}      callback.err        An error object (if any)
 * @param {String}      callback.data       The data that sits in the file.
 * @private
 */
var cacheFile = function(path, doSynchronous, callback) {
    callback = callback || function() {};

    /**
     * Caches the returned data against the path name.
     * @param  {Boolean|null} err  [description]
     * @param  {[type]} data [description]
     * @return {[type]}      [description]
     */
    var cacheFileData = function(err, data) {
        if (err) {
            log().error(err);
            return callback(err);
        }

        // Cache the data with a key that matches a URL which the UI would use.
        var url = path.replace(uiDirectory, '');
        fileCache[url] = data;

        // Once we've cached the data, we call the callback immediately.
        // We can do other tasks async.
        callback(null, data);

        // Check if it's a widget configuration file.
        var m = url.match(widgetConfigFilter);
        if (m !== null) {
            try {
                widgetConfigs[m[1]] = JSON.parse(data);
            } catch (err) {
                log().error('Couldn\'t parse the widget config for %s', m[1]);
            }
        }
    };

    if (doSynchronous) {
        var data = fs.readFileSync(path, 'utf-8');
        cacheFileData(null, data);
    } else {
        fs.readFile(path, 'utf-8', cacheFileData);
    }

};

/**
 * Walks a directory and calls the callback each time it finds a file
 * that matches the filter.
 * We don't want to exceed the maximum number of open files so we try to do
 * as much as possible synchronous.
 * This has the downside that it could slow down server startup by a second or two.
 *
 * @param {String}      dir             The directory to run over.
 * @param {RegExp}      filter          A regular expression that gets run against each filename.
 * @param {Function}    callback        The method that needs to be executed *for each* matched filename.
 * @param {Object}      callback.err    An error object (if any)
 * @param {String}      callback.path   The path of a file that had a matching filename
 * @private
 */
var walk = function(dir, filter, callback) {
    callback = callback || function() {};

    var files = fs.readdirSync(dir);
    for (var i = 0; i < files.length;i++) {
        var file = files[i];
        if (file.indexOf('.') === 0) {
            continue;
        }

        var stat = fs.statSync(dir + '/' + file);
        if (stat.isDirectory()) {
            walk(dir + '/' + file, filter, callback);
        } else if (filter.test(file)) {
            callback(null, dir + '/' + file);
        }
    }
};