/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var ShortId = require('shortid');

var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var log = require('oae-logger').logger('content-dao');
var OaeUtil = require('oae-util/lib/util');

var Revision = require('oae-content/lib/model').Revision;


///////////////
// Retrieval //
///////////////


/**
 * Get a set of revisions.
 *
 * @param  {String}         contentId           The id of the object for which we want to get the revisions
 * @param  {String}         start               Determines the point at which revisions are returned for paging purposes.  If not provided, the first x elements will be returned
 * @param  {Integer}        limit               Number of revisions to return. Will default to 10 if not provided
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `revisions`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Revision[]}     callback.revisions  Array that contains an object for each revision.
 */
var getRevisions = module.exports.getRevisions = function(contentId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10);

    Cassandra.runPagedColumnQuery('RevisionByContent', 'contentId', contentId, start, limit, {'reversed': true}, function(err, row) {
        if (err) {
            return callback(err);
        } else if (row.count === 0) {
            return callback(null, []);
        }

        var revisionsToRetrieve = [];
        row.forEach(function(name, value) {
            revisionsToRetrieve.push(value);
        });

        Cassandra.runQuery('SELECT * FROM Revisions WHERE revisionId IN (?)', [revisionsToRetrieve], function(err, rows) {
            if (err) {
                return callback(err);
            }

            // Generate the Revision objects.
            var revisions = [];
            for (var i = 0; i < rows.length; i++) {
                var revision = _rowToRevision(rows[i]);
                revisions.push(revision);
            }
            callback(null, revisions);
        });
    });
};

/**
 * Get a specific revision.
 *
 * @param  {String}     revisionId          The ID of the revision to retrieve.
 * @param  {Function}   callback            Standard callback function takes arguments `err` and `revision`
 * @param  {Object}     callback.err        Error object containing the error message
 * @param  {Revision}   callback.revision   The retrieved revision
 */
var getRevision = module.exports.getRevision = function(revisionId, callback) {
    Cassandra.runQuery('SELECT * FROM Revisions WHERE revisionId = ?', [revisionId], function (err, rows) {
        if (err) {
            return callback(err);
        }

        // Cassandra always returns the key as a column so the count property will always be 1.
        if (rows[0].count <= 1) {
            return callback({'code': 404, 'msg': 'Couldn\'t find revision: ' + revisionId});
        }

        var revision = _rowToRevision(rows[0]);
        callback(null, revision);
    });
};


///////////////
// Modifiers //
///////////////

/**
 * Create a new revision in the database.
 *
 * @param  {String}     contentId           The contentId this revision is for.
 * @param  {String}     createdBy           The ID of the user who created this revision.
 * @param  {Object}     [opts]              Extra options that should be stored on the revision. Each key will be stored as a column.
 * @param  {Function}   [callback]          An optional callback method.
 * @param  {Object}     [callback.err]      An error object (if any)
 * @param  {Revision}   [callback.revision] A revision object.
 */
var createRevision = module.exports.createRevision = function(contentId, createdBy, opts, callback) {
    // Copy all the options (if any)
    var values = _.extend({}, opts);

    // Add some more meta data.
    values.contentId = contentId;
    values.created = Date.now();
    values.createdBy = createdBy;
    var tenantAlias = AuthzUtil.getResourceFromId(contentId).tenantAlias;
    var revisionId = AuthzUtil.toId('rev', tenantAlias, ShortId.generate());

    var q = Cassandra.constructUpsertCQL('Revisions', 'revisionId', revisionId, values, 'QUORUM');
    Cassandra.runQuery(q.query, q.parameters, function(err) {
        if (err) {
            return callback(err);
        }

        // Add the revision to the list.
        Cassandra.runQuery('UPDATE RevisionByContent SET ?=? WHERE contentId=?', [values.created, revisionId, contentId], function(err) {
            if (err) {
                return callback(err);
            }

            if (opts.previews) {
                try {
                    opts.previews = JSON.parse(opts.previews);
                } catch (jsonErr) {
                    opt.previews = {};
                }
            }

            var revision = new Revision(contentId, revisionId, values.createdBy, values.created, opts);
            callback(null, revision);
        });
    });
};

/**
 * Updates a revision with a set of passed in options.
 *
 * @param  {String}     revisionId      The ID of the revision to update
 * @param  {Object}     opts            Simple column->value mapping
 * @param  {Function}   callback        Standard callback method
 * @param  {Object}     callback.err    Standard error object, if any
 */
var updateRevision = module.exports.updateRevision = function(revisionId, opts, callback) {
    var q = Cassandra.constructUpsertCQL('Revisions', 'revisionId', revisionId, opts, 'QUORUM');
    Cassandra.runQuery(q.query, q.parameters, callback);
};


///////////////////////
// Utility functions //
///////////////////////


/**
 * Converts a Cassandra Row to a Revision object.
 *
 * @param  {Row}        row         A Helenus Row
 * @return {Revision}               A revision object or null if the column could not be converted.
 * @api private
 */
var _rowToRevision = function(row) {
    var hash = Cassandra.rowToHash(row);
    if (hash.previews) {
        try {
            hash.previews = JSON.parse(hash.previews);
        } catch (jsonErr) {
            hash.previews = {};
        }
    }
    return new Revision(hash.contentId, hash.revisionId, hash.createdBy, hash.created, hash);
};
