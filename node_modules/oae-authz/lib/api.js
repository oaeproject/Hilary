/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var _ = require('underscore');
var Cassandra = require('oae-util/lib/cassandra');
var Telemetry = require('oae-telemetry').telemetry('authz');
var Validator = require('oae-authz/lib/validator').Validator;
var AuthzUtil = require('oae-authz/lib/util');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;


///////////
// ROLES //
///////////

/**
 * Determine the role assigned to the principal directly on the specified resource instance.
 * 
 * @param {String}              principalUuid   the UUID of the principal
 * @param {String}              resourceUuid    The UUID of the resource
 * @param {Function}            callback        A function specifying the role of the principal. If the principal has no role or there is an error performing the check, role will be null
 * @param {Object}              callback.err    An error that occurred, if any.
 * @param {String}              callback.role   The role of the principal on the resource
 */
var getRole = module.exports.getRole = function(principalUuid, resourceUuid, callback) {
    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided.'}).isPrincipal();
    validator.check(resourceUuid, {code: 400, msg: 'Invalid resource UUID provided.'}).isValidUuid();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getRoles([principalUuid], resourceUuid, function(err, roles) {
        if (err) {
            return callback(err);
        }

        return callback(null, roles[principalUuid]);
    });
};

/**
 * Given a principal and a resource, determine all the effective roles that the principal has on the resource, by virtue of direct
 * association and indirect group inheritance.
 *
 * @param {String}       principalUuid     The UUID of the principal to check
 * @param {String}       resoureceUuid     The UUID of the resource to check
 * @param {Function}     callback          A callback function invoked when the process completes
 * @param {Object}       callback.err      An error that occurred, if any
 * @param {Object}       callback.roles    A JSON Object, keyed by all the roles the principal has on the resource. The value of all the entries is simply `true`
 */
var getAllRoles = module.exports.getAllRoles = function(principalUuid, resourceUuid, callback) {
    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided.'}).isPrincipal();
    validator.check(resourceUuid, {code: 400, msg: 'Invalid resource UUID provided.'}).isValidUuid();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getAllRoles(principalUuid, resourceUuid, callback);
};

/**
 * Determines whether or not the principal has the specified role directly on the given resource.
 * 
 * @param {String}      principalUuid       The UUID of the princpals
 * @param {String}      resourceUuid        The UUID of the resource
 * @param {String}      role                The role to check
 * @param {Function}    callback            A function specifying whether or not the user has the role on the resource
 * @param {Object}      callback.err        An error that occurred, if any
 * @param {Boolean}     callback.hasRole    Whether or not the principal has the specified role on the resource
 */
var hasRole = module.exports.hasRole = function(principalUuid, resourceUuid, role, callback) {
    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided.'}).isPrincipal();
    validator.check(resourceUuid, {code: 400, msg: 'Invalid resource UUID provided.'}).isValidUuid();
    validator.check(role, {code: 400, msg: 'Invalid role provided.'}).isValidRole();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _hasRole(principalUuid, resourceUuid, role, callback);
};

/**
 * Given a resourceType (as determined by Resource.resourceType), return all {resource uuid} => {role} entries that are
 * associated to the principal. The structure of the entries result looks like the following:
 * 
 *     [
 *       {
 *         "uuid": "<resource uuid 1>",
 *         "role": "<role 1>"
 *       },
 *       {
 *         "uuid": "<resource uuid 2>"
 *         "role": "<role 2>"
 *       }
 *     ]
 * 
 * @param {String}          principalUuid       The UUID of the principal
 * @param {String}          resourceType        The resource type to search, as determined by Resource.resourceType
 * @param {String}          start               The starting entry on which to begin returning results (used for paging). **This is not a number**. If null, then the results will simply begin from the start. If the resource uuid is provided, then results will begin from that resource's location, exclusively.
 * @param {Number}          limit               The maximum number of entries to return (used for paging; default: 10)
 * @param {Function}        callback            A function, providing the list of role entries that match the search
 * @param {Object}          callback.err        An error that occurred, if any
 * @param {Object}          callback.entries    A JSON object of the format provided in the summary. Contains all resource instances and the role the principal has on them
 */
var getRolesForResourceType = module.exports.getRolesForResourceType = function(principalUuid, resourceType, start, limit, callback) {
    limit = limit || 10;

    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided.'}).isPrincipal();
    validator.check(limit, {code: 400, msg: '"limit" parameter must be a number when searching for active roles'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var firstColumnIndex = 0;
    var columnPrefix = resourceType+':';

    if (start === null) {
        start = columnPrefix;    
    } else {
        // increment the limit if the user specified the start point, because we skip the first entry to get the EXCLUSIVE
        // page range
        limit++;
        firstColumnIndex = 1;
    }

    var cql = 'SELECT FIRST ' + limit + ' ? .. \'\' FROM AuthzRoles USING CONSISTENCY QUORUM WHERE principalId = ?';
    Cassandra.runQuery(cql, [start, principalUuid], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var entries = [];
        for (var i = firstColumnIndex, j = rows[0].count; i < j; i++) {
            var col = rows[0][i];
            // we need to stop when we've surpassed the last of the specified resource type
            if (col.name.indexOf(columnPrefix) !== 0) {
                break;
            }
            entries.push({ 'uuid': col.name, 'role': col.value });
        }
        callback(null, entries);
    });
};

/**
 * Assign multiple principals a role on a resource instance. If the user already has a role, it will simply be updated. When
 * false is passed in as a role, the role for that principal will be removed.
 *
 * @param {String}          resourceUuid    the UUID of the resource
 * @param {Object}          changes         JSON object where the keys are principal ids and the values are role values
 * @param {Function}        callback        Standard callback function
 * @param {Object}          callback.err    Error object, containing the error message
 */
var applyRoleChanges = module.exports.applyRoleChanges = function(resourceUuid, changes, callback) {

    var validator = new Validator();
    validator.check(resourceUuid, {code: 400, msg: 'Invalid resource UUID provided.'}).isValidUuid();
    validator.check(resourceUuid, {code: 400, msg: 'Cannot assign a role for a principal on a group resource.'}).isNotGroupResource();
    for (var i = 0, keys = _.keys(changes); i < keys.length; i++) {
        var principalUuid = keys[i];
        validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID specified: '+principalUuid}).isValidUuid();
        validator.check(changes[principalUuid], {code: 400, msg: 'Invalid role provided.'}).isValidRoleChange();

    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _applyRoleChanges(resourceUuid, changes, callback);
};

/**
 * Get all principal roles associated to the resourceType for all the principals in the array of principalUuids. This is similar
 * to getRolesForResourceType, except it can be performed on multiple principals at once.
 * 
 * The structure of the resulting entries is structured a hash, indicating all resourceUuids that were returned and what the
 * roles associated to those resources were. For example:
 *
 *     {
 *      'u:cam:simong': { 'member': true },
 *      'g:cam:group-b': { 'member': true }
 *     }
 *
 * or:
 *
 *     {
 *      'c:gat:Foo.docx': { 'viewer': true, 'manager': true},
 *      'c:cam:Bar.pdf':  { 'viewer': true }
 *     }
 *
 * In the latter case, 'c:gat:Foo.docx' has both 'viewer' and 'manager' role associated to it. This indicates that some principal
 * had a role of 'viewer' on the resource, while some other principal had the 'manager' role.
 *
 * @param {Array}          principalUuids      The array of principalUuds to query for
 * @param {String}         resourceType        The resource type of the resources to search for, as determined by Resource.resourceType
 * @param {Number}         limit               The maximum number of resources to return per user
 * @param {Function}       callback            A function providing all the {resource uuid} -> {roles} mappings aggregated for all the provided principals queried
 * @param {Object}         callback.err        An error that occurred, if any
 * @param {Object}         callback.entries    A JSON Object representing the roles associated to the users
 * @see oae-authz#getRolesForResourceType
 */
var getRolesForPrincipalsAndResourceType = module.exports.getRolesForPrincipalsAndResourceType = function(principalUuids, resourceType, limit, callback) {
    limit = limit || 1000;

    var validator = new Validator();
    validator.check(limit, {code: 400, msg: '"limit" parameter must be a number when searching for active roles'});
    for (var i = 0; i < principalUuids.length; i++) {
        var principalUuid = principalUuids[i];
        validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID specified: '+principalUuid}).isPrincipal();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // we append a '|' to the "end" range, as | has a high ASCII alphabetical ordering. This may not suffice if resourceIds have
    // multi-byte characters, which is technically possible. Unfortunately, I don't think there is a better way to do this with
    // CQL.
    var columnPrefix = resourceType+':';
    var start = columnPrefix;
    var end = start+'|';

    var cql = 'SELECT FIRST ' + limit + ' ? .. ? FROM AuthzRoles USING CONSISTENCY QUORUM WHERE principalId IN (?)';
    Cassandra.runQuery(cql, [start, end, principalUuids], function(err, rows) {
        if (!err) {
            var entries = {};

            // aggregate all resources from all the rows (principals) into the entries hash
            var expandRow = function(name, value) {
                if (!entries[name]) {
                    entries[name] = {};
                }
                entries[name][value] = true;
            };
            for (var i = 0; i < rows.length; i++) {
                rows[i].forEach(expandRow);
            }
            
            callback(null, entries);
        } else {
            callback(err);
        }
    });
};

/**
 * Given a principal and a resource, determine all the roles that the principal has on the resource, by virtue of direct association and
 * indirect group inheritance.
 *
 * @param   {String}       principalUuid   The UUID of the principal to check
 * @param   {String}       resoureceUuid   The UUID of the resource to check
 * @param   {Function}     callback        A callback function invoked when the process completes
 * @param   {Object}       callback.err    An error that occurred, if any
 * @param   {Object}       callback.roles  A JSON Object, keyed by all the roles the principal has on the resource. The value of all the entries is simply `true`
 */
var _getAllRoles = function(principalUuid, resourceUuid, callback) {

    // the hash of all roles that will be aggregated
    var allRoles = {};

    // get the entire group ancestry to get the list of all principals for which we'll need to check roles
    _getGroupMembershipAncestry(principalUuid, function(err, principalUuids) {
        if (err) {
            return callback(err);
        }

        // include the current principal
        principalUuids[principalUuid] = true;
        _getRoles(_.keys(principalUuids), resourceUuid, function(err, roles) {
            if (err) {
                return callback(err);
            }

            // we need to iterate over the *values* of this roles hash to aggregate all effective roles.
            for (var p in roles) {
                if (roles.hasOwnProperty(p)) {
                    // aggregate this role into the hash
                    allRoles[roles[p]] = true;
                }
            }

            return callback(null, allRoles);
        });
    });
};

/**
 * Determine the role assigned to the given principals directly on the specified resource instance.
 * 
 * @param   {String}       principalUuid   the UUID of the principal
 * @param   {String}       resourceUuid    The UUID of the resource
 * @param   {Function}     callback        A function specifying the role of the principal. If the principal has no role or there is an error performing the check, role will be null
 * @param   {Object}       callback.err    An error that occurred, if any.
 * @param   {Object}       callback.roles  A hash keyed by principalUuid, with value set to the role they have directly on the resource 
 **/
var _getRoles = function(principalUuids, resourceUuid, callback) {
    Cassandra.runQuery('SELECT principalId, ? FROM AuthzRoles USING CONSISTENCY QUORUM WHERE principalId IN (?)', [resourceUuid, principalUuids], function(err, rows) {
        if (err) {
            return callback(err);
        }

        // aggregate the roles for the principals
        var roles = {};
        rows.forEach(function(row) {
            var resourceCol = row.get(resourceUuid);
            var principalCol = row.get('principalId');
            if (resourceCol) {
                roles[principalCol.value] = resourceCol.value;
            }
        });

        return callback(null, roles);
    });
};

/**
 * Determines whether or not the principal has the specified role directly on the given resource.
 * 
 * @param {String}       principalUuid       The UUID of the princpals
 * @param {String}       resourceUuid        The UUID of the resource
 * @param {String}       role                The role to check
 * @param {Function}     callback            A function specifying whether or not the user has the role on the resource
 * @param {Object}       callback.err        An error that occurred, if any
 * @param {Boolean}      callback.hasRole    Whether or not the principal has the specified role on the resource
 */
var _hasRole = function(principalUuid, resourceUuid, role, callback) {
    _getRoles([principalUuid], resourceUuid, function(err, actualRole) {
        if (!err) {
            callback(null, role === actualRole[principalUuid]);
        } else {
            callback(err);
        }
    });
};

/**
 * Assign multiple principals a role on a resource instance. If the user already has a role, it will simply be updated. When
 * false is passed in as a role, the role for that principal will be removed.
 *
 * @param   {String}        resourceUuid    the UUID of the resource
 * @param   {Object}        changes         JSON object where the keys are principal ids and the values are role values
 * @param   {Function}      callback        Standard callback function
 * @param   {Object}        callback.err    Error object, containing the error message
 */
var _applyRoleChanges = function(resourceUuid, changes, callback) {
    var queries = [];
    for (var i = 0, keys = _.keys(changes); i < keys.length; i++) {
        var principalUuid = keys[i];
        if (changes[principalUuid]) {
            queries.push({
                'query': 'UPDATE AuthzRoles SET ? = ? WHERE principalId = ?',
                'parameters': [resourceUuid, changes[principalUuid], principalUuid]
            });
        } else if (changes[principalUuid] === false) {
            queries.push({
                'query': 'DELETE ? FROM AuthzRoles WHERE principalId = ?',
                'parameters': [resourceUuid, principalUuid]
            });
        } else {
            return callback({'code': 400, 'msg': 'An invalid role has been passed in (undefined)'});
        }
    }
    Cassandra.runBatchQuery(queries, 'QUORUM', callback);
};


//////////////////////
// GROUP MEMBERSHIP //
//////////////////////

/**
 * Apply a bulk set of group memberships changes, as specified by the 'changes' parameter. The changes should
 * be a JSON Object keyed by the principal UUID, with value being the role to assign in the group. If the value
 * is 'false', then the principal should be removed from the group.
 * 
 * @param   {String}       groupUuid       The group to which the changes should be applied
 * @param   {Object}       changes         A JSON Object representing the changes to be applied. See method summary for more information.
 * @param   {Function}     callback        Standard callback, invoked when the process completes
 * @param   {Object}       callback.err    An error that occurred, if any
 */
var applyGroupMembershipChanges = module.exports.applyGroupMembershipChanges = function(groupUuid, changes, callback) {
    var validator = new Validator();
    validator.check(groupUuid, {code: 400, msg: 'Invalid group UUID provided.'}).isGroupPrincipal();
    for (var i = 0, keys = _.keys(changes); i < keys.length; i++) {
        var memberUuid = keys[i];
        validator.check(memberUuid, {code: 400, msg: 'Invalid principal UUID provided: '+memberUuid}).isPrincipal();
        validator.check(changes[memberUuid], {code: 400, msg: 'Invalid role provided.'}).isValidRoleChange();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _applyGroupMembershipChanges(groupUuid, changes, callback);
};

/**
 * Get all the members of a group.
 *
 * @param  {String}           groupUuid               An unique identifier for a group. ex: g:cam-oae-team
 * @param  {String}           start                   The principal id that comes just before the first principal you wish to have in your results.
 * @param  {Number}           limit                   The number of members you wish to retrieve.
 * @param  {Function}         callback                Standard callback method that has an array of the direct members of a group.
 * @param  {Object}           callback.err            An error that occurred, if any
 * @param  {Array<String>}    callback.members        The principal UUIDs for all members of the group
 */
var getGroupMembers = module.exports.getGroupMembers = function(groupUuid, start, limit, callback) {
    limit = limit || 100;
    callback = callback || function(err, members) {};

    var validator = new Validator();
    validator.check(groupUuid, {code: 400, msg: 'Invalid group UUID provided'}).isGroupPrincipal();
    validator.check(limit, {code: 400, msg: 'The limit parameter needs to be a number'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Page the query.
    var paging = Cassandra.getPagingParameters(start, limit);

    Cassandra.runQuery("SELECT FIRST " + paging.limit + " ?..\'\' FROM AuthzGroupMembers USING CONSISTENCY QUORUM WHERE groupId = ?", [paging.start, groupUuid], function (err, rows) {
        if (err) {
            return callback(err);
        }

        var members = [];
        var row = rows[0];
        for (var i = paging.startIndex, j = row.count; i < j; i++) {
            var name = row[i].name;
            var role = row[i].value;
            if (name !== "groupId") {
                members.push({'uuid': name, 'role': role});
            }
        }

        return callback(false, members);
    });
};

/**
 * Gets all the groups of which a principal (either user or group) is a member. This includes all group ancestors to which the user is indirectly
 * a member.
 *
 * @param {String}           principalUuid           The principal for which to retrieve all the groups
 * @param {Function}         callback                Standard callback method invoked when the process completes
 * @param {Object}           callback.err            An error that occured, if any
 * @param {String[]}         callback.groups         An (inconsistently ordered) array of groups to which the user belongs, either directly or indirectly
 */
var getMemberOf = module.exports.getMemberOf = function(principalUuid, callback) {
    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided'}).isPrincipal();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getGroupMembershipAncestry(principalUuid, function(err, groups) {
        if (!err) {
            return callback(null, _.keys(groups));
        } else {
            return callback(err);
        }
    });
};

/**
 * Determines whether or not the principal (either user or group) is a member (either directly or indirectly) of the specified group.
 *
 * @param {String}            principalUuid               The principal to check
 * @param {String}            groupUuid                   The group to check
 * @param {Function}          callback                    Standard callback function, invoked when the process completes
 * @param {Object}            callback.err                An error that occurred, if any
 * @param {Boolean}           callback.isMemberOf         Specifies whether or not the principal is a member of the specified group
 */
var isMemberOf = module.exports.isMemberOf = function(principalUuid, groupUuid, callback) {
    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided'}).isPrincipal();
    validator.check(groupUuid, {code: 400, msg: 'Invalid group UUID provided'}).isGroupPrincipal();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    isAllowedAny(principalUuid, groupUuid, callback);
};

/**
 * Apply a series of group membership changes. Note this internal function does no validation on the data. Please do
 * validation prior to send batches of changes to this method.
 * 
 * @param {String}              groupUuid       The UUID of the group to which the members should be added
 * @param {Array<Object>}       changes         A JSON object keyed by a principalUuid, with value either the role to apply, or 'false' to indicate removal from the group.
 * @param {String}              role            The role to assign to all the members
 * @param {Function}            callback        The Function called when the process is finished
 * @param {Object}              callback.err    An error that occurred, if any
 * @param {Object}              callback.added  A list of the memberUuids that were successfully added
 */
var _applyGroupMembershipChanges = function(groupUuid, changes, callback) {
    var queries = [];
    var memberUuids = _.keys(changes);

    for (var i = 0; i < memberUuids.length; i++) {
        var memberUuid = memberUuids[i];
        var role = changes[memberUuid];

        if (role === false) {

            // first, delete from AuthzGroupMembers
            queries.push({
                query: 'DELETE ? FROM AuthzGroupMembers WHERE groupId = ?',
                parameters: [memberUuid, groupUuid]
            });

            // second, delete from the AuthzRoles 
            queries.push({
                query: 'DELETE ? FROM AuthzRoles WHERE principalId = ?',
                parameters: [groupUuid, memberUuid]
            });

        } else if (role) {

            // first, add to AuthzGroupMembers
            queries.push({
                query: 'UPDATE AuthzGroupMembers SET ? = ? WHERE groupId = ?',
                parameters: [memberUuid, role, groupUuid]
            });

            // second, add to roles
            queries.push({
                query: 'UPDATE AuthzRoles SET ? = ? WHERE principalId = ?',
                parameters: [groupUuid, role, memberUuid]
            });

        }
    }

    Cassandra.runBatchQuery(queries, 'QUORUM', function(err) {
        if (!err) {
            callback(null, memberUuids);
        } else {
            callback(err);
        }
    });
};

/**
 * Given some principal, get their entire group membership ancestry. In other words, get all the groups to which they belong,
 * and the groups to all those groups belong, and so on.
 *
 * @param   {String}        principalUuid       The UUID of the principal
 * @param   {Function}      callback            A callback function specifying the entire group ancestry of the given principal
 * @param   {Object}        callback.err        The err that occured, if any
 * @param   {Object}        callback.ancestry   A hash keyed by the group UUID of each group of which the user is indirectly a member. The value of each entry is `true`.
 */
var _getGroupMembershipAncestry = function(principalUuid, callback) {
    var results = {};

    var _multiGetGroupMembershipAncestry = function(principalUuids, results) {
        getRolesForPrincipalsAndResourceType(principalUuids, AuthzConstants.resourceTypes.GROUP, 10000, function(err, entries) {
            var nextPrincipalBatch = [];
            if (!err) {
                var ancestors = Object.keys(entries);
                // for each group parent, determine if we've already recorded their membership. if not, we record it, and search it's parents
                for (var i = 0; i < ancestors.length; i++) {
                    var ancestorUuid = ancestors[i];
                    if (!results[ancestorUuid]) {
                        results[ancestorUuid] = true;
                        nextPrincipalBatch.push(ancestorUuid);
                    }
                }

                // if we found new ancestors, we need to recurse to find their ancestors. Otherwise we're done.
                if (nextPrincipalBatch.length > 0) {
                    return _multiGetGroupMembershipAncestry(nextPrincipalBatch, results);
                } else {
                    return callback(false, results);
                }
            } else {
                return callback(err);
            }
        });
    };

    _multiGetGroupMembershipAncestry([principalUuid], results, callback);
};



/////////////////
// PERMISSIONS //
/////////////////

/**
 * Determine whether or not the principal specified by principalUuid can perform the action on the given resourceUuid
 * 
 * @param {String}          principalUuid        The principal to check
 * @param {String}          action               The action to check
 * @param {String}          resourceUuid         The resource to check
 * @param {Function}        callback             A function specifying whether or not the user can perform the operation
 * @param {Object}          callback.err         An error that occured, if any
 * @param {Boolean}         callback.isAllowed   Whether or not the principal can perform the operation on the resource
 */
var isAllowed = module.exports.isAllowed = function(principalUuid, action, resourceUuid, callback) {
    var startIsAllowed = Date.now();
    // first check this principal directly
    hasRole(principalUuid, resourceUuid, action, function(err, hasRole) {
        if (!err) {
            if (hasRole) {
                Telemetry.append('isAllowed.direct.time', duration(startIsAllowed));
                Telemetry.incr('isAllowed.direct.count');
                return callback(null, true);
            } else {
                // get the entire (indirect as well) group ancestry of the principal and check if they have the access
                Telemetry.incr('isAllowed.indirect.count');
                var startMemberOf = Date.now();

                // TODO: There is a potential optimization here to not aggressively get all ancestors, but rather check one level at a time
                // We can do the above optimization assuming we can short-circuit the checks when we get one positive check.
                getMemberOf(principalUuid, function(err, groupUuids) {
                    if (!err) {
                        Telemetry.append('isAllowed.getMemberOf.time', duration(startMemberOf));
                        var startInternalIsAllowed = Date.now();
                        return _isAllowed(groupUuids, action, resourceUuid, function(err, isAllowed) {
                            if (err) {
                                Telemetry.incr('isAllowed.err.count');
                                return callback(err);
                            }

                            Telemetry.append('isAllowed.batch.time', duration(startInternalIsAllowed));
                            Telemetry.append('isAllowed.indirect.time', duration(startIsAllowed));

                            if (!isAllowed) {
                                Telemetry.incr('isAllowed.negative.count');
                            }

                            return callback(null, isAllowed);
                        });
                    } else {
                        Telemetry.incr('isAllowed.err.count');
                        return callback(err);
                    }
                });
            }
        } else {
            return callback(err);
        }
    });
};

/**
 * Determine whether or not the principal specified by principalUuid can perform at least one action on the given resourceUuid
 *
 * @param {String}          principalUuid        The principal to check
 * @param {String}          resourceUuid         The resourceUuid to check
 * @param {Function}        callback             A function specifying whether or not the user can perform any operation
 * @param {Object}          callback.err         An error that occured, if any
 * @param {Boolean}         callback.isAllowed   Whether or not the principal is authorized to perform any action on the resource
 */
var isAllowedAny = module.exports.isAllowedAny = function(principalUuid, resourceUuid, callback) {
    var startIsAllowed = Date.now();
    // first check the principal directly
    getRole(principalUuid, resourceUuid, function(err, role) {
        if (!err) {
            if (role) {
                Telemetry.append('isAllowed.direct.time', duration(startIsAllowed));
                Telemetry.incr('isAllowed.direct.count');
                // there was a role, short-circuit and indicate that the user has some role on the resource
                return callback(null, true);
            } else {
                Telemetry.incr('isAllowed.indirect.count');
                var startMemberOf = Date.now();

                getMemberOf(principalUuid, function(err, groupUuids) {
                    Telemetry.append('isAllowed.getMemberOf.time', duration(startMemberOf));
                    var startInternalIsAllowed = Date.now();

                    if (!err) {
                        return _isAllowed(groupUuids, null, resourceUuid, function(err, isAllowed) {
                            if (err) {
                                Telemetry.incr('isAllowed.err.count');
                                return callback(err);
                            }

                            Telemetry.append('isAllowed.batch.time', duration(startInternalIsAllowed));
                            Telemetry.append('isAllowed.indirect.time', duration(startIsAllowed));

                            if (!isAllowed) {
                                Telemetry.incr('isAllowed.negative.count');
                            }

                            return callback(null, isAllowed);
                        });
                    } else {
                        Telemetry.incr('isAllowed.err.count');
                        return callback(err);
                    }
                });
            }
        } else {
            return callback(err);
        }
    });
};

/**
 * Determine whether or not one of the principals in the array of principalUuids is able to perform the action on the
 * resource specified. If the action is null, then we will determine if the user can perform *any* action on the
 * resource specified.
 *
 * @param {Array<String>}      principalUuids       The array of principals to check
 * @param {String}             action               The action to check. If null, check for any action.
 * @param {String}             resourceUuid         The resource to check
 * @param {Function}           callback             A function invoked when the process is complete.
 * @param {Object}             callback.err         An error that occured, if any
 * @param {Boolean}            callback.isAllowed   Whether or not one of the principals is authorized to perform the action
 */
var _isAllowed = function(principalUuids, action, resourceUuid, callback) {

    // short circuit if there is no ancestry
    if (!(principalUuids.length > 0)) {
        return callback(null, false);
    }

    // variables for monitoring the progress of permissions checks
    var index = 0;
    var isAllowedResult = false;
    var errResult = false;

    // this function monitors the progress of asynchronous permissions checks, calling back to the caller when appropriate
    var checkStatus = function(err, isAllowed) {
        if (errResult || isAllowedResult) {
            // do nothing, because we've already finished executing and called the callback
        } else if (err) {
            // we got an error while executing, call back with the error
            errResult = err;
            return callback(errResult);
        } else if (isAllowed) {
            // one of the principals is allowed to perform the action, short circuit
            isAllowedResult = isAllowed;
            return callback(null, isAllowedResult);
        } else {
            index++;
            if (index >= principalUuids.length) {
                // we've reached the end of the check and none are allowed, return false
                return callback(null, false);
            }
        }
    };

    // invoke the entire ancestry asynchronously. checkStatus will determine the result and when it is possible to call back.
    for (var i = 0; i < principalUuids.length; i++) {
        var principalUuid = principalUuids[i];
        if (action !== null) {
            hasRole(principalUuid, resourceUuid, action, checkStatus);
        } else {
            // we pass checkStatus directly here on the basis that the 'isAllowed' parameter is a duck-check and not strictly typed.
            getRole(principalUuid, resourceUuid, checkStatus);
        }
    }
};

/**
 * Return the duration in milliseconds from the `from` time to now.
 *
 * @param   {Number} from   The starting point (millis since epoch) from which to calculation the duration
 * @return  {Number}        The number of milliseconds between the `from` time and now.
 */
var duration = function(from) {
    return Date.now() - from;
}
