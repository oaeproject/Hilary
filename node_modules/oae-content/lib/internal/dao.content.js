/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var ShortId = require('shortid');

var AuthzAPI = require('oae-authz');
var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var LibraryAPI = require('oae-library');
var log = require('oae-logger').logger('content-dao');
var OaeUtil = require('oae-util/lib/util');

var Content = require('oae-content/lib/model').Content;
var ContentConstants = require('oae-content/lib/constants').ContentConstants;

var RevisionsDAO = require('./dao.revisions');

///////////////
// Retrieval //
///////////////


/**
 * Get a content's basic profile information based on a pooled content id
 *
 * @param  {String}         contentId           The id of the content object we want to retrieve
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Content}        callback.contentObj Retrieved content object
 */
var getContent = module.exports.getContent = function(contentId, callback) {
    Cassandra.runQuery('SELECT * FROM Content USING CONSISTENCY QUORUM WHERE contentId = ?', [contentId], function (err, rows) {
        if (err) {
            return callback(err);
        }

        // Cassandra always returns the key as a column so the count will always be 1.
        if (rows[0].count <= 1) {
            return callback({'code': 404, 'msg': 'Couldn\'t find content: ' + contentId}, null);
        }

        var contentObj = _rowToContent(rows[0]);
        return callback(null, contentObj);
    });
};

/**
 * Get multiple content basic profiles at the same time based on their content ids.
 *
 * @param  {String[]}       contentIds          Array of content object ids we want to retrieve. The content profiles will be returned in the same order
 * @param  {String[]}       [fields]            The fields to fetch from the content items. If not specified, all will be fetched
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `contentObj`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Content[]}      callback.contentObj Retrieved content objects
 */
var getMultipleContentItems = module.exports.getMultipleContentItems = function(contentIds, fields, callback) {
    if (!contentIds.length) {
        return callback(null, []);
    }

    var query = null;
    var parameters = [];

    // If `fields` was specified, we select only the fields specified. Otherwise we select all (i.e., *)
    if (fields) {
        var placeholders = [];
        _.map(fields, function(field) {
            placeholders.push('?');
            parameters.push(field);
        });
        query = 'SELECT ' + placeholders.join(',') + ' FROM Content USING CONSISTENCY QUORUM WHERE contentId IN (?)';
    } else {
        query = 'SELECT * FROM Content USING CONSISTENCY QUORUM WHERE contentId IN (?)';
    }

    parameters.push(contentIds);

    Cassandra.runQuery(query, parameters, function(err, rows) {
        if (err) {
            return callback(err);
        }

        // Iterate over the content items
        for (var i = 0; i < rows.length; i++) {
            // Check if the piece of content exists. Cassandra always returns the key as a column so the count will always be 1
            if (rows[i].count > 1) {
                var contentObj = _rowToContent(rows[i]);
                contentIds[_.indexOf(contentIds, contentObj.id)] = contentObj;

            // If the content item could not be found, the item has probably been deleted, so we indicate that with a null value
            } else {
                contentIds[_.indexOf(contentIds, rows[i].get('contentId').value)] = null;
            }
        }

        return callback(null, contentIds);
    });
};

/**
 * Function that gets all of the principals that are directly associated to a piece of content.
 *
 * @param  {String}         contentId           The id of the content object for which we want to get the members
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `members`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Object[]}       callback.members    An array of hashes, where the 'id' property of the hash is the principal id, and the 'role' property of the hash is the role of the principal.
 */
var getAllContentMembers = module.exports.getAllContentMembers = function(contentId, callback) {
    AuthzAPI.getAuthzMembers(contentId, null, 10000, callback);
};


///////////////
// Modifiers //
///////////////


/**
 * Create a new piece of pooled content
 *
 * @param  {String}         contentId           The id of the piece of content
 * @param  {String}         revisionId          The id of the first revision
 * @param  {String}         createdBy           The id of the user who is creating the content item
 * @param  {String}         resourceSubType     The content type. Possible values are "file", "collabdoc" and "link"
 * @param  {String}         displayName         The display name for the piece of content
 * @param  {String}         description         The description of the piece of content [optional]
 * @param  {String}         visibility          The visibility setting for the piece of content. Possible values are "public", "loggedin" and "private" [optional]
 * @param  {Object}         additionalMembers   Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {Object}         otherValues         JSON object where the keys represent other metadata values that need to be stored, and the values represent the metadata values
 * @param  {Object}         revisionData        JSON object where the keys represent revision columns that need to be stored, and the values represent the revision values
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `content`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Content}        callback.content    JSON object containing the pool id of the created content
 * @param  {Revision}       callback.revision   The initial revision object for this content item.
 */
var createContent = module.exports.createContent = function(contentId, revisionId, createdBy, resourceSubType, displayName, description, visibility, additionalMembers, otherValues, revisionData, callback) {
    // Use an empty description if no description has been provided
    description = description || '';
    // Make sure the otherValues and additionalMembers are valid objects
    additionalMembers = additionalMembers || {};
    otherValues = otherValues || {};

    // Seed the revision first
    RevisionsDAO.createRevision(revisionId, contentId, createdBy, revisionData, function(err, revision) {
        if (err) {
            return callback(err);
        }

        // Get the tenantAlias out of the content model.
        var tenantAlias = AuthzUtil.getResourceFromId(contentId).tenantAlias;

        // Set the properties
        var parameters = {
            'tenantAlias': tenantAlias,
            'visibility': visibility,
            'displayName': displayName,
            'description': description,
            'resourceSubType': resourceSubType,
            'createdBy': createdBy,
            'created': Date.now(),
            'latestRevisionId': revision.revisionId,
            'previews': {'status': 'pending'}
        };

        // Add the other values into the query
        parameters = _.extend(parameters, otherValues);
        var q = Cassandra.constructUpsertCQL('Content', 'contentId', contentId, parameters, 'QUORUM');

        // Create the content
        Cassandra.runQuery(q.query, q.parameters, function(err) {
            if (err) {
                return callback(err);
            }

            var contentObj = new Content(tenantAlias, contentId, visibility, displayName, description, resourceSubType, parameters.createdBy, parameters.created, null, revision.revisionId);
            contentObj.previews = {'status': 'pending'};
            callback(null, contentObj, revision);
        });
    });
};

/**
 * Updates a piece of content in the database.
 *
 * @param  {String}     contentObj              The full (pre-update) content object that is being updated
 * @param  {Object}     profileUpdates          An object where the keys represent the column names and the values the new column values to apply to the content profile
 * @param  {Boolean}    librariesUpdate         Whether or not to update the libraries that this content item sits in
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            Error object containing the error message
 * @param  {Content}    callback.content        The new content object
 */
var updateContent = module.exports.updateContent = function(contentObj, profileUpdates, librariesUpdate, callback) {
    // Set the lastModified timestamp.
    var oldLastModified = contentObj.lastModified;
    profileUpdates.lastModified = Date.now();

    var q = Cassandra.constructUpsertCQL('Content', 'contentId', contentObj.id, profileUpdates, 'QUORUM');
    Cassandra.runQuery(q.query, q.parameters, function(err) {
        if (err) {
            return callback(err);
        }

        // Create the new content object by merging in the metadata changes over the old content object
        var newContentObj = _.extend({}, contentObj, profileUpdates);

        // In case the revision ID has changed
        if (newContentObj.resourceSubType === 'file') {
            newContentObj.downloadPath = '/api/content/' + newContentObj.id + '/download/' + newContentObj.latestRevisionId;
        }

        if (!librariesUpdate) {
            return callback(null, newContentObj);
        } else {
            _updateLibraries(newContentObj, oldLastModified, newContentObj.lastModified, [], function(err) {
                if (err) {
                    return callback(err);
                }
                callback(null, newContentObj);
            });
        }
    });
};

/**
 * Deletes a piece of content from the database and removes it from all the managers/members
 * their libraries.
 *
 * @param  {Content}    contentObj      The piece of content that should be removed.
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    Error object containing the error message
 */
var deleteContent = module.exports.deleteContent = function(contentObj, callback) {
    Cassandra.runQuery('DELETE FROM Content WHERE contentId = ?', [contentObj.id], function(err) {
        if (err) {
            return callback(err);
        }

        getAllContentMembers(contentObj.id, function(err, members) {
            if (err) {
                return callback(err);
            } else if (members.length === 0) {
                return callback();
            }

            var updateMembers = {};
            var membersToRemove = [];
            for (var m = 0; m < members.length; m++) {
                updateMembers[members[m].id] = false;
                membersToRemove.push(members[m].id);
            }

            // Update the roles CF
            AuthzAPI.updateRoles(contentObj.id, updateMembers, function(err) {
                if (err) {
                    return callback(err);
                }

                // Simply remove this item from all member libraries
                LibraryAPI.Index.remove(ContentConstants.library.CONTENT_LIBRARY_INDEX_NAME, membersToRemove, contentObj.id, contentObj.lastModified, function(err) {
                    if (err) {
                        // If there was an error updating libraries here, the permissions were still changed, so we should not return an error. Just log it.
                        log().warn({
                            'err': err,
                            'contentObj': contentObj,
                            'removedMembers': removedMembers
                        }, 'Failed to update user libraries after updating content permissions.');
                    }

                    return callback();
                });
            });
        });
    });
};


///////////////
// Libraries //
///////////////


/**
 * Get a user's or group's library. This function assumes that all permission check will have
 * been done and the processed principal id is passed in. It also assumes that a valid start and limit parameter are passed in.
 *
 * @param  {String}         principalId         The ID of the principal for which the library should be retrieved.
 * @param  {String}         visibility          Which library should be returned.
 * @param  {String}         start               Determines the point at which content items are returned for paging purposed.  If not provided, the first x elements will be returned
 * @param  {Number}         limit               Number of items to return. Will default to 10 if not provided
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `content`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Content[]}      callback.content    Array of basic content profiles representing the requested items in the library
 * @param  {String}         callback.nextToken  The value to use for the `start` parameter to get the next set of results
 */
var getLibraryItems = module.exports.getLibraryItems = function(principalId, visibility, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10);

    LibraryAPI.Index.list(ContentConstants.library.CONTENT_LIBRARY_INDEX_NAME, principalId, visibility, {'start': start, 'limit': limit}, function(err, resourceIds, nextToken) {
        if (err) {
            return callback(err);
        }

        getMultipleContentItems(resourceIds, null, function(err, contentItems) {
            if (err) {
                return callback(err);
            }

            return callback(null, contentItems, nextToken);
        });
    });
};

/**
 * Iterate through all the content items. This will return just the raw content properties that are specified in the `properties`
 * parameter, and only `batchSize` content items at a time. On each iteration of `batchSize` content items, the `onEach` callback
 * will be invoked, and the next batch will not be fetched until you have invoked the `onEach.done` function parameter. When
 * complete (e.g., there are 0 content items left to iterate through or an error has occurred), the `callback` parameter will be
 * invoked.
 *
 * @param  {String[]}   [properties]        The names of the content properties to return in the content objects. If not specified (or is empty array), it returns just the `contentId`s
 * @param  {Number}     [batchSize]         The number of content items to fetch at a time. Defaults to 100
 * @param  {Function}   onEach              Invoked with each batch of content items that are fetched from storage
 * @param  {Object[]}   onEach.contentRow   An array of objects holding the raw content rows that were fetched from storage
 * @param  {Function}   onEach.done         The function to invoke when processing of the current batch is complete
 * @param  {Object}     onEach.done.err     An error that occurred, if any, while processing the current batch. If you specify this error, iteration will finish and the completion callback will be invoked
 * @param  {Function}   [callback]          Invoked when all rows have been iterated, or an error has occurred
 * @param  {Object}     [callback.err]      An error that occurred, while iterating rows, if any
 * @see Cassandra#iterateAll
 */
var iterateAll = module.exports.iterateAll = function(properties, batchSize, onEach, callback) {
    if (!properties || !properties.length) {
        properties = ['contentId'];
    }

    var opts = {
        'batchSize': batchSize,
        'consistency': 'ONE',
        'slugColumnName': 'visibility'
    };

    /*!
     * Handles each batch from the cassandra iterateAll method.
     *
     * @see Cassandra#iterateAll
     */
    var _iterateAllOnEach = function(rows, done) {
        // Convert the rows to a hash and delegate action to the caller onEach method
        var hashedRows = [];
        rows.forEach(function(row) {
            hashedRows.push(Cassandra.rowToHash(row));
        });

        return onEach(hashedRows, done);
    };

    Cassandra.iterateAll(properties, 'Content', 'contentId', opts, _iterateAllOnEach, callback);
};

/*
 * Updates the libraries of all of the members of a piece of content. This will remove the old entry with
 * the old lastModified date/sorting and add the new one. The content item's `lastModified` timestamp will
 * be updated such that it ranked higher in libraries.
 *
 * @param  {Content}    contentObj                  The content object for which the libraries should be updated.
 * @param  {String[]}   removedMembers              An array of principal IDs that should no longer have this item in their library.
 * @param  {Function}   [callback]                  Standard callback function
 * @param  {Object}     [callback.err]              Error object containing the error message
 * @param  {Content}    [callback.newContentObj]    The content object with the updated `lastModified` field. Note that this may be returned even if there is an error as the content-update operation may have succeeded but the library-update operation fails.
 */
var updateLibraries = module.exports.updateLibraries = function(contentObj, removedMembers, callback) {
    // Grab hold of the old last modified timestamp to remove columns in the library CF (if any)
    var oldLastModified = contentObj.lastModified;

    // Update the content item with a new timestamp.
    updateContent(contentObj, {}, false, function(err, newContentObj) {
        if (err) {
            return callback(err);
        }

        // Update the libraries.
        _updateLibraries(contentObj, oldLastModified, newContentObj.lastModified, removedMembers, function(err) {
            if (err) {
                return callback(err, newContentObj);
            }

            return callback(null, newContentObj);
        });
    });
};

/**
 * Internal function that updates the content libries for a piece of content.
 *
 * @param  {Content}    contentObj          The content object for which the libraries should be updated
 * @param  {Number}     oldLastModified     The timestamp when the content item was last modified. (Note: this is the timestamp that is used in the libraries)
 * @param  {Number}     newLastModified     The new timestamp
 * @param  {String[]}   removedMembers      An array of principal IDs that should no longer have this item in their library.
 * @param  {Function}   [callback]          Standard callback function
 * @param  {Object}     [callback.err]      Error object containing the error message
 */
var _updateLibraries = function(contentObj, oldLastModified, newLastModified, removedMembers, callback) {
    // Grab all the current members.
    getAllContentMembers(contentObj.id, function(err, members) {
        if (err) {
            return callback(err);
        }

        // Extract all the memberids from the members response
        var memberIds = _.map(members, function(member) { return member.id; });
        var libraryVisibility = LibraryAPI.Authz.resolveEffectiveLibraryVisibilities(memberIds, contentObj);

        if (!oldLastModified) {
            // We are creating a new content item. We only care about who is getting added, so insert it into the library index for all members
            return LibraryAPI.Index.insert(ContentConstants.library.CONTENT_LIBRARY_INDEX_NAME, libraryVisibility, contentObj.id, newLastModified, callback);
        }

        // At this point, this is a content update (profile or permissions)
        var membersToUpdate = [];

        // Sort out who gets updated and who gets deleted
        _.each(memberIds, function(memberId) {
            if (!_.contains(removedMembers, memberId)) {
                // The member is only an update candidate if they aren't actually being removed here
                membersToUpdate.push(memberId);
            }
        });

        var errs = [];

        /*!
         * Handles assembling the error object based on all the errors we may have received and calls back to the
         * caller.
         */
        var _doCallback = function() {
            var err = null;
            if (errs.length > 0) {
                err = {
                    'code': 500,
                    'msg': 'Error applying library updates for content members',
                    'errs': errs
                };
            }
            return callback(err);
        };

        // Trim the visibilities down to just the members we'll update
        libraryVisibility = LibraryAPI.Authz.resolveEffectiveLibraryVisibilities(membersToUpdate, contentObj);

        // First apply the updates
        return LibraryAPI.Index.update(ContentConstants.library.CONTENT_LIBRARY_INDEX_NAME, libraryVisibility, contentObj.id, newLastModified, oldLastModified, function(err) {
            if (err) {
                errs.push(err);
            }

            if (removedMembers && removedMembers.length > 0) {
                // Delete the item from the removed members libraries
                return LibraryAPI.Index.remove(ContentConstants.library.CONTENT_LIBRARY_INDEX_NAME, removedMembers, contentObj.id, oldLastModified, function(err) {
                    if (err) {
                        errs.push(err);
                    }

                    return _doCallback();
                });
            } else {
                // No removals needed, just return
                return _doCallback();
            }
        });
    });
};


///////////////////////
// Utility functions //
///////////////////////

/**
 * Creates a Content item from a Cassandra row.
 *
 * @param  {Row}        row     Cassandra Row
 * @return {Content}            Converted content object
 * @api private
 */
var _rowToContent = function(row) {
    var hash = Cassandra.rowToHash(row);
    var contentObj = new Content(hash.tenantAlias, hash.contentId, hash.visibility, hash.displayName, hash.description, hash.resourceSubType, hash.createdBy, hash.created, hash.lastModified, hash.latestRevisionId);
    if (contentObj.resourceSubType === 'file') {
        contentObj.filename = hash.filename;
        contentObj.size = (hash.size) ? parseInt(hash.size, 10) : 0;
        contentObj.mime = hash.mime;
    } else if (contentObj.resourceSubType === 'link') {
        contentObj.link = hash.link;
    } else if (contentObj.resourceSubType === 'collabdoc') {
        contentObj.etherpadGroupId = hash.etherpadGroupId;
        contentObj.etherpadPadId = hash.etherpadPadId;
    }

    if (hash.previews) {
        try {
            contentObj.previews = JSON.parse(hash.previews);
        } catch (err) {
            contentObj.previews = {};
            log().warn({'hash': hash}, 'Could not parse the previews object');
        }
    } else {
        // If there was no previews field selected, simply replace it with an empty object
        contentObj.previews = {};
    }

    return contentObj;
};
