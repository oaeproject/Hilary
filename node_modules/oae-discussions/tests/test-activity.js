/*
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');
var fs = require('fs');

var AuthzUtil = require('oae-authz/lib/util');
var log = require('oae-logger').logger('test-activity');
var PreviewConstants = require('oae-preview-processor/lib/constants');
var RestAPI = require('oae-rest');
var RestContext = require('oae-rest/lib/model').RestContext;
var TestsUtil = require('oae-tests');

var ActivityTestsUtil = require('oae-activity/lib/test/util');
var EmailTestsUtil = require('oae-email/lib/test/util');

describe('Discussion Activity', function() {

    // Rest contexts that can be used performing rest requests
    var anonymousCamRestContext = null;
    var camAdminRestContext = null;
    var globalAdminRestContext = null;

    var suitable_files = null;
    var suitable_sizes = null;

    /**
     * Function that will fill up the tenant admin and anymous rest context
     */
    before(function(callback) {
        // Fill up the anonymous cam rest context
        anonymousCamRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host);
        // Fill up global admin rest context
        camAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.cam.host);
        globalAdminRestContext = TestsUtil.createGlobalAdminRestContext();
        callback();
    });

    describe('Activity Entity Models', function() {

        describe('Discussions', function() {

            /**
             * Test that verifies the properties of the discussion entity
             */
            it('verify the discussion entity model contains the correct information', function(callback) {
                TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users) {
                    var simon = _.values(users)[0];

                    RestAPI.Discussions.createDiscussion(simon.restContext, 'Goats', 'Start discussing this sweet topic', 'loggedin', null, null, function(err, discussion) {
                        assert.ok(!err);
                        assert.ok(discussion);

                        // Simon should've received a discussion activity in his stream
                        ActivityTestsUtil.collectAndGetActivityStream(simon.restContext, simon.user.id, null, function(err, activityStream) {
                            assert.ok(!err);
                            var entity = activityStream.items[0];
                            assert.equal(entity['oae:activityType'], 'discussion-create');
                            assert.equal(entity['verb'], 'create');

                            // Assert Simon is the actor.
                            assert.equal(entity.actor['oae:id'], simon.user.id);

                            // Assert the discussion is the object.
                            assert.equal(entity.object['oae:id'], discussion.id);
                            assert.equal(entity.object['oae:visibility'], discussion.visibility);
                            assert.equal(entity.object['oae:profilePath'], discussion.profilePath);
                            assert.equal(entity.object['displayName'], discussion.displayName);
                            callback();
                        });
                    });
                });
            });

            /**
             * Test that verifies the properties of the discussion entity when updating.
             */
            it('verify the discussion entity model contains the correct information when updating a discussion', function(callback) {
                TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users) {
                    var simon = _.values(users)[0];

                    RestAPI.Discussions.createDiscussion(simon.restContext, 'Bonobos', 'Start discussing this sweet topic', 'loggedin', null, null, function(err, discussion) {
                        assert.ok(!err);
                        assert.ok(discussion);

                        RestAPI.Discussions.updateDiscussion(simon.restContext, discussion.id, {'displayName': 'Not bonobos'}, function(err, updatedDiscussion) {
                            assert.ok(!err);

                            // Simon should've received two entries in his stream (1 create and 1 update)
                            ActivityTestsUtil.collectAndGetActivityStream(simon.restContext, simon.user.id, null, function(err, activityStream) {
                                assert.ok(!err);
                                var entity = activityStream.items[0];
                                assert.equal(entity['oae:activityType'], 'discussion-update');
                                assert.equal(entity['verb'], 'update');

                                // Assert Simon is the actor.
                                assert.equal(entity.actor['oae:id'], simon.user.id);

                                // Assert the discussion is the object.
                                assert.equal(entity.object['oae:id'], discussion.id);
                                assert.equal(entity.object['displayName'], 'Not bonobos');
                                assert.equal(entity.object['oae:profilePath'], discussion.profilePath);

                                RestAPI.Discussions.updateDiscussion(simon.restContext, discussion.id, {'visibility': 'public'}, function(err, updatedDiscussion) {
                                    assert.ok(!err);

                                    ActivityTestsUtil.collectAndGetActivityStream(simon.restContext, simon.user.id, null, function(err, activityStream) {
                                        assert.ok(!err);
                                        var entity = activityStream.items[0];
                                        assert.equal(entity['oae:activityType'], 'discussion-update-visibility');
                                        assert.equal(entity['verb'], 'update');
                                        callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        describe('Discussion messages', function() {
            /**
             * Test that verifies the properies of a discussion message.
             */
            it('verify the discussion message entity model contains the correct information', function(callback) {
                TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users) {
                    var simon = _.values(users)[0];
                    var nico = _.values(users)[1];

                    RestAPI.Discussions.createDiscussion(simon.restContext, 'Something something discussworthy', 'Start discussing this sweet topic', 'loggedin', null, null, function(err, discussion) {
                        assert.ok(!err);
                        assert.ok(discussion);

                        RestAPI.Discussions.createMessage(simon.restContext, discussion.id, 'My message', null, function(err, message) {
                            assert.ok(!err);
                            ActivityTestsUtil.collectAndGetActivityStream(simon.restContext, simon.user.id, null, function(err, activityStream) {
                                assert.ok(!err);
                                var entity = activityStream.items[0];
                                assert.equal(entity['oae:activityType'], 'discussion-message');
                                assert.equal(entity['verb'], 'post');
                                // Assert Simon is the actor.
                                assert.equal(entity.actor['oae:id'], simon.user.id);

                                // Assert the discussion is the target.
                                assert.equal(entity.target['oae:id'], discussion.id);
                                assert.equal(entity.target['displayName'], discussion.displayName);
                                assert.equal(entity.target['oae:profilePath'], discussion.profilePath);

                                // Assert the message is the object.
                                assert.equal(entity.object['oae:id'], message.id);
                                assert.equal(entity.object['oae:messageBoxId'], message.messageBoxId);
                                assert.equal(entity.object['oae:threadKey'], message.threadKey);
                                assert.equal(entity.object['content'], message.body);
                                assert.equal(entity.object['published'], message.created);
                                assert.equal(entity.object['objectType'], 'comment');
                                assert.equal(entity.object['id'], 'http://' + global.oaeTests.tenants.cam.host + '/api/discussion/' + discussion.id + '/messages/' + message.created);

                                // Nico replies
                                RestAPI.Discussions.createMessage(nico.restContext, discussion.id, 'A reply', message.created, function(err, nicosMessage) {
                                    assert.ok(!err);

                                    ActivityTestsUtil.collectAndGetActivityStream(simon.restContext, simon.user.id, null, function(err, activityStream) {
                                        assert.ok(!err);

                                        // The first item should still be a discussion-message.
                                        // The object and actor will now be collections rather than a single message/person.
                                        var entity = activityStream.items[0];
                                        assert.equal(entity['oae:activityType'], 'discussion-message');

                                        // The object should be an oae:collection containing 2 messages (the original message and the reply)
                                        assert.equal(entity.object['objectType'], 'collection');
                                        assert.ok(entity.object['oae:collection']);
                                        assert.equal(entity.object['oae:collection'].length, 2);
                                        var originalMessage = _.find(entity.object['oae:collection'], function(activityMessage) { return activityMessage['oae:id'] === message.id; });
                                        assert.ok(originalMessage);
                                        assert.equal(originalMessage['oae:id'], message.id);
                                        assert.equal(originalMessage['content'], message.body);
                                        assert.equal(originalMessage['author']['oae:id'], simon.user.id);
                                        assert.equal(originalMessage['oae:tenant']['alias'], global.oaeTests.tenants.cam.alias);

                                        var reply = _.find(entity.object['oae:collection'], function(activityMessage) { return activityMessage['oae:id'] === nicosMessage.id; });
                                        assert.ok(reply);
                                        assert.equal(reply['oae:id'], nicosMessage.id);
                                        assert.equal(reply['oae:messageBoxId'], nicosMessage.messageBoxId);
                                        assert.equal(reply['oae:threadKey'], nicosMessage.threadKey);
                                        assert.equal(reply['oae:tenant']['alias'], global.oaeTests.tenants.cam.alias);
                                        assert.equal(reply['content'], nicosMessage.body);
                                        assert.equal(reply['published'], nicosMessage.created);
                                        assert.equal(reply['author']['oae:id'], nico.user.id);
                                        assert.ok(reply['inReplyTo']);
                                        assert.equal(reply['inReplyTo']['oae:id'], message.id);

                                        // Verify both actors are present.
                                        assert.equal(entity.actor['objectType'], 'collection');
                                        var simonEntity = _.find(entity.actor['oae:collection'], function(userEntity) { return userEntity['oae:id'] === simon.user.id; });
                                        assert.ok(simonEntity);
                                        assert.equal(simonEntity['oae:id'], simon.user.id);
                                        assert.equal(simonEntity['oae:profilePath'], '/user/' + simon.user.tenant.alias + '/' + AuthzUtil.getResourceFromId(simon.user.id).resourceId);

                                        var nicoEntity = _.find(entity.actor['oae:collection'], function(userEntity) { return userEntity['oae:id'] === nico.user.id; });
                                        assert.ok(nicoEntity);
                                        assert.equal(nicoEntity['oae:id'], nico.user.id);
                                        assert.equal(nicoEntity['oae:profilePath'], '/user/' + nico.user.tenant.alias + '/' + AuthzUtil.getResourceFromId(nico.user.id).resourceId);

                                        callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });


    describe('Discussion Activities', function() {

        /**
         * Test that verifies when a discussion is updated, an activity is generated for the action
         */
        it('verify updating a discussion results in an activity being generated', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users) {
                var simon = _.values(users)[0];

                // Create a discussion to share
                RestAPI.Discussions.createDiscussion(simon.restContext, 'Something something discussworthy', 'Start discussing this sweet topic', 'loggedin', null, null, function(err, discussion) {
                    assert.ok(!err);
                    assert.ok(discussion);

                    RestAPI.Discussions.updateDiscussion(simon.restContext, discussion.id, {'displayName': 'Blah!'}, function(err, discussionProfile) {
                        assert.ok(!err);
                        assert.ok(discussionProfile);

                        // Collect the activities
                        ActivityTestsUtil.collectAndGetActivityStream(simon.restContext, simon.user.id, null, function(err, activityStream) {
                            assert.ok(!err);

                            // Verify the discussion-share activity is the newest one in the feed
                            var activity = activityStream.items[0];
                            assert.ok(activity);
                            assert.equal(activity['oae:activityType'], 'discussion-update');
                            assert.equal(activity.actor['oae:id'], simon.user.id);
                            assert.equal(activity.object['oae:id'], discussion.id);

                            return callback();
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies when a discussion is shared, an activity is generated for the action
         */
        it('verify sharing a discussion results in an activity being generated', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users) {
                var simon = _.values(users)[0];
                var nico = _.values(users)[1];

                // Create a discussion to share
                RestAPI.Discussions.createDiscussion(simon.restContext, 'Something something discussworthy', 'Start discussing this sweet topic', 'loggedin', null, null, function(err, discussion) {
                    assert.ok(!err);
                    assert.ok(discussion);

                    // Simon shares the discussion with nicolaas
                    RestAPI.Discussions.shareDiscussion(simon.restContext, discussion.id, [nico.user.id], function(err) {
                        assert.ok(!err);

                        // Collect the activities
                        ActivityTestsUtil.collectAndGetActivityStream(simon.restContext, simon.user.id, null, function(err, activityStream) {
                            assert.ok(!err);

                            // Verify the discussion-share activity is the newest one in the feed
                            var activity = activityStream.items[0];
                            assert.ok(activity);
                            assert.equal(activity['oae:activityType'], 'discussion-share');
                            assert.equal(activity.actor['oae:id'], simon.user.id);
                            assert.equal(activity.object['oae:id'], discussion.id);
                            assert.equal(activity.target['oae:id'], nico.user.id);

                            return callback();
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies when a user is added as a manager to a discussion, a share activity is generated
         */
        it('verify updating permissions of a discussion results in a share activity being generated', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users) {
                var simon = _.values(users)[0];
                var branden = _.values(users)[1];

                // Create a discussion to share
                RestAPI.Discussions.createDiscussion(simon.restContext, 'Something something discussworthy', 'Start discussing this sweet topic', 'loggedin', null, null, function(err, discussion) {
                    assert.ok(!err);
                    assert.ok(discussion);

                    var memberUpdates = {};
                    memberUpdates[branden.user.id] = 'member';

                    // Simon shares the discussion with Branden
                    RestAPI.Discussions.updateDiscussionMembers(simon.restContext, discussion.id, memberUpdates, function(err) {
                        assert.ok(!err);

                        // Collect the activities
                        ActivityTestsUtil.collectAndGetActivityStream(simon.restContext, simon.user.id, null, function(err, activityStream) {
                            assert.ok(!err);

                            // Verify the discussion-share activity is the newest one in the feed
                            var activity = activityStream.items[0];
                            assert.ok(activity);
                            assert.equal(activity['oae:activityType'], 'discussion-share');
                            assert.equal(activity.actor['oae:id'], simon.user.id);
                            assert.equal(activity.object['oae:id'], discussion.id);
                            assert.equal(activity.target['oae:id'], branden.user.id);

                            return callback();
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies when a user adds a discussion to their library, an activity is generated
         */
        it('verify adding a discussion to your library results in an discussion-ad-to-library activity being generated', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users) {
                var simon = _.values(users)[0];
                var nico = _.values(users)[1];

                // Create a discussion to share
                RestAPI.Discussions.createDiscussion(simon.restContext, 'Something something discussworthy', 'Start discussing this sweet topic', 'loggedin', null, null, function(err, discussion) {
                    assert.ok(!err);
                    assert.ok(discussion);

                    // Nicolaas adds the discussion to his library
                    RestAPI.Discussions.shareDiscussion(nico.restContext, discussion.id, [nico.user.id], function(err) {
                        assert.ok(!err);

                        // Collect the activities
                        ActivityTestsUtil.collectAndGetActivityStream(nico.restContext, nico.user.id, null, function(err, activityStream) {
                            assert.ok(!err);

                            // Verify the discussion-share activity is the newest one in the feed
                            var activity = activityStream.items[0];
                            assert.ok(activity);
                            assert.equal(activity['oae:activityType'], 'discussion-add-to-library');
                            assert.equal(activity.actor['oae:id'], nico.user.id);
                            assert.equal(activity.object['oae:id'], discussion.id);

                            return callback();
                        });
                    });
                });
            });
        });
    });

    describe('Email', function() {

        /**
         * Test that verifies an email is sent to the discussion managers when someone posts a message, and that private users
         * are appropriately scrubbed.
         */
        it('verify discussion message email and privacy', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 3, function(err, users) {
                assert.ok(!err);

                var mrvisser = _.values(users)[0];
                var simong = _.values(users)[1];
                var nicolaas = _.values(users)[2];

                // Generate e-mail addresses
                mrvisser.user.email = 'mrvisser' + Math.random() + '@email.com';
                simong.user.email = 'simong' + Math.random() + '@email.com';

                // Simon is private and mrvisser is public
                var mrvisserUpdate = {'email': mrvisser.user.email};
                var simongUpdate = {
                    'email': simong.user.email,
                    'visibility': 'private',
                    'publicAlias': 'swappedFromPublicAlias'
                };

                // Update the users
                RestAPI.User.updateUser(mrvisser.restContext, mrvisser.user.id, mrvisserUpdate, function(err) {
                    assert.ok(!err);

                    RestAPI.User.updateUser(simong.restContext, simong.user.id, simongUpdate, function(err) {
                        assert.ok(!err);

                        // Create the discussion
                        RestAPI.Discussions.createDiscussion(mrvisser.restContext, 'A talk', 'about computers', 'public', [], [], function(err, discussion) {
                            assert.ok(!err);

                            // Post a new message
                            RestAPI.Discussions.createMessage(simong.restContext, discussion.id, 'Nice discussion, would read again', null, function(err, simongMessage) {
                                assert.ok(!err);

                                EmailTestsUtil.collectAndFetchEmails(function(emails) {
                                    // There should be exactly one email, the one sent to mrvisser (manager of discussion receives discussion-message notification)
                                    assert.equal(emails.length, 1);

                                    var stringEmail = JSON.stringify(emails[0]);
                                    var email = emails[0]._message;

                                    // Sanity check that the email is to mrvisser
                                    assert.equal(email.to, mrvisser.user.email);

                                    // Ensure simong's private info is nowhere to be found
                                    assert.equal(stringEmail.indexOf(simong.user.displayName), -1);
                                    assert.equal(stringEmail.indexOf(simong.user.email), -1);
                                    assert.equal(stringEmail.indexOf(simong.user.locale), -1);
                                    assert.equal(stringEmail.indexOf(simong.user.timezone), -1);

                                    // The email should contain the public alias
                                    assert.notEqual(stringEmail.indexOf('swappedFromPublicAlias'), -1);

                                    // Send a message as nicolaas and ensure the recent commenter, simong receives an email about it
                                    RestAPI.Discussions.createMessage(nicolaas.restContext, discussion.id, 'I have a computer, too', null, function(err, nicolaasMessage) {
                                        assert.ok(!err);

                                        EmailTestsUtil.collectAndFetchEmails(function(emails) {
                                            // There should be 2 emails this time, one to the manager and one to the recent commenter, simong
                                            assert.equal(emails.length, 2);

                                            var emailAddresses = [emails[0]._message.to, emails[1]._message.to];
                                            assert.ok(_.contains(emailAddresses, simong.user.email));
                                            assert.ok(_.contains(emailAddresses, mrvisser.user.email));
                                            return callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies an email is sent to the members when a discussion is created, and that private users are
         * appropriately scrubbed.
         */
        it('verify discussion-create email and privacy', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users) {
                assert.ok(!err);

                var mrvisser = _.values(users)[0];
                var simong = _.values(users)[1];

                // Generate e-mail addresses
                mrvisser.user.email = 'mrvisser' + Math.random() + '@email.com';
                simong.user.email = 'simong' + Math.random() + '@email.com';

                // Simon is private and mrvisser is public
                var mrvisserUpdate = {'email': mrvisser.user.email};
                var simongUpdate = {
                    'email': simong.user.email,
                    'visibility': 'private',
                    'publicAlias': 'swappedFromPublicAlias'
                };

                // Update the users
                RestAPI.User.updateUser(mrvisser.restContext, mrvisser.user.id, mrvisserUpdate, function(err) {
                    assert.ok(!err);

                    RestAPI.User.updateUser(simong.restContext, simong.user.id, simongUpdate, function(err) {
                        assert.ok(!err);

                        // Create the link, sharing it with mrvisser during the creation step. We will ensure he gets an email about it
                        RestAPI.Discussions.createDiscussion(simong.restContext, 'A talk', 'not about computers', 'public', [], [mrvisser.user.id], function(err, discussion) {
                            assert.ok(!err);

                            // Mrvisser should get an email, with simong's information scrubbed
                            EmailTestsUtil.collectAndFetchEmails(function(emails) {
                                // There should be exactly one email, the one sent to mrvisser
                                assert.equal(emails.length, 1);

                                var stringEmail = JSON.stringify(emails[0]);
                                var email = emails[0]._message;

                                // Sanity check that the email is to mrvisser
                                assert.equal(email.to, mrvisser.user.email);

                                // Ensure simong's private info is nowhere to be found
                                assert.equal(stringEmail.indexOf(simong.user.displayName), -1);
                                assert.equal(stringEmail.indexOf(simong.user.email), -1);
                                assert.equal(stringEmail.indexOf(simong.user.locale), -1);
                                assert.equal(stringEmail.indexOf(simong.user.timezone), -1);

                                // The email should contain the public alias
                                assert.notEqual(stringEmail.indexOf('swappedFromPublicAlias'), -1);

                                callback();
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies an email is sent to the target users when a discussion is shared, and that private users are
         * appropriately scrubbed.
         */
        it('verify discussion-share email and privacy', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users) {
                assert.ok(!err);

                var mrvisser = _.values(users)[0];
                var simong = _.values(users)[1];

                // Generate e-mail addresses
                mrvisser.user.email = 'mrvisser' + Math.random() + '@email.com';
                simong.user.email = 'simong' + Math.random() + '@email.com';

                // Simon is private and mrvisser is public
                var mrvisserUpdate = {'email': mrvisser.user.email};
                var simongUpdate = {
                    'email': simong.user.email,
                    'visibility': 'private',
                    'publicAlias': 'swappedFromPublicAlias'
                };

                // Update the users
                RestAPI.User.updateUser(mrvisser.restContext, mrvisser.user.id, mrvisserUpdate, function(err) {
                    assert.ok(!err);

                    RestAPI.User.updateUser(simong.restContext, simong.user.id, simongUpdate, function(err) {
                        assert.ok(!err);

                        // Create the link, then share it with mrvisser. We will ensure that mrvisser gets the email about the share
                        RestAPI.Discussions.createDiscussion(simong.restContext, 'A talk', 'about the moon', 'public', [], [], function(err, discussion) {
                            assert.ok(!err);

                            // Collect the createLink activity
                            EmailTestsUtil.collectAndFetchEmails(function(emails) {

                                RestAPI.Discussions.shareDiscussion(simong.restContext, discussion.id, [mrvisser.user.id], function(err) {
                                    assert.ok(!err);

                                    // Mrvisser should get an email, with simong's information scrubbed
                                    EmailTestsUtil.collectAndFetchEmails(function(emails) {
                                        // There should be exactly one email, the one sent to mrvisser
                                        assert.equal(emails.length, 1);

                                        var stringEmail = JSON.stringify(emails[0]);
                                        var email = emails[0]._message;

                                        // Sanity check that the email is to mrvisser
                                        assert.equal(email.to, mrvisser.user.email);

                                        // Ensure simong's private info is nowhere to be found
                                        assert.equal(stringEmail.indexOf(simong.user.displayName), -1);
                                        assert.equal(stringEmail.indexOf(simong.user.email), -1);
                                        assert.equal(stringEmail.indexOf(simong.user.locale), -1);
                                        assert.equal(stringEmail.indexOf(simong.user.timezone), -1);

                                        // The email should contain the public alias
                                        assert.notEqual(stringEmail.indexOf('swappedFromPublicAlias'), -1);
                                        callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });
});
