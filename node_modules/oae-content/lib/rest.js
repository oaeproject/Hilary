/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var Util = require('oae-util/lib/util');
var OAE = require('oae-util/lib/oae');

var ContentAPI = require('./api');


/*!
 * Create a new piece of content
 */
OAE.tenantServer.post('/api/content/create', function(req, res) {
    req.telemetryUrl = '/api/content/create';
    // Pick the managers and viewers off the request
    var additionalMembers = {};
    if (req.body.managers) {
        if (!Array.isArray(req.body.managers)) {
            req.body.managers = [req.body.managers];
        }
        for (var i = 0; i < req.body.managers.length; i++) {
            additionalMembers[req.body.managers[i]] = 'manager';
        }
    }
    if (req.body.viewers) {
        if (!Array.isArray(req.body.viewers)) {
            req.body.viewers = [req.body.viewers];
        }
        for (var j = 0; j < req.body.viewers.length; j++) {
            additionalMembers[req.body.viewers[j]] = 'viewer';
        }
    }

    // Link creation
    if (req.body.contentType === 'link') {
        ContentAPI.createLink(req.ctx, req.body.displayName, req.body.description, req.body.visibility, req.body.link, additionalMembers, function(err, contentObj) {
            if (err) {
                return res.send(err.code, err.msg);
            }
            res.send(201, contentObj);
        });
    // File creation
    } else if (req.body.contentType === 'file') {
        var uploadedFile = null;
        if (req.files) {
            uploadedFile = req.files.file;
        }
        ContentAPI.createFile(req.ctx, req.body.displayName, req.body.description, req.body.visibility, additionalMembers, uploadedFile, function(err, contentObj) {
            if (err) {
                // At this point we can use regular responses again.
                return res.send(err.code, err.msg);
            }
            res.send(201, contentObj);
        });
    // Sakai doc creation
    } else if (req.body.contentType === 'sakaidoc') {
        ContentAPI.createSakaiDoc(req.ctx, req.body.displayName, req.body.description, req.body.visibility, additionalMembers, function(err, contentObj) {
            if (err) {
                return res.send(err.code, err.msg);
            }
            res.send(201, contentObj);
        });
    // Not a recognized file type
    } else {
        res.send(400, 'Unrecognized contentType. Accepted values are "link", "file" and "sakaidoc"');
    }
});

/*!
 * Delete a piece of content
 */
OAE.tenantServer.del('/api/content/:contentId', function(req, res) {
    req.telemetryUrl = '/api/content/id';
    ContentAPI.deleteContent(req.ctx, req.params.contentId, function(err) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200);
    });
});

/*!
 * Get a full content profile for a piece of content
 */
OAE.tenantServer.get('/api/content/:contentId', function(req, res) {
    req.telemetryUrl = '/api/content/id';
    ContentAPI.getFullContentProfile(req.ctx, req.params.contentId, function(err, contentProfile) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, contentProfile);
    });
});

/*!
 * Edit content metadata
 */
OAE.tenantServer.post('/api/content/:contentId', function(req, res) {
    req.telemetryUrl = '/api/content/id';
    ContentAPI.updateContentMetadata(req.ctx, req.params.contentId, req.body, function(err) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200);
    });
});

/*!
 * Download the latest version of a piece of content
 */
OAE.tenantServer.get('/api/content/:contentId/download', function(req, res) {
    req.telemetryUrl = '/api/content/id/download';
    ContentAPI.getRevision(req.ctx, req.params.contentId, null, function(err, revision) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        handleDownloadLink(res, revision);
    });
});

/*!
 * Download a specific version of a piece of content.
 */
OAE.tenantServer.get('/api/content/:contentId/download/:revisionId', function(req, res) {
    req.telemetryUrl = '/api/content/id/download/version';
    ContentAPI.getRevision(req.ctx, req.params.contentId, req.params.revisionId, function(err, revision) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        handleDownloadLink(res, revision);
    });
});

/*!
 * Upload a new version
 */
OAE.tenantServer.post('/api/content/:contentId/newversion', function(req, res) {
    req.telemetryUrl = '/api/content/id/newversion';
    if (!req.files || !req.files.file) {
        return res.send(400, 'Missing file parameter');
    }

    ContentAPI.updateFileBody(req.ctx, req.params.contentId, req.files.file, function(err) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200);
    });
});

/*!
 * Attach a preview item to a piece of content.
 */
OAE.tenantServer.post('/api/content/:contentId/previews', function(req, res) {
    req.telemetryUrl = '/api/content/id/previews';
    var metadata = null;
    var sizes = null;
    try {
        metadata = JSON.parse(req.body.metadata);
        sizes = JSON.parse(req.body.sizes);
    } catch (err) {
        return res.send(400, 'Malformed metadata object. Expected proper JSON.');
    }
    ContentAPI.setPreviewItems(req.ctx, req.params.contentId, req.body.status, req.files, sizes, metadata, function(err) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(201);
    });
});

/*!
 * Get a list of preview items for the latest revision
 */
OAE.tenantServer.get('/api/content/:contentId/previews', function(req, res) {
    req.telemetryUrl = '/api/content/id/previews';
    ContentAPI.getPreviewItems(req.ctx, req.params.contentId, function(err, previews) {
        if (err) {
            return res.send(err.code, err.msg);
        }

        res.send(200, previews);
    });
});

/*!
 * Download a preview item.
 */
OAE.tenantServer.get('/api/content/:contentId/previews/:item', function(req, res) {
    req.telemetryUrl = '/api/content/id/previews/download/item';
    var signature = {
        'signature': req.query.signature,
        'expires': req.query.expires,
        'lastModified': req.query.lastmodified
    };
    ContentAPI.verifySignedPreviewItem(req.ctx, req.params.contentId, req.params.item, signature, function(err, result) {
        if (err) {
            return res.send(err.code, err.msg);
        }

        handleDownloadLink(res, result);
    });
});

/*!
 * Content revisions
 */
OAE.tenantServer.get('/api/content/:contentId/revisions', function(req, res) {
    req.telemetryUrl = '/api/content/id/revisions';
    ContentAPI.getRevisions(req.ctx, req.params.contentId, req.query.start, req.query.limit, function(err, revisions) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, revisions);
    });
});

/*!
 * Content membership list
 */
OAE.tenantServer.get('/api/content/:contentId/members', function(req, res) {
    req.telemetryUrl = '/api/content/id/members';
    ContentAPI.getContentMembers(req.ctx, req.params.contentId, req.query.start, req.query.limit, function(err, members){
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, {'results': members});
    });
});

/*!
 * Set content permission
 */
OAE.tenantServer.post('/api/content/:contentId/members', function(req, res) {
    req.telemetryUrl = '/api/content/id/members';
    // Parse the incoming false values
    var requestKeys = _.keys(req.body);
    for (var r = 0; r < requestKeys.length; r++) {
        req.body[requestKeys[r]] = Util.castToBoolean(req.body[requestKeys[r]]);
    }
    ContentAPI.setContentPermissions(req.ctx, req.params.contentId, req.body, function(err) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200);
    });
});

/*!
 * Share content
 */
OAE.tenantServer.post('/api/content/:contentId/share', function(req, res) {
    req.telemetryUrl = '/api/content/id/share';
    // Make sure viewer is an array
    if (!Array.isArray(req.body.viewers)) {
        req.body.viewers = [req.body.viewers];
    }
    ContentAPI.shareContent(req.ctx, req.params.contentId, req.body.viewers, function(err) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200);
    });
});

/*!
 * Comments
 */

OAE.tenantServer.post('/api/content/:contentId/comments', function(req, res) {
    ContentAPI.createComment(req.ctx, req.params.contentId, req.body.body, req.body.replyTo, function(err, comment) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(201, comment);
    });
});

OAE.tenantServer.get('/api/content/:contentId/comments', function(req, res) {
    ContentAPI.getComments(req.ctx, req.params.contentId, req.query.start, req.query.limit, function(err, comments) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, {'results': comments});
    });
});

OAE.tenantServer.del('/api/content/:contentId/comments/:commentId', function(req, res) {
    ContentAPI.deleteComment(req.ctx, req.params.contentId, req.params.commentId, function(err, deleted) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, deleted);
    });
});

/*!
 * Library
 */
OAE.tenantServer.get('/api/content/library/:principalId', function(req, res) {
    req.telemetryUrl = '/api/content/library/id';
    ContentAPI.getLibraryItems(req.ctx, req.params.principalId, req.query.start, req.query.limit, function(err, items) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, {'results': items});
    });
});

/*!
 * Download a file, verification happens via a signature in the querystring.
 * By adding a signature an expensive access check is avoided.
 * This should only be used for items that do not have a high security risk attached to them.
 */
OAE.tenantServer.get('/api/download/signed', function(req, res) {
    req.telemetryUrl = '/api/download/signed';
    ContentAPI.verifySignedUri(req.ctx, req.query.uri, req.query.expires, req.query.signature, function(err, data) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        handleDownloadLink(res, data);
    });
});

/**
 * Sends the correct HTTP response depending on a link object.
 * @param {Response}    res         The Express Response object.
 * @param {Revision}    revision    A revision object
 */
var handleDownloadLink = function(res, revision) {
    var link = revision.link;
    // The link object is passed on from the storage backends.
    // These will respond with the appropriate HTTP status code and links.
    // The app servers should never be responsible for streaming downloaded
    // files to the client.

    // A 204 suggest that the LB (nginx, apache, lighthttpd, ..) will be handling the download via the x-sendfile mechanisme.
    if (link.code === 204) {
        // nginx
        res.setHeader('X-Accel-Redirect', link.url);

        // apache
        res.setHeader('X-Sendfile', link.url);

        // lighthttpd
        res.setHeader('X-LIGHTTPD-send-file', link.url);

        res.setHeader('Content-Disposition', 'attachment; filename="' + revision.opts.filename + '"');
        res.send(204, link.url);

    // A 301 or 302 will redirect the user to a url that allows him to download the file.
    // It's up to the storage backend to create a secure URL with the endpoint.
    // In case of S3, this happens via a signed url.
    } else if (link.code === 301 || link.code === 302) {
        res.setHeader('Location', link.url);
        res.send(link.code);

    // In all other cases we respond with a 404.
    } else {
        res.send(404);
    }
};
