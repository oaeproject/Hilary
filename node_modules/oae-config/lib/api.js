/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var clone = require('clone');

var Cassandra = require('oae-util/lib/cassandra');
var Util = require('oae-util/lib/util');
var IO = require('oae-util/lib/io');
var Modules = require('oae-util/lib/modules');
var OAE = require('oae-util/lib/oae');
var Pubsub = require('oae-util/lib/pubsub');
var TenantAPI = require('oae-tenants');
var Validator = require('oae-util/lib/validator').Validator;
var log = require('oae-logger').logger('oae-config');

var Fields = require('./fields');

var config = null;
var cachedConfiguration = {};

/**
 * Catches a published message from the oae-config module and executes functions that bring the cached configuration up to date
 * 
 * @param  {String}  receivedMessage  The message sent out to the cluster, provides information on the event that took place (e.g. `cam config updated`)
 * @api private
 */
Pubsub.on('oae-config', function(receivedMessage) {
    // Messages are of the form:
    //      cam config updated
    //      gt started
    var tenantAlias = receivedMessage.split(' ')[0];
    // If the global tenant has been updated all tenants need an update
    if (tenantAlias === config.servers.globalAdminAlias) {
        initializeConfig(config);
    } else {
        getConfigFromCassandra(tenantAlias, function() {});
    }
});

/**
 * Gets a single configuration value for a tenant from the cached configuration
 * 
 * @param   {String}    moduleId  The ID of the module to get configuration of
 * @return  {Function}  getValue  Function that returns the cached value of the feature's element in a module.
 */
module.exports.config = function(moduleId) {
    var validator = new Validator();
    validator.check(moduleId, {'code': 400, 'msg': 'Missing the moduleId parameter'}).notEmpty();
    if (validator.hasErrors()) {
        return validator.getFirstError();
    }

    return {
        /**
         * Returns the cached value for the feature's element in a module.
         * @param   {String}  tenantAlias          The tenantAlias to get the config value from. e.g. `cam`
         * @param   {String}  feature              The feature to get the element's value from. e.g. `twitter`
         * @param   {String}  element              The element to get the config value from. e.g. `enabled`
         * @return  {Object}  cachedConfiguration  Returns a single configuration value for a feature's element in a module e.g. `true`
         */
        getValue: function(tenantAlias, feature, element) {
            var validator = new Validator();
            validator.check(tenantAlias, {'code': 400, 'msg': 'Missing the tenantid parameter'}).notEmpty();
            validator.check(feature, {'code': 400, 'msg': 'Missing the feature parameter'}).notEmpty();
            validator.check(element, {'code': 400, 'msg': 'Missing the element parameter'}).notEmpty();
            if (validator.hasErrors()) {
                return validator.getFirstError();
            }

            return cachedConfiguration[tenantAlias][moduleId][feature].elements[element].defaultValue;
        }
    };
};

/**
 * Writes configuration to Cassandra
 * 
 * @param  {Context}    ctx                The current context.
 * @param  {String}     tenantAlias        The alias of the tenant to store config for
 * @param  {Object}     configValues       The configuration to store
 * @param  {Function}   callback           Function executed when storing the configuration completes
 * @param  {Object}     callback.err       An error object is passed as an argument if an error occurs
 */
var writeConfig = module.exports.writeConfig = function(ctx, tenantAlias, configValues, callback) {
    if (!ctx.user() || !ctx.user().isAdmin(tenantAlias)) {
        return callback({'code': 401, 'msg': 'Only authorized tenant admins can change config values'});
    }

    var validator = new Validator();
    var configFields = _.keys(configValues);
    validator.check(tenantAlias, {'code': 400, 'msg': 'Missing tenantid'}).notEmpty();
    validator.check(configFields.length, {'code': 400, 'msg': 'Missing configuration. Example configuration: {"oae-authentication/google-authentication/google-authentication-enabled": {"tenantid": "global","value": false}}'}).min(1);
    for (var i = 0; i < configFields.length; i++) {
        validator.check(configFields[i], {'code': 400, 'msg': 'The configuration field cannot be null'}).not('null');
        validator.check(configValues[configFields[i]], {'code': 400, 'msg': 'The configuration value cannot be null'}).notNull();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var q = Cassandra.constructUpsertCQL('Config', 'tenantAlias', tenantAlias, configValues, 'QUORUM');
    Cassandra.runQuery(q.query, q.parameters, function(err) {
        if (!err) {
            Pubsub.publish('oae-config', tenantAlias + ' config updated');
        }
        callback(err);
    });
};

/**
 * Reads the configuration values from cache or calls retrieveConfigFromCassandra and returns the configuration
 * 
 * @param  {String}    tenantAlias   The ID of the tenant to get configuration for
 * @param  {Function}  callback      Function executed after config has been read
 * @param  {Object}    callback.err  An error object is passed as an argument if an error occurs
 */
var getConfig = module.exports.getConfig = function(tenantAlias, callback) {
    var validator = new Validator();
    validator.check(tenantAlias, {'code': 400, 'msg': 'Missing tenantid'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    callback(false, cachedConfiguration[tenantAlias]);
};

/**
 * Reads the configuration values from Cassandra
 * 
 * @param  {String}    tenantAlias  The ID of the tenant to get configuration for
 * @param  {Function}  callback     Function executed after config has been read
 * @api private
 */
var getConfigFromCassandra = function(tenantAlias, callback) {
    var cqlParams = [config.servers.globalAdminAlias];
    if (tenantAlias !== config.servers.globalAdminAlias) {
        cqlParams.push(tenantAlias);
    }

    Cassandra.runQuery('SELECT * FROM Config USING CONSISTENCY QUORUM WHERE tenantAlias IN (?)', [cqlParams], function(err, rows) {
        if (err) {
            return callback(err);
        }

        getDefaultConfiguration(function(defaultConfig) {
            cachedConfiguration[tenantAlias] = mergeStoredConfigIntoOriginal(rows, defaultConfig);
            callback(false, cachedConfiguration[tenantAlias]);
        });
    });
};

/**
 * Merges the different configurations into one. config.json < global config < tenant config
 * 
 * @param   {Object}  cassandraConfig    Helenus object that contains configuration values stored in Cassandra. There will be one row for the global tenant, and also one row for the current tenant if the current tenant is not the global tenant
 * @param   {Object}  moduleConfig       Contains the aggregated configurations for all of the available modules
 * @return  {Object}                     All of the configuration values for all available modules, with values overriden if the current tenant has modifications to that config variable
 * @api private
 */
var mergeStoredConfigIntoOriginal = function(cassandraConfig, moduleConfig) {

    moduleConfig = clone(moduleConfig);

    // Loop over this as the config
    for (var r = 0; r < cassandraConfig.length; r++) {
        // Loop over all of the configured fields for the current tenant
        for (var c = 0; c < cassandraConfig[r].count; c++) {
            if (cassandraConfig[r][c].name !== 'tenantAlias') {
                // colHash looks like: ['moduleid', 'optionid', 'elementid']. e.g. ['oae-authentication', 'twitter', 'enabled']
                var colHash = cassandraConfig[r][c].name.split('/');
                if (moduleConfig[colHash[0]] && moduleConfig[colHash[0]][colHash[1]] && moduleConfig[colHash[0]][colHash[1]].elements[colHash[2]]) {
                    moduleConfig[colHash[0]][colHash[1]].elements[colHash[2]].defaultValue = Util.castToBoolean(cassandraConfig[r][c].value);
                }
            }
        }
    }

    return moduleConfig;
};

 /**
 * Retrieve all of the available modules and Filters out modules that don't have a configuration file in the config directory and fills an 
 * Array of modules with configuration. Every file in the /config directory of a module is read. It's assumed that the files contains valid JSON.
 * If multiple configuration files exist in one module they will be merged together.
 *
 * @param  {Function}  callback                  Callback function executed when filtering is complete. Passes through the filtered Array of config objects.
 * @param  {Object}    callback.defaultConfig    Object containing the default configuration for all of the configurable modules
 * @api private
 */
var getDefaultConfiguration = function(callback) {

    // Get the available module
    var modules = Modules.getAvailableModules();
    var configurableModules = {};
    var toDo = modules.length;
    var done = 0;

    /**
     * Gets the configuration files for a given module
     *
     * @param  {String}  dir       The URL to a module's configuration directory. e.g. '/node_modules/oae-principals/config/'
     * @param  {String}  module    The module we're getting the configuration for. e.g. 'oae-principals'
     */
    var getConfigContent = function(dir, module) {
        IO.getFileListForFolder(dir, function(files) {
            for (var ii = 0; ii < files.length; ii++) {
                var content = require(module + '/config/' + files[ii]);
                configurableModules[module] = _.extend(configurableModules[module] || {}, content[module]);
            }
            done++;
            if (done === toDo) {
                callback(configurableModules);
            }
        });
    };

    for (var i = 0; i < modules.length; i++) {
        var dir = 'node_modules/' + modules[i] + '/config/';
        getConfigContent(dir, modules[i]);
    }
};

/**
 * Initializes and caches the configuration values for all tenants
 * 
 * @param  {Object}    _config                         JSON object containing configuration values for Cassandra, Redis, logging and telemetry
 * @param  {Function}  callback                        Function executed after all tenant configuration has been retrieved
 * @param  {Object}    callback.err                    An error object is passed as an argument if an error occurs
 * @param  {Object}    callback.cachedConfiguration    The retrieved and cached configuration for all tenants
 */
var initializeConfig = module.exports.initializeConfig = function(_config, callback) {
    config = _config;
    callback = callback || function(err) {
        if (err) {
            log().error({err: err}, 'An error occured whilst initializing the configuration');
        }
    };

    TenantAPI.getAllTenants(function(err, tenants) {
        var cqlParams = [config.servers.globalAdminAlias];
        // Add the aliases of all of the tenants
        cqlParams = cqlParams.concat(_.keys(tenants));

        Cassandra.runQuery('SELECT * FROM Config USING CONSISTENCY QUORUM WHERE tenantAlias IN (?)', [cqlParams], function(err, rows) {
            if (err) {
                return callback(err);
            }

            getDefaultConfiguration(function(defaultConfig) {
                // Loop over the returned rows to get the global tenant's configuration.
                // The global tenant config will be used to merge with tenant configuration and serve as a default.
                for (var r = 0; r < rows.length; r++) {
                    if (rows[r].get('tenantAlias').value === config.servers.globalAdminAlias) {
                        cachedConfiguration[config.servers.globalAdminAlias] = mergeStoredConfigIntoOriginal([rows[r]], defaultConfig);
                        break;
                    }
                }

                // Loop over the tenant configuration and merge with the global tenant configuration
                for (var rr = 0; rr < rows.length; rr++) {
                    if (rows[rr].get('tenantAlias').value !== config.servers.globalAdminAlias) {
                        cachedConfiguration[rows[rr].get('tenantAlias').value] = mergeStoredConfigIntoOriginal([rows[rr]], cachedConfiguration[config.servers.globalAdminAlias]);
                    }
                }

                callback(null, cachedConfiguration);
            });
        });
    });
};
