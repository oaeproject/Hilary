/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var util = require('util');

var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var Cassandra = require('oae-util/lib/cassandra');

/*!
 * The visibility masks define the visibility groups that each visibility bucket contains. The
 * key is the name of the bucket, and the array of values are the visibilities of resources that
 * belong in that bucket.
 */
var visibilityMasks = {
    'private': [AuthzConstants.visibility.PUBLIC, AuthzConstants.visibility.LOGGEDIN, AuthzConstants.visibility.PRIVATE],
    'loggedin': [AuthzConstants.visibility.PUBLIC, AuthzConstants.visibility.LOGGEDIN],
    'public': [AuthzConstants.visibility.PUBLIC]
};

/**
 * The `LibraryIndexer` index is built to manage "ranked" libraries of items that are grouped according to a
 * "visibility mask". It should be used in the following way:
 *
 *  *   Multiple different modules may have multiple different types of libraries. It is expected that
 *      `indexName` namespaces the library across the whole application, and also namespaces this particular
 *      type of library within the module (e.g., For oae-principals, you may have: "Group Members" library and
 *      "Group Memberships" library)
 *  *   For a library index, there is a group of buckets for each visibility. When `insert`ing a public resource
 *      for a user's content library, you would specify the pair {"<principalId>": "public"} as an item in the
 *      `keyVisibilities` hash. This item would then be available in the private, loggedin and private buckets
 *      for the principal's library, as specified by the `visibilityMasks`
 *  *   The libraries order the resources (largest to smallest) by a `rank`. When inserting or updating a resource
 *      in the libraries, the index needs to know the `rank` of the item to insert, and if it is an update, it
 *      needs to know the previous rank to remove the old version
 *  *   There is potential for race-conditions in the index, most of which would result in duplicate items. Since
 *      these cases will result in items being closely ranked in the index, the index detects duplicates while
 *      paging and automatically repairs. As a result, it is possible if you `list` 25 items from the index, you
 *      may receive 24 (or less). Therefore, pay close attention to the `nextToken` variable to determine if the
 *      index has more items, **don't** determine if the list is empty by receiving less than the requested amount
 *      of items!
 *  *   Untimely losses of servers may result in inserts to work and deletes to faile when replacing items. This may
 *      result in duplicates that are not very close in rank, and therefore may never be automatically repaired. Either
 *      these items would have to be manually removed from the database, or a sufficiently large `list` request to the
 *      library would trigger the indexer to auto-repair it
 */
var LibraryIndex = module.exports;

/**
 * Insert a resource into a library index. This is different than `update` in that it makes no attempt
 * to delete a previously-ranked item from the index.
 *
 * @param  {String}         indexName           The name of the index to insert into. Should be namespaced to the module using it.
 * @param  {Object}         keyVisibilities     An object whose key is a unique identifier for the group of buckets, and the value is the visibility of the bucket in which to perform the insert
 * @param  {String}         resourceId          The id of the resource to insert
 * @param  {String|Number}  rank                The rank of the resource to insert
 * @param  {Function}       callback            Invoked when the process completes
 * @param  {Object}         callback.err        An error that occurred, if any
 */
var insert = module.exports.insert = function(indexName, keyVisibilities, resourceId, rank, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({
                'err': err,
                'indexName': indexName,
                'keyVisibilities': keyVisibilities,
                'resourceId': resourceId,
                'rank': rank
            }, 'Error inserting library update');
        }
    };

    var valueKey = _createValueKey(resourceId, rank);

    // Allowing the caller to specify the data may prove to be a useful performance tool where there is
    // a "light-weight" version of an item desired, which could be achieved without having to follow with
    // a multi-get (e.g., store a denormalized version of library items for light-weight view)
    var value = '1';

    var queries = [];
    _.each(visibilityMasks, function(mask, bucketName) {
        _.each(keyVisibilities, function(visibility, key) {
            if (_.contains(mask, visibility)) {
                // If this bucket contains resources of this visibility, insert it for each key
                queries.push({
                    'query': 'UPDATE LibraryIndex SET ? = ? WHERE bucketKey = ?',
                    'parameters': [valueKey, value, _createBucketKey(indexName, key, bucketName)]
                });
            }
        });
    });

    Cassandra.runBatchQuery(queries, 'QUORUM', callback);
};

/**
 * Update a resource in a library index. This will attempt to delete an old item according to an `oldRank`, and insert a
 * new item according to the `newRank`. Items will be aggressively deleted from all visibility buckets, so only the current
 * visibility is needed to determine the buckets of the insert.
 *
 * @param  {String}         indexName           The name of the index to insert into. Should be namespaced to the module using it.
 * @param  {Object}         keyVisibilities     An object whose key is a unique identifier for the group of buckets, and the value is the visibility of the bucket in which to perform the insert
 * @param  {String}         resourceId          The id of the resource to update
 * @param  {String|Number}  newRank             The rank of the resource to update
 * @param  {String|Number}  oldRank             The rank of the previous entry of the resource
 * @param  {Function}       callback            Invoked when the process completes
 * @param  {Object}         callback.err        An error that occurred, if any
 */
var update = module.exports.update = function(indexName, keyVisibilities, resourceId, newRank, oldRank, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({
                'err': err,
                'indexName': indexName,
                'keyVisibilities': keyVisibilities,
                'resourceId': resourceId,
                'newRank': newRank,
                'oldRank': oldRank
            }, 'Error inserting library update');
        }
    };

    // What we will insert into the index
    var oldValueKey = _createValueKey(resourceId, oldRank);
    var newValueKey = _createValueKey(resourceId, newRank);
    var value = '1';

    // Either we had an error or successfully set the latest last modified, so we will perform the necessary index
    // updates.
    var queries = [];

    // First delete the old version of this resource for all buckets
    _.each(visibilityMasks, function(mask, bucketName) {
        _.each(keyVisibilities, function(visibility, key) {
            queries.push({
                'query': 'DELETE ? FROM LibraryIndex WHERE bucketKey = ?',
                'parameters': [oldValueKey, _createBucketKey(indexName, key, bucketName)]
            });
        });
    });

    // Insert the new version of this resource for the buckets associated to the specified visibility
    _.each(keyVisibilities, function(visibility, key) {
        _.each(visibilityMasks, function(mask, bucketName) {
            if (_.contains(mask, visibility)) {
                // If this bucket's mask accepts this visibility, we update it with the content item
                queries.push({
                    'query': 'UPDATE LibraryIndex SET ? = ? WHERE bucketKey = ?',
                    'parameters': [newValueKey, value, _createBucketKey(indexName, key, bucketName)]
                });
            }
        });
    });

    Cassandra.runBatchQuery(queries, 'QUORUM', callback);
};

/**
 * Remove a resource from the library index.
 *
 * @param  {String}         indexName           The name of the index to insert into. Should be namespaced to the module using it.
 * @param  {String[]}       keys                An array of keys that identify buckets groups from which to remove the resource
 * @param  {String}         resourceId          The id of the resource to delete
 * @param  {String|Number}  rank                The rank of the resource to delete
 * @param  {Function}       callback            Invoked when the process completes
 * @param  {Object}         callback.err        An error that occurred, if any
 */
var remove = module.exports.remove = function(indexName, keys, resourceId, rank, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({
                'err': err,
                'indexName': indexName,
                'keys': keys,
                'resourceId': resourceId,
                'visibility': visibility,
                'newRank': newRank,
                'oldRank': oldRank
            }, 'Error removing resource from library');
        }
    };
    var valueKey = _createValueKey(resourceId, rank);

    // Delete this resource for all visibility buckets
    var queries = [];
    _.each(visibilityMasks, function(mask, bucketName) {
        _.each(keys, function(key) {
            queries.push({
                'query': 'DELETE ? FROM LibraryIndex WHERE bucketKey = ?',
                'parameters': [valueKey, _createBucketKey(indexName, key, bucketName)]
            });
        });
    });

    Cassandra.runBatchQuery(queries, 'QUORUM', callback);
};

/**
 * Retrieve an ordered list of items from the index
 *
 * @param  {String}     indexName               The name of the index to list. Should be namespaced to the module using it
 * @param  {Object}     key                     A key that identifies the bucket group that should be listed
 * @param  {String}     visibility              The visibility of the bucket that should be listed
 * @param  {String}     [start]                 Determines the rank at which items are returned for paging purposed. If not provided, the first x elements will be returned
 * @param  {Number}     [limit]                 Number of items to return. Will default to 10 if not provided
 * @param  {Object}     [opts]                  Additional optional parameters
 * @param  {Boolean}    [opts.reversed]         Determines if the items should be sorted ascending or descending
 * @param  {Function}   callback                Invoked when the process completes
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Object}     callback.resourceIds    The ids of the retrieved resources
 * @param  {Object}     callback.nextToken      The value to use for the `start` parameter to get the next set of results
 */
var list = module.exports.list = function(indexName, key, visibility, start, limit, opts, callback) {
    limit = limit || 10;
    opts = opts || {};

    // This is a little tricky. By default the indexer lists things in order of highest rank to lowest rank. Cassandra orders column
    // names by default the opposite way. So, if the consumer specifies "reversed" ordering here, we make it opposite when fetching
    // from the cassandra module.
    var reversed = (opts.reversed === true) ? false : true;
    var bucketKey = _createBucketKey(indexName, key, visibility);

    Cassandra.runPagedColumnQuery('LibraryIndex', 'bucketKey', bucketKey, start, limit, {'reversed': reversed}, function(err, row, nextToken) {
        if (err) {
            return callback(err);
        }

        var numResults = 0;

        // For repair-on-read, we will keep track of duplicate keys and delete duplicates after
        var deletePlaceholders = [];
        var valueKeysToDelete = [];

        // Because of the repair-on-read the nextToken might now be invalid so we need to recalculate it
        var newNextToken = null;

        var resourceIds = [];
        row.forEach(function(valueKey) {
            numResults++;
            _splitValueKey(valueKey, function(resourceId, timestamp) {
                if (!_.contains(resourceIds, resourceId)) {
                    resourceIds.push(resourceId);
                    newNextToken = valueKey;
                } else {
                    deletePlaceholders.push('?');
                    valueKeysToDelete.push(valueKey);
                }
            });
        });

        // If the runPagedColumnQuery method didn't return a next token, it means there are no more items to retrieve
        if (!nextToken) {
            newNextToken = null;
        }

        if (valueKeysToDelete.length > 0) {
            // There were duplicates, delete them asynchronously
            valueKeysToDelete.push(bucketKey);
            Cassandra.runQuery('DELETE ' + deletePlaceholders.join (',') + ' FROM LibraryIndex USING CONSISTENCY ONE WHERE bucketKey = ?', valueKeysToDelete);
        }

        return callback(null, resourceIds, newNextToken);
    });
};

/**
 * Create the storage key that tracks the items in the index with key `indexKey` and name `bucketName`
 *
 * It is of the format: <indexKey>#<bucketName>
 *
 * @param  {String}     indexName   The name of the index
 * @param  {String}     indexKey    The key of the index under this name
 * @param  {String}     bucketName  The name of the bucket in the bucket key
 * @return {String}                 The bucket key
 * @api private
 */
var _createBucketKey = function(indexName, indexKey, bucketName) {
    return util.format('%s#%s#%s', indexName, indexKey, bucketName);
};

/**
 * Create the value key (i.e., key of column name which stores the index value) for the given
 * resource and rank.
 *
 * @param  {String}         resourceId  The id of the resource
 * @param  {String|Number}  rank        The rank of the resource in the library
 * @return {String}                     The key to use as the column name in the index
 * @api private
 */
var _createValueKey = function(resourceId, rank) {
    return util.format('%s#%s', rank, resourceId);
};

/**
 * Given a value key (as created form `_createValueKey`) into its rank and resourceId.
 *
 * @param  {String}     valueKey            The valueKey to split
 * @param  {Function}   callback            Invoked when the key has been split
 * @param  {String}     callback.resourceId The id of the resource in the valueKey
 * @param  {String}     callback.rank       The rank (string representation of the number if it was a number) of the resourceKey in the index
 * @api private
 */
var _splitValueKey = function(valueKey, callback) {
    var parts = valueKey.split('#');
    return callback(parts.slice(1).join('#'), parts[0]);
};
