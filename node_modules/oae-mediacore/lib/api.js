/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var crypto = require('crypto');
var request = require('request');

var ContentAPI = require('oae-content');
var ContentConstants = require('oae-content/lib/constants').ContentConstants;
var ContentDao = require('oae-content/lib/internal/dao');
var log = require('oae-logger').logger('oae-mediacore');

var MediaCoreConfig = require('oae-config').config('oae-mediacore');

var MediaCoreDao = require('./internal/dao');

/**
 * Signs a url with HMAC for mediacore
 *
 * @param  {String}     url               The url to be signed
 * @param  {String}     queryString       The queryString for the url
 * @param  {String}     keyId             The mediacore key id
 * @param  {String}     secretKey         The mediacore secret key
 * @param  {Integer}    [tll]             The number of seconds this signature should be valid for
 * @param  {String}     [ipMask]          The mediacore ipMask
 * @return {String}                       A signed url
 */
var getSignedUrl = module.exports.getSignedUrl = function(url, queryString, keyId, secretKey, tll, ipMask) {
    var expiryEpoch = null;
    if (tll){
        expiryEpoch = (Math.floor((Date.now()/100)) + tll);
    }

    var policyString = _makePolicyString(url, queryString, expiryEpoch, ipMask);
    log().trace(policyString);
    var encodedPolicyString = _urlSafeB64Encode(policyString);
    var signature = _getSignature(secretKey, encodedPolicyString);

    var newQs = '_Policy=' + encodedPolicyString + '&_Signature=' + signature + '&_KeyId=' + keyId;

    if (queryString !== '' && queryString !== '*') {
        newQs = queryString + '&' + newQs;
    }
    return url + '?' + newQs;
};

/**
 * Gets the html to put a mediacore player in a page
 *
 * @param  {Context}        ctx                 Standard context object
 * @param  {String}         contentId           The contentId of the content to play in the mediacore player
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error if one occurred
 * @param  {Object}         callback.embedCode  A JSON object with one element, 'html', which is the html code that should be inserted in the page
 */
var getEmbedCode = module.exports.getEmbedCode = function(ctx, contentId, callback) {
    ContentAPI.getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }
        if (! contentObj.previews.mediacoreId) {
            return callback({'code': 400, 'msg': 'This content doesn\'t have a mediacore ID'});
        }

        mcConf = getConfig();

        request.get(getSignedUrl(mcConf.url + '/api2/media/' + contentObj.previews.mediacoreId + '/embedcode', '', mcConf.keyId, mcConf.secret, 15), function(err, res, body) {
            if (err) {
                return callback({'code': 500, 'msg': 'Error communicating with MediaCore server.'});
            }
            if (res.statusCode >= 300) {
                return callback({'code': res.statusCode, 'msg': body});
            }

            var embedCode = JSON.parse(body);

            // The iframe src comes back unsigned, so we have to sign it and put the new url in
            embedCode.html = embedCode.html.replace(/src=["']*([^\s"']*)["']*[\s>]/, function(match, url) {
                url = url.split('?');
                return 'src="' + getSignedUrl(url[0], url[1],   mcConf.keyId, mcConf.secret, 3600) + '"' + match[match.length - 1];
            });

            return callback(null, embedCode);
        });
    });
};

/**
 * Get the mediacore API values that have been configured in the Admin UI.
 *
 * @return {Object} The url, keyID and secret from the Admin UI.
 * @api private
 */
var getConfig = module.exports.getConfig = function() {
    return {
        'url': MediaCoreConfig.getValue('admin', 'mediacore', 'url'),
        'keyId': MediaCoreConfig.getValue('admin', 'mediacore', 'keyId'),
        'secret': MediaCoreConfig.getValue('admin', 'mediacore', 'secret'),
        'collectionId': MediaCoreConfig.getValue('admin', 'mediacore', 'collectionId')
    };
};

/**
 * Save a mapping from a mediacore Id to a content revision
 *
 * @param  {PreviewContext} ctx              The context
 * @param  {String}         mediacoreId      The mediacore ID
 * @param  {Function}       callback         Standard callback function
 * @param  {Object}         callback.err
 */
var saveMediaCoreId = module.exports.saveMediaCoreId = function(ctx, mediacoreId, callback) {
    MediaCoreDao.saveId(mediacoreId, ctx.contentId, ctx.revisionId, callback);
};

/**
 * Update thumbnails from mediacore
 *
 * @param  {String}         mediacoreId      The mediacore ID
 * @param  {Function}       callback         Standard callback function
 * @param  {Object}         callback.err
 */
var updateThumbs = module.exports.updateThumbs = function(mediacoreId, callback) {
    MediaCoreDao.getId(mediacoreId, function(err, contentInfo){
        if (err) {
            return callback(err);
        }
        var mcConf = getConfig();
        var thumbUrl = getSignedUrl(mcConf.url + '/api2/media/' + mediacoreId + '/thumbs', '', mcConf.keyId, mcConf.secret, 15);
        request.get(thumbUrl, function(err, res, body) {
            if(err) {
                return callback(err);
            }
            if (res.statusCode >= 300) {
                return callback({'code': res.statusCode, 'msg': body});
            }
            body = JSON.parse(body);

            var thumbnailUri = 'remote:' + body.sizes.l;
            var previewMetadata = {
                'smallUri': 'remote:' + body.sizes.l,
                'mediumUri': 'remote:' + body.sizes['720p'],
                'largeUri': 'remote:' + body.sizes['720p'],
                'wideUri': 'remote:' + body.sizes['720p'],
                'mediacoreId': mediacoreId
            };
            ContentDao.Content.getContent(contentInfo.contentId, function(err, contentObj) {
                if (err) {
                    return callback(err);
                }

                ContentDao.Previews.storeMetadata(contentObj, contentInfo.revisionId, ContentConstants.previews.DONE, thumbnailUri, null, previewMetadata, {}, function(err){
                    if (err) {
                        return callback(err);
                    }
                    // Fire an event so we can update the search index.
                    ContentAPI.emit(ContentConstants.events.UPDATED_CONTENT_PREVIEW, null, contentObj.id, contentObj);

                    return callback();
                });
            });
        });
    });
};

/**
 * Build a mediacore policy JSON
 *
 * @param  {String}        url            The url of the policy resource
 * @param  {String}        [queryString]  The queryString for the url
 * @param  {Integer}       [expiryEpoch]  Unix epoch timestamp for when this policy expires
 * @param  {String}        [ipMask]       The mediacore ipMask for this policy
 * @return {String}                       A JSON representation of the policy
 * @api private
 */
var _makePolicyString = function(url, queryString, expiryEpoch, ipMask) {
    policy = {
        'resource': url
    };
    if (queryString && queryString !== '') {
        policy.query_string = queryString;
    }
    if (ipMask) {
        policy.ip_range = ipMask;
    }
    if (expiryEpoch) {
        policy.expiry_epoch = expiryEpoch;
    }
    return JSON.stringify(policy);
};

/**
 * Base64 encode a string with url safe characters
 *
 * @param  {String}    unencoded         The string to be encoded
 * @return {String}                      The base64 encoded string
 * @api private
 */
var _urlSafeB64Encode = function(unencoded) {
    var encoded = new Buffer(unencoded || '').toString('base64');
    // replace '+' with '-', '/' with '_', and strip padding '=' chars
    var urlSafe = encoded.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    return urlSafe;
};

/**
 * Get an HMAC signature
 *
 * @param  {String}  secretKey       A url safe base64 encoded secret key
 * @param  {String}  value           A string to sign
 * @return {String}                  The HMAC hash
 * @api private
 */
var _getSignature = function(secretKey, value) {
    var sKeyBytes = new Buffer(secretKey, 'base64');
    var algo = 'sha256';
    if (sKeyBytes.toString('hex').length == 256) {
        algo = 'sha512';
    }
    var hash = crypto.createHmac(algo, sKeyBytes).update(value).digest('base64');
    // replace '+' with '-', '/' with '_', and strip padding '=' chars
    hash = hash.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    return hash;
};
