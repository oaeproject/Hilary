var _ = require('underscore');
var assert = require('assert');
var temp = require('temp');
var async = require('async');

var Cassandra = require('oae-util/lib/cassandra');
var RestAPI = require('oae-rest');
var TestsUtil = require('oae-tests');
var TaskQueue = require('oae-util/lib/taskqueue');
var PreviewConstants = require('oae-preview-processor/lib/constants');

var MqTestsUtil = require('oae-util/lib/test/mq-util');
var ActivityAggregator = require('oae-activity/lib/internal/aggregator');
var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;

describe('Loodle update', function () {

    // Rest context that can be used every time we need to make a request as an anonymous user
    var anonymousRestContext = null;

    // Rest contexts that can be used every time we need to make a request as a tenant admin
    var camAdminRestContext = null;
    var gtAdminRestContext = null;

    // Rest context that can be used every time we need to make a request as a global admin
    var globalAdminRestContext = null;

    /**
     * Create a number of users that will be used inside of a test
     * @param  {Function(contexts)}  callback           Standard callback function
     * @param  {Object}              callback.contexts  Object where the keys are identifiers for the created users and the values are an
     *                                                  object with a user key containing the user object for the created user and a restContext key
     *                                                  containing the REST Context for that user
     */
    var setUpUsers = function (callback) {
        var contexts = {};
        var createUser = function(identifier, visibility, displayName) {
            var userId = TestsUtil.generateTestUserId(identifier);
            var email = TestsUtil.generateTestEmailAddress(null, global.oaeTests.tenants.cam.emailDomain);
            RestAPI.User.createUser(camAdminRestContext, userId, 'password', displayName, email, {'visibility' : visibility}, function(err, createdUser) {
                if (err) {
                    assert.fail('Could not create test user');
                }
                contexts[identifier] = {
                    'user': createdUser,
                    'restContext': TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, userId, 'password')
                };
                if (_.keys(contexts).length === 7) {
                    callback(contexts);
                }
            });
        };

        createUser('nicolaas', 'public', 'Nicolaas Matthijs');
        createUser('simon', 'loggedin', 'Simon Gaeremynck');
        createUser('bert', 'private', 'Bert Pareyn');
        createUser('branden', 'private', 'Branden Visser');
        createUser('anthony', 'public', 'Anthony Whyte');
        createUser('stuart', 'public', 'Stuart Freeman');
        createUser('ian', 'public', 'Ian Dolphin');
    };

    /**
     * Function that will fill up the anonymous and tenant admin REST context
     */
    before(function (callback) {
        // Fill up anonymous rest context
        anonymousRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host);

        // Fill up tenant admin rest contexts
        camAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.cam.host);
        gtAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.gt.host);

        // Fill up global admin rest context
        globalAdminRestContext = TestsUtil.createGlobalAdminRestContext();

        // Log in the tenant admin so his cookie jar is set up appropriately. This is because TestsUtil.generateTestUsers
        // will concurrently try and create users, which causes race conditions when trying to authenticate the rest
        // context.
        RestAPI.User.getMe(camAdminRestContext, function(err, meObj) {
            assert.ok(!err);

            // Unbind the current handler, if any
            TaskQueue.unbind(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, function(err) {
                assert.ok(!err);

                /*!
                 * Task handler that will just drain the queue.
                 *
                 * @see MQ#bind
                 */
                var _handleTaskDrain = function(data, mqCallback) {
                    // Simply callback, which acknowledges the message without doing anything.
                    mqCallback();
                };

                // Drain the queue
                TaskQueue.bind(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, _handleTaskDrain, null, function(err) {
                    assert.ok(!err);
                    callback();
                });
            });
        });
    });

    /**
     * Function that will clean up any files that we have lingering around.
     */
    after(function () {
        temp.cleanup();
    });

    describe('add another user to a loodle', function () {

        it('should give the user an access to the loodle', function (callback) {

            setUpUsers(function (contexts) {
                // Create the loodle
                RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Test', 'private', [], [], [], function (err, data) {
                    if (err) return callback(err);

                    // Add an user
                    var changes = {};
                    changes[contexts['simon'].user.id] = 'manager';
                    RestAPI.Content.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                        if (err) return callback(err);

                        RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                            assert.equal(err, null);
                            assert.equal(content.isManager, true);

                            return callback();
                        });
                    });
                });
            });

        });

        it('should add the user as a participant in the loodle', function (callback) {

            setUpUsers(function (contexts) {
                // Create the loodle
                RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Test', 'private', [], [], [], function (err, data) {
                    if (err) return callback(err);

                    // Add an user
                    var changes = {};
                    changes[contexts['simon'].user.id] = 'manager';
                    RestAPI.Content.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                        if (err) return callback(err);

                        RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                            assert.equal(err, null);

                            var users = _.pluck(content.loodleData.users, 'first_name');
                            assert.equal(users.length, 2);
                            assert.equal(_.contains(users, 'Branden'), true);
                            assert.equal(_.contains(users, 'Simon'), true);

                            return callback();
                        });
                    });
                });
            });

        });

        it('should handle the case where the user already had another access to the loodle through a group : he/she is not added again as participant in the loodle and keeps/gains the "higher" role according to his/her access', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe', 'Un groupe de test', 'private', 'no', [], [contexts['simon'].user.id], function (err, group) {
                    if (err) return callback(err);

                    // Create the loodle
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Test', 'private', [group.id], [], [], function (err, data) {
                        if (err) return callback(err);

                        // Add an user
                        var changes = {};
                        changes[contexts['simon'].user.id] = 'viewer';
                        RestAPI.Content.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                            if (err) return callback(err);

                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                assert.equal(err, null);
                                assert.equal(content.isManager, true);

                                var users = _.pluck(content.loodleData.users, 'first_name');
                                assert.equal(users.length, 2);
                                assert.equal(_.contains(users, 'Branden'), true);
                                assert.equal(_.contains(users, 'Simon'), true);

                                return callback();
                            });
                        });
                    });

                });

            });

        });

        it('should handle the case where the user already had another access to this loodle through a folder : he/she is added as participantant in the loodle and have his/her role updated', function (callback) {

            setUpUsers(function (contexts) {

                // Create a folder
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon super dossier', 'Un dossier de test', 'private', [contexts['simon'].user.id], [], function (err, folder) {
                    if (err) return callback(err);

                    // Create the loodle
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Test', 'private', [], [], [folder.id], function (err, data) {
                        if (err) return callback(err);

                        // Add an user
                        var changes = {};
                        changes[contexts['simon'].user.id] = 'manager';
                        RestAPI.Content.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                            if (err) return callback(err);

                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                assert.equal(err, null);
                                assert.equal(content.isManager, true);

                                var users = _.pluck(content.loodleData.users, 'first_name');
                                assert.equal(users.length, 2);
                                assert.equal(_.contains(users, 'Branden'), true);
                                assert.equal(_.contains(users, 'Simon'), true);

                                return callback();
                            });
                        });
                    });

                });

            });

        });

    });

    describe('add another group to a loodle', function () {

        it('should give the group an access to the loodle', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe', 'Un groupe de test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, group) {
                    if (err) return callback(err);

                    // Create a loodle
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Un loodle de test', 'private', [group.id], [], [], function (err, data) {
                        if (err) return callback(err);

                        // Add a group
                        var changes = {};
                        changes[group.id] = 'manager';
                        RestAPI.Content.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                            if (err) return callback(err);

                            async.parallel({
                                getBySimon: function (done) {
                                    RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                        assert.equal(err, null);
                                        assert.equal(content.isManager, true);
                                        return done();
                                    });
                                },
                                getByStuart: function (done) {
                                    RestAPI.Content.getContent(contexts['stuart'].restContext, data.id, function (err, content) {
                                        assert.equal(err, null);
                                        assert.equal(content.isManager, true);
                                        return done();
                                    });
                                }
                            }, callback);
                        });
                    });
                });

            });

        });

        it('should add all the users of the group as participants in the loodle', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe', 'Un groupe de test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, group) {
                    if (err) return callback(err);

                    // Create a loodle
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Un loodle de test', 'private', [group.id], [], [], function (err, data) {
                        if (err) return callback(err);

                        // Add a group
                        var changes = {};
                        changes[group.id] = 'manager';
                        RestAPI.Content.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                            if (err) return callback(err);

                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                assert.equal(err, null);

                                var users = _.pluck(content.loodleData.users, 'first_name');
                                assert.equal(users.length, 3);
                                assert.equal(_.contains(users, 'Branden'), true);
                                assert.equal(_.contains(users, 'Simon'), true);
                                assert.equal(_.contains(users, 'Stuart'), true);

                                return callback();
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the added group has other groups as members : all the users must have an access to the loodle', function (callback) {

            setUpUsers(function (contexts) {

                // Create a first group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe 1', 'Un groupe de test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, group1) {
                    if (err) return callback(err);

                    // Create a second group
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe 2', 'Un groupe de test', 'private', 'no', [contexts['ian'].user.id], [contexts['anthony'].user.id], function (err, group2) {
                        if (err) return callback(err);

                        // Add the second group as a member of the first one
                        var changes = {};
                        changes[group2.id] = 'manager';
                        RestAPI.Group.setGroupMembers(contexts['branden'].restContext, group1.id, changes, function (err, result) {
                            if (err) return callback(err);

                            // Create a loodle
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Un loodle de test', 'private', [], [], [], function (err, data) {
                                if (err) return callback(err);

                                // Add the first group
                                var changes = {};
                                changes[group1.id] = 'manager';
                                RestAPI.Content.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                                    if (err) return callback(err);

                                    async.parallel({
                                        getBySimon: function (done) {
                                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, true);
                                                return done();
                                            });
                                        },
                                        getByStuart: function (done) {
                                            RestAPI.Content.getContent(contexts['stuart'].restContext, data.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, true);
                                                return done();
                                            });
                                        },
                                        getByIan: function (done) {
                                            RestAPI.Content.getContent(contexts['ian'].restContext, data.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, true);
                                                return done();
                                            });
                                        },
                                        getByAnthony: function (done) {
                                            RestAPI.Content.getContent(contexts['anthony'].restContext, data.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, true);
                                                return done();
                                            });
                                        }
                                    }, callback);
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the added group has other groups as members : all the users must be added as participants', function (callback) {

            setUpUsers(function (contexts) {

                // Create a first group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe 1', 'Un groupe de test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, group1) {
                    if (err) return callback(err);

                    // Create a second group
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe 2', 'Un groupe de test', 'private', 'no', [contexts['ian'].user.id], [contexts['anthony'].user.id], function (err, group2) {
                        if (err) return callback(err);

                        // Add the second group as a member of the first one
                        var changes = {};
                        changes[group2.id] = 'manager';
                        RestAPI.Group.setGroupMembers(contexts['branden'].restContext, group1.id, changes, function (err, result) {
                            if (err) return callback(err);

                            // Create a loodle
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Un loodle de test', 'private', [], [], [], function (err, data) {
                                if (err) return callback(err);

                                // Add the first group
                                var changes = {};
                                changes[group1.id] = 'manager';
                                RestAPI.Content.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                                    if (err) return callback(err);

                                    RestAPI.Content.getContent(contexts['branden'].restContext, data.id, function (err, content) {
                                        assert.equal(err, null);

                                        var users = _.pluck(content.loodleData.users, 'first_name');
                                        assert.equal(users.length, 5);
                                        assert.equal(_.contains(users, 'Branden'), true);
                                        assert.equal(_.contains(users, 'Simon'), true);
                                        assert.equal(_.contains(users, 'Stuart'), true);
                                        assert.equal(_.contains(users, 'Ian'), true);
                                        assert.equal(_.contains(users, 'Anthony'), true);

                                        return callback();
                                    });
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where one group user has another access to the loodle thanks to being personaly invited or through another group : he/she is not added again as participant and keeps/gains the "higher" role he/she can have', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe', 'Un groupe de test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a loodle
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Un loodle de test', 'private', [], [], [], function (err, data) {
                        if (err) return callback(err);

                        // Add an user
                        var changes = {};
                        changes[contexts['simon'].user.id] = 'viewer';
                        RestAPI.Content.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                            if (err) return callback(err);

                            // Add a group
                            changes = {};
                            changes[group.id] = 'manager';
                            RestAPI.Content.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                                if (err) return callback(err);

                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);
                                    assert.equal(content.isManager, true);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 2);
                                    assert.equal(_.contains(users, 'Branden'), true);
                                    assert.equal(_.contains(users, 'Simon'), true);

                                    return callback();
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where one group user has another access to the loodle through another folder : he/she is added again as a participant and have his/her access updated', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe', 'Un groupe de test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a folder
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon super dossier', 'Un dossier de test', 'private', [contexts['simon'].user.id], [], function (err, folder) {
                        if (err) return callback(err);

                        // Create a loodle
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Un loodle de test', 'private', [], [], [folder.id], function (err, data) {
                            if (err) return callback(err);

                            // Add an user
                            var changes = {};
                            changes[contexts['simon'].user.id] = 'manager';
                            RestAPI.Content.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                                if (err) return callback(err);

                                // Add a group
                                changes = {};
                                changes[group.id] = 'manager';
                                RestAPI.Content.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                                    if (err) return callback(err);

                                    RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                        assert.equal(err, null);
                                        assert.equal(content.isManager, true);

                                        var users = _.pluck(content.loodleData.users, 'first_name');
                                        assert.equal(users.length, 2);
                                        assert.equal(_.contains(users, 'Branden'), true);
                                        assert.equal(_.contains(users, 'Simon'), true);

                                        return callback();
                                    });
                                });
                            });
                        });
                    });
                });

            });

        });

    });

    describe('add a loodle to a folder', function () {

        it('should give an access in read only mode to all the users of the folder to the loodle ', function (callback) {

            setUpUsers(function (contexts) {

                // Create a folder
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon super dossier', 'Un dossier de test', 'private', [contexts['simon'].user.id], [], function (err, folder) {
                    if (err) return callback(err);

                    // Create a loodle
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Un loodle de test', 'private', [], [], [], function (err, data) {
                        if (err) return callback(err);

                        // Add the loodle to the folder
                        RestAPI.Folders.addContentItemsToFolder(contexts['branden'].restContext, folder.id, [data.id], function (err) {
                            if (err) return callback (err);

                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                assert.equal(err, null);

                                return callback();
                            });
                        });
                    })
                });

            });

        });

        it('should not add the folder members as participants of the loodle', function (callback) {

            setUpUsers(function (contexts) {

                // Create a folder
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon super dossier', 'Un dossier de test', 'private', [contexts['simon'].user.id], [], function (err, folder) {
                    if (err) return callback(err);

                    // Create a loodle
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Un loodle de test', 'private', [], [], [], function (err, data) {
                        if (err) return callback(err);

                        // Add the loodle to the folder
                        RestAPI.Folders.addContentItemsToFolder(contexts['branden'].restContext, folder.id, [data.id], function (err) {
                            if (err) return callback (err);

                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                assert.equal(err, null);

                                var users = _.pluck(content.loodleData.users, 'first_name');
                                assert.equal(users.length, 1);
                                assert.equal(_.contains(users, 'Branden'), true);

                                return callback();
                            });
                        });
                    })
                });

            });

        });

        it('should handle the case where a group is a folder member : all group users must have access in read only mode to the loodle', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe de test', 'test', 'private', 'no', [contexts['stuart'].user.id], [contexts['ian'].user.id], function (err, group) {
                    if (err) return callback(err);

                    // Create a folder with a group as a member
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon super dossier', 'Un dossier de test', 'private', [contexts['simon'].user.id, group.id], [], function (err, folder) {
                        if (err) return callback(err);

                        // Create a loodle
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Un loodle de test', 'private', [], [], [], function (err, data) {
                            if (err) return callback(err);

                            // Add the loodle to the folder
                            RestAPI.Folders.addContentItemsToFolder(contexts['branden'].restContext, folder.id, [data.id], function (err) {
                                if (err) return callback (err);

                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);

                                    return callback();
                                });
                            });
                        })
                    });
                });

            });

        });

        it('should handle the case where a group is a folder member and one group user has another access to the loodle thanks to being invited personaly or through another group : he/she keeps being a participant in the loodle and keeps the role he/she had', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe de test', 'test', 'private', 'no', [contexts['stuart'].user.id], [contexts['ian'].user.id], function (err, group) {
                    if (err) return callback(err);

                    // Create a folder with a group as a member
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon super dossier', 'Un dossier de test', 'private', [contexts['simon'].user.id, group.id], [], function (err, folder) {
                        if (err) return callback(err);

                        // Create a loodle
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Un loodle de test', 'private', [contexts['stuart'].user.id], [], [], function (err, data) {
                            if (err) return callback(err);

                            // Add the loodle to the folder
                            RestAPI.Folders.addContentItemsToFolder(contexts['branden'].restContext, folder.id, [data.id], function (err) {
                                if (err) return callback (err);

                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 2);
                                    assert.equal(_.contains(users, 'Branden'), true);
                                    assert.equal(_.contains(users, 'Stuart'), true);

                                    return callback();
                                });
                            });
                        })
                    });
                });

            });

        });

        it('should handle the case where a group is a folder member and one group user has another access to the loodle through another folder : he/she keeps only having a read only access to the loodle without being added as participant', function (callback) {

            setUpUsers(function (contexts) {

                // Create a first folder
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon super dossier 1', 'Un dossier de test', 'private', [contexts['simon'].user.id], [], function (err, folder1) {
                    if (err) return callback(err);

                    // Create a second folder
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon super doosier 2', 'Un dossier de test', 'private', [contexts['simon'].user.id], [], function (err, folder2) {
                        if (err) return callback(err);

                        // Create a loodle within the first folder
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Un loodle de test', 'private', [], [], [folder1.id], function (err, data) {
                            if (err) return callback(err);

                            // Add the loodle to the second folder
                            RestAPI.Folders.addContentItemsToFolder(contexts['branden'].restContext, folder2.id, [data.id], function (err) {
                                if (err) return callback(err);

                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    if (err) return callback(err);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 1);
                                    assert.equal(_.contains(users, 'Branden'), true);

                                    return callback();
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where a group is a folder member and one of its group member is also a group which has another access to the loodle thanks to being invited personaly or through another group : the concerned group users keep being participants and they keep the role they had', function (callback) {

            setUpUsers(function (contexts) {

                // Create a first group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe de test 1', 'test', 'private', 'no', [contexts['stuart'].user.id], [contexts['ian'].user.id], function (err, group1) {
                    if (err) return callback(err);

                    // Create a second group with the first group as member
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe de test 2', 'test', 'private', 'no', [contexts['stuart'].user.id, group1.id], [], function (err, group2) {
                        if (err) return callback(err);

                        // Create a folder with the second group as a member
                        RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon super dossier', 'Un dossier de test', 'private', [contexts['simon'].user.id, group2.id], [], function (err, folder) {
                            if (err) return callback(err);

                            // Create a loodle
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Un loodle de test', 'private', [group1.id], [], [], function (err, data) {
                                if (err) return callback(err);

                                // Add the loodle to the folder
                                RestAPI.Folders.addContentItemsToFolder(contexts['branden'].restContext, folder.id, [data.id], function (err) {
                                    if (err) return callback (err);

                                    RestAPI.Content.getContent(contexts['branden'].restContext, data.id, function (err, content) {
                                        assert.equal(err, null);

                                        var users = _.pluck(content.loodleData.users, 'first_name');
                                        assert.equal(users.length, 3);
                                        assert.equal(_.contains(users, 'Branden'), true);
                                        assert.equal(_.contains(users, 'Stuart'), true);
                                        assert.equal(_.contains(users, 'Ian'), true);

                                        return callback();
                                    });
                                });
                            })
                        });
                    });
                });

            });

        });

    });

    describe('remove an user from a loodle', function () {

        it('should stop the access to the loodle for this user', function (callback) {

            setUpUsers(function (contexts) {

                // Create a loodle
                RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'test', 'private', [contexts['simon'].user.id], [], [], function (err, data) {
                    if (err) return callback(err);

                    // Remove an user from a loodle
                    var changes = {};
                    changes[contexts['simon'].user.id] = false;
                    RestAPI.Loodles.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                        if (err) return callback(err);

                        RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                            assert.notEqual(err, null);
                            assert.equal(err.code, 401);
                            assert.equal(err.msg, 'The current user does not have access to this resource');

                            return callback();
                        });
                    });
                });

            });

        });

        it('should remove the user as a participant of the loodle', function (callback) {

            setUpUsers(function (contexts) {

                // Create a loodle
                RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'test', 'private', [contexts['simon'].user.id], [], [], function (err, data) {
                    if (err) return callback(err);

                    // Remove an user from a loodle
                    var changes = {};
                    changes[contexts['simon'].user.id] = false;
                    RestAPI.Loodles.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                        if (err) return callback(err);

                        RestAPI.Content.getContent(contexts['branden'].restContext, data.id, function (err, content) {
                            assert.equal(err, null);

                            var users = _.pluck(content.loodleData.users, 'first_name');
                            assert.equal(users.length, 1);
                            assert.equal(_.contains(users, 'Branden'), true);

                            return callback();
                        });
                    });
                });

            });

        });

        it('should handle the case where the user has another access to the loodle thanks to a group : the user keeps an updated access to the loodle according to the access of the group and keeps being a participant in the loodle', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe', 'un groupe de test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a loodle
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'test', 'private', [contexts['simon'].user.id], [group.id], [], function (err, data) {
                        if (err) return callback(err);

                        // Remove an user from a loodle
                        var changes = {};
                        changes[contexts['simon'].user.id] = false;
                        RestAPI.Loodles.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                            if (err) return callback(err);

                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                assert.equal(err, null);
                                assert.equal(content.isManager, false);

                                var users = _.pluck(content.loodleData.users, 'first_name');
                                assert.equal(users.length, 2);
                                assert.equal(_.contains(users, 'Branden'), true);
                                assert.equal(_.contains(users, 'Simon'), true);

                                return callback();
                            });
                        });
                    });
                });
            });

        });

        it('should handle the case where the user has another access to the loodle thanks to a folder : the user keep an access in read only mode to the loodle but is removed as participant', function (callback) {

            setUpUsers(function (contexts) {

                // Create a folder
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon super dossier de test', 'test', 'private', [contexts['simon'].user.id], [], function (err, folder) {
                    if (err) return callback(err);

                    // Create a loodle inside of the folder
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'test', 'private', [contexts['simon'].user.id], [], [folder.id], function (err, data) {
                        if (err) return callback(err);

                        // Remove an user from a loodle
                        var changes = {};
                        changes[contexts['simon'].user.id] = false;
                        RestAPI.Loodles.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                            if (err) return callback(err);

                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                assert.equal(err, null);
                                assert.equal(content.isManager, false);

                                var users = _.pluck(content.loodleData.users, 'first_name');
                                assert.equal(users.length, 1);
                                assert.equal(_.contains(users, 'Branden'), true);

                                return callback();
                            });
                        });
                    });
                });
            });

        });

    });

    describe('remove a group from a loodle', function () {

        it('should stop the access for the group', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe de test', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a loodle
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'test', 'private', [group.id], [], [], function (err, data) {
                        if (err) return callback(err);

                        // Remove the group from the loodle
                        var changes = {};
                        changes[group.id] = false;
                        RestAPI.Loodles.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                            if (err) return callback(err);

                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err) {
                                assert.notEqual(err, null);
                                assert.equal(err.code, 401);
                                assert.equal(err.msg, 'The current user does not have access to this resource');

                                return callback();
                            });
                        });
                    });
                });

            });

        });

        it('should remove the group users as participants of the loodle', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe de test', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a loodle
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'test', 'private', [group.id], [], [], function (err, data) {
                        if (err) return callback(err);

                        // Remove the group from the loodle
                        var changes = {};
                        changes[group.id] = false;
                        RestAPI.Loodles.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                            if (err) return callback(err);

                            RestAPI.Content.getContent(contexts['branden'].restContext, data.id, function (err, content) {
                                assert.equal(err, null);

                                var users = _.pluck(content.loodleData.users, 'first_name');
                                assert.equal(users.length, 1);
                                assert.equal(_.contains(users, 'Branden'), true);

                                return callback();
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the group has another access to the loodle through another group : the group members keep being participants and have the same role as their group', function (callback) {

            setUpUsers(function (contexts) {

                // Create a first group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super group de test 1', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group1) {
                    if (err) return callback(err);

                    // Create a second group
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe de test 2', 'test', 'private', 'no', [contexts['stuart'].user.id], [group1.id], function (err, group2) {
                        if (err) return callback(err);

                        // Create a loodle
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle de test', 'test', 'private', [group1.id], [group2.id], [], function (err, data) {
                            if (err) return callback(err);

                            // Remove the first group from the loodle
                            var changes = {};
                            changes[group1.id] = false;
                            RestAPI.Loodles.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                                if (err) return callback(err);

                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);
                                    assert.equal(content.isManager, false);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 3);
                                    assert.equal(_.contains(users, 'Branden'), true);
                                    assert.equal(_.contains(users, 'Simon'), true);
                                    assert.equal(_.contains(users, 'Stuart'), true);

                                    return callback();
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the group has another access to the loodle through a folder : the group members are removed as participants in the loodle and have a read only access', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super group test', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create folder with the group as member
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon super dossier de test', 'test', 'private', [group.id], [], function (err, folder) {
                        if (err) return callback(err);

                        // Create a loodle
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle de test', 'test', 'private', [group.id], [], [folder.id], function (err, data) {
                            if (err) return callback(err);

                            // Remove the group from the loodle
                            var changes = {};
                            changes[group.id] = false;
                            RestAPI.Loodles.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                                if (err) return callback(err);

                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);
                                    assert.equal(content.isManager, false);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 1);
                                    assert.equal(_.contains(users, 'Branden'), true);

                                    return callback();
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where one member of the removed group is another group : all groups must lose their access to the loodle and all groups users must be removed as participants of the loodle', function (callback) {

            setUpUsers(function (contexts) {

                // Create a first group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe de test 1', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group1) {
                    if (err) return callback(err);

                    // Create a second group with the first group as member
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe de test 2', 'test', 'private', 'no', [group1.id], [], function (err, group2) {
                        if (err) return callback(err);

                        // Create a loodle with the second group as member
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle de test', 'test', 'private', [group2.id], [], [], function (err, data) {
                            if (err) return callback(err);

                            // Remove the second group from the loodle
                            var changes = {};
                            changes[group2.id] = false;
                            RestAPI.Loodles.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                                if (err) return callback(err);

                                async.parallel({
                                    getBySimon: function (done) {
                                        RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                            assert.notEqual(err, null);
                                            assert.equal(err.code, 401);
                                            assert.equal(err.msg, 'The current user does not have access to this resource');

                                            return done();
                                        });
                                    },
                                    getByBranden: function (done) {
                                        RestAPI.Content.getContent(contexts['branden'].restContext, data.id, function (err, content) {
                                            assert.equal(err, null);
                                            assert.equal(content.isManager, true);

                                            var users = _.pluck(content.loodleData.users, 'first_name');
                                            assert.equal(users.length, 1);
                                            assert.equal(_.contains(users, 'Branden'), true);

                                            return done();
                                        });
                                    }
                                }, callback);
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where one user of the removed group has another access to the loodle thanks to being invited personaly or through another group : the user keeps an access to the loodle and keeps being a participant', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe de test', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a loodle with the group and one group member as members
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle de test', 'test', 'private', [group.id], [contexts['simon'].user.id], [], function (err, data) {
                        if (err) return callback(err);

                        // Remove the group from the loodle
                        var changes = {};
                        changes[group.id] = false;
                        RestAPI.Loodles.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                            if (err) return callback(err);

                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                assert.equal(err, null);
                                assert.equal(content.isManager, false);

                                var users = _.pluck(content.loodleData.users, 'first_name');
                                assert.equal(users.length, 2);
                                assert.equal(_.contains(users, 'Branden'), true);
                                assert.equal(_.contains(users, 'Simon'), true);

                                return callback();
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where one user of the removed group has another access to the loodle through a folder : the user is removed as a participant in the loodle and have a read only access', function (callback) {

            setUpUsers(function (contexts) {

                // Create a folder with one user
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [contexts['simon'].user.id], [], function (err, folder) {
                    if (err) return callback(err);

                    // Create one group with the same user in it
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                        if (err) return callback(err);

                        // Create a loodle inside of the folder and with the group as member
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [group.id], [], [folder.id], function (err, data) {
                            if (err) return callback(err);

                            // Remove the group from the loodle
                            var changes = {};
                            changes[group.id] = false;
                            RestAPI.Loodles.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                                if (err) return callback(err);

                                // Check if the common user between the folder and the group has been removed as participant and have a read only access
                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);
                                    assert.equal(content.isManager, false);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 1);
                                    assert.equal(_.contains(users, 'Branden'), true);

                                    return callback();
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where one member of the removed group is another group which has another access to the loodle thanks to being invited personaly or through another group : the group users keep an access to the loodle and keeps being participants', function (callback) {

            setUpUsers(function (contexts) {

                // Create a first group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe 1', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group1) {
                    if (err) return callback(err);

                    // Create a second group with the first group as member
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe 2', 'test', 'private', 'no', [group1.id], [], function (err, group2) {
                        if (err) return callback(err);

                        // Create a loodle with the first and second group as members
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [group2.id], [group1.id], [], function (err, data) {
                            if (err) return callback(err);

                            // Remove the second group from the loodle
                            var changes = {};
                            changes[group2.id] = false;
                            RestAPI.Loodles.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                                if (err) return callback(err);

                                // Check if the first group users have still access to the loodle and are still displayed as participants
                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);
                                    assert.equal(content.isManager, false);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 2);
                                    assert.equal(_.contains(users, 'Branden'), true);
                                    assert.equal(_.contains(users, 'Simon'), true);

                                    return callback();
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where one member of the removed group is another group which has another access to the loodle through a folder : the group users are removed as participants in the loodle and have a read only access', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a folder with the group as member
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [group.id], [], function (err, folder) {
                        if (err) return callback(err);

                        // Create a loodle inside of the folder and with the group as member
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [group.id], [], [folder.id], function (err, data) {
                            if (err) return callback(err);

                            // Remove the group from the loodle
                            var changes = {};
                            changes[group.id] = false;
                            RestAPI.Loodles.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                                if (err) return callback(err);

                                // Check if the group users have still access to the loodle in read only mode and have been removed as participants
                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);
                                    assert.equal(content.isManager, false);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 1);
                                    assert.equal(_.contains(users, 'Branden'), true);

                                    return callback();
                                });
                            });
                        });
                    });
                });

            });

        });

    });

    describe('remove a loodle from a folder', function () {

        it('should stop the access for all the folder members', function (callback) {

            setUpUsers(function (contexts) {

                // Create a folder
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, folder) {
                    if (err) return callback(err);

                    // Create a loodle inside of the folder
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [], [], [folder.id], function (err, data) {
                        if (err) return callback(err);

                        // Remove the loodle from the folder
                        RestAPI.Folders.removeContentItemsFromFolder(contexts['branden'].restContext, folder.id, [data.id], function (err) {
                            if (err) return callback(err);

                            // Check that the the access to the loodle has been removed for all the folder users
                            async.parallel({
                                getBySimon: function (done) {
                                    RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err) {
                                        assert.notEqual(err, null);
                                        assert.equal(err.code, 401);
                                        assert.equal(err.msg, 'The current user does not have access to this resource');

                                        return done();
                                    });
                                },
                                getByStuart: function (done) {
                                    RestAPI.Content.getContent(contexts['stuart'].restContext, data.id, function (err) {
                                        assert.notEqual(err, null);
                                        assert.equal(err.code, 401);
                                        assert.equal(err.msg, 'The current user does not have access to this resource');

                                        return done();
                                    });
                                }
                            }, callback);
                        });
                    });
                });

            });

        });

        it('should handle the case where an user of the folder has another access to the loodle thanks to being personaly invited or through another group : the user is still a participant in the loodle and keeps the same access', function (callback) {

            setUpUsers(function (contexts) {

                // Create a folder
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, folder) {
                    if (err) return callback(err);

                    // Create a loodle inside of the folder
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [contexts['simon'].user.id], [], [folder.id], function (err, data) {
                        if (err) return callback(err);

                        // Remove the loodle from the folder
                        RestAPI.Folders.removeContentItemsFromFolder(contexts['branden'].restContext, folder.id, [data.id], function (err) {
                            if (err) return callback(err);

                            // Check if the user that had two access to the loodle is still a participant and still has access
                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                assert.equal(err, null);
                                assert.equal(content.isManager, true);

                                var users = _.pluck(content.loodleData.users, 'first_name');
                                assert.equal(users.length, 2);
                                assert.equal(_.contains(users, 'Branden'), true);
                                assert.equal(_.contains(users, 'Simon'), true);

                                return callback();
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where an user of the folder has another access to the loodle through another folder : the user is still not a participant in the loodle and keeps the same read only access', function (callback) {

            setUpUsers(function (contexts) {

                // Create a first folder
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier 1', 'test', 'private', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, folder1) {
                    if (err) return callback(err);

                    // Create a second folder
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier 2', 'test', 'private', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, folder2) {
                        if (err) return callback(err);

                        // Create a loodle inside of the two folders
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [], [], [folder1.id, folder2.id], function (err, data) {
                            if (err) return callback(err);

                            // Remove the loodle from the first folder
                            RestAPI.Folders.removeContentItemsFromFolder(contexts['branden'].restContext, folder1.id, [data.id], function (err) {
                                if (err) return callback(err);

                                // Check if the user that had two access to the loodle is still a participant and still has access
                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);
                                    assert.equal(content.isManager, false);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 1);
                                    assert.equal(_.contains(users, 'Branden'), true);

                                    return callback();
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the folder has a group as a member which has another access to the loodle thanks to being personaly invited or through another group : the group users are still participants in the loodle and keep the same access', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon group', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a folder with the group as member
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [group.id], [], function (err, folder) {
                        if (err) return callback(err);

                        // Create a loodle inside of the folder and with the group as member
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [group.id], [], [folder.id], function (err, data) {
                            if (err) return callback(err);

                            // Remove the loodle from the folder
                            RestAPI.Folders.removeContentItemsFromFolder(contexts['branden'].restContext, folder.id, [data.id], function (err) {
                                if (err) return callback(err);

                                // Check if the user that had two access to the loodle is still a participant and still has access
                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);
                                    assert.equal(content.isManager, true);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 2);
                                    assert.equal(_.contains(users, 'Branden'), true);
                                    assert.equal(_.contains(users, 'Simon'), true);

                                    return callback();
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the folder has a group as a member which has another access to the loodle through another folder : the group users are still not participants in the loodle and keep the same access', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a first folder with the group as member
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier 1', 'test', 'private', [group.id], [], function (err, folder1) {
                        if (err) return callback(err);

                        // Create a second folder with the group as member
                        RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier 2', 'test', 'private', [group.id], [], function (err, folder2) {
                            if (err) return callback(err);

                            // Create a loodle inside of the two folders
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [], [], [folder1.id, folder2.id], function (err, data) {
                                if (err) return callback(err);

                                // Remove the loodle from the first folder
                                RestAPI.Folders.removeContentItemsFromFolder(contexts['branden'].restContext, folder1.id, [data.id], function (err) {
                                    if (err) return callback(err);

                                    // Check if the group users still have an read only access to the loodle
                                    RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                        assert.equal(err, null);
                                        assert.equal(content.isManager, false);

                                        var users = _.pluck(content.loodleData.users, 'first_name');
                                        assert.equal(users.length, 1);
                                        assert.equal(_.contains(users, 'Branden'), true);

                                        return callback();
                                    });
                                });
                            });
                        });
                    });
                });

            });

        });

    });

    describe('remove a user from a group', function () {

        it('should remove the access to the loodles of the group from the user', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a first loodle with the group as member
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [group.id], [], [], function (err, data1) {
                        if (err) return callback(err);

                        // Create a second loodle with the group as member
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [group.id], [], [], function (err, data2) {
                            if (err) return callback(err);

                            // Remove an user from the group
                            var changes = {};
                            changes[contexts['simon'].user.id] = false;
                            RestAPI.Group.setGroupMembers(contexts['branden'].restContext, group.id, changes, function (err) {
                                if (err) return callback(err);

                                // Check the user has no longer access to any of the group loodles
                                async.parallel({
                                    getFirstLoodleBySimon: function (done) {
                                        RestAPI.Content.getContent(contexts['simon'].restContext, data1.id, function (err, content) {
                                            assert.notEqual(err, null);
                                            assert.equal(err.code, 401);
                                            assert.equal(err.msg, 'The current user does not have access to this resource');

                                            return done();
                                        });
                                    },
                                    getSecondLoodleBySimon: function (done) {
                                        RestAPI.Content.getContent(contexts['simon'].restContext, data2.id, function (err, content) {
                                            assert.notEqual(err, null);
                                            assert.equal(err.code, 401);
                                            assert.equal(err.msg, 'The current user does not have access to this resource');

                                            return done();
                                        });
                                    }
                                }, callback);
                            });
                        });
                    });
                });

            });

        });

        it('should remove the user as participant of all the loodles of the group', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a first loodle with the group as member
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [group.id], [], [], function (err, data1) {
                        if (err) return callback(err);

                        // Create a second loodle with the group as member
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [group.id], [], [], function (err, data2) {
                            if (err) return callback(err);

                            // Remove an user from the group
                            var changes = {};
                            changes[contexts['simon'].user.id] = false;
                            RestAPI.Group.setGroupMembers(contexts['branden'].restContext, group.id, changes, function (err) {
                                if (err) return callback(err);

                                // Check the user is no longer a participant to any of the group loodles
                                async.parallel({
                                    getBySimon: function (done) {
                                        RestAPI.Content.getContent(contexts['branden'].restContext, data1.id, function (err, content) {
                                            assert.equal(err, null);
                                            assert.equal(content.isManager, true);

                                            var users = _.pluck(content.loodleData.users, 'first_name');
                                            assert.equal(users.length, 1);
                                            assert.equal(_.contains(users, 'Branden'), true);

                                            return done();
                                        });
                                    },
                                    getByBranden: function (done) {
                                        RestAPI.Content.getContent(contexts['branden'].restContext, data2.id, function (err, content) {
                                            assert.equal(err, null);
                                            assert.equal(content.isManager, true);

                                            var users = _.pluck(content.loodleData.users, 'first_name');
                                            assert.equal(users.length, 1);
                                            assert.equal(_.contains(users, 'Branden'), true);

                                            return done();
                                        });
                                    }
                                }, callback);
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the user has another access to one or many loodles of the group thanks to being personaly invited or through another group : the user has his/her role updated but keeps an access to these loodles and keeps being a participant', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a first loodle with the group as member and one group member explicitly invited
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [group.id], [contexts['simon'].user.id], [], function (err, data1) {
                        if (err) return callback(err);

                        // Create a second loodle with the group as member and one group member explicitly invited
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [group.id], [contexts['simon'].user.id], [], function (err, data2) {
                            if (err) return callback(err);

                            // Remove the group member explicitly invited from the group
                            var changes = {};
                            changes[contexts['simon'].user.id] = false;
                            RestAPI.Group.setGroupMembers(contexts['branden'].restContext, group.id, changes, function (err) {
                                if (err) return callback(err);

                                // Check if he/she keeps his/her access, has the same role as the group and is still a participant in the loodle
                                async.series({
                                    getFirstLoodleBySimon: function (done) {
                                        RestAPI.Content.getContent(contexts['simon'].restContext, data1.id, function (err, content) {
                                            assert.equal(err, null);
                                            assert.equal(content.isManager, false);

                                            var users = _.pluck(content.loodleData.users, 'first_name');
                                            assert.equal(users.length, 2);
                                            assert.equal(_.contains(users, 'Branden'), true);
                                            assert.equal(_.contains(users, 'Simon'), true);

                                            return done();
                                        });
                                    },
                                    getSecondLoodleBySimon: function (done) {
                                        RestAPI.Content.getContent(contexts['simon'].restContext, data2.id, function (err, content) {
                                            assert.equal(err, null);
                                            assert.equal(content.isManager, false);

                                            var users = _.pluck(content.loodleData.users, 'first_name');
                                            assert.equal(users.length, 2);
                                            assert.equal(_.contains(users, 'Branden'), true);
                                            assert.equal(_.contains(users, 'Simon'), true);

                                            return done();
                                        });
                                    }
                                }, callback);
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the user has another access to one or many loodles through a folder : the user keeps an access in read only mode but is no longer a participant in this loodle', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a folder with one group member
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [contexts['simon'].user.id], [], function (err, folder) {
                        if (err) return callback(err);

                        // Create a first loodle inside of the folder with the group as a member
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [group.id], [], [folder.id], function (err, data1) {
                            if (err) return callback(err);

                            // Create a second loodle inside of the folder with the group as a member
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [group.id], [], [folder.id], function (err, data2) {
                                if (err) return callback(err);

                                // Remove the user from the group
                                var changes = {};
                                changes[contexts['simon'].user.id] = false;
                                RestAPI.Group.setGroupMembers(contexts['branden'].restContext, group.id, changes, function (err) {
                                    if (err) return callback(err);

                                    // Check if the user only has a read only access and is no longer a participant in a all the loodles of the group
                                    async.series({
                                        getFirstLoodleBySimon: function (done) {
                                            RestAPI.Content.getContent(contexts['simon'].restContext, data1.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, false);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 1);
                                                assert.equal(_.contains(users, 'Branden'), true);

                                                return done();
                                            });
                                        },
                                        getSecondLoodleBySimon: function (done) {
                                            RestAPI.Content.getContent(contexts['simon'].restContext, data2.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, false);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 1);
                                                assert.equal(_.contains(users, 'Branden'), true);

                                                return done();
                                            });
                                        }
                                    }, callback);
                                });
                            });
                        });
                    });
                });

            });

        });

    });

    describe('remove a group B from a group A', function () {

        it('should remove the access of all the loodles of group A from group B', function (callback) {

            setUpUsers(function (contexts) {

                // Create group B
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe B', 'test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, groupB) {
                    if (err) return callback(err);

                    // Create group A with group B as member
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe A', 'test', 'private', 'no', [groupB.id], [], function (err, groupA) {
                        if (err) return callback(err);

                        // Create a first loodle with group A as member
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [groupA.id], [], [], function (err, data1) {
                            if (err) return callback(err);

                            // Create a second loodle with group A as member
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [groupA.id], [], [], function (err, data2) {
                                if (err) return callback(err);

                                // Remove group B from group A
                                var changes = {};
                                changes[groupB.id] = false;
                                RestAPI.Group.setGroupMembers(contexts['branden'].restContext, groupA.id, changes, function (err) {
                                    if (err) return callback(err);

                                    // Check if all the users of group B have lost their access to all the loodle of group A
                                    async.series({
                                        getFirstLoodleBySimon: function (done) {
                                            RestAPI.Content.getContent(contexts['simon'].restContext, data1.id, function (err) {
                                                assert.notEqual(err, null);
                                                assert.equal(err.code, 401);
                                                assert.equal(err.msg, 'The current user does not have access to this resource');

                                                return done();
                                            });
                                        },
                                        getFirstLoodleByStuart: function (done) {
                                            RestAPI.Content.getContent(contexts['stuart'].restContext, data1.id, function (err) {
                                                assert.notEqual(err, null);
                                                assert.equal(err.code, 401);
                                                assert.equal(err.msg, 'The current user does not have access to this resource');

                                                return done();
                                            });
                                        },
                                        getSecondLoodleBySimon: function (done) {
                                            RestAPI.Content.getContent(contexts['simon'].restContext, data2.id, function (err) {
                                                assert.notEqual(err, null);
                                                assert.equal(err.code, 401);
                                                assert.equal(err.msg, 'The current user does not have access to this resource');

                                                return done();
                                            });
                                        },
                                        getSecondLoodleByStuart: function (done) {
                                            RestAPI.Content.getContent(contexts['stuart'].restContext, data2.id, function (err) {
                                                assert.notEqual(err, null);
                                                assert.equal(err.code, 401);
                                                assert.equal(err.msg, 'The current user does not have access to this resource');

                                                return done();
                                            });
                                        }
                                    }, callback);
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should remove all the members of group B as participants of all the loodles of group A', function (callback) {

            setUpUsers(function (contexts) {

                // Create group B
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe B', 'test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, groupB) {
                    if (err) return callback(err);

                    // Create group A with group B as member
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe A', 'test', 'private', 'no', [groupB.id], [], function (err, groupA) {
                        if (err) return callback(err);

                        // Create a first loodle with group A as member
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [groupA.id], [], [], function (err, data1) {
                            if (err) return callback(err);

                            // Create a second loodle with group A as member
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [groupA.id], [], [], function (err, data2) {
                                if (err) return callback(err);

                                // Remove group B from group A
                                var changes = {};
                                changes[groupB.id] = false;
                                RestAPI.Group.setGroupMembers(contexts['branden'].restContext, groupA.id, changes, function (err) {
                                    if (err) return callback(err);

                                    // Check if all the users of group B are no longer participants of all the loodles of group A
                                    async.series({
                                        getFirstLoode: function (done) {
                                            RestAPI.Content.getContent(contexts['branden'].restContext, data1.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, true);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 1);
                                                assert.equal(_.contains(users, 'Branden'), true);

                                                return done();
                                            });
                                        },
                                        getSecondLoodle: function (done) {
                                            RestAPI.Content.getContent(contexts['branden'].restContext, data2.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, true);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 1);
                                                assert.equal(_.contains(users, 'Branden'), true);

                                                return done();
                                            });
                                        }
                                    }, callback);
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where group B has another access to one or many loodles of group A thanks to being personaly invited or through another group : group B keeps an access to these loodles with an updated role according to its access and the users of group B are still participants', function (callback) {

            setUpUsers(function (contexts) {

                // Create group B
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe B', 'test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, groupB) {
                    if (err) return callback(err);

                    // Create group A with group B as member
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe A', 'test', 'private', 'no', [groupB.id], [], function (err, groupA) {
                        if (err) return callback(err);

                        // Create a first loodle with group A and group B as members
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [groupA.id], [groupB.id], [], function (err, data1) {
                            if (err) return callback(err);

                            // Create a second loodle with group A and group B as members
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [groupA.id], [groupB.id], [], function (err, data2) {
                                if (err) return callback(err);

                                // Remove group B from group A
                                var changes = {};
                                changes[groupB.id] = false;
                                RestAPI.Group.setGroupMembers(contexts['branden'].restContext, groupA.id, changes, function (err) {
                                    if (err) return callback(err);

                                    // Check if group B users have still access to the two loodles, have an updated roles and are still participants in these loodles
                                    async.series({
                                        getFirstLoodleBySimon: function (done) {
                                            RestAPI.Content.getContent(contexts['simon'].restContext, data1.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, false);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 3);
                                                assert.equal(_.contains(users, 'Branden'), true);
                                                assert.equal(_.contains(users, 'Simon'), true);
                                                assert.equal(_.contains(users, 'Stuart'), true);

                                                return done();
                                            });
                                        },
                                        getFirstLoodleByStuart: function (done) {
                                            RestAPI.Content.getContent(contexts['stuart'].restContext, data1.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, false);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 3);
                                                assert.equal(_.contains(users, 'Branden'), true);
                                                assert.equal(_.contains(users, 'Simon'), true);
                                                assert.equal(_.contains(users, 'Stuart'), true);

                                                return done();
                                            });
                                        },
                                        getSecondLoodleBySimon: function (done) {
                                            RestAPI.Content.getContent(contexts['simon'].restContext, data2.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, false);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 3);
                                                assert.equal(_.contains(users, 'Branden'), true);
                                                assert.equal(_.contains(users, 'Simon'), true);
                                                assert.equal(_.contains(users, 'Stuart'), true);

                                                return done();
                                            });
                                        },
                                        getSecondLoodleByStuart: function (done) {
                                            RestAPI.Content.getContent(contexts['stuart'].restContext, data2.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, false);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 3);
                                                assert.equal(_.contains(users, 'Branden'), true);
                                                assert.equal(_.contains(users, 'Simon'), true);
                                                assert.equal(_.contains(users, 'Stuart'), true);

                                                return done();
                                            });
                                        }
                                    }, callback);
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where group B has another access to one or many loodles of group A through another folder : group B members keep an access in read only mode but are no longer participants to these loodles', function (callback) {

            setUpUsers(function (contexts) {

                // Create group B
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe B', 'test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, groupB) {
                    if (err) return callback(err);

                    // Create group A with group B as member
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe A', 'test', 'private', 'no', [groupB.id], [], function (err, groupA) {
                        if (err) return callback(err);

                        // Create a folder with group B as member
                        RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [groupB.id], [], function (err, folder) {
                            if (err) return callback(err);

                            // Create a fist loodle inside of the folder with group A as member
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [groupA.id], [], [folder.id], function (err, data1) {
                                if (err) return callback(err);

                                // Create a second loodle inside of the folder with group A as member
                                RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [groupA.id], [], [folder.id], function (err, data2) {
                                    if (err) return callback(err);

                                    // Remove group B from group A
                                    var changes = {};
                                    changes[groupB.id] = false;
                                    RestAPI.Group.setGroupMembers(contexts['branden'].restContext, groupA.id, changes, function (err) {
                                        if (err) return callback(err);

                                        // Check if group B users have a read only access to group A loodles, and are no longer participants of these loodles
                                        async.series({
                                            getFirstLoodleBySimon: function (done) {
                                                RestAPI.Content.getContent(contexts['simon'].restContext, data1.id, function (err, content) {
                                                    assert.equal(err, null);
                                                    assert.equal(content.isManager, false);

                                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                                    assert.equal(users.length, 1);
                                                    assert.equal(_.contains(users, 'Branden'), true);

                                                    return done();
                                                });
                                            },
                                            getFirstLoodleByStuart: function (done) {
                                                RestAPI.Content.getContent(contexts['stuart'].restContext, data1.id, function (err, content) {
                                                    assert.equal(err, null);
                                                    assert.equal(content.isManager, false);

                                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                                    assert.equal(users.length, 1);
                                                    assert.equal(_.contains(users, 'Branden'), true);

                                                    return done();
                                                });
                                            },
                                            getSecondLoodleBySimon: function (done) {
                                                RestAPI.Content.getContent(contexts['simon'].restContext, data2.id, function (err, content) {
                                                    assert.equal(err, null);
                                                    assert.equal(content.isManager, false);

                                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                                    assert.equal(users.length, 1);
                                                    assert.equal(_.contains(users, 'Branden'), true);

                                                    return done();
                                                });
                                            },
                                            getSecondLoodleByStuart: function (done) {
                                                RestAPI.Content.getContent(contexts['stuart'].restContext, data2.id, function (err, content) {
                                                    assert.equal(err, null);
                                                    assert.equal(content.isManager, false);

                                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                                    assert.equal(users.length, 1);
                                                    assert.equal(_.contains(users, 'Branden'), true);

                                                    return done();
                                                });
                                            }
                                        }, callback);
                                    });
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where group B has a user who has another access to one or many loodles of group A thanks to being personaly invited or through another group : the user keeps an access with an updated role according to its access and is still a participant of these loodles', function (callback) {

            setUpUsers(function (contexts) {

                // Create group B
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe B', 'test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, groupB) {
                    if (err) return callback(err);

                    // Create group A with group B as member
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe A', 'test', 'private', 'no', [groupB.id], [], function (err, groupA) {
                        if (err) return callback(err);

                        // Create a first loodle with group A and one group B user as members
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [groupA.id], [contexts['simon'].user.id], [], function (err, data1) {
                            if (err) return callback(err);

                            // Create a second loodle with group A and one group B user as members
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [groupA.id], [contexts['stuart'].user.id], [], function (err, data2) {
                                if (err) return callback(err);

                                // Remove group B from group A
                                var changes = {};
                                changes[groupB.id] = false;
                                RestAPI.Group.setGroupMembers(contexts['branden'].restContext, groupA.id, changes, function (err) {
                                    if (err) return callback(err);

                                    // Check if the users of group B personaly invited in the loodles have still access to them, had his/her role updated and are still a participant in these loodles
                                    async.parallel({
                                        getFirstLoodleBySimon: function (done) {
                                            RestAPI.Content.getContent(contexts['simon'].restContext, data1.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, false);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 2);
                                                assert.equal(_.contains(users, 'Branden'), true);
                                                assert.equal(_.contains(users, 'Simon'), true);

                                                return done();
                                            });
                                        },
                                        getSecondLoodleByStuart: function (done) {
                                            RestAPI.Content.getContent(contexts['stuart'].restContext, data2.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, false);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 2);
                                                assert.equal(_.contains(users, 'Branden'), true);
                                                assert.equal(_.contains(users, 'Stuart'), true);

                                                return done();
                                            });
                                        }
                                    }, callback);
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where group B has a user who has another access to one or many loodles of group A through another folder : the user keeps an access in read only mode but is no longer a participant to these loodles', function (callback) {

            setUpUsers(function (contexts) {

                // Create a folder
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, folder) {
                    if (err) return callback(err);

                    // Create group B with one user being in the folder
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe B', 'test', 'private', 'no', [contexts['simon'].user.id, contexts['stuart'].user.id], [], function (err, groupB) {
                        if (err) return callback(err);

                        // Create group A with group B as member
                        RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe A', 'test', 'private', 'no', [groupB.id], [], function (err, groupA) {
                            if (err) return callback(err);

                            // Create a first loodle inside of the folder and with group A as member
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [groupA.id], [], [folder.id], function (err, data1) {
                                if (err) return callback(err);

                                // Create a second loodle inside of the folder and with group A as member
                                RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [groupA.id], [], [folder.id], function (err, data2) {
                                    if (err) return callback(err);

                                    // Remove group B from group A
                                    var changes = {};
                                    changes[groupB.id] = false;
                                    RestAPI.Group.setGroupMembers(contexts['branden'].restContext, groupA.id, changes, function (err) {
                                        if (err) return callback(err);

                                        // Check if the users of group B who are members of the folder have still access to the loodles of group A in read only mode and are no longer participants
                                        async.series({
                                            getFirstLoodleBySimon: function (done) {
                                                RestAPI.Content.getContent(contexts['simon'].restContext, data1.id, function (err, content) {
                                                    assert.equal(err, null);
                                                    assert.equal(content.isManager, false);

                                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                                    assert.equal(users.length, 1);
                                                    assert.equal(_.contains(users, 'Branden'), true);

                                                    return done();
                                                });
                                            },
                                            getFirstLoodleByStuart: function (done) {
                                                RestAPI.Content.getContent(contexts['stuart'].restContext, data1.id, function (err, content) {
                                                    assert.equal(err, null);
                                                    assert.equal(content.isManager, false);

                                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                                    assert.equal(users.length, 1);
                                                    assert.equal(_.contains(users, 'Branden'), true);

                                                    return done();
                                                });
                                            },
                                            getSecondLoodleBySimon: function (done) {
                                                RestAPI.Content.getContent(contexts['simon'].restContext, data2.id, function (err, content) {
                                                    assert.equal(err, null);
                                                    assert.equal(content.isManager, false);

                                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                                    assert.equal(users.length, 1);
                                                    assert.equal(_.contains(users, 'Branden'), true);

                                                    return done();
                                                });
                                            },
                                            getSecondLoodleByStuart: function (done) {
                                                RestAPI.Content.getContent(contexts['stuart'].restContext, data2.id, function (err, content) {
                                                    assert.equal(err, null);
                                                    assert.equal(content.isManager, false);

                                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                                    assert.equal(users.length, 1);
                                                    assert.equal(_.contains(users, 'Branden'), true);

                                                    return done();
                                                });
                                            }
                                        }, callback);
                                    });
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where group B has another group as a member which has another access to one or many loodles of group A thanks to being personaly invited or through another group : the group users keep an access with an updated role according to their access and are still participants of these loodles', function (callback) {

            setUpUsers(function (contexts) {

                // Create group C
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe C', 'test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, groupC) {
                    if (err) return callback(err);

                    // Create group B with group C as member
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe B', 'test', 'private', 'no', [groupC.id], [], function (err, groupB) {
                        if (err) return callback(err);

                        // Create group A with group B as member
                        RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe A', 'test', 'private', 'no', [groupB.id], [], function (err, groupA) {
                            if (err) return callback(err);

                            // Create a first loodle with group A and C as members
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [groupA.id], [groupC.id], [], function (err, data1) {
                                 if (err) return callback(err);

                                // Create a second loodle with group A and C as members
                                RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [groupA.id], [groupC.id], [], function (err, data2) {
                                    if (err) return callback(err);

                                    // Remove group B from group A
                                    var changes = {};
                                    changes[groupB.id] = false;
                                    RestAPI.Group.setGroupMembers(contexts['branden'].restContext, groupA.id, changes, function (err) {
                                        if (err) return callback(err);

                                        // Check that the group C users have an updated access to the group A loodles and are still participants to these loodles
                                        async.series({
                                            getFirstLoodleBySimon: function (done) {
                                                RestAPI.Content.getContent(contexts['simon'].restContext, data1.id, function (err, content) {
                                                    assert.equal(err, null);
                                                    assert.equal(content.isManager, false);

                                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                                    assert.equal(users.length, 3);
                                                    assert.equal(_.contains(users, 'Branden'), true);
                                                    assert.equal(_.contains(users, 'Simon'), true);
                                                    assert.equal(_.contains(users, 'Stuart'), true);

                                                    return done();
                                                });
                                            },
                                            getFirstLoodleByStuart: function (done) {
                                                RestAPI.Content.getContent(contexts['stuart'].restContext, data1.id, function (err, content) {
                                                    assert.equal(err, null);
                                                    assert.equal(content.isManager, false);

                                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                                    assert.equal(users.length, 3);
                                                    assert.equal(_.contains(users, 'Branden'), true);
                                                    assert.equal(_.contains(users, 'Simon'), true);
                                                    assert.equal(_.contains(users, 'Stuart'), true);

                                                    return done();
                                                });
                                            },
                                            getSecondLoodleBySimon: function (done) {
                                                RestAPI.Content.getContent(contexts['simon'].restContext, data2.id, function (err, content) {
                                                    assert.equal(err, null);
                                                    assert.equal(content.isManager, false);

                                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                                    assert.equal(users.length, 3);
                                                    assert.equal(_.contains(users, 'Branden'), true);
                                                    assert.equal(_.contains(users, 'Simon'), true);
                                                    assert.equal(_.contains(users, 'Stuart'), true);

                                                    return done();
                                                });
                                            },
                                            getSecondLoodleByStuart: function (done) {
                                                RestAPI.Content.getContent(contexts['stuart'].restContext, data2.id, function (err, content) {
                                                    assert.equal(err, null);
                                                    assert.equal(content.isManager, false);

                                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                                    assert.equal(users.length, 3);
                                                    assert.equal(_.contains(users, 'Branden'), true);
                                                    assert.equal(_.contains(users, 'Simon'), true);
                                                    assert.equal(_.contains(users, 'Stuart'), true);

                                                    return done();
                                                });
                                            }
                                        }, callback);
                                    });
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where group B has another group as a member which has another access to one or many loodles of group A through another folder : the group users keep an access in read only mode but are no longer a participant to these loodles', function (callback) {

            setUpUsers(function (contexts) {

                // Create group C
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe C', 'test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, groupC) {
                    if (err) return callback(err);

                    // Create group B with group C as member
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe B', 'test', 'private', 'no', [groupC.id], [], function (err, groupB) {
                        if (err) return callback(err);

                        // Create group A with group B as member
                        RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe A', 'test', 'private', 'no', [groupB.id], [], function (err, groupA) {
                            if (err) return callback(err);

                            // Create a folder with group C as member
                            RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [groupC.id], [], function (err, folder) {
                                if (err) return callback(err);

                                // Create a first loodle inside of the folder and with group A as member
                                RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [groupA.id], [], [folder.id], function (err, data1) {
                                    if (err) return callback(err);

                                    // Create a second loodle inside of the folder and with group B as member
                                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [groupA.id], [], [folder.id], function (err, data2) {
                                        if (err) return callback(err);

                                        // Remove group B from group A
                                        var changes = {};
                                        changes[groupB.id] = false;
                                        RestAPI.Group.setGroupMembers(contexts['branden'].restContext, groupA.id, changes, function (err) {
                                            if (err) return callback(err);

                                            // Check if the group C users have still an read only access to the group A loodles and are no longer participants to these loodles
                                            async.series({
                                                getFirstLoodleBySimon: function (done) {
                                                    RestAPI.Content.getContent(contexts['simon'].restContext, data1.id, function (err, content) {
                                                        assert.equal(err, null);
                                                        assert.equal(content.isManager, false);

                                                        var users = _.pluck(content.loodleData.users, 'first_name');
                                                        assert.equal(users.length, 1);
                                                        assert.equal(_.contains(users, 'Branden'), true);

                                                        return done();
                                                    });
                                                },
                                                getFirstLoodleByStuart: function (done) {
                                                    RestAPI.Content.getContent(contexts['stuart'].restContext, data1.id, function (err, content) {
                                                        assert.equal(err, null);
                                                        assert.equal(content.isManager, false);

                                                        var users = _.pluck(content.loodleData.users, 'first_name');
                                                        assert.equal(users.length, 1);
                                                        assert.equal(_.contains(users, 'Branden'), true);

                                                        return done();
                                                    });
                                                },
                                                getSecondLoodleBySimon: function (done) {
                                                    RestAPI.Content.getContent(contexts['simon'].restContext, data2.id, function (err, content) {
                                                        assert.equal(err, null);
                                                        assert.equal(content.isManager, false);

                                                        var users = _.pluck(content.loodleData.users, 'first_name');
                                                        assert.equal(users.length, 1);
                                                        assert.equal(_.contains(users, 'Branden'), true);

                                                        return done();
                                                    });
                                                },
                                                getSecondLoodleByStuart: function (done) {
                                                    RestAPI.Content.getContent(contexts['stuart'].restContext, data2.id, function (err, content) {
                                                        assert.equal(err, null);
                                                        assert.equal(content.isManager, false);

                                                        var users = _.pluck(content.loodleData.users, 'first_name');
                                                        assert.equal(users.length, 1);
                                                        assert.equal(_.contains(users, 'Branden'), true);

                                                        return done();
                                                    });
                                                }
                                            }, callback);
                                        });
                                    });
                                });
                            });
                        });
                    });
                });

            });

        });

    });

    describe('remove an user from a folder', function () {

        it('should remove the access to the loodles of the folder for the user', function (callback) {

            setUpUsers(function (contexts) {

                // Create a fodler
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [contexts['simon'].user.id], [], function (err, folder) {
                    if (err) return callback(err);

                    // Create a loodle inside of the folder
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [], [], [folder.id], function (err, data) {
                        if (err) return callback(err);

                        // Remove an user from the folder
                        var changes = {};
                        changes[contexts['simon'].user.id] = false;
                        RestAPI.Folders.updateFolderMembers(contexts['branden'].restContext, folder.id, changes, function (err, folder) {
                            if (err) return callback(err);

                            // Check if the user has lost his/her access to the loodle
                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                assert.notEqual(err, null);
                                assert.equal(err.code, 401);
                                assert.equal(err.msg, 'The current user does not have access to this resource');

                                return callback();
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the user has another access to one or many loodles of the folder thanks to being personaly invited or through another group : the user keeps the same access and is still a participant of these loodles', function (callback) {

            setUpUsers(function (contexts) {

                // Create a folder
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [contexts['simon'].user.id], [], function (err, folder) {
                    if (err) return callback(err);

                    // Create a loodle inside of the folder and with one folder user as member
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [contexts['simon'].user.id], [], [folder.id], function (err, data) {
                        if (err) return callback(err);

                        // Remove the user from the folder
                        var changes = {};
                        changes[contexts['simon'].user.id] = false;
                        RestAPI.Folders.updateFolderMembers(contexts['branden'].restContext, folder.id, changes, function (err) {
                            if (err) return callback(err);

                            // Check if the user had keep the same access to the loodle he is invited in and is still a participant in the loodle
                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                assert.equal(err, null);
                                assert.equal(content.isManager, true);

                                var users = _.pluck(content.loodleData.users, 'first_name');
                                assert.equal(users.length, 2);
                                assert.equal(_.contains(users, 'Branden'), true);
                                assert.equal(_.contains(users, 'Simon'), true);

                                return callback();
                            });
                        })
                    });
                });

            });

        });

        it('should handle the case where the user has another access to one or many loodles of the folder through another folder : the user keeps the same access and is still not a participant of these loodles', function (callback) {

            setUpUsers(function (contexts) {

                // Create a first folder
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier 1', 'test', 'private', [contexts['simon'].user.id], [], function (err, folder1) {
                    if (err) return callback(err);

                    // Create a second folder with the sames users
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier 2', 'test', 'private', [contexts['simon'].user.id], [], function (err, folder2) {
                        if (err) return callback(err);

                        // Create a loodle inside of the two folders
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [], [], [folder1.id, folder2.id], function (err, data) {
                            if (err) return callback(err);

                            // Remove an user from the first folder
                            var changes = {};
                            changes[contexts['simon'].user.id] = false;
                            RestAPI.Folders.updateFolderMembers(contexts['branden'].restContext, folder1.id, changes, function (err) {
                                if (err) return callback(err);

                                // Check if the removed user has still a read only access to the loodles and is still not a participant in the loodle
                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);
                                    assert.equal(content.isManager, false);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 1);
                                    assert.equal(_.contains(users, 'Branden'), true);

                                    return callback();
                                });
                            });
                        });
                    });
                });

            });

        });

    });

    describe('remove a group from a folder', function () {

        it('should remove the access to the loodles of the folder for the group', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, group) {
                    if (err) return callback(err);

                    // Create a folder with the group as member
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [], [group.id], function (err, folder) {
                        if (err) return callback(err);

                        // Create a loodle inside of the folder
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [], [], [folder.id], function (err, data) {
                            if (err) return callback(err);

                            // Remove the group from the folder
                            var changes = {};
                            changes[group.id] = false;
                            RestAPI.Folders.updateFolderMembers(contexts['branden'].restContext, folder.id, changes, function (err) {
                                if (err) return callback(err);

                                // Check if the group users do not have access to the loodle anymore
                                async.series({
                                    getBySimon: function (done) {
                                        RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err) {
                                            assert.notEqual(err, null);
                                            assert.equal(err.code, 401);
                                            assert.equal(err.msg, 'The current user does not have access to this resource');

                                            return done();
                                        });
                                    },
                                    getByStuart: function (done) {
                                        RestAPI.Content.getContent(contexts['stuart'].restContext, data.id, function (err) {
                                            assert.notEqual(err, null);
                                            assert.equal(err.code, 401);
                                            assert.equal(err.msg, 'The current user does not have access to this resource');

                                            return done();
                                        });
                                    }
                                }, callback);
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the removed group has another access to one or many loodles of the folder thanks to being personaly invited or through another group : the group users keep the same access are still participants of these loodles', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, group) {
                    if (err) return callback(err);

                    // Create a folder
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [], [group.id], function (err, folder) {
                        if (err) return callback(err);

                        // Create a loodle inside of the folder and with the group as member
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [group.id], [], [folder.id], function (err, data) {
                            if (err) return callback(err);

                            // Remove the group from the folder
                            var changes = {};
                            changes[group.id] = false;
                            RestAPI.Folders.updateFolderMembers(contexts['branden'].restContext, folder.id, changes, function (err) {
                                if (err) return callback(err);

                                // Check the group users have still the same access to the loodle and are still participants in it
                                async.series({
                                    getBySimon: function (done) {
                                        RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                            assert.equal(err, null);
                                            assert.equal(content.isManager, true);

                                            var users = _.pluck(content.loodleData.users, 'first_name');
                                            assert.equal(users.length, 3);
                                            assert.equal(_.contains(users, 'Branden'), true);
                                            assert.equal(_.contains(users, 'Simon'), true);
                                            assert.equal(_.contains(users, 'Stuart'), true);

                                            return done();
                                        });
                                    },
                                    getByStuart: function (done) {
                                        RestAPI.Content.getContent(contexts['stuart'].restContext, data.id, function (err, content) {
                                            assert.equal(err, null);
                                            assert.equal(content.isManager, true);

                                            var users = _.pluck(content.loodleData.users, 'first_name');
                                            assert.equal(users.length, 3);
                                            assert.equal(_.contains(users, 'Branden'), true);
                                            assert.equal(_.contains(users, 'Simon'), true);
                                            assert.equal(_.contains(users, 'Stuart'), true);

                                            return done();
                                        });
                                    }
                                }, callback);
                            })
                        });
                    });
                });

            });

        });

        it('should handle the case where the removed group has another access to one or many loodles of the folder through another folder : the group users keep the same access are still not participants of these loodles', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, group) {
                    if (err) return callback(err);

                    // Create a first folder with the group as member
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier 1', 'test', 'private', [], [group.id], function (err, folder1) {
                        if (err) return callback(err);

                        // Create a second folder with the group as member
                        RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier 2', 'test', 'private', [], [group.id], function (err, folder2) {
                            if (err) return callback(err);

                            // Create a loodle inside of the two folders
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [], [], [folder1.id, folder2.id], function (err, data) {
                                if (err) return callback(err);

                                // Remove the group from the first folder
                                var changes = {};
                                changes[group.id] = false;
                                RestAPI.Folders.updateFolderMembers(contexts['branden'].restContext, folder1.id, changes, function (err) {
                                    if (err) return callback(err);

                                    // Check that the group users have still the same read only access to the loodle and are still not participants to it
                                    async.series({
                                        getBySimon: function (done) {
                                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, false);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 1);
                                                assert.equal(_.contains(users, 'Branden'), true);

                                                return done();
                                            });
                                        },
                                        getByStuart: function (done) {
                                            RestAPI.Content.getContent(contexts['stuart'].restContext, data.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, false);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 1);
                                                assert.equal(_.contains(users, 'Branden'), true);

                                                return done();
                                            });
                                        }
                                    }, callback);
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the removed group has an user who has another access to one or many loodles of the folder thanks to being personaly invited or through another group : the user keeps the same access and is still a participant in these loodles', function (callback) {


            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, group) {
                    if (err) return callback(err);

                    // Create a folder with the group as member
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [], [group.id], function (err, folder) {
                        if (err) return callback(err);

                        // Create a loodle inside the folder and one group user as members
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [contexts['simon'].user.id], [], [folder.id], function (err, data) {
                            if (err) return callback(err);

                            // Remove the group from the folder
                            var changes = {};
                            changes[group.id] = false;
                            RestAPI.Folders.updateFolderMembers(contexts['branden'].restContext, folder.id, changes, function (err) {
                                if (err) return callback(err);

                                // Check if the group user being invited personaly has still the same access and id still a participant in the loodle
                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);
                                    assert.equal(content.isManager, true);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 2);
                                    assert.equal(_.contains(users, 'Branden'), true);
                                    assert.equal(_.contains(users, 'Simon'), true);

                                    return callback();
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the removed group has an user who has another access to one or many loodles of the folder through another folder : the user keeps the same access and is still not a participant in these loodles', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, group) {
                    if (err) return callback(err);

                    // Create a first folder with the group as member
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier 1', 'test', 'private', [], [group.id], function (err, folder1) {
                        if (err) return callback(err);

                        // Create a second folder with one group user as member
                        RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier 2', 'test', 'private', [], [contexts['simon'].user.id], function (err, folder2) {
                            if (err) return callback(err);

                            // Create a loodle inside the two folders
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [], [], [folder1.id, folder2.id], function (err, data) {
                                if (err) return callback(err);

                                // Remove the group from the first folder
                                var changes = {};
                                changes[group.id] = false;
                                RestAPI.Folders.updateFolderMembers(contexts['branden'].restContext, folder1.id, changes, function (err) {
                                    if (err) return callback(err);

                                    // Check the group user inside the second folder has still a read only access to the loodle and is still not a participant to it
                                    RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                        assert.equal(err, null);
                                        assert.equal(content.isManager, false);

                                        var users = _.pluck(content.loodleData.users, 'first_name');
                                        assert.equal(users.length, 1);
                                        assert.equal(_.contains(users, 'Branden'), true);

                                        return callback();
                                    });
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the removed group has another group as member which has another access to one or many loodles of the folder thanks to being personaly invited or through another group : the group users keep the same access and are still participants in these loodles', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group B
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe B', 'test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, groupB) {
                    if (err) return callback(err);

                    // Create a group A with group B as member
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe A', 'test', 'private', 'no', [], [groupB.id], function (err, groupA) {
                        if (err) return callback(err);

                        // Create a folder with the group A as member
                        RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [], [groupA.id], function (err, folder) {
                            if (err) return callback(err);

                            // Create a loodle inside of the folder and with group B as member
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [], [groupB.id], [folder.id], function (err, data) {
                                if (err) return callback(err);

                                // Remove the group A from the folder
                                var changes = {};
                                changes[groupA.id] = false;
                                RestAPI.Folders.updateFolderMembers(contexts['branden'].restContext, folder.id, changes, function (err) {
                                    if (err) return callback(err);

                                    // Check if the group B users have still the same access to the loodle and are still participants
                                    async.series({
                                        getBySimon: function (done) {
                                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, false);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 3);
                                                assert.equal(_.contains(users, 'Branden'), true);
                                                assert.equal(_.contains(users, 'Simon'), true);
                                                assert.equal(_.contains(users, 'Stuart'), true);

                                                return done();
                                            });
                                        },
                                        getByStuart: function (done) {
                                            RestAPI.Content.getContent(contexts['stuart'].restContext, data.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, false);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 3);
                                                assert.equal(_.contains(users, 'Branden'), true);
                                                assert.equal(_.contains(users, 'Simon'), true);
                                                assert.equal(_.contains(users, 'Stuart'), true);

                                                return done();
                                            });
                                        }
                                    }, callback);
                                })
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the removed group has another group as member which has another access to one or many loodles of the folder through another folder : the group users keep the same access and are still not participants in these loodles', function (callback) {


            setUpUsers(function (contexts) {

                // Create group B
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe B', 'test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, groupB) {
                    if (err) return callback(err);

                    // Create group A with group B as member
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe A', 'test', 'private', 'no', [], [groupB.id], function (err, groupA) {
                        if (err) return callback(err);

                        // Create a first folder with group A as member
                        RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier 1', 'test', 'private', [], [groupA.id], function (err, folder1) {
                            if (err) return callback(err);

                            // Create a second folder with group B as member
                            RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier 2', 'test', 'private', [], [groupB.id], function (err, folder2) {
                                if (err) return callback(err);

                                // Create a loodle inside of the two folders
                                RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [], [], [folder1.id, folder2.id], function (err, data) {
                                    if (err) return callback(err);

                                    // Remove group A from the first folder
                                    var changes = {};
                                    changes[groupA.id] = false;
                                    RestAPI.Folders.updateFolderMembers(contexts['branden'].restContext, folder1.id, changes, function (err) {
                                        if (err) return callback(err);

                                        // Check the group B users have still a read only access to the loodle and are still not participants
                                        async.series({
                                            getBySimon : function (done) {
                                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                                    assert.equal(err, null);
                                                    assert.equal(content.isManager, false);

                                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                                    assert.equal(users.length, 1);
                                                    assert.equal(_.contains(users, 'Branden'), true);

                                                    return done();
                                                });
                                            },
                                            getByStuart: function (done) {
                                                RestAPI.Content.getContent(contexts['stuart'].restContext, data.id, function (err, content) {
                                                    assert.equal(err, null);
                                                    assert.equal(content.isManager, false);

                                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                                    assert.equal(users.length, 1);
                                                    assert.equal(_.contains(users, 'Branden'), true);

                                                    return done();
                                                });
                                            }
                                        }, callback);
                                    });
                                });
                            });
                        });
                    });
                });

            });

        });

    });

    describe('add another user to a group', function () {

        it('should give an access to all the loodles of the group to the new user and him/her as participant in each of them', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe' ,'test', 'private', 'no', [], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a first loodle with the group as member
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [group.id], [], [], function (err, data1) {
                        if (err) return callback(err);

                        // Create a second loodle with the group as member
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [], [group.id], [], function (err, data2) {
                            if (err) return callback(err);

                            // Add another user to the group
                            var changes = {};
                            changes[contexts['simon'].user.id] = 'manager';
                            RestAPI.Group.setGroupMembers(contexts['branden'].restContext, group.id, changes, function (err) {
                                if (err) return callback(err);

                                // Check the user has the same access as his/her group to the loodles and is a participant in these loodles
                                async.series({
                                    getFirstLoodleBySimon: function (done) {
                                        RestAPI.Content.getContent(contexts['simon'].restContext, data1.id, function (err, content) {
                                            assert.equal(err, null);
                                            assert.equal(content.isManager, true);

                                            var users = _.pluck(content.loodleData.users, 'first_name');
                                            assert.equal(users.length, 2);
                                            assert.equal(_.contains(users, 'Branden'), true);
                                            assert.equal(_.contains(users, 'Simon'), true);

                                            return done();
                                        });
                                    },
                                    getSecondLoodleBySimon: function (done) {
                                        RestAPI.Content.getContent(contexts['simon'].restContext, data2.id, function (err, content) {
                                            assert.equal(err, null);
                                            assert.equal(content.isManager, false);

                                            var users = _.pluck(content.loodleData.users, 'first_name');
                                            assert.equal(users.length, 2);
                                            assert.equal(_.contains(users, 'Branden'), true);
                                            assert.equal(_.contains(users, 'Simon'), true);

                                            return done();
                                        });
                                    }
                                }, callback);
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the added user already has another acces to one or many loodles of the group thanks to being personaly invited or through another group : the user is not added again as participant to these loodles and have an updated role according to his/her access', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a first loodle with the group and another user as members
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [group.id], [contexts['simon'].user.id], [], function (err, data1) {
                        if (err) return callback(err);

                        // Create a second loodle with the group and another user as members
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [contexts['simon'].user.id], [group.id], [], function (err, data2) {
                            if (err) return callback(err);

                            // Add one user to group A
                            var changes = {};
                            changes[contexts['simon'].user.id] = 'manager';
                            RestAPI.Group.setGroupMembers(contexts['branden'].restContext, group.id, changes, function (err) {
                                if (err) return callback(err);

                                // Check the user added to group A is not added again as participant and have an updated role if group A access was "higher" to the user access he/she already had
                                async.series({
                                    getFirstLoodleBySimon: function (done) {
                                        RestAPI.Content.getContent(contexts['simon'].restContext, data1.id, function (err, content) {
                                            assert.equal(err, null);
                                            assert.equal(content.isManager, true);

                                            var users = _.pluck(content.loodleData.users, 'first_name');
                                            assert.equal(users.length, 2);
                                            assert.equal(_.contains(users, 'Branden'), true);
                                            assert.equal(_.contains(users, 'Simon'), true);

                                            return done();
                                        });
                                    },
                                    getSecondLoodleBySimon: function (done) {
                                        RestAPI.Content.getContent(contexts['simon'].restContext, data2.id, function (err, content) {
                                            assert.equal(err, null);
                                            assert.equal(content.isManager, true);

                                            var users = _.pluck(content.loodleData.users, 'first_name');
                                            assert.equal(users.length, 2);
                                            assert.equal(_.contains(users, 'Branden'), true);
                                            assert.equal(_.contains(users, 'Simon'), true);

                                            return done();
                                        });
                                    }
                                }, callback);
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the added user already has another acces to one or many loodles of the group through another folder : the user is added as participant to these loodles and get the same access as the group', function (callback) {

            setUpUsers(function (contexts) {

                // Create a folder
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [contexts['simon'].user.id], [], function (err, folder) {
                    if (err) return callback(err);

                    // Create a group
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [], [], function (err, group) {
                        if (err) return callback(err);

                        // Create a first loodle inside of the folder and with the group as member
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [group.id], [], [folder.id], function (err, data1) {
                            if (err) return callback(err);

                            // Create a second loodle inside of the folder and with the group as member
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [], [group.id], [folder.id], function (err, data2) {
                                if (err) return callback(err);

                                // Add one folder user to the group
                                var changes = {};
                                changes[contexts['simon'].user.id] = 'manager';
                                RestAPI.Group.setGroupMembers(contexts['branden'].restContext, group.id, changes, function (err) {
                                    if (err) return callback(err);

                                    // Check if the user has the same access as the group to the loodles and is a participant in these loodles
                                    async.series({
                                        getFirstLoodleBySimon: function (done) {
                                            RestAPI.Content.getContent(contexts['simon'].restContext, data1.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, true);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 2);
                                                assert.equal(_.contains(users, 'Branden'), true);
                                                assert.equal(_.contains(users, 'Simon'), true);

                                                return done();
                                            });
                                        },
                                        getSecondLoodleBySimon: function (done) {
                                            RestAPI.Content.getContent(contexts['simon'].restContext, data2.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, false);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 2);
                                                assert.equal(_.contains(users, 'Branden'), true);
                                                assert.equal(_.contains(users, 'Simon'), true);

                                                return done();
                                            });
                                        }
                                    }, callback);
                                });
                            });
                        });
                    });
                });

            });

        });

    });

    describe('add a group B to a group A', function () {

        it('should give an access to all the loodles of group A to group B and should add as participants in the group A loodles all the group B users', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group A
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe A', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, groupA) {
                    if (err) return callback(err);

                    // Create a group B
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe B', 'test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, groupB) {
                        if (err) return callback(err);

                        // Create a first loodle inside of group A
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [groupA.id], [], [], function (err, data1) {
                            if (err) return callback(err);

                            // Create a second loodle inside of group A
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [], [groupA.id], [], function (err, data2) {
                                if (err) return callback(err);

                                // Add group B to group A
                                var changes = {};
                                changes[groupB.id] = 'manager';
                                RestAPI.Group.setGroupMembers(contexts['branden'].restContext, groupA.id, changes, function (err) {
                                    if (err) return callback(err);

                                    // Check if all the users of group B have an access to all the loodles of group A
                                    async.series({
                                        getFirstLoodleBySimon: function (done) {
                                            RestAPI.Content.getContent(contexts['simon'].restContext, data1.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, true);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 3);
                                                assert.equal(_.contains(users, 'Branden'), true);
                                                assert.equal(_.contains(users, 'Simon'), true);
                                                assert.equal(_.contains(users, 'Stuart'), true);

                                                return done();
                                            });
                                        },
                                        getFirstLoodleByStuart: function (done) {
                                            RestAPI.Content.getContent(contexts['stuart'].restContext, data1.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, true);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 3);
                                                assert.equal(_.contains(users, 'Branden'), true);
                                                assert.equal(_.contains(users, 'Simon'), true);
                                                assert.equal(_.contains(users, 'Stuart'), true);

                                                return done();
                                            });
                                        },
                                        getSecondLoodleBySimon: function (done) {
                                            RestAPI.Content.getContent(contexts['simon'].restContext, data2.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, false);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 3);
                                                assert.equal(_.contains(users, 'Branden'), true);
                                                assert.equal(_.contains(users, 'Simon'), true);
                                                assert.equal(_.contains(users, 'Stuart'), true);

                                                return done();
                                            });
                                        },
                                        getSecondLoodleByStuart: function (done) {
                                            RestAPI.Content.getContent(contexts['stuart'].restContext, data2.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, false);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 3);
                                                assert.equal(_.contains(users, 'Branden'), true);
                                                assert.equal(_.contains(users, 'Simon'), true);
                                                assert.equal(_.contains(users, 'Stuart'), true);

                                                return done();
                                            });
                                        }
                                    }, callback);
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the group B has another access to one or many loodles of group A thanks to being personaly invited or through another group : the group users are not added again as participants in these loodles and keep/gain the "higher" role according to their access', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group A
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe A', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, groupA) {
                    if (err) return callback(err);

                    // Create a group B
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe B', 'test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, groupB) {
                        if (err) return callback(err);

                        // Create a first loodle with group A and group B as members
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [groupA.id], [groupB.id], [], function (err, data1) {
                            if (err) return callback(err);

                            // Create a second loodle with group A and group B as members
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [groupB.id], [groupA.id], [], function (err, data2) {
                                if (err) return callback(err);

                                // Add group B to group A
                                var changes = {};
                                changes[groupB.id] = 'manager';
                                RestAPI.Group.setGroupMembers(contexts['branden'].restContext, groupA.id, changes, function (err) {
                                    if (err) return callback(err);

                                    // Check if the group B users have the correct access to the group A loodles and are not added again as participants
                                    async.series({
                                        getFirstLoodleBySimon: function (done) {
                                            RestAPI.Content.getContent(contexts['simon'].restContext, data1.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, true);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 3);
                                                assert.equal(_.contains(users, 'Branden'), true);
                                                assert.equal(_.contains(users, 'Simon'), true);
                                                assert.equal(_.contains(users, 'Stuart'), true);

                                                return done();
                                            });
                                        },
                                        getFirstLoodleByStuart: function (done) {
                                            RestAPI.Content.getContent(contexts['stuart'].restContext, data1.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, true);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 3);
                                                assert.equal(_.contains(users, 'Branden'), true);
                                                assert.equal(_.contains(users, 'Simon'), true);
                                                assert.equal(_.contains(users, 'Stuart'), true);

                                                return done();
                                            });
                                        },
                                        getSecondLoodleBySimon: function (done) {
                                            RestAPI.Content.getContent(contexts['simon'].restContext, data2.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, true);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 3);
                                                assert.equal(_.contains(users, 'Branden'), true);
                                                assert.equal(_.contains(users, 'Simon'), true);
                                                assert.equal(_.contains(users, 'Stuart'), true);

                                                return done();
                                            });
                                        },
                                        getSecondLoodleByStuart: function (done) {
                                            RestAPI.Content.getContent(contexts['stuart'].restContext, data2.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, true);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 3);
                                                assert.equal(_.contains(users, 'Branden'), true);
                                                assert.equal(_.contains(users, 'Simon'), true);
                                                assert.equal(_.contains(users, 'Stuart'), true);

                                                return done();
                                            });
                                        }
                                    }, callback);
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the group B has another access to one or many loodles of group A through another folder : the group users are added as participants and get an access in these loodles', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group A
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe A', 'test', 'private', 'no', [], [], function (err, groupA) {
                    if (err) return callback(err);

                    // Create a group B
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe B', 'test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, groupB) {
                        if (err) return callback(err);

                        // Create a folder with group B as member
                        RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [groupB.id], [], function (err, folder) {
                            if (err) return callback(err);

                            // Create a first loodle inside of the folder and with group A as member
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [groupA.id], [], [folder.id], function (err, data1) {
                                if (err) return callback(err);

                                // Create a second loodle inside of the folder and with group B as member
                                RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [], [groupA.id], [folder.id], function (err, data2) {
                                    if (err) return callback(err);

                                    // Add group B to group A
                                    var changes = {};
                                    changes[groupB.id] = 'manager';
                                    RestAPI.Group.setGroupMembers(contexts['branden'].restContext, groupA.id, changes, function (err) {
                                        if (err) return callback(err);

                                        // Check if the group B users have the correct access to the group A loodles and are participants in these loodles
                                        async.series({
                                            getFirstLoodleBySimon: function (done) {
                                                RestAPI.Content.getContent(contexts['simon'].restContext, data1.id, function (err, content) {
                                                    assert.equal(err, null);
                                                    assert.equal(content.isManager, true);

                                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                                    assert.equal(users.length, 3);
                                                    assert.equal(_.contains(users, 'Branden'), true);
                                                    assert.equal(_.contains(users, 'Simon'), true);
                                                    assert.equal(_.contains(users, 'Stuart'), true);

                                                    return done();
                                                });
                                            },
                                            getFirstLoodleByStuart: function (done) {
                                                RestAPI.Content.getContent(contexts['stuart'].restContext, data1.id, function (err, content) {
                                                    assert.equal(err, null);
                                                    assert.equal(content.isManager, true);

                                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                                    assert.equal(users.length, 3);
                                                    assert.equal(_.contains(users, 'Branden'), true);
                                                    assert.equal(_.contains(users, 'Simon'), true);
                                                    assert.equal(_.contains(users, 'Stuart'), true);

                                                    return done();
                                                });
                                            },
                                            getSecondLoodleBySimon: function (done) {
                                                RestAPI.Content.getContent(contexts['simon'].restContext, data2.id, function (err, content) {
                                                    assert.equal(err, null);
                                                    assert.equal(content.isManager, false);

                                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                                    assert.equal(users.length, 3);
                                                    assert.equal(_.contains(users, 'Branden'), true);
                                                    assert.equal(_.contains(users, 'Simon'), true);
                                                    assert.equal(_.contains(users, 'Stuart'), true);

                                                    return done();
                                                });
                                            },
                                            getSecondLoodleByStuart: function (done) {
                                                RestAPI.Content.getContent(contexts['stuart'].restContext, data2.id, function (err, content) {
                                                    assert.equal(err, null);
                                                    assert.equal(content.isManager, false);

                                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                                    assert.equal(users.length, 3);
                                                    assert.equal(_.contains(users, 'Branden'), true);
                                                    assert.equal(_.contains(users, 'Simon'), true);
                                                    assert.equal(_.contains(users, 'Stuart'), true);

                                                    return done();
                                                });
                                            }
                                        }, callback);
                                    });
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the group B has a user who has another access to one or many loodles of group A thanks to being personaly invited or through another group : the user is not added again as participant in these loodles and keeps/gains the "higher" role according to their access', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group A
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe A', 'test', 'private', 'no', [], [], function (err, groupA) {
                    if (err) return callback(err);

                    // Create a group B
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe B', 'test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, groupB) {
                        if (err) return callback(err);

                        // Create a first loodle with group A and one group B user as members
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [groupA.id], [contexts['simon'].user.id], [], function (err, data1) {
                            if (err) return callback(err);

                            // Create a second loodle with group A and on group B user as members
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [contexts['simon'].user.id], [groupA.id], [], function (err, data2) {
                                if (err) return callback(err);

                                // Add group B to group A
                                var changes = {};
                                changes[groupB.id] = 'manager';
                                RestAPI.Group.setGroupMembers(contexts['branden'].restContext, groupA.id, changes, function (err) {
                                    if (err) return callback(err);

                                    // Check if the group B user with multiple access to the group A loodles has a correct access and is not added as participant
                                    async.series({
                                        getFirstLoodleBySimon: function (done) {
                                            RestAPI.Content.getContent(contexts['simon'].restContext, data1.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, true);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 3);
                                                assert.equal(_.contains(users, 'Branden'), true);
                                                assert.equal(_.contains(users, 'Simon'), true);
                                                assert.equal(_.contains(users, 'Stuart'), true);

                                                return done();
                                            });
                                        },
                                        getSecondLoodleBySimon: function (done) {
                                            RestAPI.Content.getContent(contexts['simon'].restContext, data2.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, true);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 3);
                                                assert.equal(_.contains(users, 'Branden'), true);
                                                assert.equal(_.contains(users, 'Simon'), true);
                                                assert.equal(_.contains(users, 'Stuart'), true);

                                                return done();
                                            });
                                        }
                                    }, callback);
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the group B has a user who has another access to one or many loodles of group A through another folder : the user is added as participant in these loodles and get an access', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group A
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe A', 'test', 'private', 'no', [], [], function (err, groupA) {
                    if (err) return callback(err);

                    // Create a group B
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe B', 'test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, groupB) {
                        if (err) return callback(err);

                        // Create a folder with one group B user as member
                        RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [contexts['simon'].user.id], [], function (err, folder) {
                            if (err) return callback(err);

                            // Create a first loodle inside of the folder and with group A as member
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [groupA.id], [], [folder.id], function (err, data1) {
                                if (err) return callback(err);

                                // Create a second loodle inside of the folder and with group A as member
                                RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [], [groupA.id], [folder.id], function (err, data2) {
                                    if (err) return callback(err);

                                    // Add group B to group A
                                    var changes = {};
                                    changes[groupB.id] = 'manager';
                                    RestAPI.Group.setGroupMembers(contexts['branden'].restContext, groupA.id, changes, function (err) {
                                        if (err) return callback(err);

                                        // Check if the group B user with multiple access to the group A loodles has a correct access and is added as participant
                                        async.series({
                                            getFirstLoodleBySimon: function (done) {
                                                RestAPI.Content.getContent(contexts['simon'].restContext, data1.id, function (err, content) {
                                                    assert.equal(err, null);
                                                    assert.equal(content.isManager, true);

                                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                                    assert.equal(users.length, 3);
                                                    assert.equal(_.contains(users, 'Branden'), true);
                                                    assert.equal(_.contains(users, 'Simon'), true);
                                                    assert.equal(_.contains(users, 'Stuart'), true);

                                                    return done();
                                                });
                                            },
                                            getSecondLoodleBySimon: function (done) {
                                                RestAPI.Content.getContent(contexts['simon'].restContext, data2.id, function (err, content) {
                                                    assert.equal(err, null);
                                                    assert.equal(content.isManager, false);

                                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                                    assert.equal(users.length, 3);
                                                    assert.equal(_.contains(users, 'Branden'), true);
                                                    assert.equal(_.contains(users, 'Simon'), true);
                                                    assert.equal(_.contains(users, 'Stuart'), true);

                                                    return done();
                                                });
                                            }
                                        }, callback);
                                    });
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the group B has another group as member which has another access to one or many loodles of group A thanks to being personaly invited or through another group : the group users are not added again as participants in these loodles and keep/gain the "higher" role according to their access', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group A
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe A', 'test', 'private', 'no', [], [], function (err, groupA) {
                    if (err) return callback(err);

                    // Create a group C
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe C', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, groupC) {
                        if (err) return callback(err);

                        // Create a group B with group C as member
                        RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe B', 'test', 'private', 'no', [groupC.id], [contexts['stuart'].user.id], function (err, groupB) {
                            if (err) return callback(err);

                            // Create a first loodle with group A and C as members
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [groupA.id], [groupC.id], [], function (err, data1) {
                                if (err) return callback(err);

                                // Create a second loodle with group A and C as members
                                RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [groupC.id], [groupA.id], [], function (err, data2) {
                                    if (err) return callback(err);

                                    // Add group B to group A
                                    var changes = {};
                                    changes[groupB.id] = 'manager';
                                    RestAPI.Group.setGroupMembers(contexts['branden'].restContext, groupA.id, changes, function (err) {
                                        if (err) return callback(err);

                                        // Check the group C users have the correct access to group A loodles and are not added again as participants
                                        async.series({
                                            getFirstLoodleBySimon: function (done) {
                                                RestAPI.Content.getContent(contexts['simon'].restContext, data1.id, function (err, content) {
                                                    assert.equal(err, null);
                                                    assert.equal(content.isManager, true);

                                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                                    assert.equal(users.length, 3);
                                                    assert.equal(_.contains(users, 'Branden'), true);
                                                    assert.equal(_.contains(users, 'Simon'), true);
                                                    assert.equal(_.contains(users, 'Stuart'), true);

                                                    return done();
                                                });
                                            },
                                            getSecondLoodleBySimon: function (done) {
                                                RestAPI.Content.getContent(contexts['simon'].restContext, data2.id, function (err, content) {
                                                    assert.equal(err, null);
                                                    assert.equal(content.isManager, true);

                                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                                    assert.equal(users.length, 3);
                                                    assert.equal(_.contains(users, 'Branden'), true);
                                                    assert.equal(_.contains(users, 'Simon'), true);
                                                    assert.equal(_.contains(users, 'Stuart'), true);

                                                    return done();
                                                });
                                            }
                                        }, callback);
                                    });
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the group B has another group as member which has another access to one or many loodles of group A through another folder : the group get an access and the group users are added as participants in these loodles', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group A
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe A', 'test', 'private', 'no', [], [], function (err, groupA) {
                    if (err) return callback(err);

                    // Create a group C
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe C', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, groupC) {
                        if (err) return callback(err);

                        // Create a group B with group C as member
                        RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe B', 'test', 'private', 'no', [groupC.id], [contexts['stuart'].user.id], function (err, groupB) {
                            if (err) return callback(err);

                            // Create a folder with group C as member
                            RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [groupC.id], [], function (err, folder) {
                                if (err) return callback(err);

                                // Create a first loodle inside of the folder and with group A as member
                                RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [groupA.id], [], [folder.id], function (err, data1) {
                                    if (err) return callback(err);

                                    // Create a second loodle inside of the folder and with group A as member
                                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [], [groupA.id], [folder.id], function (err, data2) {
                                        if (err) return callback(err);

                                        // Add group B to group A
                                        var changes = {};
                                        changes[groupB.id] = 'manager';
                                        RestAPI.Group.setGroupMembers(contexts['branden'].restContext, groupA.id, changes, function (err) {
                                            if (err) return callback(err);

                                            // Check the group C users have the correct access to group A loodles and are not added again as participants
                                            async.series({
                                                getFirstLoodleBySimon: function (done) {
                                                    RestAPI.Content.getContent(contexts['simon'].restContext, data1.id, function (err, content) {
                                                        assert.equal(err, null);
                                                        assert.equal(content.isManager, true);

                                                        var users = _.pluck(content.loodleData.users, 'first_name');
                                                        assert.equal(users.length, 3);
                                                        assert.equal(_.contains(users, 'Branden'), true);
                                                        assert.equal(_.contains(users, 'Simon'), true);
                                                        assert.equal(_.contains(users, 'Stuart'), true);

                                                        return done();
                                                    });
                                                },
                                                getSecondLoodleBySimon: function (done) {
                                                    RestAPI.Content.getContent(contexts['simon'].restContext, data2.id, function (err, content) {
                                                        assert.equal(err, null);
                                                        assert.equal(content.isManager, false);

                                                        var users = _.pluck(content.loodleData.users, 'first_name');
                                                        assert.equal(users.length, 3);
                                                        assert.equal(_.contains(users, 'Branden'), true);
                                                        assert.equal(_.contains(users, 'Simon'), true);
                                                        assert.equal(_.contains(users, 'Stuart'), true);

                                                        return done();
                                                    });
                                                }
                                            }, callback);
                                        });
                                    });
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where group B is added to group A but group A is also a member of group B : every users of group B have an access and are added as participants in every loodles of group A', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group A
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe A', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, groupA) {
                    if (err) return callback(err);

                    // Create a group B with group A as member
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe B', 'test', 'private', 'no', [contexts['stuart'].user.id], [groupA.id], function (err, groupB) {
                        if (err) return callback(err);

                        // Create a first loodle with group A as member
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [groupA.id], [], [], function (err, data1) {
                            if (err) return callback(err);

                            // Create a second loodle with group A as member
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [], [groupA.id], [], function (err, data2) {
                                if (err) return callback(err);

                                // Add group B to group A
                                var changes = {};
                                changes[groupB.id] = 'manager';
                                RestAPI.Group.setGroupMembers(contexts['branden'].restContext, groupA.id, changes, function (err) {
                                    if (err) return callback(err);

                                    // Check it the users of group B have access to the loodles of group A and are added as participants when they were not
                                    async.series({
                                        getFirstLoodleBySimon: function (done) {
                                            RestAPI.Content.getContent(contexts['simon'].restContext, data1.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, true);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 3);
                                                assert.equal(_.contains(users, 'Branden'), true);
                                                assert.equal(_.contains(users, 'Simon'), true);
                                                assert.equal(_.contains(users, 'Stuart'), true);

                                                return done();
                                            });
                                        },
                                        getFirstLoodleByStuart: function (done) {
                                            RestAPI.Content.getContent(contexts['stuart'].restContext, data1.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, true);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 3);
                                                assert.equal(_.contains(users, 'Branden'), true);
                                                assert.equal(_.contains(users, 'Simon'), true);
                                                assert.equal(_.contains(users, 'Stuart'), true);

                                                return done();
                                            });
                                        },
                                        getSecondLoodleBySimon: function (done) {
                                            RestAPI.Content.getContent(contexts['simon'].restContext, data2.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, false);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 3);
                                                assert.equal(_.contains(users, 'Branden'), true);
                                                assert.equal(_.contains(users, 'Simon'), true);
                                                assert.equal(_.contains(users, 'Stuart'), true);

                                                return done();
                                            });
                                        },
                                        getSecondLoodleByStuart: function (done) {
                                            RestAPI.Content.getContent(contexts['stuart'].restContext, data2.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, false);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 3);
                                                assert.equal(_.contains(users, 'Branden'), true);
                                                assert.equal(_.contains(users, 'Simon'), true);
                                                assert.equal(_.contains(users, 'Stuart'), true);

                                                return done();
                                            });
                                        }
                                    }, callback);
                                });
                            });
                        });
                    });

                });

            });
        });

    });

    describe('add another user to a folder', function () {

        it('should give an access to all the loodles of the folder to the new user and should not add him/her as participant', function (callback) {

            setUpUsers(function (contexts) {

                // Create a folder
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon folder', 'test', 'private', [], [], function (err, folder) {
                    if (err) return callback(err);

                    // Create a loodle inside of the folder
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [], [], [folder.id], function (err, data) {
                        if (err) return callback(err);

                        // Add another user to the folder
                        var changes = {};
                        changes[contexts['simon'].user.id] = 'manager';
                        RestAPI.Folders.updateFolderMembers(contexts['branden'].restContext, folder.id, changes, function (err) {
                            if (err) return callback(err);

                            // Check if the user has a read only access to the folder loodle and is not added as participant in it
                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                assert.equal(err, null);
                                assert.equal(content.isManager, false);

                                var users = _.pluck(content.loodleData.users, 'first_name');
                                assert.equal(users.length, 1);
                                assert.equal(_.contains(users, 'Branden'), true);

                                return callback();
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the added user already has another access to one or many loodles of the folder thanks to being personaly invited or through another group : the user is still a participant in these loodles and keeps the same role', function (callback) {

            setUpUsers(function (contexts) {

                // Create a folder
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [], [], function (err, folder) {
                    if (err) return callback(err);

                    // Create a loodle inside of the folder and with one other user as member
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [contexts['simon'].user.id], [], [folder.id], function (err, data) {
                        if (err) return callback(err);

                        // Add the user inside of the folder
                        var changes = {};
                        changes[contexts['simon'].user.id] = 'manager';
                        RestAPI.Folders.updateFolderMembers(contexts['branden'].restContext, folder.id, changes, function (err) {
                            if (err) return callback(err);

                            // Check if the user still has the same access and is still a participant in the loodle
                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                assert.equal(err, null);
                                assert.equal(content.isManager, true);

                                var users = _.pluck(content.loodleData.users, 'first_name');
                                assert.equal(users.length, 2);
                                assert.equal(_.contains(users, 'Branden'), true);
                                assert.equal(_.contains(users, 'Simon'), true);

                                return callback();
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the added user already has another access to one or many loodles of the folder through another folder : the user is still not added as participant in these loodles and keeps the same read only access', function (callback) {

            setUpUsers(function (contexts) {

                // Create a first folder A
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier A', 'test', 'private', [], [], function (err, folderA) {
                    if (err) return callback(err);

                    // Create a second folder B
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier B', 'test', 'private', [contexts['simon'].user.id], [], function (err, folderB) {
                        if (err) return callback(err);

                        // Create a loodle inside of folder A and B
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [], [], [folderA.id, folderB.id], function (err, data) {
                            if (err) return callback(err);

                            // Add one folder B user to folder A
                            var changes = {};
                            changes[contexts['simon'].user.id] = 'manager';
                            RestAPI.Folders.updateFolderMembers(contexts['branden'].restContext, folderA.id, changes, function (err) {
                                if (err) return callback(err);

                                // Check if the user keeps the same access to folder A loodle and is still not added as participant
                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);
                                    assert.equal(content.isManager, false);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 1);
                                    assert.equal(_.contains(users, 'Branden'), true);

                                    return callback();
                                });
                            });
                        });
                    });
                });

            });

        });

    });

    describe('add another group to a fodler', function () {

        it('should give an access to all the loodles of the folder to the new group but not add the group users as participants in the folder loodles', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a folder
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [], [], function (err, folder) {
                        if (err) return callback(err);

                        // Create a loodle inside the folder
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [], [], [folder.id], function (err, data) {
                            if (err) return callback(err);

                            // Add the group to the folder
                            var changes = {};
                            changes[group.id] = 'manager';
                            RestAPI.Folders.updateFolderMembers(contexts['branden'].restContext, folder.id, changes, function (err) {
                                if (err) return callback(err);

                                // Check if the group members have access to the folder loodle and are not participants in it
                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);
                                    assert.equal(content.isManager, false);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 1);
                                    assert.equal(_.contains(users, 'Branden'), true);

                                    return callback();
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the added group already has another access to one or many loodles of the folder thanks to being personaly invited or through another group : the group users are still participants in these loodles and keep the same role', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a folder
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [], [], function (err, folder) {
                        if (err) return callback(err);

                        // Create a loodle inside of the folder and with the group as member
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [group.id], [], [folder.id], function (err, data) {
                            if (err) return callback(err);

                            // Add the group to the folder
                            var changes = {};
                            changes[group.id] = 'manager';
                            RestAPI.Folders.updateFolderMembers(contexts['branden'].restContext, folder.id, changes, function (err) {
                                if (err) return callback(err);

                                // Check the group users have still the same access and are still participants to the loodle
                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);
                                    assert.equal(content.isManager, true);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 2);
                                    assert.equal(_.contains(users, 'Branden'), true);
                                    assert.equal(_.contains(users, 'Simon'), true);

                                    return callback();
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the added group already has another access to one or many loodles of the folder through another folder : the group users are still not added as participants in these loodles and keep the same role', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a first folder A
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier A', 'test', 'private', [], [], function (err, folderA) {
                        if (err) return callback(err);

                        // Create a second folder B with the group as member
                        RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier B', 'test', 'private', [group.id], [], function (err, folderB) {
                            if (err) return callback(err);

                            // Create a loodle inside of the two folders
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [], [], [folderA.id, folderB.id], function (err, data) {
                                if (err) return callback(err);

                                // Add the group to folder A
                                var changes = {};
                                changes[group.id] = 'manager';
                                RestAPI.Folders.updateFolderMembers(contexts['branden'].restContext, folderA.id, changes, function (err) {
                                    if (err) return callback(err);

                                    // Check the group user has still the same access and is still not a participant in the loodle
                                    RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                        assert.equal(err, null);
                                        assert.equal(content.isManager, false);

                                        var users = _.pluck(content.loodleData.users, 'first_name');
                                        assert.equal(users.length, 1);
                                        assert.equal(_.contains(users, 'Branden'), true);

                                        return callback();
                                    });
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the added group has an user who already has another access to one or many loodles of the folder thanks to being personaly invited or through another group : the user is still a participant in these loodles and keeps the same role', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a folder
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [],[], function (err, folder) {
                        if (err) return callback(err);

                        // Create a loodle inside of the folder and with one group user as member
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [contexts['simon'].user.id], [], [folder.id], function (err, data) {
                            if (err) return callback(err);

                            // Add the group to the folder
                            var changes = {};
                            changes[group.id] = 'manager';
                            RestAPI.Folders.updateFolderMembers(contexts['branden'].restContext, folder.id, changes, function (err) {
                                if (err) return callback(err);

                                // Check the group user with multiple access to the loodle has still the same access as it's group and is still a participant in the loodle
                                RestAPI.Content.getContent(contexts['branden'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);
                                    assert.equal(content.isManager, true);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 2);
                                    assert.equal(_.contains(users, 'Branden'), true);
                                    assert.equal(_.contains(users, 'Simon'), true);

                                    return callback();
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the added group has an user who already has another access to one or many loodles of the folder through another folder : the user is still not added as a participant in these loodles and keep the same role', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a first folder A
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier A', 'test', 'private', [], [], function (err, folderA) {
                        if (err) return callback(err)

                        // Create a second folder B with one group user as member
                        RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier B', 'test', 'private', [contexts['simon'].user.id], [], function (err, folderB) {
                            if (err) return callback(err);

                            // Create a loodle inside of the two folders
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [], [], [folderA.id, folderB.id], function (err, data) {
                                if (err) return callback(err);

                                // Add the group to folder A
                                var changes = {};
                                changes[group.id] = 'manager';
                                RestAPI.Folders.updateFolderMembers(contexts['branden'].restContext, folderA.id, changes, function (err) {
                                    if (err) return callback(err);
                                });

                                // Check if the group user with multiple access has the correct access to the loodle and is still not a participant
                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);
                                    assert.equal(content.isManager, false);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 1);
                                    assert.equal(_.contains(users, 'Branden'), true);

                                    return callback();
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the added group has another group as a member which already has another access to one or many loodles of the folder thanks to being personaly invited or through another group : the group users are still participants in these loodles and keep the same role', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group B
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe B', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, groupB) {
                    if (err) return callback(err);

                    // Create a group A with group B as member
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe A', 'test', 'private', 'no', [groupB.id], [], function (err, groupA) {
                        if (err) return callback(err);

                        // Create a folder
                        RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [], [], function (err, folder) {
                            if (err) return callback(err);

                            // Create a loodle inside of the folder and with group B as member
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [groupB.id], [], [folder.id], function (err, data) {
                                if (err) return callback(err);

                                // Add group A to the folder
                                var changes = {};
                                changes[groupA.id] = 'manager';
                                RestAPI.Folders.updateFolderMembers(contexts['branden'].restContext, folder.id, changes, function (err) {
                                    if (err) return callback(err);

                                    // Check if group B user has stil the same access and is still a participant in the loodle
                                    RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                        assert.equal(err, null);
                                        assert.equal(content.isManager, true);

                                        var users = _.pluck(content.loodleData.users, 'first_name');
                                        assert.equal(users.length, 2);
                                        assert.equal(_.contains(users, 'Branden'), true);
                                        assert.equal(_.contains(users, 'Simon'), true);

                                        return callback();
                                    });
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the added group has another group as a member which already has another access to one or many loodles of the folder through another folder : the group users are still not added as participants in these loodles and keep the same role', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group B
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe B', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, groupB) {
                    if (err) return callback(err);

                    // Create a group A with group B as member
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe A', 'test', 'private', 'no', [groupB.id], [], function (err, groupA) {
                        if (err) return callback(err);

                        // Create a first folder A
                        RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier A', 'test', 'private', [], [], function (err, folderA) {
                            if (err) return callback(err);

                            // Create a second folder B with group B as member
                            RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier B', 'test', 'private', [groupB.id], [], function (err, folderB) {
                                if (err) return callback(err);

                                // Create a loodle inside of the two folders
                                RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [], [], [folderA.id, folderB.id], function (err, data) {
                                    if (err) return callback(err);

                                    // Add group A to the folder A
                                    var changes = {};
                                    changes[groupA.id] = 'manager';
                                    RestAPI.Folders.updateFolderMembers(contexts['branden'].restContext, folderA.id, changes, function (err)  {
                                        if (err) return callback(err);

                                        // Check if group B user has stil the same access and is still a participant in the loodle
                                        RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                            assert.equal(err, null);
                                            assert.equal(content.isManager, false);

                                            var users = _.pluck(content.loodleData.users, 'first_name');
                                            assert.equal(users.length, 1);
                                            assert.equal(_.contains(users, 'Branden'), true);

                                            return callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });

            });

        });

    });

    describe('add a time slot to a loodle', function () {

        it('should add correctly the schedule to the loodle', function (callback) {

            setUpUsers(function (contexts) {

                // Create a loodle
                RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [], [], [], function (err, data) {
                    if (err) return callback(err);

                    // Add a time slot to the loodle
                    RestAPI.Content.getContent(contexts['branden'].restContext, data.id, function (err, content) {
                        var loodleId = content.loodleData.id;

                        var schedule = {
                            begin_time: '04/29/2016 3:00 PM',
                            end_time: '04/29/2016 4:00 PM',
                        };
                        RestAPI.Loodles.addSchedule(contexts['branden'].restContext, loodleId, schedule, function (err) {
                            if (err) return callback(err);

                            // Check the loodle have the new time slot registred
                            RestAPI.Content.getContent(contexts['branden'].restContext, data.id, function (err, content) {
                                assert.equal(err, null);
                                assert.equal(content.isManager, true);

                                var schedules = content.loodleData.schedules;
                                assert.equal(schedules[0].begin_time, '2016-04-29T13:00:00.000Z');
                                assert.equal(schedules[0].end_time, '2016-04-29T14:00:00.000Z');

                                return callback();
                            });
                        });
                    });
                });

            });

        });

        it('should create default votes about this time slot for all the participants of the loodle', function (callback) {

            setUpUsers(function (contexts) {

                // Create a loodle
                RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [], [], [], function (err, data) {
                    if (err) return callback(err);

                    // Add a time slot to the loodle
                    RestAPI.Content.getContent(contexts['branden'].restContext, data.id, function (err, content) {
                        if (err) return callback(err);

                        var loodleId = content.loodleData.id;
                        var schedule = {
                            begin_time: '04/29/2016 3:00 PM',
                            end_time: '04/29/2016 4:00 PM',
                        };
                        RestAPI.Loodles.addSchedule(contexts['branden'].restContext, loodleId, schedule, function (err) {
                            if (err) return callback(err);

                            // Check the loodle have the default votes for the new time slot registred
                            RestAPI.Content.getContent(contexts['branden'].restContext, data.id, function (err, content) {
                                assert.equal(err, null);
                                assert.equal(content.isManager, true);

                                var scheduleId = content.loodleData.schedules[0].id;
                                var scheduleIdsInVotes = _.pluck(content.loodleData.votes, 'schedule_id');
                                assert.equal(_.contains(scheduleIdsInVotes, scheduleId), true);

                                return callback();
                            });
                        });
                    });
                });

            });

        });

    });

    describe('remove a time slot from a loodle', function () {

        it('should remove the time slot from the loodle and delete all the votes associated with it', function (callback) {

            setUpUsers(function (contexts) {

                // Create a loodle
                RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [contexts['simon'].user.id], [contexts['stuart'].user.id], [], function (err, data) {
                    if (err) return callback(err);

                    // Add a new time slot
                    RestAPI.Content.getContent(contexts['branden'].restContext, data.id, function (err, content) {
                        if (err) return callback(err);

                        var loodleId = content.loodleData.id;
                        var schedule = {
                            begin_time: '04/29/2016 3:00 PM',
                            end_time: '04/29/2016 4:00 PM',
                        };
                        RestAPI.Loodles.addSchedule(contexts['branden'].restContext, loodleId, schedule, function (err) {
                            if (err) return callback(err);

                            // Remove the time slot from the loodle
                            RestAPI.Content.getContent(contexts['branden'].restContext, data.id, function (err, content) {
                                if (err) return callback(err);

                                var scheduleId = content.loodleData.schedules[0].id;
                                RestAPI.Loodles.deleteSchedule(contexts['branden'].restContext, loodleId, scheduleId, function (err) {
                                    if (err) return callback(err);

                                    // Check the time slot has been correctly removed from the loodle
                                    RestAPI.Content.getContent(contexts['branden'].restContext, data.id, function (err, content) {
                                        assert.equal(err, null);

                                        var schedules = content.loodleData.schedules;
                                        var votes = content.loodleData.votes;
                                        assert.equal(schedules.length, 0);
                                        assert.equal(votes.length, 0);

                                        return callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });

        });

    });

    describe('edit the votes of a loodle', function () {

        it('should correctly edit the votes of the loodle', function (callback) {

            setUpUsers(function (contexts) {

                // Create a loodle
                RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [], [], [], function (err, data) {
                    if (err) return callback(err);

                    // Add a new time slot
                    RestAPI.Content.getContent(contexts['branden'].restContext, data.id, function (err, content) {
                        if (err) return callback(err);

                        var loodleId = content.loodleData.id;
                        var schedule = {
                            begin_time: '04/29/2016 3:00 PM',
                            end_time: '04/29/2016 4:00 PM',
                        };
                        RestAPI.Loodles.addSchedule(contexts['branden'].restContext, loodleId, schedule, function (err) {
                            if (err) return callback(err);

                            RestAPI.Content.getContent(contexts['branden'].restContext, data.id, function (err, content) {
                                if (err) return callback(err);

                                // Edit the votes of one user
                                var voteId = content.loodleData.votes[0].vote_id;
                                var votes = {};
                                votes[voteId] = 1;
                                RestAPI.Loodles.updateVotes(contexts['branden'].restContext, loodleId, votes, function (err) {
                                    if (err) return callback(err);

                                    // Check if the votes have been correctly edited
                                    RestAPI.Content.getContent(contexts['branden'].restContext, data.id, function (err, content) {
                                        if (err) return callback(err);

                                        var votes = content.loodleData.votes;
                                        assert.equal(votes.length, 1);
                                        assert.equal(votes[0].vote_id, voteId);
                                        assert.equal(votes[0].vote, 1);

                                        return callback();
                                    });
                                });
                            });
                        });
                    });
                });

            });

        });

    });

});
