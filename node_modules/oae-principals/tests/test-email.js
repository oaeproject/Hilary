/*
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');

var ConfigTestUtil = require('oae-config/lib/test/util');
var EmailAPI = require('oae-email');
var EmailTestsUtil = require('oae-email/lib/test/util');
var PrincipalsTestUtil = require('oae-principals/lib/test/util');
var RestAPI = require('oae-rest');
var TestsUtil = require('oae-tests');

describe('Users', function() {

    // Rest contexts that can be used to make requests as different types of users
    var anonymousRestContext = null;
    var camAdminRestContext = null;
    var gtAdminRestContext = null;

    /**
     * Set up the rest contexts and drain the email queue. Note that
     * this needs to happen before each test
     */
    beforeEach(function(callback) {
        // Set up the rest contexts
        anonymousRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host);
        camAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.cam.host);
        gtAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.gt.host);

        // Drain the email queue
        EmailTestsUtil.clearEmailCollections(callback);
    });

    describe('Email tokens', function() {

        describe('Events', function() {
            /**
             * Test that verifies that an email token is sent when creating a user account through the REST api
             */
            it('verify a verification email is sent when creating a user account through the REST api', function(callback) {
                // Disable recaptcha so we can create a user
                ConfigTestUtil.updateConfigAndWait(camAdminRestContext, null, {'oae-principals/recaptcha/enabled': false}, function(err) {
                    assert.ok(!err);

                    var username = TestsUtil.generateTestUserId();
                    var email = TestsUtil.generateTestEmailAddress(username);
                    RestAPI.User.createUser(anonymousRestContext, username, 'password', 'Test User', {'email': email}, function(err) {
                        assert.ok(!err);
                    });

                    // Assert we've sent an email token
                    PrincipalsTestUtil.whenVerificationEmailSent(email, function(token) {

                        // Assert the email is not verified yet
                        var restContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, username, 'password');
                        RestAPI.User.getMe(restContext, function(err, me) {
                            assert.ok(!err);
                            assert.strictEqual(me.email, email);
                            assert.strictEqual(me.emailVerified, false);

                            // Enable re-captcha again
                            ConfigTestUtil.updateConfigAndWait(camAdminRestContext, null, {'oae-principals/recaptcha/enabled': true}, function(err) {
                                assert.ok(!err);
                                return callback();
                            });
                        });
                    });
                });
            });

            /**
             * Test that verifies that an email token is sent when a user updates his email address
             */
            it('verify a verification email is sent when a user updates his email address', function(callback) {
                TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, simong) {
                    assert.ok(!err);

                    var email = TestsUtil.generateTestEmailAddress();
                    RestAPI.User.updateUser(simong.restContext, simong.user.id, {'email': email}, function(err) {
                        assert.ok(!err);
                    });

                    // Assert we've sent an email token
                    PrincipalsTestUtil.whenVerificationEmailSent(email, function(token) {

                        // Assert the email is not verified yet
                        RestAPI.User.getMe(simong.restContext, function(err, me) {
                            assert.ok(!err);
                            assert.strictEqual(me.email, email);
                            assert.strictEqual(me.emailVerified, false);

                            return callback();
                        });
                    });
                });
            });
        });

        describe('Verifying email tokens', function() {

            /**
             * Test that verifies that an email token can be used to verify an email address
             */
            it('verify an email token can be used to verify an email address', function(callback) {
                TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, simong) {
                    assert.ok(!err);

                    var email = TestsUtil.generateTestEmailAddress();
                    RestAPI.User.updateUser(simong.restContext, simong.user.id, {'email': email}, function(err) {
                        assert.ok(!err);
                    });

                    // Assert we've sent an email token
                    PrincipalsTestUtil.whenVerificationEmailSent(email, function(token) {

                        // Verify the token
                        RestAPI.User.verifyEmailToken(simong.restContext, token, function(err) {
                            assert.ok(!err);

                            // Assert that the email was verified
                            RestAPI.User.getMe(simong.restContext, function(err, me) {
                                assert.ok(!err);
                                assert.strictEqual(me.emailVerified, true);

                                return callback();
                            });
                        });
                    });
                });
            });

            /**
             * Test that verifies the email tokens are validated
             */
            it('verify validation', function(callback) {
                TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, simong) {
                    assert.ok(!err);

                    RestAPI.User.verifyEmailToken(simong.restContext, null, function(err) {
                        assert.strictEqual(err.code, 400);

                        RestAPI.User.verifyEmailToken(simong.restContext, 'bad token', function(err) {
                            assert.strictEqual(err.code, 400);

                            RestAPI.User.verifyEmailToken(simong.restContext, 'email-nonexistingtoken', function(err) {
                                assert.strictEqual(err.code, 404);
                                return callback();
                            });
                        });
                    });
                });
            });
        });

        describe('Resending email tokens', function(callback) {

            /**
             * Test that verifies parameters are validated
             */
            it('verify validation', function(callback) {
                TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, simong, nico) {
                    assert.ok(!err);
                    // Invalid user id
                    RestAPI.User.resendEmailToken(simong.restContext, 'not a user id', function(err, bla, body) {
                        assert.strictEqual(err.code, 400);

                        return callback();
                    });
                });
            });

            /**
             * Test that verifies that unauthorized users cannot resend email tokens
             */
            it('verify authorization', function(callback) {
                TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, simong, nico) {
                    assert.ok(!err);

                    // Anonymous users cannot resend tokens
                    RestAPI.User.resendEmailToken(anonymousRestContext, simong.user.id, function(err) {
                        assert.strictEqual(err.code, 401);

                        // Users cannot resend tokens for other users
                        RestAPI.User.resendEmailToken(simong.restContext, nico.user.id, function(err) {
                            assert.strictEqual(err.code, 401);
                            return callback();
                        });
                    });
                });
            });

            /**
             * Test that verifies that an email token can be resent by a user
             */
            it('verify an email token can be resent by a user', function(callback) {
                TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, simong) {
                    assert.ok(!err);

                    RestAPI.User.resendEmailToken(simong.restContext, simong.user.id, function(err) {
                        assert.ok(!err);
                    });

                    EmailAPI.once('debugSent', function(message) {
                        assert.strictEqual(message.to[0].address, simong.user.email);
                        return callback();
                    });
                });
            });

            /**
             * Test that verifies that an email token can be resent by a tenant admin
             */
            it('verify an email token can be resent by a tenant admin', function(callback) {
                TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, simong) {
                    assert.ok(!err);

                    RestAPI.User.resendEmailToken(camAdminRestContext, simong.user.id, function(err) {
                        assert.ok(!err);
                    });

                    EmailAPI.once('debugSent', function(message) {
                        assert.strictEqual(message.to[0].address, simong.user.email);
                        return callback();
                    });
                });
            });

            /**
             * Test that verifies that an email token can be resent by a global admin
             */
            it('verify an email token can be resent by a global admin', function(callback) {
                TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, simong) {
                    assert.ok(!err);

                    var globalAdminRestContext = TestsUtil.createGlobalAdminRestContext();
                    RestAPI.User.resendEmailToken(globalAdminRestContext, simong.user.id, function(err) {
                        assert.ok(!err);
                    });

                    EmailAPI.once('debugSent', function(message) {
                        assert.strictEqual(message.to[0].address, simong.user.email);
                        return callback();
                    });
                });
            });
        });
    });

    describe('Updating an email address', function() {

        /**
         * Test that verifies that a user cannot set their email address to that of another user
         */
        it('verify a user cannot set their email address to that of another user', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, simon, nico) {

                // Nico can't set his email address to something that Simon already uses
                RestAPI.User.updateUser(nico.restContext, nico.user.id, {'email': simon.user.email}, function(err) {
                    assert.ok(err);
                    assert.strictEqual(err.code, 400);

                    // Administrators can't break this rule either
                    RestAPI.User.updateUser(camAdminRestContext, nico.user.id, {'email': simon.user.email}, function(err) {
                        assert.ok(err);
                        assert.strictEqual(err.code, 400);

                        return callback();
                    });
                });
            });
        });

        /**
         * Test that verifies that an email address is unverified when updated
         */
        it('verify an email address is unverified when updated', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 3, function(err, users, simon, nico, stuart) {

                // Nico updates his email address
                var newEmail = TestsUtil.generateTestEmailAddress();
                RestAPI.User.updateUser(nico.restContext, nico.user.id, {'email': newEmail}, function(err) {
                    assert.ok(!err);

                    // Verify we send a verification email. This also ensures it can't mess up our email
                    // checking further down in the test
                    EmailAPI.once('debugSent', function(message) {
                        assert.strictEqual(message.to[0].address, newEmail);

                        // Verify the email address is unverified
                        RestAPI.User.getMe(nico.restContext, function(err, me) {
                            assert.ok(!err);

                            // Trigger an email worthy activity. Because Nico hasn't verified his
                            // email address yet, we shouldn't send an email to it
                            RestAPI.Content.createLink(simon.restContext, 'Google', 'Google', 'public', 'http://www.google.ca', [], [nico.user.id, stuart.user.id], [], function(err, link) {
                                assert.ok(!err);

                                 // We should've sent only 1 email (to Stuart)
                                EmailTestsUtil.collectAndFetchAllEmails(function(messages) {
                                    assert.strictEqual(messages.length, 1);
                                    assert.strictEqual(messages[0].to.length, 1);
                                    assert.strictEqual(messages[0].to[0].address, stuart.user.email);
                                    return callback();
                                });
                            });
                        });
                    });
                });
            });
        });
    });
});
