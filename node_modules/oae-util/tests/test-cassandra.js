/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the 'License'); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an 'AS IS'
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var assert = require('assert');

var Cassandra = require('oae-util/lib/cassandra');
var Util = require('oae-util/lib/util');


describe('Utilities', function() {

    describe('Cassandra', function() {

        /**
         * Test that will validate that keyspaces can be created, checked and dropped
         */
        it('verify keyspaces', function(callback) {
            // Create a key space
            var keyspace = 'keyspacetest' + Math.floor(Math.random() * 100000000);
            Cassandra.createKeyspace(keyspace, function(err, created) {
                assert.ok(!err);
                assert.ok(created);

                // Check that the keyspace exists
                Cassandra.keyspaceExists(keyspace, function(err, exists) {
                    assert.ok(!err);
                    assert.ok(exists);

                    // Check that a non-existing keyspace doesn't exist
                    var nonExistingKeyspace = 'keyspacetest' + Math.floor(Math.random() * 100000000);
                    Cassandra.keyspaceExists(nonExistingKeyspace, function(err, exists) {
                        assert.ok(!err);
                        assert.ok(!exists);

                        // Drop the created keyspace
                        Cassandra.dropKeyspace(keyspace, function(err, dropped) {
                            assert.ok(!err);
                            assert.ok(dropped);

                            // Check that a non-existing keyspace can't be dropped
                            Cassandra.dropKeyspace(keyspace, function(err, dropped) {
                                assert.ok(err);
                                callback();
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that it is possible to create, check and drop column families.
         */
        it('verify column family', function(callback) {
            // Create a column family
            var name = 'cf' + Math.floor(Math.random() * 10000000);
            Cassandra.createColumnFamily(name, 'CREATE COLUMNFAMILY ' + name + ' (keyId text PRIMARY KEY)', function(err, created) {
                assert.ok(!err);
                assert.ok(created);

                 // Check if it exists.
                Cassandra.columnFamilyExists(name, function(err, exists) {
                    assert.ok(!err);
                    assert.ok(exists);

                    // Check if a non-existing CF exists
                    var nonExistingCF = 'cf' + Math.floor(Math.random() * 100000000);
                    Cassandra.keyspaceExists(nonExistingCF, function(err, exists) {
                        assert.ok(!err);
                        assert.ok(!exists);

                        // Drop it.
                        Cassandra.dropColumnFamily(name, function(err, dropped) {
                            assert.ok(!err);
                            assert.ok(dropped);

                            // Make sure it's gone.
                            Cassandra.columnFamilyExists(name, function(err, exists) {
                                assert.ok(!err);
                                assert.ok(!exists);

                                // Try to drop a non-existing CF
                                Cassandra.dropColumnFamily(nonExistingCF, function(err, dropped) {
                                    assert.ok(err);
                                    callback();
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that it is possible to create, check and drop multiple columnfamilies at once.
         */
        it('verify multiple column families', function(callback) {
            var name1 = 'cf' + Math.floor(Math.random() * 10000000);
            var name2 = 'cf' + Math.floor(Math.random() * 10000000);

            Cassandra.createColumnFamilies({
                name1: 'CREATE COLUMNFAMILY ' + name1 + ' (keyId text PRIMARY KEY)',
                name2: 'CREATE COLUMNFAMILY ' + name2 + ' (keyId text PRIMARY KEY)'
            }, function(err) {
                assert.ok(!err);
                // Check if it exists.
                Cassandra.columnFamilyExists(name1, function(err, exists) {
                    assert.ok(!err);
                    assert.ok(exists);
                    Cassandra.columnFamilyExists(name2, function(err, exists) {
                        assert.ok(!err);
                        assert.ok(exists);
                        // Remove them
                        Cassandra.dropColumnFamilies([name1, name2], function(err) {
                            assert.ok(!err);
                            // Check if they still exist
                            Cassandra.columnFamilyExists(name1, function(err, exists) {
                                assert.ok(!err);
                                assert.ok(!exists);
                                Cassandra.columnFamilyExists(name2, function(err, exists) {
                                    assert.ok(!err);
                                    assert.ok(!exists);
                                    callback();
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test the runQuery function, making sure that null and undefined values are handled appropriately
         */
        it('verify run query', function(callback) {
            // Create a CF first
            Cassandra.createColumnFamily('testQuery', 'CREATE COLUMNFAMILY testQuery (keyId text PRIMARY KEY)', function(err, created) {
                assert.ok(!err);
                assert.ok(created);
                // Check if the CF exists
                Cassandra.columnFamilyExists('testQuery', function(err, exists) {
                    assert.ok(!err);
                    assert.ok(exists);
                    // Try to run a simple insert
                    Cassandra.runQuery('INSERT INTO testQuery (keyId, c1, c2) VALUES (?, ?, ?) USING CONSISTENCY QUORUM', ['key1', 'value1', 'value2'], function (err) {
                        assert.ok(!err);
                        // Try to run an invalid insert
                        Cassandra.runQuery('INSERT INTO testQuery (keyId, c1, c2) VALUES (?, ?, ?) USING CONSISTENCY QUORUM', ['key2', 'value', null], function (err) {
                            assert.ok(err);
                            // Try to run a simple select
                            Cassandra.runQuery('SELECT * FROM testQuery USING CONSISTENCY QUORUM WHERE keyId = ?', ['key1'], function (err, rows) {
                                assert.ok(!err);
                                assert.equal(rows.length, 1);
                                assert.equal(rows[0].key, 'key1');
                                // Try to run an invalid select
                                Cassandra.runQuery('SELECT * FROM testQuery USING CONSISTENCY QUORUM WHERE keyId = ?', [null], function (err, rows) {
                                    assert.ok(err);
                                    callback();
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test casting to a Boolean
         */
        it('verify casting to a Boolean', function(callback) {
            Cassandra.createColumnFamily('testBooleans', 'CREATE COLUMNFAMILY testBooleans (keyId text PRIMARY KEY)', function(err, created) {
                assert.ok(!err);
                assert.ok(created);
                Cassandra.runQuery('INSERT INTO testBooleans (keyId, testbool, testnumbool, teststring) VALUES (?, ?, ?, ?) USING CONSISTENCY QUORUM', ['testkey', 'true', '0', 'notaboolean'], function (err) {
                    assert.ok(!err);
                    Cassandra.runQuery('SELECT testbool, testnumbool, teststring FROM testBooleans USING CONSISTENCY QUORUM WHERE keyId = ?', ['testkey'], function (err, rows) {
                        assert.ok(!err);
                        assert.equal(typeof Util.castToBoolean(rows[0][0].value), 'boolean');
                        assert.equal(typeof Util.castToBoolean(rows[0][1].value), 'boolean');
                        assert.equal(typeof Util.castToBoolean(rows[0][2].value), 'string');
                        callback();
                    });
                });
            });
        });

        /**
         * Test whether the constructUpsertCQL works as expected, making sure that invalid parameters
         * are handled appropriately
         */
        it('verify construct upsert', function(callback) {
            // Test an invalid call with no provided cf
            var query1 = Cassandra.constructUpsertCQL(null, 'testId', 'testValue', {'key1': 'value1'});
            assert.ok(!query1);
            // Test an invalid call with no provided values
            var query2 = Cassandra.constructUpsertCQL('testCF', 'testId', 'testValue', {});
            assert.ok(!query2);
            // Test a valid update with one key-value pair
            var query3 = Cassandra.constructUpsertCQL('testCF', 'testId', 'testValue', {'key1': 'value1'});
            assert.ok(query3);
            assert.equal(query3.query, 'UPDATE testCF SET ? = ? WHERE testId = ?');
            assert.equal(query3.parameters[0], 'key1');
            assert.equal(query3.parameters[1], 'value1');
            assert.equal(query3.parameters[2], 'testValue');
            // Test a valid update with one key-value pair and consistency
            var query4 = Cassandra.constructUpsertCQL('testCF', 'testId', 'testValue', {'key1': 'value1'}, 'QUORUM');
            assert.ok(query4);
            assert.equal(query4.query, 'UPDATE testCF USING CONSISTENCY QUORUM SET ? = ? WHERE testId = ?');
            assert.equal(query4.parameters[0], 'key1');
            assert.equal(query4.parameters[1], 'value1');
            assert.equal(query4.parameters[2], 'testValue');
            // Test a valid update with multiple key-value pairs
            var query5 = Cassandra.constructUpsertCQL('testCF', 'testId', 'testValue', {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'});
            assert.ok(query5);
            assert.equal(query5.query, 'UPDATE testCF SET ? = ?, ? = ?, ? = ? WHERE testId = ?');
            assert.equal(query5.parameters[0], 'key1');
            assert.equal(query5.parameters[1], 'value1');
            assert.equal(query5.parameters[2], 'key2');
            assert.equal(query5.parameters[3], 'value2');
            assert.equal(query5.parameters[4], 'key3');
            assert.equal(query5.parameters[5], 'value3');
            assert.equal(query5.parameters[6], 'testValue');
            // Test a valid update with multiple key-value pairs and consistency
            var query6 = Cassandra.constructUpsertCQL('testCF', 'testId', 'testValue', {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}, 'QUORUM');
            assert.ok(query6);
            assert.equal(query6.query, 'UPDATE testCF USING CONSISTENCY QUORUM SET ? = ?, ? = ?, ? = ? WHERE testId = ?');
            assert.equal(query6.parameters[0], 'key1');
            assert.equal(query6.parameters[1], 'value1');
            assert.equal(query6.parameters[2], 'key2');
            assert.equal(query6.parameters[3], 'value2');
            assert.equal(query6.parameters[4], 'key3');
            assert.equal(query6.parameters[5], 'value3');
            assert.equal(query6.parameters[6], 'testValue');

            // Verify TTL is added to the query with proper syntax
            var query7 = Cassandra.constructUpsertCQL('testCF', 'testId', 'testValue', {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}, 'QUORUM', 500);
            assert.ok(query7);
            assert.equal(query7.query, 'UPDATE testCF USING CONSISTENCY QUORUM AND TTL 500 SET ? = ?, ? = ?, ? = ? WHERE testId = ?');
            assert.equal(query7.parameters[0], 'key1');
            assert.equal(query7.parameters[1], 'value1');
            assert.equal(query7.parameters[2], 'key2');
            assert.equal(query7.parameters[3], 'value2');
            assert.equal(query7.parameters[4], 'key3');
            assert.equal(query7.parameters[5], 'value3');
            assert.equal(query7.parameters[6], 'testValue');

            // Verify a JSON object and JSON array are stringified
            var query8 = Cassandra.constructUpsertCQL('testCF', 'testId', 'testValue', {'key1': {'anobject': 'a value'}, 'key2': ['index0', 'index1'], 'key3': 'value3'}, 'QUORUM', 500);
            assert.ok(query8);
            assert.equal(query8.query, 'UPDATE testCF USING CONSISTENCY QUORUM AND TTL 500 SET ? = ?, ? = ?, ? = ? WHERE testId = ?');
            assert.equal(query8.parameters[0], 'key1');
            assert.equal(JSON.parse(query8.parameters[1])['anobject'], 'a value');
            assert.equal(query8.parameters[2], 'key2');
            assert.equal(JSON.parse(query8.parameters[3])[0], 'index0');
            assert.equal(JSON.parse(query8.parameters[3])[1], 'index1');
            assert.equal(query8.parameters[4], 'key3');
            assert.equal(query8.parameters[5], 'value3');
            assert.equal(query8.parameters[6], 'testValue');

            callback();
        });

    });
});
