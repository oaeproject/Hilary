/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var Locking = require('oae-util/lib/locking');
var log = require('oae-logger').logger('oae-content');
var StatsAPI = require('oae-stats');
var TenantsAPI = require('oae-tenants');

var ContentConstants = require('oae-content/lib/constants').ContentConstants;
var ContentUtil = require('./internal/util');

var collectionInterval = null;
var config = null;

// The constant that will be used to guarantee only 1 node in the cluster is collecting the statistics
var STORAGE_STATS_LOCKKEY = 'oae-content/stats-storage-lockkey';

/**
 * Refresh the content storage statistics collector
 *
 * @param  {Object} _config The configuration object for the storage collection. See `config.stats.storage` in the main `config.js`
 */
var refreshConfiguration = module.exports.refreshConfiguration = function(_config) {
    config = _config;

    // Stop the old timer if there is one
    if (collectionInterval) {
        clearInterval(collectionInterval);
    }

    if (config.enabled) {
        // Start a new timer that collects the storage stats everytime it ticks
        collectionInterval = setInterval(collectStats, config.interval * 1000);
    }
    setTimeout(collectStats, 3000);
};

/**
 * Tries to collect the storage statistics for all the enabled tenants in the system. This function will
 * first try to get a lock guaranteeing only one node in the cluster can collect the storage statistics
 * at any given time. The lock is released when the storage statistics for all tenants have been collected.
 *
 * @param  {Function}   [callback]      Standard callback function
 * @param  {Object}     callback.err    An error object, if any
 */
var collectStats = module.exports.collectStats = function(callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'An error occured when collecting the storage counts');
        }
    };

    // Try to get a lock on 
    Locking.acquire(STORAGE_STATS_LOCKKEY, config.expiry * 1000, function(err, lockToken) {
        if (err) {
            log().error({'err': err}, 'An error occurred when trying to get a lock for collecting storage statistics');
            return callback(err);
        } else if (!lockToken) {
            // We could not acquire a lock, someone else came around and is collecting the stats
            return callback(err);
        }

        _startCollecting(function(collectionError) {
            if (collectionError) {
                log().error({'err': collectionError}, 'An expected error ocurred when collecting the storage stats');
                // Do not callback here, we should release the lock first
            }

            // Release the lock
            Locking.release(STORAGE_STATS_LOCKKEY, lockToken, function(lockError, hadLock) {
                if (lockError) {
                    log().warn({'err': lockError, 'type': type}, 'An unexpected error occurred while releasing the lock for collecting storage stats');

                    // If there was an error releasing the lock, worst case scenario would be that the lock eventually expires
                    // and a cluster node picks it up soon after that and continues collecting stats
                    return callback(collectionError);
                }

                log().trace('Successfully released lock for collecting stats');

                if (!hadLock) {
                    // This means that the lock expired before we finished collecting stats, which likely means the lock expiry
                    // is not configured high enough. Send an error, because some of the collection logic might cause a performance
                    // degradation when ran concurrently
                    log().error({
                        'collectionExpiry': bucketInfo.collectionExpiry
                    }, 'The lock expired before we finished collecting the statistics. This probably means that it takes longer than ' +
                        'the "collectionExpiry" number of seconds for the storage collector to run. Consider increasing "collectionExpiry"');
                }

                return callback(collectionError);
            });
        });
    });
};

/**
 * Collects the storage counts for all the enabled tenants in the system
 *
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error object, if any
 * @api private
 */
var _startCollecting = function(callback) {
    // Get all the tenants for which the stats should be collected
    var tenants = TenantsAPI.getTenants(true);
    tenants = _.keys(tenants);

    // Collect them all
    _collectTenants(tenants, function(counts) {
        // Persist the collected values with the stats api
        var stats = _.map(counts, function(count) {
            return {
                'name': ContentConstants.stats.STORAGE,
                'tenantAlias': count.tenantAlias,
                'value': count.count
            };
        });

        StatsAPI.setStatistics(stats, callback);
    });
};

/**
 * Collect the storage counts for a set of tenants
 *
 * @param  {String[]}   tenants             The aliases of the tenants which need to be checked
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error object, if any
 * @param  {Object[]}   callback.counts     A set of objects, each one holding the storage size for a tenant
 * @api private
 */
var _collectTenants = function(tenants, callback, _counts) {
    _counts = _counts || [];

    // We're done if there are no more tenants to collect
    if (tenants.length === 0) {
        return callback(_counts);
    }

    // Collect the next tenant
    var tenantAlias = tenants.pop();
    var backend = ContentUtil.getStorageBackendForTenant(tenantAlias);
    backend.getStorageCount(tenantAlias, function(err, storageCount) {
        if (err) {
            log().error({'err': err, 'tenant': tenantAlias}, 'Failed to collect the storage stats for this tenant');
        } else {
            _counts.push({
                'tenantAlias': tenantAlias,
                'count': storageCount
            });
        }

        _collectTenants(tenants, callback, _counts);
    });
};
