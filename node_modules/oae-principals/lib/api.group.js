var _ = require('underscore');
var rolesAPI = require('oae-roles');
var cassandra = require('oae-util/lib/cassandra');
var utils = require('./utils');

/**
 * Get the basic profile for a group.
 * @param  {String}   group_id  An identifier for a group. ex: g:cam:oae-team
 * @param  {Function} callback  Standard callback method where the first argument is an error object
 *                              that contains a code suitable as http statuscode and a corresponding message.
 *                              The second argument holds the group information.
 */
module.exports.getGroup = function(group_id, callback) {
    if (!utils.isGroup(group_id)) {
        return callback({'code': 400, 'msg': 'The provided group_id is not a group identifier.'}, null);
    }

    utils.getPrincipal(group_id, callback);
};

/**
 * Get all the members of a group.
 *
 * @param  {String}   group_id An identifier for a group. ex: g:cam-oae-team
 * @param  {Boolean}  retrieve_basicprofile Wether or not the basic profile should be included for the principals
 * @param  {String}   start The principal_id that comes just before the first principal you wish to have in your results.
 * @param  {Number}   limit The number of members you wish to retrieve.
 * @param  {Function(err, members)} callback  Standard callback method that has an array of the direct members of a group.
 */
module.exports.getGroupMembers = function(group_id, retrieve_basicprofile, start, limit, callback) {
    // Defaults.
    limit = limit || 100;
    callback = callback || function(err, members) {};

    if (isNaN(limit)) {
        return callback({'code': 400, 'msg': 'The limit parameter needs to be a number'});
    }

    // Ensure that this group exists.
    module.exports.getGroup(group_id, function(err, group) {
        if (err) {
            return callback(err, null);
        }

        // Page the query.
        var startColumnIndex = 0;
        if (start) {
            limit++;
            startColumnIndex = 1;
        } else {
            start = '';
        }

        cassandra.runQuery("SELECT first " + limit + " ?..\'\' FROM GroupMembers WHERE group_id = ?", [start, group_id], function (err, rows) {
            if (err) {
                return callback({'code': 500, 'msg': err}, null);
            }

            var members = [];
            for (var i = startColumnIndex, j = rows[0].cols.length;i<j;i++) {
                if (rows[0].cols[i].name !== "group_id") {
                    members.push(rows[0].cols[i].name);
                }
            }
            if (members.length === 0) {
                return callback(false, members);
            }

            if (!retrieve_basicprofile) {
                return callback(false, members);
            }

            utils.getBasicProfile(members, callback);
        });
    });
};

/**
 * Gets all the groups a principal (both user or groups) is a member of.
 * @param  {String}   principal_id      The principal to retrieve all the groups for.
 * @param  {Boolean}  retrieve_basicprofile Whether or not the profile should be retrieved. If false, only the principal_ids for each group will be returned.
 * @param  {String}   start The principal_id that comes just before the first principal you wish to have in your results.
 * @param  {Number}   limit The number of members you wish to retrieve.
 * @param  {Function} callback  Standard callback method where the first argument is an error object
 *                              that contains a code suitable as http statuscode and a corresponding message.
 *                              The second argument holds the groups this principal is a member of.
 */
module.exports.memberOf = function(principal_id, retrieve_basicprofile, start, limit, callback) {
    if (isNaN(limit)) {
        return callback({'code': 400, 'msg': 'The limit parameter needs to be a number'});
    }
    utils.getPrincipal(principal_id, function(err, principal) {
        if (err) {
            return callback(err, null);
        }

        // Page the query.
        var startColumnIndex = 0;
        if (start) {
            limit++;
            startColumnIndex = 1;
        } else {
            start = '';
        }

        cassandra.runQuery("SELECT first " + limit + " ?..\'\' FROM MemberOf WHERE principal_id = ?", [start, principal_id], function (err, rows) {
            if (err) {
                return callback({'code': 500, 'msg': err}, null);
            }

            var memberships = [];
            for (var i = startColumnIndex, j = rows[0].cols.length;i<j;i++) {
                if (rows[0].cols[i].name !== "principal_id") {
                    memberships.push(rows[0].cols[i].name);
                }
            }
            if (memberships.length === 0) {
                return callback(false, memberships);
            }

            if (!retrieve_basicprofile) {
                return callback(false, memberships);
            }

            utils.getBasicProfile(memberships, callback);
        });
    });
};

/**
 * Adds a principal to a group.
 * @param {String}   group_id        The identifier of a group. ex: g:cam:oae-team
 * @param {String[]} principalsToAdd An array of principal identifiers you wish to add. ex: [g:cam:ui-team, g:cam:backend-team]
 * @param  {Function} callback  Standard callback method where the first argument is an error object
 *                              that contains a code suitable as http statuscode and a corresponding message.
 */
module.exports.addGroupMembers = function(group_id, principalsToAdd, callback) {
    // Check if group and whether or not we have access to edit.
    module.exports.getGroup(group_id, function(err, group) {
        if (err) {
            return callback(err, null);
        }

        // If we only add in one principal.
        if (typeof principalsToAdd === "string") {
            principalsToAdd = [principalsToAdd];
        }

        // Check the prefixes of each member we wish to add.
        var proceed = true;
        for (var i = 0; i < principalsToAdd.length;i++) {
            if ( (principalsToAdd[i].slice(0, 2) !== "g:" && principalsToAdd[i].slice(0, 2) !== "u:") || (principalsToAdd[i] === group_id)) {
                proceed = false;
                break;
            }
        }

        if (!proceed) {
            return callback({'code': 400, 'msg': "You can only add users and/or groups and not the group itself."}, null);
        }

        // Verify that the provided principals actually exist in the database.
        cassandra.runQuery('SELECT * FROM Principals WHERE principal_id IN (?)', [principalsToAdd], function (err, rows) {
            if (err) {
                return callback({'code': 500, 'msg': err}, null);
            }

            // Convert principalsToAdd to hash to create faster lookup.
            var requestPrincipals = {};
            for (var i = 0; i < principalsToAdd.length;i++) {
                requestPrincipals[principalsToAdd[i]] = true;
            }

            var all_valid = true;
            for (var i = 0; i < rows.rowCount();i++) {
                if (rows[i]._colCount === 1) {
                    // This is an invalid principal!
                    requestPrincipals[rows[i].colHash.principal_id] = false;
                    all_valid = false;
                }
            }

            if (!all_valid) {
                return callback({'code': 400, 'msg': 'Not all the provided principals exist!'});
            }

            // Ensure that we're not adding any circular dependencies by
            // making sure that all the provided principals are NOT a parent of this group.
            // Basically the whole group graph needs to be a Directed Acyclical Graph.
            cassandra.runQuery('SELECT * FROM MemberOf WHERE principal_id IN (?)', [principalsToAdd], function (err, rows) {
                if (err) {
                    return callback({'code': 500, 'msg': err}, null);
                }

                for (var i = 0; i < principalsToAdd.length;i++) {
                    if (typeof rows[0].colHash[principalsToAdd[i]] !== "undefined") {
                        return callback({'code': 400, 'msg': 'You cannot make a parent group member of one of it\'s children.'}, null);
                    }
                }

                // Get all the groups that this group is a member of so we can add them to the principallist later.
                cassandra.runQuery('SELECT * FROM MemberOf WHERE principal_id  = ?', [group_id], function (err, rows) {
                    if (err) {
                        return callback({'code': 500, 'msg': err}, null);
                    }

                    var parentGroups = [];
                    for (var i = 0; i < rows[0].cols.length;i++) {
                        if (rows[0].cols[i].name !== "principal_id") {
                            parentGroups.push(rows[0].cols[i].name);
                        }
                    }

                    var q = [];
                    var parameters = [];
                    for (var i = 0; i < principalsToAdd.length;i++) {
                        q.push("?=?");
                        parameters.push(principalsToAdd[i]);
                        parameters.push("");
                    }
                    parameters.push(group_id);

                    cassandra.runQuery("UPDATE GroupMembers SET " + q.join(', ') + " WHERE group_id = ?", parameters, function(err) {
                        if (err) {
                            return callback({'code': 500, 'msg': err}, null);
                        }

                        // Explode the principals and add them all in.
                        utils.explodePrincipals(principalsToAdd, false, function(err, users) {
                            if (err) {
                                return callback({'code': 500, 'msg': err}, null);
                            }

                            users = principalsToAdd.concat(_.keys(users));
                            // We add this group to each principal his membership list.
                            // We also need to add all the parent groups of this group to the membership list of each principal.
                            var queries = [];
                            for (var i = 0; i < users.length;i++) {
                                var query = {'query':'', 'parameters': []};
                                var parameters = [];
                                var parentGroupsQuery = "";
                                for (var g = 0; g < parentGroups.length;g++) {
                                    parentGroupsQuery += "?=?,";
                                    query.parameters.push(parentGroups[g]);
                                    query.parameters.push("");
                                }
                                query.query= "UPDATE MemberOf SET " + parentGroupsQuery + " ?=?  WHERE principal_id=?";
                                query.parameters.push(group_id);
                                query.parameters.push("");
                                query.parameters.push(users[i]);
                                queries.push(query);
                            }

                            cassandra.runBatchQuery(queries, function(err) {
                                if (err) {
                                    return callback({'code': 500, 'msg': err}, null);
                                }

                                callback(false, null);
                            });
                        });
                    });
                });
            });
        });
    });
};

/**
 * Create a new group within this tenant.
 * @param  {Tenant}   tenant      The current tenant
 * @param  {String}   title       The title for this group. This will be stemmed down to something that we can use in Cassandra and prefixed with g:tenant.alias:
 * @param  {String}   description A description for this group.
 * @param  {Function} callback    Standard callback method where the first argument is an error object
 *                                that contains a code suitable as http statuscode and a corresponding message.
 *                                The second argument holds the group id as a string.
 */
module.exports.createGroup = function(tenant, title, description, callback) {
    var groupId = title.replace(/[:;<>#%{}|~`@%&!$,.="'\^\+\/\?\(\)\*\s\\\\\[\]]/gi, '-');
    var id = "g:" + tenant.alias + ":" + groupId;
    // Check if the group already exists.
    module.exports.getGroup(id, function(err, group) {
        if (!err) {
            return callback({'code': 400, 'msg': 'This name is not available.'}, null);
        }

        // Create the group.
        cassandra.runQuery('INSERT INTO Principals (principal_id, tenant, group_title, group_description) VALUES (?, ?, ?, ?)', [id, tenant.alias, title, description], function (err) {
            if (err) {
                callback({'code': 500, 'msg': err}, null);
            } else {
                callback(false, id);
            }
        });
    });
};

/**
 * Explodes a group down to all its user principals.
 * @param  {String}   group_id   The ID of a group.
 * @param  {Function} callback  Standard callback method where the first argument is an error object
 *                              that contains a code suitable as http statuscode and a corresponding message.
 *                              The second argument holds all the users principals in this group.
 * @return {[type]}
 */
module.exports.getGroupUsers = function(group_id, callback) {
    utils.explodePrincipals([group_id], true, function(err, users) {
        var members = _.keys(users);
        callback(false, members);
    });
};