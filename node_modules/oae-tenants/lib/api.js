/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var EventEmitter = require('events').EventEmitter;
var OAE = require('oae-util/lib/oae');
var Cassandra = require('oae-util/lib/cassandra');
var Pubsub = require('oae-util/lib/pubsub');
var Validator = require('oae-util/lib/validator').Validator;
var log = require('oae-logger').logger('oae-tenants');

var Tenant = require('./model').Tenant;

// Variable that caches the server configuration as specified in the config.js file
var serverConfig = null;

// Variable that caches the available tenants, keyed by their alias
var tenants = {};
// Variable that caches the available tenants, keyed by their hostname. This will be used for
// quick look-ups when checking whether or not a hostname is associated to a tenant
var tenantsByHost = {};

// Variable that caches the global administration tenant object
var globalTenant = null;

/**
 * ### Events
 *
 * The `TenantsAPI` emits the following events:
 *
 * * `start(tenant)`: A request has been received to "start" a tenant.
 * * `stop(tenant)`: A request has been received to "stop" a tenant.
 * * `refresh(tenant)`: A request has been received to "refresh" the metadata of a tenant.
 */
var emitter = module.exports = new EventEmitter();

/*!
 * Listen for cluster wide requests involving tenants
 *
 * @param  {String}  message    A brief command in the form of `start cam`, `stop cam` or `refresh cam`
 */
Pubsub.on('oae-tenants', function (message) {
    var args = message.split(' ');
    var cmd = args.shift();
    var alias = args.shift();

    // Re-cache the available tenants
    _cacheTenants(function(err) {
        if (err) {
            return log().error('There was an error caching the tenants');
        }

        emitter.emit(cmd, getTenant(alias));
    });
});

/**
 * Initialize the middleware that will put the tenant object onto the request and cache all of the registered
 * tenants
 *
 * @param  {Object}         serverConfig        Server configuration object containing global admin tenant information
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        Error object containing the error code and message
 */
var init = module.exports.init = function(_serverConfig, callback) {
    // Cache the server configuration
    serverConfig = _serverConfig;

    // This middleware adds the tenant to each request on the global admin server
    OAE.globalAdminServer.use(function(req, res, next) {
        req.tenant = globalTenant;
        return next();
    });

    // This middleware adds the tenant to each request on the user tenant server
    OAE.tenantServer.use(function(req, res, next) {
        req.tenant = getTenantByHost(req.headers.host);
        // We stop the request if we can't find a tenant associated to the current hostname
        if (!req.tenant) {
            res.setHeader('Connection', 'Close');
            return res.send(418, 'This hostname is not associated to any tenant');
        }

        // Check whether or not the tenant has been disabled
        if (!req.tenant.active) {
            // If the tenant has been stopped, there is no point in keeping connections open
            res.setHeader('Connection', 'Close');
            return res.send(503, 'This server is currently disabled. Please check back later.');
        }
        next();
    });

    // Cache the available tenants
    _cacheTenants(callback);
};

/**
 * Get all available tenants from cache. The global admin tenant and deleted tenants will be excluded from the resulting tenant list
 *
 * @param  {Boolean}        [excludeDisabled]   Whether or not disabled tenants should be included. By default, all tenants will be returned
 * @return {Object}                             An object keyed by tenant alias holding all the (non-deleted) tenants
 */
var getTenants = module.exports.getTenants = function(excludeDisabled) {
    var filteredTenants = {};
    _.each(tenants, function(tenant, tenantAlias) {
        // Exclude the global admin tenant and deleted tenants. Also exclude all disabled tenants when
        // `exludeDisabled` has been provided
        if (!tenant.isGlobalAdminServer && !tenant.deleted && (!excludeDisabled || tenant.active)) {
            filteredTenants[tenantAlias] = _copyTenant(tenant);
        }
    });
    return filteredTenants;
};

/**
 * Get a tenant by alias from cache
 *
 * @param  {String}         tenantAlias         Alias for the tenant that should be retrieved
 * @return {Tenant}                             Tenant object associated to the provided tenant alias
 */
var getTenant = module.exports.getTenant = function(tenantAlias) {
    return _copyTenant(tenants[tenantAlias]);
};

/**
 * Get a tenant by host name from cache
 *
 * @param  {String}         tenantHost          Host name for the tenant that should be retrieved
 * @return {Tenant}                             Tenant object associated to the provided tenant host
 */
var getTenantByHost = module.exports.getTenantByHost = function(tenantHost) {
    return _copyTenant(tenantsByHost[tenantHost.toLowerCase()]);
};

/**
 * Fetch the available tenants and cache them
 *
 * @param  {Function}       [callback]          Standard callback function
 * @param  {Object}         [callback.err]      Error object containing the error code and message
 * @api private
 */
var _cacheTenants = function(callback) {
    callback = callback || function() {};

    // Get the available tenants
    Cassandra.runQuery('SELECT * FROM Tenant USING CONSISTENCY QUORUM', false, function(err, rows) {
        if (err) {
            return callback(err);
        }

        // Reset the previously cached tenants
        tenants = {};
        tenantsByHost = {};

        // Create a dummy tenant object that can serve as the global admin tenant object
        globalTenant = new Tenant(serverConfig.globalAdminAlias, 'Global admin server', serverConfig.globalAdminHost, {'isGlobalAdminServer': true});

        // Cache it as part of the available tenants
        tenants[globalTenant.alias] = globalTenant;
        tenantsByHost[globalTenant.host] = globalTenant;

        for (var i = 0; i < rows.length; i++) {
            var tenant = mapToTenant(rows[i]);
            // Cache all tenants
            tenants[tenant.alias] = tenant;
            tenantsByHost[tenant.host] = tenant;
        }

        callback(null, tenants);
    });
};

/**
 * Create a new tenant and spin it up on the fly
 *
 * @param  {Context}    ctx                     The current context
 * @param  {String}     alias                   The unique alias for the tenant
 * @param  {String}     displayName             A descriptive short name for the tenant
 * @param  {String}     host                    The host on which this tenant will be proxying (e.g. oae.cam.ac.uk or oae.gatech.edu)
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            Error object containing the error code and message
 * @param  {Tenant}     callback.tenant         The created tenant
 */
var createTenant = module.exports.createTenant = function(ctx, alias, displayName, host, callback) {
    callback = callback || function() {};

    if (!ctx.user() || !ctx.user().isGlobalAdmin()) {
        return callback({'code': 401, 'msg': 'Only global administrators can create new tenants'});
    }

    var validator = new Validator();
    validator.check(alias, {'code': 400, 'msg': 'Missing alias'}).notEmpty();
    validator.check(alias, {'code': 400, 'msg': 'The tenant alias should not contain a space'}).notContains(' ');
    validator.check(alias, {'code': 400, 'msg': 'The tenant alias should not contain a colon'}).notContains(':');
    validator.check(displayName, {'code': 400, 'msg': 'Missing tenant displayName'}).notEmpty();
    validator.check(host, {'code': 400, 'msg': 'Missing tenant host'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Make sure the tenant host name is all lower-case
    host = host.toLowerCase();

    // Make sure that a tenant with the same alias doesn't exist yet
    if (!getTenant(alias)) {
        // Make sure that a tenant with the same hostname doesn't exist yet
        if (!getTenantByHost(host)) {
            // Create the tenant
            var tenant = new Tenant(alias, displayName, host);
            Cassandra.runQuery('UPDATE Tenant USING CONSISTENCY QUORUM SET displayName = ?, host = ?, active = ? WHERE alias = ?',
                [tenant.displayName, host, tenant.active, tenant.alias], function(err) {
                if (err) {
                    return callback(err);
                }

                // Send a message to all the app servers in the cluster notifying them that the tenant should be started
                Pubsub.publish('oae-tenants', 'start ' + tenant.alias, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Let the configuration module know that a new tenant has been created and configuration needs to be fetched
                    Pubsub.publish('oae-config', tenant.alias);
                    callback(null, tenant);
                });
            });
        } else {
            callback({'code': 400, 'msg': 'A tenant with the host ' + host + ' already exists'});
        }
    } else {
        callback({'code': 400, 'msg': 'A tenant with the alias ' + alias + ' already exists'});
    }
};

/**
 * Update a tenant's metadata
 *
 * @param  {Context}    ctx                             The current context
 * @param  {String}     alias                           The alias of the tenant we want to update
 * @param  {Object}     tenantUpdates                   Object where the keys represents the metadata identifiers and the values represent the new metadata values
 * @param  {String}     [tenantUpdates.displayName]     Updated tenant display name
 * @param  {String}     [tenantUpdates.host]            Updated tenant hostname
 * @param  {Function}   callback                        Standard callback function
 * @param  {Object}     callback.err                    Error object containing the error code and message
 */
var updateTenant = module.exports.updateTenant = function(ctx, alias, tenantUpdates, callback) {
    if (!ctx.user() || !ctx.user().isAdmin(ctx.user().tenant.alias)) {
        return callback({'code': 401, 'msg': 'Unauthorized users cannot update tenants'});
    }

    var validator = new Validator();
    validator.check(alias, {'code': 400, 'msg': 'Missing alias'}).notEmpty();
    // Check that at least either a new display name or hostname have been provided
    var updateFields = tenantUpdates ? _.keys(tenantUpdates) : [];
    validator.check(updateFields.length, {'code': 400, 'msg': 'You should at least specify a new displayName or hostname'}).min(1);
    _.each(tenantUpdates, function(updateValue, updateField) {
        validator.check(updateField, {'code': 400, 'msg': updateField + ' is not a recognized tenant update field'}).isIn(['displayName', 'host']);
        if (updateField === 'displayName') {
            validator.check(updateValue, {'code': 400, 'msg': 'A displayName cannot be empty'}).notEmpty();
        } else if (updateField === 'host') {
            validator.check(updateValue, {'code': 400, 'msg': 'A hostname cannot be empty'}).notEmpty();
            validator.check(getTenantByHost(updateValue), {'code': 400, 'msg': 'The hostname has already been taken'}).isNull();
        }
    });
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Make sure the tenant host name is all lower-case
    if (tenantUpdates.host) {
        tenantUpdates.host = tenantUpdates.host.toLowerCase();
    }

    var q = Cassandra.constructUpsertCQL('Tenant', 'alias', alias, tenantUpdates, 'QUORUM');
    Cassandra.runQuery(q.query, q.parameters, function(err) {
        if (err) {
            return callback(err);
        }

        // Emit a cluster-wide event to let the app servers re-cache the tenant's metadata
        Pubsub.publish('oae-tenants', 'refresh ' + alias, callback);
    });
};

/**
 * Disable or enable a tenant
 *
 * @param  {Context}      ctx             The current context
 * @param  {String[]}     aliases         An array of aliases representing the tenants that should be stopped
 * @param  {Boolean}      disabled        True if the tenant needs to be disabled
 * @param  {[Function]}   callback        Callback function executed when request is completed
 * @param  {Object}       callback.err    An error object (if any)
 */
var disableTenants = module.exports.disableTenants = function(ctx, aliases, disabled, callback) {
    callback = callback || function() {};

    if (!ctx.user() || !ctx.user().isGlobalAdmin()) {
        return callback({'code': 401, 'msg': 'Unauthorized users cannot disable or enable tenants'});
    }

    if (!aliases) {
        return callback({'code': 400, 'msg': 'Please provide at least one tenant alias'});
    }

    if (!_.isArray(aliases)) {
        aliases = [aliases];
    }

    // Store the activity flag in cassandra.
    var queries = [];
    for (var i = 0; i < aliases.length; i++) {
        queries.push({
            'query': 'UPDATE Tenant SET active = ? WHERE alias = ?',
            'parameters': [!disabled, aliases[i]]
        });
    }
    Cassandra.runBatchQuery(queries, 'QUORUM', function(err) {
        if (err) {
            return callback(err);
        }

        // Broadcast the message accross the cluster
        // so we can start/stop the tenants.
        var cmd = disabled ? 'stop' : 'start';
        for (var i = 0; i < aliases.length; i++) {
            Pubsub.publish('oae-tenants', cmd + ' ' + aliases[i], callback);
        }
    });
};

/**
 * Rather than physically deleting a tenant, we just disable it for now.
 *
 * @param  {Context}   ctx             The current context
 * @param  {String[]}  aliases         An array of aliases representing the tenants that should be deleted.
 * @param  {Function}  callback        Callback function executed when request is completed.
 * @param  {Object}    callback.err    An error object (if any.)
 */
var deleteTenants = module.exports.deleteTenants = function(ctx, aliases, callback) {
    callback = callback || function() {};

    if (!ctx.user() || !ctx.user().isGlobalAdmin()) {
        return callback({'code': 401, 'msg': 'Unauthorized users cannot delete tenants'});
    }

    if (!aliases) {
        return callback({'code': 400, 'msg': 'Please provide a ports array'});
    }
    if (!Array.isArray(aliases)) {
        aliases = [aliases];
    }

    var queries = [];
    for (var i = 0; i < aliases.length; i++) {
        queries.push({
            'query': 'UPDATE Tenant SET active = ?, deleted = ? WHERE alias = ?',
            'parameters': [false, true, aliases[i]]
        });
    }
    Cassandra.runBatchQuery(queries, 'QUORUM', function(err) {
        if (err) {
            return callback(err);
        }
        // Broadcast the message accross the cluster
        // so we can stop the tenants.
        for (var i = 0; i < aliases.length; i++) {
            Pubsub.publish('oae-tenants', 'stop ' + aliases[i], callback);
        }
    });
};

/**
 * Create a new version of the tenant with the same information.
 *
 * @param  {Tenant}     tenant      The tenant whose data to copy to a new tenant object
 * @return {Tenant}                 A copy of the tenant object that was provided, such that modifying its properties is safe
 * @api private
 */
var _copyTenant = function(tenant) {
    if (!tenant) {
        return null;
    }

    return new Tenant(tenant.alias, tenant.displayName, tenant.host, {
        'active': tenant.active,
        'deleted': tenant.deleted,
        'isGlobalAdminServer': tenant.isGlobalAdminServer
    });
};

/**
 * Map a cassandra row element to a tenant object.
 *
 * @param  {Row}    row     The row to be mapped
 * @return {Tenant}         A tenant corresponding to the row
 * @api private
 */
var mapToTenant = function(row) {
    var hash = Cassandra.rowToHash(row);
    return new Tenant(hash.alias, hash.displayName, hash.host.toLowerCase(), {
        'active': hash.active,
        'deleted': hash.deleted
    });
};
