/*
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');
var fs = require('fs');
var ShortId = require('shortid');
var url = require('url');

var ActivityTestsUtil = require('oae-activity/lib/test/util');
var AuthzAPI = require('oae-authz');
var AuthzUtil = require('oae-authz/lib/util');
var EmailTestsUtil = require('oae-email/lib/test/util');
var RestAPI = require('oae-rest');
var RestContext = require('oae-rest/lib/model').RestContext;
var RestUtil = require('oae-rest/lib/util');
var TestsUtil = require('oae-tests');

describe('Principals Activity', function() {

    // Rest context that can be used every time we need to make a request as an anonymous user
    var anonymousCamRestContext = null;
    var anonymousGtRestContext = null;
    // Rest context that can be used every time we need to make a request as a tenant admin
    var camAdminRestContext = null;

    /**
     * Function that will fill up the tenant admin and anymous rest context
     */
    before(function(callback) {
        // Fill up the anonymous cam rest context
        anonymousCamRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host);
        // Fill up the anonymous gt rest context
        anonymousGtRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.gt.host);
        // Fill up global admin rest context
        camAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.cam.host);
        callback();
    });

    /**
     * Drain the email queue
     */
    beforeEach(function(callback) {
        EmailTestsUtil.clearEmailCollections(callback);
    });

    /*!
     * Get the activity from the stream with the given criteria.
     *
     * @param  {ActivityStream}    activityStream      The stream to search
     * @param  {String}            activityType        The type of activity to find
     * @param  {String}            entityType          The type of entity to apply the criteria (one of actor, object or target)
     * @param  {String}            entityOaeId         The oae:id of the entity to search
     * @return {Activity}                              An activity from the stream that matches the provided criteria
     */
    var _getActivity = function(activityStream, activityType, entityType, entityOaeId) {
        if (!activityStream || !activityStream.items) {
            return null;
        }

        for (var i = 0; i < activityStream.items.length; i++) {
            var activity = activityStream.items[i];
            if (activity['oae:activityType'] === activityType && activity[entityType] && activity[entityType]['oae:id'] === entityOaeId) {
                return activity;
            }
        }
        return null;
    };

    /*!
     * Make a single membership or role change object to apply to a group membership or resource role.
     *
     * @param  {String} principalId   The principalId whose role to change
     * @param  {String} role          The role to change to
     * @return {Object}               The change JSON Object to apply
     */
    var _makeChange = function(principalId, role) {
        var change = {};
        change[principalId] = role;
        return change;
    };

    describe('Routes', function() {

        it('verify cyclic group memberships terminate while routing an activity', function(callback) {
            var doerUsername = TestsUtil.generateTestUserId('doer');
            var jackUsername = TestsUtil.generateTestUserId('jack');
            var group1Alias = TestsUtil.generateTestUserId('group1');
            var group2Alias = TestsUtil.generateTestUserId('group2');
            var group3Alias = TestsUtil.generateTestUserId('group3');
            var group4Alias = TestsUtil.generateTestUserId('group4');

            RestAPI.User.createUser(camAdminRestContext, doerUsername, 'password', 'Doer', null, function(err, doer) {
                assert.ok(!err);
                var doerCtx = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, doerUsername, 'password');

                RestAPI.User.createUser(camAdminRestContext, jackUsername, 'password', 'Jack McJackerson', null, function(err, jack) {
                    assert.ok(!err);
                    var jackCtx = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, jackUsername, 'password');

                    // Create the 4 groups that will form a cycle
                    RestAPI.Group.createGroup(doerCtx, group1Alias, group1Alias, 'public', 'no', [], [], function(err, group1) {
                        assert.ok(!err);

                        RestAPI.Group.createGroup(doerCtx, group2Alias, group2Alias, 'public', 'no', [group1.id], [], function(err, group2) {
                            assert.ok(!err);

                            // Group 3 will be joinable, so Jack can join it to trigger an activity
                            RestAPI.Group.createGroup(doerCtx, group3Alias, group3Alias, 'public', 'yes', [group2.id], [], function(err, group3) {
                                assert.ok(!err);

                                RestAPI.Group.createGroup(doerCtx, group4Alias, group4Alias, 'public', 'no', [group3.id], [], function(err, group4) {
                                    assert.ok(!err);

                                    // Add group4 as manager to group1 to complete the cycle
                                    var cycleChange = {};
                                    cycleChange[group4.id] = 'manager';
                                    RestAPI.Group.setGroupMembers(doerCtx, group1.id, cycleChange, function(err) {
                                        assert.ok(!err);

                                        RestAPI.Group.joinGroup(jackCtx, group3.id, function(err) {
                                            assert.ok(!err);

                                            // Verify that each group now has this as its most recent activity
                                            ActivityTestsUtil.collectAndGetActivityStream(jackCtx, group1.id, null, function(err, activityStream) {
                                                assert.ok(!err);
                                                assert.equal(activityStream.items[0]['oae:activityType'], 'group-join');
                                                assert.equal(activityStream.items[0].object['oae:id'], group3.id);

                                                ActivityTestsUtil.collectAndGetActivityStream(jackCtx, group2.id, null, function(err, activityStream) {
                                                    assert.ok(!err);
                                                    assert.equal(activityStream.items[0]['oae:activityType'], 'group-join');
                                                    assert.equal(activityStream.items[0].object['oae:id'], group3.id);

                                                    ActivityTestsUtil.collectAndGetActivityStream(jackCtx, group3.id, null, function(err, activityStream) {
                                                        assert.ok(!err);
                                                        assert.equal(activityStream.items[0]['oae:activityType'], 'group-join');
                                                        assert.equal(activityStream.items[0].object['oae:id'], group3.id);

                                                        ActivityTestsUtil.collectAndGetActivityStream(jackCtx, group4.id, null, function(err, activityStream) {
                                                            assert.ok(!err);
                                                            assert.equal(activityStream.items[0]['oae:activityType'], 'group-join');
                                                            assert.equal(activityStream.items[0].object['oae:id'], group3.id);
                                                            return callback();
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that activities are routed to indirect group member descendants. This exercises a "membership" operation which should
         * only be routed to managers, as well as a regular update operation which should get routed to all members.
         */
        it('verify group activities are routed to group member descendants', function(callback) {
            var doerUsername = TestsUtil.generateTestUserId('doer');
            var jackUsername = TestsUtil.generateTestUserId('jack');
            var managerGroupMemberUsername = TestsUtil.generateTestUserId('managerGroupMember');

            RestAPI.User.createUser(camAdminRestContext, doerUsername, 'password', 'Doer', null, function(err, doer) {
                assert.ok(!err);
                var doerCtx = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, doerUsername, 'password');

                RestAPI.User.createUser(camAdminRestContext, jackUsername, 'password', 'Jack McJackerson', null, function(err, jack) {
                    assert.ok(!err);
                    var jackCtx = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, jackUsername, 'password');

                    RestAPI.User.createUser(camAdminRestContext, managerGroupMemberUsername, 'password', 'Jane', null, function(err, managerGroupMember) {
                        assert.ok(!err);
                        var managerGroupMemberCtx = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, managerGroupMemberUsername, 'password');

                        // Create the member group, which will be member to the group that gets updated and has a user added. This group should not receive the "user added" activity
                        RestAPI.Group.createGroup(doerCtx, TestsUtil.generateTestUserId('memberGroup'), TestsUtil.generateTestUserId('memberGroup'), 'public', 'no', [], [], function(err, memberGroup) {
                            assert.ok(!err);

                            // Create the manager group, which should receive both update and "user added" activities
                            RestAPI.Group.createGroup(doerCtx, TestsUtil.generateTestUserId('managerGroup'), TestsUtil.generateTestUserId('managerGroup'), 'public', 'no', [], [], function(err, managerGroup) {
                                assert.ok(!err);

                                // ManagerGroupMember should be a member of the manager group to verify indirect group member routing
                                var membership = {};
                                membership[managerGroupMember.id] = 'manager';
                                RestAPI.Group.setGroupMembers(doerCtx, managerGroup.id, membership, function(err) {
                                    assert.ok(!err);

                                    // Create the target group, manager group and member group are members
                                    RestAPI.Group.createGroup(doerCtx, TestsUtil.generateTestUserId('targetGroup'), TestsUtil.generateTestUserId('targetGroup'), 'public', 'yes', [managerGroup.id], [memberGroup.id], function(err, targetGroup) {
                                        assert.ok(!err);

                                        RestAPI.Group.joinGroup(jackCtx, targetGroup.id, function(err) {
                                            assert.ok(!err);

                                            // Update the group to propagate an activity
                                            RestAPI.Group.updateGroup(doerCtx, targetGroup.id, {'displayName': 'Ha ha I make change'}, function(err) {
                                                assert.ok(!err);

                                                // Ensure manager group received both update and join activities
                                                ActivityTestsUtil.collectAndGetActivityStream(doerCtx, managerGroup.id, null, function(err, activityStream) {
                                                    assert.ok(!err);
                                                    assert.ok(_getActivity(activityStream, 'group-update', 'object', targetGroup.id));
                                                    assert.ok(_getActivity(activityStream, 'group-join', 'object', targetGroup.id));

                                                    // Ensure the member group received update, but not join
                                                    ActivityTestsUtil.collectAndGetActivityStream(doerCtx, memberGroup.id, null, function(err, activityStream) {
                                                        assert.ok(!err);
                                                        assert.ok(_getActivity(activityStream, 'group-update', 'object', targetGroup.id));
                                                        assert.ok(!_getActivity(activityStream, 'group-join', 'object', targetGroup.id));

                                                        // Ensure member of the manager group got both update and join
                                                        ActivityTestsUtil.collectAndGetActivityStream(managerGroupMemberCtx, managerGroupMember.id, null, function(err, activityStream) {
                                                            assert.ok(!err);
                                                            assert.ok(_getActivity(activityStream, 'group-update', 'object', targetGroup.id));
                                                            assert.ok(_getActivity(activityStream, 'group-join', 'object', targetGroup.id));
                                                            callback();
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    describe('Activity Entity Model', function() {

        // In order to test download url expiry, we need to
        // override the `Date.now` function, After each test
        // ensure it is set to the proper function
        var _originalDateNow = Date.now;
        afterEach(function(callback) {
            Date.now = _originalDateNow;
            return callback();
        });

        /**
         * Returns a stream to a jpg image
         *
         * @return {Stream} A stream to jpg image.
         */
        var _getPictureStream = function() {
            var file = __dirname + '/data/restroom.jpg';
            return fs.createReadStream(file);
        };

        /**
         * Test that verifies the contents of the full group and user activity entity models.
         */
        it('verify the user and group activity entity model', function(callback) {
            var publicUsername = TestsUtil.generateTestUserId('userPublic');
            var privateUsername = TestsUtil.generateTestUserId('userPrivate');

            // Create a public user so we can verify all the information is returned
            RestAPI.User.createUser(camAdminRestContext, publicUsername, 'password', 'Jack McJackerson', {'visibility': 'public'}, function(err, publicUser) {
                assert.ok(!err);
                var publicUserRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, publicUsername, 'password');

                var sizes = {
                    'x': 0,
                    'y': 0,
                    'width': 35,
                    'height': 35
                };

                // Give the users a profile picture so we can verify it is on the entity model
                RestAPI.User.uploadPicture(publicUserRestContext, publicUser.id, _getPictureStream, sizes, function(err) {
                    assert.ok(!err);

                    // Create private user so we can verify information is properly hidden where appropriate
                    RestAPI.User.createUser(camAdminRestContext, privateUsername, 'password', 'Jane Janerville', {'visibility': 'private', 'publicAlias': 'Jane'}, function(err, privateUser) {
                        assert.ok(!err);
                        var privateUserRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, privateUsername, 'password');

                        // Add a profile picture to the private user so we can verify it gets hidden
                        RestAPI.User.uploadPicture(privateUserRestContext, privateUser.id, _getPictureStream, sizes, function(err) {
                            assert.ok(!err);

                            // Create a group
                            RestAPI.Group.createGroup(camAdminRestContext, TestsUtil.generateTestGroupId('group'), TestsUtil.generateTestGroupId('group'), 'public', 'no', [], [], function(err, group) {
                                assert.ok(!err);

                                // Give the group a profile picture
                                RestAPI.Group.uploadPicture(camAdminRestContext, group.id, _getPictureStream, sizes, function(err) {
                                    assert.ok(!err);

                                    // Add both the public and private users to the group. They should receive eachother's user entities in the feeds
                                    var permissionChanges = {};
                                    permissionChanges[publicUser.id] = 'manager';
                                    permissionChanges[privateUser.id] = 'manager';
                                    RestAPI.Group.setGroupMembers(camAdminRestContext, group.id, permissionChanges, function(err) {
                                        assert.ok(!err);

                                        // Verify the publicUser and group model in the public user group-add-member activity
                                        ActivityTestsUtil.collectAndGetActivityStream(publicUserRestContext, publicUser.id, null, function(err, activityStream) {
                                            assert.ok(!err);

                                            // Pluck the group-add-member activity from the user's feed
                                            var activity = activityStream.items[0];
                                            assert.ok(activity);

                                            var actor = activity.actor;     // Public user
                                            var object = activity.object;   // Private user
                                            var target = activity.target;   // Group
                                            assert.ok(actor);
                                            assert.ok(object);
                                            assert.ok(target);

                                            assert.equal(object['objectType'], 'collection');
                                            assert.equal(object['oae:collection'].length, 2);

                                            var publicUserActivityEntity = null;
                                            var privateUserActivityEnity = null;
                                            _.each(object['oae:collection'], function(user) {
                                                var resourceId = AuthzUtil.getResourceFromId(user['oae:id']).resourceId;
                                                if (user['oae:id'] === publicUser.id) {
                                                    publicUserActivityEntity = user;

                                                    // Verify the public user model
                                                    assert.ok(user['id'].indexOf(publicUser.id) !== -1);
                                                    assert.equal(user['displayName'], publicUser.displayName);
                                                    assert.equal(user['objectType'], 'user');
                                                    assert.equal(user['oae:id'], publicUser.id);
                                                    assert.equal(user['oae:profilePath'], publicUser.profilePath);
                                                    assert.equal(user['oae:visibility'], publicUser.visibility);
                                                    assert.equal(user['url'], 'http://' + global.oaeTests.tenants.cam.host + '/user/camtest/' + resourceId);
                                                    assert.ok(user['image']);
                                                } else if (user['oae:id'] === privateUser.id) {
                                                    privateUserActivityEnity = user;

                                                    // Verify the private user model
                                                    assert.ok(user['id'].indexOf(privateUser.id) !== -1);
                                                    assert.equal(user['displayName'], privateUser.publicAlias);
                                                    assert.equal(user['objectType'], 'user');
                                                    assert.equal(user['oae:id'], privateUser.id);
                                                    assert.equal(user['oae:profilePath'], undefined);
                                                    assert.equal(user['oae:visibility'], privateUser.visibility);

                                                    // Url and image are not defined for unprivileged users in feeds
                                                    assert.ok(!user['url']);
                                                    assert.ok(!user['image']);
                                                }
                                            });

                                            assert.ok(publicUserActivityEntity);
                                            assert.ok(privateUserActivityEnity);

                                            // Verify the group model
                                            resourceId = AuthzUtil.getResourceFromId(group.id).resourceId;
                                            assert.ok(target['id'].indexOf(group.id) !== -1);
                                            assert.equal(target['displayName'], group.displayName);
                                            assert.equal(target['objectType'], 'group');
                                            assert.equal(target['oae:id'], group.id);
                                            assert.equal(target['oae:profilePath'], group.profilePath);
                                            assert.equal(target['oae:visibility'], group.visibility);
                                            assert.equal(target['url'], 'http://' + global.oaeTests.tenants.cam.host + '/group/camtest/' + resourceId);
                                            assert.ok(target['image']);

                                            // Ensure the standard image for the public user and group can be downloaded right now by even an anonymous user on another tenant
                                            var signedDownloadUrl = url.parse(publicUserActivityEntity.image.url, true);
                                            RestUtil.RestRequest(anonymousGtRestContext, signedDownloadUrl.pathname, 'GET', signedDownloadUrl.query, function(err, body, response) {
                                                assert.ok(!err);
                                                assert.equal(response.statusCode, 204);

                                                signedDownloadUrl = url.parse(target.image.url, true);
                                                RestUtil.RestRequest(anonymousGtRestContext, signedDownloadUrl.pathname, 'GET', signedDownloadUrl.query, function(err, body, response) {
                                                    assert.ok(!err);
                                                    assert.equal(response.statusCode, 204);

                                                    // Jump ahead in time by 5 years, test-drive a hovercar and check if the signatures still work
                                                    var now = Date.now();
                                                    Date.now = function() { return now + (5 * 365 * 24 * 60 * 60 * 1000); };

                                                    // Ensure the standard image for the public user and group can still be downloaded by even an anonymous user on another tenant
                                                    signedDownloadUrl = url.parse(publicUserActivityEntity.image.url, true);
                                                    RestUtil.RestRequest(anonymousGtRestContext, signedDownloadUrl.pathname, 'GET', signedDownloadUrl.query, function(err, body, response) {
                                                        assert.ok(!err);
                                                        assert.equal(response.statusCode, 204);

                                                        signedDownloadUrl = url.parse(target.image.url, true);
                                                        RestUtil.RestRequest(anonymousGtRestContext, signedDownloadUrl.pathname, 'GET', signedDownloadUrl.query, function(err, body, response) {
                                                            assert.ok(!err);
                                                            assert.equal(response.statusCode, 204);

                                                            return callback();
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies private unjoinable groups are not delivered to unauthorized users' activity feeds for a group-add-member activity
         */
        it('verify private unjoinable group is not propagated to non-member users for a group-add-member activity', function(callback) {
            // Create a user with which to create a group, then ensure the user gets the activity
            TestsUtil.generateTestUsers(camAdminRestContext, 3, function(err, users, mrvisser, simon, bert) {
                assert.ok(!err);

                // Simon follows bert because he's a pretty cool guy
                RestAPI.Following.follow(simon.restContext, bert.user.id, function(err) {
                    assert.ok(!err);

                    // The Vissmeister creates a joinable and unjoinable private group
                    RestAPI.Group.createGroup(mrvisser.restContext, TestsUtil.generateTestGroupId('group'), TestsUtil.generateTestGroupId('group'), 'private', 'yes', [], [], function(err, groupJoinable) {
                        assert.ok(!err);
                        RestAPI.Group.createGroup(mrvisser.restContext, TestsUtil.generateTestGroupId('group'), TestsUtil.generateTestGroupId('group'), 'private', 'no', [], [], function(err, groupUnjoinable) {
                            assert.ok(!err);

                            // Mrvisser adds bert as a member to the joinable group
                            var membersUpdate = {};
                            membersUpdate[bert.user.id] = 'member';
                            RestAPI.Group.setGroupMembers(mrvisser.restContext, groupJoinable.id, membersUpdate, function(err) {
                                assert.ok(!err);

                                // Ensure simon gets the activity because he follows bert and the group is joinable so he is allowed to see it
                                ActivityTestsUtil.collectAndGetActivityStream(simon.restContext, null, null, function(err, activityStream) {
                                    assert.ok(!err);
                                    assert.ok(_getActivity(activityStream, 'group-add-member', 'target', groupJoinable.id));

                                    // Mrvisser now adds bert to the unjoinable group
                                    RestAPI.Group.setGroupMembers(mrvisser.restContext, groupUnjoinable.id, membersUpdate, function(err) {
                                        assert.ok(!err);

                                        // Ensure simon does not get the second activity. Although he follows bert, the group propagation should forbid it
                                        ActivityTestsUtil.collectAndGetActivityStream(simon.restContext, null, null, function(err, activityStream) {
                                            assert.ok(!err);
                                            assert.ok(!_getActivity(activityStream, 'group-add-member', 'target', groupUnjoinable.id));
                                            return callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies private unjoinable groups are not delivered to unauthorized users' activity feeds for a group-create activity
         */
        it('verify that a private unjoinable group is not delivered to a non-member user feed for a group-create activity', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 3, function(err, users, branden, nico) {
                assert.ok(!err);

                // Branden and Nico follow each other
                RestAPI.Following.follow(branden.restContext, nico.user.id, function(err) {
                    assert.ok(!err);

                    RestAPI.Following.follow(nico.restContext, branden.user.id, function(err) {
                        assert.ok(!err);

                        // The Vissmeister creates a private group
                        RestAPI.Group.createGroup(branden.restContext, 'Private Group', null, 'private', 'no', [], [], function(err, privateGroup) {
                            assert.ok(!err);

                            // Ensure only the 2 following activities are in Nico's feed as he does not have access to the private group
                            ActivityTestsUtil.collectAndGetActivityStream(nico.restContext, nico.user.id, null, function(err, response) {
                                assert.ok(!err);
                                assert.equal(response.items.length, 2);
                                assert.equal(response.items[0]['oae:activityType'], 'following-follow');
                                assert.equal(response.items[1]['oae:activityType'], 'following-follow');

                                // The Vissmeister creates a public group
                                RestAPI.Group.createGroup(branden.restContext, 'Public Group', null, 'public', 'no', [], [], function(err, publicGroup) {
                                    assert.ok(!err);

                                    // Ensure the group creation activity has been delivered
                                    ActivityTestsUtil.collectAndGetActivityStream(nico.restContext, nico.user.id, null, function(err, response) {
                                        assert.ok(!err);
                                        assert.equal(response.items.length, 3);
                                        assert.equal(response.items[0]['oae:activityType'], 'group-create');
                                        assert.equal(response.items[0].object['oae:id'], publicGroup.id);

                                        return callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies private unjoinable groups are delivered to managers of content with which they are shared
         */
        it('verify private unjoinable group is propagated to content managers', function(callback) {
            // Create a user with which to create a group, then ensure the user gets the activity
            TestsUtil.generateTestUsers(camAdminRestContext, 3, function(err, users, mrvisser, simon) {
                assert.ok(!err);

                // Simon creates a public content item, he's totally a manager as well as mrvisser
                RestAPI.Content.createLink(simon.restContext, 'Google', 'Google', 'public', 'http://www.google.ca', [mrvisser.user.id], [], function(err, link) {
                    assert.ok(!err);

                    // Mrvisser creates a private unjoinable group
                    RestAPI.Group.createGroup(mrvisser.restContext, TestsUtil.generateTestGroupId('group'), TestsUtil.generateTestGroupId('group'), 'private', 'no', [], [], function(err, groupUnjoinable) {
                        assert.ok(!err);

                        // Mrvisser shares Simon's content item with his private unjoinable group
                        RestAPI.Content.shareContent(mrvisser.restContext, link.id, [groupUnjoinable.id], function(err) {
                            assert.ok(!err);

                            // Ensure that Simon gets the activity, even though he doesn't really have access to the group
                            ActivityTestsUtil.collectAndGetActivityStream(simon.restContext, null, null, function(err, activityStream) {
                                assert.ok(!err);
                                assert.ok(_getActivity(activityStream, 'content-share', 'target', groupUnjoinable.id));

                                // Mrvisser promotes the group to be a manager of the content item
                                var membersUpdate = {};
                                membersUpdate[groupUnjoinable.id] = 'manager';
                                RestAPI.Content.updateMembers(mrvisser.restContext, link.id, membersUpdate, function(err) {
                                    assert.ok(!err);

                                    // Ensure that Simon gets this activity as well since he is manager and should know
                                    ActivityTestsUtil.collectAndGetActivityStream(simon.restContext, null, null, function(err, activityStream) {
                                        assert.ok(!err);
                                        assert.ok(_getActivity(activityStream, 'content-update-member-role', 'object', groupUnjoinable.id));

                                        return callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    describe('Posting Activities', function() {

        /**
         * Test that verifies the group-create, group-update and group-update-visibility activities gets generated
         */
        it('verify group-create, group-update, group-update-visibility activities are delivered', function(callback) {
            var username = TestsUtil.generateTestUserId('user');

            // Create a user with which to create a group, then ensure the user gets the activity
            RestAPI.User.createUser(camAdminRestContext, username, 'password', 'Jack McJackerson', null, function(err, user) {
                assert.ok(!err);
                var userRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, username, 'password');

                RestAPI.Group.createGroup(camAdminRestContext, TestsUtil.generateTestGroupId('group'), TestsUtil.generateTestGroupId('group'), 'public', 'no', [user.id], [], function(err, group) {
                    assert.ok(!err);

                    RestAPI.Group.updateGroup(camAdminRestContext, group.id, {'visibility': 'loggedin'}, function(err) {
                        assert.ok(!err);

                        RestAPI.Group.updateGroup(camAdminRestContext, group.id, {'displayName': 'har har har'}, function(err) {
                            assert.ok(!err);

                            ActivityTestsUtil.collectAndGetActivityStream(camAdminRestContext, user.id, null, function(err, activityStream) {
                                assert.ok(!err);
                                assert.ok(_getActivity(activityStream, 'group-create', 'object', group.id));
                                assert.ok(_getActivity(activityStream, 'group-update', 'object', group.id));
                                assert.ok(_getActivity(activityStream, 'group-update-visibility', 'object', group.id));
                                callback();
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies the group-join activity gets fired
         */
        it('verify group-join activity is delivered', function(callback) {
            var doerUsername = TestsUtil.generateTestUserId('doer');
            var username = TestsUtil.generateTestUserId('user');

            // Create the user with which to perform setup
            RestAPI.User.createUser(camAdminRestContext, doerUsername, 'password', 'Doer', null, function(err, doer) {
                assert.ok(!err);
                var doerRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, doerUsername, 'password');

                // Create a user with which to create a group, then ensure the user gets the activity
                RestAPI.User.createUser(camAdminRestContext, username, 'password', 'Jack McJackerson', null, function(err, user) {
                    assert.ok(!err);
                    var userRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, username, 'password');

                    RestAPI.Group.createGroup(doerRestContext, TestsUtil.generateTestGroupId('group'), TestsUtil.generateTestGroupId('group'), 'public', 'yes', [], [], function(err, group) {
                        assert.ok(!err);

                        RestAPI.Group.joinGroup(userRestContext, group.id, function(err) {
                            assert.ok(!err);

                            ActivityTestsUtil.collectAndGetActivityStream(userRestContext, user.id, null, function(err, activityStream) {
                                assert.ok(!err);
                                assert.ok(_getActivity(activityStream, 'group-join', 'object', group.id));
                                callback();
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies group managers receive a notification when a user joins that group
         */
        it('verify group-join notifications are delivered', function(callback) {
            // Generate one user to create a group and one to join the group
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, mrvisser, simong) {
                assert.ok(!err);

                // Create the group that will be joined
                RestAPI.Group.createGroup(mrvisser.restContext, TestsUtil.generateTestGroupId('group'), TestsUtil.generateTestGroupId('group'), 'public', 'yes', [], [], function(err, group) {
                    assert.ok(!err);

                    // Join the group
                    RestAPI.Group.joinGroup(simong.restContext, group.id, function(err) {
                        assert.ok(!err);

                        // Ensure that the manager of the group (mrvisser) receives the notification
                        ActivityTestsUtil.collectAndGetNotificationStream(mrvisser.restContext, null, function(err, notificationStream) {
                            assert.ok(!err);
                            assert.ok(_getActivity(notificationStream, 'group-join', 'object', group.id));

                            return callback();
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies the group-add-member activity gets generated
         */
        it('verify group-add-member activity gets generated', function(callback) {
            var username = TestsUtil.generateTestUserId('user');

            // Create a user with which to create a group, then ensure the user gets the activity
            RestAPI.User.createUser(camAdminRestContext, username, 'password', 'Jack McJackerson', null, function(err, user) {
                assert.ok(!err);
                var userRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, username, 'password');

                RestAPI.Group.createGroup(camAdminRestContext, TestsUtil.generateTestGroupId('group'), TestsUtil.generateTestGroupId('group'), 'public', 'yes', [], [], function(err, group) {
                    assert.ok(!err);

                    var memberships = {};
                    memberships[user.id] = 'member';
                    RestAPI.Group.setGroupMembers(camAdminRestContext, group.id, memberships, function(err) {
                        assert.ok(!err);

                        ActivityTestsUtil.collectAndGetActivityStream(camAdminRestContext, user.id, null, function(err, activityStream) {
                            assert.ok(!err);
                            assert.ok(_getActivity(activityStream, 'group-add-member', 'target', group.id));

                            return callback();
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies the group-update-member-role activity gets generated
         */
        it('verify group-update-member-role activity gets generated', function(callback) {
            // Generate 2 users
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, john, jane) {
                assert.ok(!err);

                // Create a new group with John as manager and jane as a member
                RestAPI.Group.createGroup(john.restContext, TestsUtil.generateTestGroupId('group'), TestsUtil.generateTestGroupId('group'), 'public', 'yes', [], [jane.user.id], function(err, group) {
                    assert.ok(!err);

                    // Change Jane's role from member to manager
                    RestAPI.Group.setGroupMembers(john.restContext, group.id, _makeChange(jane.user.id, 'manager'), function(err) {
                        assert.ok(!err);

                        // Verify that John's activity stream received a 'group-update-member-role' activity
                        ActivityTestsUtil.collectAndGetActivityStream(john.restContext, null, null, function(err, activityStream) {
                            assert.ok(!err);
                            ActivityTestsUtil.assertActivity(activityStream.items[0], 'group-update-member-role', 'update', john.user.id, jane.user.id, group.id);

                            // Verify that Jane's activity stream received a 'group-update-member-role' activity
                            RestAPI.Activity.getCurrentUserActivityStream(jane.restContext, null, function(err, activityStream) {
                                assert.ok(!err);
                                ActivityTestsUtil.assertActivity(activityStream.items[0], 'group-update-member-role', 'update', john.user.id, jane.user.id, group.id);
                                return callback();
                            });
                        });
                    });
                });
            });
        });
    });

    describe('Activity Aggregation', function() {

        /**
         * Test that verifies group-join activities aggregate.
         */
        it('verify group-join activities aggregation', function(callback) {
            var jackUsername = TestsUtil.generateTestUserId('jack');
            var janeUsername = TestsUtil.generateTestUserId('jane');
            var brandenUsername = TestsUtil.generateTestUserId('branden');

            RestAPI.User.createUser(camAdminRestContext, jackUsername, 'password', 'Jack McJackerson', null, function(err, jack) {
                assert.ok(!err);
                var jackCtx = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, jackUsername, 'password');

                RestAPI.User.createUser(camAdminRestContext, janeUsername, 'password', 'Jane', null, function(err, jane) {
                    assert.ok(!err);
                    var janeCtx = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, janeUsername, 'password');

                    RestAPI.User.createUser(camAdminRestContext, brandenUsername, 'password', 'Branden', null, function(err, branden) {
                        assert.ok(!err);
                        var brandenCtx = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, brandenUsername, 'password');

                        RestAPI.Group.createGroup(jackCtx, TestsUtil.generateTestGroupId('group'), TestsUtil.generateTestGroupId('group'), 'public', 'yes', [], [], function(err, group) {
                            assert.ok(!err);

                            // Join as jane
                            RestAPI.Group.joinGroup(janeCtx, group.id, function(err) {
                                assert.ok(!err);

                                // Join as branden
                                RestAPI.Group.joinGroup(brandenCtx, group.id, function(err) {
                                    assert.ok(!err);

                                    // Get jack's own feed
                                    ActivityTestsUtil.collectAndGetActivityStream(jackCtx, null, null, function(err, activityStream) {
                                        assert.ok(!err);

                                        // Verify 1 for the group create, plus 1 for the aggregated group-join activities
                                        assert.equal(activityStream.items.length, 2);

                                        // Verify the first is the group join, with a collection of 2 actor entities (jane and branden)
                                        var entity = activityStream.items[0].actor;
                                        assert.ok(entity['oae:collection']);
                                        assert.equal(entity['oae:collection'].length, 2);
                                        callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies group-add-member activities aggregate.
         */
        it('verify group-add-member activities aggregation', function(callback) {
            var jackUsername = TestsUtil.generateTestUserId('jack');
            var janeUsername = TestsUtil.generateTestUserId('jane');
            var brandenUsername = TestsUtil.generateTestUserId('branden');

            RestAPI.User.createUser(camAdminRestContext, jackUsername, 'password', 'Jack McJackerson', null, function(err, jack) {
                assert.ok(!err);
                var jackCtx = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, jackUsername, 'password');

                RestAPI.User.createUser(camAdminRestContext, janeUsername, 'password', 'Jane', null, function(err, jane) {
                    assert.ok(!err);

                    RestAPI.User.createUser(camAdminRestContext, brandenUsername, 'password', 'Branden', null, function(err, branden) {
                        assert.ok(!err);

                        RestAPI.Group.createGroup(jackCtx, TestsUtil.generateTestGroupId('group'), TestsUtil.generateTestGroupId('group'), 'public', 'yes', [], [], function(err, group) {
                            assert.ok(!err);

                            // Join as jane
                            var membership = {};
                            membership[jane.id] = 'member';
                            RestAPI.Group.setGroupMembers(jackCtx, group.id, membership, function(err) {
                                assert.ok(!err);

                                // Join as branden
                                membership = {};
                                membership[branden.id] = 'member';
                                RestAPI.Group.setGroupMembers(jackCtx, group.id, membership, function(err) {
                                    assert.ok(!err);

                                    ActivityTestsUtil.collectAndGetActivityStream(jackCtx, null, null, function(err, activityStream) {
                                        assert.ok(!err);

                                        // Verify 1 for the group create, plus 1 for the aggregated group-add-member activities
                                        assert.equal(activityStream.items.length, 2);

                                        // Verify the first is the group join, with a collection of 2 actor entities (jane and branden)
                                        var entity = activityStream.items[0].object;
                                        assert.ok(entity['oae:collection']);
                                        assert.equal(entity['oae:collection'].length, 2);
                                        callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    describe('Emails', function() {

        /**
         * Verify that when a user is added to a group at the time a group is created, they receive an email. Also verifies
         * that private user information is appropriately scrubbed from the email.
         */
        it('verify group-create email and privacy', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users) {
                assert.ok(!err);

                var mrvisser = _.values(users)[0];
                var simong = _.values(users)[1];

                mrvisser.user.email = TestsUtil.generateTestEmailAddress('mrvisser');
                simong.user.email = TestsUtil.generateTestEmailAddress('simong');

                // Simon is private and mrvisser is public
                var mrvisserUpdate = {'email': mrvisser.user.email};
                var simongUpdate = {
                    'email': simong.user.email,
                    'visibility': 'private',
                    'publicAlias': 'swappedFromPublicAlias'
                };

                RestAPI.User.updateUser(mrvisser.restContext, mrvisser.user.id, mrvisserUpdate, function(err) {
                    assert.ok(!err);

                    RestAPI.User.updateUser(simong.restContext, simong.user.id, simongUpdate, function(err) {
                        assert.ok(!err);

                        // Create the group with a user. We will ensure that user receives an email
                        RestAPI.Group.createGroup(simong.restContext, 'emailGroupCreate', 'emailGroupCreate', 'public', 'yes', [], [mrvisser.user.id], function(err, group) {
                            assert.ok(!err);

                            // Mrvisser should get an email, with simong's information scrubbed
                            EmailTestsUtil.collectAndFetchEmails(function(messages) {

                                // There should be exactly one message, the one sent to mrvisser
                                assert.equal(messages.length, 1);

                                var stringMessage = JSON.stringify(messages[0]);
                                var message = messages[0]._message;

                                // Sanity check that the message is to mrvisser
                                assert.equal(message.to, mrvisser.user.email);

                                // Ensure some data expected to be in the email is there
                                assert.notEqual(stringMessage.indexOf(simong.restContext.hostHeader), -1);
                                assert.notEqual(stringMessage.indexOf(group.profilePath), -1);
                                assert.notEqual(stringMessage.indexOf(group.displayName), -1);

                                // Ensure simong's private info is *nowhere* to be found
                                assert.equal(stringMessage.indexOf(simong.user.displayName), -1);
                                assert.equal(stringMessage.indexOf(simong.user.email), -1);
                                assert.equal(stringMessage.indexOf(simong.user.locale), -1);

                                // The message probably contains the public alias, though
                                assert.notEqual(stringMessage.indexOf('swappedFromPublicAlias'), -1);

                                callback();
                            });
                        });
                    });
                });
            });
        });

        /**
         * Verify that group managers receive an email when someone joins that group. Also verifies that private user information
         * is appropriately scrubbed from the email.
         */
        it('verify group-join email and privacy', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 4, function(err, users, mrvisser, simong, bert, stuart) {
                assert.ok(!err);

                // Simon is private, Bert is loggedin, mrvisser and stuart are both public
                var simongUpdate = {
                    'visibility': 'private',
                    'publicAlias': 'swappedFromPublicAlias'
                };

                var bertUpdate = {
                    'visibility': 'loggedin',
                    'publicAlias': 'swappedFromPublicAlias'
                };

                // Make Bert loggedin
                RestAPI.User.updateUser(bert.restContext, bert.user.id, bertUpdate, function(err) {
                    assert.ok(!err);

                    // Make Simon private
                    RestAPI.User.updateUser(simong.restContext, simong.user.id, simongUpdate, function(err) {
                        assert.ok(!err);

                        // Create the group and then share it after. We will verify the share triggered an email
                        RestAPI.Group.createGroup(mrvisser.restContext, 'emailGroupAddMember', 'emailGroupAddMember', 'public', 'yes', [], [], function(err, group) {
                            assert.ok(!err);

                            // Collect the createGroup activity and emails before adding a member
                            EmailTestsUtil.collectAndFetchEmails(function(messages) {

                                // Join the group as simong to trigger an email with a private user
                                RestAPI.Group.joinGroup(simong.restContext, group.id, function(err) {
                                    assert.ok(!err);

                                    // Mrvisser should get an email, with simong's information scrubbed
                                    EmailTestsUtil.collectAndFetchEmails(function(messages) {

                                        // There should be exactly one message, the one sent to mrvisser
                                        assert.equal(messages.length, 1);

                                        var stringMessage = JSON.stringify(messages[0]);
                                        var message = messages[0]._message;

                                        // Sanity check that the message is to mrvisser
                                        assert.equal(message.to, mrvisser.user.email);

                                        // Ensure some data expected to be in the email is there
                                        assert.notEqual(stringMessage.indexOf(simong.restContext.hostHeader), -1);
                                        assert.notEqual(stringMessage.indexOf(group.profilePath), -1);
                                        assert.notEqual(stringMessage.indexOf(group.displayName), -1);

                                        // Ensure simong's private info is *nowhere* to be found
                                        assert.equal(stringMessage.indexOf(simong.user.displayName), -1);
                                        assert.equal(stringMessage.indexOf(simong.user.email), -1);
                                        assert.equal(stringMessage.indexOf(simong.user.locale), -1);

                                        // The message probably contains the public alias, though
                                        assert.notEqual(stringMessage.indexOf('swappedFromPublicAlias'), -1);

                                        // Join the group as bert to trigger another email with a loggedin user
                                        RestAPI.Group.joinGroup(bert.restContext, group.id, function(err) {
                                            assert.ok(!err);

                                            // Mrvisser should get an email, with Bert's information present
                                            EmailTestsUtil.collectAndFetchEmails(function(messages) {
                                                // There should be exactly one message, the one sent to mrvisser
                                                assert.equal(messages.length, 1);

                                                var stringMessage = JSON.stringify(messages[0]);
                                                var message = messages[0]._message;

                                                // Sanity check that the message is to mrvisser
                                                assert.equal(message.to, mrvisser.user.email);

                                                // Ensure some data expected to be in the email is there
                                                assert.notEqual(stringMessage.indexOf(bert.restContext.hostHeader), -1);
                                                assert.notEqual(stringMessage.indexOf(group.profilePath), -1);
                                                assert.notEqual(stringMessage.indexOf(group.displayName), -1);

                                                // Ensure bert's displayName is not scrubbed
                                                assert.notEqual(stringMessage.indexOf(bert.user.displayName), -1);
                                                assert.equal(stringMessage.indexOf('swappedFromPublicAlias'), -1);

                                                // The rest of bert's sensitive information should be scrubbed
                                                assert.equal(stringMessage.indexOf(bert.user.email), -1);
                                                assert.equal(stringMessage.indexOf(bert.user.locale), -1);

                                                // Join the group as stuart to trigger another email with a public user
                                                RestAPI.Group.joinGroup(stuart.restContext, group.id, function(err) {
                                                    assert.ok(!err);

                                                    // Mrvisser should get an email, with Stuart's information present
                                                    EmailTestsUtil.collectAndFetchEmails(function(messages) {
                                                        // There should be exactly one message, the one sent to mrvisser
                                                        assert.equal(messages.length, 1);

                                                        var stringMessage = JSON.stringify(messages[0]);
                                                        var message = messages[0]._message;

                                                        // Sanity check that the message is to mrvisser
                                                        assert.equal(message.to, mrvisser.user.email);

                                                        // Ensure some data expected to be in the email is there
                                                        assert.notEqual(stringMessage.indexOf(stuart.restContext.hostHeader), -1);
                                                        assert.notEqual(stringMessage.indexOf(group.profilePath), -1);
                                                        assert.notEqual(stringMessage.indexOf(group.displayName), -1);

                                                        // Ensure stuart's displayName is not scrubbed
                                                        assert.notEqual(stringMessage.indexOf(stuart.user.displayName), -1);
                                                        assert.equal(stringMessage.indexOf('swappedFromPublicAlias'), -1);

                                                        // The rest of stuart's sensitive information should be scrubbed
                                                        assert.equal(stringMessage.indexOf(stuart.user.email), -1);
                                                        assert.equal(stringMessage.indexOf(stuart.user.locale), -1);
                                                        return callback();
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Verify that when a user is added to a group, they receive an email. Also verifies that private user information
         * is appropriately scrubbed from the email.
         */
        it('verify group-add-member email and privacy', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, mrvisser, simong) {
                assert.ok(!err);

                mrvisser.user.email = TestsUtil.generateTestEmailAddress('mrvisser');
                simong.user.email = TestsUtil.generateTestEmailAddress('simong');

                // Simon is private and mrvisser is public
                var mrvisserUpdate = {'email': mrvisser.user.email};
                var simongUpdate = {
                    'email': simong.user.email,
                    'visibility': 'private',
                    'publicAlias': 'swappedFromPublicAlias'
                };

                RestAPI.User.updateUser(mrvisser.restContext, mrvisser.user.id, mrvisserUpdate, function(err) {
                    assert.ok(!err);

                    RestAPI.User.updateUser(simong.restContext, simong.user.id, simongUpdate, function(err) {
                        assert.ok(!err);

                        // Create the group and then share it after. We will verify the share triggered an email
                        RestAPI.Group.createGroup(simong.restContext, 'emailGroupAddMember', 'emailGroupAddMember', 'public', 'yes', [], [], function(err, group) {
                            assert.ok(!err);

                            // Collect the createGroup activity and emails before adding a member
                            EmailTestsUtil.collectAndFetchEmails(function(messages) {

                                var roleChanges = {};
                                roleChanges[mrvisser.user.id] = 'member';
                                RestAPI.Group.setGroupMembers(simong.restContext, group.id, roleChanges, function(err) {
                                    assert.ok(!err);

                                    // Mrvisser should get an email, with simong's information scrubbed
                                    EmailTestsUtil.collectAndFetchEmails(function(messages) {

                                        // There should be exactly one message, the one sent to mrvisser
                                        assert.equal(messages.length, 1);

                                        var stringMessage = JSON.stringify(messages[0]);
                                        var message = messages[0]._message;

                                        // Sanity check that the message is to mrvisser
                                        assert.equal(message.to, mrvisser.user.email);

                                        // Ensure some data expected to be in the email is there
                                        assert.notEqual(stringMessage.indexOf(simong.restContext.hostHeader), -1);
                                        assert.notEqual(stringMessage.indexOf(group.profilePath), -1);
                                        assert.notEqual(stringMessage.indexOf(group.displayName), -1);

                                        // Ensure simong's private info is *nowhere* to be found
                                        assert.equal(stringMessage.indexOf(simong.user.displayName), -1);
                                        assert.equal(stringMessage.indexOf(simong.user.email), -1);
                                        assert.equal(stringMessage.indexOf(simong.user.locale), -1);

                                        // The message probably contains the public alias, though
                                        assert.notEqual(stringMessage.indexOf('swappedFromPublicAlias'), -1);

                                        callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });
});
