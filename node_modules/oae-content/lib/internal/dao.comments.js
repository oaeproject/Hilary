/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var ShortId = require('shortid');

var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var log = require('oae-logger').logger('content-dao');
var OaeUtil = require('oae-util/lib/util');

var Comment = require('oae-content/lib/model').Comment;

// A user will be considered a recent commenter for 30 days after they have commented on an item
var DURATION_RECENT_COMMENTER_SECONDS = 30 * 24 * 60 * 60;

///////////////
// Retrieval //
///////////////


/**
 * Retrieves a single comment from Cassandra and returns a Comment object in the callback function.
 *
 * @param  {String}     commentId           The ID of the comment
 * @param  {Function}   callback            Standard callback function takes argument `err` and `comment`
 * @param  {Object}     callback.err        Error object containing the error message
 * @param  {Comment}    callback.comment    The retrieved comment object
 */
var getComment = module.exports.getComment = function(commentId, callback) {
    Cassandra.runQuery('SELECT * FROM Comments USING CONSISTENCY QUORUM WHERE commentId = ?', [commentId], function (err, commentRows) {
        if (err) {
            return callback(err);
        }

        callback(err, _rowsToComments(commentRows)[0]);
    });
};

/**
 * Retrieves the comments for a specified content item.
 *
 * @param  {String}     contentId            The ID of the content to get comments for
 * @param  {String}     start                Determines the point at which content items are returned for paging purposed. If not provided, the first x elements will be returned
 * @param  {Integer}    limit                Number of items to return. Will default to 10 if not provided
 * @param  {Function}   callback             Standard callback function takes argument `err` and `comments`
 * @param  {Object}     callback.err         Error object containing the error message
 * @param  {Comment[]}  callback.comments    The comments starting from the `start`.
 */
var getComments = module.exports.getComments = function(contentId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10);
    
    Cassandra.runPagedColumnQuery('CommentsByContent', 'contentId', contentId, start, limit, {'reversed': true}, function(err, row) {
        if (err) {
            return callback(err);
        } else if (!row.count) {
            return callback(null, []);
        }

        // Get detailed comment information
        var commentIds = [];
        row.forEach(function(name, value) {
            commentIds.push(value);
        });
        
        Cassandra.runQuery('SELECT * FROM Comments USING CONSISTENCY QUORUM WHERE commentId IN (?)', [commentIds], function (err, commentsRows) {
            if (err) {
                return callback(err);
            }

            if (commentsRows.length === 0) {
                return callback(null, []);
            }

            // Add comments to the Array to return
            var comments = _rowsToComments(commentsRows);
            for (var ii = 0; ii < comments.length; ii++) {
                // When a comment is deleted not all data needs to go back to the UI. The level
                // will be used to determine the comment's indentation, and created will be used
                // for paging purposes
                if (comments[ii].deleted === true) {
                    comments[ii] = new Comment(comments[ii].commentId, null, null, null, comments[ii].created, comments[ii].level, comments[ii].replyTo, true);
                }
            }

            return callback(null, comments);
        });
    });
};


///////////////
// Modifiers //
///////////////


/**
 * Creates a comment on a piece of content.
 *
 * @param  {String}     contentId           The ID of the piece of content that is getting a comment
 * @param  {String}     tenantAlias         The alias of the tenant where the comment is placed
 * @param  {String}     creatorId           The ID of the user who placed the comment
 * @param  {String}     body                The comment body
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containing the error message
 * @param  {Comment}    callback.commentId  The new comment
 */
var createComment = module.exports.createComment = function(contentId, tenantAlias, creatorId, body, callback) {
    // Generate a unique comment ID
    var commentId = _generateId(tenantAlias);

    // Generate a timestamp, add the `|` for correct sorting of threaded comments
    var created = Date.now() + '|';
    var queries = [
        {
            'query': 'INSERT INTO Comments (commentId, body, createdBy, created, contentId) VALUES (?, ?, ?, ?, ?)',
            'parameters': [commentId, body, creatorId, created, contentId]
        },
        {
            'query': 'UPDATE CommentsByContent SET ? = ? WHERE contentId = ?',
            'parameters': [created, commentId, contentId]
        },
        {
            'query': 'UPDATE CommentsRecentCommenters USING TTL ' + DURATION_RECENT_COMMENTER_SECONDS + ' SET ? = \'1\' WHERE contentId = ?',
            'parameters': [creatorId, contentId]
        }
    ];

    Cassandra.runBatchQuery(queries, 'QUORUM', function(err) {
        if (err) {
            return callback(err);
        }

        var comment = new Comment(commentId, body, contentId, creatorId, created, 0, null, false);
        return callback(null, comment);
    });
};

/**
 * Creates a reply to another comment.
 *
 * @param  {String}     contentId           The ID of the piece of content that is getting a comment
 * @param  {String}     tenantAlias         The alias of the tenant where the comment is placed
 * @param  {Comment}    commentReplyingTo   The comment that's being replied on
 * @param  {String}     creatorId           The ID of the user who placed the comment
 * @param  {String}     body                The comment body
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containing the error message
 * @param  {Comment}    callback.comment    The new comment
 */
var createReply = module.exports.createReply = function(contentId, tenantAlias, commentReplyingTo, creatorId, body, callback) {
    // Generate a unique comment ID
    var commentId = _generateId(tenantAlias);

    // When replying to a comment the `|` needs to be replaced by a `#` to ensure correct ordering of the returned comments (threaded)
    // A reply on a comment looks like timestampA#timestampB| where a top level comment looks like timestampA|
    var created = commentReplyingTo.created.split('|')[0] + '#' + Date.now() + '|';

    var commentContentQuery = {
        'query': 'INSERT INTO Comments (commentId, body, createdBy, replyTo, level, contentId, created) VALUES (?, ?, ?, ?, ?, ?, ?) USING CONSISTENCY QUORUM',
        'parameters': [commentId, body, creatorId, commentReplyingTo.commentId, commentReplyingTo.level + 1, contentId, created]
    };

    var commentIndexQuery = {
        'query': 'UPDATE CommentsByContent USING CONSISTENCY QUORUM SET ? = ? WHERE contentId = ?',
        'parameters': [created, commentId, contentId]
    };

    var commentCommentersQuery = {
        'query': 'UPDATE CommentsRecentCommenters USING CONSISTENCY ONE AND TTL ' + DURATION_RECENT_COMMENTER_SECONDS + ' SET ? = \'1\' WHERE contentId = ?',
        'parameters': [creatorId, contentId]
    };

    // First add the content, if this is not successful, then we should not do the comment index update
    Cassandra.runQuery(commentContentQuery.query, commentContentQuery.parameters, function(err) {
        if (err) {
            return callback(err);
        }

        // Comment was inserted successfully, now we need to attach the comment to the content item
        Cassandra.runQuery(commentIndexQuery.query, commentIndexQuery.parameters, function(err) {
            if (err) {
                return callback(err);
            }

            // Update the commenters asynchronously
            Cassandra.runQuery(commentCommentersQuery.query, commentCommentersQuery.parameters);
            
            return callback(null, new Comment(commentId, body, contentId, creatorId, created, commentReplyingTo.level + 1, commentReplyingTo.commentId, false));
        });
    });
};

/**
 * Delete a comment from the database.
 *
 * @param  {Comment}        comment             The comment to delete.
 * @param  {Function}       [callback]          Standard callback function
 * @param  {Object}         [callback.err]      Standard error object
 * @param  {Comment|null}   [callback.comment]  When the comment has been soft deleted (because it has replies), a stripped down comment object representing the deleted comment will be returned, with the `deleted` parameter set to `false`. If the comment has been deleted from Cassandra, no comment object will be returned.
 */
var deleteComment = module.exports.deleteComment = function(comment, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'commentId': comment.commentId}, 'Could not remove a comment from the database.');
        }
    };

    // Get the comment and the comment following it to check if there's a reply.
    getComments(comment.contentId, comment.created, 1, function(err, comments) {
        if (err) {
            return callback(err);
        }

        if (comments.length > 0 && comments[0].replyTo === comment.commentId) {
            // If there is a reply, mark the message as deleted but don't delete
            var q = 'UPDATE Comments USING CONSISTENCY QUORUM SET deleted = ? WHERE commentId = ?';
            Cassandra.runQuery(q, [true, comment.commentId], function(err) {
                if (err) {
                    return callback(err);
                }

                // Construct the stripped down deleted comment object and set deleted to false
                var softDeleted = new Comment(comment.commentId, null, comment.contentId, null, comment.created, comment.level, comment.replyTo, false);
                callback(err, softDeleted);
            });
        } else {
            var queries = [{
                'query': 'DELETE ? FROM CommentsByContent WHERE contentId = ?',
                'parameters': [comment.created, comment.contentId]
            }, {
                'query': 'DELETE FROM Comments WHERE commentId = ?',
                'parameters': [comment.commentId]
            }];
            Cassandra.runBatchQuery(queries, 'QUORUM', callback);
        }
    });
};

///////////////////////
// Recent commenters //
///////////////////////

/**
 * Get all the recent commenters of a content item.
 *
 * @param  {String}     contentId               The id of the content item whose recent commenters to fetch
 * @param  {String}     [start]                 The commenter (user) id from which to start fetching commenters (exclusive). If unspecified, will fetch from the start
 * @param  {Number}     [limit]                 The maximum number of commenter ids to fetch
 * @param  {Function}   callback                Invoked when the process completes
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {String[]}   callback.commenterIds   The ids of the recent commenters
 */
var getRecentCommenterIds = module.exports.getRecentCommenterIds = function(contentId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10);
    Cassandra.runPagedColumnQuery('CommentsRecentCommenters', 'contentId', contentId, start, limit, null, function(err, row) {
        if (err) {
            return callback(err);
        }

        // Scan the commenterIds from the row in order by column name
        var commenterIds = [];
        row.forEach(function(name) {
            commenterIds.push(name);
        });

        return callback(null, commenterIds);
    });
};

///////////////////////
// Utility functions //
///////////////////////

/**
 * Creates and returns an array of content comments from an Array of rows retrieved from Cassandra.
 *
 * @param  {Rows}        commentRows    Cassandra rows retrieved from the Comments CF containing comment details and references to the CommentByContentId CF
 * @return {Comment[]}                  Returns a Array of Comment objects.
 * @api private
 */
var _rowsToComments = function(commentRows) {
    var commentsArr = [];
    for (var i = 0; i < commentRows.length; i++) {
        commentRows[i] = Cassandra.rowToHash(commentRows[i]);
        var comment = new Comment(commentRows[i].commentId, commentRows[i].body, commentRows[i].contentId, commentRows[i].createdBy, commentRows[i].created, commentRows[i].level, commentRows[i].replyTo, commentRows[i].deleted);
        commentsArr.push(comment);
    }
    return commentsArr;
};

/**
 * Generates a unique resourceID for a comment.
 *
 * @param  {String} tenantAlias The alias of the tenant on which the comment is placed.
 * @return {String}             A unique resource ID.
 * @api private
 */
var _generateId = function(tenantAlias) {
    return AuthzUtil.toId('comm', tenantAlias, ShortId.generate());
};
