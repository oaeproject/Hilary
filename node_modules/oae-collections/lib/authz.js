/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var util = require('util');

var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzAPI = require('oae-authz');
var ContentAPI = require('oae-content');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var TenantsUtil = require('oae-tenants/lib/util');

var CollectionsConstants = require('./constants').CollectionsConstants;

/**
 * Determine if the user invoking the current request is allowed to view a given collection
 *
 * @param  {Context}        ctx                 The context of the current request
 * @param  {Collection}     collection          The collection for which to test permission
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Boolean}        callback.canView    `true` if the current user in context can view the collection, `false` otherwise
 */
var canViewCollectionProfile = module.exports.canViewCollectionProfile = function(ctx, collection, callback) {
    var user = ctx.user();
    AuthzAPI.resolveImplicitRole(ctx, collection.groupId, collection.tenant.alias, collection.visibility, CollectionsConstants.roles.ALL_PRIORITY, function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (implicitRole) {
            // We have an implicit access, no reason to try and find an explicit access because we can at least view the item
            return callback(null, true);
        } else if (!user) {
            // Anonymous user with no implicit access cannot view
            return callback(null, false);
        }

        // By this point, we only have access to view if we have a role on the item
        return AuthzAPI.hasAnyRole(user.id, collection.groupId, callback);
    });
};

/**
 * Determine if the user invoking the current request is allowed to manage a given collection
 *
 * @param  {Context}        ctx                 The context of the current request
 * @param  {Collection}     collection          The collection for which to test permission
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Boolean}        callback.canManage  `true` if the current user in context can manage the collection, `false` otherwise
 */
var canManageCollection = module.exports.canManageCollection = function(ctx, collection, callback) {
    var user = ctx.user();

    // Anonymous can never manage
    if (!user) {
        return callback(null, false);
    }

    AuthzAPI.resolveImplicitRole(ctx, collection.groupId, collection.tenant.alias, collection.visibility, CollectionsConstants.roles.ALL_PRIORITY, function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (implicitRole === CollectionsConstants.roles.MANAGER) {
            // We have an implicit management role (e.g., we are an administrator), return true
            return callback(null, true);
        }

        // By this point, we can only manage if we have explicit manager role
        return AuthzAPI.hasRole(user.id, collection.groupId, CollectionsConstants.roles.MANAGER, callback);
    });
};

/**
 * Determine if the user invoking the current request is allowed to share a given collection, and if
 * it is possible for the target principals to become members of the collection
 *
 * @param  {Context}        ctx                             The context of the current request
 * @param  {Collection}     collection                      The collection for which to test permission
 * @param  {String[]}       principalIds                    The ids of the principals with which the user is trying to share
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Boolean}        callback.canShare               `true` if the current user in context can share the collection, `false` otherwise
 * @param  {String[]}       callback.illegalPrincipalIds    If permission check failed because of target principal ids, this array will hold the principal ids that violated access boundaries
 */
var canShareCollection = module.exports.canShareCollection = function(ctx, collection, principalIds, callback) {
    var user = ctx.user();

    // Anonymous users can never share
    if (!user) {
        return callback(null, false);
    }

    // Get the principal objects for the principals we wish to share with
    PrincipalsDAO.getPrincipals(principalIds, null, function(err, principals) {
        if (err) {
            return callback(err);
        } else if (_.keys(principals).length !== principalIds.length) {
            return callback({'code': 400, 'msg': 'One or more target members being granted access do not exist'});
        }

        principals = _.values(principals);

        // Verify that the current user can interact with the content and the specified principals
        AuthzAPI.canInteract(ctx, collection.tenant.alias, principals, function(err, canInteract, illegalPrincipalIds) {
            if (err) {
                return callback(err);
            } else if (!canInteract) {
                return callback(null, false, illegalPrincipalIds);
            }

            AuthzAPI.resolveImplicitRole(ctx, collection.groupId, collection.tenant.alias, collection.visibility, CollectionsConstants.roles.ALL_PRIORITY, function(err, implicitRole, canInteract) {
                if (err) {
                    return callback(err);
                } else if (implicitRole === CollectionsConstants.roles.MANAGER) {
                    // Managers can always share
                    return callback(null, true);
                } else if (canInteract) {
                    // If we can interact with the item, we can always share it
                    return callback(null, true);
                }

                // If the collection is private, only managers can share it
                if (collection.visibility === AuthzConstants.visibility.PRIVATE) {
                    AuthzAPI.hasRole(user.id, collection.groupId, CollectionsConstants.roles.MANAGER, function(err, hasRole) {
                        return callback(err, hasRole);
                    });
                    return;
                }

                // At this point, we have to see if the user has any explicit role on the resource to see if they can share it
                AuthzAPI.hasAnyRole(user.id, collection.groupId, function(err, hasAnyRole) {
                    return callback(err, hasAnyRole);
                });
            });
        });
    });
};

/**
 * Determine if the user invoking the current request is allowed to set the permissions of a given
 * collection, and if it is possible for the target principals to become members of the collection
 *
 * @param  {Context}        ctx                             The context of the current request
 * @param  {Collection}     collection                      The collection for which to test permission
 * @param  {String[]}       addMemberIds                    The ids of the principals that are being added to the collection
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Boolean}        callback.canSet                 `true` if the current user in context can set the collection permissions, `false` otherwise
 * @param  {String[]}       callback.illegalPrincipalIds    If permission check failed because of target principal ids, this array will hold the principal ids that violated access boundaries
 */
var canSetCollectionPermissions = module.exports.canSetCollectionPermissions = function(ctx, collection, addMemberIds, callback) {
    // Anonymous can never update the permissions of a collection
    if (!ctx.user()) {
        return callback(null, false);
    }

    // Get the principal objects for the principals we wish to change the permissions
    // We need to grab them from the DAO as we might need the full object in the authz API
    PrincipalsDAO.getPrincipals(addMemberIds, null, function(err, principals) {
        if (err) {
            return callback(err);
        } else if (_.keys(principals).length !== addMemberIds.length) {
            return callback({'code': 400, 'msg': 'One or more target members being granted access do not exist'});
        }

        principals = _.values(principals);

        // Verify that the current user can interact with the content and the specified principals
        AuthzAPI.canInteract(ctx, collection.tenant.alias, principals, function(err, canInteract, illegalPrincipalIds) {
            if (err) {
                return callback(err);
            } else if (!canInteract) {
                return callback(null, false, illegalPrincipalIds);
            }

            // Boundaries are all good, perform the manager check
            return canManageCollection(ctx, collection, callback);
        });
    });
};

/**
 * Determine if the user invoking the current request is allowed to add content items to a given
 * collection, and if it is possible for the target content items to be added to the collection
 *
 * @param  {Context}        ctx                             The context of the current request
 * @param  {Collection}     collection                      The collection for which to test permission
 * @param  {String[]}       contentItems                    The content items being added to the collection
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Boolean}        callback.canAddItems            `true` if the current user in context can set the collection permissions, `false` otherwise
 * @param  {String[]}       callback.illegalContentItemIds  If permission check failed because of target content items, this array will hold the content item ids that violated access boundaries
 */
var canAddItemsToCollection = module.exports.canAddItemsToCollection = function(ctx, collection, contentItems, callback) {
    // Anonymous users can never add something to a collection
    if (!ctx.user()) {
        return callback({'code': 401, 'msg': 'You must be authenticated to add items to a collection'});
    }

    var privateAndOtherResources = _separatePrivateResources(contentItems);
    var privateResources = privateAndOtherResources.privateResources;
    var otherResources = privateAndOtherResources.otherResources;

    // First ensure that the current user has manager access to all the private items, if any
    ContentAPI.canManageAll(ctx, privateResources, function(err, canManageAll, illegalContentItems) {
        if (err) {
            return callback(err);
        } else if (!canManageAll) {
            return callback(null, false, _.pluck(illegalContentItems, 'id'));
        }

        // Ensure that the user is not making a tenant boundary violation with private items by
        // associating a collection to a content item who are from tenants that are not in the same
        // tenant network
        illegalContentItems = _.filter(privateResources, function(privateResource) {
            return !TenantsUtil.canInteract(collection.tenant.alias, privateResource.tenant.alias);
        });

        if (!_.isEmpty(illegalContentItems)) {
            return callback(null, false, _.pluck(illegalContentItems, 'id'));
        }

        // Ensure that the user is not making tenant or privacy boundary violations with the
        // non-private content items. These are done differently than the private items simply
        // because for the private items the user must be a manager, and standard interaction checks
        // will not cover that
        AuthzAPI.canInteract(ctx, collection.tenant.alias, otherResources, function(err, canInteract, illegalContentIds) {
            if (err) {
                return callback(err);
            } else if (!canInteract) {
                return callback(null, false, illegalContentIds);
            }

            // Finally, ensure we can manage the collection to which we are adding the content items
            return canManageCollection(ctx, collection, callback);
        });
    });
};

/**
 * Resolve the overall access the current user in context has on the given collection
 *
 * @param  {Context}        ctx                     The context of the current request
 * @param  {Collection}     collection              The collection for which to test permission
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Boolean}        callback.canView        Whether or not the current user can view the given collection
 * @param  {Boolean}        callback.canManage      Whether or not the current user can manage the given collection
 * @param  {Boolean}        callback.canAddItem     Whether or not the current user can add a content item to the given collection
 */
var resolveEffectiveCollectionAccess = module.exports.resolveEffectiveCollectionAccess = function(ctx, collection, callback) {
    var user = ctx.user();
    AuthzAPI.resolveEffectiveRole(ctx, collection.groupId, collection.tenant.alias, collection.visibility, CollectionsConstants.roles.ALL_PRIORITY, function(err, effectiveRole, canInteract) {
        if (err) {
            return callback(err);
        }

        var canView = _.isString(effectiveRole);
        var canManage = (effectiveRole === CollectionsConstants.roles.MANAGER);
        var canAddItem = canManage;

        // Anyone who can interact can share, unless the collection is private. In that case, only managers can share
        var canShare = canInteract;
        if (collection.visibility !== AuthzConstants.visibility.PUBLIC && collection.visibility !== AuthzConstants.visibility.LOGGEDIN) {
            canShare = canManage;
        }

        return callback(null, canView, canManage, canShare, canAddItem);
    });
};

/**
 * Separate the list of resources between those that are private and those that are not
 *
 * @param  {Object[]}   resources                   An array of resources to separate
 * @param  {String}     resources[i].visibility     Each resource should have a visibility field to test
 * @return {Object}                                 An object with 2 fields: `privateResources` and `otherResources`; indicating the private and non-private resources of the array, respectively
 * @api private
 */
var _separatePrivateResources = function(resources) {
    var split = _.partition(resources, function(resource) {
        return (resource.visibility === AuthzConstants.visibility.PRIVATE);
    });

    return {'privateResources': split[0], 'otherResources': split[1]};
};
