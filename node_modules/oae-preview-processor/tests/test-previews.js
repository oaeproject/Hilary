/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');
var fs = require('fs');
var ShortId = require('shortid');
var Path = require('path');

var IO = require('oae-util/lib/io');
var RestAPI = require('oae-rest');
var Tempfile = require('oae-util/lib/tempfile');
var TestsUtil = require('oae-tests/lib/util');

var PreviewAPI = require('oae-preview-processor/lib/api');
var PreviewContext = require('oae-preview-processor/lib/model').PreviewContext;
var PreviewImages = require('oae-preview-processor/lib/api.images');
var PreviewOffice = require('oae-preview-processor/lib/api.office');
var PreviewPDF = require('oae-preview-processor/lib/api.pdf');
var PreviewUtil = require('oae-preview-processor/lib/util');

describe('Preview processor', function() {

    // We fill this variable on tests startup with the configuration
    // as specified in the root config.js/beforeTests file.
    var defaultConfig = null;

    // Rest contexts that can be used every time we need to make a request as a tenant admin
    var signedAdminRestContext = null;

    before(function(callback) {
        signedAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.localhost.host);

        // Log in the admin so his cookie jar is set up appropriately
        RestAPI.User.getMe(signedAdminRestContext, function(err, meObj) {
            assert.ok(!err);

            defaultConfig = PreviewAPI.getConfiguration();

            callback();
        });
    });

    /**
     * Some of these tests change the configuration of the processors.
     * Ensure that after each test, the default config (as specified in /config.js)
     * is re-initialized.
     */
    afterEach(function(callback) {
        PreviewAPI.refreshPreviewConfiguration(defaultConfig, callback);
    });

    /**
     * @return {Stream} Returns a stream that points to an image.
     */
    var getImageStream = function() {
        return fs.createReadStream(__dirname + '/data/image.png');
    };

    /**
     * @return {Stream} Returns a stream that points to an Office file.
     */
    var getOfficeStream = function() {
        return fs.createReadStream(__dirname + '/data/word.docx');
    };

    /**
     * @return {Stream} Returns a stream that points to a PDF file.
     */
    var getPDFStream = function() {
        return fs.createReadStream(__dirname + '/data/pdf.pdf');
    };

    describe('Processor registration', function() {

        /**
         * Verifies that the processors are unregistered correctly and that the specified ranking is honoured.
         */
        it('verify that processors can be unregistered', function() {
            // Register 2 processors for the same content type/mimetype.
            PreviewAPI.registerProcessor('verify-unregister-20', 'verify-unregister-resourceSubType', ['text/plain'], 20, function() { return 20; });
            PreviewAPI.registerProcessor('verify-unregister-30', 'verify-unregister-resourceSubType', ['text/plain'], 30, function() { return 30; });

            // Our processor '30' should be the first
            var proc = PreviewAPI.getProcessor('verify-unregister-resourceSubType', 'text/plain');
            assert.ok(proc);
            assert.equal(proc(), 30);

            // When we remove processor '30', processor '20' should now be the top one.
            PreviewAPI.unregisterProcessor('verify-unregister-30');
            proc = PreviewAPI.getProcessor('verify-unregister-resourceSubType', 'text/plain');
            assert.ok(proc);
            assert.equal(proc(), 20);

            // When we remove processor '20', null should be returned
            PreviewAPI.unregisterProcessor('verify-unregister-20');
            proc = PreviewAPI.getProcessor('verify-unregister-resourceSubType', 'text/plain');
            assert.equal(proc, null);
        });

        /**
         * Verifies that processors can be registered without specifying a mimetype.
         * (As some content types don't have a mimetype.)
         */
        it('verify mimetypes are optional', function() {
            PreviewAPI.registerProcessor('verify-no-mimetype', 'verify-no-mimetype-resourceSubType', null, 20, function() { return 20; });
            var proc = PreviewAPI.getProcessor('verify-no-mimetype-resourceSubType');
            assert.ok(proc);
            assert.equal(proc(), 20);
        });

        /**
         * Tries to register a processor with the provided parameters.
         * It expects a failure.
         */
        var registerProcessor = function(id, resourceSubType, mimeType, ranking, processor) {
            assert.throws(function() {
                PreviewAPI.registerProcessor(id, resourceSubType, mimeType, ranking, processor);
            }, Error, 'Registering a processor with missing parameters should throw an error');
        };

        /**
         * Verifies that all required parameters are validated when (un)registering a processor.
         */
        it('verify parameter validation', function() {
            registerProcessor(null, 'verify-param-validation-resourceSubType', ['text/plain'], 20, function() { return 20; });
            registerProcessor('verify-param-validation', null, ['text/plain'], 20, function() { return 20; });
            registerProcessor('verify-param-validation', 'verify-param-validation-resourceSubType', ['text/plain'], null, function() { return 20; });
            registerProcessor('verify-param-validation', 'verify-param-validation-resourceSubType', ['text/plain'], 'non numeric', function() { return 20; });
            registerProcessor('verify-param-validation', 'verify-param-validation-resourceSubType', ['text/plain'], 20, null);

            assert.throws(function() {
                PreviewAPI.unregisterProcessor(null);
            }, Error, 'Trying to unregistering without a processor ID should fail.');
        });
    });

    describe('Model', function() {

        describe('#setStatus', function() {

            /**
             * Verifies that the setStatus method of the PreviewContext works as expected.
             */
            it('verify that the content item gets updated', function(callback) {
                // Create a piece of content as a regular user
                TestsUtil.generateTestUsers(signedAdminRestContext, 1, function(err, response) {
                    assert.ok(!err);
                    var restCtx = _.values(response)[0].restContext;
                    RestAPI.Content.createFile(restCtx, 'Test Content 1', 'Test content description 1', 'private', getImageStream,  [], [], function(err, contentObj) {
                        assert.ok(!err);
                        assert.equal(contentObj.previews.status, 'pending');

                        // Now try setting the preview status to error.
                        var previewContext = new PreviewContext(defaultConfig, contentObj.id);
                        previewContext.login(function(err) {
                            assert.ok(!err);

                            previewContext.setStatus('error', function(err) {
                                assert.ok(!err);

                                RestAPI.Content.getContent(restCtx, contentObj.id, function(err, updatedContent) {
                                    assert.ok(!err);
                                    assert.equal(updatedContent.previews.status, 'error');
                                    callback();
                                });
                            });
                        });
                    });
                });
            });
        });

        describe('#savePreviews', function() {

            /**
             * Tests the logic for adding previews and ensures they are associated to the content object.
             */
            it('verify that previews can be added', function(callback) {
                // Create a piece of content as a regular user
                TestsUtil.generateTestUsers(signedAdminRestContext, 1, function(err, response) {
                    assert.ok(!err);
                    var restCtx = _.values(response)[0].restContext;
                    RestAPI.Content.createFile(restCtx, 'Test Content 1', 'Test content description 1', 'private', getImageStream,  [], [], function(err, contentObj) {
                        assert.ok(!err);
                        assert.equal(contentObj.previews.status, 'pending');

                        var previewContext = new PreviewContext(defaultConfig, contentObj.id);
                        previewContext.login(function(err) {
                            assert.ok(!err);

                            // Fake a preview and thumbnail.
                            previewContext.addPreview(__dirname + '/data/image.png', 'medium');
                            previewContext.setThumbnail(__dirname + '/data/image.png');

                            // Add some metadata
                            previewContext.addMetadata('pageCount', 6);

                            previewContext.savePreviews(function(err) {
                                assert.ok(!err);

                                // Ensure they were stored.
                                RestAPI.Content.getPreviewItems(restCtx, contentObj.id, function(err, previews, response) {
                                    assert.ok(!err);
                                    assert.equal(previews.files.length, 1);

                                    // Ensure there is a thumbnail.
                                    RestAPI.Content.getContent(restCtx, contentObj.id, function(err, updatedContent) {
                                        assert.ok(!err);
                                        // Ensure we have a thumbnail url.
                                        assert.ok(updatedContent.previews.thumbnailUrl);
                                        // That url should be deterministic.
                                        assert.equal(updatedContent.previews.thumbnailUrl.indexOf('/api/content/' + contentObj.id + '/previews/thumbnail.png'), 0);
                                        assert.equal(updatedContent.previews.pageCount, 6);
                                        callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    describe('Preview processor initialization', function() {

        /**
         * Configuring the Office PP with the wrong path to the LibreOffice binary should result in a 500 error.
         */
        it('verify the Office PP can detect if it is configured correctly.', function(callback) {
            var config = {
                'previews': {
                    'office': {
                        'binary': 'some-none-existinant-binary'
                    }
                }
            };
            PreviewOffice.init(config, function(err) {
                assert.ok(err);
                assert.equal(err.code, 500);
                callback();
            });
        });

        /**
         * Configuring the PDF PP with the wrong path to the pdftk binary should result in a 500 error.
         */
        it('verify the PDF PP can detect if it is configured correctly.', function(callback) {
            var config = {
                'previews': {
                    'pdf': {
                        'binary': 'some-none-existinant-binary'
                    }
                }
            };
            PreviewPDF.init(config, function(err) {
                assert.ok(err);
                assert.equal(err.code, 500);
                callback();
            });
        });
    });

    describe('Preview generation', function() {
        var ctx = null;

        /**
         * Clean up after each test.
         */
        afterEach(function() {
            if (ctx) {
                ctx.cleanup();
            }
        });

        /**
         * Returns a semi-mocked PreviewContext object where the download method is mocked so it always returns the specified path.
         *
         * @param  {String}         path    The path that should be returned when `download` is executed.
         * @return {PreviewContext}         The mocked preview context object.
         */
        var getPreviewContext = function(path) {
            var contentId = 'c:foo:' + ShortId.generate();
            var ctx = new PreviewContext(defaultConfig, contentId);

            // Mock the download method.
            ctx.download = function(callback) {
                callback(null, path);
            };
            return ctx;
        };

        /**
         * Verifies that the number of generated previews matches the expected number.
         * This method will also verify that there are actual files on disk.
         *
         * @param  {PreviewContext} ctx              The PreviewContext object that holds the metadata
         * @param  {Number}         expectedPreviews The amount of preview items we expected to create.
         */
        var verifyPreviews = function(ctx, expectedPreviews) {
            var previews = ctx.getPreviews();
            assert.equal(previews.length, expectedPreviews);

            // Ensure that the thumbnail exists.
            assert.ok(ctx.getThumbnail());
            assert.ok(fs.existsSync(ctx.getThumbnail()));

            // Ensure that the previews exist on the filesystem.
            _.each(previews, function(preview) {
                assert.ok(preview.path);
                assert.ok(fs.existsSync(preview.path));
            });
        };

        /**
         * Verifies the image processor.
         */
        it('verify image processing works', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            ctx = getPreviewContext(__dirname + '/data/image.png');

            PreviewImages.generatePreviews(ctx, function(err) {
                assert.ok(!err);
                verifyPreviews(ctx, 2);

                // Ensure that the names are <size>.png
                var mappedPreviews = {};
                _.each(ctx.getPreviews(), function(preview) { mappedPreviews[preview.size] = preview; });
                assert.equal(Path.basename(mappedPreviews['medium'].path), 'medium.png');
                assert.equal(Path.basename(mappedPreviews['small'].path), 'small.png');
                callback();
            });
        });

        /**
         * Verifies the office processor.
         */
        it('verify office processing works', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            ctx = getPreviewContext(__dirname + '/data/word.docx');

            PreviewOffice.generatePreviews(ctx, function(err) {
                assert.ok(!err);
                verifyPreviews(ctx, 6);
                assert.equal(ctx.getMetadata().pageCount, 2);
                callback();
            });
        });

        /**
         * Verifies the PDF processor.
         */
        it('verify pdf processing works', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            ctx = getPreviewContext(__dirname + '/data/pdf.pdf');

            PreviewPDF.generatePreviews(ctx, function(err) {
                assert.ok(!err);
                verifyPreviews(ctx, 3);
                assert.equal(ctx.getMetadata().pageCount, 1);

                var mappedPreviews = {};
                _.each(ctx.getPreviews(), function(preview) { mappedPreviews[preview.size] = preview; });
                assert.equal(Path.basename(mappedPreviews['large'].path), 'page.1.large.png');
                assert.equal(Path.basename(mappedPreviews['normal'].path), 'page.1.normal.png');
                assert.equal(Path.basename(mappedPreviews['small'].path), 'page.1.small.png');
                callback();
            });
        });

        /**
         * Create a document and verify that the PP ignores it and sets the status.
         */
        it('verify that documents get ignored', function(callback) {
            TestsUtil.generateTestUsers(signedAdminRestContext, 1, function(err, response) {
                assert.ok(!err);
                var restCtx = _.values(response)[0].restContext;
                RestAPI.Content.createCollabDoc(restCtx, 'Test document', 'Test content description', 'private', [], [], function(err, contentObj) {
                    assert.ok(!err);
                    assert.equal(contentObj.previews.status, 'pending');

                    PreviewAPI.generatePreviews(contentObj.id, function(err) {
                        assert.ok(!err);

                        RestAPI.Content.getContent(restCtx, contentObj.id, function(err, updatedContent) {
                            assert.ok(!err);
                            assert.equal(updatedContent.previews.status, 'ignored');
                            callback();
                        });
                    });
                });
            });
        });
    });

    describe('Preview util', function() {
        describe('#downloadRemoteFile', function() {

            it('verify remote files can be downloaded', function() {
                var tmpPath = Tempfile.createTempFile();
                PreviewUtil.downloadRemoteFile('http://localhost:2000/api/me', tmpPath.path, function(err, path) {
                    assert.ok(!err);
                    IO.readFile(path, function(err, data) {
                        assert.ok(!err);

                        // Verify there is some data there.
                        assert.ok(data);

                        // Verify we don't leak the global session into the download fetcher.
                        data = JSON.parse(data);
                        assert.ok(data.anon);
                    });
                });
            });
        });
    });
});
