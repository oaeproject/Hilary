/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var roles = { 'api': require('oae-roles/lib/api') };
var principals = { 'api': require('oae-principals/lib/api') };

/**
 * Determine whether or not the principal specified by principalUuid can perform the action on the given resourceUuid
 * 
 * @param {String} principalUuid The principal to check
 * @param {String} action The action to check
 * @param {String} resourceUuid The resource to check
 * @param {Function(err, isAllowed)} callback A function specifying whether or not the user can perform the operation
 * @param {Object} callback.err An error that occured, if any
 * @param {Boolean} callback.isAllowed Whether or not the principal can perform the operation on the resource
 */
module.exports.isAllowed = function(principalUuid, action, resourceUuid, callback) {
    // first check this principal directly
    roles.api.hasRole(principalUuid, resourceUuid, action, function(err, hasRole) {
        if (!err) {
            if (hasRole) {
                return callback(null, true);
            } else {
                // get the entire (indirect as well) group ancestry of the principal and check if they have the access

                // TODO: There is a potential optimization here to not aggressively get all ancestors, but rather check one level at a time
                // We can do the above optimization assuming we can short-circuit the checks when we get one positive check.
                principals.api.memberOf(principalUuid, false, null, null, function(err, groupUuids) {
                    if (!err) {
                        return internalIsAllowed(groupUuids, action, resourceUuid, callback);
                    } else {
                        return callback(err);
                    }
                });
            }
        } else {
            return callback(err);
        }
    });
}

/**
 * Determine whether or not the principal specified by principalUuid can perform at least one action on the given resourceUuid

 * @param {String} principalUuid The principal to check
 * @param {String} resourceUuid The resourceUuid to check
 * @param {Function(err, isAllowed)} callback A function specifying whether or not the user can perform any operation
 * @param {Object} callback.err An error that occured, if any
 * @param {Boolean} callback.isAllowed Whether or not the principal is authorized to perform any action on the resource
 */
module.exports.isAllowedAny = function(principalUuid, resourceUuid, callback) {
    // first check the principal directly
    roles.api.getRole(principalUuid, resourceUuid, function(err, role) {
        if (!err) {
            if (role) {
                // there was a role, short-circuit and indicate that the user has some role on the resource
                return callback(null, true);
            } else {
                principals.api.memberOf(principalUuid, false, null, null, function(err, groupUuids) {
                    if (!err) {
                        return internalIsAllowed(groupUuids, null, resourceUuid, callback);
                    } else {
                        return callback(err);
                    }
                });
            }
        } else {
            return callback(err);
        }
    });
}

/**
 * Determine whether or not one of the principals in the array of principalUuids is able to perform the action on the
 * resource specified. If the action is null, then we will determine if the user can perform *any* action on the
 * resource specified.
 *
 * @param {Array<String>} principalUuids The array of principals to check
 * @param {String} action The action to check. If null, check for any action.
 * @param {String} resourceUuid The resource to check
 * @param {Function(err, isAllowed)} callback A function invoked when the process is complete.
 * @param {Object} callback.err An error that occured, if any
 * @param {Boolean} callback.isAllowed Whether or not one of the principals is authorized to perform the action
 */
var internalIsAllowed = function(principalUuids, action, resourceUuid, callback) {

    // short circuit if there is no ancestry
    if (!(principalUuids.length > 0)) {
        return callback(null, false);
    }

    // variables for monitoring the progress of permissions checks
    var index = 0;
    var isAllowedResult = false;
    var errResult = false;

    // this function monitors the progress of asynchronous permissions checks, calling back to the caller when appropriate
    var checkStatus = function(err, isAllowed) {
        if (errResult || isAllowedResult) {
            // do nothing, because we've already finished executing and called the callback
        } else if (err) {
            // we got an error while executing, call back with the error
            errResult = err;
            return callback(errResult);
        } else if (isAllowed) {
            // one of the principals is allowed to perform the action, short circuit
            isAllowedResult = isAllowed;
            return callback(null, isAllowedResult);
        } else {
            index++;
            if (index >= principalUuids.length) {
                // we've reached the end of the check and none are allowed, return false
                return callback(null, false);
            }
        }
    }

    // invoke the entire ancestry asynchronously. checkStatus will determine the result and when it is possible to call back.
    for (var i = 0; i < principalUuids.length; i++) {
        var principalUuid = principalUuids[i];
        if (action !== null) {
            roles.api.hasRole(principalUuid, resourceUuid, action, checkStatus);
        } else {
            // we pass checkStatus directly here on the basis that the 'isAllowed' parameter is a duck-check and not strictly typed.
            roles.api.getRole(principalUuid, resourceUuid, checkStatus);
        }
    }
}