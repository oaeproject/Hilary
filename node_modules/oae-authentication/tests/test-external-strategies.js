/*
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');
var request = require('request');
var url = require('url');
var xml2js = require('xml2js');

var ConfigTestUtil = require('oae-config/lib/test/util');
var RestAPI = require('oae-rest');
var RestUtil = require('oae-rest/lib/util');
var TestsUtil = require('oae-tests');

var AuthenticationAPI = require('oae-authentication');
var AuthenticationConstants = require('oae-authentication/lib/constants').AuthenticationConstants;
var Config = require('oae-config/lib/api').config('oae-authentication');

describe('Authentication', function() {

    // Rest context that can be used every time we need to make a request as a global admin
    var globalAdminRestContext = null;

    var anonymousCamRestContext = null;
    var camAdminRestContext = null;

    /**
     * Function that will fill up the global admin rest context
     */
    before(function() {
        // Fill up global admin rest context
        globalAdminRestContext = TestsUtil.createGlobalAdminRestContext();
        // Fill up Cam anonymous rest context
        anonymousCamRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host);
        // Fill up Cam admin rest context
        camAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.cam.host);
    });

    /**
     * Test util function to enable an authentication strategy
     *
     * @param  {String}     strategyName            The name of the authentication strategy to enable
     * @param  {Function}   enabledCallback         Standard function that will be invoked when the strategy is enabled
     * @param  {Function}   enabledCallback.done    Standard function that you will have to invoke once you're done with the strategy and it can be reset again
     * @param  {Function}   resetCallback           Standard function that will be invoked when the strategy has been reset
     */
    var enableStrategy = function(strategyName, enabledCallback, resetCallback) {
        var strategyStatus = Config.getValue(global.oaeTests.tenants.global.alias, strategyName, 'enabled');

        // Enable strategy
        var configUpdate = {};
        configUpdate['oae-authentication/' + strategyName + '/enabled'] = true;
        ConfigTestUtil.updateConfigAndWait(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, configUpdate, function(err) {
            assert.ok(!err);
        });

        // Wait until the authentication api has finished refreshing its strategies
        AuthenticationAPI.once(AuthenticationConstants.events.REFRESHED_STRATEGIES, function(tenant) {
            // The strategy has been enabled, perform some assertions
            enabledCallback(function() {
                // Reset strategy to cached status
                configUpdate['oae-authentication/' + strategyName + '/enabled'] = strategyStatus;
                ConfigTestUtil.updateConfigAndWait(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, configUpdate, function(err) {
                    assert.ok(!err);
                });
                AuthenticationAPI.once(AuthenticationConstants.events.REFRESHED_STRATEGIES, function(tenant) {
                    resetCallback();
                });
            });
        });
    };

    /**
     * Disables an external authentication strategy and verifies the endpoint no longer responds to
     * authentication requests.
     *
     * @param  {String}     strategyName    The strategy to disable. e.g., `twitter`, `facebook`, ..
     * @param  {String}     method          The HTTP method to use for the callback URL. Some strategies (e.g., `SAML2`) require a POST callback
     * @param  {Function}   callback        Standard callback method
     */
    var verifyEndpointIsDisabled = function(strategyName, method, callback) {
        enableStrategy(strategyName, function(done) {
            var options = {
                'uri': 'http://' + global.oaeTests.tenants.localhost.host + '/api/auth/' + strategyName,
                'headers': {
                    'host': global.oaeTests.tenants.localhost.host,
                    'referer': '/'
                },
                'method': 'POST',
                'followRedirect': false
            };
            request(options, function (err, response, body) {
                assert.ok(!err);
                assert.equal(response.statusCode, 302);

                // Now disable it
                var configUpdate = {};
                configUpdate['oae-authentication/' + strategyName + '/enabled'] = false;
                ConfigTestUtil.updateConfigAndWait(globalAdminRestContext, 'localhost', configUpdate, function() {
                    assert.ok(!err);
                });

                // Wait until the authentication api has finished refreshing its strategies
                AuthenticationAPI.once(AuthenticationConstants.events.REFRESHED_STRATEGIES, function(tenant) {

                    // A disabled endpoint should return a 401.
                    request(options, function (err, response, body) {
                        assert.ok(!err);
                        assert.equal(response.statusCode, 302);
                        assert.equal(response.headers.location, '/?authentication=disabled');
                        options.uri = 'http://' + global.oaeTests.tenants.localhost.host + '/api/auth/' + strategyName + '/callback';
                        options.method = method;

                        request(options, function (err, response, body) {
                            assert.ok(!err);
                            assert.equal(response.statusCode, 302);
                            assert.equal(response.headers.location, '/?authentication=disabled');

                            // Reset the strategy
                            done();
                        });
                    });
                });
            });
        }, callback);
    };

    /**
     * Verifies that the given strategy forwards the client to the given host
     *
     * @param  {String}   strategyName      The name of the authentication strategy to use
     * @param  {String}   host              The host that the strategy is expected to forward the user to
     * @param  {Function} callback          Function to call when test is completed
     */
    var verifyForward = function(strategyName, host, callback) {
        enableStrategy(strategyName, function(done) {
            var options = {
                'uri': 'http://' + global.oaeTests.tenants.localhost.host + '/api/auth/' + strategyName,
                'headers': {
                    'host': global.oaeTests.tenants.localhost.host,
                    'referer': '/'
                },
                'method': 'POST',
                'followRedirect': false
            };
            request(options, function(err, res, body) {
                assert.ok(!err);
                assert.equal(res.statusCode, 302);
                assert.equal(url.parse(res.headers['location']).hostname, host);

                return done();
            });
        }, callback);
    };

    /**
     * Verifies that an authentication strategy can deal with parameter tampering
     *
     * @param  {String}     strategyName    The name of the authentication strategy to test
     * @param  {String}     method          The HTTP method to use
     * @param  {Object}     parameters      The parameters (either querystring or POST parameters) to send in the request
     * @param  {Function}   callback        Standard callback function
     */
    var verifyCallbackTampering = function(strategyName, method, parameters, callback) {
        enableStrategy(strategyName, function(done) {
            var options = {
                'uri': 'http://' + global.oaeTests.tenants.localhost.host + '/api/auth/' + strategyName + '/callback',
                'headers': {
                    'host': global.oaeTests.tenants.localhost.host
                },
                'method': method,
                'followRedirect': false
            };
            if (method === 'GET') {
                options.qs = parameters;
            } else {
                options.form = parameters;
            }

            request(options, function(err, response, body) {
                assert.ok(!err);
                assert.equal(response.statusCode, 302);
                assert.equal(response.headers.location, '/?authentication=error');
                return done();
            });
        }, callback);
    };

    describe('External authentication', function() {

        /**
         * Verifies that /api/auth/google sends the client to google
         */
        it('verify forward to google', function(callback) {
            verifyForward('google', 'accounts.google.com', callback);
        });

        /**
         * Verifies that /api/auth/facebook sends the client to facebook
         */
        it('verify forward to facebook', function(callback) {
            verifyForward('facebook', 'www.facebook.com', callback);
        });

        /**
         * Verifies that /api/auth/twitter sends the client to twitter
         */
        it('verify forward to twitter', function(callback) {
            verifyForward('twitter', 'api.twitter.com', callback);
        });

        /**
         * Verifies that disabling the CAS authentication mechanism in the Config
         * disabled the authentication logic in the REST endpoints.
         */
        it('verify disabling the CAS strategy', function(callback) {
            verifyEndpointIsDisabled('cas', 'GET', callback);
        });

        /**
         * Verifies that disabling the Facebook authentication mechanism in the Config
         * disabled the authentication logic in the REST endpoints.
         */
        it('verify disabling the Facebook strategy', function(callback) {
            verifyEndpointIsDisabled('facebook', 'GET', callback);
        });

        /**
         * Verifies that disabling the Google authentication mechanism in the Config
         * disabled the authentication logic in the REST endpoints.
         */
        it('verify disabling the Google strategy', function(callback) {
            verifyEndpointIsDisabled('google', 'GET', callback);
        });

        /**
         * Verifies that disabling the Shibboleth authentication mechanism in the Config
         * disabled the authentication logic in the REST endpoints.
         */
        it('verify disabling the Shibboleth strategy', function(callback) {
            verifyEndpointIsDisabled('shibboleth', 'POST', callback);
        });

        /**
         * Verifies that disabling the Twitter authentication mechanism in the Config
         * disabled the authentication logic in the REST endpoints.
         */
        it('verify disabling the Twitter strategy', function(callback) {
            verifyEndpointIsDisabled('twitter', 'GET', callback);
        });

        /**
         * Test that verifies that the Twitter authentication mechanism can deal with URL tampering
         */
        it('verify the Twitter callback endpoint can deal with URL tampering', function(callback) {
            verifyCallbackTampering('twitter', 'GET', {'oauth_token': 'not-valid'} , callback);
        });

        /**
         * Test that verifies that the Google authentication mechanism can deal with URL tampering
         */
        it('verify the Google callback endpoint can deal with URL tampering', function(callback) {
            verifyCallbackTampering('google', 'GET', {'code': 'not-valid'}, callback);
        });

        /**
         * Test that verifies that the Facebook authentication mechanism can deal with URL tampering
         */
        it('verify the Facebook callback endpoint can deal with URL tampering ', function(callback) {
            verifyCallbackTampering('facebook', 'GET', {'code': 'not-valid'}, callback);
        });
    });

    describe('Shibboleth authentication', function() {

        /**
         * Test that verifies the Shibboleth SP metadata can be retrieved
         */
        it('verify the Shibboleth Service Provider metadata can be retrieved', function(callback) {
            // Set the proper shib metadata
            var configUpdate = {};
            configUpdate['oae-authentication/shibboleth/name'] = 'Test IdP';
            configUpdate['oae-authentication/shibboleth/idpUrl'] = 'https://idp.example.com';
            configUpdate['oae-authentication/shibboleth/idpPublicKey'] = 'The IdP Public key';
            configUpdate['oae-authentication/shibboleth/spEntityID'] = 'Our SP entity Id';
            configUpdate['oae-authentication/shibboleth/spCertificate'] = 'Our SP public key';
            configUpdate['oae-authentication/shibboleth/spCertificateSubjectName'] = 'Our SP certificate subject name';
            configUpdate['oae-authentication/shibboleth/spPrivateKey'] = 'Our SP private key';
            ConfigTestUtil.updateConfigAndWait(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, configUpdate, function(err) {
                assert.ok(!err);

                enableStrategy('shibboleth', function(done) {

                    // Get the shibboleth metadata
                    var options = {
                        'uri': 'http://' + global.oaeTests.tenants.localhost.host + '/api/auth/shibboleth/metadata',
                        'headers': {
                            'host': global.oaeTests.tenants.localhost.host
                        }
                    };
                    request(options, function(err, res, body) {
                        assert.ok(!err);
                        assert.equal(res.statusCode, 200);

                        // Assert that the format and content is correct
                        xml2js.parseString(body, function (err, result) {
                            assert.ok(!err);
                            // Assert our entity ID is present
                            assert.equal(result['md:EntityDescriptor']['$']['entityID'], configUpdate['oae-authentication/shibboleth/spEntityID']);

                            // Assert that we only support SAML2
                            assert.ok(result['md:EntityDescriptor']);
                            assert.ok(result['md:EntityDescriptor']['md:SPSSODescriptor']);
                            assert.ok(result['md:EntityDescriptor']['md:SPSSODescriptor'][0]);
                            assert.equal(result['md:EntityDescriptor']['md:SPSSODescriptor'][0]['$']['protocolSupportEnumeration'], 'urn:oasis:names:tc:SAML:2.0:protocol');

                            // Assert our Service Provider data is correct
                            assert.ok(result['md:EntityDescriptor']['md:SPSSODescriptor'][0]['md:KeyDescriptor']);
                            assert.ok(result['md:EntityDescriptor']['md:SPSSODescriptor'][0]['md:KeyDescriptor'][0]);
                            var keyDescriptor = result['md:EntityDescriptor']['md:SPSSODescriptor'][0]['md:KeyDescriptor'][0];
                            assert.ok(keyDescriptor['ds:KeyInfo']);
                            assert.ok(keyDescriptor['ds:KeyInfo'][0]);
                            assert.equal(keyDescriptor['ds:KeyInfo'][0]['ds:KeyName'][0], configUpdate['oae-authentication/shibboleth/spCertificateSubjectName']);
                            assert.equal(keyDescriptor['ds:KeyInfo'][0]['ds:X509Data'][0]['ds:X509SubjectName'][0], 'CN=' + configUpdate['oae-authentication/shibboleth/spCertificateSubjectName']);
                            assert.equal(keyDescriptor['ds:KeyInfo'][0]['ds:X509Data'][0]['ds:X509Certificate'][0], configUpdate['oae-authentication/shibboleth/spCertificate']);

                            // Assert we're handing out the correct url where users should be redirected towards
                            assert.ok(result['md:EntityDescriptor']['md:SPSSODescriptor'][0]['md:AssertionConsumerService']);
                            assert.ok(result['md:EntityDescriptor']['md:SPSSODescriptor'][0]['md:AssertionConsumerService'][0]);
                            var assertionConsumerService = result['md:EntityDescriptor']['md:SPSSODescriptor'][0]['md:AssertionConsumerService'][0];
                            var redirectUrl = 'https://' + global.oaeTests.tenants.localhost.host + '/api/auth/shibboleth/callback';
                            assert.equal(assertionConsumerService['$']['Location'], redirectUrl);
                            assert.equal(assertionConsumerService['$']['Binding'], 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST');

                            // Assert we're not handing out our private key somehow
                            assert.strictEqual(body.indexOf(configUpdate['oae-authentication/shibboleth/spPrivateKey']), -1);

                            // Clear the shib config
                            ConfigTestUtil.clearConfigAndWait(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, _.keys(configUpdate), function(err) {
                                assert.ok(!err);

                                return done();
                            });
                        });
                    });
                }, callback);
            });
        });
    });

    describe('CAS authentication', function() {

        // Our mocked CAS server variables
        var app = null;
        var server = null;

        // A string that can be used with our mocked CAS server that will return a succesfull response
        var validTicket = null;

        /**
         * Function that will start up a mocked CAS server. The url will be configured for the `localhost` tenant
         */
        beforeEach(function(callback) {
            TestsUtil.createTestServer(function(_app, _server, _port) {
                app = _app;
                server = _server;

                validTicket = 'ticket-' + _.random(0, 10000);
                app.get('/cas/serviceValidate', function(req, res) {
                    if (req.query.ticket === validTicket) {
                        var successXml = '<cas:serviceResponse>';
                        successXml += '<cas:authenticationSuccess>';
                        successXml += '<cas:user>sg555</cas:user>';
                        successXml += '<cas:attributes>';
                        successXml += '  <cas:displayName>Simon</cas:displayName>';
                        successXml += '  <cas:email>simon@test.com</cas:email>';
                        successXml += '</cas:attributes>';
                        successXml += '</cas:authenticationSuccess>';
                        successXml += '</cas:serviceResponse>';
                        res.send(200, successXml);
                    } else {
                        res.send(401, '<cas:serviceResponse><cas:authenticationFailure>true</cas:authenticationFailure></cas:serviceResponse>');
                    }
                });

                // Setup the CAS strategy (but do not enable it just yet)
                var configUpdate = {};
                configUpdate['oae-authentication/cas/url'] = 'http://localhost:' + _port;
                configUpdate['oae-authentication/cas/mapDisplayName'] = '<%= displayName %>';
                configUpdate['oae-authentication/cas/mapEmail'] = '<%= email %>';
                ConfigTestUtil.updateConfigAndWait(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, configUpdate, function(err) {
                    assert.ok(!err);
                });

                // Wait until the authentication api has finished refreshing its strategies
                AuthenticationAPI.once(AuthenticationConstants.events.REFRESHED_STRATEGIES, function(tenant) {
                    return callback();
                });
            });
        });

        /**
         * Function that will close the mocked CAS server and clear the config values
         */
        afterEach(function(callback) {
            server.close(function(err) {
                assert.ok(!err);
                var keysToClear = [
                    'oae-authentication/cas/url',
                    'oae-authentication/cas/mapDisplayName',
                    'oae-authentication/cas/mapEmail'
                ];

                // Invoke the callback after both the config and strategies are refreshed
                callback = _.after(2, callback);

                ConfigTestUtil.clearConfigAndWait(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, keysToClear, function(err) {
                    assert.ok(!err);
                    return callback();
                });

                AuthenticationAPI.once(AuthenticationConstants.events.REFRESHED_STRATEGIES, function(tenant) {
                    return callback();
                });
            });
        });

        /**
         * Test that verifies the ticket gets validated
         */
        it('verify ticket validation', function(callback) {
            enableStrategy('cas', function(done) {
                var options = {
                    'followRedirect': false,
                    'headers': {
                        'host': global.oaeTests.tenants.localhost.host,
                        'referer': '/'
                    },
                    'method': 'GET',
                    'qs': {
                        'ticket': 'invalid-ticket'
                    },
                    'uri': 'http://' + global.oaeTests.tenants.localhost.host + '/api/auth/cas/callback'
                };

                request(options, function(err, response, body) {
                    assert.ok(!err);
                    assert.equal(response.statusCode, 302);
                    assert.equal(response.headers.location, '/?authentication=failed&reason=tampering');

                    // Try with a valid ticket
                    options.qs.ticket = validTicket;
                    options.jar = {};
                    request(options, function(err, response, body) {
                        assert.ok(!err);
                        assert.equal(response.statusCode, 302);
                        assert.equal(response.headers.location, '/me');
                        return done();
                    });
                });
            }, callback);
        });

        /**
         * Test that verifies the CAS strategy can deal with an error from the CAS server
         */
        it('verify ticket error handling', function(callback) {
            // By configuring the CAS url to something non existant, we will trigger an error in the validation step
            var configUpdate = {};
            configUpdate['oae-authentication/cas/url'] = 'http://nothing.here.local';
            ConfigTestUtil.updateConfigAndWait(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, configUpdate, function(err) {
                assert.ok(!err);
            });
            AuthenticationAPI.once(AuthenticationConstants.events.REFRESHED_STRATEGIES, function(tenant) {

                enableStrategy('cas', function(done) {
                    // Trigger a ticket validation error by attempting to log in
                    var options = {
                        'followRedirect': false,
                        'headers': {
                            'host': global.oaeTests.tenants.localhost.host,
                            'referer': '/'
                        },
                        'jar': {},
                        'method': 'GET',
                        'qs': {
                            'ticket': 'Someticket'
                        },
                        'uri': 'http://' + global.oaeTests.tenants.localhost.host + '/api/auth/cas/callback'
                    };
                    request(options, function(err, response, body) {
                        assert.ok(!err);
                        assert.equal(response.statusCode, 302);
                        assert.equal(response.headers.location, '/?authentication=error');
                        return done();
                    });
                }, callback);
            });
        });

        /**
         * Test that verifies the ticket gets validated
         */
        it('verify CAS attribute mapping', function(callback) {
            enableStrategy('cas', function(done) {
                // Log in with our CAS server
                var options = {
                    'followRedirect': false,
                    'headers': {
                        'host': global.oaeTests.tenants.localhost.host,
                        'referer': '/'
                    },
                    'jar': {},
                    'method': 'GET',
                    'qs': {
                        'ticket': validTicket
                    },
                    'uri': 'http://' + global.oaeTests.tenants.localhost.host + '/api/auth/cas/callback'
                };
                request(options, function(err, response, body) {
                    assert.ok(!err);
                    assert.equal(response.statusCode, 302);
                    assert.equal(response.headers.location, '/me');

                    // Check that the attributes were parsed correctly
                    var meOptions = {
                        'followRedirect': false,
                        'headers': {
                            'host': global.oaeTests.tenants.localhost.host,
                            'referer': '/'
                        },
                        'jar': options.jar,
                        'method': 'GET',
                        'uri': 'http://' + global.oaeTests.tenants.localhost.host + '/api/me'
                    };
                    request(meOptions, function(err, response, body) {
                        assert.ok(!err);
                        body = JSON.parse(body);
                        assert.strictEqual(body.displayName, 'Simon');
                        assert.strictEqual(body.email, 'simon@test.com');

                        return done();
                    });
                });
            }, callback);
        });
    });
});
