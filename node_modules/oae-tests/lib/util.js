/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');
var ShortId = require('shortid');
var util = require('util');

var ConfigTestUtil = require('oae-config/lib/test/util');
var Context = require('oae-context').Context;
var RestAPI = require('oae-rest');
var RestContext = require('oae-rest/lib/model').RestContext;
var RestUtil  =require('oae-rest/lib/util');
var User = require('oae-principals/lib/model').User;

/**
 * Generate a number of random users that can be used inside of tests
 *
 * @param  {RestContext}  restCtx             Standard REST Context object that contains the current tenant URL and the current user credentials
 * @param  {Number}       total               The total number of test groups that need to be created. If not provided, a single test group will be created
 * @param  {Function}     callback            Standard callback method
 * @param  {Object}       callback.err        Error object containing error code and error message
 * @param  {Object}       callback.response   Object where the keys are the user ids of the created users and the values are objects with a key 'user' that contains the user object and a key 'restContext' that contains the Rest Context object for that user
 */
var generateTestUsers = module.exports.generateTestUsers = function(restCtx, total, callback) {
    total = total || 1;
    var createdUsers = {};

    var userCreated = function(err, userObj, username) {
        if (err) {
            return callback({'code': 500, 'msg': 'An error occured whilst creating random test users'});
        }
        createdUsers[userObj.id] = {
            'user': userObj,
            'restContext': new RestContext(restCtx.host, username, 'password', restCtx.hostHeader)
        };
        if (_.keys(createdUsers).length === total) {
            callback(null, createdUsers);
        }
    };

    var createUsers = function() {
        var _createUser = function() {
            var username = generateTestUserId('random-user');
            var displayName = generateTestGroupId('random-user');
            RestAPI.User.createUser(restCtx, username, 'password', displayName, null, function(err, userObj) {
                userCreated(err, userObj, username);
            });
        };
        for (var u = 0; u < total; u++) {
            _createUser();
        }
    };

    // We first have to make sure that the admin creating the users is logged in, otherwise the asynchronous
    // nature will confuse the cookie jar management in OAE Rest
    if (!restCtx.cookieJar) {
        RestAPI.User.getMe(restCtx, function(err) {
            if (err) {
                callback(err);
            } else {
                createUsers();
            }
        });
    } else {
        createUsers();
    }
};

/**
 * Generate a number of random groups that can be used inside of tests
 *
 * @param  {RestContext}  restCtx             Standard REST Context object that contains the current tenant URL and the current user credentials
 * @param  {Number}       total               The total number of test groups that need to be created. If not provided, a single test group will be created
 * @param  {Function}     callback            Standard callback method
 * @param  {Object}       callback.err        Error object containing error code and error message
 * @param  {Object}       callback.response   Object where the keys are the group ids of the created groups and the values are the actual group objects
 */
var generateTestGroups = module.exports.generateTestGroups = function(restCtx, total, callback) {
    total = total || 1;
    var createdGroups = {};

    var groupCreated = function(err, groupObj) {
        if (err) {
            return callback({'code': 500, 'msg': 'An error occured whilst creating random test groups'});
        }
        createdGroups[groupObj.id] = groupObj;
        if (_.keys(createdGroups).length === total) {
            callback(null, createdGroups);
        }
    };

    // We first have to make sure that the user creating the groups is logged in, otherwise the asynchronous
    // nature will confuse the cookie jar management in OAE Rest
    RestAPI.User.getMe(restCtx, function(err, meObj) {
        if (err) {
            return callback({'code': 500, 'msg': 'An error occured whilst trying to log in the user'});
        }
        for (var g = 0; g < total; g++) {
            RestAPI.Group.createGroup(restCtx, generateTestGroupId('random-title'), generateTestGroupId('random-description'), 'public', 'yes', [], [], groupCreated);
        }
    });
};

/**
 * Create a new tenant with a tenant administrator user.
 *
 * @param  {String}        tenantAlias                     The tenant alias of the tenant to create
 * @param  {String}        tenantHost                      The host of the tenant to create
 * @param  {Function}      callback                        Invoked when the process completes
 * @param  {Object}        callback.err                    An error that occurred, if any
 * @param  {Object}        callback.tenant                 The tenant data object
 * @param  {RestContext}   callback.tenantAdminRestContext The rest context that can be used to make requests on behalf of the tenant administrator
 */
var createTenantWithAdmin = module.exports.createTenantWithAdmin = function(tenantAlias, tenantHost, callback) {
    var adminCtx = createGlobalAdminRestContext();
    RestAPI.Tenant.createTenant(adminCtx, tenantAlias, tenantAlias, tenantHost, function(err, tenant) {
        if (err) {
            return callback(err);
        }

        // Disable recaptcha so we can create a user
        ConfigTestUtil.updateConfigAndWait(adminCtx, tenantAlias, 'oae-principals/recaptcha/enabled', false, function(err) {
            if (err) {
                return callback(err);
            }

            // Create the user and make them admin
            var anonymousCtx = createTenantRestContext(tenantHost);
            RestAPI.User.createUser(anonymousCtx, 'administrator', 'administrator', 'Tenant Administrator', null, function(err, tenantAdmin) {
                if (err) {
                    return callback(err);
                }

                RestAPI.User.setTenantAdmin(adminCtx, tenantAdmin.id, true, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Re-enable captcha
                    var tenantAdminRestCtx = createTenantAdminRestContext(tenantHost);
                    ConfigTestUtil.updateConfigAndWait(tenantAdminRestCtx, null, 'oae-principals/recaptcha/enabled', true, function(err) {
                        if (err) {
                            return callback(err);
                        }

                        return callback(null, tenant, tenantAdminRestCtx);
                    });
                });
            });
        });
    });
};

/**
 * Create a group hierarchy, starting from the 0th group in the array as the highest level down to the last group as the lowest level.
 *
 * @param  {Context}     restCtx         The context of the REST request
 * @param  {String[]}    groupIds        An array of group IDs that describe the hierarchy to create. If there are 0 or 1 groupIds, this method effectively does nothing. If there are 2 groupIds, the group at groupId[1] becomes a member of groupId[0]. And so on.
 * @param  {String}      role            The role to assign to the group membership
 * @param  {Function}    callback        Standard callback method
 * @param  {Object}      callback.err    An error that occurred, if any
 */
var generateGroupHierarchy = module.exports.generateGroupHierarchy = function(restCtx, groupIds, role, callback) {
    if (groupIds.length <= 1) {
        return callback();
    }

    var membershipChanges = {};
    membershipChanges[groupIds[1]] = role;

    RestAPI.Group.setGroupMembers(restCtx, groupIds[0], membershipChanges, function(err) {
        if (err) {
            return callback(err);
        }

        // Recurse, removing the first group
        generateGroupHierarchy(restCtx, groupIds.slice(1), role, callback);
    });

};

/**
 * Generate a random user id that can be used inside of tests. We use a double Math.random randomizer to make
 * the collision chances even smaller.
 *
 * @param  {String}     seed        String that should be used as the first part of the generated user id
 * @return {String}                 Random user id
 */
var generateTestUserId = module.exports.generateTestUserId = function(seed) {
    return (seed || 'user') + '-' + ShortId.generate();
};

/**
 * Generate a random group id that can be used inside of tests. We use a double Math.random randomizer to make
 * the collision chances even smaller.
 *
 * @param  {String}     seed        String that should be used as the first part of the generated group id
 * @return {String}                 Random group id
 */
var generateTestGroupId = module.exports.generateTestGroupId = function(seed) {
    return (seed || 'group') + '-' + ShortId.generate();
};

/**
 * Create a Rest Context object that represents an anonymous or logged in user and can be used for tests
 *
 * @param  {String}         host             Tenant URL for the tenant on which we want to perform a REST call
 * @param  {String}         [username]       Username for the user performing the request. This should be null for an anonymous user
 * @param  {String}         [password]       Password for the user performing the request. This should be null for an anonymous user
 * @return {RestContext}                     Rest Context object that represents the anonymous or logged in user user on the provided tenant
 */
var createTenantRestContext = module.exports.createTenantRestContext = function(host, username, password) {
    return new RestContext('http://localhost:2001', username, password, host);
};

/**
 * Create a Rest Context object that represents an admin user for a teant and can be used for tests
 *
 * @param  {String}         host             Tenant URL for the tenant on which we want to perform a REST call
 * @return {RestContext}                     Rest Context object that represents the admin user on the provided tenant
 */
var createTenantAdminRestContext = module.exports.createTenantAdminRestContext = function(host) {
    return createTenantRestContext(host, 'administrator', 'administrator');
};

/**
 * Create a Rest Context object that represents an anonymous or logged in user on the global admin server
 * and can be created for tests
 *
 * @param  {String}         [username]       Username for the user performing the request. This should be null for an anonymous user.
 * @param  {String}         [password]       Password for the user performing the request. This should be null for an anonymous user
 * @return {RestContext}                     Rest Context object that represents the anonymous or logged in user on the global admin server
 */
var createGlobalRestContext = module.exports.createGlobalRestContext = function(username, password) {
    return new RestContext('http://localhost:2000', username, password);
};

/**
 * Create a Rest Context object that represents the admin user on the global admin server and can be created
 * for tests
 *
 * @return {RestContext}                     Rest Context object that represents the global admin user on the provided tenant
 */
var createGlobalAdminRestContext = module.exports.createGlobalAdminRestContext = function() {
    return createGlobalRestContext('administrator', 'administrator');
};

/**
 * Create an API Context object that represents a tenant admin of the given tenant.
 *
 * @param  {Tenant}    tenant  The tenant for which the context should be an administrator
 * @return {Context}           The api context that represents an administrator of the tenant
 */
var createTenantAdminContext = module.exports.createTenantAdminContext = function(tenant) {
    return new Context(tenant, new User(tenant.alias, 'u:' + tenant.alias + ':admin', 'Tenant Administrator', {'isTenantAdmin': true}));
};

/**
 * Create an API Context object that represents a global administrator.
 *
 * @return {Context}           The api context that represents an administrator of the tenant
 */
var createGlobalAdminContext = module.exports.createGlobalAdminContext = function() {
    var globalTenant = global.oaeTests.tenants.global;
    return new Context(globalTenant, new User(globalTenant.alias, 'u:' + globalTenant.alias + ':admin', 'Global Administrator', {'isGlobalAdmin': true}));
};

/**
 * Generate a string that contains `nrOfWords` words.
 * The words are random alphanumerical strings of 12 characters.
 *
 * @param  {Number} nrOfWords The amount of words you wish to generate.
 * @return {String}           A randomly generated string with `nrOfWords` in it.
 */
var generateRandomText = module.exports.generateRandomText = function(nrOfWords) {
    var alphabet = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
    var text = [];
    for (var i = 0; i < nrOfWords; i++) {
        var wordLength = 12;
        var word = '';
        for (var l = 0; l < wordLength; l++) {
            var letter = Math.floor(Math.random() * alphabet.length);
            word += alphabet[letter];
        }
        text.push(word);
    }
    return text.join(' ');
};


/**
 * Set up 2 public tenants and 2 private tenants, each with a public, loggedin and private set of users.
 * The resulting model looks like:
 *
 * ```
 *  {
 *      "publicTenant": {
 *          "tenant": <Tenant>,
 *          "anonymousRestCtx": <RestContext>,
 *          "adminRestCtx": <RestCOntext> (of the tenant admin),
 *          "publicUser": {
 *              "user": <User>,
 *              "restCtx": <RestContext>
 *          },
 *          "loggedinUser": { ... },
 *          "privateUser": { ... },
 *          "publicGroup": <Group>,
 *          "loggedinGroup": <Group>,
 *          "privateGroup": <Group>
 *      },
 *      "publicTenant1": { ... },
 *      "privateTenant": { ... },
 *      "privateTenant1": { ... }
 *  }
 * ```
 *
 * @param  {Function}   Invoked when all the entities are set up
 * @throws {Error}      An assertion error is thrown if something does not get created properly
 */
var setupMultiTenantPrivacyEntities = module.exports.setupMultiTenantPrivacyEntities = function(callback) {
    _createMultiPrivacyTenants(function(publicTenant, publicTenant1, privateTenant, privateTenant1) {
        _setupTenant(publicTenant, function() {
            _setupTenant(publicTenant1, function() {
                _setupTenant(privateTenant, function() {
                    _setupTenant(privateTenant1, function() {
                        return callback(publicTenant, publicTenant1, privateTenant, privateTenant1);
                    });
                });
            });
        });
    });
};


/**
 * Set up tenants of all privacies
 *
 * @param  {Function}   callback                Invoked when all entities are setup
 * @param  {Tenant}     callback.publicTenant   A public tenant
 * @param  {Tenant}     callback.publicTenant1  Another public tenant
 * @param  {Tenant}     callback.privateTenant  A private tenant
 * @param  {Tenant}     callback.privateTenant1 Another private tenant
 * @throws {Error}                              An assertion error is thrown if something does not get created properly
 * @api private
 */
var _createMultiPrivacyTenants = function(callback) {
    var randomId = ShortId.generate();
    var publicTenantAlias = util.format('public-%s', randomId);
    var publicTenant1Alias = util.format('public1-%s', randomId);
    var privateTenantAlias = util.format('private-%s', randomId);
    var privateTenant1Alias = util.format('private1-%s', randomId);

    _createPublicTenant(publicTenantAlias, function(tenant, tenantAdminRestCtx) {
        var publicTenant = {'tenant': tenant, 'adminRestCtx': tenantAdminRestCtx, 'anonymousRestCtx': createTenantRestContext(tenant.host)};
        _createPublicTenant(publicTenant1Alias, function(tenant, tenantAdminRestCtx) {
            var publicTenant1 = {'tenant': tenant, 'adminRestCtx': tenantAdminRestCtx, 'anonymousRestCtx': createTenantRestContext(tenant.host)};
            _createPrivateTenant(privateTenantAlias, function(tenant, tenantAdminRestCtx) {
                var privateTenant = {'tenant': tenant, 'adminRestCtx': tenantAdminRestCtx, 'anonymousRestCtx': createTenantRestContext(tenant.host)};
                _createPrivateTenant(privateTenant1Alias, function(tenant, tenantAdminRestCtx) {
                    var privateTenant1 = {'tenant': tenant, 'adminRestCtx': tenantAdminRestCtx, 'anonymousRestCtx': createTenantRestContext(tenant.host)};
                    return callback(publicTenant, publicTenant1, privateTenant, privateTenant1);
                });
            });
        });
    });
};


/**
 * Prepare the given tenant according to the spec from #setupMultiTenantPrivacyEntities
 *
 * @param  {Tenant}     tenant          The tenant to setup
 * @param  {Function}   callback        Invoked when all the entities are set up
 * @throws {Error}                      An assertion error is thrown if something does not get created properly
 * @api private
 */
var _setupTenant = function(tenant, callback) {
    _createMultiPrivacyUsers(tenant.adminRestCtx, function(publicUser, loggedinUser, privateUser) {
        tenant.publicUser = publicUser;
        tenant.loggedinUser = loggedinUser;
        tenant.privateUser = privateUser;
        _createMultiPrivacyGroups(tenant, function(publicGroup, loggedinGroup, privateGroup) {
            tenant.publicGroup = publicGroup;
            tenant.loggedinGroup = loggedinGroup;
            tenant.privateGroup = privateGroup;
            return callback();
        });
    });
};

/**
 * Set up users of all privacies using the given rest context.
 *
 * @param  {RestContext}    restCtx         The rest context to use
 * @param  {Function}       callback        Invoked when all the entities are set up
 * @throws {Error}                          An assertion error is thrown if something does not get created properly
 * @api private
 */
var _createMultiPrivacyUsers = function(restCtx, callback) {
    _createUserWithVisibility(restCtx, 'public', function(publicUser) {
        _createUserWithVisibility(restCtx, 'loggedin', function(loggedinUser) {
            _createUserWithVisibility(restCtx, 'private', function(privateUser) {
                return callback(publicUser, loggedinUser, privateUser);
            });
        });
    });
};

/**
 * Create a user with the specified visibility
 *
 * @param  {RestContext}    restCtx             The rest context to use
 * @param  {String}         visibility          The visibility of the user
 * @param  {Function}       callback            Invoked when all the entities are set up
 * @param  {User}           callback.user       The created user
 * @param  {RestContext}    callback.restCtx    The RestContext of the user
 * @throws {Error}                              An assertion error is thrown if something does not get created properly
 * @api private
 */
var _createUserWithVisibility = function(restCtx, visibility, callback) {
    var randomId = util.format('%s-%s', visibility, ShortId.generate());
    var username = 'username-' + randomId;
    var password = 'password-' + randomId;
    var displayName = 'displayName-' + randomId;
    var publicAlias = 'publicAlias-' + randomId;
    RestAPI.User.createUser(restCtx, username, password, displayName, {'visibility': visibility, 'publicAlias': publicAlias}, function(err, user) {
        assert.ok(!err);
        return callback({'user': user, 'restCtx': createTenantRestContext(restCtx.hostHeader, username, password)});
    });
};

/**
 * Set up groups of all privacies using the given rest context.
 *
 * @param  {Tenant}         tenant          The tenant on which to create the groups
 * @param  {Function}       callback        Invoked when all the entities are set up
 * @throws {Error}                          An assertion error is thrown if something does not get created properly
 * @api private
 */
var _createMultiPrivacyGroups = function(tenant, callback) {
    _createGroupWithVisibility(tenant, 'public', tenant.publicUser.user.id, function(publicGroup) {
        _createGroupWithVisibility(tenant, 'loggedin', tenant.loggedinUser.user.id, function(loggedinGroup) {
            _createGroupWithVisibility(tenant, 'private', tenant.privateUser.user.id, function(privateGroup) {
                return callback(publicGroup, loggedinGroup, privateGroup);
            });
        });
    });
};

/**
 * Create a group with the specified visibility.
 * The group will be created by the tenant admin and an extra member can be specified
 * with the `memberPrincipalId` parameter.
 *
 * @param  {Tenant}         tenant              The tenant on which to create the groups
 * @param  {String}         visibility          The visibility of the user
 * @param  {String}         memberPrincipalId   The ID of the principal which should be added as a member.
 * @param  {Function}       callback            Invoked when all the entities are set up
 * @param  {User}           callback.group      The created group
 * @throws {Error}                              An assertion error is thrown if something does not get created properly
 * @api private
 */
var _createGroupWithVisibility = function(tenant, visibility, memberPrincipalId, callback) {
    var randomId = util.format('%s-%s', visibility, ShortId.generate());
    var displayName = 'displayName-' + randomId;
    var description = 'description-' + randomId;
    RestAPI.Group.createGroup(tenant.adminRestCtx, displayName, description, visibility, 'request', [], [memberPrincipalId], function(err, newGroup) {
        assert.ok(!err);
        return callback(newGroup);
    });
};

/**
 * Create a private tenant with the given alias
 *
 * @param  {String}         tenantAlias                 The alias of the tenant
 * @param  {Function}       callback                    Invoked when the tenant is created
 * @param  {Tenant}         callback.tenant             The created tenant object
 * @param  {RestContext}    callback.tenantAdminRestCtx The rest context of the tenant administrator
 * @throws {Error}                                      An assertion error is thrown if there is an issue creating the tenant
 * @api private
 */
var _createPrivateTenant = function(tenantAlias, callback) {
    _createPublicTenant(tenantAlias, function(tenant, tenantAdminRestCtx) {
        // Only global admins can update tenant privacy, so use that
        ConfigTestUtil.updateConfigAndWait(createGlobalAdminRestContext(), tenant.alias, 'oae-tenants/tenantprivacy/tenantprivate', true, function(err) {
            assert.ok(!err);
            return callback(tenant, tenantAdminRestCtx);
        });
    });
};

/**
 * Create a public tenant with the given alias
 *
 * @param  {String}         tenantAlias                 The alias of the tenant
 * @param  {Function}       callback                    Invoked when the tenant is created
 * @param  {Tenant}         callback.tenant             The created tenant object
 * @param  {RestContext}    callback.tenantAdminRestCtx The rest context of the tenant administrator
 * @throws {Error}                                      An assertion error is thrown if there is an issue creating the tenant
 * @api private
 */
var _createPublicTenant = function(tenantAlias, callback) {
    createTenantWithAdmin(tenantAlias, tenantAlias, function(err, tenant, tenantAdminRestCtx) {
        assert.ok(!err);
        return callback(tenant, tenantAdminRestCtx);
    });
};
