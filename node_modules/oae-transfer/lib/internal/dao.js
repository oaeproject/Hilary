/*!
 * Copyright 2017 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var async = require('async');
var codeGenerator = require('password-generator');
var util = require('util');

var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var Cassandra = require('oae-util/lib/cassandra');
var ContentConstants = require('oae-content/lib/constants').ContentConstants;
var ContentDAO = require('oae-content/lib/internal/dao.content');
var DiscussionsConstants = require('oae-discussions/lib/constants').DiscussionsConstants;
var DiscussionsDAO = require('oae-discussions/lib/internal/dao');
var FoldersConstants = require('oae-folders/lib/constants').FoldersConstants;
var FoldersDAO = require('oae-folders/lib/internal/dao');
var GroupAPI = require('oae-principals/lib/api.group');
var LibraryAPI = require('oae-library'); 
var MeetingsConstants = require('oae-jitsi/lib/constants').MeetingsConstants;
var MeetingsDAO = require('oae-jitsi/lib/internal/dao');
var PrincipalsAPI = require('oae-principals/lib/api.user');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');

var Transfer = require('oae-transfer/lib/model').Transfer;

// Number of seconds in a day
const SECONDS_IN_A_DAY = 24 * 60 * 60;

/** 
 * PUBLIC FUNCTIONS 
 */

/**
 * Create a new transfer and return it
 *
 * @param  {Object}         ctx                     Context
 * @param  {String}         originalUserId          The account identifier from which the data will be transferred
 * @param  {String}         originalEmail           The email of the account from which the data will be transferred
 * @param  {String}         targetEmail             The email of the account to which the data will be transferred
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {transfer}       callback.transfer       The transfer that was created
 */
var initiateTransfer = module.exports.initiateTransfer = function (ctx, originalUserId, originalEmail, targetEmail, callback) { 
    
    var code = _initiateTransferCode();

    // Initialize TTL of the transfer
    _getTTLTransfer(ctx, function (err, TTL) {
        if (err) {
            return callback(err);
        }
        var finalTTL = TTL * SECONDS_IN_A_DAY;

        // Create transfer
        Cassandra.runQuery('INSERT INTO "TransferById" ("originalUserId", "code", "originalEmail", "targetEmail") VALUES (?, ?, ?, ?) USING TTL ?', [originalUserId, code, originalEmail, targetEmail, finalTTL], function(err) {
            if (err) {
                return callback(err);
            }
            Cassandra.runQuery('INSERT INTO "TransferByEmail" ("originalEmail", "code", "originalUserId", "targetEmail") VALUES (?, ?, ?, ?) USING TTL ?', [originalEmail, code, originalUserId, targetEmail, finalTTL], function(err) {
                if (err) {
                    return callback(err);
                }

                var transfer = new Transfer(originalUserId, code, originalEmail, targetEmail, null, null, 'ongoing');

                return callback(null, transfer);
            });
        });
    });
};

/**
 * Start the transfer.
 *
 * @param  {Context}        ctx                         Standard context object containing the current user and the current tenant
 * @param  {String}         originalEmail               The email of the account from which the data will be transferred
 * @param  {String}         code                        The code used by the user to secure the transfer
 * @param  {String}         targetEmail                 The email of the account to which the data will be transferred
 * @param  {String}         transfer                    The transfer
 * @param  {String}         targetUserId                The identifier of the account to which the data will be transferred
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error that occurred, if any
 * @param  {members}        callback.members            All the members of user resource
 */
 var completeTransfer = module.exports.completeTransfer = function (ctx, originalEmail, code, targetEmail, targetUserId, transfer, callback) {
    
    // Get AuthzRoles 
    Cassandra.runQuery('SELECT * FROM "AuthzRoles" WHERE "principalId" = ?', [transfer.originalUserId], function(err, authzRoles) {
        if (err) {
            return callback(err);
        }

        // If there is no data to transfer, cancel it
        if (_.isEmpty(authzRoles)) {
            err = {'code': 400, 'msg': 'The user has no roles to transfer'};
            return callback(err);
        }

        // Create queries to insert and delete authzRoles and authzMembers
        _transferRoles(ctx, authzRoles, targetUserId, transfer.originalUserId, function(err, newAuthzRoles) {
            if (err) {
                return callback(err);
            }

            // Delete the transfer in the table "Transfer"
            cancelTransfer(originalEmail, code, transfer.originalUserId, function (err) {
                if (err) {
                    return callback(err);
                }

                // Record the transfer
                _recordTransfer(originalEmail, transfer.originalUserId, targetEmail, targetUserId, function (err, recordedTransfer) {
                    if (err) {
                        return callback(err);
                    }
                    if (!recordedTransfer) {
                        return callback({'code': 400, 'msg': 'A problem happened recording the transfer'});
                    }

                    if (_.isEmpty(newAuthzRoles)) {
                        // return callback
                        return callback(null); 
                    } else {

                        // Get id originalEmail
                        PrincipalsDAO.getUserIdsByEmails([originalEmail], function(err, originalUserId) {
                            if (err) {
                                return callback(err);
                            } 

                            // Found all members related to this resource to then send them an email
                            _getMembers(ctx, newAuthzRoles, targetUserId, originalUserId, function (err, members) {
                                if (err) {
                                    return callback(err);
                                } 

                                return callback(null, members); 
                            });
                        }); 
                    }
                });
            });
        }); 
    });
};

/**
 * Get a transfer data by an id.
 *
 * @param  {String}         originalUserId          The account identifier from which the data will be transferred
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {transfer}       callback.transfer       User's transfer
 */
var getTransferById = module.exports.getTransferById = function (originalUserId, callback) {
    Cassandra.runQuery('SELECT * FROM "TransferById" WHERE "originalUserId" = ?', [originalUserId], function(err, transfer) {
        if (err) {
            return callback(err);
        }
        return callback(null, transfer[0]);
    });
};

/**
 * Get a transfer data by an email and a code.
 *
 * @param  {String}         originalEmail           The email of the account from which the data will be transferred
 * @param  {String}         code                    The code used by the user to secure the transfer
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {transfer}       callback.transfer       User's transfer
 */
var getTransferByEmail = module.exports.getTransferByEmail = function (originalEmail, code, callback) {
    Cassandra.runQuery('SELECT * FROM "TransferByEmail" WHERE "originalEmail" = ? AND "code" = ?', [originalEmail, code], function(err, transfer) {
        if (err) {
            return callback(err);
        }
        return callback(null, transfer[0]);
    });
};

/**
 * Delete a transfer data by an email.
 *
 * @param  {String}         code                    The code used by the user to secure the transfer
 * @param  {String}         originalEmail           The email of the account from which the data will be transferred
 * @param  {String}         originalUserId          The account identifier from which the data will be transferred
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 */
var cancelTransfer = module.exports.cancelTransfer = function (originalEmail, code, originalUserId, callback) {
    Cassandra.runQuery('DELETE FROM "TransferByEmail" WHERE "originalEmail" = ? AND "code" = ?', [originalEmail, code], function(err, result) {
        if (err) {
            return callback(err);
        }
        Cassandra.runQuery('DELETE FROM "TransferById" WHERE "originalUserId" = ?', [originalUserId], function(err, result) {
            if (err) {
                return callback(err);
            } 
            return callback();
        });
    });
};

/**
 * get recorded transfer.
 *
 * @param  {String}         originalUserId          The account identifier from which the data will be transferred
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 */
var getRecordedTransfer = module.exports.getRecordedTransfer = function (originalUserId, callback) {
    Cassandra.runQuery('SELECT * FROM "RecordedTransfer" WHERE "originalUserId" = ?', [originalUserId], function (err, recordedTransfer) {
        if (err) {
            return callback(err);
        } 
        return callback(null, recordedTransfer[0]);
    });
};

/**
 * PRIVATE FUNCTIONS
 */

/**
 * Record the transfer.
 *
 * @param  {String}         originalEmail               The email of the account from which the data will be transferred
 * @param  {String}         originalUserId              The account identifier from which the data will be transferred
 * @param  {String}         targetEmail                 The email of the account to which the data will be transferred
 * @param  {String}         targetUserId                The identifier of the account to which the data will be transferred
 *
 * @returns recorded transfer
 * @api private used to record a transter
 */
var _recordTransfer = function(originalEmail, originalUserId, targetEmail, targetUserId, callback) {

    // Insert into the table the recorded transfer
    Cassandra.runQuery('INSERT INTO "RecordedTransfer" ("originalEmail", "originalUserId", "targetEmail", "targetUserId") VALUES (?, ?, ?, ?)', [originalEmail, originalUserId, targetEmail, targetUserId], function(err) {
        if (err) {
            return callback(err);
        }
        var recordedTransfer = new Transfer(originalUserId, null, originalEmail, targetEmail, targetUserId, null, null);

        return callback(null, recordedTransfer);
    });
};

/**
 * Update roles and Get array of roles modified
 *  
 * @param {Array}       authzRoles          An array of an object composed of the principal id, a resource and his permission on it      
 * @param {String}      targetUserId        The identifier of the account to which the data will be transferred
 * @param {String}      originalUserId      The account identifier from which the data will be transferred
 * @param {Function}    callback                
 * @param {Array}       _userHashes
 *
 * @returns array of roles modified
 * @api private used to make the transter
 */
var _transferRoles = function(ctx, authzRoles, targetUserId, originalUserId, callback, _userHashes) {

    _userHashes = _userHashes || []
    
    // If no more authzroles, return list of modified roles
    if (_.isEmpty(authzRoles)) {
        return callback(null, _userHashes);
    }

    var authzRole = authzRoles.shift();
    var memberToUpdate = {};
    var newAuthzRoles = {};
    memberToUpdate[targetUserId] = authzRole.role;
    memberToUpdate[originalUserId] = false;

    _doUpdate(authzRole, targetUserId, originalUserId, function (err, doUpdate) {
        if (err) {
            return callback(err);
        }

        if(doUpdate) {

            // Update target user's role && remove origin user's role
            AuthzAPI.updateRoles(authzRole.resourceId, memberToUpdate, function(err, usersToInvalidate) {
                if (err) {
                    return callback(err);
                }

                // Insert to library
                _transferResourceLibrary(ctx, authzRole.resourceId, targetUserId, originalUserId, function (err, result) {
                    if (err) {
                        return callback(err);
                    }
                    newAuthzRoles['resourceId'] = authzRole.resourceId;
                    newAuthzRoles['role'] = authzRole.role;
                    newAuthzRoles['principalId'] = targetUserId;
                    _userHashes.push(newAuthzRoles);

                    return _transferRoles(ctx, authzRoles, targetUserId, originalUserId, callback, _userHashes);
                });
            });
        } else {
            return _transferRoles(ctx, authzRoles, targetUserId, originalUserId, callback, _userHashes);
        }
    });
};

/**
 * Look at the right of target and origin to make a decision about the transfer. 
 * if the target user has better permission, we don't change it
 * 
 * @param {Object} hash
 * @param {String} targetUserId         The identifier of the account to which the data will be transferred
 * @param {String} originalUserId       The account identifier from which the data will be transferred
 *
 * @returns boolean
 * @api private used to make the transter
 */
var _doUpdate = function(hash, targetUserId, originalUserId, callback) {

    AuthzAPI.getAuthzMembers(hash.resourceId, null, null, function(err, members) {
        if (err) {
            return callback(err);
        }

        var userOriginRole = _.find(members, function(obj) {
          return obj.id == originalUserId;
        });

        var userTargetRole = _.find(members, function(obj) {
          return obj.id == targetUserId;
        });

        if (!userTargetRole) {
            return callback(null, true);
        }

        _isRoleHigherThan(userTargetRole.role, userOriginRole.role, function(isRoleHighterThan) {
            if (isRoleHighterThan) {
                return callback(null, true);
            }
            return callback(null, false);
        });
    });                     
};

/**
 * Determine if userTargetRole is an higher right than userOriginRole
 * 
 * @param {String} userTargetRole       The user role 
 * @param {String} userOriginRole       The user role
 *
 * @returns boolean
 * @api private used to make the transter
 */
var _isRoleHigherThan = function(userTargetRole, userOriginRole, callback) {

    var originRole = 5;
    var targetRole = 5;

    switch (userTargetRole) {
        case AuthzConstants.role.MANAGER:
            targetRole = 1;
            break;
        case AuthzConstants.role.MEMBER:
            targetRole = 2;
            break;
        case AuthzConstants.role.EDITOR:
            targetRole = 3;
            break;
        case AuthzConstants.role.VIEWER:
            targetRole = 4;
            break;
    }

    switch (userOriginRole) {
        case AuthzConstants.role.MANAGER:
            originRole = 1;
            break;
        case AuthzConstants.role.MEMBER:
            originRole = 2;
            break;
        case AuthzConstants.role.EDITOR:
            originRole = 3;
            break;
        case AuthzConstants.role.VIEWER:
            originRole = 4;
            break;
    }

    if (targetRole <= originRole) {
        return callback(false);
    } else {
        return callback(true);
    }
};

/**
 * Generate a new 20 caracters code
 *      Parametters : length, memorable, pattern, prefix
 * 
 * @returns transferCode
 * @api private
 */
var _initiateTransferCode = function() {
    return codeGenerator(20, false);
};

/**
 * Get managers from authzroles
 * 
 * @param {Object}  ctx                 Context
 * @param {Array}   authzRoles          An array of an object composed of the principal id, a resource and his permission on it
 * @param {String}  targetUserId        The identifier of the account to which the data will be transferred
 * @param {String}  originalUserId      The account identifier from which the data will be transferred
 *
 * @returns managers
 * @api private
 */
var _getMembers = function (ctx, authzRoleHashes, targetUserId, originalUserId, callback, listMembers) {

    var listMembers = listMembers || [];
    // Return when there are no more folder in the array
    if (!authzRoleHashes || _.isEmpty(authzRoleHashes)) {
        return callback(null, listMembers);
    } 
    var hash = authzRoleHashes.shift();

    // Found all members related to this resource and put then into 'members'
    AuthzAPI.getAuthzMembers(hash.resourceId, null, null, function(err, members) {
        if (err) {
            return callback(err);
        }

        async.eachSeries(members, function(res, callback) {

            // Get the user
            Cassandra.runQuery('SELECT * FROM "Principals" WHERE "principalId" = ?', [res.id], function (err, member) {
                if (err) {
                    return callback(err);
                } 

                // Get resource
                _getDocument(ctx, hash.resourceId, function (err, element) {
                    if (err) {
                        return callback(err);
                    }
                    
                    if (res.id !== targetUserId) {
                        member = _.chain(member).map(Cassandra.rowToHash)._wrapped[0];
                        listMembers.push([{'profile': member}, {'resource': element}]);
                    }
                    callback();
                }); 
            });
        }, function(err) {
            if (err) {
              return callback(err);
            }
            return _getMembers(ctx, authzRoleHashes, targetUserId, originalUserId, callback, listMembers);
        });
    });   
};

/**
 * Get the name of the resource by its id 
 * take advantage of the differentiation of data type to modify the library
 * 
 * @param {Object} ctx                  Context 
 * @param {String} resourceId           The id of the resource to transfer
 * @param {String} targetUserId         The identifier of the account to which the data will be transferred
 * @param {String} originalUserId       The account identifier from which the data will be transferred
 *
 * @returns nothing
 * @api private
 */
var _transferResourceLibrary = function (ctx, resourceId, targetUserId, originalUserId, callback) {

    // Get resource
    _getDocument(ctx, resourceId, function (err, resource) {
        if (err) {
            return callback(err);
        }

        var resourceType = resource.id.split(':')[0];
        
        var libraryIndexName = '';

        switch (resourceType) {
            case 'c':
                libraryIndexName = ContentConstants.library.CONTENT_LIBRARY_INDEX_NAME;
                break;
            case 'f':
                libraryIndexName = FoldersConstants.library.FOLDERS_LIBRARY_INDEX_NAME;
                break;
            case 'd':
                libraryIndexName = DiscussionsConstants.library.DISCUSSIONS_LIBRARY_INDEX_NAME;
                break;
            case 'm':
                libraryIndexName = MeetingsConstants.library.MEETINGS_LIBRARY_INDEX_NAME;
                break;
        }

        // Insert to library 
        _addOnLibrary(resource, targetUserId, libraryIndexName, function(err) {
            if (err) {
                return callback(err);
            }

            // Remove to library 
            _removeFromLibrary(resource, originalUserId, libraryIndexName, function(err) {
                if (err) {
                    return callback(err);
                }
                return callback();                
            }); 
        }); 
    }); 
};

/**
 * Get the name of the resource by its id 
 * take advantage of the differentiation of data type to modify the library
 * 
 * @param {Object} ctx              Context
 * @param {String} resourceId       The id of the resource to transfer
 *
 * @returns resource
 * @api private
 */
var _getDocument = function (ctx, resourceId, callback) {

    var resourceType = resourceId.split(':')[0];

    switch (resourceType) {
        case 'c':
            ContentDAO.getContent(resourceId, function(err, result) {
                if (err) {
                    return callback(err);
                }
                return callback(null, result);        
            });
            break;
        case 'g':
            _getFoldersByGroupIds(ctx, resourceId, function(err, result) {
                if (err) {
                    return callback(err);
                }
                return callback(null, result);                
            }); 
            break;
        case 'd':
            DiscussionsDAO.getDiscussion(resourceId, function(err, result) {
                if (err) {
                    return callback(err);
                }
                return callback(null, result);                
            }); 
            break;
        case 'm':
            MeetingsDAO.getMeeting(resourceId, function(err, result) {
                if (err) {
                    return callback(err);
                }
                return callback(null, result);                
            });
            break;
    }
};

/**
 * Get folder by group id
 * 
 * @param {Object} ctx              Context
 * @param {String} resourceId       The id of the resource to transfer
 *
 * @returns folder
 * @api private
 */
 var _getFoldersByGroupIds = function (ctx, resourceId, callback) {

    Cassandra.runQuery('SELECT * FROM "FoldersGroupId" WHERE "groupId" = ?', [resourceId], function(err, result) {

        // The resource is a group if there is no result to this query
        if (_.isEmpty(result)) {
            GroupAPI.getGroup(ctx, resourceId, function(err, group) {
                if (err) {
                    return callback(err);
                }
                return callback(null, group);
            });
        } else {
            FoldersDAO.getFolder(result[0].folderId, function(err, folder) {
                if (err) {
                    return callback(err);
                }
                return callback(null, folder);
            });
        }
    });
};

/**
 * Get the time to live transfer of a specific tenant.
 *
 * @param  {Object}         ctx                     Context to determine the time to live of a transfer code
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Error
 */
var _getTTLTransfer = function (ctx, callback) {

    var defaultTime = 1;
    var configkey = 'oae-transfer/TTL/value';

    Cassandra.runQuery('SELECT "value" FROM "Config" WHERE "tenantAlias" = ? AND "configKey" = ?', [ctx.tenant().alias, configkey], function(err, result) {
        if (err) {
            return callback(err);
        }

        if (_.isEmpty(result)) {
            return callback(null, defaultTime);
            
        } else {
            return callback(null, result[0].value);
        }
    });
};

/**
 * Insert an element to the library.
 *
 * @param  {Object}         obj                     The resource to insert into the library       
 * @param  {Object}         principalId             The user id of the library where we want to insert a resource
 * @param  {Object}         constant                The resource constant corresponding to folder, content, meeting, discussion or group
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Error
 */
var _addOnLibrary = function(obj, principalId, constant, callback) {
    var entries = [{
        'id': principalId,
        'rank': obj.lastModified,
        'resource': obj
    }];
    LibraryAPI.Index.insert(constant, entries, callback);
};

/**
 * Remove an element to the library.
 *
 * @param  {Object}         obj                     The resource to insert into the library       
 * @param  {Object}         principalId             The user id of the library where we want to insert a resource
 * @param  {Object}         constant                The resource constant corresponding to folder, content, meeting, discussion or group
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Error
 */
var _removeFromLibrary = function(obj, principalId, constant, callback) {
    var entries = [{
        'id': principalId,
        'rank': obj.lastModified,
        'resource': obj
    }];
    LibraryAPI.Index.remove(constant, entries, callback);
};
