/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var assert = require('assert');

var MQ = require('oae-util/lib/mq');

describe('MQ', function() {

    /**
     * Some options that can be used to bind to a message queue.
     */
    var purgeQueueOptions = {
        'subscribe': {
            'prefetchCount': 1
        },
        'queue': {
            'durable': false
        }
    };

    describe('#bind()', function() {

        /**
         * Verify that re-initializing the MQ doesn't invoke an error
         */
        it('verify re-initialization is safe', function(callback) {
            // Ensure processing continues, and that MQ is still stable with the tests that follow.
            MQ.init({}, callback);
        });

        /**
         * Verify that a bound worker starts receiving tasks.
         */
        it('verify binding can receive a task', function(callback) {
            var testQueue = 'testQueue-' + new Date().getTime();
            MQ.bind(testQueue, function(data, taskCallback) {
                assert.ok(data);
                assert.equal(data.activity, 'you stink!');
                taskCallback();
                callback();
            }, null,
            function() {
                MQ.submit(testQueue, {'activity': 'you stink!'});
            });
        });

        /**
         * Verify a worker can be bound, then unbound, the rebound and still receive tasks
         */
        it('verify unbinding and then rebinding', function(callback) {
            var testQueue = 'testQueue-' + new Date().getTime();
            MQ.bind(testQueue, function() {
                // Dead end. if this is the effective method the test will hang and time out
            }, null,
            function() {
                // Now unbind it so we can re-bind with a valid handler
                MQ.unbind(testQueue, function() {
                    MQ.bind(testQueue, function(data, taskCallback) {
                        assert.ok(data);
                        assert.equal(data.activity, 'you stink!');
                        taskCallback();
                        callback();
                    }, null,
                    function() {
                        MQ.submit(testQueue, {'activity': 'you stink!'});
                    });
                });
            });
        });

        /**
         * Verify that binding a worker when there is already one doesn't invoke an error
         */
        it('verify binding an existing queue is safe', function(callback) {
            var testQueue = 'testQueue-' + new Date().getTime();
            MQ.bind(testQueue, function(){}, null, function() {
                // Simply make sure the callback gets executed and we can carry on
                MQ.bind(testQueue, function(){}, null, callback);
            });
        });

        /**
         * Verify that unbinding a non-existing worker does not invoke an error
         */
        it('verify unbind non-existing queue is safe', function(callback) {
            var testQueue = 'testQueue-' + new Date().getTime();
            // Simply make sure there is no exception
            MQ.unbind(testQueue, callback);
        });

        /**
         * Verify that processing continues safely when an exception is thrown from within a worker.
         */
        it('verify exception in listener is safe', function(callback) {
            var testQueue = 'testQueue-' + new Date().getTime();
            MQ.bind(testQueue, function(data) {
                throw new Error('Hard-coded exception to verify application remains stable.');
            }, null,
            function() {
                MQ.submit(testQueue, { 'activity': 'blah' });
                // Simply make sure tests continue normally when the exception is thrown
                callback();
            });
        });
    });

    describe('#purge()', function() {

        /**
         * Verify that a queue can be purged of its tasks.
         */
        it ('verify a queue can be purged', function(callback) {
            var called = 0;
            var taskHandler = function(data, taskCallback) {
                called++;
                setTimeout(taskCallback, 2000);
            };

            var testQueue = 'testQueue-' + new Date().getTime();
            MQ.bind(testQueue, taskHandler, purgeQueueOptions, function() {
                // Submit a couple of tasks.
                for (var i = 0; i < 10; i++) {
                    MQ.submit(testQueue, { 'foo': 'bar' });
                }

                // Purge the queue.
                MQ.purge(testQueue, function() {
                    // Because of the asynchronous nature of node/rabbitmq it's possible that a task gets delivered
                    // before the purge command is processed.
                    // That means we should have only handled at most 1 task.
                    assert.ok(called <= 1);
                    callback();
                });
            });
        });
    });

    describe('#purgeAll()', function() {

        /**
         * Verify that all known queues can be purged of its tasks.
         */
        it ('verify all queues can be purged', function(callback) {
            var called = {'a': 0, 'b': 0};
            var taskHandler = function(data, taskCallback) {
                called[data.queue]++;
                setTimeout(taskCallback, 2000);
            };

            var testQueueA = 'testQueueA-' + new Date().getTime();
            var testQueueB = 'testQueueB-' + new Date().getTime();
            MQ.bind(testQueueA, taskHandler, purgeQueueOptions, function() {
                MQ.bind(testQueueB, taskHandler, purgeQueueOptions, function() {
                    // Submit a couple of tasks.
                    for (var i = 0; i < 10; i++) {
                        MQ.submit(testQueueA, { 'queue': 'a' });
                        MQ.submit(testQueueB, { 'queue': 'b' });
                    }

                    // Purge all the queues.
                    MQ.purgeAll(function() {
                        // Because of the asynchronous nature of node/rabbitmq it's possible that a task gets delivered
                        // before the purge command is processed.
                        // That means we should have only handled at most 1 task.
                        assert.ok(called['a'] <= 1);
                        assert.ok(called['b'] <= 1);
                        callback();
                    });
                });
            });
        });
    });
});
