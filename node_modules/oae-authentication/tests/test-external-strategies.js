/*
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');
var fs = require('fs');
var request = require('request');
var url = require('url');
var util = require('util');
var xml2js = require('xml2js');

var ConfigTestUtil = require('oae-config/lib/test/util');
var PrincipalsTestUtil = require('oae-principals/lib/test/util');
var RestAPI = require('oae-rest');
var RestUtil = require('oae-rest/lib/util');
var TenantsTestUtil = require('oae-tenants/lib/test/util');
var TestsUtil = require('oae-tests');

var AuthenticationAPI = require('oae-authentication');
var AuthenticationConstants = require('oae-authentication/lib/constants').AuthenticationConstants;
var AuthenticationTestUtil = require('oae-authentication/lib/test/util');
var Config = require('oae-config/lib/api').config('oae-authentication');
var ShibbolethAPI = require('oae-authentication/lib/strategies/shibboleth/api');

describe('Authentication', function() {

    // Rest context that can be used every time we need to make a request as a global admin
    var globalAdminRestContext = null;

    var anonymousCamRestContext = null;
    var camAdminRestContext = null;

    /**
     * Function that will fill up the global admin rest context
     */
    before(function() {
        // Fill up global admin rest context
        globalAdminRestContext = TestsUtil.createGlobalAdminRestContext();
        // Fill up Cam anonymous rest context
        anonymousCamRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host);
        // Fill up Cam admin rest context
        camAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.cam.host);
    });

    /**
     * Test util function to enable an authentication strategy
     *
     * @param  {String}     strategyName            The name of the authentication strategy to enable
     * @param  {Function}   enabledCallback         Standard function that will be invoked when the strategy is enabled
     * @param  {Function}   enabledCallback.done    Standard function that you will have to invoke once you're done with the strategy and it can be reset again
     * @param  {Function}   resetCallback           Standard function that will be invoked when the strategy has been reset
     */
    var _enableStrategy = function(strategyName, enabledCallback, resetCallback) {
        var strategyStatus = Config.getValue(global.oaeTests.tenants.global.alias, strategyName, 'enabled');

        // Enable strategy
        var configUpdate = {};
        configUpdate['oae-authentication/' + strategyName + '/enabled'] = true;
        AuthenticationTestUtil.assertUpdateAuthConfigSucceeds(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, configUpdate, function() {

            // The strategy has been enabled, perform some assertions
            enabledCallback(function() {

                // Reset strategy to cached status
                configUpdate['oae-authentication/' + strategyName + '/enabled'] = strategyStatus;
                return AuthenticationTestUtil.assertUpdateAuthConfigSucceeds(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, configUpdate, resetCallback);
            });
        });
    };

    /**
     * Disables an external authentication strategy and verifies the endpoint no longer responds to
     * authentication requests.
     *
     * @param  {String}     strategyName    The strategy to disable. e.g., `twitter`, `facebook`, ..
     * @param  {String}     method          The HTTP method to use for the callback URL. Some strategies (e.g., `SAML2`) require a POST callback
     * @param  {Function}   callback        Standard callback function
     */
    var verifyEndpointIsDisabled = function(strategyName, method, callback) {
        _enableStrategy(strategyName, function(done) {
            var options = {
                'uri': 'http://' + global.oaeTests.tenants.localhost.host + '/api/auth/' + strategyName,
                'headers': {
                    'host': global.oaeTests.tenants.localhost.host,
                    'referer': '/'
                },
                'method': 'POST',
                'followRedirect': false
            };
            request(options, function (err, response, body) {
                assert.ok(!err);
                assert.equal(response.statusCode, 302);

                // Now disable it
                var configUpdate = {};
                configUpdate['oae-authentication/' + strategyName + '/enabled'] = false;
                AuthenticationTestUtil.assertUpdateAuthConfigSucceeds(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, configUpdate, function() {

                    // A disabled endpoint should return a 401.
                    request(options, function (err, response, body) {
                        assert.ok(!err);
                        assert.equal(response.statusCode, 302);
                        assert.equal(response.headers.location, '/?authentication=disabled');
                        options.uri = 'http://' + global.oaeTests.tenants.localhost.host + '/api/auth/' + strategyName + '/callback';
                        options.method = method;

                        request(options, function (err, response, body) {
                            assert.ok(!err);
                            assert.equal(response.statusCode, 302);
                            assert.equal(response.headers.location, '/?authentication=disabled');

                            // Reset the strategy
                            done();
                        });
                    });
                });
            });
        }, callback);
    };

    /**
     * Verifies that the given strategy forwards the client to the given host
     *
     * @param  {String}   strategyName      The name of the authentication strategy to use
     * @param  {String}   host              The host that the strategy is expected to forward the user to
     * @param  {Function} callback          Standard callback function
     */
    var verifyForward = function(strategyName, host, callback) {
        _enableStrategy(strategyName, function(done) {
            var options = {
                'uri': 'http://' + global.oaeTests.tenants.localhost.host + '/api/auth/' + strategyName,
                'headers': {
                    'host': global.oaeTests.tenants.localhost.host,
                    'referer': '/'
                },
                'method': 'POST',
                'followRedirect': false
            };
            request(options, function(err, res, body) {
                assert.ok(!err);
                assert.equal(res.statusCode, 302);
                assert.equal(url.parse(res.headers['location']).hostname, host);

                return done();
            });
        }, callback);
    };

    /**
     * Verifies that an authentication strategy can deal with parameter tampering
     *
     * @param  {String}     strategyName    The name of the authentication strategy to test
     * @param  {String}     method          The HTTP method to use
     * @param  {Object}     parameters      The parameters (either querystring or POST parameters) to send in the request
     * @param  {Function}   callback        Standard callback function
     */
    var verifyCallbackTampering = function(strategyName, method, parameters, callback) {
        _enableStrategy(strategyName, function(done) {
            var options = {
                'uri': 'http://' + global.oaeTests.tenants.localhost.host + '/api/auth/' + strategyName + '/callback',
                'headers': {
                    'host': global.oaeTests.tenants.localhost.host
                },
                'method': method,
                'followRedirect': false
            };
            if (method === 'GET') {
                options.qs = parameters;
            } else {
                options.form = parameters;
            }

            request(options, function(err, response, body) {
                assert.ok(!err);
                assert.equal(response.statusCode, 302);
                assert.equal(response.headers.location, '/?authentication=error');
                return done();
            });
        }, callback);
    };

    describe('External authentication', function() {

        /**
         * Revert the localhost tenant's hostname to its old value
         */
        afterEach(function(callback) {
            callback = _.once(callback);

            var tenantUpdate = {'host': global.oaeTests.tenants.localhost.host};
            RestAPI.Tenants.updateTenant(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, tenantUpdate, function(err) {
                if (err) {
                    if (err.msg === 'The hostname has already been taken') {
                        // This means the test did not change the localhost tenant's hostname
                        // so we can ignore this error and immediately move on to the next test
                        return callback();
                    } else {
                        var msg = 'Did not expect an error message when reverting the localhost hostname.';
                        msg += 'This might cause failures further down the line.';
                        assert.fail(err.msg, '', msg);
                        return;
                    }
                }
            });

            // When we did update the test we need to wait untill the authentication strategies have been refreshed
            AuthenticationAPI.once(AuthenticationConstants.events.REFRESHED_STRATEGIES, function(tenant) {
                return callback();
            });
        });

        /**
         * Verifies that /api/auth/google sends the client to google
         */
        it('verify forward to google', function(callback) {
            verifyForward('google', 'accounts.google.com', callback);
        });

        /**
         * Verifies that /api/auth/facebook sends the client to facebook
         */
        it('verify forward to facebook', function(callback) {
            verifyForward('facebook', 'www.facebook.com', callback);
        });

        /**
         * Verifies that /api/auth/twitter sends the client to twitter
         */
        it('verify forward to twitter', function(callback) {
            verifyForward('twitter', 'api.twitter.com', callback);
        });

        /**
         * Verifies that disabling the CAS authentication mechanism in the Config
         * disabled the authentication logic in the REST endpoints.
         */
        it('verify disabling the CAS strategy', function(callback) {
            verifyEndpointIsDisabled('cas', 'GET', callback);
        });

        /**
         * Verifies that disabling the Facebook authentication mechanism in the Config
         * disabled the authentication logic in the REST endpoints.
         */
        it('verify disabling the Facebook strategy', function(callback) {
            verifyEndpointIsDisabled('facebook', 'GET', callback);
        });

        /**
         * Verifies that disabling the Google authentication mechanism in the Config
         * disabled the authentication logic in the REST endpoints.
         */
        it('verify disabling the Google strategy', function(callback) {
            verifyEndpointIsDisabled('google', 'GET', callback);
        });

        /**
         * Verifies that disabling the Shibboleth authentication mechanism in the Config
         * disabled the authentication logic in the REST endpoints.
         */
        it('verify disabling the Shibboleth strategy', function(callback) {
            verifyEndpointIsDisabled('shibboleth', 'GET', callback);
        });

        /**
         * Verifies that disabling the Twitter authentication mechanism in the Config
         * disabled the authentication logic in the REST endpoints.
         */
        it('verify disabling the Twitter strategy', function(callback) {
            verifyEndpointIsDisabled('twitter', 'GET', callback);
        });

        /**
         * Test that verifies that the Twitter authentication mechanism can deal with URL tampering
         */
        it('verify the Twitter callback endpoint can deal with URL tampering', function(callback) {
            verifyCallbackTampering('twitter', 'GET', {'oauth_token': 'not-valid'} , callback);
        });

        /**
         * Test that verifies that the Google authentication mechanism can deal with URL tampering
         */
        it('verify the Google callback endpoint can deal with URL tampering', function(callback) {
            verifyCallbackTampering('google', 'GET', {'code': 'not-valid'}, callback);
        });

        /**
         * Test that verifies that the Facebook authentication mechanism can deal with URL tampering
         */
        it('verify the Facebook callback endpoint can deal with URL tampering ', function(callback) {
            verifyCallbackTampering('facebook', 'GET', {'code': 'not-valid'}, callback);
        });


        /**
         * Test that verifies that the authentication strategies are refreshed when a tenant is updated
         */
        it('verify the authentication strategies are refreshed when a tenant is updated', function(callback) {
            _enableStrategy('google', function(done) {

                // Sanity check that Google is requesting authentication for localhost:2001
                var restContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.localhost.host);
                restContext.followRedirect = false;
                RestAPI.Authentication.googleRedirect(restContext, function(err, body, response) {
                    assert.ok(!err);

                    // Assert a redirect
                    assert.equal(response.statusCode, 302);

                    // Assert we're redirecting with the localhost:2001 hostname
                    var redirectUri = util.format('http://%s/api/auth/google/callback', global.oaeTests.tenants.localhost.host);
                    var parsedUrl = url.parse(response.headers.location, true);
                    assert.strictEqual(parsedUrl.query.redirect_uri, redirectUri);

                    // Update the localhost tenant (and ensure that it's truly different, otherwise this test is useless)
                    var tenantUpdate = {'host': '127.0.0.1:2001'};
                    assert.notEqual(tenantUpdate.host, global.oaeTests.tenants.localhost.host);
                    RestAPI.Tenants.updateTenant(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, tenantUpdate, function(err) {
                        assert.ok(!err);
                    });

                    // Wait until the authentication api has finished refreshing its strategies
                    AuthenticationAPI.once(AuthenticationConstants.events.REFRESHED_STRATEGIES, function(tenant) {

                        // Assert we refreshed the strategies for the localhost tenant
                        assert.equal(tenant.alias, global.oaeTests.tenants.localhost.alias);
                        assert.equal(tenant.host, tenantUpdate.host);

                        // Verify the authentication strategies are using the new tenant hostname
                        restContext = TestsUtil.createTenantRestContext(tenantUpdate.host);
                        restContext.followRedirect = false;
                        RestAPI.Authentication.googleRedirect(restContext, function(err, body, response) {
                            assert.ok(!err);

                            // Assert a redirect
                            assert.equal(response.statusCode, 302);

                            // Assert we're redirecting with the new hostname
                            redirectUri = util.format('http://%s/api/auth/google/callback', tenantUpdate.host);
                            parsedUrl = url.parse(response.headers.location, true);
                            assert.strictEqual(parsedUrl.query.redirect_uri, redirectUri);
                            return done();
                        });
                    });
                });
            }, callback);
        });

        /**
         * Test that verifies that non-authoritative strategies cannot create user accounts
         * with an email address that does not match the configured tenant email domain
         */
        it('verify non-authoritative strategies cannot create user accounts with an email address that does not match the configured email domain', function(callback) {
            // Create a tenant and enable the external authentication strategies
            var tenantAlias = TenantsTestUtil.generateTestTenantAlias();
            var tenantHost = TenantsTestUtil.generateTestTenantHost();
            TestsUtil.createTenantWithAdmin(tenantAlias, tenantHost, function(err, tenant, tenantAdminRestContext) {
                assert.ok(!err);
                var config = {
                    'oae-authentication/facebook/enabled': true,
                    'oae-authentication/google/enabled': true
                };
                AuthenticationTestUtil.assertUpdateAuthConfigSucceeds(tenantAdminRestContext, null, config, function() {

                    // Signing in without providing an email should fail
                    AuthenticationTestUtil.assertFacebookLoginFails(tenant.host, null, 'email_missing', function() {

                        // Signing in with an email address that does not belong to the configured
                        // email domain should fail
                        var email = TestsUtil.generateTestEmailAddress();
                        AuthenticationTestUtil.assertFacebookLoginFails(tenant.host, email, 'email_domain_mismatch', function() {

                            // Signing in with an email address that does belong to the configured
                            // email domain should succeed
                            email = TestsUtil.generateTestEmailAddress(null, tenant.emailDomains[0]).toLowerCase();
                            AuthenticationTestUtil.assertFacebookLoginSucceeds(tenant.host, {'email': email}, function(restCtx, me) {
                                assert.strictEqual(me.email, email);

                                // Similarly, signing in through Google with an email address that does not match
                                // the configured email domain should result in an authentication failure
                                email = TestsUtil.generateTestEmailAddress();
                                AuthenticationTestUtil.assertGoogleLoginFails(tenant.host, email, 'email_domain_mismatch', function() {

                                    // Signing in with an email address that does belong to the configured
                                    // email domain should succeed
                                    email = TestsUtil.generateTestEmailAddress(null, tenant.emailDomains[0]).toLowerCase();
                                    AuthenticationTestUtil.assertGoogleLoginSucceeds(tenant.host, email, function(restCtx, me) {

                                        return callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    describe('CAS authentication', function() {

        // Our mocked CAS server variables
        var app = null;
        var server = null;
        var port = null;

        // A string that can be used with our mocked CAS server that will return a succesfull response
        var validTicket = null;
        var externalId = null;
        var email = null;

        /**
         * Function that will start up a mocked CAS server. The url will be configured for the `localhost` tenant
         */
        beforeEach(function(callback) {
            TestsUtil.createTestServer(function(_app, _server, _port) {
                app = _app;
                server = _server;
                port = _port;

                validTicket = 'ticket-' + _.random(0, 10000);
                externalId = 'sg555@' + _.random(0, 10000);
                email = TestsUtil.generateTestEmailAddress();
                app.get('/cas/serviceValidate', function(req, res) {
                    if (req.query.ticket === validTicket) {
                        var successXml = '<cas:serviceResponse>';
                        successXml += '<cas:authenticationSuccess>';
                        successXml += '<cas:user>' + externalId + '</cas:user>';
                        successXml += '<cas:attributes>';
                        successXml += '  <cas:displayName>Simon</cas:displayName>';
                        successXml += '  <cas:email>' + email + '</cas:email>';
                        successXml += '</cas:attributes>';
                        successXml += '</cas:authenticationSuccess>';
                        successXml += '</cas:serviceResponse>';
                        res.send(200, successXml);
                    } else {
                        res.send(401, '<cas:serviceResponse><cas:authenticationFailure>true</cas:authenticationFailure></cas:serviceResponse>');
                    }
                });

                // Setup the CAS strategy (but do not enable it just yet)
                var configUpdate = {};
                configUpdate['oae-authentication/cas/url'] = 'http://localhost:' + _port + '/cas';
                configUpdate['oae-authentication/cas/loginPath'] = '/login';
                configUpdate['oae-authentication/cas/mapDisplayName'] = '{displayName}';
                configUpdate['oae-authentication/cas/mapEmail'] = '{email}';
                return AuthenticationTestUtil.assertUpdateAuthConfigSucceeds(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, configUpdate, callback);
            });
        });

        /**
         * Function that will close the mocked CAS server and clear the config values
         */
        afterEach(function(callback) {
            server.close(function(err) {
                assert.ok(!err);
                var keysToClear = [
                    'oae-authentication/cas/url',
                    'oae-authentication/cas/loginPath',
                    'oae-authentication/cas/mapDisplayName',
                    'oae-authentication/cas/mapEmail'
                ];

                ConfigTestUtil.clearConfigAndWait(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, keysToClear, function(err) {
                    assert.ok(!err);
                });

                AuthenticationAPI.once(AuthenticationConstants.events.REFRESHED_STRATEGIES, function(tenant) {

                    // Clear the email domain
                    TenantsTestUtil.updateTenantAndWait(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, {'emailDomains': ''}, function(err) {
                        assert.ok(!err);
                        return callback();
                    });
                });
            });
        });

        /**
         * Test that verifies the user gets forwarded to the CAS server
         */
        it('verify forward to cas', function(callback) {
            _enableStrategy('cas', function(done) {

                var restContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.localhost.host);
                restContext.followRedirect = false;
                RestAPI.Authentication.casRedirect(restContext, function(err, body, response) {
                    assert.ok(!err);
                    assert.equal(response.statusCode, 302);

                    // Assert we're redirected to the proper CAS endpoint
                    var casLocation = url.parse(response.headers.location, true);
                    assert.equal(casLocation.hostname, 'localhost');
                    assert.equal(casLocation.port, port);
                    assert.equal(casLocation.pathname, '/cas/login');
                    assert.ok(casLocation.query);
                    assert.equal(casLocation.query.service, 'http://localhost:2001/api/auth/cas/callback');

                    // Configure the login path
                    var configUpdate = {'oae-authentication/cas/loginPath': '/login/something/foo'};
                    AuthenticationTestUtil.assertUpdateAuthConfigSucceeds(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, configUpdate, function() {

                        // The CAS redirect should now redirect to the new login url
                        RestAPI.Authentication.casRedirect(restContext, function(err, body, response) {
                            assert.ok(!err);
                            assert.equal(response.statusCode, 302);

                            // Assert we're redirected to the proper CAS endpoint
                            var casLocation = url.parse(response.headers.location, true);
                            assert.equal(casLocation.hostname, 'localhost');
                            assert.equal(casLocation.port, port);
                            assert.equal(casLocation.pathname, '/cas/login/something/foo');
                            assert.ok(casLocation.query);
                            assert.equal(casLocation.query.service, 'http://localhost:2001/api/auth/cas/callback');
                            return callback();
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies the ticket gets validated
         */
        it('verify ticket validation', function(callback) {
            _enableStrategy('cas', function(done) {

                var restContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.localhost.host);
                restContext.followRedirect = false;
                RestAPI.Authentication.casCallback(restContext, {'ticket': 'invalid-ticket'}, function(err, body, response) {
                    assert.ok(!err);
                    assert.equal(response.statusCode, 302);
                    assert.equal(response.headers.location, '/?authentication=error');

                    // Try with a valid ticket
                    RestAPI.Authentication.casCallback(restContext, {'ticket': validTicket}, function(err, body, response) {
                        assert.ok(!err);
                        assert.equal(response.statusCode, 302);
                        assert.equal(response.headers.location, '/');
                        return done();
                    });
                });
            }, callback);
        });

        /**
         * Test that verifies the CAS strategy can deal with an error from the CAS server
         */
        it('verify ticket error handling', function(callback) {
            // By configuring the CAS url to something non existant, we will trigger an error in the validation step
            var configUpdate = {};
            configUpdate['oae-authentication/cas/url'] = 'http://nothing.here.local';
            AuthenticationTestUtil.assertUpdateAuthConfigSucceeds(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, configUpdate, function() {

                _enableStrategy('cas', function(done) {
                    // Trigger a ticket validation error by attempting to log in
                    var restContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.localhost.host);
                    restContext.followRedirect = false;
                    RestAPI.Authentication.casCallback(restContext, {'ticket': 'Someticket'}, function(err, body, response) {
                        assert.ok(!err);
                        assert.equal(response.statusCode, 302);
                        assert.equal(response.headers.location, '/?authentication=failed&reason=tampering');
                        return done();
                    });
                }, callback);
            });
        });

        /**
         * Test that verifies the ticket gets validated
         */
        it('verify CAS attribute mapping', function(callback) {
            _enableStrategy('cas', function(done) {
                // Log in with our CAS server
                var restContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.localhost.host);
                restContext.followRedirect = false;
                RestAPI.Authentication.casCallback(restContext, {'ticket': validTicket}, function(err, body, response) {
                    assert.ok(!err);
                    assert.equal(response.statusCode, 302);
                    assert.equal(response.headers.location, '/');

                    // Check that the attributes were parsed correctly
                    RestAPI.User.getMe(restContext, function(err, me) {
                        assert.ok(!err);
                        assert.ok(!me.anon);
                        assert.strictEqual(me.displayName, 'Simon');
                        assert.strictEqual(me.email, email.toLowerCase());
                        assert.strictEqual(me.authenticationStrategy, 'cas');

                        return done();
                    });
                });
            }, callback);
        });

        /**
         * Test that verifies that accounts with an invalid email address can still be created
         */
        it('verify accounts with an invalid email address get created', function(callback) {
            _enableStrategy('cas', function(done) {
                email = 'an invalid email address';

                // Log in with our CAS server
                var restContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.localhost.host);
                restContext.followRedirect = false;
                RestAPI.Authentication.casCallback(restContext, {'ticket': validTicket}, function(err, body, response) {
                    assert.ok(!err);
                    assert.equal(response.statusCode, 302);
                    assert.equal(response.headers.location, '/');

                    // Check that the attributes were parsed correctly
                    RestAPI.User.getMe(restContext, function(err, me) {
                        assert.ok(!err);
                        assert.ok(!me.anon);
                        assert.strictEqual(me.displayName, 'Simon');
                        assert.strictEqual(me.authenticationStrategy, 'cas');
                        assert.ok(!me.email);

                        return done();
                    });
                });
            }, callback);
        });

        /**
         * Test that verifies that misconfigured attributes doe not break the authentication flow
         */
        it('verify misconfigured attribute mapping does not break the authentication flow', function(callback) {
            _enableStrategy('cas', function(done) {

                // Misconfigure some attributes
                var configUpdate = {};
                configUpdate['oae-authentication/cas/mapDisplayName'] = '}displayname{';
                AuthenticationTestUtil.assertUpdateAuthConfigSucceeds(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, configUpdate, function() {

                    // Log in with our CAS server, authentication should succeed
                    var restContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.localhost.host);
                    restContext.followRedirect = false;
                    RestAPI.Authentication.casCallback(restContext, {'ticket': validTicket}, function(err, body, response) {
                        assert.ok(!err);
                        assert.equal(response.statusCode, 302);
                        assert.equal(response.headers.location, '/');

                        // Check that the attributes were parsed correctly
                        RestAPI.User.getMe(restContext, function(err, me) {
                            assert.ok(!err);
                            assert.ok(!me.anon);
                            assert.strictEqual(me.authenticationStrategy, 'cas');

                            // Nothing can be replaced from the attribute template, so we use it as-is
                            assert.strictEqual(me.displayName, '}displayname{');

                            return done();
                        });
                    });
                });
            }, callback);
        });

        /**
         * Test that verifies that the user is sent to the proper logout url on the CAS server
         * when the user logs out of OAE
         */
        it('verify CAS logout', function(callback) {
            var configUpdate = {};
            configUpdate['oae-authentication/cas/logoutUrl'] = 'http://localhost:' + port + '/cas/logout';
            AuthenticationTestUtil.assertUpdateAuthConfigSucceeds(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, configUpdate, function() {

                _enableStrategy('cas', function(done) {
                    // Log in with our CAS server
                    var restContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.localhost.host);
                    restContext.followRedirect = false;
                    RestAPI.Authentication.casCallback(restContext, {'ticket': validTicket}, function(err, body, response) {
                        assert.ok(!err);
                        assert.equal(response.statusCode, 302);
                        assert.equal(response.headers.location, '/');

                        // Sanity check we're logged in
                        RestAPI.User.getMe(restContext, function(err, me) {
                            assert.ok(!err);
                            assert.ok(!me.anon);
                            assert.strictEqual(me.authenticationStrategy, 'cas');

                            // Log out
                            RestAPI.Authentication.logout(restContext, function(err, data, response) {
                                assert.ok(!err);

                                // The user should be redirected to the CAS server
                                assert.equal(response.statusCode, 302);
                                assert.ok(response.headers.location);
                                assert.equal(response.headers.location, 'http://localhost:' + port + '/cas/logout');

                                // Sanity-check we're logged out
                                RestAPI.User.getMe(restContext, function(err, me) {
                                    assert.ok(!err);
                                    assert.ok(me.anon);
                                    return done();
                                });
                            });
                        });
                    });
                }, callback);
            });
        });

        /**
         * Test that verifies that accounts with an email address that does not match the tenant
         * configured email domain can be created
         */
        it('verify accounts with an email address that does not match the tenant configured email domain can be created', function(callback) {
            _enableStrategy('cas', function(done) {

                // Configure an email domain
                var emailDomain = TenantsTestUtil.generateTestTenantHost();
                TenantsTestUtil.updateTenantAndWait(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, {'emailDomains': [emailDomain]}, function(err) {
                    assert.ok(!err);

                    // Log in through CAS with an email address that definitely does not belong to
                    // the tenant's configured email domain
                    var otherEmailDomain = TenantsTestUtil.generateTestTenantHost();
                    assert.notStrictEqual(emailDomain, otherEmailDomain);
                    email = TestsUtil.generateTestEmailAddress(null, otherEmailDomain);

                    var restContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.localhost.host);
                    restContext.followRedirect = false;
                    RestAPI.Authentication.casCallback(restContext, {'ticket': validTicket}, function(err, body, response) {
                        assert.ok(!err);
                        assert.equal(response.statusCode, 302);
                        assert.equal(response.headers.location, '/');

                        // Check that the attributes were parsed correctly
                        RestAPI.User.getMe(restContext, function(err, me) {
                            assert.ok(!err);
                            assert.ok(!me.anon);
                            assert.strictEqual(me.displayName, 'Simon');
                            assert.strictEqual(me.email, email.toLowerCase());
                            assert.strictEqual(me.authenticationStrategy, 'cas');

                            return done();
                        });
                    });
                });
            }, callback);
        });
    });

    describe('Shibboleth authentication', function() {

        /**
         * Function that will configure the shibboleth authentication strategy
         */
        beforeEach(function(callback) {
            // Setup the Shibboleth strategy (but do not enable it just yet)
            var configUpdate = {};
            configUpdate['oae-authentication/shibboleth/idpEntityID'] = 'https://idp.example.com/shibboleth';
            return AuthenticationTestUtil.assertUpdateAuthConfigSucceeds(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, configUpdate, callback);
        });

        /**
         * Function that will clear the config values
         */
        afterEach(function(callback) {
            var keysToClear = [
                'oae-authentication/shibboleth/idpEntityID'
            ];

            ConfigTestUtil.clearConfigAndWait(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, keysToClear, function(err) {
                assert.ok(!err);
            });

            AuthenticationAPI.once(AuthenticationConstants.events.REFRESHED_STRATEGIES, function(tenant) {
                // Clear the email domain
                TenantsTestUtil.updateTenantAndWait(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, {'emailDomains': ''}, function(err) {
                    assert.ok(!err);
                    return callback();
                });
            });
        });

        /**
         * Perform the inital steps of the Shibboleth authentication flow:
         *   1.  Declare that you want to log in with Shibboleth on the localhost tenant
         *   2.  Hit the SP endpoint and verify that the user is redirect to the Shibboleth login handlers
         *
         * @param  {String}         [redirectUrl]                   The URL where the user should be redirected to once authenticated in the system
         * @param  {Function}       callback                        Standard callback function
         * @param  {RestContext}    callback.tenantRestContext      The rest context that can be used on the tenant on which you want to sign in
         * @param  {RestContext}    callback.spRestContext          The rest context that can be used on the service provider "tenant"
         */
        var _initiateShibbolethAuthFlow = function(redirectUrl, callback) {
            var tenantRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.localhost.host);
            tenantRestContext.followRedirect = false;
            RestAPI.Authentication.shibbolethTenantRedirect(tenantRestContext, redirectUrl, function(err, body, response) {
                assert.ok(!err);
                assert.strictEqual(response.statusCode, 302);

                // Assert we're redirected to the SP host
                var spHost = ShibbolethAPI.getSPHost();
                var location = url.parse(response.headers.location, true);
                assert.strictEqual(location.host, spHost);
                assert.strictEqual(location.pathname, '/api/auth/shibboleth/sp');

                // Assert that we pass in the correct parameters
                assert.ok(location.query);
                assert.strictEqual(location.query.tenantAlias, global.oaeTests.tenants.localhost.alias);
                assert.ok(location.query.signature);
                assert.ok(location.query.expires);

                // Assert we can use this parameters with our SP and that it redirects us to the login handler
                var spRestContext = TestsUtil.createTenantRestContext(spHost);
                spRestContext.followRedirect = false;
                var params = location.query;
                RestAPI.Authentication.shibbolethSPRedirect(spRestContext, params, function(err, body, response) {
                    assert.ok(!err);
                    assert.strictEqual(response.statusCode, 302);

                    // Assert we're redirected to the proper Shibboleth handler
                    var location = url.parse(response.headers.location, true);
                    assert.strictEqual(location.pathname, '/Shibboleth.sso/Login');

                    // Assert that we pass in the entity ID of the IdP and a target where the user should be redirected back to
                    assert.ok(location.query);
                    assert.strictEqual(location.query.entityID, 'https://idp.example.com/shibboleth');
                    assert.strictEqual(location.query.target, '/api/auth/shibboleth/sp/returned');

                    return callback(tenantRestContext, spRestContext);
                });
            });
        };

        /**
         * Perform the callback steps of the Shibboleth authentication flow
         *
         * @param  {RestContext}    tenantRestContext           The rest context that can be used on the tenant on which you want to sign in
         * @param  {RestContext}    spRestContext               The rest context that can be used on the service provider "tenant"
         * @param  {Object}         attributes                  The attributes that mod_shib is supposed to pass into the SP callback endpoint
         * @param  {String}         [expectedRedirectUrl]       The URL where the user should be redirected to once he arrives on the tenant. Defaults to `/`
         * @param  {Function}       callback                    Standard callback function
         */
        var _callbackShibbolethAuthFlow = function(tenantRestContext, spRestContext, attributes, expectedRedirectUrl, callback) {
            expectedRedirectUrl = expectedRedirectUrl || '/';

            // The user returns from the Shibboleth IdP and arrives on our SP
            RestAPI.Authentication.shibbolethSPCallback(spRestContext, attributes, function(err, body, response) {
                assert.ok(!err);
                assert.equal(response.statusCode, 302);

                // Assert that we're redirected back to the tenant
                var location = url.parse(response.headers.location, true);
                assert.strictEqual(location.host, global.oaeTests.tenants.localhost.host);
                assert.strictEqual(location.pathname, '/api/auth/shibboleth/callback');

                // Assert that the user id of the created user is present
                assert.ok(location.query);
                assert.ok(location.query.userId);
                assert.ok(location.query.signature);
                assert.ok(location.query.expires);

                // We arrive back at our tenant
                var params = location.query;
                RestAPI.Authentication.shibbolethTenantCallback(tenantRestContext, params, function(err, body, response) {
                    assert.ok(!err);

                    // We should be redirected to the specified redirect URL
                    assert.equal(response.statusCode, 302);
                    assert.equal(response.headers.location, expectedRedirectUrl);

                    return callback();
                });
            });
        };

        /**
         * Get a stream that points towards a CSV file
         *
         * @return {Stream}     A readable stream pointing to a CSV file
         */
        var getShibbolethCSVfile = function() {
            return fs.createReadStream(__dirname + '/data/shibboleth.csv');
        };

        /**
         * Test that verifies the user gets forwarded to our SP endpoint
         */
        it('verify redirection flow', function(callback) {
            _enableStrategy('shibboleth', function(done) {

                // Initiate the Shibboleth auth flow
                _initiateShibbolethAuthFlow('/content/bla', function(tenantRestContext, spRestContext) {

                    var email = TestsUtil.generateTestEmailAddress();
                    var attributes = {
                        // Fake a session ID to log in
                        'shib-session-id': Math.random(),

                        // Fake some data about the IdP
                        'persistent-id': 'https://idp.example.com/shibboleth#https://sp.example.com/shibboleth#' + Math.random(),
                        'identityProvider': 'https://idp.example.com/shibboleth',
                        'affiliation': 'Digital Services',
                        'unscopedAffiliation': 'OAE Team',

                        // Generate an external id
                        'remote_user': 'simon' + Math.random(),

                        // Pass along some attributes
                        'displayname': 'Simon',
                        'email': email,
                        'locale': 'en_UK'
                    };

                    // Perform the callback part of the authentication flow
                    _callbackShibbolethAuthFlow(tenantRestContext, spRestContext, attributes, '/content/bla', function() {

                        // Assert we're logged in and the attributes were correctly persisted
                        RestAPI.User.getMe(tenantRestContext, function(err, me) {
                            assert.ok(!err);
                            assert.ok(!me.anon);
                            assert.strictEqual(me.authenticationStrategy, 'shibboleth');
                            assert.strictEqual(me.displayName, 'Simon');
                            assert.strictEqual(me.email, email.toLowerCase());
                            assert.strictEqual(me.locale, 'en_UK');
                            return done();
                        });
                    });
                });
            }, callback);
        });

        /**
         * Test that verifies that the remote_user attribute is used when no displayName attributes are specified
         */
        it('verify the remote_user attribute is used when no displayName attributes are specified', function(callback) {
            _enableStrategy('shibboleth', function(done) {

                // Initiate the Shibboleth auth flow
                _initiateShibbolethAuthFlow('/content/bla', function(tenantRestContext, spRestContext) {

                    var email = TestsUtil.generateTestEmailAddress();
                    var attributes = {
                        // Fake a session ID to log in
                        'shib-session-id': Math.random(),

                        // Fake some data about the IdP
                        'persistent-id': 'https://idp.example.com/shibboleth#https://sp.example.com/shibboleth#' + Math.random(),
                        'identityProvider': 'https://idp.example.com/shibboleth',
                        'affiliation': 'Digital Services',
                        'unscopedAffiliation': 'OAE Team',

                        // Generate an external id
                        'remote_user': 'simon' + Math.random(),

                        // Pass along some attributes, but don't specify a display name attribute
                        'email': email,
                        'locale': 'en_UK'
                    };

                    // Perform the callback part of the authentication flow
                    _callbackShibbolethAuthFlow(tenantRestContext, spRestContext, attributes, '/content/bla', function() {

                        // Assert we're logged in and the attributes were correctly persisted
                        RestAPI.User.getMe(tenantRestContext, function(err, me) {
                            assert.ok(!err);
                            assert.ok(!me.anon);
                            assert.strictEqual(me.authenticationStrategy, 'shibboleth');
                            assert.strictEqual(me.displayName, attributes.remote_user);
                            assert.strictEqual(me.email, email.toLowerCase());
                            assert.strictEqual(me.locale, 'en_UK');
                            return done();
                        });
                    });
                });
            }, callback);
        });

        /**
         * Test utility for verifying that the user visibility will be set to private when remote_user is used to populate
         * display name and resembles a shibboleth identifier
         * 
         * @param  {String}         remoteUser           The remote_user attribute we want to use to populate display name
         * @param  {Function}       callback             Standard callback function
         */
        var verifyInvalidDisplayNameMakesProfilePrivate = function(remoteUser, callback) {
            // Initiate the Shibboleth auth flow
            _initiateShibbolethAuthFlow('/content/bla', function(tenantRestContext, spRestContext) {

                var email = TestsUtil.generateTestEmailAddress();
                var attributes = {
                    // Fake a session ID to log in
                    'shib-session-id': Math.random(),

                    // Fake some data about the IdP
                    'persistent-id': 'https://idp.example.com/shibboleth#https://sp.example.com/shibboleth#' + Math.random(),
                    'identityProvider': 'https://idp.example.com/shibboleth',
                    'affiliation': 'Digital Services',
                    'unscopedAffiliation': 'OAE Team',

                    // Set the remote user value which will be used as the display name
                    'remote_user': remoteUser,

                    // Pass along some attributes, but don't specify a display name attribute
                    'email': email,
                    'locale': 'en_UK'
                };

                // Perform the callback part of the authentication flow
                _callbackShibbolethAuthFlow(tenantRestContext, spRestContext, attributes, '/content/bla', function() {

                    // Assert we're logged in and the attributes were correctly persisted
                    RestAPI.User.getMe(tenantRestContext, function(err, me) {
                        assert.ok(!err);
                        assert.ok(!me.anon);
                        assert.strictEqual(me.authenticationStrategy, 'shibboleth');
                        assert.strictEqual(me.displayName, attributes.remote_user);
                        assert.strictEqual(me.visibility, 'private');
                        callback();
                    });
                });
            });
        }

        /**
         * Test that verifies that the user visibility will be set to private if displayName resembles a shibboleth identifier,
         * URL or email address
         */
        it('verify the user will be private if displayName resembles a Shibboleth identifier, URL or email address', function(callback) {
            _enableStrategy('shibboleth', function(done) {
                // Profile should be made private if display name looks like a shibboleth identifier
                verifyInvalidDisplayNameMakesProfilePrivate('shibboleth!' + Math.random, function() {
                    // Profile should be made private if display name is an email address
                    verifyInvalidDisplayNameMakesProfilePrivate(TestsUtil.generateTestEmailAddress(), function() {
                        // Profile should be made private if display name is a URL starting with https...
                        verifyInvalidDisplayNameMakesProfilePrivate('https://idp.example.com/shibboleth', function() {
                            // ...or http.
                            verifyInvalidDisplayNameMakesProfilePrivate('http://example.tenant.com/profile', function(){
                                return done();
                            });
                        });
                    });
                });
            }, callback);
        });

        /**
         * Test that verifies the parameters are validated when redirecting a user from a tenant to our SP
         */
        it('verify SP redirect', function(callback) {
            _enableStrategy('shibboleth', function(done) {

                // The tenant we try to authenticate on
                var tenantAlias = global.oaeTests.tenants.localhost.alias;

                // The rest context for our SP "tenant"
                var spHost = ShibbolethAPI.getSPHost();
                var spRestContext = TestsUtil.createTenantRestContext(spHost);
                spRestContext.followRedirect = false;

                // Missing or invalid parameters
                RestAPI.Authentication.shibbolethSPRedirect(spRestContext, {'tenantAlias': null, 'signature': null, 'expires': null}, function(err, body, response) {
                    assert.strictEqual(err.code, 400);
                    RestAPI.Authentication.shibbolethSPRedirect(spRestContext, {'tenantAlias': tenantAlias, 'signature': null, 'expires': null}, function(err, body, response) {
                        assert.strictEqual(err.code, 400);
                        RestAPI.Authentication.shibbolethSPRedirect(spRestContext, {'tenantAlias': tenantAlias, 'signature': 'sign', 'expires': null}, function(err, body, response) {
                            assert.strictEqual(err.code, 400);
                            RestAPI.Authentication.shibbolethSPRedirect(spRestContext, {'tenantAlias': tenantAlias, 'signature': 'sign', 'expires': 'not a number'}, function(err, body, response) {
                                assert.strictEqual(err.code, 400);
                                RestAPI.Authentication.shibbolethSPRedirect(spRestContext, {'tenantAlias': tenantAlias, 'signature': 'sign', 'expires': (Date.now() - 1000)}, function(err, body, response) {
                                    assert.strictEqual(err.code, 400);

                                    // Invalid signature
                                    RestAPI.Authentication.shibbolethSPRedirect(spRestContext, {'tenantAlias': tenantAlias, 'signature': 'sign', 'expires': (Date.now() + 10000)}, function(err, body, response) {
                                        assert.strictEqual(err.code, 401);

                                        // The SP Redirect endpoint should not be functioning on a regular tenant
                                        var tenantRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host);
                                        RestAPI.Authentication.shibbolethSPRedirect(tenantRestContext, {}, function(err, body, response) {
                                            assert.strictEqual(err.code, 501);

                                            return done();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            }, callback);
        });

        /**
         * Test that verifies the parameters are validated when redirecting a user from our SP to the tenant callback endpoint
         */
        it('verify the tenant callback endpoint validates its parameters', function(callback) {
            _enableStrategy('shibboleth', function(done) {
                var restContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.localhost.host);
                restContext.followRedirect = false;

                // Missing or invalid parameters
                RestAPI.Authentication.shibbolethTenantCallback(restContext, {'userId': null, 'signature': null, 'expires': null}, function(err, body, response) {
                    assert.strictEqual(err.code, 400);
                    RestAPI.Authentication.shibbolethTenantCallback(restContext, {'userId': 'u:foo:bar', 'signature': null, 'expires': null}, function(err, body, response) {
                        assert.strictEqual(err.code, 400);
                        RestAPI.Authentication.shibbolethTenantCallback(restContext, {'userId': 'u:foo:bar', 'signature': 'sign', 'expires': null}, function(err, body, response) {
                            assert.strictEqual(err.code, 400);
                            RestAPI.Authentication.shibbolethTenantCallback(restContext, {'userId': 'u:foo:bar', 'signature': 'sign', 'expires': 'expires'}, function(err, body, response) {
                                assert.strictEqual(err.code, 400);
                                RestAPI.Authentication.shibbolethTenantCallback(restContext, {'userId': 'u:foo:bar', 'signature': 'sign', 'expires': (Date.now() - 1000)}, function(err, body, response) {
                                    assert.strictEqual(err.code, 400);

                                    // Invalid signature
                                    RestAPI.Authentication.shibbolethTenantCallback(restContext, {'userId': 'u:foo:bar', 'signature': 'sign', 'expires': (Date.now() + 10000)}, function(err, body, response) {
                                        assert.strictEqual(err.code, 401);

                                        return done();
                                    });
                                });
                            });
                        });
                    });
                });
            }, callback);
        });

        /**
         * Test that verifies that the SP callback endpoint verifies the cookie hasn't been tampered with
         * and that it can't be called from regular tenants
         */
        it('verify the SP callback endpoint spoofing', function(callback) {
            _enableStrategy('shibboleth', function(done) {

                // Initiate the Shibboleth auth flow
                _initiateShibbolethAuthFlow('/', function(tenantRestContext, spRestContext) {

                    // The user returns from the Shibboleth IdP and arrives on our SP
                    // but he somehow managed to fake his cookie and changes the tenant alias
                    var fakeCookie = request.cookie('shibboleth=s:camtest.fakedsignature');
                    spRestContext.cookieJar.setCookie(fakeCookie, 'http://localhost:2000/');
                    var attributes = {};
                    RestAPI.Authentication.shibbolethSPCallback(spRestContext, attributes, function(err, body, response) {
                        assert.equal(err.code, 400);

                        // The SP callback endpoint should not be exposed on regular tenants
                        RestAPI.Authentication.shibbolethSPCallback(tenantRestContext, {}, function(err) {
                            assert.strictEqual(err.code, 501);
                            return done();
                        });
                    });
                });
            }, callback);
        });

        /**
         * Test that verifies that provisioned users can log in with Shibboleth
         */
        it('verify provisioned users can log in with Shibboleth', function(callback) {
            _enableStrategy('shibboleth', function(done) {

                // Import users as a global admin using the Shibboleth authentication strategy
                PrincipalsTestUtil.importUsers(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, getShibbolethCSVfile, 'shibboleth', null, function(err) {
                    assert.ok(!err);

                    // Configure the attribute priority list so it tries an `employee-numer`
                    var configUpdate = {};
                    configUpdate['oae-authentication/shibboleth/externalIdAttributes'] = 'irrelevant-attribute employee-number eppn persistent-id targeted-id';
                    AuthenticationTestUtil.assertUpdateAuthConfigSucceeds(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, configUpdate, function() {

                        // Initiate the Shibboleth auth flow
                        _initiateShibbolethAuthFlow('/content/bla', function(tenantRestContext, spRestContext) {

                            var attributes = {
                                // Fake a session ID to log in
                                'shib-session-id': Math.random(),

                                // Fake some data about the IdP
                                'persistent-id': 'https://idp.example.com/shibboleth#https://sp.example.com/shibboleth#' + Math.random(),
                                'identityProvider': 'https://idp.example.com/shibboleth',

                                // Generate an external id
                                'remote_user': 'viggo' + Math.random(),

                                // Pass along some attributes
                                'displayname': 'Aron Viggo with some extra data',
                                'eppn': 'aron+extra-bits@institution.edu',
                                'locale': 'en_UK',

                                // Specify the same employee number as the one from the CSV file
                                'employee-number': 'em0005'
                            };

                            // Perform the callback part of the authentication flow
                            _callbackShibbolethAuthFlow(tenantRestContext, spRestContext, attributes, '/content/bla', function() {

                                // Because the user was already created in the system,
                                // we should NOT have created a new account. We can verify
                                // this by checking if the user's profile is unchanged
                                RestAPI.User.getMe(tenantRestContext, function(err, me) {
                                    assert.ok(!err);
                                    assert.strictEqual(me.displayName, 'Aron Viggo');
                                    assert.strictEqual(me.email, 'aron@institution.edu');
                                    return callback();
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that the displayName field can be configured as a priority list
         */
        it('verify the displayName field can be configured as a priority list', function(callback) {
            _enableStrategy('shibboleth', function(done) {

                // Verify the display name attribute with the highest priority is selected
                _initiateShibbolethAuthFlow('/content/bla', function(tenantRestContext, spRestContext) {
                    var attributes = {
                        'shib-session-id': _.random(100000),
                        'persistent-id': 'https://idp.example.com/shibboleth#https://sp.example.com/shibboleth#' + Math.random(),
                        'identityProvider': 'https://idp.example.com/shibboleth',
                        'affiliation': 'Digital Services',
                        'unscopedAffiliation': 'OAE Team',
                        'remote_user': 'simon' + _.random(100000),

                        // Supply both `displayName` and `cn`. `displayName` has the highest priority
                        'displayname': 'Simon via displayname',
                        'cn': 'Simon via cn',
                        'email': TestsUtil.generateTestEmailAddress(),
                        'locale': 'en_UK'
                    };
                    _callbackShibbolethAuthFlow(tenantRestContext, spRestContext, attributes, '/content/bla', function() {
                        RestAPI.User.getMe(tenantRestContext, function(err, me) {
                            assert.ok(!err);
                            assert.ok(!me.anon);
                            assert.strictEqual(me.authenticationStrategy, 'shibboleth');
                            assert.strictEqual(me.displayName, 'Simon via displayname');
                            assert.strictEqual(me.email, attributes.email.toLowerCase());
                            assert.strictEqual(me.locale, 'en_UK');


                            // Verify that lower priority attributes are used when highest priority
                            // atrribute is not present
                            _initiateShibbolethAuthFlow('/content/bla', function(tenantRestContext, spRestContext) {
                                var attributes = {
                                    'shib-session-id': _.random(100000),
                                    'persistent-id': 'https://idp.example.com/shibboleth#https://sp.example.com/shibboleth#' + Math.random(),
                                    'identityProvider': 'https://idp.example.com/shibboleth',
                                    'affiliation': 'Digital Services',
                                    'unscopedAffiliation': 'OAE Team',
                                    'remote_user': 'nico' + _.random(100000),

                                    // Supply `cn`, which has a lower priority than `displayName`.
                                    // Because `displayName` is not provided, `cn` will be used
                                    'cn': 'Nico via cn',
                                    'email': TestsUtil.generateTestEmailAddress(),
                                    'locale': 'en_UK'
                                };
                                _callbackShibbolethAuthFlow(tenantRestContext, spRestContext, attributes, '/content/bla', function() {
                                    RestAPI.User.getMe(tenantRestContext, function(err, me) {
                                        assert.ok(!err);
                                        assert.ok(!me.anon);
                                        assert.strictEqual(me.authenticationStrategy, 'shibboleth');
                                        assert.strictEqual(me.displayName, 'Nico via cn');
                                        assert.strictEqual(me.email, attributes.email.toLowerCase());
                                        assert.strictEqual(me.locale, 'en_UK');
                                        return done();
                                    });
                                });
                            });
                        });
                    });
                });
            }, callback);
        });

        /**
         * Test that verifies that the email field can be configured as a priority list
         */
        it('verify the email field can be configured as a priority list', function(callback) {
            _enableStrategy('shibboleth', function(done) {

                // Verify the email attribute with the highest priority is selected
                _initiateShibbolethAuthFlow('/content/bla', function(tenantRestContext, spRestContext) {
                    var attributes = {
                        'shib-session-id': _.random(100000),
                        'persistent-id': 'https://idp.example.com/shibboleth#https://sp.example.com/shibboleth#' + Math.random(),
                        'identityProvider': 'https://idp.example.com/shibboleth',
                        'affiliation': 'Digital Services',
                        'unscopedAffiliation': 'OAE Team',
                        'remote_user': 'simon' + _.random(100000),

                        // Supply both `email` and `eppn`. `email` has the highest priority
                        'displayname': 'Simon',
                        'email': TestsUtil.generateTestEmailAddress(),
                        'eppn': TestsUtil.generateTestEmailAddress(),
                        'locale': 'en_UK'
                    };
                    _callbackShibbolethAuthFlow(tenantRestContext, spRestContext, attributes, '/content/bla', function() {
                        RestAPI.User.getMe(tenantRestContext, function(err, me) {
                            assert.ok(!err);
                            assert.ok(!me.anon);
                            assert.strictEqual(me.authenticationStrategy, 'shibboleth');
                            assert.strictEqual(me.displayName, 'Simon');
                            assert.strictEqual(me.email, attributes.email.toLowerCase());
                            assert.strictEqual(me.locale, 'en_UK');


                            // Verify that lower priority attributes are used when highest priority
                            // atrribute is not present
                            _initiateShibbolethAuthFlow('/content/bla', function(tenantRestContext, spRestContext) {
                                var attributes = {
                                    'shib-session-id': _.random(100000),
                                    'persistent-id': 'https://idp.example.com/shibboleth#https://sp.example.com/shibboleth#' + Math.random(),
                                    'identityProvider': 'https://idp.example.com/shibboleth',
                                    'affiliation': 'Digital Services',
                                    'unscopedAffiliation': 'OAE Team',
                                    'remote_user': 'simon' + _.random(100000),

                                    // Supply `eppn`, which has a lower priority than `email`.
                                    // Because `email` is not provided, `eppn` will be used
                                    'displayname': 'Simon',
                                    'eppn': TestsUtil.generateTestEmailAddress(),
                                    'locale': 'en_UK'
                                };
                                _callbackShibbolethAuthFlow(tenantRestContext, spRestContext, attributes, '/content/bla', function() {
                                    RestAPI.User.getMe(tenantRestContext, function(err, me) {
                                        assert.ok(!err);
                                        assert.ok(!me.anon);
                                        assert.strictEqual(me.authenticationStrategy, 'shibboleth');
                                        assert.strictEqual(me.displayName, 'Simon');
                                        assert.strictEqual(me.email, attributes.eppn.toLowerCase());
                                        assert.strictEqual(me.locale, 'en_UK');
                                        return done();
                                    });
                                });
                            });
                        });
                    });
                });
            }, callback);
        });

        /**
         * Test that verifies that the locale field can be configured as a priority list
         */
        it('verify the locale field can be configured as a priority list', function(callback) {
            _enableStrategy('shibboleth', function(done) {

                // Verify the locale attribute with the highest priority is selected
                _initiateShibbolethAuthFlow('/content/bla', function(tenantRestContext, spRestContext) {
                    var attributes = {
                        'shib-session-id': _.random(100000),
                        'persistent-id': 'https://idp.example.com/shibboleth#https://sp.example.com/shibboleth#' + Math.random(),
                        'identityProvider': 'https://idp.example.com/shibboleth',
                        'affiliation': 'Digital Services',
                        'unscopedAffiliation': 'OAE Team',
                        'remote_user': 'simon' + _.random(100000),

                        // Supply both `locality` and `locale`. `locality` has the highest priority
                        'displayname': 'Simon',
                        'email': TestsUtil.generateTestEmailAddress(),
                        'locality': 'en_UK',
                        'locale': 'nl_BE'
                    };
                    _callbackShibbolethAuthFlow(tenantRestContext, spRestContext, attributes, '/content/bla', function() {
                        RestAPI.User.getMe(tenantRestContext, function(err, me) {
                            assert.ok(!err);
                            assert.ok(!me.anon);
                            assert.strictEqual(me.authenticationStrategy, 'shibboleth');
                            assert.strictEqual(me.displayName, 'Simon');
                            assert.strictEqual(me.email, attributes.email.toLowerCase());
                            assert.strictEqual(me.locale, attributes.locality);


                            // Verify that lower priority attributes are used when highest priority
                            // atrribute is not present
                            _initiateShibbolethAuthFlow('/content/bla', function(tenantRestContext, spRestContext) {

                                var attributes = {
                                    'shib-session-id': _.random(100000),
                                    'persistent-id': 'https://idp.example.com/shibboleth#https://sp.example.com/shibboleth#' + Math.random(),
                                    'identityProvider': 'https://idp.example.com/shibboleth',
                                    'affiliation': 'Digital Services',
                                    'unscopedAffiliation': 'OAE Team',
                                    'remote_user': 'simon' + _.random(100000),

                                    // Supply `locale`, which has a lower priority than `locality`.
                                    // Because `locality` is not provided, `locale` will be used
                                    'displayname': 'Simon',
                                    'eppn': TestsUtil.generateTestEmailAddress(),
                                    'locale': 'en_UK'
                                };
                                _callbackShibbolethAuthFlow(tenantRestContext, spRestContext, attributes, '/content/bla', function() {
                                    RestAPI.User.getMe(tenantRestContext, function(err, me) {
                                        assert.ok(!err);
                                        assert.ok(!me.anon);
                                        assert.strictEqual(me.authenticationStrategy, 'shibboleth');
                                        assert.strictEqual(me.displayName, 'Simon');
                                        assert.strictEqual(me.email, attributes.eppn.toLowerCase());
                                        assert.strictEqual(me.locale, attributes.locale);
                                        return done();
                                    });
                                });
                            });
                        });
                    });
                });
            }, callback);
        });

        /**
         * Test that verifies that an invalid locale attribute is not used as a user's locale
         */
        it('verify an invalid locale attribute is not used as a user\'s locale', function(callback) {
            _enableStrategy('shibboleth', function(done) {
                _initiateShibbolethAuthFlow('/content/bla', function(tenantRestContext, spRestContext) {
                    var attributes = {
                        'shib-session-id': _.random(10000),
                        'persistent-id': 'https://idp.example.com/shibboleth#https://sp.example.com/shibboleth#' + Math.random(),
                        'identityProvider': 'https://idp.example.com/shibboleth',
                        'affiliation': 'Digital Services',
                        'unscopedAffiliation': 'OAE Team',
                        'remote_user': 'simon' + _.random(10000),

                        // Use an invalid locale. This should not be stored against the user
                        'displayname': 'Simon',
                        'email': TestsUtil.generateTestEmailAddress(),
                        'locale': 'Ohmygosh, I am like, totally, too_COOL'
                    };
                    _callbackShibbolethAuthFlow(tenantRestContext, spRestContext, attributes, '/content/bla', function() {
                        RestAPI.User.getMe(tenantRestContext, function(err, me) {
                            assert.ok(!err);
                            assert.ok(!me.anon);
                            assert.strictEqual(me.authenticationStrategy, 'shibboleth');
                            assert.strictEqual(me.displayName, 'Simon');
                            assert.strictEqual(me.email, attributes.email.toLowerCase());
                            assert.notStrictEqual(me.locale, attributes.locale);

                            // Verify the user's locale defaulted to the tenant's default locale
                            RestAPI.Config.getTenantConfig(tenantRestContext, null, function(err, config) {
                                assert.ok(!err);
                                assert.strictEqual(me.locale, config['oae-principals']['user']['defaultLanguage']);
                                return done();
                            });
                        });
                    });
                });
            }, callback);
        });

        /**
         * Test that verifies that accounts with an invalid email address can still be created
         */
        it('verify accounts with an invalid email address get created', function(callback) {
            _enableStrategy('shibboleth', function(done) {
                _initiateShibbolethAuthFlow('/content/bla', function(tenantRestContext, spRestContext) {
                    var attributes = {
                        'shib-session-id': _.random(10000),
                        'persistent-id': 'https://idp.example.com/shibboleth#https://sp.example.com/shibboleth#' + Math.random(),
                        'identityProvider': 'https://idp.example.com/shibboleth',
                        'affiliation': 'Digital Services',
                        'unscopedAffiliation': 'OAE Team',
                        'remote_user': 'simon' + _.random(10000),

                        // Use an invalid email. This should not be stored against the user
                        'displayname': 'Simon',
                        'email': 'not a valid email address',
                    };
                    _callbackShibbolethAuthFlow(tenantRestContext, spRestContext, attributes, '/content/bla', function() {
                        RestAPI.User.getMe(tenantRestContext, function(err, me) {
                            assert.ok(!err);
                            assert.ok(!me.anon);
                            assert.strictEqual(me.authenticationStrategy, 'shibboleth');
                            assert.strictEqual(me.displayName, 'Simon');
                            assert.ok(!me.email);
                            return callback();
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that accounts with an email address that does not match the tenant
         * configured email domain can be created
         */
        it('verify accounts with an email address that does not match the tenant configured email domain can be created', function(callback) {
            _enableStrategy('shibboleth', function(done) {

                // Configure an email domain
                var emailDomain = TenantsTestUtil.generateTestTenantHost();
                TenantsTestUtil.updateTenantAndWait(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, {'emailDomains': emailDomain}, function(err) {
                    assert.ok(!err);

                    // Log in through Shibboleth with an email address that definitely does not
                    // belong to the tenant's configured email domain
                    var otherEmailDomain = TenantsTestUtil.generateTestTenantHost();
                    assert.notStrictEqual(emailDomain, otherEmailDomain);
                    var email = TestsUtil.generateTestEmailAddress(null, otherEmailDomain);

                    _initiateShibbolethAuthFlow('/content/bla', function(tenantRestContext, spRestContext) {
                        var attributes = {
                            'shib-session-id': _.random(10000),
                            'persistent-id': 'https://idp.example.com/shibboleth#https://sp.example.com/shibboleth#' + Math.random(),
                            'identityProvider': 'https://idp.example.com/shibboleth',
                            'affiliation': 'Digital Services',
                            'unscopedAffiliation': 'OAE Team',
                            'remote_user': 'simon' + _.random(10000),
                            'displayname': 'Simon',
                            'email': email
                        };
                        _callbackShibbolethAuthFlow(tenantRestContext, spRestContext, attributes, '/content/bla', function() {
                            RestAPI.User.getMe(tenantRestContext, function(err, me) {
                                assert.ok(!err);
                                assert.ok(!me.anon);
                                assert.strictEqual(me.authenticationStrategy, 'shibboleth');
                                assert.strictEqual(me.displayName, 'Simon');
                                assert.strictEqual(me.email, attributes.email.toLowerCase());

                                return done();
                            });
                        });
                    });
                });
            }, callback);
        });
    });

    describe('Google authentication', function() {

        /**
         * Configure a set of allowed domains with the `localhost` tenant's google authentication
         *
         * @param  {String}         domains     The comma-separated list of allowed domains
         * @param  {Function}       callback    Standard callback function
         */
        var _setGoogleDomains = function(domains, callback) {
            var config = {
                'oae-authentication/google/domains': domains
            };
            return AuthenticationTestUtil.assertUpdateAuthConfigSucceeds(globalAdminRestContext, global.oaeTests.tenants.localhost.alias, config, callback);
        };

        /**
         * Test that verifies that authentication can be scoped to a set of domains
         */
        it('verify authentication can be scoped to a set of domains', function(callback) {
            _enableStrategy('google', function(done) {

                // Try with no domains
                _setGoogleDomains('', function() {
                    AuthenticationTestUtil.assertGoogleLoginSucceeds(global.oaeTests.tenants.localhost.host, 'simon@foo.com', function() {
                        AuthenticationTestUtil.assertGoogleLoginSucceeds(global.oaeTests.tenants.localhost.host, 'simon@bar.com', function() {
                            AuthenticationTestUtil.assertGoogleLoginSucceeds(global.oaeTests.tenants.localhost.host, 'simon@baz.com', function() {

                                // Try with a single domain
                                _setGoogleDomains('foo.com', function() {
                                    AuthenticationTestUtil.assertGoogleLoginSucceeds(global.oaeTests.tenants.localhost.host, 'simon@foo.com', function() {
                                        AuthenticationTestUtil.assertGoogleLoginFails(global.oaeTests.tenants.localhost.host, 'simon@bar.com', 'domain_not_allowed', function() {
                                            AuthenticationTestUtil.assertGoogleLoginFails(global.oaeTests.tenants.localhost.host, 'simon@baz.com', 'domain_not_allowed', function() {

                                                // Try with multiple domains
                                                _setGoogleDomains('foo.com,bar.com', function() {
                                                    AuthenticationTestUtil.assertGoogleLoginSucceeds(global.oaeTests.tenants.localhost.host, 'simon@foo.com', function() {
                                                        AuthenticationTestUtil.assertGoogleLoginSucceeds(global.oaeTests.tenants.localhost.host, 'simon@bar.com', function() {
                                                            AuthenticationTestUtil.assertGoogleLoginFails(global.oaeTests.tenants.localhost.host, 'simon@baz.com', 'domain_not_allowed', function() {

                                                                // Try with multiple domains, trailing spaces and mixed capitals
                                                                _setGoogleDomains('foo.com, BAR.com', function() {
                                                                    AuthenticationTestUtil.assertGoogleLoginSucceeds(global.oaeTests.tenants.localhost.host, 'simon@foo.com', function() {
                                                                        AuthenticationTestUtil.assertGoogleLoginSucceeds(global.oaeTests.tenants.localhost.host, 'simon@bar.com', function() {
                                                                            AuthenticationTestUtil.assertGoogleLoginFails(global.oaeTests.tenants.localhost.host, 'simon@baz.com', 'domain_not_allowed', function() {

                                                                                return done();
                                                                            });
                                                                        });
                                                                    });
                                                                });
                                                            });
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            }, callback);
        });
    });
});
