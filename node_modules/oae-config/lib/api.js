/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var cloneextend = require('cloneextend');
var fs = require('fs');

var Cassandra = require('oae-util/lib/cassandra');
var Util = require('oae-util/lib/util');
var IO = require('oae-util/lib/io');
var OAE = require('oae-util/lib/oae');
var Pubsub = require('oae-util/lib/pubsub');
var TenantAPI = require('oae-tenants');
var Validator = require('oae-util/lib/validator').Validator;

var Fields = require('./fields');

var cachedConfiguration = {};

/**
 * Catches a published message from the oae-config module and executes functions that bring the cached configuration up to date
 * @param  {String}  receivedMessage  The message sent out to the cluster, provides information on the event that took place (e.g. `cam config updated`)
 */
Pubsub.on('oae-config', function(receivedMessage) {
    // Messages are of the form:
    //      cam config updated
    //      gt started
    var tenantId = receivedMessage.split(' ')[0];
    // If the global tenant has been updated all tenants need an update
    if (tenantId === OAE.serverTenant.alias) {
        initializeConfig(function() {});
    } else {
        getConfigFromCassandra(tenantId, function() {});
    }
});

/**
 * Gets a single configuration value for a tenant from the cached configuration
 * @param   {String}    moduleId  The ID of the module to get configuration of
 * @return  {Function}  getValue  Function that returns the cached value of the feature's element in a module.
 */
module.exports.config = function(moduleId) {
    var validator = new Validator();
    validator.check(moduleId, {'code': 400, 'msg': 'Missing the moduleId parameter'}).notEmpty();
    if (validator.hasErrors()) {
        return validator.getFirstError();
    }

    return {
        /**
         * Returns the cached value for the feature's element in a module.
         * @param   {String}  tenantid             The tenantId to get the config value from. e.g. `cam`
         * @param   {String}  feature              The feature to get the element's value from. e.g. `twitter`
         * @param   {String}  element              The element to get the config value from. e.g. `enabled`
         * @return  {Object}  cachedConfiguration  Returns a single configuration value for a feature's element in a module e.g. `true`
         */
        getValue: function(tenantId, feature, element) {
            var validator = new Validator();
            validator.check(tenantId, {'code': 400, 'msg': 'Missing the tenantid parameter'}).notEmpty();
            validator.check(feature, {'code': 400, 'msg': 'Missing the feature parameter'}).notEmpty();
            validator.check(element, {'code': 400, 'msg': 'Missing the element parameter'}).notEmpty();
            if (validator.hasErrors()) {
                return validator.getFirstError();
            }

            return cachedConfiguration[tenantId][moduleId][feature].elements[element].defaultValue;
        }
    };
};

/**
 * Writes configuration to Cassandra
 * @param  {String}    tenantId      The id of the tenant to store config for
 * @param  {Object}    configValues  The configuration to store
 * @param  {Function}  callback      Function executed when storing the configuration completes
 */
var writeConfig = module.exports.writeConfig = function(tenantId, configValues, callback) {
    var validator = new Validator();
    validator.check(tenantId, {'code': 400, 'msg': 'Missing tenantid'}).notEmpty();
    validator.check(_.keys(configValues).length, {'code': 400, 'msg': 'Missing configuration. Example configuration: {"oae-authentication/google-authentication/google-authentication-enabled": {"tenantid": "global","value": false}}'}).min(1);
    for (var i = 0; i < _.keys(configValues).length; i++) {
        validator.check(_.keys(configValues)[i], {'code': 400, 'msg': 'The configuration field cannot be null'}).not('null');
        validator.check(configValues[_.keys(configValues)[i]].toString(), {'code': 400, 'msg': 'The configuration value cannot be null'}).notNull();

        // We store objects as strings in Cassandra
        if (_.isObject(configValues[_.keys(configValues)[i]])) {
            configValues[_.keys(configValues)[i]] = JSON.stringify(configValues[_.keys(configValues)[i]]);
        }
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var q = Cassandra.constructUpsertCQL('Config', 'tenantId', tenantId, configValues, 'QUORUM');
    Cassandra.runQuery(q.query, q.parameters, function(err, config) {
        if (!err) {
            Pubsub.publish('oae-config', tenantId + ' config updated');
        }
        callback(err, config);
    });
};

/**
 * Reads the configuration values from cache and returns the object
 * @param  {String}    tenantId  The ID of the tenant to get configuration for
 * @param  {Function}  callback  Function executed after config has been read
 */
var getConfig = module.exports.getConfig = function(tenantId, callback) {
    var validator = new Validator();
    validator.check(tenantId, {'code': 400, 'msg': 'Missing tenantid'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    callback(false, cachedConfiguration[tenantId]);
};

/**
 * Reads the configuration values for a single tenant from Cassandra
 * @param  {String}    tenantId  The ID of the tenant to get configuration for
 * @param  {Function}  callback  Function executed after config has been read
 */
var getConfigFromCassandra = function(tenantId, callback) {
    var cqlParams = [OAE.serverTenant.alias];
    if (tenantId !== OAE.serverTenant.alias) {
        cqlParams.push(tenantId);
    }

    Cassandra.runQuery('SELECT * FROM Config USING CONSISTENCY QUORUM WHERE tenantId IN (?)', [cqlParams], function(err, rows) {
        if (err) {
            return callback(err);
        }

        getDefaultConfiguration(function(defaultConfig) {
            cachedConfiguration[tenantId] = mergeStoredConfigIntoOriginal(rows, defaultConfig);
            callback(false, cachedConfiguration[tenantId]);
        });
    });
};

/**
 * Merges the different configurations into one. config.json < global config < tenant config
 * @param   {Object}  cassandraConfig  Helenus object that contains configuration values stored in Cassandra. There will be one  row for the global tenant, and also one row for the current tenant if the current tenant  is not the global tenant
 * @param   {Object}  moduleConfig     Contains the aggregated configurations for all of the available modules
 * @return  {Object}                   All of the configuration values for all available modules, with values overriden if the current tenant has modifications to that config variable
 */
var mergeStoredConfigIntoOriginal = function(cassandraConfig, moduleConfig) {

    moduleConfig = cloneextend.clone(moduleConfig);

    // Loop over this as the config
    for (var r = 0; r < cassandraConfig.length; r++) {
        // Loop over all of the configured fields for the current tenant
        for (var c = 0; c < cassandraConfig[r].count; c++) {
            if (cassandraConfig[r][c].name !== 'tenantId') {
                // colHash looks like: ['moduleid', 'optionid', 'elementid']. e.g. ['oae-authentication', 'twitter', 'enabled']
                var colHash = cassandraConfig[r][c].name.split('/');
                if (moduleConfig[colHash[0]] && moduleConfig[colHash[0]][colHash[1]] && moduleConfig[colHash[0]][colHash[1]].elements[colHash[2]]) {
                    var parsedValue = Util.castToBoolean(Util.castToObject(cassandraConfig[r][c].value));
                    var schema = moduleConfig[colHash[0]][colHash[1]].schema;

                    // If there's a schema, use it
                    if (schema) {
                        for (var i = 0; i < _.keys(parsedValue).length; i++) {
                            parsedValue[_.keys(parsedValue)[i]] = cloneextend.extend(cloneextend.clone(schema), parsedValue[_.keys(parsedValue)[i]]);
                        }
                    }

                    // Overwrite/extend the module config with the stored config
                    cloneextend.extend(moduleConfig[colHash[0]][colHash[1]].elements[colHash[2]].defaultValue, parsedValue);
                }
            }
        }
    }

    return moduleConfig;
};

 /**
 * Retrieve all of the available modules and Filters out modules that don't have a configuration file in the config directory and fills an 
 * Array of modules with configuration. Every file in the /config directory of a module is read. It's assumed that the files contains valid JSON.
 * If multiple configuration files exist in one module they will be merged together.
 * @param  {Function}  callback                Callback function executed when filtering is complete. Passes through the filtered Array of config objects.
 * @param  {Object}    callback.defaultConfig  Object containing the default configuration for all of the configurable modules
 */
var getDefaultConfiguration = function(callback) {

    // Get the available module
    var modules = OAE.getAvailableModules();
    var configurableModules = {};
    var toDo = modules.length;
    var done = 0;

    /**
     * Gets the configuration files for a given module
     * @param  {String}  dir     The URL to a module's configuration directory. e.g. '/node_modules/oae-principals/config/'
     * @param  {String}  module  The module we're getting the configuration for. e.g. 'oae-principals'
     */
    var getConfigContent = function(dir, module) {
        IO.getFileListForFolder(dir, function(files) {
            for (var ii = 0; ii < files.length; ii++) {
                var content = require(module + '/config/' + files[ii]);
                configurableModules[module] = _.extend(configurableModules[module] || {}, content[module]);
            }
            done++;
            if (done === toDo) {
                callback(configurableModules);
            }
        });
    };

    for (var i = 0; i < modules.length; i++) {
        var dir = 'node_modules/' + modules[i] + '/config/';
        getConfigContent(dir, modules[i]);
    }
};

/**
 * Initializes and caches the configuration values for all tenants
 * @param  {Function}  callback                      Function executed after all tenant configuration has been retrieved
 * @param  {Object}    callback.cachedConfiguration  The retrieved and cached configuration for all tenants
 */
var initializeConfig = module.exports.initializeConfig = function(callback) {
    TenantAPI.getAllTenants(function(err, tenants) {
        var cqlParams = [OAE.serverTenant.alias];

        for (var t = 0; t < tenants.length; t++) {
            cqlParams.push(tenants[t].alias);
        }
        Cassandra.runQuery('SELECT * FROM Config USING CONSISTENCY QUORUM WHERE tenantId IN (?)', [cqlParams], function(err, rows) {
            if (err) {
                return callback(err);
            }

            getDefaultConfiguration(function(defaultConfig) {
                for (var r = 0; r < rows.length; r++) {
                    if (rows[r].get('tenantId').value === OAE.serverTenant.alias) {
                        cachedConfiguration[OAE.serverTenant.alias] = mergeStoredConfigIntoOriginal([rows[r]], defaultConfig);
                        break;
                    }
                }

                for (var rr = 0; rr < rows.length; rr++) {
                    if (rows[rr].get('tenantId').value !== OAE.serverTenant.alias) {
                        cachedConfiguration[rows[rr].get('tenantId').value] = mergeStoredConfigIntoOriginal([rows[rr]], cachedConfiguration[OAE.serverTenant.alias]);
                    }
                }

                callback(cachedConfiguration);
            });
        });
    });
};
