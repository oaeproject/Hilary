/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var Cassandra = require('oae-util/lib/cassandra');
var log = require('oae-logger').logger('content-dao');


///////////////
// Retrieval //
///////////////


/**
 * Get an array of preview items.
 *
 * @param  {String}     contentId           The ID of the piece of content for which the preview items should be retrieved.
 * @param  {Function}   callback            Invoked when the process compeletes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Object[]}   callback.previews   The preview objects.
 */
var getContentPreviews = module.exports.getContentPreviews = function(contentId, callback) {
    Cassandra.runQuery('SELECT * FROM ContentPreviews WHERE contentId = ?', [contentId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var previews = [];
        var filenames = Cassandra.rowToHash(rows[0]);
        delete filenames.contentId;
        _.each(filenames, function(value, filename) {
            var data = value.split('#');
            previews.push({
                'size': data[0],
                'uri': data[1],
                'filename': filename
            });
        });
        callback(null, previews);
    });
};

/**
 * Get a specific content preview.
 *
 * @param  {String}     contentId           The ID of the piece of content for which a preview item should be retrieved.
 * @param  {String}     previewItem         The name of the preview item that should be retrieved.
 * @param  {Function}   callback            Invoked when the process compeletes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Object}     callback.preview    The preview object.
 */
var getContentPreview = module.exports.getContentPreview = function(contentId, previewItem, callback) {
    Cassandra.runQuery('SELECT ? FROM ContentPreviews WHERE contentId = ?', [previewItem, contentId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        // Cassandra always returns a row with the rowKey as a column so there is always at least 1 row.
        // We retrieve a column that has the same name as requested preview item to verify it exists.
        var col = rows[0].get(previewItem);
        if (!col) {
            return callback({'code': 404, 'msg': "Couldn't find item " + previewItem + " for contentId: " + contentId});
        }
        var data = col.value.split('#');
        var preview = {
            'size': data[0],
            'uri': data[1]
        };
        callback(null, preview);
    });
};

/**
 * Get the previews object of all the content items listed by id in `contentIds`. The returned `previews` object
 * contains the standard `previews` object of the content, as well as the lastModified date of the content item
 * so that the preview URL may be determined:
 *
 * ```javascript
 *  {
 *      '<ContentId0>' {
 *          'lastModified': 123456789,
 *          'previews': { <ContentPreviews> }
 *      },
 *      ...
 *  }
 * ```
 *
 * @param  {String[]}   contentIds                  The list of content ids whose previews to get
 * @param  {Function}   callback                    Invoked when the process compeletes
 * @param  {Object}     callback.err                An error that occurred, if any
 * @param  {Object}     callback.contentPreviews    An object keyed by `contentId` whose value contains the lastModified date of the content and its associated previews. If the content has no valid preview object, then its contentId will not be found as a key in this object.
 */
var getContentPreviewsMetadata = module.exports.getContentPreviewsMetadata = function(contentIds, callback) {
    if (!contentIds || !contentIds.length) {
        return callback(null, {});
    }

    Cassandra.runQuery('SELECT lastModified, previews FROM Content WHERE contentId IN (?)', [contentIds], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var previews = {};
        rows.forEach(function(row) {
            var lastModified = row.get('lastModified');
            var preview = row.get('previews');
            if (preview && preview.value && lastModified && lastModified.value) {
                lastModified = lastModified.value;
                try {
                    preview = JSON.parse(preview.value);
                } catch (err) {
                    log().warn({'contentId': row.key, 'previews': preview.value}, 'Could not parse preview data for content item.');
                    return;
                }

                previews[row.key] = {'lastModified': lastModified, 'previews': preview};
            }
        });

        return callback(null, previews);
    });
};


///////////////
// Modifiers //
///////////////


/**
 * Stores preview metadata on the Content object in Cassandra.
 * This method will:
 *  1/ Remove old preview items associated to the piece of content (if any)
 *  2/ Remove the old thumbnailUri (if one was present), if `thumbnailUri` is not defined.
 *  3/ Store the new preview URIs (if any)
 *  4/ Update the previews object in the Content CF.
 *
 * @param {Content}     contentObj      The ID of the piece of content for which we need to update the preview metadata.
 * @param {String}      status          The result of the preview processing operation. It should be one of the values of ContentConstants.previews.
 * @param {String}      thumbnailUri    The uri of a thumbnail
 * @param {Object}      metadata        Each key corresponds to a string value that should be stored on the content object.
 * @param {Object}      fileData        Each key corresponds to a filename, the value is of the form 'size#uri'.
 * @param {Function}    callback        Standard callback method
 * @param {Object}      callback.err    Standard error object (if any.)
 */
var storeMetadata = module.exports.storeMetadata = function(contentObj, status, thumbnailUri, metadata, fileData, callback) {
    var queries = [];
    // 1. Remove the old previews
    if (contentObj.previews.total && contentObj.previews.total > 0) {
        queries.push({
            'query': 'DELETE FROM ContentPreviews WHERE contentId = ?',
            'parameters': [contentObj.id]
        });
    }

    // 2. Remove the thumbnail URI if we don't add in a new one.
    if (contentObj.thumbnailUri && !thumbnailUri) {
        queries.push({
            'query': 'DELETE thumbnailUri FROM Content WHERE contentId = ?',
            'parameters': [contentObj.id]
        });
    }
    // 3. Add in the new preview items (if any.)
    var nrOfFiles = Object.keys(fileData).length;
    if (nrOfFiles > 0) {
        queries.push(Cassandra.constructUpsertCQL('ContentPreviews', 'contentId', contentObj.id, fileData));
    }

    // 4. Store the previews object.
    var data = {'status': status, 'total': nrOfFiles};
    // Set the thumbnail URI if we have one.
    if (thumbnailUri) {
        data.thumbnailUri = thumbnailUri;
    }
    // Pass in data second, in case metadata contains a status or thumbnailUri key.
    var previews = _.extend({}, metadata, data);
    contentObj.previews = previews;

    previews = JSON.stringify(previews);
    queries.push({
        'query': 'UPDATE Content SET previews = ? WHERE contentId = ?',
        'parameters': [previews, contentObj.id]
    });

    // Save the data.
    Cassandra.runBatchQuery(queries, 'QUORUM', callback);
};
