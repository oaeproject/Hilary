/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var Crypto = require('crypto');
var fs = require('fs');

var log = require('oae-logger').logger('signature');

var Validator = require('oae-util/lib/validator').Validator;


var privKey = null;
var pubKey = null;

/**
 * Read the key files.
 */
var init = module.exports.init = function() {
    privKey = fs.readFileSync('key.pem').toString('ascii');
    pubKey = fs.readFileSync('key.pub').toString('ascii');

    var defaultKey = "MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAJzVDZcFhH64XcGy9neYgOsGNpojBxxg\nrJaUSr0cyl4PcWrVwWL6UtWZGiycnqbK49wCakMYdxFZm2T0mxCQw30CAwEAAQ==";


    // Complain very loud if the keys have not been changed.
    if (pubKey.indexOf(defaultKey) !== -1) {
        // TODO: This will most likely end-up in bootstrap.log, which might be overlooked, console.log?
        var warningMessage = 'You are using the default keys to sign URLs, this is *NOT* secure and should be changed immediately.\n';
        warningMessage += 'The system will continue to function, but it is strongly recommended that you change your keys.\n';
        warningMessage += 'If you have OpenSSL installed you can generate a key by running:\n';
        warningMessage += '  openssl genrsa -out key.pem 1024\n';
        warningMessage += '  openssl rsa -in mykey.pem -pubout > key.pub\n';
        warningMessage += 'Make sure that each app server has the same set of keys though.';
        log().warn(warningMessage);
    }
};

/**
 * Sign a string with our private key.
 *
 * @param  {String}  tenantAlias    The alias that identifies which tenant this message originates from.
 * @param  {String}  body           The string to sign.
 * @return {String}                 A signature.
 */
var sign = module.exports.sign = function(tenantAlias, body) {
    var signer = Crypto.createSign('RSA-SHA256');
    var msg = tenantAlias + '#' + body;
    signer.update(msg);
    return signer.sign(privKey, 'hex');
};

/**
 * Verify that the passed in signature matches the body.
 *
 * @param  {String}     tenantAlias     The alias that identifies which tenant the message originated from.
 * @param  {String}     body            The body that was originally signed.
 * @param  {String}     signature       The signature that was passed in by the user.
 * @return {Boolean}                    Whether or not the body was untampered with
 */
var verify = module.exports.verify = function(tenantAlias, body, signature) {
    var verifier = Crypto.createVerify('RSA-SHA256');
    var msg = tenantAlias + '#' + body;
    verifier.update(msg);
    return verifier.verify(pubKey, signature, 'hex');
};

/**
 * Creates a signature that is valid for `expires` amount of minutes.
 *
 * @param  {String}     tenantAlias     The alias that identifies which tenant this message originates from.
 * @param  {Number}     expires         The number of minutes this signature is valid.
 * @param  {String}     body            The body that needs signing
 * @return {Object}                     An object with a `signature` key that holds the signature and a `expires` key which holds the timestamp when the signature will expire.
 */
var createExpiringSignature = module.exports.createExpiringSignature = function(tenantAlias, expires, body) {
    var ts = Date.now() + (expires * 60000);
    var msg = ts + '#' + body;
    var signature = sign(tenantAlias, msg);
    return {
        'signature': signature,
        'expires' : ts
    };
};

/**
 * Verifies if the signature matches a given body.
 * The `expires` value will be taken into account and checked against the current time.
 *
 * @param  {String}     tenantAlias     The alias that identifies which tenant the message originated from.
 * @param  {Number}     expires         A timestamp in ms when this signature expires.
 * @param  {String}     body            The body that the signature was placed on.
 * @param  {String}     signature       The signature as generated by `createExpiringSignature`.
 * @return {Boolean}                    Whether or not the signature is valid.
 */
var verifyExpiringSignature = module.exports.verifyExpiringSignature = function(tenantAlias, expires, body, signature) {
    // Check the expiry date.
    if (Date.now() > expires) {
        return false;
    }

    // Check the signature.
    var msg = expires + '#' + body
    return verify(tenantAlias, msg, signature);
};



/**
 * Creates a signature that is valid till the `expiresAt` date.
 *
 * @param  {String}     tenantAlias     The alias that identifies which tenant this message originates from.
 * @param  {Date}       expiresAt       The date when the signature should expire.
 * @param  {String}     body            The body that needs signing
 * @return {Object}                     An object with a `signature` key that holds the signature and an `expires` key which holds the timestamp when the signature will expire.
 */
var createExpiresAtSignature = module.exports.createExpiresAtSignature = function(tenantAlias, expiresAt, body) {
    var msg = expiresAt.getTime() + '#' + body;
    var signature = sign(tenantAlias, msg);
    return {
        'signature': signature,
        'expires' : expiresAt.getTime()
    };
};

/**
 * Check whether or not a signature is valid.
 *
 * @param  {String} tenantAlias     The alias that identifies which tenant the message originated from.
 * @param  {String} body            The body that was used to generate the signature.
 * @see verify
 */
Validator.prototype.verifySignature = function(tenantAlias, body) {
    if (!this.str || !verify(tenantAlias, body, this.str)) {
        this.error(this.msg || 'Invalid signature');
    }
    return this;
};

/**
 * Check whether or not an expiring signature is valid.
 *
 * @param  {String} tenantAlias     The alias that identifies which tenant the message originated from.
 * @param  {Number} expires         The timestamp in ms when the signature expires.
 * @param  {String} body            The body that was used to generate the signature.
 * @see verifyExpiringSignature
 */
Validator.prototype.verifyExpiringSignature = function(tenantAlias, expires, body) {
    if (!this.str || !verifyExpiringSignature(tenantAlias, expires, body, this.str)) {
        this.error(this.msg || 'Invalid signature');
    }
    return this;
};
