/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzUtil = require('oae-authz/lib/util');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var PrincipalsUtil = require('oae-principals/lib/util');
var TenantsUtil = require('oae-tenants/lib/util');

var DiscussionsConstants = require('./constants').DiscussionsConstants;

/**
 * Determine whether or not the user in context can view the provided discussion.
 *
 * @param  {Context}    ctx                 The context of the current request
 * @param  {Discussion} discussion          The discussion to test for access
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.canView    `true` if the user in context has the appropriate permission. `false` otherwise.
 */
var canViewDiscussion = module.exports.canViewDiscussion = function(ctx, discussion, callback) {
    var user = ctx.user();
    AuthzAPI.resolveImplicitRole(ctx, discussion.id, discussion.tenant.alias, discussion.visibility, DiscussionsConstants.roles.ALL_PRIORITY, function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (implicitRole) {
            // We have an implicit access, no reason to try and find an explicit access because we can atleast view
            return callback(null, true);
        } else if (!user) {
            // Anonymous user with no implicit access cannot view
            return callback(null, false);
        }

        // By this point, we only have access to view if we have a role on the item
        return AuthzAPI.hasAnyRole(user.id, discussion.id, callback);
    });
};

/**
 * Determine whether or not the user in context can manage the provided discussion.
 *
 * @param  {Context}    ctx                 The context of the current request
 * @param  {Discussion} discussion          The discussion to test for access
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.canManage  `true` if the user in context has the appropriate permission. `false` otherwise.
 */
var canManageDiscussion = module.exports.canManageDiscussion = function(ctx, discussion, callback) {
    var user = ctx.user();

    // Anonymous can never manage
    if (!user) {
        return callback(null, false);
    }

    AuthzAPI.resolveImplicitRole(ctx, discussion.id, discussion.tenant.alias, discussion.visibility, DiscussionsConstants.roles.ALL_PRIORITY, function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (implicitRole === DiscussionsConstants.roles.MANAGER) {
            // We have an implicit management role (e.g., we are an administrator), return true
            return callback(null, true);
        }

        // By this point, we can only manage if we have explicit manager role
        return AuthzAPI.hasRole(user.id, discussion.id, DiscussionsConstants.roles.MANAGER, callback);
    });
};

/**
 * Determine whether or not the user in context can share the provided discussion with the principalIds
 * provided. `canShare` can be `false` either if the user doesn't have appopriate permission to share the
 * discussion, or if sharing with some target principals violates tenant boundaries.
 *
 * @param  {Context}    ctx                             The context of the current request
 * @param  {Discussion} discussion                      The discussion to test for access
 * @param  {String[]}   principalIds                    The principalIds with which the user wishes to share the discussion
 * @param  {Function}   callback                        Invoked when the process completes
 * @param  {Object}     callback.err                    An error that occurred, if any
 * @param  {Boolean}    callback.canShare               `true` if the user in context is allowed to perform this share operation. `false` otherwise
 * @param  {String[]}   [callback.illegalPrincipalIds]  If the check failed because of a tenant boundary violation, this will be an array of principalIds that were in violation
 */
var canShareDiscussion = module.exports.canShareDiscussion = function(ctx, discussion, principalIds, callback) {
    var user = ctx.user();

    // Anonymous users can never share
    if (!user) {
        return callback(null, false);
    }

    // Get the principal objects for the principals we wish to share with
    // We need to grab them from the DAO as we might need the full object in the authz API
    PrincipalsDAO.getPrincipals(principalIds, null, function(err, principals) {
        if (err) {
            return callback(err);
        } else if (_.keys(principals).length !== principalIds.length) {
            return callback({'code': 400, 'msg': 'One or more target members being granted access do not exist'});
        }

        principals = _.values(principals);

        // Verify that the current user can interact with the content and the specified principals
        AuthzAPI.canInteract(ctx, discussion.tenant.alias, principals, function(err, canInteract, illegalPrincipalIds) {
            if (err) {
                return callback(err);
            } else if (!canInteract) {
                return callback(null, false, illegalPrincipalIds);
            }

            AuthzAPI.resolveImplicitRole(ctx, discussion.id, discussion.tenant.alias, discussion.visibility, DiscussionsConstants.roles.ALL_PRIORITY, function(err, implicitRole, canInteract) {
                if (err) {
                    return callback(err);
                } else if (implicitRole === DiscussionsConstants.roles.MANAGER) {
                    // Managers can always share
                    return callback(null, true);
                } else if (canInteract) {
                    // If we can interact with the item, we can always share it
                    return callback(null, true);
                }

                // If the discussion is private, only managers can share it
                if (discussion.visibility === AuthzConstants.visibility.PRIVATE) {
                    AuthzAPI.hasRole(user.id, discussion.id, DiscussionsConstants.roles.MANAGER, function(err, hasRole) {
                        return callback(err, hasRole);
                    });
                    return;
                }

                // At this point, we have to see if the user has any explicit role on the resource to see if they can share it
                AuthzAPI.hasAnyRole(user.id, discussion.id, function(err, hasAnyRole) {
                    return callback(err, hasAnyRole);
                });
            });
        });
    });
};

/**
 * Determine whether or not the user in context can update the permissions of the provided discussion. Since tenant boundaries
 * allow that existing members of discussions can have their membership changed (even if their tenant has since become private)
 * and members may be removed even if they cross private tenant boundaries, the `addMemberIds` array should only contain ids of
 * members who don't already exist as members on the discussion.
 *
 * @param  {Context}    ctx                         The context of the current request
 * @param  {Discussion} discussion                  The discussion to test for access
 * @param  {String[]}   addMemberIds                An array of ids of members that are being **added** to the discussion
 * @param  {Function}   callback                    Invoked when the process completes
 * @param  {Object}     callback.err                An error that occurred, if any
 * @param  {Boolean}    callback.canSetPermissions  `true` if the user in context has the appropriate permission. `false` otherwise.
 */
var canSetDiscussionPermissions = module.exports.canSetDiscussionPermissions = function(ctx, discussion, addMemberIds, callback) {
    // Only managers can set the permissions of any discussion, regardless of privacy rules
    if (!ctx.user()) {
        return callback({'code': 401, 'msg': 'You must be authenticated to update permissions of a discussion'});
    }

    // Get the principal objects for the principals we wish to change the permissions
    // We need to grab them from the DAO as we might need the full object in the authz API
    PrincipalsDAO.getPrincipals(addMemberIds, null, function(err, principals) {
        if (err) {
            return callback(err);
        } else if (_.keys(principals).length !== addMemberIds.length) {
            return callback({'code': 400, 'msg': 'One or more target members being granted access do not exist'});
        }

        principals = _.values(principals);

        // Verify that the current user can interact with the content and the specified principals
        AuthzAPI.canInteract(ctx, discussion.tenant.alias, principals, function(err, canInteract, illegalPrincipalIds) {
            if (err) {
                return callback(err);
            } else if (!canInteract) {
                return callback(null, false, illegalPrincipalIds);
            }

            // Boundaries are all good, perform the manager check
            return canManageDiscussion(ctx, discussion, callback);
        });
    });
};

/**
 * Determine whether or not the user in context can post a message in the provided discussion.
 *
 * @param  {Context}    ctx                 The context of the current request
 * @param  {Discussion} discussion          The discussion to test for access
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.canPost    `true` if the user in context has the appropriate permission. `false` otherwise.
 */
var canPostDiscussionMessage = module.exports.canPostDiscussionMessage = function(ctx, discussion, callback) {
    var user = ctx.user();

    if (!user) {
        // Anonymous can never post to a discussion
        return callback(null, false);
    }

    AuthzAPI.resolveImplicitRole(ctx, discussion.id, discussion.tenant.alias, discussion.visibility, DiscussionsConstants.roles.ALL_PRIORITY, function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (implicitRole === DiscussionsConstants.roles.MANAGER) {
            // Implicit managers can always post, regardless of tenant
            return callback(null, true);
        } else if (canInteract) {
            // If we can interact with the item, we can always post to it
            return callback(null, true);
        }

        // See if this user has any explicit role, if so they can post
        return AuthzAPI.hasAnyRole(user.id, discussion.id, callback);
    });
};

/**
 * Determine whether or not the user in context can delete the provided message in the provided discussion.
 *
 * @param  {Context}    ctx                 The context of the current request
 * @param  {Discussion} discussion          The discussion to test for access
 * @param  {Message}    message             The message to test for access
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.canDelete  `true` if the user in context has the appropriate permission. `false` otherwise.
 */
var canDeleteDiscussionMessage = module.exports.canDeleteDiscussionMessage = function(ctx, discussion, message, callback) {
    var user = ctx.user();

    if (!user) {
        return callback(null, false);
    }

    AuthzAPI.resolveImplicitRole(ctx, discussion.id, discussion.tenant.alias, discussion.visibility, DiscussionsConstants.roles.ALL_PRIORITY, function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (implicitRole === DiscussionsConstants.roles.MANAGER) {
            // Managers can always delete messages
            return callback(null, true);
        } else if (canInteract && message.createdBy === user.id) {
            // The user is still able to interact with this tenant, they can delete their own message
            return callback(null, true);
        }

        // It's not our message, or we cannot implicitly interact. We need explicit manager access to delete the message
        return AuthzAPI.hasRole(user.id, discussion.id, DiscussionsConstants.roles.MANAGER, callback);
    });
};

/**
 * Determine the full set of access that the user in context has on the discussion
 *
 * @param  {Context}    ctx                 The context of the current request
 * @param  {Discussion} discussion          The discussion to test for access
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.canView    `true` if the user in context can view the discussion. `false` otherwise.
 * @param  {Boolean}    callback.canManage  `true` if the user in context can manage the discussion. `false` otherwise.
 * @param  {Boolean}    callback.canShare   `true` if the user in context can share the discussion. `false` otherwise.
 * @param  {Boolean}    callback.canPost    `true` if the user in context can post a message in the discussion. `false` otherwise.
 * @param  {Boolean}    callback.isManager  `true` if the user in context is an explicit manager of the discussion. `false` otherwise.
 * @param  {Boolean}    callback.isMember   `true` if the user in context is an explicit viewer of the discussion. `false` otherwise.
 */
var resolveEffectiveDiscussionAccess = module.exports.resolveEffectiveDiscussionAccess = function(ctx, discussion, callback) {
    if (!ctx.user()) {
        return callback(null, (discussion.visibility === AuthzConstants.visibility.PUBLIC), false, false, false, false, false);
    }

    // Resolve the implicit role this user has on the discussion
    AuthzAPI.resolveImplicitRole(ctx, discussion.id, discussion.tenant.alias, discussion.visibility, DiscussionsConstants.roles.ALL_PRIORITY, function(err, implicitRole, implicitInteract) {
        if (err) {
            return callback(err);
        }

        // Get the explicit roles the user holds on the discussion
        AuthzAPI.getAllRoles(ctx.user().id, discussion.id, function(err, roles) {
            if (err) {
                return callback(err);
            }

            var hasRole = (roles.length > 0);
            var isMember = _.contains(roles, DiscussionsConstants.roles.MEMBER);
            var isManager = _.contains(roles, DiscussionsConstants.roles.MANAGER);

            // Explicit managers or tenant/global admins can manage the discussion
            var canManage = isManager || ctx.user().isAdmin(discussion.tenant.alias);

            // You can view the discussion if the visibility settings allow it or when you have an explicit role on it or when you can manage it
            var canView = implicitInteract || _.isString(implicitRole) || isMember || canManage;

            // You can interact with the discussion either via the implicit visibility settings or when you have a role on it
            var canInteract = implicitInteract || hasRole;

            // Anybody who can "interact" with the discussion can post to it
            var canPost = canInteract;

            // Anyone who can "interact" can share, unless the discussion is private. In that case, only managers can share
            var canShare = canInteract;
            if (discussion.visibility === AuthzConstants.visibility.PRIVATE) {
                canShare = canManage;
            }

            return callback(null, canView, canManage, canShare, canPost, isManager, isMember);
        });
    });
};
