/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var Cassandra = require('oae-util/lib/cassandra');
var log = require('oae-logger').logger('content-dao');

var Content = require('oae-content/lib/model').Content;


/**
 * Get a content's basic profile information based on a pooled content id
 *
 * @param  {String}         contentId           The id of the content object we want to retrieve
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Content}        callback.contentObj Retrieved content object
 */
var getContent = module.exports.getContent = function(contentId, callback) {
    Cassandra.runQuery('SELECT * FROM Content USING CONSISTENCY QUORUM WHERE contentId = ?', [contentId], function (err, rows) {
        if (err) {
            return callback(err);
        }

        // Cassandra always returns the key as a column so the count will always be 1.
        // TODO: https://github.com/sakaiproject/Hilary/issues/251
        if (rows[0].count <= 2) {
            return callback({'code': 404, 'msg': "Couldn't find content: " + contentId}, null);
        }

        var contentObj = _rowToContent(rows[0]);
        return callback(null, contentObj);
    });
};

/**
 * Get multiple content basic profiles at the same time based on their content ids.
 *
 * @param  {String[]}       contentIds          Array of content object ids we want to retrieve. The content profiles will be returned in the same order
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `contentObj`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Content[]}      callback.contentObj Retrieved content objects
 */
var getMultipleContentItems = module.exports.getMultipleContentItems = function(contentIds, callback) {
    if (contentIds.length) {
        Cassandra.runQuery('SELECT * FROM Content USING CONSISTENCY QUORUM WHERE contentId IN (?)', [contentIds], function(err, rows) {
            if (err) {
                return callback(err);
            }
            // Iterate over the content items.
            for (var i = 0; i < rows.length; i++) {
                var contentObj = _rowToContent(rows[i]);
                contentIds[_.indexOf(contentIds, contentObj.id)] = contentObj;
            }
            callback(null, contentIds);
        });
    } else {
        callback(null, []);
    }
};

/**
 * Get a user's or group's library. This function assumes that all permission check will have
 * been done and the processed principal id is passed in. It also assumes that a valid start and limit parameter are passed in.
 *
 * @param  {String}         libraryId         The library id of the library we're requesting. This is the processed library principal id, meaning that it will be the principal id when direct access is allowed, principalId#loggedin if the user is logged to the tenant, or principalId#public for otherwise unprivileged users
 * @param  {String}         start             Determines the point at which content items are returned for paging purposed.  If not provided, the first x elements will be returned
 * @param  {Integer}        limit             Number of items to return. Will default to 10 if not provided
 * @param  {Function}       callback          Standard callback function takes arguments `err` and `content`
 * @param  {Object}         callback.err      Error object containing the error message
 * @param  {Content[]}      callback.content  Array of basic content profiles representing the requested items in the library
 */
var getLibraryItems = module.exports.getLibraryItems = function(principalId, start, limit, callback) {
    // Page the query.
    var paging = Cassandra.getPagingParameters(start, limit);

    Cassandra.runQuery('SELECT FIRST ' + paging.limit + ' REVERSED ?..\'\' FROM LibraryByPrincipal USING CONSISTENCY QUORUM WHERE principalId = ?', [paging.start, principalId], function (err, rows) {
        if (err) {
            return callback(err);
        }

        var items = [];
        for (var r = paging.startIndex; r < rows[0].count; r++) {
            items.push(rows[0][r].value);
        }
        // Get the content profiles of the content items, assuming that
        // we have access to all of the returned items
        getMultipleContentItems(items, callback);
    });
};

/**
 * Iterate through all the content items. This will return just the raw content properties that are specified in the `properties`
 * parameter, and only `batchSize` content items at a time. On each iteration of `batchSize` content items, the `onEach` callback
 * will be invoked, and the next batch will not be fetched until you have invoked the `onEach.done` function parameter. When
 * complete (e.g., there are 0 content items left to iterate through or an error has occurred), the `callback` parameter will be
 * invoked.
 *
 * @param  {String[]}   [properties]        The names of the content properties to return in the content objects. If not specified (or is empty array), it returns just the `contentId`s
 * @param  {Number}     [batchSize]         The number of content items to fetch at a time. Defaults to 100
 * @param  {Function}   onEach              Invoked with each batch of content items that are fetched from storage
 * @param  {Object}     onEach.contentRow   An object holding the raw content data that was fetched from storage
 * @param  {Function}   onEach.done         The function to invoke when processing of the current batch is complete
 * @param  {Object}     onEach.done.err     An error that occurred, if any, while processing the current batch. If you specify this error, iteration will finish and the completion callback will be invoked
 * @param  {Function}   [callback]          Invoked when all rows have been iterated, or an error has occurred
 * @param  {Object}     [callback.err]      An error that occurred, while iterating rows, if any
 * @see Cassandra#iterateAll
 */
var iterateAll = module.exports.iterateAll = function(properties, batchSize, onEach, callback) {
    if (!properties || !properties.length) {
        properties = ['contentId'];
    }

    var opts = {
        'batchSize': batchSize,
        'consistency': 'ONE',
        'slugColumnName': 'visibility'
    };

    /*!
     * Handles each batch from the cassandra iterateAll method.
     *
     * @see Cassandra#iterateAll
     */
    var _iterateAllOnEach = function(rows, done) {
        // Convert the rows to a hash and delegate action to the caller onEach method
        var hashedRows = [];
        rows.forEach(function(row) {
            hashedRows.push(Cassandra.rowToHash(row));
        });

        return onEach(hashedRows, done);
    };

    Cassandra.iterateAll(properties, 'Content', 'contentId', opts, _iterateAllOnEach, callback);
};


///////////////////////
// Utility functions //
///////////////////////

/**
 * Creates a Content item from a Cassandra row.
 *
 * @param  {Row}        row     Cassandra Row
 * @return {Content}            Converted content object
 * @api private
 */
var _rowToContent = function(row) {
    var hash = Cassandra.rowToHash(row);
    var contentObj = new Content(hash.tenant, hash.contentId, hash.visibility, hash.displayName, hash.description, hash.contentType, hash.createdBy, hash.created, hash.lastModified);
    if (contentObj.contentType === 'file') {
        contentObj.filename = hash.filename;
        contentObj.size = (hash.size) ? parseInt(hash.size, 10) : 0;
        contentObj.mime = hash.mime;
        contentObj.downloadPath = '/api/content/' + contentObj.id + '/download';
    } else if (contentObj.contentType === 'link') {
        contentObj.link = hash.link;
    }

    try {
        contentObj.previews = JSON.parse(hash.previews);
    } catch (err) {
        contentObj.previews = {};
        log().warn({'hash': hash}, 'Could not parse the previews object.');
    }
    return contentObj;
};
