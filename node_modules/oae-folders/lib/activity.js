/*
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var ActivityAPI = require('oae-activity');
var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;
var ActivityModel = require('oae-activity/lib/model');
var ActivityUtil = require('oae-activity/lib/util');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzUtil = require('oae-authz/lib/util');
var ContentConstants = require('oae-content/lib/constants').ContentConstants;
var ContentUtil = require('oae-content/lib/internal/util');
var MessageBoxAPI = require('oae-messagebox');
var MessageBoxUtil = require('oae-messagebox/lib/util');
var PreviewConstants = require('oae-preview-processor/lib/constants');
var PrincipalsUtil = require('oae-principals/lib/util');
var TenantsUtil = require('oae-tenants/lib/util');

var FoldersAPI = require('oae-folders');
var FoldersConstants = require('oae-folders/lib/constants').FoldersConstants;
var FoldersDAO = require('oae-folders/lib/internal/dao');

///////////////////
// FOLDER-CREATE //
///////////////////

ActivityAPI.registerActivityType(FoldersConstants.activity.ACTIVITY_FOLDER_CREATE, {
    'groupBy': [{'actor': true, 'target': true}],
    'streams': {
        'activity': {
            'router': {
                'actor': ['self', 'followers'],
                'object': ['self', 'members']
            }
        },
        'notification': {
            'router': {
                'object': ['members']
            }
        },
        'email': {
            'router': {
                'object': ['members']
            }
        }
    }
});

/*!
 * Post a folder-create activity when a user creates a folder
 */
FoldersAPI.on(FoldersConstants.events.CREATED_FOLDER, function(ctx, folder, memberChangeInfo) {
    var millis = Date.now();
    var actorResource = new ActivityModel.ActivitySeedResource('user', ctx.user().id, {'user': ctx.user()});
    var objectResource = new ActivityModel.ActivitySeedResource('folder', folder.id, {'folder': folder});
    var targetResource = null;

    // Get the extra members
    var extraMembers = _.chain(memberChangeInfo.members.added)
        .pluck('id')
        .without(ctx.user().id)
        .value();

    // If we only added 1 extra user or group, we set the target to that entity
    if (extraMembers.length === 1) {
        var targetResourceType = (PrincipalsUtil.isGroup(extraMembers[0])) ? 'group' : 'user';
        targetResource = new ActivityModel.ActivitySeedResource(targetResourceType, extraMembers[0]);
    }

    // Generate the activity seed and post it to the queue
    var activitySeed = new ActivityModel.ActivitySeed(FoldersConstants.activity.ACTIVITY_FOLDER_CREATE, millis, ActivityConstants.verbs.CREATE, actorResource, objectResource, targetResource);
    ActivityAPI.postActivity(ctx, activitySeed);
});


//////////////////////////
// FOLDER-ADD-TO-FOLDER //
//////////////////////////

ActivityAPI.registerActivityType(FoldersConstants.activity.ACTIVITY_FOLDER_ADD_TO_FOLDER, {
    // Simon added Content A and B to folder X
    // Simon added Content A, B and C to folder Y
    'groupBy': [{'target': true}],
    'streams': {
        'activity': {
            'router': {
                'actor': ['self', 'followers'],
                'object': ['managers'],
                'target': ['members']
            }
        },
        'notification': {
            'router': {
                'target': ['members']
            }
        },
        'email': {
            'router': {
                'target': ['members']
            }
        }
    }
});

/*!
 * Post a folder-add-to-folder activity when a user adds content items to a folder
 */
FoldersAPI.on(FoldersConstants.events.ADDED_CONTENT_ITEMS, function(ctx, actionContext, folder, contentItems) {
    // Ignore activities triggered by content-create
    if (actionContext !== 'content-create') {
        var millis = Date.now();
        var actorResource = new ActivityModel.ActivitySeedResource('user', ctx.user().id, {'user': ctx.user()});
        var targetResource = new ActivityModel.ActivitySeedResource('folder', folder.id, {'folder': folder});
        _.each(contentItems, function(content) {
            var objectResource = new ActivityModel.ActivitySeedResource('content', content.id, {'content': content});
            var activitySeed = new ActivityModel.ActivitySeed(FoldersConstants.activity.ACTIVITY_FOLDER_ADD_TO_FOLDER, millis, ActivityConstants.verbs.ADD, actorResource, objectResource, targetResource);
            ActivityAPI.postActivity(ctx, activitySeed);
        });
    }
});


///////////////////////////////////////////////
// FOLDER-UPDATE and FOLDER-UPDATE-VISIBILITY//
///////////////////////////////////////////////

ActivityAPI.registerActivityType(FoldersConstants.activity.ACTIVITY_FOLDER_UPDATE, {
    'groupBy': [{'actor': true}],
    'streams': {
        'activity': {
            'router': {
                'actor': ['self'],
                'object': ['self', 'members']
            }
        },
        'notification': {
            'router': {
                'object': ['managers']
            }
        },
        'email': {
            'router': {
                'object': ['managers']
            }
        }
    }
});

ActivityAPI.registerActivityType(FoldersConstants.activity.ACTIVITY_FOLDER_UPDATE_VISIBILITY, {
    'groupBy': [{'actor': true}],
    'streams': {
        'activity': {
            'router': {
                'actor': ['self'],
                'object': ['self', 'members']
            }
        },
        'notification': {
            'router': {
                'object': ['managers']
            }
        },
        'email': {
            'router': {
                'object': ['managers']
            }
        }
    }
});

/*!
 * Post a folder-update activity when a user updates a folder
 */
FoldersAPI.on(FoldersConstants.events.UPDATED_FOLDER, function(ctx, oldFolder, updatedFolder) {
    var millis = Date.now();
    var actorResource = new ActivityModel.ActivitySeedResource('user', ctx.user().id, {'user': ctx.user()});
    var objectResource = new ActivityModel.ActivitySeedResource('folder', updatedFolder.id, {'folder': updatedFolder});

    var activityType = null;
    if (updatedFolder.visibility !== oldFolder.visibility) {
        activityType = FoldersConstants.activity.ACTIVITY_FOLDER_UPDATE_VISIBILITY;
    } else {
        activityType = FoldersConstants.activity.ACTIVITY_FOLDER_UPDATE;

    }
    var activitySeed = new ActivityModel.ActivitySeed(activityType, millis, ActivityConstants.verbs.UPDATE, actorResource, objectResource);
    ActivityAPI.postActivity(ctx, activitySeed);
});


////////////////////
// FOLDER-COMMENT //
////////////////////

ActivityAPI.registerActivityType(FoldersConstants.activity.ACTIVITY_FOLDER_COMMENT, {
    'groupBy': [{'target': true}],
    'streams': {
        'activity': {
            'router': {
                'actor': ['self'],
                'target': ['message-contributors', 'members']
            }
        },
        'notification': {
            'router': {
                'target': ['message-contributors', 'members']
            }
        },
        'email': {
            'router': {
                'target': ['message-contributors', 'members']
            }
        },
        'message': {
            'transient': true,
            'router': {

                // Route the activity to the folder
                'target': ['self']
            }
        }
    }
});

/*!
 * Post a folder-comment activity when a user comments on a folder
 */
FoldersAPI.on(FoldersConstants.events.CREATED_COMMENT, function(ctx, message, folder) {
    var millis = Date.now();
    var actorResource = new ActivityModel.ActivitySeedResource('user', ctx.user().id, {'user': ctx.user()});
    var objectResource = new ActivityModel.ActivitySeedResource('folder-comment', message.id, {'folderId': folder.id, 'message': message});
    var targetResource = new ActivityModel.ActivitySeedResource('folder', folder.id, {'folder': folder});
    var activitySeed = new ActivityModel.ActivitySeed(FoldersConstants.activity.ACTIVITY_FOLDER_COMMENT, millis, ActivityConstants.verbs.POST, actorResource, objectResource, targetResource);
    ActivityAPI.postActivity(ctx, activitySeed);
});


////////////////////////////////////////////////
// FOLDER-SHARE and FOLDER-UPDATE-MEMBER-ROLE //
////////////////////////////////////////////////

ActivityAPI.registerActivityType(FoldersConstants.activity.ACTIVITY_FOLDER_ADD_TO_LIBRARY, {
    // "Branden Visser added 5 folders to his library"
    'groupBy': [{'actor': true}],
    'streams': {
        'activity': {
            'router': {
                'actor': ['self', 'followers'],
                'object': ['managers']
            }
        }
    }
});

ActivityAPI.registerActivityType(FoldersConstants.activity.ACTIVITY_FOLDER_SHARE, {
    'groupBy': [
        // "Branden Visser shared Folder with 5 users and groups"
        {'actor': true, 'object': true},

        // "Branden Visser shared 8 folders with OAE Team"
        {'actor': true, 'target': true}
    ],
    'streams': {
        'activity': {
            'router': {
                'actor': ['self', 'followers'],
                'object': ['managers'],
                'target': ['self', 'members', 'followers']
            }
        },
        'notification': {
            'router': {
                'target': ['self']
            }
        },
        'email': {
            'router': {
                'target': ['self']
            }
        }
    }
});

ActivityAPI.registerActivityType(FoldersConstants.activity.ACTIVITY_FOLDER_UPDATE_MEMBER_ROLE, {
    'groupBy': [{'actor': true, 'target': true}],
    'streams': {
        'activity': {
            'router': {
                'actor': ['self'],
                'object': ['self', 'members'],
                'target': ['managers']
            }
        }
    }
});

FoldersAPI.on(FoldersConstants.events.UPDATED_FOLDER_MEMBERS, function(ctx, folder, memberChangeInfo, opts) {
    if (opts.invitation) {
        // If this member update came from an invitation, we bypass adding activity as there is a
        // dedicated activity for that
        return;
    }

    var addedMemberIds = _.pluck(memberChangeInfo.members.added, 'id');
    var updatedMemberIds = _.pluck(memberChangeInfo.members.updated, 'id');

    var millis = Date.now();
    var actorResource = new ActivityModel.ActivitySeedResource('user', ctx.user().id, {'user': ctx.user()});
    var folderResource = new ActivityModel.ActivitySeedResource('folder', folder.id, {'folder': folder});

    // When a user is added, it is considered either a folder-share or a folder-add-to-library
    // activity, depending on whether the added user is the current user in context
    _.each(addedMemberIds, function(memberId) {
        if (memberId === ctx.user().id) {
            // Users can't "share" with themselves, they actually "add it to their library"
            ActivityAPI.postActivity(ctx, new ActivityModel.ActivitySeed(FoldersConstants.activity.ACTIVITY_FOLDER_ADD_TO_LIBRARY, millis, ActivityConstants.verbs.ADD, actorResource, folderResource));
        } else {
            // A user shared a folder with some other user, fire the folder share activity
            var principalResourceType = (PrincipalsUtil.isGroup(memberId)) ? 'group' : 'user';
            var principalResource = new ActivityModel.ActivitySeedResource(principalResourceType, memberId);
            ActivityAPI.postActivity(ctx, new ActivityModel.ActivitySeed(FoldersConstants.activity.ACTIVITY_FOLDER_SHARE, millis, ActivityConstants.verbs.SHARE, actorResource, folderResource, principalResource));
        }
    });

    // When a user's role is updated, we fire a "folder-update-member-role" activity
    _.each(updatedMemberIds, function(memberId) {
        var principalResourceType = (PrincipalsUtil.isGroup(memberId)) ? 'group' : 'user';
        var principalResource = new ActivityModel.ActivitySeedResource(principalResourceType, memberId);
        ActivityAPI.postActivity(ctx, new ActivityModel.ActivitySeed(FoldersConstants.activity.ACTIVITY_FOLDER_UPDATE_MEMBER_ROLE, millis, ActivityConstants.verbs.UPDATE, actorResource, principalResource, folderResource));
    });
});


///////////////////////////
// ACTIVITY ENTITY TYPES //
///////////////////////////

/*!
 * Produces a persistent 'folder' activity entity
 * @see ActivityAPI#registerActivityEntityType
 */
var _folderProducer = function(resource, callback) {
    var folder = (resource.resourceData && resource.resourceData.folder) ? resource.resourceData.folder : null;

    // If the folder was fired with the resource, use it instead of fetching
    if (folder) {
        return callback(null, _createPersistentFolderActivityEntity(folder));
    }

    FoldersDAO.getFolder(resource.resourceId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        return callback(null, _createPersistentFolderActivityEntity(folder));
    });
};

/*!
 * Transform the folder persistent activity entities into UI-friendly ones
 * @see ActivityAPI#registerActivityEntityType
 */
var _folderTransformer = function(ctx, activityEntities, callback) {
    var transformedActivityEntities = {};

    // Collect all the folder ids so we can fetch their preview data
    var folderIds = [];
    _.each(activityEntities, function(entities, activityId) {
        _.each(entities, function(entity, entityId) {
            folderIds.push(entity.folder.id);
        });
    });
    folderIds = _.uniq(folderIds);

    // Grab the latest folder objects
    FoldersDAO.getFoldersByIds(folderIds, function(err, folders) {
        if (err) {
            return callback(err);
        }

        var foldersById = _.indexBy(folders, 'id');
        var transformedActivityEntities = {};
        _.each(activityEntities, function(entitiesPerActivity, activityId) {
            transformedActivityEntities[activityId] = transformedActivityEntities[activityId] || {};
            _.each(entitiesPerActivity, function(entity, entityId) {
                transformedActivityEntities[activityId][entityId] = _transformPersistentFolderActivityEntity(ctx, entity, foldersById);
            });
        });

        return callback(null, transformedActivityEntities);
    });
};

/*!
 * Produces a persistent activity entity that represents a comment that was posted
 * @see ActivityAPI#registerActivityEntityType
 */
var _folderCommentProducer = function(resource, callback) {
    var folderId = resource.resourceData.folderId;
    var message = resource.resourceData.message;
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) {
            return callback(err);
        }

        MessageBoxUtil.createPersistentMessageActivityEntity(message, function(err, entity) {
            if (err) {
                return callback(err);
            }

            // Store the folder id and visibility on the entity as these are required for routing the activities
            entity.objectType = 'folder-comment';
            entity.folderId = folder.id;
            entity.folderVisibility = folder.visibility;
            return callback(null, entity);
        });
    });
};

/*!
 * Transform the persisted comment activity entities into UI-friendly ones
 * @see ActivityAPI#registerActivityEntityType
 */
var _folderCommentTransformer = function(ctx, activityEntities, callback) {
    var transformedActivityEntities = {};
    _.keys(activityEntities).forEach(function(activityId) {
        transformedActivityEntities[activityId] = transformedActivityEntities[activityId] || {};
        _.keys(activityEntities[activityId]).forEach(function(entityId) {
            var entity = activityEntities[activityId][entityId];
            var folderId = entity.folderId;
            var resource = AuthzUtil.getResourceFromId(folderId);
            var profilePath = '/folder/' + resource.tenantAlias + '/' + resource.resourceId;
            var urlFormat = '/api/folder/' + folderId + '/messages/%s';
            transformedActivityEntities[activityId][entityId] = MessageBoxUtil.transformPersistentMessageActivityEntity(ctx, entity, profilePath, urlFormat);
        });
    });
    return callback(null, transformedActivityEntities);
};

/*!
 * Transform the persisted comment activity entities into UI-friendly ones
 * @see ActivityAPI#registerActivityEntityType
 */
var _folderCommentInternalTransformer = function(ctx, activityEntities, callback) {
    var transformedActivityEntities = {};
    _.keys(activityEntities).forEach(function(activityId) {
        transformedActivityEntities[activityId] = transformedActivityEntities[activityId] || {};
        _.keys(activityEntities[activityId]).forEach(function(entityId) {
            var entity = activityEntities[activityId][entityId];
            transformedActivityEntities[activityId][entityId] =  MessageBoxUtil.transformPersistentMessageActivityEntityToInternal(ctx, entity.message);
        });
    });
    return callback(null, transformedActivityEntities);
};

ActivityAPI.registerActivityEntityType('folder', {
    'producer': _folderProducer,
    'transformer': {
        'activitystreams': _folderTransformer,
        'internal': _folderTransformer
    },
    'propagation': function(associationsCtx, entity, callback) {
        ActivityUtil.getStandardResourcePropagation(entity.folder.visibility, AuthzConstants.joinable.NO, callback);
    }
});

ActivityAPI.registerActivityEntityType('folder-comment', {
    'producer': _folderCommentProducer,
    'transformer': {
        'activitystreams': _folderCommentTransformer,
        'internal': _folderCommentInternalTransformer
    },
    'propagation': function(associationsCtx, entity, callback) {
        return callback(null, [{'type': ActivityConstants.entityPropagation.ALL}]);
    }
});

//////////////////////////////////
// ACTIVITY ENTITY ASSOCIATIONS //
//////////////////////////////////

/*!
 * Register an association that presents the folder
 */
ActivityAPI.registerActivityEntityAssociation('folder', 'self', function(associationsCtx, entity, callback) {
    return callback(null, [entity[ActivityConstants.properties.OAE_ID]]);
});

/*!
 * Register an association that presents the members of a folder categorized by role
 */
ActivityAPI.registerActivityEntityAssociation('folder', 'members-by-role', function(associationsCtx, entity, callback) {
    ActivityUtil.getAllAuthzMembersByRole(entity[FoldersConstants.activity.PROP_OAE_GROUP_ID], callback);
});

/*!
 * Register an association that presents all the indirect members of a folder
 */
ActivityAPI.registerActivityEntityAssociation('folder', 'members', function(associationsCtx, entity, callback) {
    associationsCtx.get('members-by-role', function(err, membersByRole) {
        if (err) {
            return callback(err);
        }

        return callback(null, _.flatten(_.values(membersByRole)));
    });
});

/*!
 * Register an association that presents all the managers of a content item
 */
ActivityAPI.registerActivityEntityAssociation('folder', 'managers', function(associationsCtx, entity, callback) {
    associationsCtx.get('members-by-role', function(err, membersByRole) {
        if (err) {
            return callback(err);
        }

        return callback(null, membersByRole[AuthzConstants.role.MANAGER]);
    });
});

/*!
 * Register an assocation that presents all the commenting contributors of a folder
 */
ActivityAPI.registerActivityEntityAssociation('folder', 'message-contributors', function(associationsCtx, entity, callback) {
    MessageBoxAPI.getRecentContributions(entity[ActivityConstants.properties.OAE_ID], null, 100, callback);
});

/*!
 * Register an association that presents the folder for a folder-comment entity
 */
ActivityAPI.registerActivityEntityAssociation('folder-comment', 'self', function(associationsCtx, entity, callback) {
    return callback(null, [entity.folderId]);
});

/**
 * Create the persistent folder entity that can be transformed into an activity entity for the UI.
 *
 * @param  {Folder}     folder      The folder that provides the data for the entity
 * @return {Object}                 An object containing the entity data that can be transformed into a UI folder activity entity
 * @api private
 */
var _createPersistentFolderActivityEntity = function(folder) {
    var opts = {'folder': folder};
    opts[FoldersConstants.activity.PROP_OAE_GROUP_ID] = folder.groupId;
    return new ActivityModel.ActivityEntity('folder', folder.id, folder.visibility, opts);
};

/**
 * Transform a folder object into an activity entity suitable to be displayed in an activity stream.
 *
 * For more details on the transformed entity model, @see ActivityAPI#registerActivityEntityTransformer
 *
 * @param  {Context}            ctx                 Standard context object containing the current user and the current tenant
 * @param  {Object}             entity              The persisted activity entity to transform
 * @param  {Object}             foldersById         A set of folders keyed against their folder id
 * @return {ActivityEntity}                         The activity entity that represents the given folder
 */
var _transformPersistentFolderActivityEntity = function(ctx, entity, foldersById) {
    // Grab the folder from the `foldersById` hash as it would contain the updated
    // previews object. If it can't be found (because it has been deleted) we fall
    // back to the folder that was provided in the activity
    var folderId = entity.folder.id;
    var folder = foldersById[folderId] || entity.folder;

    var tenant = ctx.tenant();
    var baseUrl = TenantsUtil.getBaseUrl(tenant);
    var globalId = baseUrl + '/api/folder/' + folder.id;
    var profileUrl = baseUrl + folder.profilePath;
    var opts = {
        'displayName': folder.displayName,
        'url': profileUrl,
        'ext': {}
    };
    opts.ext[ActivityConstants.properties.OAE_ID] = folder.id;
    opts.ext[ActivityConstants.properties.OAE_VISIBILITY] = folder.visibility;
    opts.ext[ActivityConstants.properties.OAE_PROFILEPATH] = folder.profilePath;

    if (folder.previews && folder.previews.thumbnailUri) {
        var thumbnailUrl = ContentUtil.getSignedDownloadUrl(ctx, folder.previews.thumbnailUri, -1);
        opts.image = new ActivityModel.ActivityMediaLink(thumbnailUrl, PreviewConstants.SIZES.IMAGE.THUMBNAIL, PreviewConstants.SIZES.IMAGE.THUMBNAIL);
    }
    if (folder.previews && folder.previews.wideUri) {
        var wideUrl = ContentUtil.getSignedDownloadUrl(ctx, folder.previews.wideUri, -1);
        opts.ext[ContentConstants.activity.PROP_OAE_WIDE_IMAGE] = new ActivityModel.ActivityMediaLink(wideUrl, PreviewConstants.SIZES.IMAGE.WIDE_WIDTH, PreviewConstants.SIZES.IMAGE.WIDE_HEIGHT);
    }

    return new ActivityModel.ActivityEntity('folder', globalId, folder.visibility, opts);
};
