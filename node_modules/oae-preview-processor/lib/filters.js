/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

/**
 * Allows for validation and applying of filters when triggering a "reprocessing" previews task
 *
 * @param  {Object}         filters                             The object containing all the content and revision filters
 * @param  {Object}         filters.content                     The object containing the content filters
 * @param  {String[]}       [filters.content.createdBy]         Filter content based on who it was created by
 * @param  {String[]}       [filters.content.previewsStatus]    Filter content based on the status of the previews processing
 * @param  {String[]}       [filters.content.resourceSubType]   Filter content based on its resourceSubType
 * @param  {String[]}       [filters.revision.mime]             Filter based on the mime type of a file. Only useful in combination with `content_resourceSubType: file`
 * @param  {Number}         [filters.revision.createdAfter]     Filter those revisions who were created after a certain timestamp. The value of the timestamp should be specified in ms since epoch
 * @param  {Number}         [filters.revision.createdBefore]    Filter those revisions who were created before a certain timestamp. The value of the timestamp should be specified in ms since epoch
 * @param  {String[]}       [filters.revision.createdBy]        Filter the revisions based on who it was created by
 * @param  {String[]}       [filters.revision.previewsStatus]   Filter the revisions based on their previews status
 * @return {Object}                                             Returns an object that contains the necessary methods to do validation and filtering
 */
var FilterGenerator = module.exports.FilterGenerator = function(filters) {
    var errors = [];
    var needsRevisions = false;
    var contentCheckers = [];
    var revisionCheckers = [];
    var columnNames = ['contentId', 'latestRevisionId', 'previews'];

    // Loop over the filters and check if there are errors
    if (_.isEmpty(filters) || (!filters.content && !filters.revision)) {
        errors.push({'code': 400, 'msg': 'Missing or invalid filters object'});
    }

    var contentFilters = filters.content;
    var revisionFilters = filters.revision;


    // Loop over all the filters and check their validity
    // At the same we construct all the functions that are
    // required to do in-app filtering

    // Content
    _.each(contentFilters, function(value, name) {
        if (name === 'resourceSubType') {
            // We'll need the resourceSubType column if we want to run this filter
            columnNames.push('resourceSubType');

            // Construct the filter function
            var types = _wrapInArray(value);
            contentCheckers.push(function(content) {
                return _.contains(types, content.resourceSubType);
            });
        } else if (name === 'previewsStatus') {
            // We'll need the previews column if we want to run this filter
            columnNames.push('previews');

            // Construct the filter function
            var statuses = _wrapInArray(value);
            contentCheckers.push(function(content) {
                if (content.previews && content.previews.status) {
                    return _.contains(statuses, content.previews.status);
                } else {
                    // If the previews object is missing, something is seriously wrong and we should reprocess it
                    return true;
                }
            });
        } else if (name === 'createdBy') {
            var userIds = _wrapInArray(value);
            contentCheckers.push(function(content) {
                return _.contains(userIds, content.createdBy);
            });
        } else {
            errors.push({'code': 400, 'msg': 'Unknown content filter'});
        }
    });

    // Revisions
    _.each(revisionFilters, function(value, name) {
        if (name === 'mime') {
            needsRevisions = true;
            var types = _wrapInArray(value);
            revisionCheckers.push(function(revision) {
                if (!revision.mime) {
                    return false;
                }

                // Check if the mime type is in the desired set of mimetypes
                return _.contains(types, revision.mime);
            });
        } else if (name === 'previewsStatus') {
            needsRevisions = true;
            var statuses = _wrapInArray(value);
            revisionCheckers.push(function(revision) {
                if (revision.previews && revision.previews.status) {
                    return _.contains(statuses, revision.previews.status);
                } else {
                    // If the previews object is missing, something is seriously wrong and we should reprocess it
                    return true;
                }
            });
        } else if (name === 'createdBy') {
            needsRevisions = true;
            var userIds = _wrapInArray(value);
            revisionCheckers.push(function(revision) {
                return _.contains(userIds, revision.createdBy);
            });
        } else if (name === 'createdAfter') {
            needsRevisions = true;
            var afterTs = parseInt(value, 10);

            revisionCheckers.push(function(revision) {
                return revision.created > afterTs;
            });
        } else if (name === 'createdBefore') {
            needsRevisions = true;
            var beforeTs = parseInt(value, 10);

            revisionCheckers.push(function(revision) {
                return revision.created < beforeTs;
            });
        } else {
            errors.push({'code': 400, 'msg': 'Unknown revision filter'});
        }
    });

    var that = {};

    /**
     * Whether or not the passed in filters contain errors
     *
     * @return {Boolean}    `true` if the filters contain errors
     */
    that.hasErrors = function() {
        return !_.isEmpty(errors);
    };

    /**
     * Get the first error in the list of errors
     *
     * @return {Object}     Standard error object containing a `code` and `msg`.
     */
    that.getFirstError = function() {
        return errors[0];
    };

    /**
     * Get all the errors
     *
     * @return {Object[]}   An array of standard error objects
     */
    that.getErrors = function() {
        return errors;
    };

    /**
     * Whether or not revisions need to be retrieved to do proper filtering
     *
     * @return {Boolean}    `true` if the revisions should be retrieved
     */
    that.needsRevisions = function() {
        return needsRevisions;
    };

    /**
     * Returns the names of the columns that should be retrieved when iterating over
     * the Content rows
     *
     * @return {String[]}   The names of the columns that should be retrieved
     */
    that.getContentColumnNames = function() {
        return columnNames;
    };

    /**
     * Filter an array of content items
     *
     * @param  {Content[]}  content     The array of content items to filter
     * @return {Content[]}              The filtered array of content items
     */
    that.filterContent = function(content) {
        var chain = _.chain(content);
        _.each(contentCheckers, function(contentChecker) {
            chain = chain.filter(contentChecker);
        });

        return chain.value();
    };

    /**
     * Filter the revisions on a content items.
     * If there are no revisions left for a content item, it will be removed from the array
     *
     * @param  {Content[]}  content     An array of content items for which to filter the revisions. It's assumed that the revisions are available at `content[i].revisions`
     * @return {Content[]}              A filtered array of content items
     */
    that.filterRevisions = function(content) {
        _.each(content, function(contentItem) {
            var chain = _.chain(contentItem.revisions);
            _.each(revisionCheckers, function(revisionChecker) {
                chain = chain.filter(revisionChecker);
            });
            contentItem.revisions = chain.value();
        });

        // Remove all those content items who no longer have a matching revision
        content = _.filter(content, function(contentItem) {
            return contentItem.revisions.length > 0;
        });

        return content;
    };

    return that;
};

/**
 * Wraps a value in an array if it's not an array already
 *
 * @param  {Object}     value   The value to wrap in an array
 * @return {Object[]}           The wrapped array
 * @api private
 */
var _wrapInArray = function(value) {
    if (!_.isArray(value)) {
        value = [ value ];
    }
    return value;
};