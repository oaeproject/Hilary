/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var util = require('util');

var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var LibraryAPI = require('oae-library');
var log = require('oae-logger').logger('discussions-api');
var MessageBoxAPI = require('oae-messagebox');
var MessageBoxConstants = require('oae-messagebox/lib/constants').MessageBoxConstants;
var OaeUtil = require('oae-util/lib/util');
var PrincipalsUtil = require('oae-principals/lib/util');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var Validator = require('oae-authz/lib/validator').Validator;

var DiscussionsAPI = require('oae-discussions');
var DiscussionsConfig = require('oae-config').config('oae-discussions');
var DiscussionsConstants = require('./constants').DiscussionsConstants;
var DiscussionsDAO = require('./internal/dao');

// Library index for the discussions module, for "discussions" libraries
var LIBRARY_INDEX_NAME = 'discussions:discussions';

// When updating discussions as a result of new messages, update it at most every hour
var LIBRARY_UPDATE_THRESHOLD_SECONDS = 3600;

// Discussion fields that are allowed to be updated
var DISCUSSION_UPDATE_FIELDS = ['displayName', 'description', 'visibility'];

/**
 * Create a new discussion.
 *
 * @param  {Context}    ctx                 The context of the current request
 * @param  {String}     displayName         The display name of the discussion
 * @param  {String}     [description]       A longer description for the discussion
 * @param  {String}     [visibility]        The visibility of the discussion. One of public, loggedin, private. Defaults to the configured tenant default.
 * @param  {Object}     [members]           The initial membership of the discussion (the user in context will be a manager regardless of this parameter)
 * @param  {Object}     [opts]              Additional optional parameters
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Discussion} callback.discussion The discussion object that was created
 */
var createDiscussion = module.exports.createDiscussion = function(ctx, displayName, description, visibility, members, opts, callback) {
    visibility = visibility || DiscussionsConfig.getValue(ctx.tenant().alias, 'visibility', 'discussion');
    members = members || {};
    opts = opts || {};

    var allVisibilities = _.values(AuthzConstants.visibility);

    // Verify basic properties
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Anonymous users cannot create a discussion'}).isLoggedInUser(ctx);
    validator.check(displayName, {'code': 400, 'msg': 'Must provide a displayName for the discussion'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'A displayName can only be 1000 characters long'}).isShortString();
    validator.check(description, {'code': 400, 'msg': 'Must provide a description for the discussion'}).notEmpty();
    validator.check(description, {'code': 400, 'msg': 'A description can only be 10000 characters long'}).isMediumString();
    validator.check(visibility, {'code': 400, 'msg': 'An invalid discussion visibility option has been provided. Must be one of: ' + allVisibilities.join(', ')}).isIn(allVisibilities);

    // Verify each memberId and role is valid
    _.each(members, function(role, memberId) {
        validator.check(memberId, {'code': 400, 'msg': 'The memberId: ' + memberId + ' is not a valid member id'}).isPrincipalId();
        validator.check(role, {'code': 400, 'msg': 'The role: ' + role + ' is not a valid member role for a discussion'}).isIn(DiscussionsConstants.roles.ALL_PRIORITY);
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // The current user is a manager
    members[ctx.user().id] = DiscussionsConstants.roles.MANAGER;

    // Persist the discussion into storage
    DiscussionsDAO.createDiscussion(ctx.user().id, displayName, description, visibility, null, function(err, discussion) {
        if (err) {
            return callback(err);
        }

        // Grant the requested users access to the discussion
        AuthzAPI.updateRoles(discussion.id, members, function(err) {
            if (err) {
                return callback(err);
            }

            // Index the discussion into user libraries
            _insertLibrary(_.keys(members), discussion, function(err) {
                if (err) {
                    return callback(err);
                }

                DiscussionsAPI.emit(DiscussionsConstants.events.CREATED_DISCUSSION, ctx, discussion, members);
                return callback(null, discussion);
            });
        });
    });
};

/**
 * Update the basic profile of the specified discussion.
 *
 * @param  {Context}    ctx                 The context of the current request
 * @param  {String}     discussionId        The id of the discussion to update
 * @param  {Object}     profileFields       An object whose keys are profile field names, and the value is the value to which you wish the field to change. Keys must be one of: displayName, visibility, discription
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Discussion} callback.discussion The updated discussion object
 */
var updateDiscussion = module.exports.updateDiscussion = function(ctx, discussionId, profileFields, callback) {
    var allVisibilities = _.values(AuthzConstants.visibility);

    var validator = new Validator();
    validator.check(discussionId, {'code': 400, 'msg': 'A discussion id must be provided'}).isResourceId();
    validator.check(null, {'code': 401, 'msg': 'You must be authenticated to update a discussion'}).isLoggedInUser(ctx);
    validator.check(_.keys(profileFields).length, {'code': 400, 'msg': 'You should at least one profile field to update'}).min(1);
    _.each(profileFields, function(value, field) {
        validator.check(field, {'code': 400, 'msg': 'The field \'' + field + '\' is not a valid field. Must be one of: ' + DISCUSSION_UPDATE_FIELDS.join(', ')}).isIn(DISCUSSION_UPDATE_FIELDS);
        if (field === 'visibility') {
            validator.check(value, {'code': 400, 'msg': 'An invalid visibility was specified. Must be one of: ' + allVisibilities.join(', ')}).isIn(allVisibilities);
        } else if (field === 'displayName') {
            validator.check(value, {'code': 400, 'msg': 'A displayName cannot be empty'}).notEmpty();
            validator.check(value, {'code': 400, 'msg': 'A displayName can only be 1000 characters long'}).isShortString();
        } else if (field === 'description') {
            validator.check(value, {'code': 400, 'msg': 'A description cannot be empty'}).notEmpty();
            validator.check(value, {'code': 400, 'msg': 'A description can only be 10000 characters long'}).isMediumString();
        }
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getDiscussion(discussionId, function(err, discussion) {
        if (err) {
            return callback(err);
        }

        DiscussionsAPI.Authz.canManageDiscussion(ctx, discussion, function(err, canManage) {
            if (err) {
                return callback(err);
            } else if (!canManage) {
                return callback({'code': 401, 'msg': 'You are not authorized to update this discussion'});
            }

            // Get all the member ids, we'll need them to update the user libraries
            _getAllMemberIds(discussion.id, function(err, memberIds) {
                if (err) {
                    return callback(err);
                }

                var oldLastModified = discussion.lastModified;

                DiscussionsDAO.updateDiscussion(discussion, profileFields, function(err, updatedDiscussion) {
                    if (err) {
                        return callback(err);
                    }

                    // Update the user libraries asynchronously
                    _updateLibrary(memberIds, updatedDiscussion, oldLastModified);

                    DiscussionsAPI.emit(DiscussionsConstants.events.UPDATED_DISCUSSION, ctx, discussion, updatedDiscussion);

                    // Fill in the full profile, the user has to have been a manager, so these are all true
                    updatedDiscussion.isManager = true;
                    updatedDiscussion.canPost = true;
                    updatedDiscussion.canShare = true;

                    return callback(null, updatedDiscussion);
                });
            });
        });
    });
};

/**
 * Deletes the specified discussion.
 *
 * @param  {Context}    ctx                 The context of the current request
 * @param  {String}     discussionId        The id of the discussion to delete
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 */
var deleteDiscussion = module.exports.deleteDiscussion = function(ctx, discussionId, callback) {
    var validator = new Validator();
    validator.check(discussionId, {'code': 400, 'msg': 'A discussion id must be provided'}).isResourceId();
    validator.check(null, {'code': 401, 'msg': 'You must be authenticated to delete a discussion'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getDiscussion(discussionId, function(err, discussion) {
        if (err) {
            return callback(err);
        }

        DiscussionsAPI.Authz.canManageDiscussion(ctx, discussion, function(err, canManage) {
            if (err) {
                return callback(err);
            } else if (!canManage) {
                return callback({'code': 401, 'msg': 'You are not authorized to delete this discussion'});
            }

            // Get all the member ids, we'll need them to remove the discussion from the principal libraries
            _getAllMemberIds(discussion.id, function(err, memberIds) {
                if (err) {
                    return callback(err);
                }

                // Remove it from the libraries.
                _removeLibrary(memberIds, discussion, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Remove the actual discussion profile.
                    DiscussionsDAO.deleteDiscussion(discussion.id, function(err) {
                        if (err) {
                            return callback(err);
                        }
                        DiscussionsAPI.emit(DiscussionsConstants.events.DELETED_DISCUSSION, ctx, discussionId);
                        callback();
                    });
                });
            });
        });
    });
};

/**
 * Get the discussions library items for the specified user. Depending on the access of the principal in context,
 * either a library of public, loggedin, or all items will be returned.
 *
 * @param  {Context}        ctx                     The context of the current request
 * @param  {String}         principalId             The id of the principal whose discussion library to fetch
 * @param  {String}         [start]                 The discussion ordering token from which to start fetching discussions (see `nextToken` in callback params)
 * @param  {Number}         [limit]                 The maximum number of results to return. Default: 10
 * @param  {Function}       callback                Invoked when the process completes
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Discussion[]}   callback.discussions    The array of discussions fetched
 * @param  {String}         [callback.nextToken]    The token that can be used as the `start` parameter to fetch the next set of tokens (exclusively). If not specified, indicates that the query fetched all remaining results.
 */
var getDiscussionsLibrary = module.exports.getDiscussionsLibrary = function(ctx, principalId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'A user or group id must be provided'}).isPrincipalId();
    validator.check(limit, {'code': 400, 'msg': 'A valid limit should be provided'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the principal
    PrincipalsDAO.getPrincipal(principalId, function(err, principal) {
        if (err) {
            return callback(err);
        }


        // Determine which library visibility the current user should receive
        LibraryAPI.Authz.resolveTargetLibraryAccess(ctx, principal, function(err, hasAccess, visibility) {
            if (err) {
                return callback(err);
            } else if (!hasAccess) {
                return callback({'code': 401, 'msg': 'You do not have have access to this library.'});
            }

            // Get the discussion ids from the library index
            LibraryAPI.Index.list(LIBRARY_INDEX_NAME, principalId, visibility, start, limit, null, function(err, discussionIds, nextToken) {
                if (err) {
                    return callback(err);
                }

                // Get the discussion objects from the discussion ids
                DiscussionsDAO.getDiscussionsById(discussionIds, function(err, discussions) {
                    if (err) {
                        return callback(err);
                    }

                    return callback(null, discussions, nextToken);
                });
            });
        });
    });
};

/**
 * Get a discussion basic profile by its id.
 *
 * @param  {Context}    ctx                 The context of the current request
 * @param  {String}     discussionId        The id of the discussion to get
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Discussion} callback.discussion The discussion object requested
 */
var getDiscussion = module.exports.getDiscussion = function(ctx, discussionId, callback) {
    var validator = new Validator();
    validator.check(discussionId, {'code': 400, 'msg': 'discussionId must be a valid resource id'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getDiscussion(discussionId, function(err, discussion) {
        if (err) {
            return callback(err);
        }

        DiscussionsAPI.Authz.canViewDiscussion(ctx, discussion, function(err, canView) {
            if (err) {
                return callback(err);
            } else if (!canView) {
                return callback({'code': 401, 'msg': 'You are not authorized to view this discussion'});
            }

            return callback(null, discussion);
        });
    });
};

/**
 * Get a discussion's full profile by its id. In addition to the basic profile, the full profile contains
 * the basic profile of the creator, and access information (see parameters)
 *
 * @param  {Context}    ctx                             The context of the current request
 * @param  {String}     discussionId                    The id of the discussion to get
 * @param  {Function}   callback                        Invoked when the process completes
 * @param  {Object}     callback.err                    An error that occurred, if any
 * @param  {Discussion} callback.discussion             The discussion object requested
 * @param  {User}       callback.discussion.createdBy   The basic profile of the user who created the discussion
 * @param  {Boolean}    callback.discussion.isManager   Specifies if the current user in context is a manager of the discussion
 * @param  {Boolean}    callback.discussion.canShare    Specifies if the current user in context is allowed to share the discussion
 * @param  {Boolean}    callback.discussion.canPost     Specifies if the current user in context is allowed to post messages to the discussion
 */
var getFullDiscussionProfile = module.exports.getFullDiscussionProfile = function(ctx, discussionId, callback) {
    var validator = new Validator();
    validator.check(discussionId, {'code': 400, 'msg': 'discussionId must be a valid resource id'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the discussion object, throwing an error if it does not exist but does not do permission checks
    _getDiscussion(discussionId, function(err, discussion) {
        if (err) {
            return callback(err);
        }

        // Resolve the full discussion access information for the current user
        DiscussionsAPI.Authz.resolveEffectiveDiscussionAccess(ctx, discussion, function(err, canView, canManage, canShare, canPost) {
            if (err) {
                return callback(err);
            } else if (!canView) {
                // The user has no effective role, which means they are not allowed to view (this has already taken into
                // consideration implicit privacy rules, such as whether or not the discussion is public).
                return callback({'code': 401, 'msg': 'You are not authorized to view this discussion'});
            }

            discussion.isManager = canManage;
            discussion.canShare = canShare;
            discussion.canPost = canPost;

            // Populate the creator of the discussion
            PrincipalsUtil.getPrincipal(ctx, discussion.createdBy, function(err, creator) {
                if (err && err.code === 404) {
                    log().warn({
                        'err': err,
                        'userId': discussion.createdBy,
                        'discussionId': discussion.id
                    }, 'Discussion creator id points to non-existing user. Proceeding with empty user for full profile.');
                }

                if (creator) {
                    discussion.createdBy = creator;
                }

                return callback(null, discussion);
            });
        });
    });
};

/**
 * Get a list of member profiles associated to a discussion, with their roles.
 *
 * @param  {Context}        ctx                             The context of the current request
 * @param  {String}         discussionId                    The id of the discussion whose members to get
 * @param  {String}         [start]                         The id of the principal from which to begin the page of results (exclusively). By default, begins from the first in the list.
 * @param  {Number}         [limit]                         The maximum number of results to return. Default: 10
 * @param  {Function}       callback                        Invoked when the process completes
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Object[]}       callback.members                Array that contains an object for each member
 * @param  {String}         callback.members[i].role        The role of the member at index `i`
 * @param  {User|Group}     callback.members[i].profile     The principal profile of the member at index `i`
 * @param  {String}         callback.nextToken              The value to provide in the `start` parameter to get the next set of results
 */
var getDiscussionMembers = module.exports.getDiscussionMembers = function(ctx, discussionId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(discussionId, {'code': 400, 'msg': 'A discussion id must be provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getDiscussion(ctx, discussionId, function(err, discussion) {
        if (err) {
            return callback(err);
        }

        // Get the discussion members
        AuthzAPI.getAuthzMembers(discussionId, start, limit, function(err, members, nextToken) {
            if (err) {
                return callback(err);
            }

            // Get the basic profiles for all of these principals
            var memberIds = _.map(members, function(member){ return member.id; });
            PrincipalsUtil.getPrincipals(ctx, memberIds, function(err, memberProfiles) {
                if (err) {
                    return callback(err);
                }

                // Merge the member profiles and roles into a single object
                var memberList = [];
                for (var m = 0; m < members.length; m++) {
                    if (memberProfiles[members[m].id]) {
                        memberList.push({
                            'profile': memberProfiles[members[m].id],
                            'role': members[m].role
                        });
                    }
                }

                return callback(null, memberList, nextToken);
            });
        });
    });

};

/**
 * Share a discussion with a number of users and groups. The role of the target principals will be `member`. If
 * any principals in the list already have the discussion in their library, then this will have no impact for
 * that user with no error. Only those who do not have the discussion in their library will be impacted.
 *
 * @param  {Context}    ctx                 The context of the current request
 * @param  {String}     discussionId        The id of the discussion to share
 * @param  {String[]}   principalIds        The ids of the principals with which the discussion will be shared
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 */
var shareDiscussion = module.exports.shareDiscussion = function(ctx, discussionId, principalIds, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to share a discussion'}).isLoggedInUser(ctx);
    validator.check(discussionId, {'code': 400, 'msg': 'A valid discussion id must be provided'}).isResourceId();
    validator.check(principalIds.length, {'code': 400, 'msg': 'The discussion must at least be shared with 1 user or group'}).min(1);
    _.each(principalIds, function(principalId) {
        validator.check(principalId, {'code': 400, 'msg': 'The member id: ' + principalId + ' is not a valid member id'}).isPrincipalId();
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getDiscussion(discussionId, function(err, discussion) {
        if (err) {
            return callback(err);
        }


        AuthzAPI.getDirectRoles(principalIds, discussionId, function(err, roles) {
            if (err) {
                return callback(err);
            }

            // Take out the principals who already have a role on this discussion
            principalIds = _.difference(principalIds, _.keys(roles));

            // Validate role and tenant boundary permissions for the current user to share the discussion with the target
            // users
            DiscussionsAPI.Authz.canShareDiscussion(ctx, discussion, principalIds, function(err, canShare, illegalPrincipalIds) {
                if (err) {
                    return callback(err);
                } else if (illegalPrincipalIds) {
                    return callback({'code': 400, 'msg': 'One or more target members are not authorized to become members on this discussion'});
                } else if (!canShare) {
                    return callback({'code': 401, 'msg': 'You are not authorized to share this discussion'});
                }

                // Apply the membership updates
                var roleChanges = {};
                _.each(principalIds, function(principalId) {
                    roleChanges[principalId] = DiscussionsConstants.roles.MEMBER;
                });

                AuthzAPI.updateRoles(discussionId, roleChanges, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Update the discussion lastModified date. This constitutes an update that is bypassing discussion
                    // permissions, but that is ok since it is only the lastModified date as a result of this share.
                    _touch(discussion, function(err, touchedDiscussion) {
                        if (err) {
                            log().warn({
                                'err': err,
                                'principalIds': principalIds,
                                'discussionId': discussion.id
                            }, 'Error touching the discussion while sharing. Ignoring.');
                        }

                        // Use the most recent discussion object
                        discussion = touchedDiscussion || discussion;

                        _insertLibrary(principalIds, discussion, function(err) {
                            if (err) {
                                log().warn({
                                    'err': err,
                                    'principalIds': principalIds,
                                    'discussionId': discussion.id
                                }, 'Error updating the library index for these users. Ignoring the error, but some repair may be necessary for these users.');
                            }

                            DiscussionsAPI.emit(DiscussionsConstants.events.UPDATED_DISCUSSION_MEMBERS, ctx, discussion, principalIds);
                            return callback();
                        });
                    });
                });
            });
        });
    });
};

/**
 * Set the permissions of a discussion. This method will ensure that the current user in context has access to change the
 * permissions, as well as ensure the discussion does not end up with no manager members.
 *
 * @param  {Context}    ctx                     The context of the current request
 * @param  {String}     discussionId            The id of the discussion to share
 * @param  {Object}     permissionChanges       An object that describes the permission changes to apply to the discussion. The key is the id of the principal to which to apply the change, and the value is the role to apply to the principal. If the value is `false`, the principal will be revoked access.
 * @param  {Function}   callback                Invoked when the process completes
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Object}     callback.permissions    An object describing the permissions of the discussion after the change is applied. The key is the principal id and the value is the role that the principal has on the discussion
 */
var setDiscussionPermissions = module.exports.setDiscussionPermissions = function(ctx, discussionId, permissionChanges, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to change discussion permissions'}).isLoggedInUser(ctx);
    validator.check(discussionId, {'code': 400, 'msg': 'A valid discussion id must be provided'}).isResourceId();
    validator.check(null, {'code': 400, 'msg': 'Must specify at least one permission change to apply'}).isObject(permissionChanges);
    validator.check(_.keys(permissionChanges).length, {'code': 400, 'msg': 'You must specify atleast one permission change'}).min(1);
    _.each(permissionChanges, function(role, principalId) {
        validator.check(principalId, {'code': 400, 'msg': 'The member id: ' + principalId + ' is not a valid member id'}).isPrincipalId();
        validator.check(role, {'code': 400, 'msg': 'The role change: ' + role + ' is not a valid value. Must either be a string, or false'}).isValidRoleChange();
        if (role) {
            validator.check(role, {'code': 400, 'msg': 'The role :' + role + ' is not a valid value. Must be one of: ' + DiscussionsConstants.roles.ALL_PRIORITY.join(', ') + '; or false'}).isIn(DiscussionsConstants.roles.ALL_PRIORITY);
        }
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the discussion object, throwing an error if it doesn't exist, but not applying permissions checks
    _getDiscussion(discussionId, function(err, discussion) {
        if (err) {
            return callback(err);
        }

        // Ensure we are allowed to add the new members
        AuthzAPI.computeMembershipAfterChanges(discussionId, permissionChanges, function(err, membershipAfterChanges, newMembers, updatedMembers, removedMembers) {
            if (err) {
                return callback(err);
            }

            // Ensure the user is allowed to set the discussion permissions
            DiscussionsAPI.Authz.canSetDiscussionPermissions(ctx, discussion, newMembers, function(err, canSetPermissions, illegalMemberIds) {
                if (err) {
                    return callback(err);
                } else if (illegalMemberIds) {
                    // Ensures we don't violate tenant privacy boundaries
                    return callback({'code': 400, 'msg': 'One or more target members being granted access are not authorized to become members on this discussion'});
                } else if (!canSetPermissions) {
                    // Ensures we have access to the discussion
                    return callback({'code': 401, 'msg': 'You are not authorized to update the permissions of this discussion'});
                } else if (!_.contains(_.values(membershipAfterChanges), DiscussionsConstants.roles.MANAGER)) {
                    // If the anticipated membership after these changes has no manager, bail out
                    return callback({'code': 400, 'msg': 'The requested change results in a discussion with no managers'});
                }

                // All validation checks have passed, finally persist the role change and update the user libraries
                AuthzAPI.updateRoles(discussionId, permissionChanges, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    var oldLastModified = discussion.lastModified;

                    // Remove from the library before we touch the discussion to update the lastModified
                    _removeLibrary(removedMembers, discussion, function(err) {
                        if (err) {
                            log().warn({
                                'err': err,
                                'principalIds': removedMembers,
                                'discussionId': discussion.id
                            }, 'Error removing discussion from principal libraries. Ignoring.');
                        }

                        // Update the discussion lastModified date so it is ordered higher in libraries
                        _touch(discussion, function(err, touchedDiscussion) {
                            if (err) {
                                log().warn({
                                    'err': err,
                                    'principalIds': principalIds,
                                    'discussionId': discussion.id
                                }, 'Error touching the discussion while. Ignoring.');
                            }

                            // Use the updated discussion object if it was successfully touched
                            discussion = touchedDiscussion || discussion;

                            // Perform an update for both the new and updated members. The library deletes on the oldLastModified
                            // for new users are not doing anything, but it shouldn't be a big deal.
                            var principalIdsToUpdate = _.union(updatedMembers, newMembers);
                            _updateLibrary(principalIdsToUpdate, discussion, oldLastModified, function(err) {
                                if (err) {
                                    log().warn({
                                        'err': err,
                                        'principalIds': principalIds,
                                        'discussionId': discussion.id
                                    }, 'Error updating the library index for these users. Ignoring the error, but some repair may be necessary for these users.');
                                }

                                DiscussionsAPI.emit(DiscussionsConstants.events.UPDATED_DISCUSSION_MEMBERS, ctx, discussion, principalIdsToUpdate);
                                return callback(null, membershipAfterChanges);
                            });
                        });
                    });
                });
            });
        });
    });
};

/**
 * Remove a discussion from a discussion library. This is its own API method due to special permission handling required, as the user
 * is effectively updating a discussions permissions (removing themselves, or removing it from a group they manage), and they might not
 * necessarily have access to update the permissions of the private discussion (e.g., they are only a member). Also, tenant privacy
 * rules do not come into play in this case.
 *
 * @param  {Context}    ctx             The context of the current request
 * @param  {String}     libraryOwnerId  The owner of the library, should be a principal id (either user or group id)
 * @param  {String}     discussionId    The id of the discussion to remove from the library
 * @param  {Function}   callback        Invoked when the method is complete
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var removeDiscussionFromLibrary = module.exports.removeDiscussionFromLibrary = function(ctx, libraryOwnerId, discussionId, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You must be authenticated to remove a discussion from a library'}).isLoggedInUser(ctx);
    validator.check(libraryOwnerId, {'code': 400, 'msg': 'A user or group id must be provided'}).isPrincipalId();
    validator.check(discussionId, {'code': 400, 'msg': 'A valid discussion id "' + discussionId + '" was provided'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Make sure the discussion exists
    _getDiscussion(discussionId, function(err, discussion) {
        if (err) {
            return callback(err);
        }

        // Verify the current user has access to remove discussions from the target library
        LibraryAPI.Authz.canRemoveFromLibrary(ctx, libraryOwnerId, function(err, canRemove) {
            if (err) {
                return callback(err);
            } else if (!canRemove) {
                return callback({'code': 401, 'msg': 'You are not authorized to delete a discussion from this library'});
            }

            var permissionChanges = {};
            permissionChanges[libraryOwnerId] = false;

            // Ensure we are actually removing something, and that we'll be left with at least one manager afterward
            AuthzAPI.computeMembershipAfterChanges(discussionId, permissionChanges, function(err, membershipAfterChanges, newMembers, updatedMembers, removedMembers) {
                if (err) {
                    return callback(err);
                } else if (!_.contains(_.values(membershipAfterChanges), DiscussionsConstants.roles.MANAGER)) {
                    // If the anticipated membership after these changes has no manager, bail out
                    return callback({'code': 400, 'msg': 'The requested change results in a discussion with no managers'});
                } else if (removedMembers.length === 0) {
                    return callback({'code': 400, 'msg': 'The specified discussion is not in this library'});
                }

                // All validation checks have passed, finally persist the role change and update the user library
                AuthzAPI.updateRoles(discussionId, permissionChanges, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    DiscussionsAPI.emit(DiscussionsConstants.events.UPDATED_DISCUSSION_MEMBERS, ctx, discussion);
                    return _removeLibrary([libraryOwnerId], discussion, callback);
                });
            });
        });
    });
};

/**
 * Create a new message in the discussion. If `replyToCreatedTimestamp` is specified, the message will be
 * a reply to the message in the discussion identified by that timestamp.
 *
 * @param  {Context}        ctx                         The context of the current request
 * @param  {String}         discussionId                The id of the discussion to which to post the message
 * @param  {String}         body                        The body of the message to post
 * @param  {String|Number}  [replyToCreatedTimestamp]   The created time of the message to which this is a reply, if applicable
 * @param  {Function}       callback                    Invoked when the process completes
 * @param  {Object}         callback.err                An error that occurred, if any
 * @param  {Message}        callback.message            The message object that was created
 */
var createMessage = module.exports.createMessage = function(ctx, discussionId, body, replyToCreatedTimestamp, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can post on discussions'}).isLoggedInUser(ctx);
    validator.check(discussionId, {'code': 400, 'msg': 'Invalid discussion id provided'}).isResourceId();
    validator.check(body, {'code': 400, 'msg': 'A discussion body must be provided'}).notEmpty();
    validator.check(body, {'code': 400, 'msg': 'A discussion body can only be 100000 characters long'}).isLongString();
    if (replyToCreatedTimestamp) {
        validator.check(replyToCreatedTimestamp, {'code': 400, 'msg': 'Invalid reply-to timestamp provided'}).isInt();
    }

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the discussion, throwing an error if it doesn't exist, avoiding permission checks for now
    _getDiscussion(discussionId, function(err, discussion) {
        if (err) {
            return callback(err);
        }

        // Determine if the current user can post discussion messages to this discussion
        DiscussionsAPI.Authz.canPostDiscussionMessage(ctx, discussion, function(err, canPost) {
            if (err) {
                return callback(err);
            } else if (!canPost) {
                return callback({'code': 401, 'msg': 'You are not authorized to post messages to this discussion'});
            }

            var oldLastModified = discussion.lastModified;
            var updateLibraries = true;

            // The following `if` block is an asynchronous block. Check to see if we are in a threshold to perform a
            // discussion lastModified update. If so, we will update the lastModified date and the discussion's
            // libraries.
            if (_testDiscussionUpdateThreshold(discussion)) {

                // Try and get the principals whose libraries will be updated
                _getAllMemberIds(discussion.id, function(err, memberIds) {
                    if (err) {
                        // If we can't get the members, don't so that we don't risk
                        return log().warn({
                            'err': err,
                            'discussionId': discussion.id
                        }, 'Error fetching discussion members list to update library. Skipping updating libraries');
                    }

                    // Update the lastModified of the discussion
                    _touch(discussion, function(err, updatedDiscussion) {
                        if (err) {
                            // If we get an error touching the discussion, we simply won't update the libraries. Better luck next time.
                            return log().warn({
                                'err': err,
                                'discussionId': discussion.id
                            }, 'Error touching discussion to update lastModified time. Skipping updating libraries');
                        }

                        _updateLibrary(memberIds, updatedDiscussion, oldLastModified);
                    });
                });
            }

            // While the libraries are updating, we can create the message and return to the user
            MessageBoxAPI.createMessage(discussionId, ctx.user().id, body, {'replyToCreated': replyToCreatedTimestamp}, function(err, message) {
                if (err) {
                    return callback(err);
                }

                message.createdBy = ctx.user();
                DiscussionsAPI.emit(DiscussionsConstants.events.CREATED_DISCUSSION_MESSAGE, ctx, discussion, message);
                callback(null, message);
            });
        });
    });
};

/**
 * Deletes a message from a discussion. Managers of the discussion can delete all messages while people that have access
 * to the discussion can only delete their own messages. Therefore, anonymous users will never be able to delete messages.
 *
 * @param  {Context}    ctx                     Standard context object, representing the currently logged in user and its tenant
 * @param  {String}     discussionId            The ID of the discussion from which to delete the message
 * @param  {String}     messageCreatedDate      The timestamp (in millis since the epoch) that the message we wish to delete was created
 * @param  {Function}   callback                Invoked when the process completes
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Comment}    [callback.softDeleted]  When the message has been soft deleted (because it has replies), a stripped down message object representing the deleted message will be returned, with the `deleted` parameter set to `false`. If the message has been deleted from the index, no message object will be returned.
 */
var deleteMessage = module.exports.deleteMessage = function(ctx, discussionId, messageCreatedDate, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can delete messages'}).isLoggedInUser(ctx);
    validator.check(discussionId, {'code': 400, 'msg': 'A discussion id must be provided'}).isResourceId();
    validator.check(messageCreatedDate, {'code': 400, 'msg': 'A valid integer message created timestamp must be specified'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the discussion without permissions check, we will check for permissions with DiscussionsAPI.Authz later
    _getDiscussion(discussionId, function(err, discussion) {
        if (err) {
            return callback(err);
        }

        // Ensure that the message exists. We also need it so we can make sure we have access to deleted it
        MessageBoxAPI.getMessages(discussionId, [messageCreatedDate], {'scrubDeleted': false}, function(err, messages) {
            if (err) {
                return callback(err);
            } else if (!messages[0]) {
                return callback({'code': 404, 'msg': 'The specified message does not exist'});
            }

            message = messages[0];

            // Determine if we have access to delete the discussion message
            DiscussionsAPI.Authz.canDeleteDiscussionMessage(ctx, discussion, message, function(err, canDelete) {
                if (err) {
                    return callback(err);
                } else if (!canDelete) {
                    return callback({'code': 401, 'msg': 'You are not authorized to delete this message'});
                }

                // Delete the message using the "leaf" method, which will SOFT delete if the message has replies, or HARD delete if it does not
                MessageBoxAPI.deleteMessage(discussionId, messageCreatedDate, {'deleteType': MessageBoxConstants.deleteTypes.LEAF}, function(err, deleteType, message) {
                    if (err) {
                        return callback(err);
                    }

                    DiscussionsAPI.emit(DiscussionsConstants.events.DELETED_DISCUSSION_MESSAGE, ctx, discussion, deleteType, messageCreatedDate, message);

                    // If a soft-delete occurred, we want to inform the consumer of the soft-delete message model
                    if (deleteType === MessageBoxConstants.deleteTypes.SOFT) {
                        return callback(null, message);
                    } else {
                        return callback();
                    }
                });
            });
        });
    });
};

/**
 * Get a list of messages from the specified discussion.
 *
 * @param  {Context}        ctx                     The context of the current request
 * @param  {String}         discussionId            The id of the discussion whose messages to fetch
 * @param  {String}         [start]                 The `threadKey` of the message from which to start retrieving messages (exclusively). By default, will start fetching from the most recent message
 * @param  {Number}         [limit]                 The maximum number of results to return. Default: 10
 * @param  {Function}       callback                Invoked when the process completes
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Message[]}      callback.messages       The list of messages fetched. Of the type `MessageBoxModel#Message`
 * @param  {String}         callback.nextToken      The value to provide in the `start` parameter to get the next set of results
 */
var getMessages = module.exports.getMessages = function(ctx, discussionId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(discussionId, {'code': 400, 'msg': 'Must provide a valid discussion id'}).isResourceId();
    validator.check(limit, {'code': 400, 'msg': 'Must provide a valid discussion id'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the discussion, throwing an error if the user in context doesn't have view access or if it doesn't exist
    getDiscussion(ctx, discussionId, function(err, discussion) {
        if (err) {
            return callback(err);
        }

        // Fetch the messages from the message box
        MessageBoxAPI.getMessagesFromMessageBox(discussionId, start, limit, null, function(err, messages, nextToken) {
            if (err) {
                return callback(err);
            }

            var userIds = _.map(messages, function(message) {
                return message.createdBy;
            });

            // Remove falsey and duplicate userIds
            userIds = _.uniq(_.compact(userIds));

            // Get the basic principal profiles of the messagers to add to the messages as `createdBy`.
            PrincipalsUtil.getPrincipals(ctx, userIds, function(err, users) {
                if (err) {
                    return callback(err);
                }

                // Attach the user profiles to the message objects
                _.each(messages, function(message) {
                    if (users[message.createdBy]) {
                        message.createdBy = users[message.createdBy];
                    }
                });

                return callback(err, messages, nextToken);
            });
        });
    });
};

/**
 * Get the discussion with the specified id. If it doesn't exist, a 404 error will be thrown. No permission checks
 * will be performed.
 *
 * @param  {Context}    ctx                 The context of the current request
 * @param  {String}     discussionId        The id of the discussion to get
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Discussion} callback.discussion The discussion object requested
 * @api private
 */
var _getDiscussion = function(discussionId, callback) {
    DiscussionsDAO.getDiscussion(discussionId, function(err, discussion) {
        if (err) {
            return callback(err);
        } else if (!discussion) {
            return callback({'code': 404, 'msg': 'Could not find discussion: ' + discussionId});
        }

        return callback(null, discussion);
    });
};

/**
 * Perform a "touch" on a discussion, which updates only the lastModified date of the discussion. The touch operation
 * operates according to a threshold, such that only one touch per hour will actually have an impact and return an
 * updated discussion.
 *
 * @param  {Discussion} discussion              The discussion object to update
 * @param  {Function}   callback                Invoked when the process completes
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Discussion} [callback.discussion]   The discussion object with the new lastModified date. If not specified, then the discussion was not updated due to rate-limiting.
 * @api private
 */
var _touch = function(discussion, callback) {
    if (_testDiscussionUpdateThreshold(discussion)) {
        DiscussionsDAO.updateDiscussion(discussion, {'lastModified': Date.now()}, callback);
    } else {
        return callback();
    }
};

/**
 * Determine if the discussion is beyond the threshold such that a `_touch` operation will be effective.
 *
 * @param  {Discussion}    discussion  The discussion to test
 * @return {Boolean}                   `true` if the discussion was last updated beyond the threshold and `_touch` will be effective. `false` otherwise.
 * @api private
 */
var _testDiscussionUpdateThreshold = function(discussion) {
    return (!discussion.lastModified || (Date.now() - discussion.lastModified) > (LIBRARY_UPDATE_THRESHOLD_SECONDS * 1000));
};

/**
 * Get all the ids of the principals that are members for the specified discussion.
 *
 * @param  {String}     discussionId        The id of the discussion whose member ids to fetch
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that ocurred, if any
 * @param  {String[]}   callback.memberIds  The member ids associated to the discussion
 * @api private
 */
var _getAllMemberIds = function(discussionId, callback) {
    AuthzAPI.getAuthzMembers(discussionId, null, 10000, function(err, members) {
        if (err) {
            return callback(err);
        }

        // Flatten the members hash into just an array of ids
        return callback(null, _.map(members, function(member) { return member.id; }));
    });
};

/**
 * Insert a discussion into the discussion libraries of the specified principals
 *
 * @param  {String[]}   principalIds    The ids of the principals whose libraries to update
 * @param  {Discussion} discussion      The discussion to insert
 * @param  {Function}   callback        Invoked when the process completes
 * @param  {Object}     callback.err    An error that occurred, if any
 * @api private
 */
var _insertLibrary = function(principalIds, discussion, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({
                'err': err,
                'principalIds': principalIds,
                'discussionId': discussion.id
            }, 'Error inserting discussion into principal libraries');
        }
    };

    if (principalIds.length === 0 || !discussion) {
        return callback();
    }

    var effectiveLibraryVisibilities = LibraryAPI.Authz.resolveEffectiveLibraryVisibilities(principalIds, discussion);
    LibraryAPI.Index.insert(LIBRARY_INDEX_NAME, effectiveLibraryVisibilities, discussion.id, discussion.lastModified, callback);
};

/**
 * Update a discussion in the discussion libraries of the specified principals
 *
 * @param  {String[]}   principalIds    The ids of the principals whose libraries to update
 * @param  {Discussion} discussion      The discussion to insert
 * @param  {String}     oldLastModified The discussion record associated to this last-modified timestamp will be removed in favour of the updated one
 * @param  {Function}   callback        Invoked when the process completes
 * @param  {Object}     callback.err    An error that occurred, if any
 * @api private
 */
var _updateLibrary = function(principalIds, discussion, oldLastModified, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({
                'err': err,
                'principalIds': principalIds,
                'discussionId': discussion.id
            }, 'Error updating discussion for principal libraries');
        }
    };

    // These are cases where an update would have no impact. Do not perform the library update
    if (principalIds.length === 0 || !discussion) {
        return callback();
    }

    var effectiveLibraryVisibilities = LibraryAPI.Authz.resolveEffectiveLibraryVisibilities(principalIds, discussion);
    LibraryAPI.Index.update(LIBRARY_INDEX_NAME, effectiveLibraryVisibilities, discussion.id, discussion.lastModified, oldLastModified, callback);
};

/**
 * Delete a discussion in the discussion libraries of the specified principals
 *
 * @param  {String[]}   principalIds    The ids of the principals whose libraries to update
 * @param  {Discussion} discussion      The discussion to remove
 * @param  {Function}   callback        Invoked when the process completes
 * @param  {Object}     callback.err    An error that occurred, if any
 * @api private
 */
var _removeLibrary = function(principalIds, discussion, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({
                'err': err,
                'principalIds': principalIds,
                'discussionId': discussion.id
            }, 'Error removing discussion from principal libraries');
        }
    };

    if (principalIds.length === 0 || !discussion) {
        return callback();
    }

    LibraryAPI.Index.remove(LIBRARY_INDEX_NAME, principalIds, discussion.id, discussion.lastModified, callback);
};
