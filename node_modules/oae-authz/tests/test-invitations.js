/*
 * Copyright 2015 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');
var clone = require('clone');
var fs = require('fs');
var url = require('url');
var util = require('util');

var ActivityTestUtil = require('oae-activity/lib/test/util');
var ContentTestUtil = require('oae-content/lib/test/util');
var DiscussionsTestUtil = require('oae-discussions/lib/test/util');
var EmailTestUtil = require('oae-email/lib/test/util');
var FoldersTestUtil = require('oae-folders/lib/test/util');
var PrincipalsTestUtil = require('oae-principals/lib/test/util');
var RestAPI = require('oae-rest');
var RestContext = require('oae-rest/lib/model').RestContext;
var Sanitization = require('oae-util/lib/sanitization');
var SearchTestUtil = require('oae-search/lib/test/util');
var TenantsAPI  = require('oae-tenants');
var TenantsTestUtil = require('oae-tenants/lib/test/util');
var TestsUtil = require('oae-tests');
var UIAPI = require('oae-ui');

var AuthzInvitationsDAO = require('oae-authz/lib/invitations/dao');
var AuthzTestUtil = require('oae-authz/lib/test/util');
var AuthzUtil = require('oae-authz/lib/util');

describe('Invitations', function() {

    // Initialize some rest contexts for anonymous and admin users
    var anonymousRestContext = null;
    var camAdminRestContext = null;

    var _randomString = function() {
        return TestsUtil.generateRandomText(1);
    };

    /*!
     * This is a wrapper of `_.partial` that allows you to specify an argless function as a
     * parameter that will be invoked to derive the argument value on each invokation
     *
     * @param  {Function}   fn      The function to curry
     * @param  {...Object}  args    The variable number of arguments to partially apply the function with
     * @return {Function}           The partially applied function, just like `_.partial`, except any partial arguments that were functions are invoked on-the-fly for each invocation
     */
    var _partialWithFns = function(firstFn) {
        var firstArgs = _.toArray(arguments).slice(1);

        // Return a function that does the call at the time it was called, but invoke any functions
        // given in the first set of arguments on-the-fly
        return function() {
            var secondArgs = _.toArray(arguments);

            // Apply all the arguments from the first call on-the-fly
            var firstArgsApplied = [];
            for (var i = 0; i <= firstArgs.length; i++) {
                var arg = firstArgs[i];
                if (arg === _ || !_.isFunction(arg)) {
                    firstArgsApplied.push(arg);
                } else {
                    firstArgsApplied.push(arg());
                }
            }

            // Create the first partial with the applied arguments
            var firstFnPartial = _.partial.apply(null, [firstFn].concat(firstArgsApplied));

            // Now return the result of the partial function with the 2nd set of arguments verbatim
            return firstFnPartial.apply(null, secondArgs);
        };
    };

    /*!
     * Build a library of common functions across different known resource types
     */
    var resourceFns = {
        'content': {
            'createSucceeds': _partialWithFns(ContentTestUtil.assertCreateLinkSucceeds, _, _randomString, _randomString, _, 'http://oae.local', _, _, [], _),
            'createFails': _partialWithFns(ContentTestUtil.assertCreateLinkFails, _, _randomString, _randomString, _, 'http://oae.local', _, _, [], _, _),
            'shareSucceeds': ContentTestUtil.assertShareContentSucceeds,
            'shareFails': ContentTestUtil.assertShareContentFails,
            'setRolesSucceeds': ContentTestUtil.assertUpdateContentMembersSucceeds,
            'setRolesFails': ContentTestUtil.assertUpdateContentMembersFails,
            'getMembersSucceeds': _partialWithFns(ContentTestUtil.getAllContentMembers, _, _, null, _),
            'getLibrarySucceeds': _partialWithFns(ContentTestUtil.assertGetAllContentLibrarySucceeds, _, _, null, _),
            'deleteSucceeds': function(adminRestContext, deleterRestContext, contentId, callback) {
                ContentTestUtil.assertDeleteContentSucceeds(deleterRestContext, contentId, callback);
            }
        },
        'discussion': {
            'createSucceeds': _partialWithFns(DiscussionsTestUtil.assertCreateDiscussionSucceeds, _, _randomString, _randomString, _, _, _, _),
            'createFails': _partialWithFns(DiscussionsTestUtil.assertCreateDiscussionFails, _, _randomString, _randomString, _, _, _, _, _),
            'shareSucceeds': DiscussionsTestUtil.assertShareDiscussionSucceeds,
            'shareFails': DiscussionsTestUtil.assertShareDiscussionFails,
            'setRolesSucceeds': DiscussionsTestUtil.assertUpdateDiscussionMembersSucceeds,
            'setRolesFails': DiscussionsTestUtil.assertUpdateDiscussionMembersFails,
            'getMembersSucceeds': _partialWithFns(DiscussionsTestUtil.getAllDiscussionMembers, _, _, null, _),
            'getLibrarySucceeds': _partialWithFns(DiscussionsTestUtil.assertGetAllDiscussionsLibrarySucceeds, _, _, null, _),
            'deleteSucceeds': function(adminRestContext, deleterRestContext, discussionId, callback) {
                DiscussionsTestUtil.assertDeleteDiscussionSucceeds(deleterRestContext, discussionId, callback);
            }
        },
        'folder': {
            'createSucceeds': _partialWithFns(FoldersTestUtil.assertCreateFolderSucceeds, _, _randomString, _randomString, _, _, _, _),
            'createFails': _partialWithFns(FoldersTestUtil.assertCreateFolderFails, _, _randomString, _randomString, _, _, _, _, _),
            'shareSucceeds': FoldersTestUtil.assertShareFolderSucceeds,
            'shareFails': FoldersTestUtil.assertShareFolderFails,
            'setRolesSucceeds': FoldersTestUtil.assertUpdateFolderMembersSucceeds,
            'setRolesFails': FoldersTestUtil.assertUpdateFolderMembersFails,
            'getMembersSucceeds': _partialWithFns(FoldersTestUtil.assertGetAllFolderMembersSucceeds, _, _, null, _),
            'getLibrarySucceeds': _partialWithFns(FoldersTestUtil.assertGetAllFoldersLibrarySucceeds, _, _, null, _),
            'deleteSucceeds': function(adminRestContext, deleterRestContext, folderId, callback) {
                FoldersTestUtil.assertDeleteFolderSucceeds(deleterRestContext, folderId, true, callback);
            }
        },
        'group': {
            'createSucceeds': _partialWithFns(PrincipalsTestUtil.assertCreateGroupSucceeds, _, _randomString, _randomString, _, 'no', _, _, _),
            'createFails': _partialWithFns(PrincipalsTestUtil.assertCreateGroupFails, _, _randomString, _randomString, _, 'no', _, _, _, _),
            'setRolesSucceeds': PrincipalsTestUtil.assertSetGroupMembersSucceeds,
            'setRolesFails': PrincipalsTestUtil.assertSetGroupMembersFails,
            'getMembersSucceeds': _partialWithFns(PrincipalsTestUtil.assertGetAllMembersLibrarySucceeds, _, _, null, _),
            'getLibrarySucceeds': _partialWithFns(PrincipalsTestUtil.assertGetAllMembershipsLibrarySucceeds, _, _, null, _),
            'deleteSucceeds': PrincipalsTestUtil.assertDeleteGroupSucceeds,
            'restoreSucceeds': PrincipalsTestUtil.assertRestoreGroupSucceeds
        }
    };

    /*!
     * Build a library of the "member" role for all known resources types. "manager" is common for
     * all resources
     */
    var resourceMemberRoles = {
        'content': 'viewer',
        'discussion': 'member',
        'folder': 'viewer',
        'group': 'member'
    };

    /*!
     * Build a library of expected activity information after an invitation is accepted for each
     * resource type
     */
    var resourceAcceptActivityInfo = {
        'content': {
            'activityType': 'content-share',
            'verb': 'share'
        },
        'discussion': {
            'activityType': 'discussion-share',
            'verb': 'share'
        },
        'folder': {
            'activityType': 'folder-share',
            'verb': 'share'
        },
        'group': {
            'activityType': 'group-add-member',
            'verb': 'add'
        },
    };

    /*!
     * Define the library names for each respective resource type
     */
    var resourceLibraryInfo = {
        'content': 'content-library',
        'discussion': 'discussion-library',
        'folder': 'folder-library',
        'group': 'memberships-library'
    };

    before(function(callback) {
        anonymousRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host);
        camAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.cam.host);
        return callback();
    });

    beforeEach(function(callback) {
        // Ensure we start each test with no emails pending
        EmailTestUtil.collectAndFetchAllEmails(function() {
            return callback();
        });
    });

    describe('Create', function() {

        describe('Content', function() {

            /**
             * Test that verifies creating content with members and invitations saves invitations
             */
            it('verify creating content with members and invitations saves invitations', function(callback) {
                return _testInvitationsForCreate('content', callback);
            });

            /**
             * Test that verifies validation of creating content with invitations
             */
            it('verify validation of creating content with invitations', function(callback) {
                return _testInvitationsValidationForCreate('content', callback);
            });

            /**
             * Test that verifies authorization of creating content with invitations
             */
            it('verify authorization of creating content with invitations', function(callback) {
                return _testInvitationsAuthorizationForCreate('content', callback);
            });

        });

        describe('Discussion', function() {

            /**
             * Test that verifies creating discussions with members and invitations saves invitations
             */
            it('verify creating discussion with members and invitations saves invitations', function(callback) {
                return _testInvitationsForCreate('discussion', callback);
            });

            /**
             * Test that verifies validation of creating discussions with invitations
             */
            it('verify validation of creating discussion with invitations', function(callback) {
                return _testInvitationsValidationForCreate('discussion', callback);
            });

            /**
             * Test that verifies authorization of creating discussions with invitations
             */
            it('verify authorization of creating discussion with invitations', function(callback) {
                return _testInvitationsAuthorizationForCreate('discussion', callback);
            });
        });

        describe('Folder', function() {

            /**
             * Test that verifies creating folders with members and invitations saves invitations
             */
            it('verify creating folder with members and invitations saves invitations', function(callback) {
                return _testInvitationsForCreate('folder', callback);
            });

            /**
             * Test that verifies validation of creating folders with invitations
             */
            it('verify validation of creating folder with invitations', function(callback) {
                return _testInvitationsValidationForCreate('folder', callback);
            });

            /**
             * Test that verifies authorization of creating folders with invitations
             */
            it('verify authorization of creating folder with invitations', function(callback) {
                return _testInvitationsAuthorizationForCreate('folder', callback);
            });
        });

        describe('Group', function() {

            /**
             * Test that verifies creating groups with members and invitations saves invitations
             */
            it('verify creating group with members and invitations saves invitations', function(callback) {
                return _testInvitationsForCreate('group', callback);
            });

            /**
             * Test that verifies validation of creating groups with invitations
             */
            it('verify validation of creating group with invitations', function(callback) {
                return _testInvitationsValidationForCreate('group', callback);
            });

            /**
             * Test that verifies authorization of creating groups with invitations
             */
            it('verify authorization of creating group with invitations', function(callback) {
                return _testInvitationsAuthorizationForCreate('group', callback);
            });
        });
    });

    describe('Share', function() {

        describe('Content', function() {

            /**
             * Test that verifies sharing content with members and invitations saves invitations
             */
            it('verify sharing content with members and invitations saves invitations', function(callback) {
                return _testInvitationsForShare('content', callback);
            });

            /**
             * Test that verifies validation of content share with invitations
             */
            it('verify validation of content share with invitations', function(callback) {
                return _testInvitationsValidationForShare('content', callback);
            });

            /**
             * Test that verifies authorization of content share with invitations
             */
            it('verify authorization of content share with invitations', function(callback) {
                return _testInvitationsAuthorizationForShare('content', callback);
            });
        });

        describe('Discussion', function() {

            /**
             * Test that verifies sharing discussion with members and invitations saves invitations
             */
            it('verify sharing discussion with members and invitations saves invitations', function(callback) {
                return _testInvitationsForShare('discussion', callback);
            });

            /**
             * Test that verifies validation of discussion share with invitations
             */
            it('verify validation of discussion share with invitations', function(callback) {
                return _testInvitationsValidationForShare('discussion', callback);
            });

            /**
             * Test that verifies authorization of discussion share with invitations
             */
            it('verify authorization of discussion share with invitations', function(callback) {
                return _testInvitationsAuthorizationForShare('discussion', callback);
            });
        });

        describe('Folder', function() {

            /**
             * Test that verifies sharing folder with members and invitations saves invitations
             */
            it('verify sharing folder with members and invitations saves invitations', function(callback) {
                return _testInvitationsForShare('folder', callback);
            });

            /**
             * Test that verifies validation of folder share with invitations
             */
            it('verify validation of folder share with invitations', function(callback) {
                return _testInvitationsValidationForShare('folder', callback);
            });

            /**
             * Test that verifies authorization of folder share with invitations
             */
            it('verify authorization of folder share with invitations', function(callback) {
                return _testInvitationsAuthorizationForShare('folder', callback);
            });
        });
    });

    describe('Set Roles', function() {

        describe('Content', function() {

            /**
             * Test that verifies setting roles of content with members and invitations saves invitations
             */
            it('verify setting roles of content with members and invitations saves invitations', function(callback) {
                return _testInvitationsForSetRoles('content', callback);
            });

            /**
             * Test that verifies validation of setting roles of content with invitations
             */
            it('verify validation of setting roles of content with invitations', function(callback) {
                return _testInvitationsValidationForSetRoles('content', callback);
            });

            /**
             * Test that verifies authorization of setting roles of content with invitations
             */
            it('verify authorization of setting roles of content with invitations', function(callback) {
                return _testInvitationsAuthorizationForSetRoles('content', callback);
            });
        });

        describe('Discussion', function() {

            /**
             * Test that verifies setting roles of discussion with members and invitations saves invitations
             */
            it('verify setting roles of discussion with members and invitations saves invitations', function(callback) {
                return _testInvitationsForSetRoles('discussion', callback);
            });

            /**
             * Test that verifies validation of setting roles of discussion with invitations
             */
            it('verify validation of setting roles of discussion with invitations', function(callback) {
                return _testInvitationsValidationForSetRoles('discussion', callback);
            });

            /**
             * Test that verifies authorization of setting roles of discussion with invitations
             */
            it('verify authorization of setting roles of discussion with invitations', function(callback) {
                return _testInvitationsAuthorizationForSetRoles('discussion', callback);
            });
        });

        describe('Folder', function() {

            /**
             * Test that verifies setting roles of folder with members and invitations saves invitations
             */
            it('verify setting roles of folder with members and invitations saves invitations', function(callback) {
                return _testInvitationsForSetRoles('folder', callback);
            });

            /**
             * Test that verifies validation of setting roles of folder with invitations
             */
            it('verify validation of setting roles of folder with invitations', function(callback) {
                return _testInvitationsValidationForSetRoles('folder', callback);
            });

            /**
             * Test that verifies authorization of setting roles of folder with invitations
             */
            it('verify authorization of setting roles of folder with invitations', function(callback) {
                return _testInvitationsAuthorizationForSetRoles('folder', callback);
            });
        });

        describe('Group', function() {

            /**
             * Test that verifies setting roles of group with members and invitations saves invitations
             */
            it('verify setting roles of group with members and invitations saves invitations', function(callback) {
                return _testInvitationsForSetRoles('group', callback);
            });

            /**
             * Test that verifies validation of setting roles of group with invitations
             */
            it('verify validation of setting roles of group with invitations', function(callback) {
                return _testInvitationsValidationForSetRoles('group', callback);
            });

            /**
             * Test that verifies authorization of setting roles of group with invitations
             */
            it('verify authorization of setting roles of group with invitations', function(callback) {
                return _testInvitationsAuthorizationForSetRoles('group', callback);
            });
        });
    });

    describe('Accept', function() {

        describe('Content', function() {

            /**
             * Test that verifies accepting an invitation with content
             */
            it('verify accepting an invitation with content', function(callback) {
                _testInvitationAccept('content', callback);
            });

            /**
             * Test that verifies validation of accepting an invitation with content
             */
            it('verify validation of accepting an invitation with content', function(callback) {
                _testInvitationAcceptValidation('content', callback);
            });

            /**
             * Test that verifies authorization of accepting an invitation with content
             */
            it('verify authorization of accepting an invitation with content', function(callback) {
                _testInvitationAcceptAuthorization('content', callback);
            });
        });

        describe('Discussion', function() {

            /**
             * Test that verifies accepting an invitation with discussions
             */
            it('verify accepting an invitation with discussions', function(callback) {
                _testInvitationAccept('discussion', callback);
            });

            /**
             * Test that verifies validation of accepting an invitation with discussions
             */
            it('verify validation of accepting an invitation with discussions', function(callback) {
                _testInvitationAcceptValidation('discussion', callback);
            });

            /**
             * Test that verifies authorization of accepting an invitation with discussions
             */
            it('verify authorization of accepting an invitation with discussions', function(callback) {
                _testInvitationAcceptAuthorization('discussion', callback);
            });
        });

        describe('Folder', function() {

            /**
             * Test that verifies accepting an invitation with folders
             */
            it('verify accepting an invitation with folders', function(callback) {
                _testInvitationAccept('folder', callback);
            });

            /**
             * Test that verifies validation of accepting an invitation with folders
             */
            it('verify validation of accepting an invitation with folders', function(callback) {
                _testInvitationAcceptValidation('folder', callback);
            });

            /**
             * Test that verifies authorization of accepting an invitation with folders
             */
            it('verify authorization of accepting an invitation with folders', function(callback) {
                _testInvitationAcceptAuthorization('folder', callback);
            });
        });

        describe('Group', function() {

            /**
             * Test that verifies accepting an invitation with groups
             */
            it('verify accepting an invitation with groups', function(callback) {
                _testInvitationAccept('group', callback);
            });

            /**
             * Test that verifies validation of accepting an invitation with groups
             */
            it('verify validation of accepting an invitation with groups', function(callback) {
                _testInvitationAcceptValidation('group', callback);
            });

            /**
             * Test that verifies authorization of accepting an invitation with groups
             */
            it('verify authorization of accepting an invitation with groups', function(callback) {
                _testInvitationAcceptAuthorization('group', callback);
            });
        });
    });

    describe('Resend', function() {

        /**
         * Test that verifies the invitation email can be resent
         */
        it('verify it resends an aggregated email for each resource type', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, creatingUser, acceptingUser) {
                assert.ok(!err);

                // Create one of each resource type with the creating user
                var email = _emailForTenant(global.oaeTests.tenants.cam);
                _createOneOfEachResourceType(creatingUser, 'public', [email], [], function(resources) {

                    // Collect all the invitations, we're going to resend them instead
                    EmailTestUtil.collectAndFetchAllEmails(function(messages) {
                        assert.strictEqual(messages.length, 1);

                        // Once all invitations are resent, then accept them
                        var _done = _.chain(resources).size().after(function() {
                            var assertions = {'role': 'manager', 'membersSize': 2, 'librarySize': 1};
                            _assertAcceptEmailInvitation(creatingUser, acceptingUser, resources, assertions, function() {
                                return callback();
                            });
                        }).value();

                        // Resend all invitations
                        _.each(resources, function(resource) {
                            AuthzTestUtil.assertResendInvitationSucceeds(creatingUser.restContext, resource.resourceType, resource.id, email, function() {
                                return _done();
                            });
                        });
                    });
                });
            });
        });
    });

    describe('Email', function() {

        /**
         * Test that verifies email invitation links to the proper tenant based on email domain
         */
        it('verify email invitation links to the proper tenant based on email domain', function(callback) {
            var fns = resourceFns.content;
            TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, user) {
                assert.ok(!err);

                var cambridgeEmail = _emailForTenant(global.oaeTests.tenants.cam);
                var guestEmail = _emailForDomain(TenantsTestUtil.generateTestTenantHost());
                fns.createSucceeds(user.restContext, 'public', [cambridgeEmail], [guestEmail], function(resource) {

                    EmailTestUtil.collectAndFetchAllEmails(function(messages) {

                        // There should be 2 emails, one for cambridgeEmail and one for guestEmail
                        assert.strictEqual(messages.length, 2);

                        var cambridgeMessage = _.find(messages, function(message) {
                            return (message.headers.to === cambridgeEmail);
                        });

                        var guestMessage = _.find(messages, function(message) {
                            return (message.headers.to === guestEmail);
                        });

                        // Grab the invitation link from the messages
                        var cambridgeInvitationUrl = AuthzTestUtil.parseInvitationUrlFromMessage(cambridgeMessage);
                        var guestInvitationUrl = AuthzTestUtil.parseInvitationUrlFromMessage(guestMessage);

                        // Ensure the links are to the proper tenancy
                        assert.strictEqual(cambridgeInvitationUrl.host, global.oaeTests.tenants.cam.host);
                        assert.strictEqual(guestInvitationUrl.host, TenantsAPI.getTenant('guest').host);

                        return callback();
                    });
                });
            });
        });

        /**
         * Test that verifies it sends an aggregated email for all resource types
         */
        it('verify it sends an aggregated email for each resource type', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, creatingUser, acceptingUser) {
                assert.ok(!err);

                // Generate the email to invite and ensure we start with an empty email queue
                var email = _emailForTenant(global.oaeTests.tenants.cam);
                // Create one of each resource type with the creating user
                _createOneOfEachResourceType(creatingUser, 'public', [email], [], function(resources) {

                    // Ensure when the invitation is accepted from the email, all resources are
                    // added to the user's respective libraries
                    var assertions = {'role': 'manager', 'membersSize': 2, 'librarySize': 1};
                    _assertAcceptEmailInvitation(creatingUser, acceptingUser, resources, assertions, function() {
                        return callback();
                    });
                });
            });
        });

        describe('Content', function() {

            /**
             * Test that verifies it sends an aggregated invitation for content of all visibilities on create
             */
            it('verify it sends an aggregated invitation for content of all visibilities on create', function(callback) {
                _testInvitationEmailVisibilityForCreate('content', callback);
            });

            /**
             * Test that verifies it sends an aggregated invitation for content of all visibilities on set roles
             */
            it('verify it sends an aggregated invitation for content of all visibilities on set roles', function(callback) {
                _testInvitationEmailVisibilityForSetRoles('content', callback);
            });

            /**
             * Test that verifies it sends an aggregated invitation for content of all visibilities on share
             */
            it('verify it sends an aggregated invitation for content of all visibilities on share', function(callback) {
                _testInvitationEmailVisibilityForShare('content', callback);
            });


            /**
             * Test that verifies it formats the title properly for various numbers of activities and
             * actors
             */
            it('verify formatting of content invitation email subject for different numbers of actors and activities', function(callback) {
                _testInvitationEmailSubject('content', 'discussion', callback);
            });

            /**
             * Test that verifies the HTML of content invitation emails
             */
            it('verify content invitation email html', function(callback) {
                var assertions = {
                    'oneResourceSummaryMatch': 'has invited you to the link ',
                    'twoResourceSummaryMatch': 'has invited you to collaborate on ',
                    'threeResourceSummaryMatch': 'has invited you to collaborate on '
                };

                return _testInvitationEmailHtmlTargets('content', assertions, callback);
            });

            /**
             * Test that verifies the HTML of content invitation accept emails
             */
            it('verify email aggregation and summary for accepting an invitation to content', function(callback) {
                var assertions = {
                    'oneResourceSummaryMatch': [' has accepted your invitation to the link &quot;'],
                    'twoResourceSummaryMatch': [' has accepted your invitation to collaborate on &quot;'],
                    'threeResourceSummaryMatch': [' has accepted your invitation to collaborate on &quot;']
                };

                _testInvitationAcceptEmailSummary('content', assertions, callback);
            });
        });

        describe('Discussion', function() {

            /**
             * Test that verifies it sends an aggregated invitation for discussions of all visibilities on create
             */
            it('verify it sends an aggregated invitation for discussions of all visibilities on create', function(callback) {
                _testInvitationEmailVisibilityForCreate('discussion', callback);
            });

            /**
             * Test that verifies it sends an aggregated invitation for discussions of all visibilities on set roles
             */
            it('verify it sends an aggregated invitation for discussions of all visibilities on set roles', function(callback) {
                _testInvitationEmailVisibilityForSetRoles('discussion', callback);
            });

            /**
             * Test that verifies it sends an aggregated invitation for discussions of all visibilities on share
             */
            it('verify it sends an aggregated invitation for discussions of all visibilities on share', function(callback) {
                _testInvitationEmailVisibilityForShare('discussion', callback);
            });

            /**
             * Test that verifies the HTML of discussion invitation emails
             */
            it('verify discussion invitation email html', function(callback) {
                var assertions = {
                    'oneResourceSummaryMatch': ' has invited you to the discussion ',
                    'twoResourceSummaryMatch': ' has invited you to the discussions ',
                    'threeResourceSummaryMatch': ' has invited you to the discussion '
                };

                return _testInvitationEmailHtmlTargets('discussion', assertions, callback);
            });

            /**
             * Test that verifies the HTML of discussion invitation accept emails
             */
            it('verify email aggregation and summary for accepting an invitation to discussion', function(callback) {
                var assertions = {
                    'oneResourceSummaryMatch': [' has accepted your invitation to the discussion &quot;'],
                    'twoResourceSummaryMatch': [' has accepted your invitation to the discussions &quot;'],
                    'threeResourceSummaryMatch': [' has accepted your invitation to the discussion &quot;']
                };

                _testInvitationAcceptEmailSummary('discussion', assertions, callback);
            });
        });

        describe('Folder', function() {

            /**
             * Test that verifies it sends an aggregated invitation for folders of all visibilities on create
             */
            it('verify it sends an aggregated invitation for folders of all visibilities on create', function(callback) {
                _testInvitationEmailVisibilityForCreate('folder', callback);
            });

            /**
             * Test that verifies it sends an aggregated invitation for folders of all visibilities on set roles
             */
            it('verify it sends an aggregated invitation for folders of all visibilities on set roles', function(callback) {
                _testInvitationEmailVisibilityForSetRoles('folder', callback);
            });

            /**
             * Test that verifies it sends an aggregated invitation for folders of all visibilities on share
             */
            it('verify it sends an aggregated invitation for folders of all visibilities on share', function(callback) {
                _testInvitationEmailVisibilityForShare('folder', callback);
            });

            /**
             * Test that verifies the HTML of folder invitation emails
             */
            it('verify folder invitation email html', function(callback) {
                var assertions = {
                    'oneResourceSummaryMatch': 'has invited you to the folder ',
                    'twoResourceSummaryMatch': 'has invited you to the folders ',
                    'threeResourceSummaryMatch': 'has invited you to the folder '
                };

                return _testInvitationEmailHtmlTargets('folder', assertions, callback);
            });

            /**
             * Test that verifies the HTML of folder invitation accept emails
             */
            it('verify email aggregation and summary for accepting an invitation to folder', function(callback) {
                var assertions = {
                    'oneResourceSummaryMatch': [' has accepted your invitation to the folder &quot;'],
                    'twoResourceSummaryMatch': [' has accepted your invitation to the folders &quot;'],
                    'threeResourceSummaryMatch': [' has accepted your invitation to the folder &quot;']
                };

                _testInvitationAcceptEmailSummary('folder', assertions, callback);
            });
        });

        describe('Group', function() {

            /**
             * Test that verifies it sends an aggregated invitation for groups of all visibilities on create
             */
            it('verify it sends an aggregated invitation for groups of all visibilities on create', function(callback) {
                _testInvitationEmailVisibilityForCreate('group', callback);
            });

            /**
             * Test that verifies it sends an aggregated invitation for groups of all visibilities on set roles
             */
            it('verify it sends an aggregated invitation for groups of all visibilities on set roles', function(callback) {
                _testInvitationEmailVisibilityForSetRoles('group', callback);
            });

            /**
             * Test that verifies the HTML of group invitation emails
             */
            it('verify group invitation email html', function(callback) {
                var assertions = {
                    'oneResourceSummaryMatch': 'has invited you to the group ',
                    'twoResourceSummaryMatch': 'has invited you to the groups ',
                    'threeResourceSummaryMatch': 'has invited you to the group '
                };

                return _testInvitationEmailHtmlTargets('group', assertions, callback);
            });

            /**
             * Test that verifies the HTML of group invitation accept emails
             */
            it('verify email aggregation and summary for accepting an invitation to group', function(callback) {
                var assertions = {
                    'oneResourceSummaryMatch': [' has accepted your invitation to the group &quot;'],
                    'twoResourceSummaryMatch': [' has accepted your invitation to the groups &quot;'],
                    'threeResourceSummaryMatch': [' has accepted your invitation to the group &quot;']
                };

                _testInvitationAcceptEmailSummary('group', assertions, callback);
            });
        });
    });

    describe('Activity', function() {

        /**
         * Test that verifies activity for all resource types and visibilities when an invitation is accepted
         */
        it('verify a separate activity is sent for each resource type when an invitation is accepted', function(callback) {
            _testActivityVisibilityForAccept('public', function() {
                _testActivityVisibilityForAccept('loggedin', function() {
                    return _testActivityVisibilityForAccept('private', callback);
                });
            });
        });

        describe('Content', function() {

            it('verify the adapted activity summaries for content accept invitation activity', function(callback) {
                var assertions = {
                    'matches': [
                        ' the link &quot;',
                        ' to collaborate on &quot;',
                        ' to collaborate on &quot;'
                    ]
                };
                _testInvitationAcceptAdaptedActivities('content', assertions, callback);
            });
        });

        describe('Discussion', function() {

            it('verify the adapted activity summaries for discussion accept invitation activity', function(callback) {
                var assertions = {
                    'matches': [
                        ' the discussion &quot;',
                        ' the discussions &quot;',
                        ' the discussion &quot;'
                    ]
                };
                _testInvitationAcceptAdaptedActivities('discussion', assertions, callback);
            });
        });

        describe('Folder', function() {

            it('verify the adapted activity summaries for folder accept invitation activity', function(callback) {
                var assertions = {
                    'matches': [
                        ' the folder &quot;',
                        ' the folders &quot;',
                        ' the folder &quot;'
                    ]
                };
                _testInvitationAcceptAdaptedActivities('folder', assertions, callback);
            });
        });

        describe('Group', function() {

            it('verify the adapted activity summaries for group accept invitation activity', function(callback) {
                var assertions = {
                    'resourceActivity': true,
                    'matches': [
                        ' the group &quot;',
                        ' the groups &quot;',
                        ' the group &quot;'
                    ]
                };
                _testInvitationAcceptAdaptedActivities('group', assertions, callback);
            });
        });
    });

    describe('Delete', function() {

        describe('Content', function() {

            /**
             * Test that verifies content that gets deleted simply gets removed from invitations
             */
            it('verify content that gets deleted simply gets removed from invitations', function(callback) {
                _testHardDeleteForAccept('content', function() {
                    return callback();
                });
            });
        });

        describe('Discussion', function() {

            /**
             * Test that verifies discussion that gets deleted simply gets removed from invitations
             */
            it('verify discussion that gets deleted simply gets removed from invitations', function(callback) {
                _testHardDeleteForAccept('discussion', function() {
                    return callback();
                });
            });
        });

        describe('Folder', function() {

            /**
             * Test that verifies folder that gets deleted simply gets removed from invitations
             */
            it('verify folder that gets deleted simply gets removed from invitations', function(callback) {
                _testHardDeleteForAccept('folder', function() {
                    return callback();
                });
            });
        });

        describe('Group', function() {

            /**
             * Test that verifies deleted group does not get added with invitation, but restoring adds it
             */
            it('verify deleted group does not get added with invitation, but restoring adds it', function(callback) {
                _testSoftDeleteForAccept('group', callback);
            });
        });
    });

    var _testInvitationAcceptAdaptedActivities = function(resourceType, assertions, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 3, function(err, users, inviterUserInfo, invitedUserInfo, otherUserInfo) {
            assert.ok(!err);
            var email = _emailForTenant(global.oaeTests.tenants.cam);

            var resources = [];

            // Share 1 of this resource and accept the invitation, while asserting the "accept invitation" activity summary
            fns.createSucceeds(inviterUserInfo.restContext, 'private', [email], [], function(resource1) {
                resources.push(resource1);

                var emailAssertions = {'role': 'manager', 'membersSize': 2, 'librarySize': 1};
                _assertAcceptEmailInvitation(inviterUserInfo, invitedUserInfo, [resource1], emailAssertions, function() {
                    _assertAdaptedActivities(inviterUserInfo, invitedUserInfo, otherUserInfo, resources, assertions, function() {

                        // Share a 2nd of this resource and accept the invitation, while asserting the "accept invitation" for the 2 items in the aggregated feed
                        fns.createSucceeds(inviterUserInfo.restContext, 'private', [email], [], function(resource2) {
                            resources.push(resource2);

                            emailAssertions = {'role': 'manager', 'membersSize': 2, 'librarySize': 2};
                            _assertAcceptEmailInvitation(inviterUserInfo, invitedUserInfo, [resource2], emailAssertions, function() {
                                _assertAdaptedActivities(inviterUserInfo, invitedUserInfo, otherUserInfo, resources, assertions, function() {

                                    // Share a 3rd of this resource and accept the invitation, while asserting the "accept invitation" for the 3 items in the aggregated feed
                                    fns.createSucceeds(inviterUserInfo.restContext, 'private', [email], [], function(resource3) {
                                        resources.push(resource3);

                                        emailAssertions = {'role': 'manager', 'membersSize': 2, 'librarySize': 3};
                                        _assertAcceptEmailInvitation(inviterUserInfo, invitedUserInfo, [resource3], emailAssertions, function() {
                                            _assertAdaptedActivities(inviterUserInfo, invitedUserInfo, otherUserInfo, resources, assertions, function() {
                                                // If we don't want to check that the resource received activities, then we're done
                                                if (!assertions.resourceActivity) {
                                                    return callback();
                                                }

                                                // Ensure the resource received an activity as well
                                                ActivityTestUtil.collectAndGetActivityStream(inviterUserInfo.restContext, resource1.id, null, function(err, result) {
                                                    assert.ok(!err);
                                                    assert.ok(result);
                                                    assert.ok(_.isArray(result.items));

                                                    // Has a create activity and an invitation accept activity
                                                    assert.strictEqual(result.items.length, 2);

                                                    var activity = result.items[0];
                                                    assert.strictEqual(activity.actor['oae:id'], invitedUserInfo.user.id);
                                                    assert.strictEqual(activity.object['oae:id'], inviterUserInfo.user.id);
                                                    assert.strictEqual(activity.target['oae:id'], resource1.id);

                                                    return callback();
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    var _testInvitationAcceptEmailSummary = function(resourceType, assertions, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, sharingUserInfo, acceptingUserInfo) {
            assert.ok(!err);
            var email = _emailForTenant(global.oaeTests.tenants.cam);

            // Share 1 of this resource and accept the invitation, while getting the
            // "accept invitation" activity email sent to the sharer
            fns.createSucceeds(sharingUserInfo.restContext, 'private', [email], [], function(resourceA) {
                var emailAssertions = {'role': 'manager', 'membersSize': 2, 'librarySize': 1};
                _assertAcceptEmailInvitation(sharingUserInfo, acceptingUserInfo, [resourceA], emailAssertions, function(message) {
                    var activities = ActivityTestUtil.parseActivityHtml(message.html);
                    assert.strictEqual(activities.length, 1);

                    _assertAcceptInvitationContainsResourceHtml(activities[0].summary.html, resourceA);
                    _.each(assertions.oneResourceSummaryMatch, function(oneResourceSummaryMatch) {
                        _assertContains(activities[0].summary.html, oneResourceSummaryMatch);
                    });

                    // Share 2 of this resource and accept the invitation, while getting the
                    // "accept invitation" activity email sent to the sharer
                    fns.createSucceeds(sharingUserInfo.restContext, 'private', [email], [], function(resourceB1) {
                        fns.createSucceeds(sharingUserInfo.restContext, 'private', [email], [], function(resourceB2) {
                            emailAssertions = {'role': 'manager', 'membersSize': 2, 'librarySize': 3};
                            _assertAcceptEmailInvitation(sharingUserInfo, acceptingUserInfo, [resourceB1, resourceB2], emailAssertions, function(message) {
                                var activities = ActivityTestUtil.parseActivityHtml(message.html);
                                assert.strictEqual(activities.length, 1);

                                _assertAcceptInvitationContainsResourceHtml(activities[0].summary.html, resourceB1);
                                _assertAcceptInvitationContainsResourceHtml(activities[0].summary.html, resourceB2);
                                _.each(assertions.twoResourceSummaryMatch, function(twoResourceSummaryMatch) {
                                    _assertContains(activities[0].summary.html, twoResourceSummaryMatch);
                                });

                                // Share 3 of this resource and accept the invitation, while getting the
                                // "accept invitation" activity email sent to the sharer
                                fns.createSucceeds(sharingUserInfo.restContext, 'private', [email], [], function(resourceC1) {
                                    fns.createSucceeds(sharingUserInfo.restContext, 'private', [email], [], function(resourceC2) {
                                        fns.createSucceeds(sharingUserInfo.restContext, 'private', [email], [], function(resourceC3) {
                                            var resourceCs = [resourceC1, resourceC2, resourceC3];
                                            emailAssertions = {'role': 'manager', 'membersSize': 2, 'librarySize': 6};
                                            _assertAcceptEmailInvitation(sharingUserInfo, acceptingUserInfo, resourceCs, emailAssertions, function(message) {
                                                var activities = ActivityTestUtil.parseActivityHtml(message.html);
                                                assert.strictEqual(activities.length, 1);

                                                // Ensure the summary has at exactly one of the resources
                                                var numMatchesDisplayName = _.chain(resourceCs)
                                                    .pluck('displayName')
                                                    .filter(function(displayName) {
                                                        return (activities[0].summary.html.indexOf(displayName) !== -1);
                                                    })
                                                    .size()
                                                    .value();
                                                var numMatchesProfilePath = _.chain(resourceCs)
                                                    .pluck('profilePath')
                                                    .filter(function(profilePath) {
                                                        return (activities[0].summary.html.indexOf(profilePath) !== -1);
                                                    })
                                                    .size()
                                                    .value();

                                                assert.strictEqual(numMatchesDisplayName, 1);
                                                assert.strictEqual(numMatchesProfilePath, 1);

                                                _.each(assertions.threeResourceSummaryMatch, function(threeResourceSummaryMatch) {
                                                    _assertContains(activities[0].summary.html, threeResourceSummaryMatch);
                                                });
                                                _assertContains(activities[0].summary.html, 'and 2 others');

                                                return callback();
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    var _testInvitationEmailHtmlTargets = function(resourceType, assertions, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, sharingUser) {
            assert.ok(!err);
            var email = _emailForTenant(global.oaeTests.tenants.cam);

            // Single resource summary
            fns.createSucceeds(sharingUser.restContext, 'public', [email], [], function(resourceA) {
                assert.ok(!err);
                EmailTestUtil.collectAndFetchAllEmails(function(messages) {
                    assert.strictEqual(messages.length, 1);

                    var activities = ActivityTestUtil.parseActivityHtml(messages[0].html);
                    assert.strictEqual(activities.length, 1);

                    _assertInvitationContainsResourceHtml(activities[0].summary.html, resourceA);
                    _assertContains(activities[0].summary.html, assertions.oneResourceSummaryMatch);

                    // 2 content items summary
                    fns.createSucceeds(sharingUser.restContext, 'public', [email], [], function(resourceB1) {
                        fns.createSucceeds(sharingUser.restContext, 'public', [email], [], function(resourceB2) {
                            EmailTestUtil.collectAndFetchAllEmails(function(messages) {
                                assert.strictEqual(messages.length, 1);

                                var activities = ActivityTestUtil.parseActivityHtml(messages[0].html);
                                assert.strictEqual(activities.length, 1);

                                _assertInvitationContainsResourceHtml(activities[0].summary.html, resourceB1);
                                _assertInvitationContainsResourceHtml(activities[0].summary.html, resourceB2);
                                _assertContains(activities[0].summary.html, assertions.twoResourceSummaryMatch);

                                // 3 content items summary
                                fns.createSucceeds(sharingUser.restContext, 'public', [email], [], function(resourceC1) {
                                    fns.createSucceeds(sharingUser.restContext, 'public', [email], [], function(resourceC2) {
                                        fns.createSucceeds(sharingUser.restContext, 'public', [email], [], function(resourceC3) {
                                            EmailTestUtil.collectAndFetchAllEmails(function(messages) {
                                                assert.strictEqual(messages.length, 1);

                                                var activities = ActivityTestUtil.parseActivityHtml(messages[0].html);
                                                assert.strictEqual(activities.length, 1);

                                                // Ensure the summary has at exactly one of the resources
                                                var numMatchesDisplayName = _.chain([resourceC1, resourceC2, resourceC3])
                                                    .pluck('displayName')
                                                    .filter(function(displayName) {
                                                        return (activities[0].summary.html.indexOf(displayName) !== -1);
                                                    })
                                                    .size()
                                                    .value();
                                                var numMatchesProfilePath = _.chain([resourceC1, resourceC2, resourceC3])
                                                    .pluck('profilePath')
                                                    .filter(function(profilePath) {
                                                        return (activities[0].summary.html.indexOf(profilePath) !== -1);
                                                    })
                                                    .size()
                                                    .value();

                                                assert.strictEqual(numMatchesDisplayName, 1);
                                                assert.strictEqual(numMatchesProfilePath, 0);
                                                _assertContains(activities[0].summary.html, assertions.threeResourceSummaryMatch);
                                                _assertContains(activities[0].summary.html, 'and 2 others');

                                                return callback();
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    var _testInvitationEmailSubject = function(resourceType, resourceType2, callback) {
        var fns = resourceFns[resourceType];
        var fns2 = resourceFns[resourceType2];
        TestsUtil.generateTestUsers(camAdminRestContext, 5, function(err, users, targetUser, sharingUser1, sharingUser2, sharingUser3, sharingUser4) {
            assert.ok(!err);

            // Verify that with 1 activity, the subject is what we would expect from the
            // activity summary
            var email = _emailForTenant(global.oaeTests.tenants.cam);
            fns.createSucceeds(sharingUser1.restContext, 'public', [email], [], function(resourceA1) {
                fns.createSucceeds(sharingUser1.restContext, 'public', [email], [], function(resourceA2) {
                    EmailTestUtil.collectAndFetchAllEmails(function(messages) {
                        assert.strictEqual(messages.length, 1);

                        var message = messages[0];
                        var subject = message.headers.subject;
                        assert.notEqual(subject.indexOf(sharingUser1.user.displayName), -1);
                        assert.notEqual(subject.indexOf(resourceA1.displayName), -1);
                        assert.notEqual(subject.indexOf(resourceA2.displayName), -1);

                        // Verify that with 2 activities and 1 actor, the subject is a
                        // little more generic, but includes the name of the actor
                        fns.createSucceeds(sharingUser1.restContext, 'public', [email], [], function(resourceA1) {
                            fns2.createSucceeds(sharingUser1.restContext, 'public', [], [email], function(resourceA2) {
                                EmailTestUtil.collectAndFetchAllEmails(function(messages) {
                                    assert.strictEqual(messages.length, 1);

                                    var message = messages[0];
                                    var subject = message.headers.subject;
                                    assert.strictEqual(subject, util.format('%s has invited you to collaborate', sharingUser1.user.displayName));

                                    // Verify that with 2 activities and 2 actors, the
                                    // subject includes the name of both
                                    fns.createSucceeds(sharingUser1.restContext, 'public', [email], [], function(resourceB1) {
                                        fns.createSucceeds(sharingUser2.restContext, 'public', [], [email], function(resourceB2) {
                                            EmailTestUtil.collectAndFetchAllEmails(function(messages) {
                                                assert.strictEqual(messages.length, 1);

                                                var message = messages[0];
                                                var subject = message.headers.subject;
                                                assert.notEqual(subject.indexOf(sharingUser1.user.displayName), -1);
                                                assert.notEqual(subject.indexOf(sharingUser2.user.displayName), -1);

                                                // Verify that with 3 activities and 3 actors, the
                                                // subject shows 1 of the actors and indicates there
                                                // are 2 others
                                                fns.createSucceeds(sharingUser1.restContext, 'public', [email], [], function(resourceB1) {
                                                    fns.createSucceeds(sharingUser2.restContext, 'public', [], [email], function(resourceB2) {
                                                        fns.createSucceeds(sharingUser3.restContext, 'public', [], [email], function(resourceB2) {
                                                            EmailTestUtil.collectAndFetchAllEmails(function(messages) {
                                                                assert.strictEqual(messages.length, 1);

                                                                var message = messages[0];
                                                                var subject = message.headers.subject;

                                                                var numMatches = _.chain([sharingUser1, sharingUser2, sharingUser3])
                                                                    .pluck('user')
                                                                    .pluck('displayName')
                                                                    .filter(function(displayName) {
                                                                        return (subject.indexOf(displayName) !== -1);
                                                                    })
                                                                    .size()
                                                                    .value();
                                                                assert.strictEqual(numMatches, 1);
                                                                assert.notEqual(subject.indexOf('and 2 others'), -1);
                                                                return callback();
                                                            });
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    /*!
     * Ensure that when a resource is soft deleted (i.e., it's delete functionality is that of a
     * "mark" as deleted which can be restored), an invitation that is accepted for it doesn't
     * result in the resource being added to the user's library.
     *
     * Furthermore, ensure that when the resource is restored, the user who accepted the resource
     * then gets it in their resource library.
     *
     * @param  {String}         resourceType    The resource type for which to execute the test
     * @param  {Function}       callback        Invoked when the test is complete
     * @throws {AssertionError}                 Thrown if any of the assertions fail
     */
    var _testSoftDeleteForAccept = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        _testHardDeleteForAccept(resourceType, function(creatingUserInfo, acceptingUserInfo, resource) {
            fns.restoreSucceeds(camAdminRestContext, camAdminRestContext, resource.id, function() {

                // Ensure that when the item is restored, the user becomes a member
                var assertions = {'role': 'manager', 'membersSize': 2, 'librarySize': 1};
                _assertRole(creatingUserInfo, acceptingUserInfo, resource, assertions, function() {
                    return callback();
                });
            });
        });
    };

    /*!
     * Ensure that when a resource is hard deleted (i.e., it is deleted from the database and
     * cannot be restored), an invitation that is accepted for it doesn't result in the resource
     * being added to the user's library
     *
     * @param  {String}         resourceType    The resource type for which to execute the test
     * @param  {Function}       callback        Invoked when the test is complete
     * @throws {AssertionError}                 Thrown if any of the assertions fail
     */
    var _testHardDeleteForAccept = function(resourceType, callback) {
        var fns = resourceFns[resourceType];

        // Create a resource with an email invited into it
        var email = _emailForTenant(global.oaeTests.tenants.cam);
        TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, creatingUserInfo, acceptingUserInfo) {
            assert.ok(!err);

            // Create the resource, sending an invite to the target user
            fns.createSucceeds(creatingUserInfo.restContext, 'public', [email], [], function(resource) {
                EmailTestUtil.collectAndFetchAllEmails(function(messages) {
                    assert.strictEqual(messages.length, 1);

                    var message = _.first(messages);
                    var token = url.parse(AuthzTestUtil.parseInvitationUrlFromMessage(message).query.url, true).query.invitationToken;

                    // Delete the resource before we have a chance to accept
                    fns.deleteSucceeds(camAdminRestContext, creatingUserInfo.restContext, resource.id, function() {

                        // Now accept the invitation, ensuring no resources are reported as being
                        // added
                        AuthzTestUtil.assertAcceptInvitationSucceeds(acceptingUserInfo.restContext, token, function(result) {
                            assert.strictEqual(result.email, email);
                            assert.strictEqual(result.resources.length, 0);

                            // Ensure nothing went into the user's library
                            fns.getLibrarySucceeds(acceptingUserInfo.restContext, acceptingUserInfo.user.id, function(libraryItems) {
                                assert.strictEqual(libraryItems.length, 0);
                                return callback(creatingUserInfo, acceptingUserInfo, resource);
                            });
                        });
                    });
                });
            });
        });
    };

    /*!
     * Ensure that the appropriate activity is sent to a user when they accept an invitation for
     * any resource type. The resources that are created will be of the specified visibility, to
     * make it simple to create multiple variations of this test for different resource
     * visibilities
     *
     * @param  {String}         visibility      The visibility to use on the created resources
     * @param  {Function}       callback        Invoked when the test is complete
     * @throws {AssertionError}                 Thrown if any of the assertions fail
     */
    var _testActivityVisibilityForAccept = function(visibility, callback) {
        TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, creatingUserInfo, acceptingUserInfo) {
            assert.ok(!err);

            var email = _emailForTenant(global.oaeTests.tenants.cam);
            _createOneOfEachResourceType(creatingUserInfo, visibility, [email], [], function(resources) {
                var assertions = {'role': 'manager', 'membersSize': 2, 'librarySize': 1};
                _assertAcceptEmailInvitation(creatingUserInfo, acceptingUserInfo, resources, assertions, function() {

                    ActivityTestUtil.collectAndGetActivityStream(acceptingUserInfo.restContext, acceptingUserInfo.user.id, null, function(err, result) {
                        assert.ok(!err);

                        var activities = result.items;

                        // Ensure we have one accept activity for each resource
                        assert.strictEqual(activities.length, _.size(resourceAcceptActivityInfo));
                        _.each(resources, function(resource) {
                            var activityInfo = resourceAcceptActivityInfo[resource.resourceType];
                            var matchingActivities = _.filter(activities, function(activity) {
                                return (
                                    activity['oae:activityType'] === 'invitation-accept' &&
                                    activity.verb === 'accept' &&
                                    activity.actor['oae:id'] === acceptingUserInfo.user.id &&
                                    activity.object['oae:id'] === creatingUserInfo.user.id &&
                                    activity.target['oae:id'] === resource.id
                                );
                            });

                            assert.ok(matchingActivities);
                            assert.strictEqual(matchingActivities.length, 1);
                        });

                        return callback();
                    });
                });
            });
        });
    };

    /*!
     * Ensure that an email is sent for the specified resource type regardless of its visibility
     * when invited VIA a "create" action. This test will ensure that resources of the specified
     * type will send an invitation email to the email that was invited, and that the information in
     * the "accept" link can be used to accept the invitation and gain access to the resources
     *
     * @param  {String}         resourceType    The resource type for which to execute the test
     * @param  {Function}       callback        Invoked when the test is complete
     * @throws {AssertionError}                 Thrown if any of the assertions fail
     */
    var _testInvitationEmailVisibilityForCreate = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, creatingUser, acceptingUser) {
            assert.ok(!err);

            var email = _emailForTenant(global.oaeTests.tenants.cam);
            fns.createSucceeds(creatingUser.restContext, 'public', [email], [], function(resource1) {
                fns.createSucceeds(creatingUser.restContext, 'loggedin', [email], [], function(resource2) {
                    fns.createSucceeds(creatingUser.restContext, 'private', [email], [], function(resource3) {
                        var assertions = {'role': 'manager', 'membersSize': 2, 'librarySize': 3};
                        _assertAcceptEmailInvitation(creatingUser, acceptingUser, [resource1, resource2, resource3], assertions, function() {
                            return callback();
                        });
                    });
                });
            });
        });
    };

    /*!
     * Ensure that an email is sent for the specified resource type regardless of its visibility
     * when invited VIA a "set roles" action. This test will ensure that resources of the specified
     * type will send an invitation email to the email that was invited, and that the information in
     * the "accept" link can be used to accept the invitation and gain access to the resources
     *
     * @param  {String}         resourceType    The resource type for which to execute the test
     * @param  {Function}       callback        Invoked when the test is complete
     * @throws {AssertionError}                 Thrown if any of the assertions fail
     */
    var _testInvitationEmailVisibilityForSetRoles = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, creatingUser, acceptingUser) {
            assert.ok(!err);

            var email = _emailForTenant(global.oaeTests.tenants.cam);

            // Create a resource of each visibility
            fns.createSucceeds(creatingUser.restContext, 'public', [], [], function(resource1) {
                fns.createSucceeds(creatingUser.restContext, 'loggedin', [], [], function(resource2) {
                    fns.createSucceeds(creatingUser.restContext, 'private', [], [], function(resource3) {
                        var roleChange = _.object([[email, 'manager']]);

                        // Set the accepting user as a manager on all 3 using set roles
                        fns.setRolesSucceeds(creatingUser.restContext, creatingUser.restContext, resource1.id, roleChange, function() {
                            fns.setRolesSucceeds(creatingUser.restContext, creatingUser.restContext, resource2.id, roleChange, function() {
                                fns.setRolesSucceeds(creatingUser.restContext, creatingUser.restContext, resource3.id, roleChange, function() {

                                    // Ensure the user can accept the email invitation
                                    var assertions = {'role': 'manager', 'membersSize': 2, 'librarySize': 3};
                                    _assertAcceptEmailInvitation(creatingUser, acceptingUser, [resource1, resource2, resource3], assertions, function() {
                                        return callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    /*!
     * Ensure that an email is sent for the specified resource type regardless of its visibility
     * when invited VIA a "share" action. This test will ensure that resources of the specified
     * type will send an invitation email to the email that was invited, and that the information in
     * the "accept" link can be used to accept the invitation and gain access to the resources
     *
     * @param  {String}         resourceType    The resource type for which to execute the test
     * @param  {Function}       callback        Invoked when the test is complete
     * @throws {AssertionError}                 Thrown if any of the assertions fail
     */
    var _testInvitationEmailVisibilityForShare = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        var memberRole = resourceMemberRoles[resourceType];

        TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, creatingUser, acceptingUser) {
            assert.ok(!err);

            var email = _emailForTenant(global.oaeTests.tenants.cam);

            // Create a resource of each visibility
            fns.createSucceeds(creatingUser.restContext, 'public', [], [], function(resource1) {
                fns.createSucceeds(creatingUser.restContext, 'loggedin', [], [], function(resource2) {
                    fns.createSucceeds(creatingUser.restContext, 'private', [], [], function(resource3) {

                        // Share with each resource
                        fns.shareSucceeds(creatingUser.restContext, creatingUser.restContext, resource1.id, [email], function() {
                            fns.shareSucceeds(creatingUser.restContext, creatingUser.restContext, resource2.id, [email], function() {
                                fns.shareSucceeds(creatingUser.restContext, creatingUser.restContext, resource3.id, [email], function() {

                                    // Ensure the user can accept the email invitation
                                    var assertions = {'role': memberRole, 'membersSize': 2, 'librarySize': 3};
                                    _assertAcceptEmailInvitation(creatingUser, acceptingUser, [resource1, resource2, resource3], assertions, function() {
                                        return callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    /*!
     * Ensure that when an invitation is accepted, the response and side-effects (i.e., gaining
     * access to the invited resources) work as expected
     *
     * @param  {String}         resourceType    The resource type for which to execute the test
     * @param  {Function}       callback        Invoked when the test is complete
     * @throws {AssertionError}                 Thrown if any of the assertions fail
     */
    var _testInvitationAccept = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        var memberRole = resourceMemberRoles[resourceType];

        TestsUtil.generateTestUsers(camAdminRestContext, 3, function(err, users, user0, userManager, userViewer) {
            assert.ok(!err);

            var managerEmail = _emailForTenant(global.oaeTests.tenants.cam);
            var viewerEmail = _emailForTenant(global.oaeTests.tenants.cam);

            // Create a resource. 2 separate invitations will go out
            fns.createSucceeds(user0.restContext, 'public', [managerEmail], [viewerEmail], function(resource) {
                var resourceAuthzId = AuthzUtil.getAuthzId(resource);

                // Accept the manager invitation and ensure they show up in the members
                AuthzTestUtil.assertAcceptInvitationForEmailSucceeds(userManager.restContext, managerEmail, function(result, invitations) {
                    assert.strictEqual(invitations.length, 1);

                    var invitation = _.first(invitations);
                    assert.strictEqual(invitation.resourceId, resourceAuthzId);
                    assert.strictEqual(invitation.email, managerEmail);
                    assert.strictEqual(invitation.inviterUserId, user0.user.id);
                    assert.strictEqual(invitation.role, 'manager');

                    var assertions = {'role': 'manager', 'membersSize': 2, 'librarySize': 1};
                    _assertRole(user0, userManager, resource, assertions, function() {
                        // Accept the viewer invitation and ensure they show up in the members
                        AuthzTestUtil.assertAcceptInvitationForEmailSucceeds(userViewer.restContext, viewerEmail, function(result, invitations) {
                            assert.strictEqual(invitations.length, 1);

                            var invitation = _.first(invitations);
                            assert.strictEqual(invitation.resourceId, resourceAuthzId);
                            assert.strictEqual(invitation.email, viewerEmail);
                            assert.strictEqual(invitation.inviterUserId, user0.user.id);
                            assert.strictEqual(invitation.role, memberRole);

                            assertions = {'role': memberRole, 'membersSize': 3, 'librarySize': 1};
                            _assertRole(user0, userViewer, resource, assertions, function() {
                                return callback();
                            });
                        });
                    });
                });
            });
        });
    };

    /*!
     * Ensure authorization of accepting an invitation that contains a particular resource type.
     *
     * This also includes authorization revolving around the changed state of the inviting user. For
     * example, if the user who invited another has since been deleted, or is demoted/removed from
     * the resource, the invitation should still be successful.
     *
     * @param  {String}         resourceType    The resource type for which to execute the test
     * @param  {Function}       callback        Invoked when the test is complete
     * @throws {AssertionError}                 Thrown if any of the assertions fail
     */
    var _testInvitationAcceptAuthorization = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        var memberRole = resourceMemberRoles[resourceType];

        TestsUtil.generateTestUsers(camAdminRestContext, 6, function(err, users, user0, user1, user2, user3, user4, user5) {
            assert.ok(!err);

            var email1 = _emailForTenant(global.oaeTests.tenants.cam);
            var email2 = _emailForTenant(global.oaeTests.tenants.cam);
            var email3 = _emailForTenant(global.oaeTests.tenants.cam);
            var email4 = _emailForTenant(global.oaeTests.tenants.cam);
            var email5 = _emailForTenant(global.oaeTests.tenants.cam);

            fns.createSucceeds(user0.restContext, 'private', [email1], [], function(resource) {

                // Accept as user1
                AuthzTestUtil.assertAcceptInvitationForEmailSucceeds(user1.restContext, email1, function() {

                    // Ensure user1 can now set roles since they should be manager
                    var roles = {};
                    roles[email2] = 'manager';
                    roles[email3] = memberRole;
                    roles[email4] = memberRole;
                    roles[email5] = memberRole;
                    fns.setRolesSucceeds(user0.restContext, user1.restContext, resource.id, roles, function() {

                        // Remove the user who invited email2 and ensure email2 invitation can still be accepted
                        roles = {};
                        roles[user1.user.id] = false;
                        fns.setRolesSucceeds(user0.restContext, user0.restContext, resource.id, roles, function() {

                            // Ensure email2 can still be accepted and makes user2 a manager
                            AuthzTestUtil.assertAcceptInvitationForEmailSucceeds(user2.restContext, email2, function() {
                                _assertRole(user0, user2, resource, {'role': 'manager'}, function() {

                                    // Accept the "member" role invitation for email3 as user2, ensuring their role
                                    // on the resource does not get demoted to the "member" role
                                    AuthzTestUtil.assertAcceptInvitationForEmailSucceeds(user2.restContext, email3, function() {
                                        _assertRole(user0, user2, resource, {'role': 'manager'}, function() {

                                            // Delete user1 from the system, and ensure the user they
                                            // invited can still accept their invitation
                                            PrincipalsTestUtil.assertDeleteUserSucceeds(camAdminRestContext, camAdminRestContext, user1.user.id, function() {

                                                // Accept the invitation for email4 and ensure it succeeds despite the fact that
                                                // the user that invited them was deleted
                                                AuthzTestUtil.assertAcceptInvitationForEmailSucceeds(user4.restContext, email4, function() {
                                                    _assertRole(user0, user4, resource, {'role': memberRole}, function() {

                                                        // Remove the invitation for email5, ensuring an invitation for email5 can still
                                                        // be accepted, but it doesn't grant any access to the resource
                                                        roles = {};
                                                        roles[email5] = false;
                                                        fns.setRolesSucceeds(user0.restContext, user0.restContext, resource.id, roles, function() {
                                                            AuthzTestUtil.assertAcceptInvitationForEmailSucceeds(user5.restContext, email5, function() {
                                                                _assertRole(user0, user5, resource, {'role': false}, function() {
                                                                    return callback();
                                                                });
                                                            });
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    /*!
     * Ensure parameter validation for accepting an invitation
     *
     * @param  {String}         resourceType    The resource type for which to execute the test
     * @param  {Function}       callback        Invoked when the test is complete
     * @throws {AssertionError}                 Thrown if any of the assertions fail
     */
    var _testInvitationAcceptValidation = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 3, function(err, users, user0, acceptingUser, sneakyUser) {
            assert.ok(!err);

            var email = _emailForTenant(global.oaeTests.tenants.cam);

            // Token is required
            AuthzTestUtil.assertAcceptInvitationFails(sneakyUser.restContext, null, 400, function() {
                // Token must exist
                AuthzTestUtil.assertAcceptInvitationFails(sneakyUser.restContext, 'nonexistingtoken', 404, function() {

                    // Create a resource with an invitation
                    fns.createSucceeds(user0.restContext, 'public', [email], [], function(resource) {
                        AuthzInvitationsDAO.getTokensByEmails([email], function(err, tokensByEmail) {
                            assert.ok(!err);

                            var token = tokensByEmail[email];

                            // User must be logged in to accept
                            AuthzTestUtil.assertAcceptInvitationFails(anonymousRestContext, token, 401, function() {

                                // Sanity check we can accept with this token as authenticated user
                                AuthzTestUtil.assertAcceptInvitationSucceeds(acceptingUser.restContext, token, function() {

                                    // Ensure re-accepting this token as a sneaky user that intercepted it fails
                                    AuthzTestUtil.assertAcceptInvitationFails(sneakyUser.restContext, token, 404, function() {

                                        // Ensure the accepting user became a manager of the resource
                                        _assertRole(user0, acceptingUser, resource, {'role': 'manager'}, function() {

                                            // Ensure the sneaky user does not have the resource
                                            _assertRole(user0, sneakyUser, resource, {'role': false, 'membersSize': 2}, function() {
                                                return callback();
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    /*!
     * Ensure that the invitations list is persisted appropriately with the expected roles when
     * an invitation occurrs in the resource "create" request
     *
     * @param  {String}         resourceType    The resource type for which to execute the test
     * @param  {Function}       callback        Invoked when the test is complete
     * @throws {AssertionError}                 Thrown if any of the assertions fail
     */
    var _testInvitationsForCreate = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 3, function(err, users, user0, userManager, userViewer) {
            assert.ok(!err);

            // Ensure a simple create mixed with a couple member users succeeds
            fns.createSucceeds(user0.restContext, 'public', ['manager@oae.local', userManager.user.id], [userViewer.user.id, 'viewer@oae.local'], function(resource) {
                return callback();
            });
        });
    };

    /*!
     * Ensure parameter validation of inviting "email-like" strings when an invitation is attempted
     * in the resource "create" request
     *
     * @param  {String}         resourceType    The resource type for which to execute the test
     * @param  {Function}       callback        Invoked when the test is complete
     * @throws {AssertionError}                 Thrown if any of the assertions fail
     */
    var _testInvitationsValidationForCreate = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, user0) {
            assert.ok(!err);

            // Ensure variations of email addresses fail
            fns.createFails(user0.restContext, 'public', ['invalid@email'], [], 400, function(resource) {

                // Sanity check can be created with valid email
                fns.createSucceeds(user0.restContext, 'public', ['manager@oae.local'], [], function(resource) {
                    return callback();
                });
            });
        });
    };

    /*!
     * Ensure authorization of inviting users from a variety of different types of tenants when
     * inviting through the resource "create" action
     *
     * @param  {String}         resourceType    The resource type for which to execute the test
     * @param  {Function}       callback        Invoked when the test is complete
     * @throws {AssertionError}                 Thrown if any of the assertions fail
     */
    var _testInvitationsAuthorizationForCreate = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.setupMultiTenantPrivacyEntities(function(publicTenant0, publicTenant1, privateTenant0) {

            // Ensure cannot create content associated to an email from a private tenant
            fns.createFails(privateTenant0.publicUser.restContext, 'public', [_emailForTenantInfo(publicTenant0)], [], 401, function(resource) {
                // Ensure cannot create content associated to a private tenant
                fns.createFails(publicTenant0.publicUser.restContext, 'public', [_emailForTenantInfo(privateTenant0)], [], 401, function(resource) {
                    // Sanity check we can create content on our own private tenant
                    fns.createSucceeds(privateTenant0.publicUser.restContext, 'public', [_emailForTenantInfo(privateTenant0)], [], function(resource) {
                        // Ensure a user can create a loggedin item and share it with an email of a user from another tenant
                        fns.createSucceeds(publicTenant0.publicUser.restContext, 'loggedin', [_emailForTenantInfo(publicTenant1)], [], function(resource) {
                            return callback();
                        });
                    });
                });
            });
        });
    };

    /*!
     * Ensure that the invitations list is persisted appropriately with the expected roles when
     * an invitation occurrs in the resource "share" request
     *
     * @param  {String}         resourceType    The resource type for which to execute the test
     * @param  {Function}       callback        Invoked when the test is complete
     * @throws {AssertionError}                 Thrown if any of the assertions fail
     */
    var _testInvitationsForShare = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 3, function(err, users, userSharer, user0, user1) {
            assert.ok(!err);
            fns.createSucceeds(userSharer.restContext, 'public', ['email1@oae.local'], [], function(resource) {
                // Ensure a simple share works as expected. It should add the new email (email2) and
                // not demote the existing email (email1)
                fns.shareSucceeds(userSharer.restContext, userSharer.restContext, resource.id, [user0.user.id, 'email1@oae.local', 'email2@oae.local', user1.user.id], function() {
                    return callback();
                });
            });
        });
    };

    /*!
     * Ensure parameter validation of inviting "email-like" strings when an invitation is attempted
     * in the resource "share" request
     *
     * @param  {String}         resourceType    The resource type for which to execute the test
     * @param  {Function}       callback        Invoked when the test is complete
     * @throws {AssertionError}                 Thrown if any of the assertions fail
     */
    var _testInvitationsValidationForShare = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, user0) {
            assert.ok(!err);
            fns.createSucceeds(user0.restContext, 'public', [], [], function(resource) {
                // Ensure cannot share with a variation of an email address
                fns.shareFails(user0.restContext, user0.restContext, resource.id, ['email1@oae'], 400, function() {
                    // Sanity check share succeeds
                    fns.shareSucceeds(user0.restContext, user0.restContext, resource.id, ['email1@oae.local'], function() {
                        return callback();
                    });
                });
            });
        });
    };

    /*!
     * Ensure authorization of inviting users from a variety of different types of tenants and
     * resource visibilities when inviting through the resource "share" action
     *
     * @param  {String}         resourceType    The resource type for which to execute the test
     * @param  {Function}       callback        Invoked when the test is complete
     * @throws {AssertionError}                 Thrown if any of the assertions fail
     */
    var _testInvitationsAuthorizationForShare = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.setupMultiTenantPrivacyEntities(function(publicTenant0, publicTenant1, privateTenant0) {
            _testInvitationsAuthorizationForPublicShare(fns, publicTenant0, publicTenant1, privateTenant0, function() {
                _testInvitationsAuthorizationForLoggedinShare(fns, publicTenant0, publicTenant1, privateTenant0, function() {
                    _testInvitationsAuthorizationForPrivateShare(fns, publicTenant0, publicTenant1, privateTenant0, callback);
                });
            });
        });
    };

    /*!
     * Ensure the authorization contraints of sharing a public resource with emails from a variety
     * of different types of tenants are as expected
     *
     * @param  {Object}         fns             The functions specification for the resource type to test, as given in `resourceFns`
     * @param  {Object}         publicTenant0   The tenant info of a public tenant
     * @param  {Object}         publicTenant1   The tenant info of another public tenant
     * @param  {Object}         privateTenant0  The tenant info of a private tenant
     * @param  {Function}       callback        Invoked when the test is complete
     * @throws {AssertionError}                 Thrown if any of the assertions fail
     */
    var _testInvitationsAuthorizationForPublicShare = function(fns, publicTenant0, publicTenant1, privateTenant0, callback) {
        var managerUser = publicTenant0.publicUser;
        var viewerUser = publicTenant0.loggedinUser;
        // Create public resource with a viewer
        fns.createSucceeds(managerUser.restContext, 'public', [], [viewerUser.user.id], function(resource) {
            // Ensure manager user can invite users from all tenants except private
            fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant0)], function() {
                fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant1)], function() {
                    fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, ['thisemail0@defaultstoguest.local'], function() {
                        fns.shareFails(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(privateTenant0)], 401, function() {
                            // Ensure viewer user can invite users from all tenants except private
                            fns.shareSucceeds(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant0)], function() {
                                fns.shareSucceeds(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant1)], function() {
                                    fns.shareSucceeds(managerUser.restContext, viewerUser.restContext, resource.id, ['thisemail1@defaultstoguest.local'], function() {
                                        fns.shareFails(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(privateTenant0)], 401, function() {
                                            return callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    /*!
     * Ensure the authorization contraints of sharing a loggedin resource with emails from a variety
     * of different types of tenants are as expected
     *
     * @param  {Object}         fns             The functions specification for the resource type to test, as given in `resourceFns`
     * @param  {Object}         publicTenant0   The tenant info of a public tenant
     * @param  {Object}         publicTenant1   The tenant info of another public tenant
     * @param  {Object}         privateTenant0  The tenant info of a private tenant
     * @param  {Function}       callback        Invoked when the test is complete
     * @throws {AssertionError}                 Thrown if any of the assertions fail
     */
    var _testInvitationsAuthorizationForLoggedinShare = function(fns, publicTenant0, publicTenant1, privateTenant0, callback) {
        var managerUser = publicTenant0.publicUser;
        var viewerUser = publicTenant0.loggedinUser;
        // Create loggedin resource with a viewer
        fns.createSucceeds(managerUser.restContext, 'loggedin', [], [viewerUser.user.id], function(resource) {
            // Ensure manager user can invite users from all tenants except private
            fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant0)], function() {
                fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant1)], function() {
                    fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, ['thisemail0@defaultstoguest.local'], function() {
                        fns.shareFails(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(privateTenant0)], 401, function() {
                            // Ensure viewer user can invite users from only their own tenant
                            fns.shareSucceeds(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant0)], function() {
                                fns.shareFails(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant1)], 401, function() {
                                    fns.shareFails(managerUser.restContext, viewerUser.restContext, resource.id, ['thisemail1@defaultstoguest.local'], 401, function() {
                                        fns.shareFails(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(privateTenant0)], 401, function() {
                                            return callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    /*!
     * Ensure the authorization contraints of sharing a private resource with emails from a variety
     * of different types of tenants are as expected
     *
     * @param  {Object}         fns             The functions specification for the resource type to test, as given in `resourceFns`
     * @param  {Object}         publicTenant0   The tenant info of a public tenant
     * @param  {Object}         publicTenant1   The tenant info of another public tenant
     * @param  {Object}         privateTenant0  The tenant info of a private tenant
     * @param  {Function}       callback        Invoked when the test is complete
     * @throws {AssertionError}                 Thrown if any of the assertions fail
     */
    var _testInvitationsAuthorizationForPrivateShare = function(fns, publicTenant0, publicTenant1, privateTenant0, callback) {
        var managerUser = publicTenant0.publicUser;
        var viewerUser = publicTenant0.loggedinUser;
        // Create private resource with a viewer
        fns.createSucceeds(managerUser.restContext, 'private', [], [viewerUser.user.id], function(resource) {
            // Ensure manager user can invite users from all tenants except private
            fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant0)], function() {
                fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant1)], function() {
                    fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, ['thisemail@defaultstoguest.local'], function() {
                        fns.shareFails(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(privateTenant0)], 401, function() {
                            // Ensure viewer user can't invite anyone into a private item
                            fns.shareFails(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant0)], 401, function() {
                                fns.shareFails(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant1)], 401, function() {
                                    fns.shareFails(managerUser.restContext, viewerUser.restContext, resource.id, ['thisemail@defaultstoguest.local'], 401, function() {
                                        fns.shareFails(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(privateTenant0)], 401, function() {
                                            return callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    /*!
     * Ensure that the invitations list is persisted appropriately with the expected roles when
     * an invitation occurrs in the resource "set roles" request
     *
     * @param  {String}         resourceType    The resource type for which to execute the test
     * @param  {Function}       callback        Invoked when the test is complete
     * @throws {AssertionError}                 Thrown if any of the assertions fail
     */
    var _testInvitationsForSetRoles = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        var memberRole = resourceMemberRoles[resourceType];

        TestsUtil.generateTestUsers(camAdminRestContext, 3, function(err, users, userSetRoles, user0, user1) {
            assert.ok(!err);
            fns.createSucceeds(userSetRoles.restContext, 'public', ['email1@oae.local'], [], function(resource) {

                // Ensure a simple set roles works as expected. email1 should be demoted to the
                // member role, and email2 should be added as a manager
                var roles = {};
                roles[user0.user.id] = 'manager';
                roles[user1.user.id] = memberRole;
                roles['email1@oae.local'] = memberRole;
                roles['email2@oae.local'] = 'manager';

                // Set the roles for both members and invitations
                fns.setRolesSucceeds(userSetRoles.restContext, userSetRoles.restContext, resource.id, roles, function() {

                    // Now remove them all, ensuring the states are updated appropriately
                    var rolesRemove = AuthzTestUtil.createRoleChange(_.keys(roles), false);
                    fns.setRolesSucceeds(userSetRoles.restContext, userSetRoles.restContext, resource.id, rolesRemove, function() {
                        return callback();
                    });
                });
            });
        });
    };

    /*!
     * Ensure parameter validation of inviting "email-like" strings when an invitation is attempted
     * in the resource "set roles" request
     *
     * @param  {String}         resourceType    The resource type for which to execute the test
     * @param  {Function}       callback        Invoked when the test is complete
     * @throws {AssertionError}                 Thrown if any of the assertions fail
     */
    var _testInvitationsValidationForSetRoles = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, user0) {
            assert.ok(!err);
            fns.createSucceeds(user0.restContext, 'public', [], [], function(resource) {

                // Ensure invalid email is rejected
                fns.setRolesFails(user0.restContext, user0.restContext, resource.id, {'email1@oae': 'manager'}, 400, function() {
                    // Ensure invalid role for email is rejected
                    fns.setRolesFails(user0.restContext, user0.restContext, resource.id, {'email1@oae.local': 'invalidrole'}, 400, function() {
                        // Sanity check we can set roles with a valid role
                        fns.setRolesSucceeds(user0.restContext, user0.restContext, resource.id, {'email1@oae.local': 'manager'}, function() {
                            return callback();
                        });
                    });
                });
            });
        });
    };

    /*!
     * Ensure authorization of inviting users from a variety of different types of tenants when
     * inviting through the resource "set roles" action
     *
     * @param  {String}         resourceType    The resource type for which to execute the test
     * @param  {Function}       callback        Invoked when the test is complete
     * @throws {AssertionError}                 Thrown if any of the assertions fail
     */
    var _testInvitationsAuthorizationForSetRoles = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        var memberRole = resourceMemberRoles[resourceType];

        TestsUtil.setupMultiTenantPrivacyEntities(function(publicTenant0, publicTenant1, privateTenant0) {
            var managerUser = publicTenant0.publicUser;
            var viewerUser = publicTenant0.loggedinUser;

            // Create public resource with a viewer
            fns.createSucceeds(managerUser.restContext, 'public', [], [viewerUser.user.id], function(resource) {

                // Ensure viewer cannot invite VIA set roles
                fns.setRolesFails(managerUser.restContext, viewerUser.restContext, resource.id, {'email1@oae.local': memberRole}, 401, function() {
                    var rolesSameTenant = {};
                    var rolesExternalPublicTenant = {};
                    var rolesGuestTenant = {'email1@oae.local': memberRole};
                    var rolesExternalPrivateTenant = {};

                    rolesSameTenant[_emailForTenantInfo(publicTenant0)] = memberRole;
                    rolesExternalPublicTenant[_emailForTenantInfo(publicTenant1)] = memberRole;
                    rolesExternalPrivateTenant[_emailForTenantInfo(privateTenant0)] = memberRole;

                    // Ensure manager can set invitation roles for all emails they can interact with
                    fns.setRolesSucceeds(managerUser.restContext, managerUser.restContext, resource.id, rolesSameTenant, function() {
                        fns.setRolesSucceeds(managerUser.restContext, managerUser.restContext, resource.id, rolesExternalPublicTenant, function() {
                            fns.setRolesSucceeds(managerUser.restContext, managerUser.restContext, resource.id, rolesGuestTenant, function() {
                                fns.setRolesFails(managerUser.restContext, managerUser.restContext, resource.id, rolesExternalPrivateTenant, 401, function() {
                                    return callback();
                                });
                            });
                        });
                    });
                });
            });
        });
    };


    var _assertAdaptedActivities = function(inviterUserInfo, invitedUserInfo, otherUserInfo, resources, assertions, callback) {
        assertions = assertions || {};

        // Get the activities. We're not going to care what stream the activities came from, we
        // just need to get all activities associated to the people and resources in context
        ActivityTestUtil.collectAndGetActivityStream(inviterUserInfo.restContext, inviterUserInfo.user.id, null, function(err, result) {
            assert.ok(!err);

            var activity = _.first(result.items);
            inviterUserInfo = _withAdaptedInfo(inviterUserInfo, activity);
            invitedUserInfo = _withAdaptedInfo(invitedUserInfo, activity);
            otherUserInfo = _withAdaptedInfo(otherUserInfo, activity, {'contextId': _.first(resources).id});

            _assertStandardInvitationAcceptSummaries(inviterUserInfo, invitedUserInfo, otherUserInfo, resources);

            // Check the resource-specific summary match against this number of resources
            var match = assertions.matches[resources.length - 1];
            _assertContains(inviterUserInfo.summary, match);
            _assertContains(invitedUserInfo.summary, match);
            _assertContains(otherUserInfo.summary, match);

            return callback();
        });
    };

    var _assertStandardInvitationAcceptSummaries = function(inviterUserInfo, invitedUserInfo, otherUserInfo, resources, opts) {
        _assertNotContains(inviterUserInfo.summary, 'You ');
        _assertContains(inviterUserInfo.summary, invitedUserInfo.user.displayName);
        _assertContains(inviterUserInfo.summary, invitedUserInfo.user.profilePath);
        _assertContains(inviterUserInfo.summary, ' has accepted your invitation to ');

        // When the user who invited the user sees the activity from their activity feed, they see
        // the target resource(s) as the preview item(s)
        _.each(resources, function(resource) {
            assert.ok(_.findWhere(inviterUserInfo.previewItems, {'oae:id': resource.id}));
        });

        _assertContains(invitedUserInfo.summary, 'You have accepted ');
        _assertNotContains(invitedUserInfo.summary, ' your ');
        _assertContains(invitedUserInfo.summary, inviterUserInfo.user.displayName);
        _assertContains(invitedUserInfo.summary, inviterUserInfo.user.profilePath);
        _assertContains(invitedUserInfo.summary, '\'s invitation to ');

        // When the user who was invited sees the activity from their activity feed, they see the
        // target resource(s) as the preview item(s)
        _.each(resources, function(resource) {
            assert.ok(_.findWhere(invitedUserInfo.previewItems, {'oae:id': resource.id}));
        });

        _assertNotContains(otherUserInfo.summary, 'You ');
        _assertContains(otherUserInfo.summary, invitedUserInfo.user.displayName);
        _assertContains(otherUserInfo.summary, invitedUserInfo.user.profilePath);
        _assertNotContains(otherUserInfo.summary, ' your ');
        _assertContains(otherUserInfo.summary, inviterUserInfo.user.displayName);
        _assertContains(otherUserInfo.summary, inviterUserInfo.user.profilePath);
        _assertContains(otherUserInfo.summary, '\'s invitation to ');

        // When an uninvolved user sees the activity from the context of one of the target resources
        // (e.g., the target group activity feed), they see the user who was invited into the group
        assert.strictEqual(otherUserInfo.previewItems.length, 1);
        assert.strictEqual(otherUserInfo.previewItems[0]['oae:id'], invitedUserInfo.user.id);

        var numResources = _.size(resources);
        if (numResources <= 2) {
            _.each(resources, function(resource) {
                _assertContains(inviterUserInfo.summary, resource.displayName);
                _assertContains(invitedUserInfo.summary, resource.displayName);
                _assertContains(otherUserInfo.summary, resource.displayName);
                _assertContains(inviterUserInfo.summary, resource.profilePath);
                _assertContains(invitedUserInfo.summary, resource.profilePath);
                _assertContains(otherUserInfo.summary, resource.profilePath);
            });
        }

        if (numResources >= 2) {
            _assertContains(inviterUserInfo.summary, ' and ');
            _assertContains(invitedUserInfo.summary, ' and ');
            _assertContains(otherUserInfo.summary, ' and ');

        }

        if (numResources > 2) {
            var label = util.format(' %s others', numResources - 1);
            _assertContains(inviterUserInfo.summary, label);
            _assertContains(invitedUserInfo.summary, label);
            _assertContains(otherUserInfo.summary, label);

            // Ensure only 1 resource appears in the summary
            var numMatches = _.chain(resources)
                .filter(function(resource) {
                    return (
                        (inviterUserInfo.summary.indexOf(resource.displayName) !== -1) &&
                        (inviterUserInfo.summary.indexOf(resource.profilePath) !== -1) &&
                        (invitedUserInfo.summary.indexOf(resource.displayName) !== -1) &&
                        (invitedUserInfo.summary.indexOf(resource.profilePath) !== -1) &&
                        (otherUserInfo.summary.indexOf(resource.displayName) !== -1) &&
                        (otherUserInfo.summary.indexOf(resource.profilePath) !== -1)
                    );
                })
                .size()
                .value();
            assert.strictEqual(numMatches, 1);
        }
    };

    /*!
     * Collect pending emails, ensure the following:
     *
     *  * Email Contents:   Ensure the contents of the email contains each of the specified
     *                      resources
     *  * Invitation Link:  Ensure the invitation link is present and contains a token that allows
     *                      the email recipient to accept the invitation, gaining access to the
     *                      specified resources
     *  * Accepting:        Ensure that when the email recipient accepts the invitation, they are
     *                      given all the specified resources in their respective libraries feeds
     *                      and searches. Also, it ensures that the members feed of the accepted
     *                      resource contains the user who accepted the invitation
     *
     * @param  {Object}         invitingUserInfo        The user info of the user who performed the invitation
     * @param  {Object}         acceptingUserInfo       The user info of the user who should accept the invitation
     * @param  {Resource[]}     resources               The resources we expect to be accepted in this email invitation
     * @param  {Object}         assertions              The assertion data according to the context o the data setup
     * @param  {String}         assertions.role         The role, if any, we expect the user to have on each resource after accepting
     * @param  {Number}         assertions.membersSize  The expected size of the resource members libraries after accepting
     * @param  {Number}         assertions.librarySize  The expected size of the respective resource library after accepting
     * @param  {Function}       callback                Invoked when the test is complete
     * @throws {AssertionError}                         Thrown if any of the assertions fail
     */
    var _assertAcceptEmailInvitation = function(invitingUserInfo, acceptingUserInfo, resources, assertions, callback) {
        // Receive the email invitation, ensuring we only have 1
        EmailTestUtil.collectAndFetchAllEmails(function(messages) {
            assert.strictEqual(_.size(messages), 1);

            var message = _.first(messages);

            // Ensure the subject contains the display name of the sender
            assert.notEqual(message.subject.indexOf(invitingUserInfo.user.displayName), -1);

            // Ensure no direct resource profile paths are contained in the email, and that at least
            // one resource display name appears in the subject
            var hasOne = false;
            _.each(resources, function(resource) {
                _assertNotContains(message.html, resource.profilePath);
                 if (message.subject.indexOf(resource.displayName)) {
                    hasOne = true;
                 }
            });
            assert.ok(hasOne);

            // Ensure the token in the email is functional
            var token = url.parse(AuthzTestUtil.parseInvitationUrlFromMessage(message).query.url, true).query.invitationToken;
            AuthzTestUtil.assertAcceptInvitationSucceeds(acceptingUserInfo.restContext, token, function() {
                // Ensure the user has the specified role on all the resources
                var _done = _.chain(resources).size().after(callback).value();
                _assertRole(invitingUserInfo, acceptingUserInfo, resources, assertions, function() {
                    // Collect the accept email and respond with it
                    EmailTestUtil.collectAndFetchAllEmails(function(messages) {
                        assert.strictEqual(_.size(messages), 1);
                        return callback(_.first(messages));
                    });
                });
            });
        });
    };

    /*!
     * Ensure the potential member user has the given role (if any) on all the specified resources
     * including:
     *
     *  * Members Feed:     Ensure the members feed of the resource contains the resource
     *  * Library Feed:     Ensure the respective library feed of the user contains each resource
     *  * Library Search:   Ensure the respective library search of the user contains each resource
     *
     * @param  {Object}         managerUserInfo         The user info of a user who manages each resource
     * @param  {Object}         memberUserInfo          The user info of the user we are going to test for membership
     * @param  {Resource[]}     resources               The resources we are checking against for membership
     * @param  {Object}         assertions              The assertion data according to the context o the data setup
     * @param  {String}         assertions.role         The role, if any, we expect the user to have on each resource
     * @param  {Number}         assertions.membersSize  The expected size of the resource members libraries
     * @param  {Number}         assertions.librarySize  The expected size of the respective resource library
     * @param  {Function}       callback                Invoked when the test is complete
     * @throws {AssertionError}                         Thrown if any of the assertions fail
     */
    var _assertRole = function(managerUserInfo, memberUserInfo, resources, assertions, callback) {
        assertions = assertions || {};
        if (!_.isArray(resources)) {
            return _assertRole(managerUserInfo, memberUserInfo, [resources], assertions, callback);
        } else if (_.isEmpty(resources)) {
            return callback();
        }

        resources = resources.slice();
        var resource = resources.shift();
        var fns = resourceFns[resource.resourceType];

        // Ensure the members library feed has/doesn't have the user with the specified role
        fns.getMembersSucceeds(managerUserInfo.restContext, resource.id, function(members) {
            if (_.isNumber(assertions.membersSize)) {
                assert.strictEqual(members.length, assertions.membersSize);
            }

            var memberInfo = _.find(members, function(memberInfo) {
                return (memberInfo.profile.id === memberUserInfo.user.id);
            });

            if (assertions.role) {
                assert.ok(memberInfo);
                assert.strictEqual(memberInfo.role, assertions.role);
            } else {
                assert.ok(!memberInfo);
            }

            // Ensure the user's library for this type of resource has/doesn't have the resource
            fns.getLibrarySucceeds(memberUserInfo.restContext, memberUserInfo.user.id, function(libraryItems) {
                if (_.isNumber(assertions.librarySize)) {
                    assert.strictEqual(libraryItems.length, assertions.librarySize);
                }

                var resourceItem = _.findWhere(libraryItems, {'id': resource.id});
                if (assertions.role) {
                    assert.ok(resourceItem);
                } else {
                    assert.ok(!resourceItem);
                }

                // If we expect the user to have a role, we should ensure their respective resource
                // library has the item in it when searching. Otherwise, ensure it does not contain
                // the resource
                var searchAssertFn = (assertions.role) ? SearchTestUtil.assertSearchContains :
                    SearchTestUtil.assertSearchNotContains;

                var libraryName = resourceLibraryInfo[resource.resourceType];
                searchAssertFn(memberUserInfo.restContext, libraryName, [memberUserInfo.user.id], null, [resource.id], function() {
                    return _assertRole(managerUserInfo, memberUserInfo, resources, assertions, callback);
                });
            });
        });
    };

    var _assertInvitationContainsResourceHtml = function(html, resource) {
        _assertContains(html, resource.displayName);
        _assertNotContains(html, resource.profilePath);
    };

    var _assertAcceptInvitationContainsResourceHtml = function(html, resource) {
        _assertContains(html, resource.displayName);
        _assertContains(html, resource.profilePath);
    };

    var _assertContains = function(sourceStr, matchStr) {
        if (!matchStr) {
            assert.fail('Cannot assert against a falsey string');
        }

        assert.notEqual(sourceStr.indexOf(matchStr), -1);
    };

    var _assertNotContains = function(sourceStr, matchStr) {
        if (!matchStr) {
            assert.fail('Cannot assert against a falsey string');
        }

        assert.strictEqual(sourceStr.indexOf(matchStr), -1);
    };


    /*!
     * Convenience function to create one of each type of resource with the specified access
     *
     * @param  {Object}         creatingUserInfo    The user info to use to create each resource
     * @param  {String}         visibility          The visibility to apply to each resource
     * @param  {String[]}       managerIds          The managers of the resource
     * @param  {String[]}       memberIds           The members of the resource
     * @param  {Function}       callback            Invoked when the test is complete
     * @param  {Resource[]}     callback.resources  The created resources
     * @throws {AssertionError}                     Thrown if any of the assertions fail
     */
    var _createOneOfEachResourceType = function(creatingUserInfo, visibility, managerIds, memberIds, callback) {
        // Create a resource of each known type, aggregating them into the `createResults`
        // object
        var resources = [];
        var _done = _.chain(resourceFns).size().after(function() {
            return callback(resources);
        }).value();

        // Perform all the creates and kick off the assertions on the created resources
        // and invitations
        PrincipalsTestUtil.assertGetMeSucceeds(creatingUserInfo.restContext, function(me) {
            _.each(resourceFns, function(fns) {
                fns.createSucceeds(creatingUserInfo.restContext, visibility, managerIds, memberIds, function(resource) {
                    resources.push(resource);
                    return _done();
                });
            });
        });
    };

    var _withAdaptedInfo = function(userInfo, activity, opts) {
        opts = opts || {};
        opts.contextId = opts.contextId || userInfo.user.id;

        var adapter = UIAPI.getActivityAdapter();
        var adapted = adapter.adapt(opts.contextId, userInfo.user, [clone(activity)], Sanitization);
        var summary = adapted[0].summary;
        var previewItems = adapted[0].activityItems;
        return _.extend({}, userInfo, {
            'previewItems': previewItems,
            'summary': UIAPI.translate(summary.i18nKey, null, summary.i18nArguments)
        });
    };

    /**
     * Utility method that returns a stream that points to the OAE logo.
     *
     * @return {Stream}     A stream that points to the OAE logo that can be uploaded.
     */
    var _getOAELogoStream = function() {
        return fs.createReadStream(util.format('%s/data/oae-logo.png', __dirname));
    };

    /*!
     * Create an email whose domain matches that of the specified tenant info
     *
     * @param  {Object}     tenantInfo  The tenant info object
     * @param  {String}     [username]  The username of the email. One will be randomly generated if unspecified
     * @return {String}                 The created email
     */
    var _emailForTenantInfo = function(tenantInfo, username) {
        return _emailForTenant(tenantInfo.tenant, username);
    };

    /*!
     * Create an email whose domain matches that of the specified tenant
     *
     * @param  {Tenant}     tenant      The tenant
     * @param  {String}     [username]  The username of the email. One will be randomly generated if unspecified
     * @return {String}                 The created email
     */
    var _emailForTenant = function(tenant, username) {
        return _emailForDomain(tenant.emailDomain, username);
    };

    /*!
     * Create an email with the specified host and username
     *
     * @param  {String}     host        The host
     * @param  {String}     [username]  The username of the email. One will be randomly generated if unspecified
     * @return {String}                 The created email
     */
    var _emailForDomain = function(host, username) {
        return util.format('%s@%s', username || TestsUtil.generateTestUserId(), host);
    };

});
