/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var fs = require('fs');
var mkdirp = require('mkdirp');
var Path = require('path');
var ShortId = require('shortid');
var util = require('util');

var Cassandra = require('oae-util/lib/cassandra');
var Config = require('oae-config').config('oae-content');
var log = require('oae-logger').logger('local-storage');
var Revision = require('oae-content/lib/model').Revision;
var Validator = require('oae-util/lib/validator').Validator;



/**
 * An implementation that will store files on the local hard disk.
 * Unless you're running a deployment with only a single app server,
 * this won't work. (ie: only useful for development.)
 *
 * Technically, this backend could simply move the file to the correct location.
 * As a reference implementation we'll work with Streams however.
 */


//////////////////////
// Storage methods. //
//////////////////////

/**
 * @borrows Interface.store as Local.store
 */
var store = module.exports.store = function(ctx, stream, opts, callback) {
    opts = opts || {};
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only logged in users can store files.'}).isLoggedInUser(ctx);
    validator.check(opts.filename, {'code': 400, 'msg': 'Missing filename option'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Store the file on disk.
    _writeBody(ctx, stream, opts, function(err, uri) {
        if (err) {
            // Although we probably won't let anonymous upload files, we check it anyway..
            var userid = ctx.user() ? ctx.user().id : 'anonymous';
            log().error({'err': err}, 'Failed to store a content item for %s', userid);
            return callback(err);
        }

        // The file has been written to disk,
        // return the uri that holds all the necessary data.
        return callback(null, 'local:' + uri);
    });

};

/**
 * @borrows Interface.remove as Local.remove
 */
var remove = module.exports.remove = function(ctx, uri, callback) {
    callback = callback || function() {};
    var path = _resolveUri(ctx, uri.split(':')[1]);

    // Sanity check that we're actually writing in the file storage dir and not in /etc/passwd for example.
    var rootDir = _getRootDir(ctx);
    var resolvedPath = Path.resolve(path);
    if (resolvedPath.indexOf(rootDir) !== 0) {
        log().error({'err': err}, 'An attempt was made to write outside of the root file storage! %s tried to write to %s as uri %s', ctx.user().id, resolvedPath, uri);
        return callback({'code': 400, 'msg': 'The provided uri points outside of the root file storage!'});
    }

    fs.unlink(path, function(err) {
        if (err) {
            return callback({'code': 500, 'msg': err});
        }
        callback();
    });
};

/**
 * @borrows Interface.getDownloadLink as Local.getDownloadLink
 */
var getDownloadLink = module.exports.getDownloadLink = function(ctx, uri) {
    return {'code':200, 'url': '/files/' + uri.split(':')[1]};
};

/////////////////////
// Private methods //
/////////////////////

/**
 * @return {String} the absolute path to the directory where files should be stored.
 * @param  {Context}    ctx     The current execution context.
 * @private
 */
var _getRootDir = function(ctx) {
    var dir = Config.getValue(ctx.tenant().alias, 'storage', 'local-dir');
    return dir || tmp;
};

/**
 * Get the absolute path that matches a uri.
 * @param  {Context}    ctx     The current execution context.
 * @param  {String}     uri     The URI that needs to be resolved.
 * @return {String}             The absolute path for a URI.
 * @private
 */
var _resolveUri = function(ctx, uri) {
    var rootDir = _getRootDir(ctx);
    return util.format('%s/%s', rootDir, uri);
};

/**
 * Creates the directory structure and applies the correct file mode.
 * @param {String}   dir            The absolute path to the directory that needs to exist.
 * @param {Function} callback       A callback method.
 * @param {Object}   callback.err   An error object (if any)
 * @private
 */
var _ensureDirectoryExists = function(dir, callback) {
    mkdirp(dir, function(err, made) {
        if (err) {
            return callback({'code': 500, 'msg': err});
        }
        callback();
    });
};

/**
 * Pipes a filebody to disk.
 * @param {Context}  ctx            The current execution context.
 * @param {Stream}   stream         The filebody to stream to disk.
 * @param {Function} callback       A callback method.
 * @param {Object}   callback.err   An error object (if any)
 * @param {String}   callback.uri   The URI that can be used to retrieve a file.
 * @private
 */
var _writeBody = function(ctx, stream, opts, callback) {
    var rootDir = _getRootDir(ctx);
    var date = new Date();
    var id = ShortId.generate();
    var dir = util.format('%d/%d/%d/%d/%d/%s', date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), id);
    var localDir = util.format('%s/%s', rootDir, dir);
    _ensureDirectoryExists(localDir, function(err) {
        if (err) {
            return callback(err);
        }

        // Something that this storage backend can re-locate the file with later on.
        var uri = util.format('%s/%s', dir, opts.filename);

        // Create a writeable stream.
        var path = util.format('%s/%s', localDir, opts.filename);
        var writeStream = fs.createWriteStream(path);

        writeStream.on('error', function(err) {
            log().error({'err': err}, 'An error occurred while streaming an upload to disk.');
            callback(err);
        });

        stream.on('end', function() {
            callback(null, uri);
            stream.destroy();
            writeStream.destroySoon();
        });

        // Pipe it to disk.
        stream.resume();
        stream.pipe(writeStream);
    });
};