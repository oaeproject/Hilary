/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var assert = require('assert');
var ShortId = require('shortid');
var util = require('util');

var ConfigTestsUtil = require('oae-config/lib/test/util');
var RestAPI = require('oae-rest');
var TestsUtil = require('oae-tests/lib/util');

/**
 * Set up 2 public tenants and 2 private tenants, each with a public, loggedin, private set of users, groups and
 * content. The resulting model looks like this:
 *
 * ```
 *  {
 *      "publicTenant": {
 *          "tenant": <Tenant>,
 *          "anonymousRestContext": <RestContext>,
 *          "adminRestContext": <RestContext>,
 *          "publicGroup": <Group>,
 *          "loggedinGroup": <Group>,
 *          "privateGroup": <Group>,
 *          "publicContent": <Content>,
 *          "loggedinContent": <Content>,
 *          "privateContent": <Content>,
 *          "publicUser": {
 *              "user": <User>,
 *              "restContext": <RestContext>
 *          },
 *          "loggedinUser": { ... }
 *          "privateUser": { ... }
 *      },
 *      "publicTenant1": { ... },
 *      "privateTenant": { ... },
 *      "privateTenant1": { ... }
 *  }
 * ```
 *
 * @param  {Function}   Invoked when all the entities are set up
 * @throws {Error}      An assertion error is thrown if something does not get created properly
 */
var setupMultiTenantPrivacyEntities = module.exports.setupMultiTenantPrivacyEntities = function(callback) {
    // Create the tenants and users
    TestsUtil.setupMultiTenantPrivacyEntities(function(publicTenant, publicTenant1, privateTenant, privateTenant1) {
        // Create the content
        _setupTenant(publicTenant, function() {
            _setupTenant(publicTenant1, function() {
                _setupTenant(privateTenant, function() {
                    _setupTenant(privateTenant1, function() {
                        return callback(publicTenant, publicTenant1, privateTenant, privateTenant1);
                    });
                });
            });
        });
    });
};

var assertGetContentMembersSucceeds = module.exports.assertGetContentMembersSucceeds = function(restContext, contentId, start, limit, callback) {
    RestAPI.Content.getContentMembers(restContext, contentId, start, limit, function(err, result) {
        assert.ok(!err);
        assert.ok(result);
        assert.ok(_.isArray(result.results));
        assert.ok(_.isString(result.nextToken) || _.isNull(result.nextToken));

        // If a valid limit was specified (valid meaning above 0 and below the maximum amount of
        // 25), ensure the `nextToken` is shown if there were less than the expected amount of
        // results
        if (_.isNumber(limit) && limit > 0 && result.results.length < limit && limit <= 25) {
            assert.strictEqual(result.nextToken, null);
        }

        // Ensure each result has an id and a valid role
        _.each(result.results, function(result) {
            assert.ok(result);
            assert.ok(result.profile);
            assert.ok(result.profile.id);
            assert.ok(_.contains(['manager', 'viewer'], result.role));
        });

        return callback(result);
    });
};

var assertUpdateContentMembersSucceeds = module.exports.assertUpdateContentMembersSucceeds = function(managerRestContext, contentId, roleChanges, callback) {
    // Ensure the members library is currently built
    getAllContentMembers(managerRestContext, contentId, null, function(membersBeforeUpdate) {

        // Build the membership of the content item before we update it, and the expected membership
        // after the update
        membersBeforeUpdate = _getMemberRolesFromResults(membersBeforeUpdate);

        var expectedMembersAfterUpdate = _.extend({}, membersBeforeUpdate);
        _.each(roleChanges, function(role, memberId) {
            if (role === false) {
                delete expectedMembersAfterUpdate[memberId];
            } else {
                expectedMembersAfterUpdate[memberId] = role;
            }
        });

        // Perform the update, causing the library to update on-the-fly
        RestAPI.Content.updateMembers(managerRestContext, contentId, roleChanges, function(err) {
            assert.ok(!err);

            // Get the content members again and ensure they have the expected
            getAllContentMembers(managerRestContext, contentId, null, function(membersAfterUpdate) {
                membersAfterUpdate = _getMemberRolesFromResults(membersAfterUpdate);
                assert.deepEqual(membersAfterUpdate, expectedMembersAfterUpdate);

                // Test the library once more by purging and building the library from scratch
                LibraryAPI.Index.isStale(ContentConstants.library.MEMBERS_LIBRARY_INDEX_NAME, contentId, function(err, isStale) {
                    assert.ok(!err);
                    assert.strictEqual(isStale, false);
                    LibraryAPI.Index.purge(ContentConstants.library.MEMBERS_LIBRARY_INDEX_NAME, contentId, function(err) {
                        assert.ok(!err);
                        LibraryAPI.Index.isStale(ContentConstants.library.MEMBERS_LIBRARY_INDEX_NAME, contentId, function(err, isStale) {
                            assert.ok(!err);
                            assert.strictEqual(isStale, true);

                            // Now that we're running with a fresh library, ensure that the members we receive are what we expect
                            getAllContentMembers(managerRestContext, contentId, null, function(membersAfterUpdate) {
                                membersAfterUpdate = _getMemberRolesFromResults(membersAfterUpdate);
                                assert.deepEqual(membersAfterUpdate, expectedMembersAfterUpdate);

                                return callback();
                            });
                        });
                    });
                });
            });
        });
    });
};

var _getMemberRolesFromResults = function(members) {
    var memberRoles = {};
    _.each(members, function(member) {
        memberRoles[member.profile.id] = member.role;
    });
    return memberRoles;
};

var getAllContentMembers = module.exports.getAllContentMembers = function(restContext, contentId, opts, callback, _members, _responses, _nextToken) {
    _members = _members || [];
    _responses = _responses || [];
    if (_nextToken === null) {
        return callback(_members, _responses);
    }

    opts = opts || {};
    opts.batchSize = opts.batchSize || 25;
    assertGetContentMembersSucceeds(restContext, contentId, _nextToken, opts.batchSize, function(result) {
        _responses.push(result);
        return getAllContentMembers(restContext, contentId, opts, callback, _.union(_members, result.results), _responses, result.nextToken);
    });
};

/**
 * Create the content within a tenant.
 *
 * @param  {Tenant}     tenant          The tenant to setup
 * @param  {Function}   callback        Invoked when all the entities are set up
 * @throws {Error}                      An assertion error is thrown if something does not get created properly
 * @api private
 */
var _setupTenant = function(tenant, callback) {
    _createMultiPrivacyContent(tenant.adminRestContext, function(publicContent, loggedinContent, privateContent) {
        tenant.publicContent = publicContent;
        tenant.loggedinContent = loggedinContent;
        tenant.privateContent = privateContent;
        return callback();
    });
};

/**
 * Set up content of all privacies using the given rest context
 *
 * @param  {RestContext}    restCtx         The rest context to use
 * @param  {Function}       callback        Invoked when all the entities are set up
 * @throws {Error}                          An assertion error is thrown if something does not get created properly
 * @api private
 */
var _createMultiPrivacyContent = function(restCtx, callback) {
    _createContentWithVisibility(restCtx, 'public', function(publicContent) {
        _createContentWithVisibility(restCtx, 'loggedin', function(loggedinContent) {
            _createContentWithVisibility(restCtx, 'private', function(privateContent) {
                return callback(publicContent, loggedinContent, privateContent);
            });
        });
    });
};

/**
 * Create a piece of content with the specified visibility
 *
 * @param  {RestContext}    restCtx             The rest context to use
 * @param  {String}         visibility          The visibility of the user
 * @param  {Function}       callback            Invoked when all the entities are set up
 * @param  {Content}        callback.content    The piece of content that was created
 * @throws {Error}                              An assertion error is thrown if something does not get created properly
 * @api private
 */
var _createContentWithVisibility = function(restCtx, visibility, callback) {
    var randomId = util.format('%s-%s', visibility, ShortId.generate());
    RestAPI.Content.createLink(restCtx, 'displayName-' + randomId, 'description-' + randomId, visibility, 'http://www.oaeproject.org', null, null, function(err, content) {
        assert.ok(!err);
        return callback(content);
    });
};
