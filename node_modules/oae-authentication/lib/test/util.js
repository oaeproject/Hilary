/*
 * Copyright 2015 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');

var ConfigTestUtil = require('oae-config/lib/test/util');
var RestAPI = require('oae-rest');
var TestsUtil = require('oae-tests/lib/util');

var AuthenticationAPI = require('oae-authentication');
var AuthenticationConstants = require('oae-authentication/lib/constants').AuthenticationConstants;

/**
 * Assert that the authentication config can be updated and the authentication strategies get refreshed
 *
 * For method parameter descriptions, @see RestAPI.Config#updateConfig
 */
var assertUpdateAuthConfigSucceeds = module.exports.assertUpdateAuthConfigSucceeds = function(restContext, tenantAlias, configUpdate, callback) {
    // Update the config
    ConfigTestUtil.updateConfigAndWait(restContext, tenantAlias, configUpdate, function(err) {
        assert.ok(!err);
    });

    // Wait until the authentication API has finished refreshing its strategies
    AuthenticationAPI.once(AuthenticationConstants.events.REFRESHED_STRATEGIES, function(tenant) {

        // Verify that the changes were persisted correctly
        RestAPI.Config.getTenantConfig(restContext, tenantAlias, function(err, config) {
            assert.ok(!err);

            _.each(configUpdate, function(value, key) {
                var parts = key.split('/');
                assert.strictEqual(config[parts[0]][parts[1]][parts[2]], value);
            });

            return callback();
        });
    });
};

/**
 * Assert that a user can log in using the local authentication strategy
 *
 * @param  {RestContext}    restContext     The REST context with which to attempt to log in
 * @param  {String}         username        The username to log in with
 * @param  {String}         password        The password to log in with
 * @param  {Function}       callback        Invoked when the user has been logged in
 * @throws {Error}                          Thrown if the operation fails in an unexpected way
 */
var assertLocalLoginSucceeds = module.exports.assertLocalLoginSucceeds = function(restContext, username, password, callback) {
    RestAPI.Authentication.login(restContext, username, password, function(err) {
        assert.ok(!err);

        // Assert the user is logged in
        RestAPI.User.getMe(restContext, function(err, me) {
            assert.ok(!err);
            assert.ok(!me.anon);

            return callback();
        });
    });
};

/**
 * Assert that a user can log in using the google authentication strategy
 *
 * @param  {String}         tenantHost              The host of the tenant on which to log in through google
 * @param  {String}         [email]                 The email address of the user that will sign in. If null, no email will be returned in the mocked response
 * @param  {Function}       callback                Invoked when it's been verified the user has logged in through google
 * @param  {RestContext}    callback.restContext    The rest context that was used to sign in through google
 * @param  {Response}       callback.response       The response that came back from the google callback endpoint
 */
var assertGoogleLoginSucceeds = module.exports.assertGoogleLoginSucceeds = function(tenantHost, email, callback) {
    _mockGoogleResponse(email);

    // A user returns from Google sign-in and hits our API
    var restContext = TestsUtil.createTenantRestContext(tenantHost);
    restContext.followRedirect = false;
    RestAPI.Authentication.googleCallback(restContext, {'code': 'foo'}, function(err, body, response) {
        assert.ok(!err);
        assert.strictEqual(response.headers.location, '/me');

        // Assert we were signed in successfully
        RestAPI.User.getMe(restContext, function(err, me) {
            assert.ok(!err);
            assert.ok(!me.anon);
            assert.strictEqual(me.email, email.toLowerCase());
            assert.strictEqual(me.authenticationStrategy, 'google');

            return callback(restContext, response);
        });
    });
};

/**
 * Assert that a user can not log in using the google authentication strategy
 *
 * @param  {String}         tenantHost              The host of the tenant on which to log in through google
 * @param  {String}         [email]                 The email address of the user that will sign in. If null, no email will be returned in the mocked response
 * @param  {Function}       callback                Invoked when it's been verified the user was not able to sign in through google
 * @param  {RestContext}    callback.restContext    The rest context that was used to attempt to sign in through google
 * @param  {Response}       callback.response       The response that came back from the google callback endpoint
 */
var assertGoogleLoginFails = module.exports.assertGoogleLoginFails = function(tenantHost, email, reason, callback) {
    _mockGoogleResponse(email);

    // A user returns from the Google sign-in page and hits our API
    var restContext = TestsUtil.createTenantRestContext(tenantHost);
    restContext.followRedirect = false;
    RestAPI.Authentication.googleCallback(restContext, {'code': 'foo'}, function(err, body, response) {
        assert.ok(!err);
        assert.strictEqual(response.headers.location, '/?authentication=failed&reason=' + reason);

        // Assert we are still anonymous
        RestAPI.User.getMe(restContext, function(err, me) {
            assert.ok(!err);
            assert.ok(me.anon);

            return callback(restContext, response);
        });
    });
};

/**
 * Mock the requests the google passport strategy will make
 *
 * @param  {String}         [email]                 The email address of the user that will sign in. If null, no email will be returned in the mocked response
 * @api private
 */
var _mockGoogleResponse = function(email) {
    // Require nock in-line as it messes with the HTTP stack
    // We only want this to happen in a controlled environment
    var nock = require('nock');

    // Ensure we can still perform regular HTTP requests during our tests
    nock.enableNetConnect();

    // Mock the "get access token" request in the OAuth2 cycle
    var accessToken = _.random(10000);
    nock('https://accounts.google.com')
        .post('/o/oauth2/token')
        .reply(200, {
            'access_token': accessToken,
            'refresh_token': 'foo'
        });

    // Mock the "get user profile" request
    var mockedResponse = {
        'kind': 'plus#person',
        'etag': 'RqKWnRU4WW46-6W3rWhLR9',
        'gender': 'male',
        'emails': [],
        'urls': [
            {'value': 'http://www.youtube.com/user/abc123','type': 'otherProfile','label': 'ABC 123'},
        ],
        'objectType': 'person',
        'id': _.random(100000),
        'displayName': 'Foo Bar',
        'name': {
            'familyName': 'Bar',
            'givenName': 'Foo'
        },
        'url': 'https://plus.google.com/' + _.random(10000000),
        'image': {
            'url': 'https://lh5.googleusercontent.com/-wfVubfsOBV0/AAAAAAAAAAI/AAAAAAAAAGQ/rEb5FmsQuiA/photo.jpg?sz=50',
            'isDefault': false
        },
        'isPlusUser': true,
        'language': 'en',
        'verified': false
    };
    if (email) {
        mockedResponse.emails.push({'value': email, 'type': 'account'});
    }
    nock('https://www.googleapis.com')
        .get('/plus/v1/people/me?access_token=' + accessToken)
        .reply(200, mockedResponse);
};
