var principalsAPI = require('oae-principals');
var permissionsAPI = require('oae-permissions');
var rolesUtil = require('oae-roles/lib/util');
var Context = require('oae-context').Context;
var Tenant = require('oae-tenants/lib/model').Tenant;


/**
 * Load the user, group and membership data from the model-loader scripts specified in scriptsDir.
 *
 * @param {Array<String>}           tenantIds       The tenants to run concurrently. All tenants will have the same data loaded.
 * @param {Object}                  results         An object to which the dataload process can attach timing results
 * @param {Function(err, model)}    callback        The function invoked when dataloading is complete
 * @param {Object}                  callback.err    An error that occurred, if any
 */
module.exports.dataload = function(tenantIds, model, results, callback) {

    results.dataload = {};

    // status vars for loader tracking
    var start = new Date().getTime();
    var resultErr = false;
    var numTenants = tenantIds.length;
    var tenantsFinished = 0;

    var trackModelLoading = function(err, tenant) {
        if (resultErr) {
            // do nothing, we already exited
        } else if (err) {
            // we received an error (for the first time), invoke callback with error
            resultErr = err;
            callback(resultErr);
        } else {
            tenantsFinished++;
            if (tenantsFinished === numTenants) {
                callback();
            }
        }
    };

    tenantIds.forEach(function(tenantId) {
        var tenant = new Tenant(tenantId, 'load-test', 'load-test', 2001, 'google.ca');
        persistModel(tenant, model, results.dataload, function(err) {
            trackModelLoading(err, tenant);
        });
    });
};

/**
 * Run the performance test concurrently for the given tenants on the model. The performance test results
 * should be attached to the results parameter object.
 *
 * @param {Array<String>}   tenantIds       An array of tenant ids for which to run the tests
 * @param {Object}          model           The data model to test against
 * @param {Object}          results         A results object that aggregates resulting timing information
 * @param {Function(err)}   callback        The method invoked when the process completes
 * @param {Object}          callback.err    An error that occurred, if any
 */
module.exports.performanceTest = function(tenantIds, model, results, callback) {
    var performance = results.performanceTest = {};

    performanceTestValidPermissions(tenantIds, model, function(err, duration, totalChecks) {
        if (!err) {
            performance['valid-permissions'] = {
                'duration': duration,
                'checks': totalChecks,
                'checksPerSecond': (totalChecks*1000)/duration

            };

            performanceTestAllPermissions(tenantIds, model, function(err, duration, totalChecks) {
                if (!err) {
                    performance['all-permissions'] = {
                        'duration': duration,
                        'checks': totalChecks,
                        'checksPerSecond': (totalChecks*1000)/duration
                    };

                    callback();
                } else {
                    callback(err);
                }
            });
        } else {
            callback(err);
        }
    });
}

// Performance test known membership permission checks
var performanceTestValidPermissions = function(tenantIds, model, callback) {
    var checks = getValidPermissionChecks(model);
    console.log('Checking all valid %s membership permissions.', checks.length);
    checkPermissionsForTenants(tenantIds.slice(0), checks, true, callback);
}

// Performance test all potential membership checks. This will result in a lot of failures
var performanceTestAllPermissions = function(tenantIds, model, callback) {
    // aggregate all potential checks
    var checks = getAllPermissionChecks(model);
    console.log('Checking all potential %s membership permissions.', checks.length);
    checkPermissionsForTenants(tenantIds.slice(0), checks, null, callback);
}

// perform all the checks provided in the 'checks' array, concurrently for all provided tenants
var checkPermissionsForTenants = function(tenantIds, checks, expect, callback) {
    var tenantsToRun = tenantIds.length;
    var tenantsRun = 0;
    var resultErr = false;
    var start = new Date().getTime();

    var checkStatus = function(err) {
        if (resultErr) {
            // do nothing, we already erred
        } else if (err) {
            resultErr = err;
            return callback(resultErr);
        } else {
            tenantsRun++;
            if (tenantsRun === tenantsToRun) {
                var duration = new Date().getTime() - start;
                return callback(null, duration, tenantsToRun*checks.length);
            }
        }
    }

    // sweep permissions checks for all tenants
    tenantIds.forEach(function(tenantId) {
        checkPermissionsForTenant(tenantId, checks.slice(0), expect, checkStatus);
    });
}

// perform all the checks in the provided 'checks' array for the given tenant
var checkPermissionsForTenant = function(tenantId, checks, expect, callback) {

    if (checks.length === 0) {
        return callback();
    }

    if (checks.length % 100 === 0) {
        console.log('[%s] %s permission checks remaining.', tenantId, checks.length);
    }

    var check = checks.pop();
    var groupUuid = rolesUtil.toUuid('g', tenantId, check.groupId);
    var principalUuid = rolesUtil.toUuid(check.principalType, tenantId, check.principalId);
    var permission = check.permission;

    permissionsAPI.isAllowed(principalUuid, permission, groupUuid, function(err, isAllowed) {
        if (!err) {
            if (expect === null || expect === isAllowed) {
                checkPermissionsForTenant(tenantId, checks, expect, callback);
            } else {
                callback("Check "+JSON.stringify(check)+" failed with isAllowed: "+isAllowed);
            }
            
        } else {
            callback(err);
        }
    });
}

// persist the given model for the given tenant.
var persistModel = function(tenant, model, results, callback) {

    results.users = {};
    results.groups = {};
    results.memberships = {};

    var start = new Date().getTime();
    var now = null;
    persistUsers(tenant, model.users.slice(0), function(err) {
        if (!err) {
            now = new Date().getTime();
            results.users.num = model.users.length;
            results.users.time = now - start;
            results.users.perSecond = (model.users.length*1000) / results.users.time;

            start = now;
            persistGroups(tenant, model.groups.slice(0), function(err) {
                if (!err) {
                    now = new Date().getTime();
                    results.groups.num = model.groups.length;
                    results.groups.time = now - start;
                    results.groups.perSecond = (model.groups.length*1000) / results.groups.time;

                    start = now;
                    return persistMemberships(tenant, model.memberships.slice(0), function(err) {
                        if (!err) {
                            now = new Date().getTime();
                            results.memberships.num = model.memberships.length;
                            results.memberships.time = now - start;
                            results.memberships.perSecond = (model.memberships.length*1000) / results.memberships.time;

                            callback();
                        } else {
                            return callback(err);
                        }
                    });
                } else {
                    return callback(err);
                }
            });
        } else {
            return callback(err);
        }
    });
}

// persist the given array of memberships
var persistMemberships = function(tenant, memberships, callback) {
    if (memberships.length === 0) {
        return callback();
    }

    if (memberships.length % 100 === 0) {
        console.log('[%s] MEMBERSHIPS - %s remaining.', tenant.alias, memberships.length);
    }

    var membership = memberships.pop();
    var creatorUuid = rolesUtil.toUuid('u', tenant.alias, membership.creatorId);
    var groupUuid = rolesUtil.toUuid('g', tenant.alias, membership.groupId);
    var memberUuid = rolesUtil.toUuid(membership.memberType, tenant.alias, membership.memberId);

    if (creatorUuid !== memberUuid && groupUuid !== memberUuid) {
        principalsAPI.getUser(creatorUuid, function(err, creator) {
            if (!err) {
                var ctx = new Context(tenant, creator);

                principalsAPI.addGroupMember(ctx, groupUuid, memberUuid, membership.role, function(err) {
                    if (!err) {
                        return persistMemberships(tenant, memberships, callback);
                    } else {
                        return callback(err);
                    }
                })
            } else {
                return callback(err);
            }
        });
    } else {
        return persistMemberships(tenant, memberships, callback);
    }
}

// persist the given array of groups
var persistGroups = function(tenant, groups, callback) {
    if (groups.length === 0) {
        return callback();
    }

    if (groups.length % 100 === 0) {
        console.log('[%s] GROUPS - %s remaining.', tenant.alias, groups.length);
    }

    var group = groups.pop();
    principalsAPI.getTenantUser(tenant, group.creator, function(err, creator) {
        if (!err) {
            var ctx = new Context(tenant, creator);
            principalsAPI.createGroup(ctx, group.id, 'performance-testing', function(err, groupUuid) {
                if (!err) {
                    // record persistent information into the hash
                    return persistGroups(tenant, groups, callback);
                } else {
                    return callback(err);
                }
            });
        } else {
            return callback(err);
        }
    });
}

// persist the given array of users
var persistUsers = function(tenant, users, callback) {
    if (users.length === 0) {
        return callback();
    }

    if (users.length % 10 === 0) {
        console.log('[%s] USERS - %s remaining.', tenant.alias, users.length);
    }

    var user = users.pop();
    principalsAPI.createUser(tenant, user.userid, user.userid, user.userAccountPrivacy, user.firstName, user.lastName, user.basicInfo.displayName, function(err, userUuid) {
        if (!err) {
            return persistUsers(tenant, users, callback);
        } else {
            return callback(err);
        }
    });
}

// Get all possible combinations of membership permission checks for the given model
var getAllPermissionChecks = function(model) {
    var checks = [];
    model.groups.forEach(function(group) {
        // only include groups that have roles
        if (group.roles) {
            model.users.forEach(function(user) {
                checks.push({
                    principalId: user.userid,
                    principalType: 'u',
                    permission: 'member',
                    groupId: group.id
                })
            });
        }
    });
    return checks;
}

// Get all the positive membership permission checks for the given model
var getValidPermissionChecks = function(model) {
    var checks = [];
    model.memberships.forEach(function(membership) {
        checks.push({
            principalId: membership.memberId,
            principalType: membership.memberType,
            permission: membership.role,
            groupId: membership.groupId
        });
    });
    return checks;
}
