/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var events = require('events');
var fs = require('fs');
var nodemailer = require('nodemailer');
var path = require('path');
var util = require('util');

var IO = require('oae-util/lib/io');
var log = require('oae-logger').logger('oae-email');
var OaeModules = require('oae-util/lib/modules');
var Validator = require('oae-util/lib/validator').Validator;

var EmailConfig = require('oae-config').config('oae-email');

// These hashes cache both the base templates (in the source tree) and the tenant override templates
// (provided in a directory by a system configuration property).
var baseCompiledTemplates = {};
var overrideCompiledTemplates = {};

/*!
 * The configuration value that specifies where the override templates lay.
 */
var customEmailTemplatesDir = null;

/*!
 * Whether or not the server is in debug mode. If true, no emails will ever be sent, instead the email
 * data will be logged. This is equivalent to "disabling" emails.
 */
var debug = true;

/*!
 * The cached smtp connection pool with the configured smtp values.
 */
var smtpTransport = null;

/**
 * ## EmailAPI
 *
 * ### Events
 *
 * * `debugSent(message)` - If `debug` is enabled, this event is fired and indicates an email was sent from the system. The `message` object, which is a MailComposer-compatable object is provided
 *
 * ### Templates
 *
 * All emails that are sent are based on an internationalizable template. To load a new template for the system, you must
 * create a directory in your OAE module called `emailTemplates`. The directory structure looks like this (using oae-content
 * as an example):
 *
 *  * oae-content/                              (module directory)
 *      ** emailTemplates/                      (directory that is scanned by oae-email)
 *          *** default/                        (the default templates, chosen if there is no locale)
 *              **** templateId.meta.json.jst   (the "meta" template for template with id "templateId")
 *              **** templateId.html.jst        (the "html" template for template with id "templateId")
 *              **** templateId.txt.jst         (the "text" template for template with id "templateId")
 *          *** en_CA/                          (the en_CA locale templates, used if the receiving user has locale en_CA)
 *              **** templateId.meta.json.jst
 *              **** templateId.html.jst
 *              **** templateId.txt.jst
 *
 * **The 'default' locale:** The default locale is chosen if the user's locale does not have a template provided for it.
 * **The 'meta.json' template:** This template should produce a JSON object that specifies email metadata. This template **must** exist, and should at least provide the "subject" of the email.
 * **The 'html' template:** This template provides an HTML-formatted version of the email content. One of HTML and TXT templates must be provided.
 * **The 'txt' template:** This template provides a plain-text version of the email content. If this is not provided, the HTML version will be converted to plain-text in replacement. One of HTML and TXT must be provided.
 *
 * Template overrides can be specified on a per-tenant basis. The overrides directory can be specified with the config property
 * `customEmailTemplatesDir`. If a template is overridden (e.g., exists in the override directory), it will be selected over
 * the base templates. The template directory structure is the same as the base templates, except each module directory should
 * exist in a folder named after the tenant alias that is overridden.
 *
 * ### JST Files
 *
 * All templates: meta.json.jst, html.jst and txt.jst are JavaScriptTemplates, and are compiled and rendered using UnderscoreJS:
 * http://underscorejs.org/#template
 */
var EmailAPI = module.exports = new events.EventEmitter();

/**
 * Initialize the email module.
 *
 * @param  {Object}     emailSystemConfig   The email config object from the system `config.js`. Refer to this file for the configuration options.
 * @param  {Function}   callback            Invoked when emails have been initialized
 * @param  {Object}     callback.err        An error that occurred, if any
 */
var init = module.exports.init = function(emailSystemConfig, callback) {
    customEmailTemplatesDir = emailSystemConfig.customEmailTemplatesDir;
    debug = (emailSystemConfig.debug !== false);

    if (debug && smtpTransport) {
        // Close the smtp transport if we're in debug mode
        smtpTransport.close();
        smtpTransport = null;
    } else if (!debug && !smtpTransport) {
        // Open an smtp transport if we're not in debug
        smtpTransport = nodemailer.createTransport('SMTP', emailSystemConfig.smtpTransport);
    }

    return refreshTemplates(callback);
};

/**
 * Refresh the email templates used for sending emails. This refreshes both the base templates located in the source
 * packages as well as the overrides provided in the directory configured by the system `config.js` file.
 *
 * @param  {Function}   callback        Invoked when the templates have been refreshed.
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var refreshTemplates = module.exports.refreshTemplates = function(callback) {
    // First refresh the base templates an then the override templates
    _refreshBaseTemplates(function(err) {
        if (err) {
            return callback(err);
        }

        return _refreshOverrideTemplates(customEmailTemplatesDir, callback);
    });
};

/**
 * Send a templated email to a user.
 *
 * @param  {String}     templateModule      The module that provides the template (e.g., 'oae-email')
 * @param  {String}     templateId          The id of the template
 * @param  {User}       toUser              The user that will be receiving the email. This is accessible in the email templates (e.g., `<%= user.displayName %>`)
 * @param  {String}     toUser.email        The email address of the user. If this is not available an error with code 400 is returned and no email is sent
 * @param  {Object}     [data]              An object that represents the data of the email. This will be accessible in the email templates (e.g., `<%= data.activity['displayName'] %>`)
 * @param  {Object}     [opts]              Additional options
 * @param  {Function}   [callback]          Invoked when the email has been sent
 * @param  {Object}     [callback.err]      An error that occurred, if any
 */
var sendEmail = module.exports.sendEmail = function(templateModule, templateId, toUser, data, opts, callback) {
    data = data || {};
    opts = opts || {};
    callback = callback || function(err) {
        if (err && err.code === 400) {
            log().error({'err': err}, 'Failed to deliver due to validation error');
        }
    };

    var validator = new Validator();
    validator.check(templateModule, {'code': 400, 'msg': 'Must specify a template module'}).notEmpty();
    validator.check(templateId, {'code': 400, 'msg': 'Must specify a template id'}).notEmpty();
    validator.check(null, {'code': 400, 'msg': 'Must specify a user when sending an email'}).isObject(toUser);

    // Only validate the user email if it was a valid object
    if (toUser) {
        validator.check(toUser.email, {'code': 400, 'msg': 'User must have a valid email address to receive email'}).isEmail();
    }

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    log().trace({
        'templateModule': templateModule,
        'templateId': templateId,
        'toUser': toUser,
        'data': data,
        'opts': opts
    }, 'Preparing template for mail to be sent.');

    var renderedTemplates = {};

    var templateCtx = {'user': toUser, 'data': data};
    var metaTemplate = _resolveTemplate(toUser.tenant, templateModule, toUser.locale, templateId, 'meta.json');
    var htmlTemplate = _resolveTemplate(toUser.tenant, templateModule, toUser.locale, templateId, 'html');
    var txtTemplate = _resolveTemplate(toUser.tenant, templateModule, toUser.locale, templateId, 'txt');

    // Verify the user templates have enough data to send an email
    if (!metaTemplate) {
        var noMetaTemplateErr = {'code': 500, 'msg': 'No email metadata template existed for user'};
        log().error({
            'err': noMetaTemplateErr,
            'templateModule': templateModule,
            'templateId': templateId,
            'toUser': {
                'id': toUser.id,
                'locale': toUser.locale
            }}, noMetaTemplateErr.msg);
        return callback(noMetaTemplateErr);
    } else if (!htmlTemplate && !txtTemplate) {
        var noContentTemplateErr = {'code': 500, 'msg': 'No email content (text or html) template existed for user'};
        log().error({
            'err': noContentTemplateErr,
            'templateModule': templateModule,
            'templateId': templateId,
            'toUser': {
                'id': toUser.id,
                'locale': toUser.locale
        }}, noContentTemplateErr.msg);
        return callback(noContentTemplateErr);
    }

    renderedTemplates = {};
    var metaContent = null;
    var htmlContent = null;
    var txtContent = null;

    try {
        // Try and parse the meta template into JSON
        metaContent = JSON.parse(metaTemplate(templateCtx));
    } catch (metaErr) {
        log().error({
            'err': metaErr,
            'templateModule': templateModule,
            'templateId': templateId,
            'toUser': {
                'id': toUser.id,
                'locale': toUser.locale
            }
        }, 'Error parsing email metadata template for user');
        return callback({'code': 500, 'msg': 'Error parsing email metadata template for user'});
    }

    // Try and render the html template
    if (htmlTemplate) {
        try {
            htmlContent = htmlTemplate(templateCtx);
        } catch (htmlErr) {
            log().warn({
                'err': htmlErr,
                'templateModule': templateModule,
                'templateId': templateId,
                'toUser': {
                    'id': toUser.id,
                    'locale': toUser.locale
                }
            }, 'Failed to parse email html template for user');
        }
    }

    // Try and render the text template
    if (txtTemplate) {
        try {
            txtContent = txtTemplate(templateCtx);
        } catch (txtErr) {
            log().warn({
                'err': txtErr,
                'templateModule': templateModule,
                'templateId': templateId,
                'toUser': {
                    'id': toUser.id,
                    'locale': toUser.locale
                }
            }, 'Failed to parse email html template for user');
        }
    }

    if (htmlContent || txtContent) {
        // If one of HTML or TXT templates managed to render, we will send the email with the content we have
        renderedTemplates['meta.json'] = metaContent;
        renderedTemplates['html'] = htmlContent;
        renderedTemplates['txt'] = txtContent;
    } else {
        return callback({'code': 500, 'msg': 'Could not parse a suitable content template for user'});
    }

    // Build the email object that will be sent through nodemailer. The 'from' property can be overridden by
    // the meta.json, then we further override that with some hard values
    var emailInfo = _.extend({'from': EmailConfig.getValue(toUser.tenant, 'general', 'from')}, renderedTemplates['meta.json'], {
        'to': toUser.email,
        'generateTextFromHTML': true
    });

    if (renderedTemplates['txt']) {
        emailInfo.text = renderedTemplates['txt'];
    }

    if (renderedTemplates['html']) {
        emailInfo.html = renderedTemplates['html'];
    }

    if (debug) {
        // When in debug mode, manually create the raw email object (email headers and all) and
        // output the email that *would* have been sent
        var mailObj = new nodemailer.Nodemailer(emailInfo);
        mailObj.generateMailObject();

        log().info({
            'emailInfo': emailInfo,
            'mailObj': mailObj.mailcomposer
        }, 'Sending email to %s', emailInfo.to);

        EmailAPI.emit('debugSent', mailObj.mailcomposer);
        
        return callback();
    } else {
        // We are not debugging, so send the email
        smtpTransport.sendMail(emailInfo, function(err, response) {
            if (err) {
                log().error({'err': err}, 'Error sending email to recipient.');
                return callback(err);
            }

            return callback();
        });
    }
};

/**
 * Refresh the base email templates, which are the ones located within the module source packages. If the
 * process is unsuccessful (an `err` is returned), there will be no change to the base email templates.
 *
 * @param  {Function}   callback        Invoked when the process completes
 * @param  {Object}     callback.err    An error that occurred, if any
 * @api private
 */
var _refreshBaseTemplates = function(callback) {
    var modules = OaeModules.getAvailableModules();

    // Refresh the base templates (from the oae source code repository)
    _compileTemplatesForModules(__dirname + '/../..', modules, function(err, newCompiledTemplates) {
        if (err) {
            return callback(err);
        }

        baseCompiledTemplates = newCompiledTemplates;
        return callback();
    });
};

/**
 * Refresh the tenant override email templates. If this fails, there is no change to the existing cached templates,
 * if any.
 *
 * @param  {String}     basedir         The base directory where the tenant override email templates are located
 * @param  {Function}   callback        Invoked when the templates have been refreshed
 * @param  {Object}     callback.err    An error that occurred, if any
 * @api private
 */
var _refreshOverrideTemplates = function(basedir, callback) {
    if (!basedir) {
        return callback();
    }

    var modules = OaeModules.getAvailableModules();

    // Overrides for a tenant are stored in a folder named after the tenant alias
    IO.getFileListForFolder(basedir, function(err, tenantAliases) {
        if (err) {
            return callback(err);
        }

        _compileTemplatesForTenants(basedir, tenantAliases, modules, function(err, newCompiledTemplates) {
            if (err) {
                return callback(err);
            }

            overrideCompiledTemplates = newCompiledTemplates;
            return callback();
        });
    });
};

/**
 * Compile the templates for a list of tenants.
 *
 * @param  {String}     basedir                     The base directory where the tenant folders are located
 * @param  {String[]}   tenantAliases               The list of tenant aliases for which to compile templates
 * @param  {String[]}   modules                     The list of modules for which to compile templates for each tenant
 * @param  {Function}   callback                    Invoked when the process completes
 * @param  {Object}     callback.err                An error that occurred, if any
 * @param  {Object}     callback.compiledTemplates  An object keyed by tenant whose value are the templates for each module
 * @param  {Object}     [_compiledTemplates]        Internal parameter to track the templates that have been compiled. Used for recursion
 * @api private
 */
var _compileTemplatesForTenants = function(basedir, tenantAliases, modules, callback, _compiledTemplates) {
    _compiledTemplates = _compiledTemplates || {};
    if (tenantAliases.length === 0) {
        return callback(null, _compiledTemplates);
    }

    var tenantAlias = tenantAliases.shift();
    var tenantDir = util.format('%s/%s', basedir, tenantAlias);
    _compileTemplatesForModules(tenantDir, modules.slice(), function(err, newCompiledTemplates) {
        // Save the templates compiled from this tenant directory for the tenant
        _compiledTemplates[tenantAlias] = newCompiledTemplates;
        _compileTemplatesForTenants(basedir, tenantAliases, modules, callback, _compiledTemplates);
    });
};

/**
 * Compile the templates for a list of modules.
 *
 * @param  {String}     basedir                     The base directory where the module folders are located
 * @param  {String[]}   modules                     The list of modules for which to compile templates
 * @param  {Function}   callback                    Invoked when the process completes
 * @param  {Object}     callback.err                An error that occurred, if any
 * @param  {Object}     callback.compiledTemplates  An object keyed by module whose value are the compiled templates for each locale
 * @param  {Object}     [_compiledTemplates]        Internal parameter to track the templates that have been compiled. Used for recursion
 * @api private
 */
var _compileTemplatesForModules = function(basedir, modules, callback, _compiledTemplates) {
    _compiledTemplates = _compiledTemplates || {};
    if (modules.length === 0) {
        return callback(null, _compiledTemplates);
    }

    // Each directory underneath a module is a locale. Fetch them and parse each locale's templates
    var module = modules.shift();
    var emailTemplatesPath = _templatesPath(basedir, module);
    IO.getFileListForFolder(emailTemplatesPath, function(err, locales) {
        if (err) {
            return callback(err);
        } else if (locales.length === 0) {
            return _compileTemplatesForModules(basedir, modules, callback, _compiledTemplates);
        }

        _compiledTemplates[module] = _compiledTemplates[module] || {};
        _compileTemplatesForLocales(basedir, module, locales, _compiledTemplates, function(err) {
            if (err) {
                return callback(err);
            }

            return _compileTemplatesForModules(basedir, modules, callback, _compiledTemplates);
        });
    });
};

/**
 * Compile the templates for a list of locales
 *
 * @param  {String}     basedir                     The base directory where the module folders are located
 * @param  {String}     module                      The module for which to compile the locale-specific templates
 * @param  {String[]}   locales                     The list of locales for which to compile the templates
 * @param  {Object}     compiledTemplates           The template object to which the compiled templates will be attached
 * @param  {Function}   callback                    Invoked when the process completes
 * @param  {Object}     callback.err                An error that occurred, if any
 * @api private
 */
var _compileTemplatesForLocales = function(basedir, module, locales, compiledTemplates, callback) {
    if (locales.length === 0) {
        return callback();
    }

    var locale = locales.shift();
    var localePath = _templatesPath(basedir, module, locale);

    compiledTemplates[module][locale] = compiledTemplates[module][locale] || {};

    // Find all the templates in the locale directory.
    IO.getFileListForFolder(localePath, function(err, templates) {
        if (err) {
            return callback(err);
        }

        // Identify a valid template by the existence of a *.meta.json.jst file
        var templateIds = {};
        _.each(templates, function(template) {
            var re = /^(.*)\.meta\.json\.jst$/;
            if (re.test(template)) {
                templateIds[template.replace(re, '$1')] = true;
            }
        });
        templateIds = _.keys(templateIds);

        if (templateIds.length === 0) {
            return _compileTemplatesForLocales(basedir, module, locales, compiledTemplates, callback);
        }

        _compileTemplatesForTemplateIds(basedir, module, locale, templateIds, compiledTemplates, function(err) {
            if (err) {
                return callback(err);
            }

            return _compileTemplatesForLocales(basedir, module, locales, compiledTemplates, callback);
        });
    });
};

/**
 * Compile the templates for a list of template ids. The templates that need to be compiled are the meta.json, txt
 * and html templates for each email template id.
 *
 * @param  {String}     basedir                     The base directory where the locale folders are located
 * @param  {String}     module                      The module for which to compile the locale-specific templates
 * @param  {String}     locale                      The locale for which to compile the templates
 * @param  {String[]}   templateIds                 The ids of the templates to compile
 * @param  {Object}     compiledTemplates           The template object to which the compiled templates will be attached
 * @param  {Function}   callback                    Invoked when the process completes
 * @param  {Object}     callback.err                An error that occurred, if any
 * @api private
 */
var _compileTemplatesForTemplateIds = function(basedir, module, locale, templateIds, compiledTemplates, callback) {
    if (templateIds.length === 0) {
        return callback();
    }

    var templateId = templateIds.shift();
    var templateMetaPath = _templatesPath(basedir, module, locale, templateId + '.meta.json.jst');
    var templateHtmlPath = _templatesPath(basedir, module, locale, templateId + '.html.jst');
    var templateTxtPath = _templatesPath(basedir, module, locale, templateId + '.txt.jst');

    // Compile each template individually
    _compileTemplate(templateMetaPath, function(err, compiledMetaTemplate) {
        if (err) {
            return callback(err);
        }

        _compileTemplate(templateHtmlPath, function(err, compiledHtmlTemplate) {
            if (err) {
                return callback(err);
            }

            _compileTemplate(templateTxtPath, function(err, compiledTxtTemplate) {
                if (err) {
                    return callback(err);
                }

                // Attach the templates to the given object of compiled templates
                compiledTemplates[module][locale][templateId] = {
                    'meta.json': compiledMetaTemplate,
                    'html': compiledHtmlTemplate,
                    'txt': compiledTxtTemplate
                };

                return _compileTemplatesForTemplateIds(basedir, module, locale, templateIds, compiledTemplates, callback);
            });
        });
    });
};

/**
 * Compile the template at the given path.
 *
 * @param  {String}     templatePath                The path to the template file to be compiled
 * @param  {Function}   callback                    Invoked when the template has been compiled
 * @param  {Object}     callback.err                An error that occurred, if any
 * @param  {Function}   callback.compiledTemplate   A function generated by underscorejs ("compiled template") that can be used to render the template
 * @api private
 */
var _compileTemplate = function(templatePath, callback) {
    fs.exists(templatePath, function(exists) {
        if (!exists) {
            return callback();
        }

        IO.readFile(templatePath, function(err, templateContent) {
            if (err) {
                return callback(err);
            }

            if (templateContent) {
                var compiledTemplate = null;
                try {
                    compiledTemplate = _.template(templateContent);
                } catch (ex) {
                    return callback({'code': 500, 'msg': ex.message});
                }

                return callback(null, compiledTemplate);
            } else {
                return callback({'code': 500, 'msg': 'Template file ' + templatePath + ' had no content.'});
            }
        });
    });
};

/**
 * Get the path for a template file or directory.
 *
 * @param  {String}     basedir     The base directory for the templates
 * @param  {String}     module      The module for the templates
 * @param  {String}     [locale]    The locale for the templates
 * @param  {String}     [template]  The full filename for the template (e.g., meta.json.jst)
 * @return {String}                 Returns the path where the locales, template files or specific template file should be found
 * @api private
 */
var _templatesPath = function(basedir, module, locale, template) {
    var templatePath = util.format('%s/%s/emailTemplates', basedir, module);

    if (locale) {
        templatePath += '/' + locale;
        if (template) {
            templatePath += '/' + template;
        }
    }

    return templatePath;
};

/**
 * Fetch the appropriate template file (either override or base) for the given tenant, module, user locale, template id and
 * template type. This method uses the template override rules to determine which, if any, override to use, then falls back
 * to the base template if necessary. If there is no appropriate override or base template, then this will return null.
 *
 * @param  {String}     tenantAlias     The alias of the tenant
 * @param  {String}     templateModule  The module to which the template belongs
 * @param  {String}     templateLocale  The locale for which to fetch the template
 * @param  {String}     templateId      The id of the template
 * @param  {String}     templateType    The type of template to fetch (i.e., one of 'html', 'txt' or 'meta.json')
 * @return {Function}                   The compiled underscorejs template function that can be used to render the template. If `null`, there was no suitable template for the given criteria.
 * @api private
 */
var _resolveTemplate = function(tenantAlias, templateModule, templateLocale, templateId, templateType) {
    // Try the override first, falling back to the base template if necessary
    return _getTemplate(overrideCompiledTemplates[tenantAlias], templateModule, templateLocale, templateId, templateType) ||
        _getTemplate(baseCompiledTemplates, templateModule, templateLocale, templateId, templateType);
};

/**
 * Fetch the appropriate template file (either override or base) for the given module, user locale, template id and
 * template type from the `compiledTemplates` object. If a template cannot be found for the given locale, this will
 * try and fall back to the 'default' template locale to find the appropriate template. If no template can be found,
 * `null` will be returned.
 *
 * @param  {Object}     compiledTemplates   An object of compiled templates to use to find the appropriate template
 * @param  {String}     templateModule      The module to which the template belongs
 * @param  {String}     templateLocale      The locale for which to fetch the template
 * @param  {String}     templateId          The id of the template
 * @param  {String}     templateType        The type of template to fetch (i.e., one of 'html', 'txt' or 'meta.json')
 * @return {Function}                       The compiled underscorejs template function that can be used to render the template. If `null`, there was no suitable template for the given criteria.
 * @api private
 */
var _getTemplate = function(compiledTemplates, templateModule, templateLocale, templateId, templateType) {
    var template =
        compiledTemplates &&
        compiledTemplates[templateModule] &&
        compiledTemplates[templateModule][templateLocale] &&
        compiledTemplates[templateModule][templateLocale][templateId] &&
        compiledTemplates[templateModule][templateLocale][templateId][templateType];

    // If we couldn't find the requested template, fall back to the default template
    return template || _getDefaultTemplate(compiledTemplates, templateModule, templateId, templateType);
};

/**
 * Fetch the template from the 'default' locale from the given object of compiled templates.
 *
 * @param  {Object}     compiledTemplates   An object of compiled templates to use to find the appropriate template
 * @param  {String}     templateModule      The module to which the template belongs
 * @param  {String}     templateId          The id of the template
 * @param  {String}     templateType        The type of template to fetch (i.e., one of 'html', 'txt' or 'meta.json')
 * @return {Function}                       The compiled underscorejs template function that can be used to render the template. If `null`, there was no 'default' locale template for the given criteria.
 * @api private
 */
var _getDefaultTemplate = function(compiledTemplates, templateModule, templateId, templateType) {
    var template =
        compiledTemplates &&
        compiledTemplates[templateModule] &&
        compiledTemplates[templateModule]['default'] &&
        compiledTemplates[templateModule]['default'][templateId] &&
        compiledTemplates[templateModule]['default'][templateId][templateType];

    // If we couldn't find the default template, we return null;
    return template || null;
};
