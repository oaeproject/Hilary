/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var AuthzAPI = require('oae-authz');
var AuthzUtil = require('oae-authz/lib/util');
var PrincipalsGroupAPI = require('oae-principals/lib/api.group');
var PrincipalsUtil = require('oae-principals/lib/util');
var TenantsUtil = require('oae-tenants/lib/util');

var DiscussionsConstants = require('./constants').DiscussionsConstants;

/**
 * Determine whether or not the user in context can view the provided discussion.
 *
 * @param  {Context}    ctx                 The context of the current request
 * @param  {Discussion} discussion          The discussion to test for access
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.canView    `true` if the user in context has the appropriate permission. `false` otherwise.
 */
var canViewDiscussion = module.exports.canViewDiscussion = function(ctx, discussion, callback) {
    var user = ctx.user();
    _resolveImplicitRole(ctx, discussion, function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (implicitRole) {
            // We have an implicit access, no reason to try and find an explicit access because we can atleast view
            return callback(null, true);
        } else if (!user) {
            // Anonymous user with no implicit access cannot view
            return callback(null, false);
        }

        // By this point, we only have access to view if we have a role on the item
        AuthzAPI.hasAnyRole(user.id, discussion.id, callback);
    });
};

/**
 * Determine whether or not the user in context can manage the provided discussion.
 *
 * @param  {Context}    ctx                 The context of the current request
 * @param  {Discussion} discussion          The discussion to test for access
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.canManage  `true` if the user in context has the appropriate permission. `false` otherwise.
 */
var canManageDiscussion = module.exports.canManageDiscussion = function(ctx, discussion, callback) {
    var user = ctx.user();

    // Anonymous can never manage
    if (!user) {
        return callback(null, false);
    }

    _resolveImplicitRole(ctx, discussion, function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (implicitRole === DiscussionsConstants.roles.MANAGER) {
            // We have an implicit management role (e.g., we are a manager), return true
            return callback(null, true);
        }

        // By this point, we can only manage if we have explicit manager role
        AuthzAPI.hasRole(user.id, discussion.id, DiscussionsConstants.roles.MANAGER, callback);
    });
};

/**
 * Determine whether or not the user in context can share the provided discussion with the principalIds
 * provided. `canShare` can be `false` either if the user doesn't have appopriate permission to share the
 * discussion, or if sharing with some target principals violates tenant boundaries.
 *
 * @param  {Context}    ctx                             The context of the current request
 * @param  {Discussion} discussion                      The discussion to test for access
 * @param  {String[]}   principalIds                    The principalIds with which the user wishes to share the discussion
 * @param  {Function}   callback                        Invoked when the process completes
 * @param  {Object}     callback.err                    An error that occurred, if any
 * @param  {Boolean}    callback.canShare               `true` if the u ser in context is allowed to perform this share operation. `false` otherwise
 * @param  {String[]}   [callback.illegalPrincipalIds]  If the check failed because of a tenant boundary violation, this will be an array of principalIds that were in violation
 */
var canShareDiscussion = module.exports.canShareDiscussion = function(ctx, discussion, principalIds, callback) {
    var user = ctx.user();

    // Anonymous users can never share
    if (!user) {
        return callback(null, false);
    }

    // Verify tenant boundaries
    var illegalPrincipalIds = _resolveTenantBoundaryViolations(user, discussion, principalIds);
    if (illegalPrincipalIds.length > 0) {
        return callback(null, false, illegalPrincipalIds);
    }

    _resolveImplicitRole(ctx, discussion, function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (implicitRole === DiscussionsConstants.roles.MANAGER) {
            // Managers can always share
            return callback(null, true);
        } else if (canInteract) {
            // If we can interact with the item, we can always share it
            return callback(null, true);
        }

        // If the discussion is private, only managers can share it
        if (discussion.visibility === DiscussionsConstants.visibility.PRIVATE) {
            return AuthzAPI.hasRole(user.id, discussion.id, DiscussionsConstants.roles.MANAGER, function(err, hasRole) {
                return callback(err, hasRole);
            });
        }

        // At this point, we have to see if the user has any explicit role on the resource to see if they can share it
        AuthzAPI.hasAnyRole(user.id, discussion.id, function(err, hasAnyRole) {
            return callback(err, hasAnyRole);
        });
    });
};

/**
 * Determine whether or not the user in context can update the permissions of the provided discussion. Since tenant boundaries
 * allow that existing members of discussions can have their membership changed (even if their tenant has since become private)
 * and members may be removed even if they cross private tenant boundaries, the `addMemberIds` array should only contain ids of
 * members who don't already exist as members on the discussion.
 *
 * @param  {Context}    ctx                         The context of the current request
 * @param  {Discussion} discussion                  The discussion to test for access
 * @param  {String[]}   addMemberIds                An array of ids of members that are being **added** to the discussion
 * @param  {Function}   callback                    Invoked when the process completes
 * @param  {Object}     callback.err                An error that occurred, if any
 * @param  {Boolean}    callback.canSetPermissions  `true` if the user in context has the appropriate permission. `false` otherwise.
 */
var canSetDiscussionPermissions = module.exports.canSetDiscussionPermissions = function(ctx, discussion, addMembers, callback) {
    // Only managers can set the permissions of any discussion, regardless of privacy rules
    if (!ctx.user()) {
        return callback({'code': 401, 'msg': 'You must be authenticated to update permissions of a discussion'});
    }

    // Reject the operation if it will violate tenant privacy boundaries
    var illegalMemberIds = _resolveTenantBoundaryViolations(ctx.user(), discussion, addMembers);
    if (illegalMemberIds.length > 0) {
        return callback(null, false, illegalMemberIds);
    }

    // Boundaries are all good, perform the manager check
    canManageDiscussion(ctx, discussion, callback);
};

/**
 * Determines whether or not the user in context can remove an item from the specified discussion library.
 *
 * @param  {Context}    ctx                 The context of the current request
 * @param  {String}     libraryOwnerId      The owner of the library from which we wish to remove discussion(s)
 * @param  {Function}   callback            Invoked when the check is completed
 * @param  {Object}     callback.err        An error that occurred, fi any
 * @param  {Boolean}    callback.canRemove  Whether or not the user in context can remove an item from the library
 */
var canRemoveDiscussionFromLibrary = module.exports.canRemoveDiscussionFromLibrary = function(ctx, libraryOwnerId, callback) {
    var user = ctx.user();

    if (!user) {
        // Anonymous can never remove a discussion from a library
        return callback(null, false);
    }

    // Admin check. Admins can do all the things
    var libraryTenantAlias = AuthzUtil.getPrincipalFromId(libraryOwnerId).tenantAlias;
    if (ctx.user().isGlobalAdmin() || ctx.user().isTenantAdmin(libraryTenantAlias)) {
        return callback(null, true);
    }

    if (PrincipalsUtil.isUser(libraryOwnerId)) {
        if (ctx.user().id === libraryOwnerId) {
            // Only admins and the user themself can delete an item from their discussion library
            return callback(null, true);
        } else {
            return callback (null, false);
        }
    } else if (PrincipalsUtil.isGroup(libraryOwnerId)) {
        // If this is a group, only managers can remove items from its library
        return PrincipalsGroupAPI.canManage(ctx, libraryOwnerId, callback);
    } else {
        return callback({'err': 400, 'code': 'Invalid library owner specified'});
    }
};

/**
 * Determine whether or not the user in context can post a message in the provided discussion.
 *
 * @param  {Context}    ctx                 The context of the current request
 * @param  {Discussion} discussion          The discussion to test for access
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.canPost    `true` if the user in context has the appropriate permission. `false` otherwise.
 */
var canPostDiscussionMessage = module.exports.canPostDiscussionMessage = function(ctx, discussion, callback) {
    var user = ctx.user();

    if (!user) {
        // Anonymous can never post to a discussion
        return callback(null, false);
    }

    _resolveImplicitRole(ctx, discussion, function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (implicitRole === DiscussionsConstants.roles.MANAGER) {
            // Implicit managers can always post, regardless of tenant
            return callback(null, true);
        } else if (canInteract) {
            // If we can interact with the item, we can always post to it
            return callback(null, true);
        }

        // See if this user has any explicit role, if so they can post
        AuthzAPI.hasAnyRole(user.id, discussion.id, callback);
    });
};

/**
 * Determine whether or not the user in context can delete the provided message in the provided discussion.
 *
 * @param  {Context}    ctx                 The context of the current request
 * @param  {Discussion} discussion          The discussion to test for access
 * @param  {Message}    message             The message to test for access
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.canDelete  `true` if the user in context has the appropriate permission. `false` otherwise.
 */
var canDeleteDiscussionMessage = module.exports.canDeleteDiscussionMessage = function(ctx, discussion, message, callback) {
    var user = ctx.user();

    if (!user) {
        return callback(null, false);
    }

    _resolveImplicitRole(ctx, discussion, function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (implicitRole === DiscussionsConstants.roles.MANAGER) {
            // Managers can always delete messages
            return callback(null, true);
        } else if (canInteract && message.createdBy === user.id) {
            // The user is still able to interact with this tenant, they can delete their own message
            return callback(null, true);
        }

        // It's not our message, or we cannot implicitly interact. We need explicit manager access to delete the message
        AuthzAPI.hasRole(user.id, discussion.id, DiscussionsConstants.roles.MANAGER, callback);
    });
};

/**
 * Determine the full set of access that the user in context has on the discussion
 *
 * @param  {Context}    ctx                 The context of the current request
 * @param  {Discussion} discussion          The discussion to test for access
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.canView    `true` if the user in context can view the discussion. `false` otherwise.
 * @param  {Boolean}    callback.canManage  `true` if the user in context can manage the discussion. `false` otherwise.
 * @param  {Boolean}    callback.canShare   `true` if the user in context can share the discussion. `false` otherwise.
 * @param  {Boolean}    callback.canPost    `true` if the user in context can post a message in the discussion. `false` otherwise.
 */
var resolveEffectiveDiscussionAccess = module.exports.resolveEffectiveDiscussionAccess = function(ctx, discussion, callback) {
    _resolveEffectiveDiscussionRole(ctx, discussion, function(err, role, canInteract) {
        if (err) {
            return callback(err);
        }

        var canView = _.isString(role);
        var canManage = (role === DiscussionsConstants.roles.MANAGER);

        // Anybody who can "interact" with the discussion can post to it
        var canPost = canInteract;

        // Anyone who can interact can share, unless the discussion is private. In that case, only managers can share
        var canShare = canInteract;
        if (discussion.visibility !== DiscussionsConstants.visibility.PUBLIC && discussion.visibility !== DiscussionsConstants.visibility.LOGGEDIN) {
            canShare = canManage;
        }

        return callback(null, canView, canManage, canShare, canPost);
    });
};

/**
 * Determine which visibility level of library the user in context should receive from the target library owner. Note that
 * the library visibility is not privacy protection for the library owner, it is privacy protection for the resources inside
 * the owner's library.
 *
 * @param  {Context}    ctx                 The context of the current request
 * @param  {String}     libraryOwnerId      The id of the owner of the library
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {String}     callback.visibility The maximum visibility (as enumerated in `DiscussionsConstants.visibility.ALL_PRIORITY`) of library the user in context can see from the target library owner
 */
var resolveTargetLibraryVisibility = module.exports.resolveTargetLibraryVisibility = function(ctx, libraryOwnerId, callback) {
    var libraryTenantAlias = AuthzUtil.getPrincipalFromId(libraryOwnerId).tenantAlias;

    // Admin users always get private libraries
    if (ctx.user() && (ctx.user().isGlobalAdmin() || ctx.user().isTenantAdmin(libraryTenantAlias))) {
        return callback(null, DiscussionsConstants.visibility.PRIVATE);
    }

    // User is not an admin of the target library tenant, so we'll have to do some acrobatics to resolve the visibility
    var visibility = DiscussionsConstants.visibility.PRIVATE;

    // Check if we are looking at a user library
    if (PrincipalsUtil.isUser(libraryOwnerId)) {
        // We give the user the public discussion stream in case the user is not logged in to the user's tenant
        if (!TenantsUtil.isLoggedIn(ctx, libraryTenantAlias)) {
            visibility = DiscussionsConstants.visibility.PUBLIC;
        // We give the user the logged in discussion stream in case the current user is not the same as the library we're looking at
        } else if (ctx.user().id !== libraryOwnerId) {
            visibility = DiscussionsConstants.visibility.LOGGEDIN;
        }

        return callback(null, visibility);

    // Check if we are looking at a group library
    } else if (PrincipalsUtil.isGroup(libraryOwnerId)) {
        // We give the user the public discussion stream in case the user is not logged in
        if (!ctx.user()) {
            return callback(null, DiscussionsConstants.visibility.PUBLIC);
        } else {
            // Check if the current user is a member of the group
            AuthzAPI.hasAnyRole(ctx.user().id, libraryOwnerId, function(err, hasAnyRole) {
                if (err) {
                    return callback(err);
                }

                // If the user is not a member, but is authenticated to the group's tenant, we give him the logged in discussion stream
                if (!hasAnyRole && TenantsUtil.isLoggedIn(ctx, libraryTenantAlias)) {
                    visibility = DiscussionsConstants.visibility.LOGGEDIN;
                // Otherwise, we give them public discussions
                } else if (!hasAnyRole) {
                    visibility = DiscussionsConstants.visibility.PUBLIC;
                }

                return callback(null, visibility);
            });
        }
    // If the passed in principal id is neither a group or user, we return an error
    } else {
        return callback({'code': 400, 'msg': 'An unrecognized library owner id (' + libraryOwnerId + ') has been provided'});
    }
};

/**
 * Determine for a resource, which library visibility levels in which it should be inserted for the each of the given list
 * of library owners.
 *
 * @param  {String[]}   libraryOwnerIds             The ids of the library owners for which to resolve the library visibilities
 * @param  {Object}     resource                    The resource to be inserted into the libraries (e.g., discussion, content)
 * @param  {String}     resource.visibility         The resource visibility (e.g., public, private, loggedin)
 * @param  {Object}     resource.tenant             The light-weight tenant object of the resource to which the resource belongs
 * @param  {String}     resource.tenant.alias       The alias of the tenant to which the resource belongs
 * @param  {Function}   callback                    Invoked when the process completes
 * @param  {Object}     callback.err                An error that occurred, if any
 * @param  {Object}     callback.keyVisibilities    An object keyed by library owner id, whose value is the visibility level in which the discussion belongs
 */
var resolveEffectiveLibraryVisibilities = module.exports.resolveEffectiveLibraryVisibilities = function(libraryOwnerIds, resource, callback) {
    // Determine the effective library visibilities for each resource relative to each provided library owner
    var keyVisibilities = {};

    _.each(libraryOwnerIds, function(principalId) {
        var effectiveVisibility = resource.visibility;
        if (effectiveVisibility === DiscussionsConstants.visibility.LOGGEDIN) {
            // If the visibility is loggedin, it only goes into the principal's 'loggedin' library if it is
            // from their *own* tenant. Otherwise, we put it into the private library
            var principalTenantAlias = AuthzUtil.getPrincipalFromId(principalId).tenantAlias;
            if (principalTenantAlias !== resource.tenant.alias) {
                effectiveVisibility = DiscussionsConstants.visibility.PRIVATE;
            }
        }

        keyVisibilities[principalId] = effectiveVisibility;
    });

    return keyVisibilities;
};

/**
 * Determine the **effective** role a user has in a discussion. Though a user can have multiple roles on a discussion
 * by virtue of indirect group membership, this determines the highest level of access granted. This check is not only
 * implicit, but includes explicit role membership lookup. Therefore, its output alone can be used as an authoritative
 * source of access information.
 *
 * @param  {Context}    ctx                     The context of the user to check for access
 * @param  {Discussion} discussion              The discussion to check against for access
 * @param  {Function}   callback                Invoked when the process completes
 * @param  {Object}     callback.err            An error that occured, if any
 * @param  {String}     callback.effectiveRole  The effective role of the user in context
 * @param  {Boolean}    callback.canInteract    Whether or not the user can interact
 * @api private
 */
var _resolveEffectiveDiscussionRole = function(ctx, discussion, callback) {
    var user = ctx.user();
    _resolveImplicitRole(ctx, discussion, function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (implicitRole === DiscussionsConstants.roles.MANAGER) {
            // We already have the highest role, use it
            return callback(null, implicitRole, true);
        } else if (!user) {
            // We are anonymous so cannot have any explicit access or interact. Use only our implicitRole if we have one
            return callback(null, implicitRole, false);
        }

        AuthzAPI.getAllRoles(user.id, discussion.id, function(err, roles) {
            if (err) {
                return callback(err);
            } else if (roles.length === 0) {
                // We have no explicit role, so we fall back to the implicit access
                return callback(null, implicitRole, canInteract);
            }

            // The resolved role is the one in the highest index of the DiscussionsConstants.roles.ALL_PRIORITY array
            var highestIndex = _.indexOf(DiscussionsConstants.roles.ALL_PRIORITY, implicitRole);
            _.each(roles, function(role) {
                highestIndex = Math.max(highestIndex, _.indexOf(DiscussionsConstants.roles.ALL_PRIORITY, role));
            });

            // The `canInteract` parameter is true because we can always interact if we have an explicit role
            return callback(null, DiscussionsConstants.roles.ALL_PRIORITY[highestIndex], true);
        });
    });
};

/**
 * Determine the highest **implicit** role that the user in context has on a discussion. Implicit means that the
 * user is granted access based on simple privacy / visibility / tenant rules associated to the context. Some
 * examples:
 *
 *  *   If the user in context is an admin, they will implicitly have manager access of the discussion, even if they
 *      don't have an explicit manager role membership on the discussion;
 *  *   If the discussion has visibility "public", all contexts (anonymous or authenticated) have implicit "viewer"
 *      role on a discussion
 *  *   If the discussion has visibility "private", no user context (except administrator) can have implicit "viewer"
 *      as that can only be determined through an **explicit** role check
 *
 * Therefore, the output from this call is the **minimum** effective permissions the current context has on a discussion,
 * since there is no concept of a "deny" permission. If this method returns that there is no implicit role, it is still
 * possible that the user has been explicitly granted a membership role. If this method returns that there is an implicit
 * "viewer" role, it is possible that the user has been explicitly granted a role of "manager".
 *
 * The `canInteract` determines if the user can implicitly "interact" with the discussion through potential tenant privacy
 * boundaries (e.g., share it, add it to their library, post a message on it). Like `implicitRole`, it is also a minimal
 * implicit check. So if this results in `false`, it is still possible that a user has an explicit manager role on the
 * discussion which grants it ability to interact.
 *
 * To get a context's explicit effective role, please use #_resolveEffectiveDiscussionRole instead.
 *
 * @param  {Context}    ctx                     The context of the current request
 * @param  {Discussion} discussion              The discussion to test access against
 * @param  {Function}   callback                Invoked when the process completes
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {String}     callback.implicitRole   The implicit (minimum) role the user in context has on the discussion
 * @param  {Boolean}    callback.canInteract    Determines whether or not the user in context can implicitly interact with the discussion
 */
var _resolveImplicitRole = function(ctx, discussion, callback) {
    var user = ctx.user();

    // Check admin access
    if (user && (user.isGlobalAdmin() || user.isTenantAdmin(discussion.tenant.alias))) {
        // The user is an administrator, give them the highest allowable access
        return callback(null, DiscussionsConstants.roles.MANAGER, true);
    }

    // If we aren't an explicit manager, ability to interact is based on tenant privacy boundaries
    var canInteract = TenantsUtil.canInteract(ctx.tenant().alias, discussion.tenant.alias);

    // Check implicit member access
    if (discussion.visibility === DiscussionsConstants.visibility.PUBLIC) {
        // Public resources can be seen by anyone
        return callback(null, DiscussionsConstants.roles.MEMBER, canInteract);
    } else if (discussion.visibility === DiscussionsConstants.visibility.LOGGEDIN && TenantsUtil.isLoggedIn(ctx, discussion.tenant.alias)) {
        // We are from the same tenant as the "loggedin" resource, so we can view it and interact
        return callback(null, DiscussionsConstants.roles.MEMBER, canInteract);
    }

    return callback();
};

/**
 * Determines tenant boundary violations between:
 *
 *  * The user in context and any principals in the list of principalIds; OR
 *  * The discussion and any principals in the list of principalIds.
 *
 * This does not resolve tenant boundary violations between the current user in context and the discussion,
 * as that is more complex and handled differently.
 *
 * @param  {User}       user                    The user in context
 * @param  {Discussion} discussion              The discussion to test with
 * @param  {String[]}   principalIds            The principalIds to check against
 * @return {String[]}                           The principalIds who violate tenant interaction boundaries
 * @api private
 */
var _resolveTenantBoundaryViolations = function(user, discussion, principalIds) {
    // Check tenant privacy between the current user in context, discussion and target principals
    var illegalPrincipalIds = [];
    _.each(principalIds, function(principalId) {
        var principalTenantAlias = AuthzUtil.getPrincipalFromId(principalId).tenantAlias;
        // The principalId is invalid if the violates boundaries between the current user *or* or the discussion
        if (!TenantsUtil.canInteract(user.tenant.alias, principalTenantAlias)) {
            illegalPrincipalIds.push(principalId);
        } else if (!TenantsUtil.canInteract(discussion.tenant.alias, principalTenantAlias)) {
            illegalPrincipalIds.push(principalId);
        }
    });

    return illegalPrincipalIds;
};
