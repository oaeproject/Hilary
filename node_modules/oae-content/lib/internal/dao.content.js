/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var ShortId = require('shortid');

var AuthzAPI = require('oae-authz');
var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var log = require('oae-logger').logger('content-dao');
var OaeUtil = require('oae-util/lib/util');

var Content = require('oae-content/lib/model').Content;
var ContentConstants = require('oae-content/lib/constants').ContentConstants;

var RevisionsDAO = require('./dao.revisions');

///////////////
// Retrieval //
///////////////


/**
 * Get a content's basic profile information based on a pooled content id
 *
 * @param  {String}         contentId           The id of the content object we want to retrieve
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Content}        callback.contentObj Retrieved content object
 */
var getContent = module.exports.getContent = function(contentId, callback) {
    Cassandra.runQuery('SELECT * FROM Content USING CONSISTENCY QUORUM WHERE contentId = ?', [contentId], function (err, rows) {
        if (err) {
            return callback(err);
        }

        // Cassandra always returns the key as a column so the count will always be 1.
        if (rows[0].count <= 1) {
            return callback({'code': 404, 'msg': "Couldn't find content: " + contentId}, null);
        }

        var contentObj = _rowToContent(rows[0]);
        return callback(null, contentObj);
    });
};

/**
 * Get multiple content basic profiles at the same time based on their content ids.
 *
 * @param  {String[]}       contentIds          Array of content object ids we want to retrieve. The content profiles will be returned in the same order
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `contentObj`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Content[]}      callback.contentObj Retrieved content objects
 */
var getMultipleContentItems = module.exports.getMultipleContentItems = function(contentIds, callback) {
    if (contentIds.length) {
        Cassandra.runQuery('SELECT * FROM Content USING CONSISTENCY QUORUM WHERE contentId IN (?)', [contentIds], function(err, rows) {
            if (err) {
                return callback(err);
            }
            // Iterate over the content items.
            for (var i = 0; i < rows.length; i++) {
                // Check if the piece of content exists. Cassandra always returns the key as a column so the count will always be 1.
                if (rows[i].count > 1) {
                    var contentObj = _rowToContent(rows[i]);
                    contentIds[_.indexOf(contentIds, contentObj.id)] = contentObj;

                // If the content item could not be found, the item has probably been deleted.
                // Pass back a null value.
                } else {
                    contentIds[_.indexOf(contentIds, rows[i].get('contentId').value)] = null;
                }
            }
            callback(null, contentIds);
        });
    } else {
        callback(null, []);
    }
};

/**
 * Function that gets all of the principals that are directly associated to a piece of content.
 *
 * @param  {String}         contentId           The id of the content object for which we want to get the members
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `members`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Object[]}       callback.members    An array of hashes, where the 'id' property of the hash is the principal id, and the 'role' property of the hash is the role of the principal.
 */
var getAllContentMembers = module.exports.getAllContentMembers = function(contentId, callback) {
    AuthzAPI.getAuthzMembers(contentId, null, 10000, callback);
};


///////////////
// Modifiers //
///////////////


/**
 * Create a new piece of pooled content
 *
 * @param  {String}         contentId           The id of the piece of content
 * @param  {String}         createdBy           The id of the user who is creating the content item
 * @param  {String}         resourceSubType     The content type. Possible values are "file", "collabdoc" and "link"
 * @param  {String}         displayName         The display name for the piece of content
 * @param  {String}         description         The description of the piece of content [optional]
 * @param  {String}         visibility          The visibility setting for the piece of content. Possible values are "public", "loggedin" and "private" [optional]
 * @param  {Object}         additionalMembers   Object where the keys represent principal ids that need to be added to the content upon creation and the values represent the role that principal will have. Possible values are "viewer" and "manager"
 * @param  {Object}         otherValues         JSON object where the keys represent other metadata values that need to be stored, and the values represent the metadata values
 * @param  {Object}         revisionData        JSON object where the keys represent revision columns that need to be stored, and the values represent the revision values
 * @param  {Function}       callback            Standard callback function takes arguments `err` and `content`
 * @param  {Object}         callback.err        Error object containing the error message
 * @param  {Content}        callback.content    JSON object containing the pool id of the created content
 * @param  {Revision}       callback.revision   The initial revision object for this content item.
 */
var createContent = module.exports.createContent = function(contentId, createdBy, resourceSubType, displayName, description, visibility, additionalMembers, otherValues, revisionData, callback) {
    // Use an empty description if no description has been provided
    description = description || '';
    // Make sure the otherValues and additionalMembers are valid objects
    additionalMembers = additionalMembers || {};
    otherValues = otherValues || {};

    // Create a revision first, so we can store the revision ID.
    RevisionsDAO.createRevision(contentId, createdBy, revisionData, function(err, revision) {
        if (err) {
            return callback(err);
        }

        // Get the tenantAlias out of the content model.
        var tenantAlias = AuthzUtil.getResourceFromId(contentId).tenantAlias;

        // Set the properties
        var parameters = {
            'tenantAlias': tenantAlias,
            'visibility': visibility,
            'displayName': displayName,
            'description': description,
            'resourceSubType': resourceSubType,
            'createdBy': createdBy,
            'created': Date.now(),
            'latestRevisionId': revision.revisionId,
            'previews': {'status': 'pending'}
        };

        // Add the other values into the query
        parameters = _.extend(parameters, otherValues);
        var q = Cassandra.constructUpsertCQL('Content', 'contentId', contentId, parameters, 'QUORUM');

        // Create the content
        Cassandra.runQuery(q.query, q.parameters, function(err) {
            if (err) {
                return callback(err);
            }

            var contentObj = new Content(tenantAlias, contentId, visibility, displayName, description, resourceSubType, parameters.createdBy, parameters.created, null, revision.revisionId);
            contentObj.previews = {'status': 'pending'};
            callback(null, contentObj, revision);
        });
    });
};

/**
 * Updates a piece of content in the database.
 *
 * @param  {String}     contentObj              The full (pre-update) content object that is being updated
 * @param  {Object}     profileUpdates          An object where the keys represent the column names and the values the new column values to apply to the content profile.
 * @param  {Boolean}    librariesUpdate         Whether or not to update the libraries that this content item sits in.
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            Error object containing the error message
 * @param  {Content}    callback.content        The new content object.
 */
var updateContent = module.exports.updateContent = function(contentObj, profileUpdates, librariesUpdate, callback) {
    // Set the lastModified timestamp.
    var oldLastModified = contentObj.lastModified;
    profileUpdates.lastModified = Date.now();

    var q = Cassandra.constructUpsertCQL('Content', 'contentId', contentObj.id, profileUpdates, 'QUORUM');
    Cassandra.runQuery(q.query, q.parameters, function(err) {
        if (err) {
            return callback(err);
        }

        // Create the new content object by merging in the metadata changes over the old content object
        var newContentObj = _.extend({}, contentObj, profileUpdates);
        if (!librariesUpdate) {
            return callback(null, newContentObj);
        } else {
            _updateLibraries(newContentObj, oldLastModified, newContentObj.lastModified, [], function(err) {
                if (err) {
                    return callback(err);
                }
                callback(null, newContentObj);
            });
        }
    });
};

/**
 * Deletes a piece of content from the database and removes it from all the managers/members
 * their libraries.
 *
 * @param  {Content}    contentObj      The piece of content that should be removed.
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    Error object containing the error message
 */
var deleteContent = module.exports.deleteContent = function(contentObj, callback) {
    Cassandra.runQuery('DELETE FROM Content WHERE contentId = ?', [contentObj.id], function(err) {
        if (err) {
            return callback(err);
        }

        getAllContentMembers(contentObj.id, function(err, members) {
            if (err) {
                return callback(err);
            } else if (members.length === 0) {
                return callback();
            }

            var updateMembers = {};
            var membersToRemove = [];
            for (var m = 0; m < members.length; m++) {
                updateMembers[members[m].id] = false;
                membersToRemove.push(members[m].id);
            }

            // Update the roles CF
            AuthzAPI.updateRoles(contentObj.id, updateMembers, function(err) {
                if (err) {
                    return callback(err);
                }

                // Now update all of the libraries this affects
                _updateLibraries(contentObj, contentObj.lastModified, Date.now(), membersToRemove, function(err) {
                    if (err) {
                        // If there was an error updating libraries here, the permissions were still changed, so we should not return an error. Just log it.
                        log().warn({
                            'err': err,
                            'contentObj': contentObj,
                            'removedMembers': removedMembers
                        }, 'Failed to update user libraries after updating content permissions.');
                    }

                    return callback();
                });
            });
        });
    });
};


///////////////
// Libraries //
///////////////


/**
 * Get a user's or group's library. This function assumes that all permission check will have
 * been done and the processed principal id is passed in. It also assumes that a valid start and limit parameter are passed in.
 *
 * @param  {String}         principalId       The ID of the principal for which the library should be retrieved.
 * @param  {String}         visibility        Which library should be returned.
 * @param  {String}         start             Determines the point at which content items are returned for paging purposed.  If not provided, the first x elements will be returned
 * @param  {Integer}        limit             Number of items to return. Will default to 10 if not provided
 * @param  {Function}       callback          Standard callback function takes arguments `err` and `content`
 * @param  {Object}         callback.err      Error object containing the error message
 * @param  {Content[]}      callback.content  Array of basic content profiles representing the requested items in the library
 */
var getLibraryItems = module.exports.getLibraryItems = function(principalId, visibility, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10);

    var libraryId = principalId;
    if (visibility !== ContentConstants.visibility.PRIVATE) {
        libraryId += '#' + visibility;
    }

    Cassandra.runPagedColumnQuery('LibraryByPrincipal', 'principalId', libraryId, start, limit, {'reversed': true}, function(err, row) {
        if (err) {
            return callback(err);
        }

        var items = [];
        row.forEach(function(name, value) {
            items.push(value);
        });

        // Get the content profiles of the content items, assuming that
        // we have access to all of the returned items
        getMultipleContentItems(items, callback);
    });
};

/**
 * Iterate through all the content items. This will return just the raw content properties that are specified in the `properties`
 * parameter, and only `batchSize` content items at a time. On each iteration of `batchSize` content items, the `onEach` callback
 * will be invoked, and the next batch will not be fetched until you have invoked the `onEach.done` function parameter. When
 * complete (e.g., there are 0 content items left to iterate through or an error has occurred), the `callback` parameter will be
 * invoked.
 *
 * @param  {String[]}   [properties]        The names of the content properties to return in the content objects. If not specified (or is empty array), it returns just the `contentId`s
 * @param  {Number}     [batchSize]         The number of content items to fetch at a time. Defaults to 100
 * @param  {Function}   onEach              Invoked with each batch of content items that are fetched from storage
 * @param  {Object}     onEach.contentRow   An object holding the raw content data that was fetched from storage
 * @param  {Function}   onEach.done         The function to invoke when processing of the current batch is complete
 * @param  {Object}     onEach.done.err     An error that occurred, if any, while processing the current batch. If you specify this error, iteration will finish and the completion callback will be invoked
 * @param  {Function}   [callback]          Invoked when all rows have been iterated, or an error has occurred
 * @param  {Object}     [callback.err]      An error that occurred, while iterating rows, if any
 * @see Cassandra#iterateAll
 */
var iterateAll = module.exports.iterateAll = function(properties, batchSize, onEach, callback) {
    if (!properties || !properties.length) {
        properties = ['contentId'];
    }

    var opts = {
        'batchSize': batchSize,
        'consistency': 'ONE',
        'slugColumnName': 'visibility'
    };

    /*!
     * Handles each batch from the cassandra iterateAll method.
     *
     * @see Cassandra#iterateAll
     */
    var _iterateAllOnEach = function(rows, done) {
        // Convert the rows to a hash and delegate action to the caller onEach method
        var hashedRows = [];
        rows.forEach(function(row) {
            hashedRows.push(Cassandra.rowToHash(row));
        });

        return onEach(hashedRows, done);
    };

    Cassandra.iterateAll(properties, 'Content', 'contentId', opts, _iterateAllOnEach, callback);
};

/*
 * Updates the libraries of all of the members of a piece of content. This will remove the old entry with
 * the old lastModified date/sorting and add the new one. The content item's `lastModified` timestamp will
 * be updated such that it ranked higher in libraries.
 *
 * @param  {Content}    contentObj                  The content object for which the libraries should be updated.
 * @param  {String[]}   removedMembers              An array of principal IDs that should no longer have this item in their library.
 * @param  {Function}   [callback]                  Standard callback function
 * @param  {Object}     [callback.err]              Error object containing the error message
 * @param  {Content}    [callback.newContentObj]    The content object with the updated `lastModified` field. Note that this may be returned even if there is an error as the content-update operation may have succeeded but the library-update operation fails.
 */
var updateLibraries = module.exports.updateLibraries = function(contentObj, removedMembers, callback) {
    // Grab hold of the old last modified timestamp to remove columns in the library CF (if any)
    var oldLastModified = contentObj.lastModified;

    // Update the content item with a new timestamp.
    updateContent(contentObj, {}, false, function(err, newContentObj) {
        if (err) {
            return callback(err);
        }

        // Update the libraries.
        _updateLibraries(contentObj, oldLastModified, newContentObj.lastModified, removedMembers, function(err) {
            if (err) {
                return callback(err, newContentObj);
            }

            return callback(null, newContentObj);
        });
    });
};

/**
 * Internal function that updates the content libries for a piece of content.
 *
 * @param  {Content}    contentObj          The content object for which the libraries should be updated
 * @param  {Number}     oldLastModified     The timestamp when the content item was last modified. (Note: this is the timestamp that is used in the libraries)
 * @param  {Number}     newLastModified     The new timestamp
 * @param  {String[]}   removedMembers      An array of principal IDs that should no longer have this item in their library.
 * @param  {Function}   [callback]          Standard callback function
 * @param  {Object}     [callback.err]      Error object containing the error message
 */
var _updateLibraries = function(contentObj, oldLastModified, newLastModified, removedMembers, callback) {
    // Grab all the current members.
    getAllContentMembers(contentObj.id, function(err, members) {
        if (err) {
            return callback(err);
        }

        var queries = [];
        for (var m = 0; m < members.length; m++) {
            var member = members[m].id;
            // Only remove the old entries if the piece of content existed before and
            // the old lastModified date has been provided
            if (oldLastModified) {
                // Remove the old entry in the private row
                queries.push({
                    'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                    'parameters': [oldLastModified + ':' + contentObj.id, member]
                });
                // Remove the old entry in the loggedin row
                queries.push({
                    'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                    'parameters': [oldLastModified + ':' + contentObj.id, member + '#' + ContentConstants.visibility.LOGGEDIN]
                });
                // Remove the old entry in the public row
                queries.push({
                    'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                    'parameters': [oldLastModified + ':' + contentObj.id, member + '#' + ContentConstants.visibility.PUBLIC]
                });
            }
            // Add it back to the private row
            queries.push({
                'query': 'UPDATE LibraryByPrincipal SET ? = ? WHERE principalId = ?',
                'parameters': [newLastModified + ':' + contentObj.id, contentObj.id, member]
            });
            // Add it back to the logged in row
            if (contentObj.visibility === ContentConstants.visibility.LOGGEDIN || contentObj.visibility === ContentConstants.visibility.PUBLIC) {
                queries.push({
                    'query': 'UPDATE LibraryByPrincipal SET ? = ? WHERE principalId = ?',
                    'parameters': [newLastModified + ':' + contentObj.id, contentObj.id, member + '#' + ContentConstants.visibility.LOGGEDIN]
                });
            }
            // Add it back to the public row
            if (contentObj.visibility === ContentConstants.visibility.PUBLIC) {
                queries.push({
                    'query': 'UPDATE LibraryByPrincipal SET ? = ? WHERE principalId = ?',
                    'parameters': [newLastModified + ':' + contentObj.id, contentObj.id, member + '#' + ContentConstants.visibility.PUBLIC]
                });
            }
        }

        // Remove the content from the libraries of all removed members
        for (var r = 0; r < removedMembers.length; r++) {
            if (oldLastModified) {
                var removedMember = removedMembers[r];
                // Remove the old entry in the private row
                queries.push({
                    'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                    'parameters': [oldLastModified + ':' + contentObj.id, removedMember]
                });
                // Remove the old entry in the loggedin row
                queries.push({
                    'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                    'parameters': [oldLastModified + ':' + contentObj.id, removedMember + '#' + ContentConstants.visibility.LOGGEDIN]
                });
                // Remove the old entry in the public row
                queries.push({
                    'query': 'DELETE ? FROM LibraryByPrincipal WHERE principalId = ?',
                    'parameters': [oldLastModified + ':' + contentObj.id, removedMember + '#' + ContentConstants.visibility.PUBLIC]
                });
            }
        }
        Cassandra.runBatchQuery(queries, 'QUORUM', callback);
    });
};


///////////////////////
// Utility functions //
///////////////////////

/**
 * Creates a Content item from a Cassandra row.
 *
 * @param  {Row}        row     Cassandra Row
 * @return {Content}            Converted content object
 * @api private
 */
var _rowToContent = function(row) {
    var hash = Cassandra.rowToHash(row);
    var contentObj = new Content(hash.tenantAlias, hash.contentId, hash.visibility, hash.displayName, hash.description, hash.resourceSubType, hash.createdBy, hash.created, hash.lastModified, hash.latestRevisionId);
    if (contentObj.resourceSubType === 'file') {
        contentObj.filename = hash.filename;
        contentObj.size = (hash.size) ? parseInt(hash.size, 10) : 0;
        contentObj.mime = hash.mime;
    } else if (contentObj.resourceSubType === 'link') {
        contentObj.link = hash.link;
    } else if (contentObj.resourceSubType === 'collabdoc') {
        contentObj.etherpadGroupId = hash.etherpadGroupId;
        contentObj.etherpadPadId = hash.etherpadPadId;
    }

    try {
        contentObj.previews = JSON.parse(hash.previews);
    } catch (err) {
        contentObj.previews = {};
        log().warn({'hash': hash}, 'Could not parse the previews object.');
    }
    return contentObj;
};
