/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var CassandraSystem = require('cassandra-client').System;
var PooledConnection = require('cassandra-client').PooledConnection;
var Connection = require('cassandra-client').Connection;
var CassandraTypes = require('cassandra-client/lib/gen-nodejs/cassandra_types');

var OAE = require('oae-util/lib/oae');
var IO  = require('oae-util/lib/io');

var CONFIG = null;
var sys = null;
var pool = null;


/**
 * Get the system connector.
 *
 * @return {System}
 */
var getSys = function() {
    return sys;
};

/**
 * Initializes the keyspace in config.keyspace with the CF's in all the modules their install.js code.
 *
 * @param  {Object}         config          A Configuration object that can be used as the node-cassandra-client config.
 * @param  {Function(err)}  callback        Standard callback method
 * @param  {Object}         callback.err    Error object, containing the error message
 */
module.exports.init = function(config, callback) {
    callback = callback || function(){};
    CONFIG = config;

    // Initialize the System connnector immediately.
    sys = new CassandraSystem(CONFIG.system);

    // Initialize the pooled connections immediately.
    pool = new PooledConnection(config);

    var keyspace = CONFIG.keyspace;

    module.exports.keyspaceExists(keyspace, function(err, exists) {
        if (err) {
            return callback(err);
        }

        if (!exists) {
            module.exports.createKeyspace(keyspace, function(err) {
                if (err) {
                    return callback(err);
                }
                module.exports.installModules(callback);
            });
        } else {
            module.exports.installModules(callback);
        }
    });
};

/**
 * Initialize the schemas for all of the OAE modules
 * @param  {Function(err)}  callback        Standard callback method
 * @param  {Object}         callback.err    Error object, containing the error message
 */
module.exports.installModules = function(callback) {
    callback = callback || function(){};
    OAE.getAvailableModules(function(modules) {
        console.log('Enabling ' + modules.join(', '));
        var installedModules = 0;
        var installModule = function(module) {
            // Check if the module has a schema.js file
            var path = "node_modules/" + module + "/lib/schema.js";
            IO.pathExists(path, function(exists) {
                if (exists) {
                    require(module + "/lib/schema").ensureSchema(function() {
                        installedModules++;
                        if (installedModules === modules.length) {
                            callback(false);
                        }
                    });
                } else {
                    installedModules++;
                    if (installedModules === modules.length) {
                        callback(false);
                    }
                }
            });
        };
        for (var i = 0; i < modules.length;i++) {
            installModule(modules[i]);
        }
    });
};

module.exports.close = function(callback) {
    sys.close(function() {
        pool.shutdown(function() {
            pool = null;
            sys.removeAllListeners();
            sys = null;
            callback();
        });
    });
};

/**
 * Create a keyspace
 * @param  {String}   name     The name of your keyspace
 * @param  {Function(err, created)} callback Callback method
 */
module.exports.createKeyspace = function(name, callback) {
    callback = callback || function(){};
    var ksDef = new CassandraTypes.KsDef({
        name: name, 
        strategy_class: 'org.apache.cassandra.locator.SimpleStrategy',
        strategy_options: {
            'replication_factor': '1'
        },
        cf_defs: []
    });
    getSys().addKeyspace(ksDef, function(err) {
        if (err) {
            callback(err);
        } else {
            callback(null, true);
        }
    });
};

/**
 * Drops a keyspace
 * @param  {String}   name     The keyspace that should be dropped.
 * @param  {Function(err, dropped)} callback dropped is a boolean that states whether or not a keyspace was dropped.
 * @return {[type]}
 */
module.exports.dropKeyspace = function(name, callback) {
    callback = callback || function(){};
    module.exports.runQuery("drop keyspace " + name, false, function(err) {
        if (err) {
            callback(err);
        } else {
            callback(false, true);
        }
    });
};

/**
 * Checks if a keyspace exists or not.
 * @param  {String}   name     The name of the keyspace to check.
 * @param  {Function(err, exists)} callback Gets called with an error object (if any) and a boolean whether or not the keyspace exists.
 */
module.exports.keyspaceExists = function(name, callback) {
    getSys().describeKeyspace(name, function(err, definition) {
        if (err && err.name) {
            if (err.name === "NotFoundException") {
                callback(false, false);
            } else {
                callback(err);
            }
        } else {
            callback(false, true);
        }
    });
};

/**
 * Checks if a CF exists or not.
 * @param  {String}   name     The name of the CF to check.
 * @param  {Function(err, exists)} callback Gets called with an error object (if any) and a boolean whether or not the CF exists.
 */
module.exports.columnFamilyExists = function(name, callback) {
    getSys().describeKeyspace(CONFIG.keyspace, function(err, definition) {
        if (err) {
            callback(err);
        } else {
            var exists = false;
            for (var i = 0; i < definition.cf_defs.length;i++) {
                if (definition.cf_defs[i].name === name) {
                    exists = true;
                    break;
                }
            }
            callback(false, exists);
        }
    });
};


/**
 * Drops a Column family. A query will only be performed if the CF exists.
 * @param  {String}   name     The name of CF you wish to drop.
 * @param  {Function(err, dropped)} callback Gets called with an error object (if any) and a boolean whether or not the CF was dropped.
 */
module.exports.dropColumnFamily = function(name, callback) {
    // Only drop if it exists.
    module.exports.columnFamilyExists(name, function(err, exists) {
        if (err) {
            callback(err);
        } else {
            if (exists) {
                module.exports.runQuery('drop columnfamily ?', [name], function(err) {
                    if (err) {
                        callback(err);
                    } else {

                        // The node-cassandra-client caches the CF schema internally.
                        // there is no way of refreshing that (synchronously)
                        // We close the pool and create a new connection.
                        // This makes using this method not suitable for production use!
                        module.exports.close(function() {
                            // Initialize the System connnector immediately.
                            sys = new CassandraSystem(CONFIG.system);

                            // Initialize the pooled connections immediately.
                            pool = new PooledConnection(CONFIG);

                            callback(false, true);
                        });
                    }
                });
            } else {
                callback(false, false);
            }
        }
    });
};

/**
 * Create a batch of column families. This is a helper method that will be
 * used by various OAE modules when they are initialized. The column families
 * will only be created when they don't exist yet
 * @param  {Array}              families        Array containing the names of all column families that should be dropped
 * @param  {Function(err)}      callback        Standard callback functionGets called when the CFs have been dropped.
 * @param  {Object}             callback.err    Array of error objects, each containing the error message.
 */
module.exports.dropColumnFamilies = function(families, callback) {
    callback = callback || function() {};
    var done = 0; var todo = families.length;
    var returnError = [];
    var finishCFDropped = function(err, exists) {
        if (err) {
            returnError.push(err);
        }
        done++;
        if (done === todo) {
            callback(returnError.length ? returnError : false);
        }
    };
    for (var cf = 0; cf < families.length; cf++) {
        module.exports.dropColumnFamily(families[cf], finishCFDropped);
    }
};

/**
 * Creates a CF if it doesn't exist yet. This is basically a helper method
 * that allows for quick creation of CF if nescecary.
 * Do NOT use this in a concurrent way as the pooled connection will be shut down!
 * 
 * @param  {String}                  name               CF name
 * @param  {String}                  cql                The CQL that can be used to create the CF if it doesn't exist.
 * @param  {Function(err, created)}  callback           Gets called when the CF has been created (or it failed.)
 * @param  {Object)}                 callback.err       Error object containing the error message
 * @param  {Boolean)}                callback.created   Whether or not the column family has actually been created
 */
module.exports.createColumnFamily = function(name, cql, callback) {
    callback = callback || function() {};
    module.exports.columnFamilyExists(name, function(err, exists) {
        if (err) {
            return callback(err);
        }

        if (!exists) {
            module.exports.runQuery(cql, false, function() {
                if (err) {
                    return callback(err);
                }

                // The node-cassandra-client caches the CF schema internally.
                // there is no way of refreshing that (synchronously)
                // We close the pool and create a new connection.
                // This makes using this method not suitable for production use!
                module.exports.close(function() {
                    // Initialize the System connnector immediately.
                    sys = new CassandraSystem(CONFIG.system);

                    // Initialize the pooled connections immediately.
                    pool = new PooledConnection(CONFIG);

                    callback(false, true);
                });
            });
        } else {
            callback(false, false);
        }
    });
};

/**
 * Create a batch of column families. This is a helper method that will be
 * used by various OAE modules when they are initialized. The column families
 * will only be created when they don't exist yet
 * @param  {Object}             families        JSON object representing the column families that need to be created. The keys 
 *                                              are the names of the CFs, the values are the CQL statements required to create them
 * @param  {Function(err)}      callback        Standard callback functionGets called when the CFs have been created.
 * @param  {Object}             callback.err    Array of error objects, each containing the error message.
 */
module.exports.createColumnFamilies = function(families, callback) {
    callback = callback || function() {};
    var done = 0; var todo = _.keys(families).length;
    var returnError = [];
    var finishCFCreate = function(err, exists) {
        if (err) {
            returnError.push(err);
        }
        done++;
        if (done === todo) {
            callback(returnError.length ? returnError : false);
        }
    };
    for (var cf in families) {
        if (families.hasOwnProperty(cf)) {
            module.exports.createColumnFamily(cf, families[cf], finishCFCreate);
        }
    }
};

/**
 * Run a single Cassandra query.
 * @param  {String}   query      The CQL query
 * @param  {array}    parameters An array of values that can be interpreted by node-cassandra-client. If an element is detected as an array the query and parameters will be fixed.
 * @param  {Function} callback   Callback method.
 */
module.exports.runQuery = function(query, parameters, callback) {
    var fixed = fixQuery(query, parameters);
    executeQuery(fixed.query, fixed.parameters, callback);
};

/**
 * Run a batched Cassandra query.
 * @param  {Object[]}   queries  An array of simple hashes. Each hash should contain a query key and parameters key.
 * @param  {Function}   callback Callback method
 */
module.exports.runBatchQuery = function(queries, callback) {
    if (queries.length === 0) {
        return callback();
    }
    var query = 'BEGIN BATCH USING CONSISTENCY ONE \n';
    var parameters = [];
    for (var i = 0; i < queries.length;i++) {
        var fixed = fixQuery(queries[i].query, queries[i].parameters);
        query += fixed.query + "; \n";
        parameters = parameters.concat(fixed.parameters);
    }
    query += 'APPLY BATCH;';
    executeQuery(query, parameters, callback);
};

/**
 * Adds the ability to pass in array parameters. If you pass in a parameter that is an array, the apropriate number of question marks will be added in the query.
 * @param  {String}    query      The query
 * @param  {Object[]}  parameters The parameters for this query.
 */
var fixQuery = function(query, parameters) {
    var fixedQuery = "";
    var fixedParameters = [];
    var q = query.indexOf('?');
    var from = 0;
    var i = 0;
    while (q >= 0) {
        fixedQuery += query.slice(from, q);

        // If we passed in an array add n-1 more question marks.
        if (Array.isArray(parameters[i])) {
            for (var c = 0; c < parameters[i].length - 1;c++) {
                fixedQuery += "?, ";
                fixedParameters.push(parameters[i][c]);
            }
            fixedParameters.push(parameters[i][parameters[i].length - 1]);
        }
        else {
            fixedParameters.push(parameters[i]);
        }
        fixedQuery += '?';


        // Next one.
        from = q+1;
        q = query.indexOf('?', from);
        i++;
    }

    // Append the request of the query.
    fixedQuery += query.slice(from);
    return {'query': fixedQuery, 'parameters': fixedParameters};
};

/**
 * Actually executes a query
 * @param  {String}    query       The query
 * @param  {Object[]}  parameters  The parameters that match this query
 * @param  {Function}  callback    Callback
 */
var executeQuery = function(query, parameters, callback) {
    callback = callback || function() {};
    // Check for null parameters that have been passed in. We have to intercept this
    // because otherwise the query will fail and an "All connections are unhealtyh" 
    // error will start coming back for each Cassandra query
    for (var p = 0; p < parameters.length; p++) {
        if (parameters[p] === null || parameters[p] === undefined) {
            return callback({
                'code': 400, 
                'msg': 'An incorrect query has been attempted. The query was "' + query + '" and the parameters that have been passed in were "[' + parameters + ']"'
            });
        }
    };
    pool.execute(query, parameters, callback);
};