/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var events = require('events');
var ShortId = require('shortid');
var util = require('util');

var ContentAPI = require('oae-content');
var ContentDAO = require('oae-content/lib/internal/dao');
var log = require('oae-logger').logger('oae-annotations');
var Validator = require('oae-util/lib/validator').Validator;

var Annotation = require('oae-annotations/lib/model').Annotation;
var AnnotationConstants = require('oae-annotations/lib/constants').AnnotationConstants;
var AnnotationDAO = require('oae-annotations/lib/internal/dao');
var AnnotationView = require('oae-annotations/lib/view');

/**
 * ### Events
 *
 * The `AnnotationAPI`, as enumerated in `AnnotationConstants.events`, emits the following events:
 *
 * * `createdAnnotation(ctx, content, revision, annotation)`: A new annotation was created
 * * `updatedAnnotation(ctx, content, revision, oldAnnotation, newAnnotation)`: An annotation was updated
 * * `deletedAnnotation(ctx, content, revision, annotation)`: An existing annotation was deleted
 */
var AnnotationAPI = module.exports = new events.EventEmitter();

/**
 * Create an annotation
 *
 * @param  {Context}        ctx                     The context of the current request
 * @param  {String}         contentId               The id of the content item for which an annotation needs to be created
 * @param  {String}         revisionId              The id of the revision for which an annotation needs to be created
 * @param  {Number}         pageNumber              The page number on which the annotation is created
 * @param  {String}         text                    The text that is being added
 * @param  {String}         quote                   The text is is being selected and annotated
 * @param  {Range[]}        ranges                  The ranges on which the annotation applies, usualy just one
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object
 * @param  {Annotation}     callback.annotation     The created annotation object
 */
var createAnnotation = module.exports.createAnnotation = function(ctx, contentId, revisionId, pageNumber, text, quote, ranges, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Anonymous users cannot create annotations'}).isLoggedInUser(ctx);
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be specified'}).isResourceId();
    validator.check(revisionId, {'code': 400, 'msg': 'A revision id must be specified'}).isResourceId();
    validator.check(pageNumber, {'code': 400, 'msg': 'A page number must be specified'}).notNull();
    validator.check(pageNumber, {'code': 400, 'msg': 'A page number must be specified'}).isNumeric();
    validator.check(pageNumber, {'code': 400, 'msg': 'A page number must be specified'}).min(1);
    validator.check(text, {'code': 400, 'msg': 'The annotation text must be specified'}).notNull();
    validator.check(quote, {'code': 400, 'msg': 'The quoted text must be specified'}).notNull();
    validator.check(ranges, {'code': 400, 'msg': 'at least one range must be specified'}).notNull();
    if (ranges) {
        validator.check(ranges.length, {'code': 400, 'msg': 'At least one range must be specified'}).min(1);
        _.each(ranges, function(range) {
            validator.check(range.start, {'code': 400, 'msg': 'Each range should have an XPath expression that indicates the beginning of the selection'}).notNull();
            validator.check(range.end, {'code': 400, 'msg': 'Each range should have an XPath expression that indicates the end of the selection'}).notNull();
            validator.check(range.startOffset, {'code': 400, 'msg': 'Each range should have a start offset'}).notNull();
            validator.check(range.startOffset, {'code': 400, 'msg': 'The start offset should be numeric'}).isNumeric();
            validator.check(range.startOffset, {'code': 400, 'msg': 'The start offset needs to be a positive number or zero'}).min(0);
            validator.check(range.endOffset, {'code': 400, 'msg': 'Each range should have an end offset'}).notNull();
            validator.check(range.endOffset, {'code': 400, 'msg': 'The end offset should be numeric'}).isNumeric();
            validator.check(range.endOffset, {'code': 400, 'msg': 'The end offset needs to be a positive number or zero'}).min(0);
        });
    }

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Now that we've validated our input, parse the stringified values into proper numbers
    pageNumber = parseInt(pageNumber, 10);
    _.each(ranges, function(range) {
        range.startOffset = parseInt(range.startOffset, 10);
        range.endOffset = parseInt(range.endOffset, 10);
    });

    // Check if this is a valid content item that we can either manage or are an explicit member of
    ContentAPI.getFullContentProfile(ctx, contentId, function(err, content) {
        if (err) {
            return callback(err);
        } else if (content.resourceSubType !== 'file') {
            return callback({'code': 400, 'msg': 'Only files can be annotated'});
        } else if (!content.canManage && !content.isViewer) {
            return callback({'code': 401, 'msg': 'Only explicit members or managers can create an annotation'});
        }

        // Ensure the revision exists
        ContentDAO.Revisions.getRevision(revisionId, function(err, revision) {
            if (err) {
                return callback(err);
            } else if (revision.contentId !== contentId) {
                return callback({'code': 401, 'msg': 'The specified revision does not belong to the specified content item'});
            }

            // Construct an annotation ID that when sorted lexically, annotations on the first page
            // return before annotations on the second page. Annotations made on the same page should
            // be sorted on their creation date
            var now = Date.now();
            var id = util.format('%s-%s-%s', pageNumber, now, ShortId.generate());
            var annotation = new Annotation(id, contentId, revisionId, now, ctx.user().id, null, null, pageNumber, text, quote, ranges);
            AnnotationDAO.createAnnotation(annotation, function(err) {
                if (err) {
                    return callback(err);
                }

                AnnotationView.toViewData(ctx, [annotation], function(err, annotations) {
                    if (err) {
                        return callback(err);
                    }

                    AnnotationAPI.emit(AnnotationConstants.events.CREATED, ctx, content, revision, annotations[0]);

                    return callback(null, annotations[0]);
                });
            });
        });
    });
};

/**
 * Update an annotation
 *
 * @param  {Context}        ctx                     The context of the current request
 * @param  {String}         contentId               The id of the content item for which an annotation needs to be updated
 * @param  {String}         revisionId              The id of the revision for which an annotation needs to be updated
 * @param  {String}         annotationId            The id of the annotation that needs to be updated
 * @param  {String}         text                    The new text of the annotation
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object
 * @param  {Annotation}     callback.annotation     The updated annotation object
 */
var updateAnnotation = module.exports.updateAnnotation = function(ctx, contentId, revisionId, annotationId, text, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Anonymous users cannot edit annotations'}).isLoggedInUser(ctx);
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be specified'}).isResourceId();
    validator.check(revisionId, {'code': 400, 'msg': 'A revision id must be specified'}).isResourceId();
    validator.check(annotationId, {'code': 400, 'msg': 'An annotation id must be specified'}).notNull();
    validator.check(text, {'code': 400, 'msg': 'The annotation text must be specified'}).notNull();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure this user can modify this annotation/content item
    _canModify(ctx, contentId, revisionId, annotationId, function(err, content, revision, oldAnnotation) {
        if (err) {
            return callback(err);
        }

        AnnotationDAO.updateAnnotation(oldAnnotation, text, ctx.user().id, function(err, updatedAnnotation) {
            if (err) {
                return callback(err);
            }

            AnnotationView.toViewData(ctx, [updatedAnnotation], function(err, annotations) {
                if (err) {
                    return callback(err);
                }

                AnnotationAPI.emit(AnnotationConstants.events.UPDATED, ctx, content, revision, oldAnnotation, annotations[0]);

                return callback(null, annotations[0]);
            });
        });
    });
};

/**
 * Delete an annotation
 *
 * @param  {Context}    ctx                     The context of the current request
 * @param  {String}     contentId               The id of the content item for which an annotation needs to be deleted
 * @param  {String}     revisionId              The id of the revision for which an annotation needs to be deleted
 * @param  {String}     annotationId            The id of the annotation that needs to be deleted
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            Standard error object
 */
var deleteAnnotation = module.exports.deleteAnnotation = function(ctx, contentId, revisionId, annotationId, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Anonymous users cannot delete annotations'}).isLoggedInUser(ctx);
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be specified'}).isResourceId();
    validator.check(revisionId, {'code': 400, 'msg': 'A revision id must be specified'}).isResourceId();
    validator.check(annotationId, {'code': 400, 'msg': 'An annotation id must be specified'}).notNull();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure this user can modify this annotation/content item
    _canModify(ctx, contentId, revisionId, annotationId, function(err, content, revision, annotation) {
        if (err) {
            return callback(err);
        }

        AnnotationDAO.deleteAnnotation(annotation, function(err) {
            if (err) {
                return callback(err);
            }

            AnnotationAPI.emit(AnnotationConstants.events.DELETED, ctx, content, revision, annotation);
            return callback();
        });
    });
};

/**
 * Check if the current user can edit or delete an annotation. If the user
 * is not allowed to modify the annotation, a 401 error will be returned.
 * A user can modify an annotation if he is a manager of the content item
 * or he is the one that created the annotation.
 *
 * @param  {Context}        ctx                     The context of the current request
 * @param  {String}         contentId               The id of the content item for which an annotation needs to be checked
 * @param  {String}         revisionId              The id of the revision for which an annotation needs to be checked
 * @param  {String}         annotationId            The id of the annotation that needs to be checked
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object
 * @param  {Content}        callback.content        The content item on which the specified annotation was made
 * @param  {Revision}       callback.revision       The revision on which the specified annotation was made
 * @param  {Annotation}     callback.annotation     The checked annotation
 * @api private
 */
var _canModify = function(ctx, contentId, revisionId, annotationId, callback) {
    // Check if this is a valid content item that we're an explicit member of
    ContentAPI.getFullContentProfile(ctx, contentId, function(err, content) {
        if (err) {
            return callback(err);
        } else if (content.resourceSubType !== 'file') {
            return callback({'code': 400, 'msg': 'Only files can be annotated'});
        }

        // Ensure the revision exists
        ContentDAO.Revisions.getRevision(revisionId, function(err, revision) {
            if (err) {
                return callback(err);
            } else if (revision.contentId !== contentId) {
                return callback({'code': 401, 'msg': 'The specified revision does not belong to the specified content item'});
            }

            // Only managers or the annotation creator can edit the annotation
            AnnotationDAO.getAnnotation(annotationId, function(err, annotation) {
                if (err) {
                    return callback(err);

                // Ensure that somebody isn't messing around with the parameters
                } else if (annotation.revisionId !== revisionId) {
                    var data = {
                        'contentId': contentId,
                        'revisionId': revisionId,
                        'annotationId': annotationId,
                        'user': ctx.user().id
                    };
                    log().warn(data, 'Potential URL tampering detected when updating an annotation');
                    return callback({'code': 401, 'msg': 'This annotation does not belong to the specified revision'});

                // Only annotations creators or content managers are allowed to modify annotations
                } else if (annotation.createdBy !== ctx.user().id && !content.canManage) {
                    return callback({'code': 401, 'msg': 'Only content managers or annotation creators can modify an annotation'});
                }

                return callback(null, content, revision, annotation);
            });
        });
    });
};

/**
 * Retrieve the annotations for a given revision and page number
 *
 * @param  {Context}        ctx                     The context of the current request
 * @param  {String}         contentId               The id of the content item for which the annotations need to be retrieved
 * @param  {String}         revisionId              The id of the revision for which the annotations need to be retrieved
 * @param  {String}         pageNumber              The page number for which the annotations need to be retrieved
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object
 * @param  {Annotation[]}   callback.annotations    The retrieved annotations
 */
var getAnnotations = module.exports.getAnnotations = function(ctx, contentId, revisionId, pageNumber, callback) {
    pageNumber = parseInt(pageNumber, 10);
    pageNumber = pageNumber || 1;

    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be specified'}).isResourceId();
    validator.check(revisionId, {'code': 400, 'msg': 'A revision id must be specified'}).isResourceId();
    validator.check(pageNumber, {'code': 400, 'msg': 'A page number must be specified'}).min(1);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure the user has access to the content item and that the revision exists
    ContentAPI.getRevision(ctx, contentId, revisionId, function(err) {
        if (err) {
            return callback(err);
        }

        AnnotationDAO.getAnnotations(revisionId, pageNumber, 100000, function(err, annotations) {
            if (err) {
                return callback(err);
            }

            AnnotationView.toViewData(ctx, annotations, callback);
        });
    });
};

