/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var ShortId = require('shortid');
var util = require('util');

var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzUtil = require('oae-authz/lib/util');
var Config = require('oae-config/lib/api').config('oae-principals');
var LibraryAPI = require('oae-library');
var log = require('oae-logger').logger('oae-principals');
var OaeUtil = require('oae-util/lib/util');
var Signature = require('oae-util/lib/signature');
var TenantsUtil = require('oae-tenants/lib/util');
var Validator = require('oae-authz/lib/validator').Validator;

var Group = require('./model.group').Group;
var PrincipalsConstants = require('./constants').PrincipalsConstants;
var PrincipalsDAO = require('./internal/dao');
var PrincipalsMembersLibrary = require('./libraries/members');
var PrincipalsEmitter = require('./internal/emitter');
var PrincipalsUtil = require('./util');

/**
 * Get the basic profile for a group.
 *
 * @param  {Context}  ctx             Standard context object containing the current user and the current tenant
 * @param  {String}   groupId         An identifier for a group. ex: g:cam:oae-team
 * @param  {Function} callback        Standard callback function
 * @param  {Object}   callback.err    An error that occurred, if any
 * @param  {Group}    callback.group  The group object
 */
var getGroup = module.exports.getGroup = function(ctx, groupId, callback) {
    var validator = new Validator();
    validator.check(groupId, {'code': 400,'msg': 'An invalid group id was specified'}).isGroupId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    return PrincipalsUtil.getPrincipal(ctx, groupId, callback);
};

/**
 * Get a full group profile. In addition to the basic profile, this includes access information such as:
 *  `isManager`: Whether or not the user in context can manage the group
 *  `isMember`: Whether or not the user in context is a member of the group
 *  `canJoin`: Whether or not the user in context can join the group
 *
 * This also differs from `getGroup` in that if the current user is not allowed to access the group, rather than "scrubbing" sensitive information from the group, it will send back a 401 error.
 *
 * @param  {Context}   ctx             Standard context object containing the current user and the current tenant
 * @param  {String}    groupId         The id of the group to get
 * @param  {Function}  callback        Standard callback function
 * @param  {Object}    callback.err    An error that occurred, if any
 * @param  {Group}     callback.group  The agumented group object
 */
var getFullGroupProfile = module.exports.getFullGroupProfile = function(ctx, groupId, callback) {
    getGroup(ctx, groupId, function(err, group) {
        if (err) {
            return callback(err);
        } else if (group.deleted) {
            return callback({'code': 404, 'msg': util.format('Couldn\'t find principal: %s', groupId)});
        }

        // Determine what roles, if any, the current user has on the group
        _getAllRoles(ctx, groupId, function(err, roles) {
            if (err) {
                return callback(err);
            }

            var hasRole = (!_.isEmpty(roles));
            if (!_canView(ctx, group, hasRole)) {
                return callback({'code': 401, 'msg': 'You do not have access to this group'});
            }

            // A tenant or global administrator should be marked as a member and a manager
            var isAdmin =  (ctx.user() && ctx.user().isAdmin(group.tenant.alias));

            group.isMember = (isAdmin || _.contains(roles, PrincipalsConstants.roles.MEMBER) || _.contains(roles, PrincipalsConstants.roles.MANAGER));
            group.isManager = (isAdmin || _.contains(roles, PrincipalsConstants.roles.MANAGER));
            group.canJoin = _canJoin(ctx, group, hasRole);

            if (group.isMember) {
                // Generate a signature that can be used for push notifications
                group.signature = Signature.createExpiringResourceSignature(ctx, groupId);

            }

            // Only fetch the group creator if there is one
            OaeUtil.invokeIfNecessary(group.createdBy, PrincipalsUtil.getPrincipal, ctx, group.createdBy, function(err, createdBy) {
                if (err) {
                    return callback(err);
                } else if (createdBy) {
                    group.createdBy = createdBy;
                }

                // As part of the group profile, get the top 8 members in the members library
                _getMembersLibrary(ctx, group, hasRole, null, 8, function(err, members) {
                    if (err) {
                        return callback(err);
                    }

                    // Add the members list to the full group profile
                    group.members = _.filter(members, function(member) {
                        // We should not show any members whose profile is not linkable
                        return member.profile.profilePath;
                    });

                    PrincipalsEmitter.emit(PrincipalsConstants.events.GET_GROUP_PROFILE, ctx, group);
                    return callback(null, group);
                });
            });
        });
    });
};

/**
 * Convenience function to get all explicit roles a user has on a group. This handles the
 * anonymous check on the provided context.
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     groupId         The id of the group whose membership to check
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 * @param  {String[]}   callback.roles  The explicit roles the user has in the group, if any
 * @api private
 */
var _getAllRoles = function(ctx, groupId, callback) {
    if (!ctx.user()) {
        // Anonymous user cannot have any explicit role
        return callback(null, []);
    }

    return AuthzAPI.getAllRoles(ctx.user().id, groupId, callback);
};

/**
 * Internal function that checks whether or not the current user can view a group
 *
 * @param  {Context}        ctx                 Standard context object containing the current user and the current tenant
 * @param  {Group}          group               The group object representing the group we're checking access for
 * @param  {Boolean}        hasRole             Whether or not the current user has a role in the group
 * @return {Boolean}                            Whether or not the current user has access to the group
 * @api private
 */
var _canView = function(ctx, group, hasRole) {
    if (group.visibility === AuthzConstants.visibility.PUBLIC) {
        return true;

    // If we have a role in the group we can always view it
    } else if (hasRole) {
        return true;

    // For the following checks, we're dealing with users who are not a member of the group

    // An anonymous user can never see a non-public group
    } else if (!ctx.user()) {
        return false;

    // If I am from the same tenant and the group is loggedin, I can see it
    } else if (TenantsUtil.isLoggedIn(ctx, group.tenant.alias) && group.visibility === AuthzConstants.visibility.LOGGEDIN) {
        return true;

    // If I am from an interacting tenant and the group is joinable, I can view it
    } else if (TenantsUtil.canInteract(ctx.user().tenant.alias, group.tenant.alias) && group.joinable === AuthzConstants.joinable.YES) {
        return true;

    // If the user is admin of the group's tenant, they have access
    } else if (ctx.user().isAdmin(group.tenant.alias)) {
        return true;
    }

    // In all other cases the user can't view the group
    return false;
};

/**
 * Get the members of a group and their roles
 *
 * @param  {Context}            ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}             groupId                 The id of the group to get the members for
 * @param  {String}             start                   The group paging token from which to start fetching group members
 * @param  {Number}             limit                   The maximum number of results to return. Default: 10
 * @param  {Function}           callback                Standard callback function
 * @param  {Object}             callback.err            An error that occurred, if any
 * @param  {User[]|Group[]}     callback.members        An array of the direct members of the group
 * @param  {String}             callback.nextToken      The value to provide in the `start` parameter to get the next set of results
 */
var getMembersLibrary = module.exports.getMembersLibrary = function(ctx, groupId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(groupId, {'code': 400,'msg': 'An invalid group id was specified'}).isGroupId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure that this group exists
    getGroup(ctx, groupId, function(err, group) {
        if (err) {
            return callback(err);
        } else if (group.deleted) {
            return callback({'code': 404, 'msg': util.format('Couldn\'t find principal: %s', groupId)});
        }

        // Get the members library to which the current user has access
        return _getMembersLibrary(ctx, group, null, start, limit, callback);
    });
};

/**
 * Get the members library of the given group
 *
 * @param  {Context}            ctx                     Standard context object containing the current user and the current tenant
 * @param  {Group}              group                   The group for which to get the members library
 * @param  {Boolean}            [hasRole]               Whether or not it has already been determined that the current user has explicit access to the group. If truthy, it implies they do. If falsey, it implies that we don't know yet
 * @param  {String}             [start]                 The group paging token from which to start fetching group members. Defaults to the beginning of the library
 * @param  {Number}             [limit]                 The maximum number of results to return. Default: 10
 * @param  {Function}           callback                Standard callback function
 * @param  {Object}             callback.err            An error that occurred, if any
 * @param  {User[]|Group[]}     callback.members        An array of the direct members of the group
 * @param  {String}             callback.nextToken      The value to provide in the `start` parameter to get the next set of results
 * @api private
 */
var _getMembersLibrary = function(ctx, group, hasRole, start, limit, callback) {
    // Ensure proper permissions if we haven't determined that they have an explicit role
    OaeUtil.invokeIfNecessary(!hasRole, LibraryAPI.Authz.resolveTargetLibraryAccess, ctx, group.id, group, function(err, hasAccess, visibility) {
        if (err) {
            return callback(err);
        } else if (hasRole) {
            // When there is an explicit role, we always have access and can see the private library
            hasAccess = true;
            visibility = AuthzConstants.visibility.PRIVATE;
        } else if (!hasAccess) {
            // We didn't have an explicit role, and `resolveTargetLibraryAccess` determined we don't
            // have access, so bail out
            return callback({'code': 401, 'msg': 'Insufficient privilege to view this group\'s members list'});
        }

        // Get the members from the members library and their basic profile
        PrincipalsMembersLibrary.list(group, visibility, {'start': start, 'limit': limit}, function(err, memberEntries, nextToken) {
            if (err) {
                return callback(err);
            }

            var memberIds = _.pluck(memberEntries, 'id');
            PrincipalsUtil.getPrincipals(ctx, memberIds, function(err, memberProfiles) {
                if (err) {
                    return callback(err);
                }

                var members = _.map(memberEntries, function(memberEntry) {
                    return {
                        'profile': memberProfiles[memberEntry.id],
                        'role': memberEntry.role
                    };
                });

                return callback(null, members, nextToken);
            });
        });
    });
};

/**
 * Get the group memberships of a principal
 *
 * @param  {Context}     ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}      principalId             The principal to retrieve all the groups for
 * @param  {String}      start                   The principalId that comes just before the first principal you wish to have in your results
 * @param  {Number}      limit                   The maximum number of results to return. Default: 10
 * @param  {Function}    callback                Standard callback function
 * @param  {Object}      callback.err            An error that occurred, if any
 * @param  {Group[]}     callback.groups         The principal's group memberships, either directly or indirectly
 * @param  {String}      callback.nextToken      The value to provide in the `start` parameter to get the next set of results
 */
var getMembershipsLibrary = module.exports.getMembershipsLibrary = function(ctx, principalId, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10, 1);

    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'Must specify a valid principalId'}).isPrincipalId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    PrincipalsDAO.getPrincipal(principalId, function(err, principal) {
        if (err) {
            return callback(err);
        } else if (principal.deleted) {
            return callback({'code': 404, 'msg': util.format('Couldn\'t find principal: %s', principalId)});
        }

        LibraryAPI.Authz.resolveTargetLibraryAccess(ctx, principal.id, principal, function(err, hasAccess, visibility) {
            if (err) {
                return callback(err);
            } else if (!hasAccess) {
                return callback({'code': 401, 'msg': 'You do not have access to this memberships library'});
            }

            return _getMembershipsLibrary(ctx, principalId, visibility, start, limit, callback);
        });
    });
};

/**
 * Get the group memberships of a principal. This function will keep fetching
 * items from the database until the requested amount of groups have been retrieved.
 * Folders will be filtered out of the results.
 *
 * @param  {Context}     ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}      principalId             The principal to retrieve all the groups for
 * @param  {String}      start                   The principalId that comes just before the first principal you wish to have in your results
 * @param  {Number}      limit                   The maximum number of results to return
 * @param  {Function}    callback                Standard callback function
 * @param  {Object}      callback.err            An error that occurred, if any
 * @param  {Group[]}     callback.groups         The principal's group memberships, either directly or indirectly
 * @param  {String}      callback.nextToken      The value to provide in the `start` parameter to get the next set of results
 * @api private
 */
var _getMembershipsLibrary = function(ctx, principalId, visibility, start, limit, callback, _items) {
    _items = _items || [];

    LibraryAPI.Index.list(PrincipalsConstants.library.MEMBERSHIPS_INDEX_NAME, principalId, visibility, {'start': start, 'limit': limit}, function(err, entries, nextToken) {
        if (err) {
            return callback(err);
        }

        var groupIds = _.pluck(entries, 'resourceId');
        PrincipalsUtil.getPrincipals(ctx, groupIds, function(err, groupsHash) {
            if (err) {
                return callback(err);
            }

            // Place the groups in the same order as `groupIds`
            var results = _.chain(groupIds)
                .map(function(groupId) {
                    return groupsHash[groupId];
                })
                .compact()
                .value();

            // Append the groups to the retrieved list
            _items = _items.concat(results);

            // If we don't have the required number of items yet and there is a next token,
            // we retrieve the next page
            if (_items.length < limit && nextToken) {
                return _getMembershipsLibrary(ctx, principalId, visibility, nextToken, limit, callback, _items);

            // Otherwise we can return back to the caller
            } else {
                // Get the exact amount of items
                var pagedItems = _items.slice(0, limit);

                // It's possible that we pulled more items from the database than we're returning
                // to the caller. In that case the `nextToken` is incorrect and needs to be adjusted
                if (pagedItems.length < _items.length) {
                    nextToken = _items[limit].id;
                }

                // Emit an event indicating that the memberships library has been retrieved
                PrincipalsEmitter.emit(PrincipalsConstants.events.GET_MEMBERSHIPS_LIBRARY, ctx, principalId, visibility, start, limit, pagedItems);

                return callback(null, pagedItems, nextToken);
            }
        });
    });
};

/**
 * Update the members of a group
 *
 * @param  {Context}     ctx             Standard context object containing the current user and the current tenant
 * @param  {String}      groupId         The id of the group to update the members for
 * @param  {Object}      memberChanges   Object where the keys represent the principal ids which should be updated/added/removed. The value is a string representing the new role. If false is passed in, the membership for that principal will be removed e.g. {'user1': 'manager', 'user2': 'viewer', 'user3': false}
 * @param  {Function}    [callback]      Standard callback function
 * @param  {Object}      [callback.err]  The error that occured, if any
 */
var setGroupMembers = module.exports.setGroupMembers = function(ctx, groupId, memberChanges, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({
                'err': err,
                'groupId': groupId,
                'changes': memberChanges
            }, 'Error updating group membership.');
        }
    };
    memberChanges = memberChanges || {};

    // Validation
    var principals = _.keys(memberChanges);
    var validator = new Validator();
    validator.check(groupId, {'code': 400, 'msg': 'Invalid groupId specified'}).isGroupId();
    validator.check(principals.length, {'code': 400, 'msg': 'You should specify at least 1 user/group on which to update group membership'}).min(1);
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update group membership'}).isLoggedInUser(ctx);
    for (var i = 0; i < principals.length;i++) {
        validator.check(principals[i], {'code': 400, 'msg': 'You cannot make the group a member of itself'}).not(groupId);
        validator.check(principals[i], {'code': 400, 'msg': 'Invalid principal specified as member for this group.'}).isPrincipalId();
        validator.check(memberChanges[principals[i]], {'code': 400, 'msg': 'Invalid principal specified as member for this group.'}).isValidRoleChange();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the group exists
    PrincipalsDAO.getPrincipal(groupId, function(err, group) {
        if (err) {
            return callback(err);
        } else if (group.deleted) {
            return callback({'code': 404, 'msg': util.format('Couldn\'t find principal: %s', groupId)});
        }

        // Make sure we can manage the group
        _canManage(ctx, group.id, function(err, canManage) {
            if (err) {
                return callback(err);
            } else if (!canManage) {
                return callback({'code': 401, 'msg': 'You are not authorized to update the members of this group'});
            }

            // Get the expected membership after the changes have been applied and ensure there is still a manager
            AuthzAPI.computeMemberRolesAfterChanges(groupId, memberChanges, function(err, computedPermissions, newMemberIds, updatedMemberIds, removedMemberIds) {
                if (err) {
                    return callback(err);
                } else if (!_.chain(computedPermissions).values().contains(PrincipalsConstants.roles.MANAGER).value()) {
                    return callback({'code': 400, 'msg': 'The requested operation would leave the group without a manager'});
                }

                // Ensure that we are not associating new members to this group that violate tenant interaction boundaries
                PrincipalsDAO.getPrincipals(newMemberIds, null, function(err, newMembers) {
                    if (err) {
                        return callback(err);
                    } else if (_.keys(newMembers).length !== newMemberIds.length) {
                        return callback({'code': 400, 'msg': 'One or more target members being granted access do not exist'});
                    }

                    newMembers = _.values(newMembers);

                    AuthzAPI.canInteract(ctx, group.tenant.alias, newMembers, function(err, canInteract, illegalPrinicpalIds) {
                        if (err) {
                            return callback(err);
                        } else if (!canInteract) {
                            return callback({'code': 401, 'msg': 'You are not authorized to make these users a member of the group: ' + illegalPrinicpalIds.join(', ')});
                        }

                        // Update the roles in the Authz lists
                        AuthzAPI.updateRoles(group.id, memberChanges, function(err) {
                            if (err) {
                                return callback(err);
                            }

                            var oldLastModified = group.lastModified;
                            var newLastModified = Date.now().toString();
                            PrincipalsDAO.updatePrincipal(group.id, {'lastModified': newLastModified}, function(err) {
                                if (err) {
                                    return callback(err);
                                }

                                group.lastModified = newLastModified;

                                // TODO: The logic that happens in _touchMembershipLibraries can be moved into a `when` listener. See
                                // `oae-principals/lib/librararies/members.js` for an example on `UPDATED_GROUP_MEMBERS`
                                _touchMembershipLibraries(group, oldLastModified, newMemberIds.slice(), removedMemberIds.slice(), function(err) {
                                    if (err) {
                                        return callback(err);
                                    }

                                    PrincipalsEmitter.emit(PrincipalsConstants.events.UPDATED_GROUP_MEMBERS, ctx, group, memberChanges, newMemberIds, updatedMemberIds, removedMemberIds, function(errs) {
                                        if (errs) {
                                            return callback(_.first(err));
                                        }

                                        return callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });
};

/**
 * Leave a group. For this to be successful, the user must be a part of the group (role does not matter).
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     groupId         The id of the group to leave
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var leaveGroup = module.exports.leaveGroup = function(ctx, groupId, callback) {
    var validator = new Validator();
    validator.check(groupId, {'code': 400, 'msg': 'Invalid groupId specified'}).isGroupId();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to join a group'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Verify we aren't trying to leave a group we aren't a part of. This is a lighter operation than `getPrincipals`, so we do it first.
    AuthzAPI.getDirectRoles([ctx.user().id], groupId, function(err, userRole) {
        if (err) {
            return callback(err);
        } else if (!userRole[ctx.user().id]) {
            return callback({'code': 400, 'msg': 'Cannot leave a group of which you aren\'t a member'});
        }

        userRole = userRole[ctx.user().id];

        // Verify the group exists
        PrincipalsDAO.getPrincipal(groupId, function(err, group) {
            if (err) {
                return callback(err);
            } else if (group.deleted) {
                return callback({'code': 404, 'msg': util.format('Couldn\'t find principal: %s', groupId)});
            }

            var memberChanges = {};
            memberChanges[ctx.user().id] = false;

            // Get the expected membership after the changes have been applied and ensure there is still a manager, but only if the user's current role was
            // manager
            AuthzAPI.computeMemberRolesAfterChanges(groupId, memberChanges, function(err, computedPermissions, newMemberIds, updatedMemberIds, removedMemberIds) {
                if (err) {
                    return callback(err);
                } else if (userRole === PrincipalsConstants.roles.MANAGER && !_.chain(computedPermissions).values().contains(PrincipalsConstants.roles.MANAGER).value()) {
                    return callback({'code': 400, 'msg': 'The requested operation would leave the group without a manager'});
                }

                AuthzAPI.updateRoles(group.id, memberChanges, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Remove the group from the user's library, but don't update the group timestamp because leaving the group isn't really an indication of
                    // relevant activity
                    _touchMembershipLibraries(group, null, [], [ctx.user().id], function(err) {
                        if (err) {
                            return callback(err);
                        }

                        PrincipalsEmitter.emit(PrincipalsConstants.events.LEFT_GROUP, ctx, group, userRole, function(errs) {
                            if (errs) {
                                return callback(_.first(errs));
                            }

                            return callback();
                        });
                    });
                });
            });
        });
    });
};

/**
 * Join a group. For this to be successful, the user must not already be a member of the group, and the group
 * must be joinable. If successful, the user will be added to the group with rol 'member'.
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     groupId         The id of the group to join
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var joinGroup = module.exports.joinGroup = function(ctx, groupId, callback) {
    var validator = new Validator();
    validator.check(groupId, {'code': 400, 'msg': 'Invalid groupId specified'}).isGroupId();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to join a group'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Verify we aren't trying to join a group we're already a member of. This is a lighter operation than `getPrincipal`, so we do it first.
    AuthzAPI.hasAnyRole(ctx.user().id, groupId, function(err, hasAnyRole) {
        if (err) {
            return callback(err);
        } else if (hasAnyRole) {
            return callback({'code': 400, 'msg': 'You are already a member of this group'});
        }

        // Verify the group exists
        PrincipalsDAO.getPrincipal(groupId, function(err, group) {
            if (err) {
                return callback(err);
            } else if (group.deleted) {
                return callback({'code': 404, 'msg': util.format('Couldn\'t find principal: %s', groupId)});
            } else if (!_canJoin(ctx, group, hasAnyRole)) {
                return callback({'code': 401, 'msg': 'You cannot join this group'});
            }

            var changeMembers = {};
            changeMembers[ctx.user().id] = PrincipalsConstants.roles.MEMBER;
            AuthzAPI.computeMemberRolesAfterChanges(group.id, changeMembers, function(err, computedPermissions, newMemberIds, updatedMemberIds, removedMemberIds) {
                if (err) {
                    return callback(err);
                }

                // Apply the changes
                AuthzAPI.updateRoles(group.id, changeMembers, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Asynchronously update the libraries of group members to indicate that the group has been interacted with
                    // more recently
                    var oldLastModified = group.lastModified;
                    var newLastModified = Date.now().toString();
                    var updatedProfileFields = {'lastModified': newLastModified};
                    PrincipalsDAO.updatePrincipal(group.id, updatedProfileFields, function(err) {
                        if (err) {
                            return log().error({
                                'err': err,
                                'group': group
                            }, 'An error has occurred while updating the group `lastModified` for member library updates after a group join');
                        }

                        // Apply the updated lastModified timestamp to the group storage object so
                        // library updates remain in sync
                        _.extend(group, updatedProfileFields);

                        // This will take care of updating the group in existing member libraries and inserting it into new member libraries
                        _touchMembershipLibraries(group, oldLastModified, newMemberIds.slice(), removedMemberIds.slice(), function(err) {
                            if (err) {
                                log().error({
                                    'err': err,
                                    'group': group,
                                    'memberIds': _.keys(computedPermissions)
                                }, 'An error occurred while updating the library index for members after a group join');
                            }
                        });
                    });

                    // Emit an event indicating that this group was joined by the current user in context
                    PrincipalsEmitter.emit(PrincipalsConstants.events.JOINED_GROUP, ctx, group, PrincipalsConstants.roles.MEMBER, function(errs) {
                        if (errs) {
                            return callback(_.first(errs));
                        }

                        return callback();
                    });
                });
            });
        });
    });
};

/**
 * Determine whether or not the user in the context is allowed to join the given group.
 *
 * @param  {Context}        ctx                 Standard context object containing the current user and the current tenant
 * @param  {Group}          group               The group object representing the group we're checking for joining
 * @param  {Boolean}        hasRole             Whether or not the current user has a role in the group
 * @return {Boolean}                            Whether or not the current user can join the group
 * @api private
 */
var _canJoin = function(ctx, group, hasRole) {
    // You cannot join a group of which you're already a member
    if (hasRole) {
        return false;

    // Anonymous users can never join a group
    } else if (!ctx.user()) {
        return false;

    // TODO: For now we only support joining a group if it's joinable property has been set to YES
    } else if (group.joinable !== AuthzConstants.joinable.YES) {
        return false;

    // By this point we know the user is logged in and that people are allowed to join the group.
    // If the user is on the same tenant as the group, he can always request to join
    } else if (ctx.user().tenant.alias === group.tenant.alias) {
        return true;

    // If the user is from another tenant, he can only join the group if the tenant permeability
    // settings allow it AND the group's visibility setting is set to public
    } else if (TenantsUtil.canInteract(ctx.user().tenant.alias, group.tenant.alias) && group.visibility === AuthzConstants.visibility.PUBLIC) {
        return true;

    // In any other case, you cannot join the group
    } else {
        return false;
    }
};

/**
 * Create a new group
 *
 * @param  {Context}   ctx                  Standard context object containing the current user and the current tenant
 * @param  {String}    displayName          The display name of the group
 * @param  {String}    [description]        A longer description for the group
 * @param  {String}    [visibility]         The visibility of the group. Should be one of `AuthzConstants.visibility`'s values. If left undefined, it defaults to the configured tenant default
 * @param  {String}    [joinable]           How the group can be joined. Should be one of `AuthzConstants.joinable`'s values. If left undefined, it defaults to the configured tenant default
 * @param  {Object}    [permissions]        A hash where each key is a principal id and the value is one of `PrincipalsConstants.roles`
 * @param  {Function}  [callback]           Standard callback function
 * @param  {Object}    [callback.err]       An error that occured, if any
 * @param  {Group}     [callback.group]     The created group
 */
var createGroup = module.exports.createGroup = function(ctx, displayName, description, visibility, joinable, permissions, callback) {
    var tenantAlias = ctx.tenant().alias;

    // Default parameters
    description = description || '';
    visibility = visibility || Config.getValue(tenantAlias, 'group', 'visibility');
    joinable = joinable || Config.getValue(tenantAlias, 'group', 'joinable');
    permissions = permissions || {};
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'An error occurred while creating a group');
        }
    };

    // Parameter validation
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Cannot create a group anonymously'}).isLoggedInUser(ctx);
    validator.check(displayName, {'code': 400, 'msg': 'You need to provide a display name for this group'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'A display name can be at most 1000 characters long'}).isShortString();
    validator.check(visibility, {'code': 400, 'msg': 'The visibility setting must be one of: ' + _.values(AuthzConstants.visibility)}).isValidVisibility();
    validator.check(joinable, {'code': 400, 'msg': 'The joinable setting must be one of: ' + _.values(AuthzConstants.joinable)}).isIn(_.values(AuthzConstants.joinable));
    if (description) {
        validator.check(description, {'code': 400, 'msg': 'A description can only be 10000 characters long'}).isMediumString();
    }
    _.each(permissions, function(role, principalId) {
        validator.check(principalId, {'code': 400, 'msg': 'Only valid principal IDs are accepted'}).isPrincipalId();
        validator.check(role, {'code': 400, 'msg': 'Only `manager` or `member` are accepted as a role for a principal'}).isIn(_.values(PrincipalsConstants.roles));
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Generate the group id
    var groupId = AuthzUtil.toId(AuthzConstants.principalTypes.GROUP, tenantAlias, ShortId.generate());

    // Immediately add the current user as a manager
    var currentUser = getUserId(ctx);
    permissions[currentUser] = PrincipalsConstants.roles.MANAGER;

    // Ensure we don't violate tenant boundaries by adding users from other private tenants
    var principalIds = _.keys(permissions);
    PrincipalsDAO.getPrincipals(principalIds, null, function(err, principals) {
        if (err) {
            return callback(err);
        } else if (_.keys(principals).length !== principalIds.length) {
            return callback({'code': 400, 'msg': 'One or more target members being granted access do not exist'});
        }

        principals = _.values(principals);

        AuthzAPI.canInteract(ctx, tenantAlias, principals, function(err, canInteract, illegalPrinicpalIds) {
            if (err) {
                return callback(err);
            }

            // Create the group
            PrincipalsDAO.createGroup(groupId, tenantAlias, displayName, description, visibility, joinable, currentUser, function (err, group) {
                if (err) {
                    return callback(err);
                }

                // Apply the permissions to the group
                AuthzAPI.updateRoles(group.id, permissions, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Update the user's libraries
                    _touchMembershipLibraries(group, null, _.keys(permissions), [], function(err) {
                        if (err) {
                            log().error({
                                'err': err,
                                'group': group,
                                'permissions': permissions
                            }, 'An error occurred trying to insert to the library index while creating a group');
                        }

                        PrincipalsEmitter.emit(PrincipalsConstants.events.CREATED_GROUP, ctx, group, permissions);
                        return callback(null, group);
                    });
                });
            });
        });
    });
};

/**
 * Update a group
 *
 * @param  {Context}        ctx                             Standard context object containing the current user and the current tenant
 * @param  {String}         groupId                         The id of the group to update
 * @param  {Object}         profileFields                   Object where the keys represent the profile fields that need to be updated and the values represent the new values for those profile fields
 * @param  {String}         [profileFields.displayName]     Updated display name for the discussion
 * @param  {String}         [profileFields.description]     Updated description for the discussion
 * @param  {String}         [profileFields.visibility]      NUpdated visibility for the discussion. Should be one of `AuthzConstants.visibility`'s values
 * @param  {String}         [profileFields.joinable]        Updated joinability for the discussion. Should be one of `AuthzConstants.joinable`'s values
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occured, if any
 * @param  {Group}          callback.updatedGroup           The updated group
 */
var updateGroup = module.exports.updateGroup = function(ctx, groupId, profileFields, callback) {
     // Parameter validation
    var fieldNames = profileFields ? _.keys(profileFields) : [];
    var validator = new Validator();
    validator.check(groupId, {'code': 400, 'msg': 'A valid group id must be provided'}).isGroupId();
    validator.check(fieldNames.length, {'code': 400, 'msg': 'You should specify at least one field'}).min(1);
    fieldNames.forEach(function(fieldName) {
        validator.check(fieldName, {'code': 400, 'msg': fieldName + ' is not a recognized group profile field'}).isIn(['displayName', 'description', 'visibility', 'joinable']);
        if (fieldName === 'visibility') {
            validator.check(profileFields['visibility'], {'code': 400, 'msg': 'The visibility setting must be one of: ' + _.values(AuthzConstants.visibility)}).isValidVisibility();
        } else if (fieldName === 'joinable') {
            validator.check(profileFields['joinable'], {'code': 400, 'msg': 'The joinable setting must be one of: ' + _.values(AuthzConstants.joinable)}).isIn(_.values(AuthzConstants.joinable));
        } else if (fieldName === 'displayName') {
            validator.check(profileFields['displayName'], {'code': 400, 'msg': 'A display name cannot be empty'}).notEmpty();
            validator.check(profileFields['displayName'], {'code': 400, 'msg': 'A display name can be at most 1000 characters long'}).isShortString();
        } else if (fieldName === 'description' && profileFields['description']) {
            validator.check(profileFields['description'], {'code': 400, 'msg': 'A description can only be 10000 characters long'}).isMediumString();
        }
    });
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a group'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure the target group exists
    PrincipalsDAO.getPrincipal(groupId, function(err, oldStorageGroup) {
        if (err) {
            return callback(err);
        } else if (oldStorageGroup.deleted) {
            return callback({'code': 404, 'msg': util.format('Couldn\'t find principal: %s', groupId)});
        }

        // Check if we can update this group
        _canManage(ctx, oldStorageGroup.id, function(err, canManage) {
            if (err) {
                return callback(err);
            } else if (!canManage) {
                return callback({'code': 401, 'msg': 'Permission denied'});
            }

            profileFields = _.extend({}, profileFields, {'lastModified': Date.now().toString()});
            PrincipalsDAO.updatePrincipal(groupId, profileFields, function(err) {
                if (err) {
                    return callback(err);
                }

                // Keep track of the updated storage group model so we can emit it in the UPDATE_GROUP event
                var updatedStorageGroup = _.extend({}, oldStorageGroup, profileFields);

                // Get the user-facing updated group object to return to the user
                PrincipalsUtil.getPrincipal(ctx, groupId, function(err, updatedGroup) {
                    if (err) {
                        return callback(err);
                    }

                    // Asynchronously update all member library indexes so that the group appears
                    // higher due to it being more recently interacted with
                    _touchMembershipLibraries(updatedGroup, oldStorageGroup.lastModified, [], [], function(err) {
                        if (err) {
                            log().error({
                                'err': err,
                                'oldGroup': oldStorageGroup,
                                'newGroup': updatedStorageGroup,
                                'memberIds': memberIds
                            }, 'An error occurred while updating the library index for group members after group update');
                        }
                    });

                    // Emit the fact that we have updated this group
                    PrincipalsEmitter.emit(PrincipalsConstants.events.UPDATED_GROUP, ctx, updatedStorageGroup, oldStorageGroup);

                    // Return the full group profile for the caller
                    return getFullGroupProfile(ctx, groupId, callback);
                });
            });
        });
    });
};

/**
 * Delete a group
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     groupId         The id of the group to delete
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 */
var deleteGroup = module.exports.deleteGroup = function(ctx, groupId, callback) {
    var validator = new Validator();
    validator.check(groupId, {'code': 400, 'msg': 'A valid group id must be provided'}).isGroupId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the user has permission to delete the group
    canDeleteGroup(ctx, groupId, function(err, canDelete, group) {
        if (err) {
            return callback(err);
        } else if (!canDelete) {
            return callback({'code': 401, 'msg': 'You are not authorized to delete this group'});
        }

        // Mark the group as deleted
        PrincipalsDAO.deletePrincipal(groupId, function(err) {
            if (err) {
                return callback(err);
            }

            // Notify consumers that a group has been deleted
            return PrincipalsEmitter.emit(PrincipalsConstants.events.DELETED_GROUP, ctx, group, callback);
        });
    });
};

/**
 * Restore a group
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     groupId         The id of the group to restore
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 */
var restoreGroup = module.exports.restoreGroup = function(ctx, groupId, callback) {
    var validator = new Validator();
    validator.check(groupId, {'code': 400, 'msg': 'A valid group id must be provided'}).isGroupId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    canRestoreGroup(ctx, groupId, function(err, canRestore, group) {
        if (err) {
            return callback(err);
        } else if (!canRestore) {
            return callback({'code': 401, 'msg': 'You are not authorized to restore this group'});
        }

        // Unmark the group as deleted
        PrincipalsDAO.restorePrincipal(groupId, function(err) {
            if (err) {
                return callback(err);
            }

            // Notify consumers that a group has been restored
            return PrincipalsEmitter.emit(PrincipalsConstants.events.RESTORED_GROUP, ctx, group, callback);
        });
    });
};

/**
 * Determine whether or not the user in context can delete a given group
 *
 * @param  {Context}    ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}     groupId             The group to check
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.canDelete  Whether or not the user can delete the group
 * @param  {Group}      callback.group      The group object that was fetched from the database
 */
var canDeleteGroup = module.exports.canDeleteGroup = function(ctx, groupId, callback) {
    canManage(ctx, groupId, callback);
};

/**
 * Determine whether or not the user in context can restore a given group
 *
 * @param  {Context}    ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}     groupId                 The group to check
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Boolean}    callback.canRestore     Whether or not the user can restore the group
 * @param  {Group}      callback.group          The group object that was fetched from the database
 */
var canRestoreGroup = module.exports.canRestoreGroup = function(ctx, groupId, callback) {
    if (!ctx.user()) {
        return callback(null, false);
    }

    // Get the group so we can look at its tenant
    getGroup(ctx, groupId, function(err, group) {
        if (err) {
            return callback(err);
        } else if (!ctx.user().isAdmin(group.tenant.alias)) {
            // Only the global or tenant admin can restore a group
            return callback(null, false);
        }

        return callback(null, true, group);
    });
};

/**
 * Determine whether or not the user in the context can manage a given group.
 *
 * @param  {Context}    ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}     groupId             The group to check
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.canManage  Whether or not the user can manage the group
 * @param  {Group}      callback.group      The group object object that was fetched from the database
 */
var canManage = module.exports.canManage = function(ctx, groupId, callback) {
    var currentUserId = getUserId(ctx);

    // Anonymous users cannot manage a group
    if (!currentUserId) {
        return callback(null, false);
    }

    getGroup(ctx, groupId, function(err, group) {
        if (err) {
            return callback(err);
        }

        _canManage(ctx, groupId, function(err, canManage) {
            if (err) {
                return callback(err);
            }

            return callback(null, canManage, group);
        });
    });
};

/**
 * Determine whether or not the user in context is able to view the members of the given group.
 *
 * @param  {Context}   ctx                         Standard context object containing the current user and the current tenant
 * @param  {Group}     group                       The group to check
 * @param  {Function}  callback                    Standard callback function
 * @param  {Object}    callback.err                An error that occurred, if any
 * @param  {Boolean}   callback.canViewMembers     Whether or not the user in context can view the members of the given group
 */
var canViewMembers = module.exports.canViewMembers = function(ctx, group, callback) {
    if (ctx.user() && ctx.user().isAdmin(group.tenant.alias)) {
        // Tenant or global admins can always view the members.
        return callback(null, true);
    } else if (group.visibility === AuthzConstants.visibility.PUBLIC) {
        // Public groups are visible to everyone
        return callback(null, true);
    } else if (group.visibility === AuthzConstants.visibility.LOGGEDIN && TenantsUtil.isLoggedIn(ctx, group.tenant.alias)) {
        // If a group is only accessible by loggedin users, the user must be logged in to the group's tenant
        return callback(null, true);
    } else if (!ctx.user()) {
        // The group is private, anonymous users can never see it
        return callback(null, false);
    } else {
        // The group is private and the user is authenticated, check if the user is a member
        AuthzAPI.hasAnyRole(ctx.user().id, group.id, callback);
    }
};

/**
 * Check if the current user can manage any principal in a set of principals. This function
 * returns as soon as one principal that can be managed is found.
 *
 * @param  {Context}    ctx                         Standard context object containing the current user and the current tenant
 * @param  {String[]}   principalIds                The set of principal ids that should be checked
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error that occured, if any
 * @param  {Boolean}    callback.canManageAny       Whether or not the current user can manage any of the principals
 */
var canManageAny = module.exports.canManageAny = function(ctx, principalIds, callback) {
    // Anonymous users cannot manage anything
    if (!ctx.user()) {
        return callback(null, false);
    }

    // If the current user's own id is in the set of principals we can return early
    if (_.contains(principalIds, ctx.user().id)) {
        return callback(null, true);
    }

    // Tenant admins can only manage principals who belong to their tenant.
    // If there is one, that is sufficient
    var canAdminOne = _.chain(principalIds)
        .map(function(principalId) {
            return AuthzUtil.getResourceFromId(principalId).tenantAlias;
        })
        .find(ctx.user().isAdmin)
        .value();
    if (canAdminOne) {
        return callback(null, true);
    }

    // At this point we need to check if the current user can manage any of the groups
    var groupIds = _.filter(principalIds, AuthzUtil.isGroupId);
    return _canManageAnyGroups(ctx, groupIds, callback);
};

/**
 * Check if the current user can manage any groups in the provided list of groups.
 *
 * @param  {Context}    ctx                         Standard context object containing the current user and the current tenant
 * @param  {String[]}   groupIds                    The set of group ids that should be checked
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error that occured, if any
 * @param  {Boolean}    callback.canManageAny       Whether or not the current user can manage any of the groups
 * @api private
 */
var _canManageAnyGroups = function(ctx, groupIds, callback) {
    if (_.isEmpty(groupIds)) {
        return callback(null, false);
    }

    var groupId = groupIds.pop();
    _canManage(ctx, groupId, function(err, canManage) {
        if (err) {
            return callback(err);
        } else if (canManage) {
            return callback(null, true);
        }

        // Try the next group
        _canManageAnyGroups(ctx, groupIds, callback);
    });
};

/**
 * Internal function that checks whether or not the current user can manage a group. This function assumes that
 * the passed in groupId actually exists
 *
 * @param  {Context}     ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}      groupId             The id of the group to check
 * @param  {Function}    callback            Standard callback function
 * @param  {Object}      callback.err        An error that occurred, if any
 * @param  {Boolean}     callback.canManage  Whether or not the user can manage the group
 * @api private
 */
var _canManage = function(ctx, groupId, callback) {
    if (!ctx.user()) {
        return callback(null, false);
    }

    var tenantAlias = AuthzUtil.getResourceFromId(groupId).tenantAlias;
    if (ctx.user().isAdmin(tenantAlias)) {
        return callback(null, true);
    }

    AuthzAPI.hasRole(getUserId(ctx), groupId, PrincipalsConstants.roles.MANAGER, callback);
};

/**
 * Given an authz change on a group, update all the membership libraries that are involved
 *
 * @param  {Group}          group                   The group that was changed
 * @param  {Number}         [oldLastModified]       The timestamp when the group was previously changed. If this is left `null`, the group will not be moved to the top of the group membership libraries for the members of the group
 * @param  {String[]}       newMemberIds            The ids of the principals that were added to the group
 * @param  {String[]}       removedMemberIds        The ids of the principals that were removed from the group
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error object, if any
 * @api private
 */
var _touchMembershipLibraries = function(group, oldLastModified, newMemberIds, removedMemberIds, callback) {
    // Get the ancestors of this group. Since a user's membership library contains all indirect
    // group memberships, we need to insert/update/remove all indirect group ancestors
    _getAncestors(group, function(err, ancestorGroups) {
        if (err) {
            return callback(err);
        }

        // Create a set of groups that holds the group we changed and all its parents
        var changedGroup = _.extend({}, group, {'oldLastModified': oldLastModified});
        var groups = ancestorGroups.concat(changedGroup);

        // Insert the group (and its ancestors) into the membership libraries of the new members
        _insertMembershipsLibraries(groups, newMemberIds, function(err, explodedInsertedPrincipals) {
            if (err) {
                return callback(err);
            }

            // Remove the group (and its ancestors) from the membership libraries of the removed
            // principals
            _removeMembershipsLibraries(removedMemberIds, groups, function(err) {
                if (err) {
                    return callback(err);
                }

                // Update the membership libraries of all the other members of the changed group to
                // ensure it shows at the top of their membership library
                if (oldLastModified) {
                    return _updateMembershipsLibraries(changedGroup, explodedInsertedPrincipals, callback);
                } else {
                    return callback();
                }
            });
        });
    });
};

/**
 * Insert the given `groups` into the memberships libraries of `newMemberIds` AND
 * all the children of `newMemberIds`.
 *
 * @param  {Group}          groups                  The groups to insert into the membership libraries
 * @param  {String[]}       newMemberIds            The ids of the members that were added to the group
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {String[]}       callback.principals     The ids of the principals for which to update the membership libraries
 * @api private
 */
var _insertMembershipsLibraries = function(groups, newMemberIds, callback) {
    if (_.isEmpty(newMemberIds)) {
        return callback(null, []);
    }

    // Get all the children of the members we've added so we can insert the group
    // and its ancestors into their membership libraries
    _getAllChildren(newMemberIds, [], function(err, allChildren) {
        if (err) {
            return callback(err);
        }

        // The principals for which the groups will be inserted in their libraries
        var principalIds = allChildren.concat(newMemberIds);

        var entries = _.chain(groups)
            .map(function(group) {
                return _.map(principalIds, function(principalId) {
                    return {
                        'id': principalId,
                        'rank': group.lastModified,
                        'resource': group
                    };
                });
            })
            .flatten()
            .value();

        LibraryAPI.Index.insert(PrincipalsConstants.library.MEMBERSHIPS_INDEX_NAME, entries, function(err) {
            if (err) {
                return callback(err);
            }

            return callback(null, allChildren);
        });
    });
};

/**
 * Update the group entries in the memberships libraries of the given member ids
 *
 * @param  {Group}          group                   The group to update in the libraries
 * @param  {String[]}       excludePrincipals       The principal ids for which the membership libraries should not be updated
 * @param  {Function}       callback                Standard callback function
 * @api private
 */
var _updateMembershipsLibraries = function(group, excludePrincipals, callback) {
    // Get the exploded members list of the group we've updated excluding any
    // principals we've dealth with earlier
    _getAllChildren([group.id], excludePrincipals, function(err, allChildren) {
        if (err) {
            return callback(err);
        }

        // The principals for which the groups will be updated in their libraries
        var principalIdsToUpdate = allChildren.concat(group.id);
        var entries = _.map(principalIdsToUpdate, function(principalId) {
            return {
                'id': principalId,
                'oldRank': group.oldLastModified,
                'newRank': group.lastModified,
                'resource': group
            };
        });


        // Update all the groups in the libraries of the updated members (and their children)
        LibraryAPI.Index.update(PrincipalsConstants.library.MEMBERSHIPS_INDEX_NAME, entries, function(err) {
            if (err) {
                log().error({
                    'err': err,
                    'group': group
                }, 'Unable to update a group in a principal\'s membership library');
            }

            return callback();
        });
    });
};

/**
 * Remove the group entries from the memberships libraries of the given member ids
 *
 * @param  {String[]}   removedMemberIds    The ids of the members for which the groups need to be removed from their membership libraries
 * @param  {Group[]}    groups              The groups that should be removed from the `removedMemberIds` their membership libraries
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @api private
 */
var _removeMembershipsLibraries = function(removedMemberIds, groups, callback) {
    if (_.isEmpty(removedMemberIds)) {
        return callback();
    }

    _getAllChildren(removedMemberIds, [], function(err, allChildren) {
        if (err) {
            return callback(err);
        }

        // The principals for which to remove the groups from their libraries
        var principalIds = allChildren.concat(removedMemberIds);

        // Gather all index removal entries to persist
        var entries = _.chain(groups)
            .map(function(group) {
                return _.map(principalIds, function(principalId) {
                    return {
                        'id': principalId,
                        'rank': group.oldLastModified || group.lastModified,
                        'resource': group
                    };
                });
            })
            .flatten()
            .value();

        // Remove the groups from the libraries of the removed members (and their children)
        LibraryAPI.Index.remove(PrincipalsConstants.library.MEMBERSHIPS_INDEX_NAME, entries, function(err) {
            if (err) {
                log().error({
                    'err': err,
                    'memberIds': removedMemberIds,
                    'groupIds': _.pluck(groups, 'id')
                }, 'Unable to remove groups from a principal\'s membership library');
            }

            return callback();
        });
    });
};

/**
 * Get a group's ancestors
 *
 * @param  {Group}          group               The group to retrieve the ancestors for
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {Group[]}        callback.groups     The ancestor groups
 * @api private
 */
var _getAncestors = function(group, callback) {
    // Get all the ancestors of the group
    AuthzAPI.getPrincipalMembershipsGraph(group.id, function(err, graph) {
        if (err) {
            return callback(err);
        }

        // Extract the ids of all groups in the memberships list from the graph
        var membershipIds = _.chain(graph.getNodes()).pluck('id').without(group.id).value();

        // Get a light-weight group representation for each ancestor
        PrincipalsDAO.getPrincipals(membershipIds, ['principalId', 'tenantAlias', 'lastModified', 'visibility'], function(err, parentGroups) {
            if (err) {
                return callback(err);
            }

            parentGroups = _.values(parentGroups);
            return callback(null, parentGroups);
        });
    });
};

/**
 * Get all the children for a set of principals
 *
 * @param  {String[]}   principalIds        The ids of the principals to retrieve all children for
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error object, if any
 * @param  {String[]}   callback.children   The ids of the principals that are a direct or indirect member of any of the given principal ids. The passed in principal ids will be included in this result set
 * @api private
 */
var _getAllChildren = function(principalIds, excludePrincipals, callback, _groupsToInvalidate, _allChildren) {
    _allChildren = _allChildren || [];
    _groupsToInvalidate = _groupsToInvalidate || _.filter(principalIds, AuthzUtil.isGroupId);

    // If there are no groups left to explode, we can remove the group from all the affected
    // member libraries
    if (_.isEmpty(_groupsToInvalidate)) {
        return callback(null, _allChildren);
    }

    // Get the next group to explode
    var groupId = _groupsToInvalidate.shift();

    // Get all of the members of the group, so they can be invalidated
    AuthzAPI.getAuthzMembers(groupId, null, 10000, function(err, members) {
        if (err) {
            return callback(err);
        }

        _.each(members, function(member) {
            // Groups need to be further exploded. In order to do this, we need to check whether or not the list
            // of groups that have already been invalidated and the list of groups that are queued up to be invalidated
            // don't contain this group, otherwise we'll invalidate the group twice.
            if (AuthzUtil.isGroupId(member.id) && !_.contains(_allChildren, member.id) && !_.contains(_groupsToInvalidate, member.id) && !_.contains(excludePrincipals, member.id)) {
                _groupsToInvalidate.push(member.id);
            }

            // The members can be invalidated
            if (!_.contains(_allChildren, member.id) && !_.contains(excludePrincipals, member.id)) {
                _allChildren.push(member.id);
            }
        });

        _getAllChildren(principalIds, excludePrincipals, callback, _groupsToInvalidate, _allChildren);
    });
};

/**
 * Get the current user id from the context, if any
 *
 * @param  {Context} ctx     Standard context object containing the current user and the current tenant
 * @return {String}          The id of the user in the context. Returns `null` if there is no active user (i.e., anonymous)
 * @api private
 */
var getUserId = function(ctx) {
    var user = ctx.user();
    return user ? user.id : null;
};

