/*
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');
var fs = require('fs');
var gm = require('gm');
var path = require('path');
var querystring = require('querystring');
var url = require('url');

var LocalStorage = require('oae-content/lib/backends/local');
var RestAPI = require('oae-rest');
var RestUtil = require('oae-rest/lib/util');
var SearchTestsUtil = require('oae-search/lib/test/util');
var TestsUtil = require('oae-tests');

var PrincipalsConstants = require('oae-principals/lib/constants').PrincipalsConstants;
var PrincipalsTestUtil = require('oae-principals/lib/test/util');
var PrincipalsUtil = require('oae-principals/lib/util');


describe('Profile pictures', function() {

    // Rest context that can be used every time we need to make a request as a global admin
    var globalAdminRestContext = null;
    // Rest context that can be used every time we need to make a request as a Cambridge tenant admin
    var camAdminRestContext = null;
    // Rest context that can be used every time we need to make an anonymous request to the Cambridge tenant
    var anonymousRestContext = null;
    // The directory where files will be stored during the tests
    var rootFilesDir = null;

    before(function(callback) {
        // Fill up the global admin rest context
        globalAdminRestContext = TestsUtil.createGlobalAdminRestContext();
        // Fill up tenant admin rest context
        camAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.cam.host);
        // Fill up anonymous rest context
        anonymousRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host);
        // Get the root files directory
        rootFilesDir = LocalStorage.getRootDirectory();
        RestAPI.User.getMe(camAdminRestContext, function(err, user) {
            assert.ok(!err);
            return callback();
        });
    });

    /**
     * Create a user and return a RestContext for it
     *
     * @param  {Function}       callback        Standard callback function
     * @param  {RestContext}    callback.ctx    The RestContext for the created user
     * @api private
     */
    var _createUser = function(callback) {
        TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users) {
            assert.ok(!err);
            var user = _.values(users)[0];
            var ctx = user.restContext;
            ctx.user = user.user;
            return callback(ctx);
        });
    };

    /**
     * Create 2 users
     *
     * @param  {Function}   callback            Standard callback function
     * @param  {Object}     callback.contexts   The RestContexts for the created users keyed by 'simon' and 'nicolaas'
     * @api private
     */
    var _createUsers = function(callback) {
        TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users) {
            assert.ok(!err);
            var contexts = {};
            users = _.values(users);
            contexts['simon'] = users[0];
            contexts['nicolaas'] = users[1];
            return callback(contexts);
        });
    };

    /**
     * @return {Stream} A stream to jpg image
     * @api private
     */
    var _getPictureStream = function() {
        var file = __dirname + '/data/restroom.jpg';
        return fs.createReadStream(file);
    };

    /**
     * @return {Stream} A stream to text file
     * @api private
     */
    var _getTextStream = function() {
        var file = __dirname + '/data/speech.txt';
        return fs.createReadStream(file);
    };

    /**
     * Returns an object that can be used to crop out a rectangle
     * @api private
     */
    var _createSelectedArea = function(x, y, width) {
        return {
            'x': x,
            'y': y,
            'width': width
        };
    };

    /**
     * Given a picture URL, parse the backend URI from the query string
     * @api private
     */
    var _getUriFromDownloadUrl = function(downloadUrl) {
        return querystring.parse(url.parse(downloadUrl).query).uri;
    };

    /**
     * Verifies the size of an image
     *
     * @param  {String}     uri         URI to the image we want to verify the size of
     * @param  {Number}     width       Expected width of the image
     * @param  {Number}     height      Expected height of the image
     * @param  {Function}   callback    Standard callback function
     * @api private
     */
    var _verifySize = function(uri, width, height, callback) {
        // Strip 'local:' from the uri.
        var uriPath = rootFilesDir + '/' + uri.substr(6);

        // #564 - Ensure the filename contains the extension.
        assert.strictEqual(path.extname(uriPath), '.jpg');

        gm(uriPath).size(function(err, size) {
            assert.ok(!err);
            assert.equal(size.width, width);
            assert.equal(size.height, height);
            return callback();
        });
    };

    /**
     * Attempts to crop a picture, if it's expected to succeed the resulting file and the updated
     * principal object will be checked
     *
     * @param  {RestContext}        restCtx             Standard REST Context object that contains the current tenant URL and the current user credentials
     * @param  {User|Group}         principal           User or group object representing the principal for which we're trying to crop the profile picture
     * @param  {Object}             selectedArea        The topleft coordinates and size of the square that should be cropped out
     * @param  {Number}             selectedArea.x      The top left x coordinate
     * @param  {Number}             selectedArea.y      The top left y coordinate
     * @param  {Number}             selectedArea.width  The width of the square
     * @param  {Number}             expectedHttpCode    The expected response code for the cropping request
     * @param  {Function}           callback            Standard callback function
     * @api private
     */
    var _verifyCropping = function(restCtx, principal, selectedArea, expectedHttpCode, callback) {
        RestAPI.Crop.cropPicture(restCtx, principal.id, selectedArea, function(err, data) {
            if (expectedHttpCode === 200) {
                assert.ok(!err);
            } else {
                // It was expected that this request would fail
                assert.equal(err.code, expectedHttpCode);
                return callback();
            }

            // When the request was OK, we verify if the cropping actually happened
            _verifySize(_getUriFromDownloadUrl(data.picture.small), PrincipalsConstants.picture.size.SMALL, PrincipalsConstants.picture.size.SMALL, function() {
                _verifySize(_getUriFromDownloadUrl(data.picture.medium), PrincipalsConstants.picture.size.MEDIUM, PrincipalsConstants.picture.size.MEDIUM, function() {
                    // Make sure the returned profile object has the expected properties
                    assert.equal(data.id, principal.id);
                    assert.equal(data.displayName, principal.displayName);
                    assert.equal(data.description, principal.description);
                    assert.equal(data.profilePath, principal.profilePath);
                    assert.equal(data.resourceType, principal.resourceType);
                    assert.equal(data.tenant.displayName, principal.tenant.displayName);
                    assert.equal(data.visibility, principal.visibility);
                    assert.ok(data.picture);

                    if (PrincipalsUtil.isGroup(principal.id)) {
                        assert.equal(data.alias, principal.alias);
                        assert.equal(data.joinable, principal.joinable);
                        assert.ok(!data.locale);
                        assert.ok(!data.publicAlias);
                        assert.strictEqual(data.isManager, true);
                        assert.strictEqual(data.isMember, true);
                        assert.strictEqual(data.canJoin, false);
                    } else {
                        assert.equal(data.publicAlias, principal.publicAlias);
                        assert.ok(data.locale);
                        assert.ok(!data.alias);
                    }

                    return callback();
                });
            });
        });
    };

    /**
     * Test that verifies that a picture can be uploaded
     */
    it('verify uploading', function(callback) {
        _createUser(function(ctx) {
            // Verify uploading a picture for a user
            RestAPI.User.uploadPicture(ctx, ctx.user.id, _getPictureStream, null, function(err) {
                assert.ok(!err);

                // Verify it for a group
                TestsUtil.generateTestGroups(ctx, 1, function(err, groups) {
                    assert.ok(!err);
                    var groupId = _.keys(groups)[0];
                    RestAPI.User.uploadPicture(ctx, groupId, _getPictureStream, null, function(err) {
                        assert.ok(!err);
                        callback();
                    });
                });
            });
        });
    });

    /**
     * Test that verifies basic required parameters
     */
    it('verify basic parameter requirements', function(callback) {
        _createUser(function(ctx) {
            RestAPI.User.uploadPicture(ctx, ctx.user.id, null, null, function(err) {
                assert.equal(err.code, 400);
                callback();
            });
        });
    });

    /**
     * Test that verifies that the picture upload endpoint only accepts pictures
     */
    it('verify uploading bad mimetype', function(callback) {
        _createUser(function(ctx) {
            RestAPI.User.uploadPicture(ctx, ctx.user.id, _getTextStream, null, function(err) {
                assert.equal(err.code, 400);
                callback();
            });
        });
    });

    /**
     * Test that verifies that pictures larger than 10 MB are rejected
     */
    it('verify a picture cannot be more than 10 MB', function(callback) {
        _createUser(function(ctx) {
            RestAPI.User.uploadPicture(ctx, ctx.user.id, TestsUtil.createFileReadableStream('pic.png', 10 * 1024 * 1024 + 1), null, function(err) {
                assert.equal(err.code, 400);
                callback();
            });
        });
    });

    /**
     * Test that verifies cropping
     */
    it('verify cropping', function(callback) {
        _createUser(function(ctx) {
            RestAPI.User.uploadPicture(ctx, ctx.user.id, _getPictureStream, null, function(err) {
                assert.ok(!err);
                var selectedArea = _createSelectedArea(10, 10, 200);
                _verifyCropping(ctx, ctx.user, selectedArea, 200, callback);
            });
        });
    });

    /**
     * Test that verifies that an appropriate response is sent when you haven't uploaded a picture yet
     */
    it('verify cropping fails if the user hasn\'t uploaded a picture yet', function(callback) {
        _createUser(function(ctx) {
            _verifyCropping(ctx, ctx.user, _createSelectedArea(10, 10, 200), 400, callback);
        });
    });

    /**
     * Test that verifies that you can crop and upload an image with 1 REST API call
     */
    it('verify uploading and cropping', function(callback) {
        _createUser(function(ctx) {
            var selectedArea = _createSelectedArea(10, 10, 200);
            RestAPI.User.uploadPicture(ctx, ctx.user.id, _getPictureStream, selectedArea, function(err) {
                assert.ok(!err);
                callback();
            });
        });
    });

    /**
     * Test that verifies that the area selection cannot be negative
     */
    it('verify cropping validation negative coordinates', function(callback) {
        _createUser(function(ctx) {
            RestAPI.User.uploadPicture(ctx, ctx.user.id, _getPictureStream, null, function(err) {
                assert.ok(!err);
                _verifyCropping(ctx, ctx.user, _createSelectedArea(-10, 10, 200), 400, function() {
                    _verifyCropping(ctx, ctx.user, _createSelectedArea(10, -10, 200), 400, function() {
                        _verifyCropping(ctx, ctx.user, _createSelectedArea(-10, -10, 200), 400, function() {
                            _verifyCropping(ctx, ctx.user, _createSelectedArea(10, 10, -200), 400, callback);
                        });
                    });
                });
            });
        });
    });

    /**
     * Test that verifies that the area selection does type validation
     */
    it('verify cropping validation area only takes numbers', function(callback) {
        _createUser(function(ctx) {
            RestAPI.User.uploadPicture(ctx, ctx.user.id, _getPictureStream, null, function(err) {
                assert.ok(!err);
                _verifyCropping(ctx, ctx.user, _createSelectedArea('foo', 10, 200), 400, function() {
                    _verifyCropping(ctx, ctx.user, _createSelectedArea(10, 'foo', 200), 400, function() {
                        _verifyCropping(ctx, ctx.user, _createSelectedArea(10, 10, 'foo'), 400, function() {
                            _verifyCropping(ctx, ctx.user, _createSelectedArea(10, 10, NaN), 400, callback);
                        });
                    });
                });
            });
        });
    });

    /**
     * Test that verifies that the cropped rectangle should be completely within the image boundaries
     */
    it('verify cropping cannot happen partially outside of the image', function(callback) {
        _createUser(function(ctx) {
            RestAPI.User.uploadPicture(ctx, ctx.user.id, _getPictureStream, null, function(err) {
                assert.ok(!err);
                _verifyCropping(ctx, ctx.user, _createSelectedArea(10, 10, 20000), 400, callback);
            });
        });
    });

    /**
     * Test that verifies that you cannot crop outside the image
     */
    it('verify cropping fails if x or y coord is outside of image', function(callback) {
        _createUser(function(ctx) {
            RestAPI.User.uploadPicture(ctx, ctx.user.id, _getPictureStream, null, function(err) {
                assert.ok(!err);
                _verifyCropping(ctx, ctx.user, _createSelectedArea(20000, 10, 100), 400, function() {
                    _verifyCropping(ctx, ctx.user, _createSelectedArea(10, 200000, 100), 400, callback);
                });
            });
        });
    });

    /**
     * Test that verifies that you can download a user picture
     */
    it('verify downloading user picture', function(callback) {
        _createUsers(function(contexts) {
            var selectedArea = _createSelectedArea(10, 10, 200, 200);
            RestAPI.User.uploadPicture(contexts['simon'].restContext, contexts['simon'].user.id, _getPictureStream, selectedArea, function(err) {
                assert.ok(!err);

                // Download the different sizes
                RestAPI.User.downloadPicture(contexts['simon'].restContext, contexts['simon'].user.id, 'small', function(err, body, response) {
                    assert.ok(!err);
                    assert.equal(response.statusCode, 204);
                    RestAPI.User.downloadPicture(contexts['simon'].restContext, contexts['simon'].user.id, 'medium', function(err, body, response) {
                        assert.ok(!err);
                        assert.equal(response.statusCode, 204);
                        RestAPI.User.downloadPicture(contexts['simon'].restContext, contexts['simon'].user.id, 'large', function(err, body, response) {
                            assert.ok(!err);
                            assert.equal(response.statusCode, 204);

                            // Now try downloading it with some invalid parameters
                            RestAPI.User.downloadPicture(contexts['simon'].restContext, 'invalid-user-id', 'small', function(err, body, response) {
                                assert.equal(err.code, 400);
                                RestAPI.User.downloadPicture(contexts['simon'].restContext, contexts['simon'].user.id, null, function(err, body, response) {
                                    assert.equal(err.code, 400);

                                    // Nicolaas has no picture, this should result in a 404
                                    RestAPI.User.downloadPicture(contexts['simon'].restContext, contexts['nicolaas'].user.id, 'small', function(err, body, response) {
                                        assert.equal(err.code, 404);
                                        callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    /**
     * Test that verifies that you can download a group picture
     */
    it('verify downloading group picture', function(callback) {
        _createUser(function(ctx) {
            TestsUtil.generateTestGroups(ctx, 2, function(err, groups) {
                var selectedArea = _createSelectedArea(10, 10, 200, 200);

                var groupA = _.keys(groups)[0];
                var groupB = _.keys(groups)[1];
                RestAPI.Group.uploadPicture(ctx, groupA, _getPictureStream, selectedArea, function(err) {
                    assert.ok(!err);

                    // Download the different sizes
                    RestAPI.Group.downloadPicture(ctx, groupA, 'small', function(err, body, response) {
                        assert.ok(!err);
                        assert.equal(response.statusCode, 204);
                        RestAPI.Group.downloadPicture(ctx, groupA, 'medium', function(err, body, response) {
                            assert.ok(!err);
                            assert.equal(response.statusCode, 204);
                            RestAPI.Group.downloadPicture(ctx, groupA, 'large', function(err, body, response) {
                                assert.ok(!err);
                                assert.equal(response.statusCode, 204);

                                // Now try downloading it with some invalid parameters
                                RestAPI.Group.downloadPicture(ctx, 'invalid-group-id', 'small', function(err, body, response) {
                                    assert.equal(err.code, 400);
                                    RestAPI.Group.downloadPicture(ctx, groupA, null, function(err, body, response) {
                                        assert.equal(err.code, 400);

                                        // The other group has no picture, this should result in a 404
                                        RestAPI.Group.downloadPicture(ctx, groupB, 'small', function(err, body, response) {
                                            assert.equal(err.code, 404);
                                            callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    /**
     * Test that verifies that you can upload/crop/download profile pictures for groups.
     */
    it('verify uploading, cropping and downloading of group profile pictures', function(callback) {
        _createUser(function(ctx) {
            TestsUtil.generateTestGroups(ctx, 1, function(err, groups) {
                var group = groups[Object.keys(groups)[0]];
                RestAPI.Group.uploadPicture(ctx, group.id, _getPictureStream, null, function(err) {
                    assert.ok(!err);
                    _verifyCropping(ctx, group, _createSelectedArea(-10, 10, 200), 400, function() {
                        _verifyCropping(ctx, group, _createSelectedArea(10, -10, 200), 400, function() {
                            _verifyCropping(ctx, group, _createSelectedArea(-10, -10, 200), 400, function() {
                                _verifyCropping(ctx, group, _createSelectedArea(10, 10, 200), 200, function() {
                                    // Download the different sizes.
                                    RestAPI.Group.downloadPicture(ctx, group.id, 'small', function(err, body, request) {
                                        assert.ok(!err);
                                        assert.equal(request.statusCode, 204);
                                        RestAPI.Group.downloadPicture(ctx, group.id, 'medium', function(err, body, request) {
                                            assert.ok(!err);
                                            assert.equal(request.statusCode, 204);
                                            RestAPI.Group.downloadPicture(ctx, group.id, 'large', function(err, body, request) {
                                                assert.ok(!err);
                                                assert.equal(request.statusCode, 204);
                                                callback();
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    /**
     * Test that verifies that the endpoints don't expose profile pictures if the user has set his visibility to private/loggedin.
     */
    it('verify visibility of cropped profile pictures', function(callback) {
        _createUsers(function(contexts) {
            var selectedArea = _createSelectedArea(10, 10, 200, 200);
            RestAPI.User.uploadPicture(contexts['simon'].restContext, contexts['simon'].user.id, _getPictureStream, selectedArea, function(err) {
                assert.ok(!err);

                RestAPI.User.updateUser(contexts['simon'].restContext, contexts['simon'].user.id, {'visibility': 'private'}, function(err) {
                    assert.ok(!err);

                    RestAPI.User.getUser(contexts['nicolaas'].restContext, contexts['simon'].user.id, function(err, user) {
                        assert.ok(!err);
                        assert.equal(user.picture.small, undefined);
                        assert.equal(user.picture.smallUri, undefined);
                        assert.equal(user.picture.medium, undefined);
                        assert.equal(user.picture.mediumUri, undefined);
                        assert.equal(user.picture.large, undefined);
                        assert.equal(user.picture.largeUri, undefined);

                        RestAPI.User.getUser(anonymousRestContext, contexts['simon'].user.id, function(err, user) {
                            assert.ok(!err);
                            assert.equal(user.picture.small, undefined);
                            assert.equal(user.picture.smallUri, undefined);
                            assert.equal(user.picture.medium, undefined);
                            assert.equal(user.picture.mediumUri, undefined);
                            assert.equal(user.picture.large, undefined);
                            assert.equal(user.picture.largeUri, undefined);

                            RestAPI.User.updateUser(contexts['simon'].restContext, contexts['simon'].user.id, {'visibility': 'loggedin'}, function(err) {
                                assert.ok(!err);

                                RestAPI.User.getUser(contexts['nicolaas'].restContext, contexts['simon'].user.id, function(err, user) {
                                    assert.ok(!err);
                                    assert.ok(user.picture.small);
                                    assert.ok(!user.picture.smallUri);
                                    assert.ok(user.picture.medium);
                                    assert.ok(!user.picture.mediumUri);
                                    assert.ok(user.picture.large);
                                    assert.ok(!user.picture.largeUri);

                                    // The user who owns the pictures can see everything
                                    RestAPI.User.getUser(contexts['simon'].restContext, contexts['simon'].user.id, function(err, user) {
                                        assert.ok(!err);
                                        assert.ok(user.picture.small);
                                        assert.ok(!user.picture.smallUri);
                                        assert.ok(user.picture.medium);
                                        assert.ok(!user.picture.mediumUri);
                                        assert.ok(user.picture.large);
                                        assert.ok(!user.picture.largeUri);
                                        callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    /**
     * Test that verifies that you cannot set/crop a picture for someone else.
     */
    it('verify uploading or cropping a picture for another user is not allowed', function(callback) {
        _createUsers(function(contexts) {
            RestAPI.User.uploadPicture(contexts['simon'].restContext, contexts['nicolaas'].user.id, _getPictureStream, null, function(err) {
                assert.equal(err.code, 401);
                _verifyCropping(contexts['simon'].restContext, contexts['nicolaas'].user, _createSelectedArea(10, 10, 200), 401, callback);
            });
        });
    });

    /**
     * Test that verifies that you cannot set a picture for a group you have no management rights on.
     */
    it('verify uploading or cropping a picture for a non-managed group is not allowed', function(callback) {
        _createUsers(function(contexts) {
            TestsUtil.generateTestGroups(contexts['simon'].restContext, 1, function(err, groups) {
                var group = groups[Object.keys(groups)[0]];
                RestAPI.Group.uploadPicture(contexts['nicolaas'].restContext, group.id, _getPictureStream, null, function(err) {
                    assert.equal(err.code, 401);
                    _verifyCropping(contexts['nicolaas'].restContext, group, _createSelectedArea(10, 10, 200), 401, function() {
                        // Making Nico a member should still not allow him to change the picture.
                        var members = {};
                        members[contexts['nicolaas'].user.id] = 'member';
                        RestAPI.Group.setGroupMembers(contexts['simon'].restContext, group.id, members, function(err) {
                            assert.ok(!err);
                            RestAPI.Group.uploadPicture(contexts['nicolaas'].restContext, group.id, _getPictureStream, null, function(err) {
                                assert.equal(err.code, 401);
                                _verifyCropping(contexts['nicolaas'].restContext, group, _createSelectedArea(10, 10, 200), 401, function() {

                                    // Making him a manager should.
                                    members[contexts['nicolaas'].user.id] = 'manager';
                                    RestAPI.Group.setGroupMembers(contexts['simon'].restContext, group.id, members, function(err) {
                                        assert.ok(!err);
                                        RestAPI.Group.uploadPicture(contexts['nicolaas'].restContext, group.id, _getPictureStream, null, function(err) {
                                            assert.ok(!err);
                                            _verifyCropping(contexts['nicolaas'].restContext, group, _createSelectedArea(10, 10, 200), 200, callback);
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    /**
     * Test that verifies that the urls we generate for profile pictures are cacheable.
     */
    it('verify profile pictures are cacheable', function(callback) {
        _createUser(function(ctx) {
            var selectedArea = _createSelectedArea(10, 10, 200, 200);
            RestAPI.User.uploadPicture(ctx, ctx.user.id, _getPictureStream, selectedArea, function(err) {
                assert.ok(!err);

                // Get my data twice, the url's for the pictures shouldn't change as that would mean they aren't cacheable
                RestAPI.User.getUser(ctx, ctx.user.id, function(err, firstRequestUser) {
                    assert.ok(!err);
                    RestAPI.User.getUser(ctx, ctx.user.id, function(err, secondRequestUser) {
                        assert.ok(!err);
                        assert.equal(firstRequestUser.smallPicture, secondRequestUser.smallPicture);
                        assert.equal(firstRequestUser.mediumPicture, secondRequestUser.mediumPicture);
                        assert.equal(firstRequestUser.largePicture, secondRequestUser.largePicture);
                        return callback();
                    });
                });
            });
        });
    });

    /**
     * Test that verifies that when you upload a new picture, the old profile pictures does NOT get removed.
     */
    it('verify that old pictures are not removed when uploading a new large picture', function(callback) {
        _createUser(function(ctx) {
            var selectedArea = _createSelectedArea(10, 10, 200, 200);
            RestAPI.User.uploadPicture(ctx, ctx.user.id, _getPictureStream, selectedArea, function(err) {
                assert.ok(!err);

                // Get the user metadata and thus the picture url.
                RestAPI.User.getUser(ctx, ctx.user.id, function(err, firstRequestUser) {
                    assert.ok(!err);

                    // Upload a new picture.
                    RestAPI.User.uploadPicture(ctx, ctx.user.id, _getPictureStream, null, function(err) {
                        assert.ok(!err);

                        // Get the new user metadata.
                        RestAPI.User.getUser(ctx, ctx.user.id, function(err, secondRequestUser) {
                            assert.ok(!err);

                            // Get the URIs and check that they are not removed on the filesystem
                            var smallPicturePath = rootFilesDir + '/' + _getUriFromDownloadUrl(firstRequestUser.picture.small).split(':')[1];
                            var mediumPicturePath = rootFilesDir + '/' + _getUriFromDownloadUrl(firstRequestUser.picture.medium).split(':')[1];
                            assert.equal(fs.existsSync(smallPicturePath), true, 'The small picture should still exist when uploading a large image');
                            assert.equal(fs.existsSync(mediumPicturePath), true, 'The medium picture should still exist when uploading a large image');
                            return callback();
                        });
                    });
                });
            });
        });
    });

    /**
     * Test that verifies the principals in upload and crop responses contain the signed picture URLs and not
     * the back-end URIs
     */
    it('verify that uploading and cropping responds with the expected principal model and no back-end picture URIs', function(callback) {
        // Create a user to which we can upload a profile picture
        TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, mrvisser) {
            assert.ok(!err);

            // Upload the profile picture and crop it for the user
            PrincipalsTestUtil.uploadAndCropPicture(mrvisser.restContext, mrvisser.user.id, _getPictureStream, {'x': 10, 'y': 10, 'width': 200}, function(uploadPrincipal, cropPrincipal) {

                // Ensure the user model of the "upload large picture" response
                assert.equal(uploadPrincipal.tenant.alias, mrvisser.user.tenant.alias);
                assert.equal(uploadPrincipal.tenant.displayName, mrvisser.user.tenant.displayName);
                assert.equal(uploadPrincipal.id, mrvisser.user.id);
                assert.equal(uploadPrincipal.displayName, mrvisser.user.displayName);
                assert.equal(uploadPrincipal.visibility, mrvisser.user.visibility);
                assert.equal(uploadPrincipal.email, mrvisser.user.email);
                assert.equal(uploadPrincipal.locale, mrvisser.user.locale);
                assert.equal(uploadPrincipal.timezone, mrvisser.user.timezone);
                assert.equal(uploadPrincipal.publicAlias, mrvisser.user.publicAlias);
                assert.equal(uploadPrincipal.profilePath, mrvisser.user.profilePath);
                assert.equal(uploadPrincipal.resourceType, mrvisser.user.resourceType);
                assert.equal(uploadPrincipal.acceptedTC, mrvisser.user.acceptedTC);
                assert.ok(uploadPrincipal.lastModified);
                assert.ok(!uploadPrincipal.picture.largeUri);
                assert.ok(uploadPrincipal.picture.large);
                assert.ok(!uploadPrincipal.picture.mediumUri);
                assert.ok(!uploadPrincipal.picture.medium);
                assert.ok(!uploadPrincipal.picture.smallUri);
                assert.ok(!uploadPrincipal.picture.small);

                // Ensure the user model of the "crop picture" response
                assert.equal(cropPrincipal.tenant.alias, mrvisser.user.tenant.alias);
                assert.equal(cropPrincipal.tenant.displayName, mrvisser.user.tenant.displayName);
                assert.equal(cropPrincipal.id, mrvisser.user.id);
                assert.equal(cropPrincipal.displayName, mrvisser.user.displayName);
                assert.equal(cropPrincipal.visibility, mrvisser.user.visibility);
                assert.equal(cropPrincipal.email, mrvisser.user.email);
                assert.equal(cropPrincipal.locale, mrvisser.user.locale);
                assert.equal(cropPrincipal.timezone, mrvisser.user.timezone);
                assert.equal(cropPrincipal.publicAlias, mrvisser.user.publicAlias);
                assert.equal(cropPrincipal.profilePath, mrvisser.user.profilePath);
                assert.equal(cropPrincipal.resourceType, mrvisser.user.resourceType);
                assert.equal(cropPrincipal.acceptedTC, mrvisser.user.acceptedTC);
                assert.ok(cropPrincipal.lastModified);
                assert.ok(!cropPrincipal.picture.largeUri);
                assert.ok(cropPrincipal.picture.large);
                assert.ok(!cropPrincipal.picture.mediumUri);
                assert.ok(cropPrincipal.picture.medium);
                assert.ok(!cropPrincipal.picture.smallUri);
                assert.ok(cropPrincipal.picture.small);

                // Create a group to which we can upload a profile picture
                TestsUtil.generateTestGroups(mrvisser.restContext, 1, function(err, groups, group) {
                    assert.ok(!err);

                    // Upload the profile picture and crop it for the group
                    PrincipalsTestUtil.uploadAndCropPicture(mrvisser.restContext, group.id, _getPictureStream, {'x': 10, 'y': 10, 'width': 200}, function(uploadPrincipal, cropPrincipal) {

                        // Ensure the group model of the "upload large picture" response
                        assert.equal(uploadPrincipal.tenant.alias, group.tenant.alias);
                        assert.equal(uploadPrincipal.tenant.displayName, group.tenant.displayName);
                        assert.equal(uploadPrincipal.id, group.id);
                        assert.equal(uploadPrincipal.displayName, group.displayName);
                        assert.equal(uploadPrincipal.visibility, group.visibility);
                        assert.equal(uploadPrincipal.joinable, group.joinable);
                        assert.equal(uploadPrincipal.description, group.description);
                        assert.equal(uploadPrincipal.profilePath, group.profilePath);
                        assert.equal(uploadPrincipal.resourceType, group.resourceType);
                        assert.ok(uploadPrincipal.lastModified);
                        assert.ok(!uploadPrincipal.picture.largeUri);
                        assert.ok(uploadPrincipal.picture.large);
                        assert.ok(!uploadPrincipal.picture.mediumUri);
                        assert.ok(!uploadPrincipal.picture.medium);
                        assert.ok(!uploadPrincipal.picture.smallUri);
                        assert.ok(!uploadPrincipal.picture.small);

                        // Ensure the group model of the "crop picture" response
                        assert.equal(cropPrincipal.tenant.alias, group.tenant.alias);
                        assert.equal(cropPrincipal.tenant.displayName, group.tenant.displayName);
                        assert.equal(cropPrincipal.id, group.id);
                        assert.equal(cropPrincipal.displayName, group.displayName);
                        assert.equal(cropPrincipal.visibility, group.visibility);
                        assert.equal(cropPrincipal.joinable, group.joinable);
                        assert.equal(cropPrincipal.description, group.description);
                        assert.equal(cropPrincipal.profilePath, group.profilePath);
                        assert.equal(cropPrincipal.resourceType, group.resourceType);
                        assert.ok(cropPrincipal.lastModified);
                        assert.strictEqual(cropPrincipal.isMember, true);
                        assert.strictEqual(cropPrincipal.isManager, true);
                        assert.strictEqual(cropPrincipal.canJoin, false);
                        assert.ok(!cropPrincipal.picture.largeUri);
                        assert.ok(cropPrincipal.picture.large);
                        assert.ok(!cropPrincipal.picture.mediumUri);
                        assert.ok(cropPrincipal.picture.medium);
                        assert.ok(!cropPrincipal.picture.smallUri);
                        assert.ok(cropPrincipal.picture.small);

                        return callback();
                    });
                });
            });
        });
    });

    /**
     * This test searches through all the members of a group and checks if the current user can see the profile pictures of them.
     * It assumes that the group has 3 members, each with a different user visibility setting
     *
     * @param  {RestContext}    restContext         The context to search with
     * @param  {String}         groupId             The ID of the group
     * @param  {Boolean}        canPublic           Whether or not the user in the passed in `restContext` should be able to see the profile picture of the public user
     * @param  {Boolean}        canLoggedIn         Whether or not the user in the passed in `restContext` should be able to see the profile picture of the loggedin user
     * @param  {Boolean}        canPrivate          Whether or not the user in the passed in `restContext` should be able to see the profile picture of the private user
     * @param  {String}         publicUserId        The ID of the user who has a visibility set to public
     * @param  {String}         loggedinUserId      The ID of the user who has a visibility set to public
     * @param  {String}         privateUserId       The ID of the user who has a visibility set to private
     * @param  {Function}       callback            Standard callback function
     * @api private
     */
    var _verifySearchThumbnails = function(restContext, groupId, canPublic, canLoggedIn, canPrivate, publicUserId, loggedinUserId, privateUserId, callback) {
        SearchTestsUtil.searchAll(restContext, 'members', [groupId], null, function(err, results) {
            assert.ok(!err);
            assert.equal(results.total, 3);
            var users = {};
            for (var i = 0; i < results.results.length; i++) {
                users[results.results[i].id] = results.results[i];
            }

            assert.equal(users[publicUserId].hasOwnProperty('thumbnailUrl'), canPublic);
            assert.equal(users[loggedinUserId].hasOwnProperty('thumbnailUrl'), canLoggedIn);
            assert.equal(users[privateUserId].hasOwnProperty('thumbnailUrl'), canPrivate);
            callback();
        });
    };

    /**
     * Test that verifies that the thumbnail property in search results respects the user visibility
     */
    it('verify the user thumbnail visibility in member search results', function(callback) {
        // Setup the user/group structure.
        TestsUtil.generateTestUsers(camAdminRestContext, 4, function(err, users) {
            assert.ok(!err);

            var publicUser = _.values(users)[0];
            var loggedInUser = _.values(users)[1];
            var privateUser = _.values(users)[2];
            var nonMemberUser = _.values(users)[3];

            RestAPI.User.updateUser(loggedInUser.restContext, loggedInUser.user.id, { 'visibility': 'loggedin' }, function(err) {
                assert.ok(!err);

                RestAPI.User.updateUser(privateUser.restContext, privateUser.user.id, { 'visibility': 'private' }, function(err) {
                    assert.ok(!err);

                    // Each user has a profile picture
                    var selectedArea = _createSelectedArea(10, 10, 200, 200);
                    RestAPI.User.uploadPicture(publicUser.restContext, publicUser.user.id, _getPictureStream, selectedArea, function(err) {
                        assert.ok(!err);

                        RestAPI.User.uploadPicture(loggedInUser.restContext, loggedInUser.user.id, _getPictureStream, selectedArea, function(err) {
                            assert.ok(!err);

                            RestAPI.User.uploadPicture(privateUser.restContext, privateUser.user.id, _getPictureStream, selectedArea, function(err) {
                                assert.ok(!err);

                                // Create a group with the two other members
                                var groupName = TestsUtil.generateTestUserId('someGroupName');
                                RestAPI.Group.createGroup(privateUser.restContext, groupName, groupName, 'public', 'no', [], [loggedInUser.user.id, publicUser.user.id], function(err, group) {
                                    assert.ok(!err);

                                    // Perform one search where we wait for the search index to refresh so all subsequent search requests don't have to wait
                                    SearchTestsUtil.searchAll(anonymousRestContext, 'members', [group.id], null, function(err, results) {
                                        assert.ok(!err);

                                        // Anonymous can search the group membership list but can only see the public user his picture.
                                        _verifySearchThumbnails(anonymousRestContext, group.id, true, false, false, publicUser.user.id, loggedInUser.user.id, privateUser.user.id, function() {

                                            // A logged in user can see the public and 'logged in' user.
                                            _verifySearchThumbnails(nonMemberUser.restContext, group.id, true, true, false, publicUser.user.id, loggedInUser.user.id, privateUser.user.id, function() {

                                                // The public member can only see his own thumbnail and the loggedin user.
                                                _verifySearchThumbnails(publicUser.restContext, group.id, true, true, false, publicUser.user.id, loggedInUser.user.id, privateUser.user.id, function() {

                                                    // The 'logged in' user can see his own thumbnail and the public one.
                                                    _verifySearchThumbnails(loggedInUser.restContext, group.id, true, true, false, publicUser.user.id, loggedInUser.user.id, privateUser.user.id, function() {

                                                        // The private user can see everyone's thumbnail.
                                                        _verifySearchThumbnails(privateUser.restContext, group.id, true, true, true, publicUser.user.id, loggedInUser.user.id, privateUser.user.id, callback);
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    /**
     * Test that verifies that the thumbnail property in search results respects the group visibility
     */
    it('verify the thumbnail is present in group search results', function(callback) {
        // Setup the user/group structure.
        TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users) {
            assert.ok(!err);

            var simon = _.values(users)[0];

            // Create some groups.
            TestsUtil.generateTestGroups(simon.restContext, 4, function(err, groups) {
                assert.ok(!err);

                var oaeTeam = _.values(groups)[0];
                var backendTeam = _.values(groups)[1];
                var uiTeam = _.values(groups)[2];
                var qaTeam = _.values(groups)[3];

                // Upload pictures for the sub teams
                var selectedArea = _createSelectedArea(10, 10, 200, 200);
                RestAPI.User.uploadPicture(simon.restContext, backendTeam.id, _getPictureStream, selectedArea, function(err) {
                    assert.ok(!err);

                    RestAPI.User.uploadPicture(simon.restContext, uiTeam.id, _getPictureStream, selectedArea, function(err) {
                        assert.ok(!err);

                        RestAPI.User.uploadPicture(simon.restContext, qaTeam.id, _getPictureStream, selectedArea, function(err) {
                            assert.ok(!err);

                            // Make the uiTeam loggedin.
                            RestAPI.Group.updateGroup(simon.restContext, uiTeam.id, { 'visibility': 'loggedin'}, function(err) {
                                assert.ok(!err);

                                // Make the qa team private.
                                RestAPI.Group.updateGroup(simon.restContext, qaTeam.id, { 'visibility': 'private'}, function(err) {
                                    assert.ok(!err);

                                    // Make the backend, ui and qa teams member of oae team.
                                    var changes = {};
                                    changes[backendTeam.id] = 'member';
                                    changes[uiTeam.id] = 'member';
                                    changes[qaTeam.id] = 'member';
                                    RestAPI.Group.setGroupMembers(simon.restContext, oaeTeam.id, changes, function(err) {
                                        assert.ok(!err);

                                        // Search trough the memberlist of oaeTeam and filter the results so we only get the backend team group back.
                                        SearchTestsUtil.searchAll(simon.restContext, 'members', [oaeTeam.id], { 'q': '' }, function(err, results) {
                                            assert.ok(!err);
                                            assert.equal(results.total, 4);

                                            // We only need the groups
                                            results.results = _.filter(results.results, function(result) { return result.resourceType !== 'user'; });

                                            // All the groups should expose their thumbnail regardless of their visibility setting.
                                            assert.ok(results.results[0].thumbnailUrl);
                                            assert.ok(results.results[1].thumbnailUrl);
                                            assert.ok(results.results[2].thumbnailUrl);

                                            // Try downloading it by just using the returned url.
                                            RestUtil.RestRequest(simon.restContext, results.results[0].thumbnailUrl, 'GET', null, function(err, body, response) {
                                                assert.ok(!err);
                                                // Downloading happens via nginx, so we can't verify the response body.
                                                // We can verify if the status code is a 204 and if the appropriate headers are present.
                                                assert.equal(response.statusCode, 204);
                                                assert.ok(response.headers['x-accel-redirect']);
                                                assert.ok(response.headers['content-disposition']);
                                                callback();
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });
});
