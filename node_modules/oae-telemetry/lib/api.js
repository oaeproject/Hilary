/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var config = null;

// Will hold all the counts.
var stats = {
    'counts': {},
    'histograms': {}
};

/**
 * Make the current telemetry configuration available to the telemetry API.
 * 
 * @param  {Object}     _config     Config object containing config values for telemetry
 */
var setTelemetryConfig = module.exports.setTelemetryConfig = function(_config) {
    config = _config;
};

/**
 * Publishers can use this method to get to the raw data.
 *
 * @return {Object}     The captured telemetry data.
 */
var getTelemetryData = module.exports.getTelemetryData = function() {
    return stats;
};

/**
 * Resets all telemetry data.
 * 
 * @param  {String}     module      The name of the module for which the telemtry should be reset
 */
var reset = module.exports.reset = function(module) {
    if (module) {
        delete stats.counts[module];
        delete stats.histograms[module];
    }
};

/**
 * Allows other modules to perform telemetry tasks.
 * ex: 
 *
 *     var Telemetry = require('oae-telemetry').telemetry('cassandra');
 *         Telemetry.incr('write');
 *
 * @param  {String} module The module.
 */
module.exports.telemetry = function(module) {
    return new Telemetry(module);
};

/**
 * The Telemetry object.
 * 
 * @param  {String} module A module to namespace counts in.
 * @api private
 */
var Telemetry = function(module) {
    // Set the counters/histograms if they are empty.
    stats.counts[module] = stats.counts[module] || {};
    stats.histograms[module] = stats.histograms[module] || {};

    // Expose some functionality.
    var that = {};

    /**
     * Increment the count for this Telemetry item.
     * If no count is present it will be set to 1.
     */
    that.incr = function(name) {
        if (!stats.counts[module][name]) {
            stats.counts[module][name] = 0;
        }
        stats.counts[module][name]++;
    };

    /**
     * Adds a value that is suitable for histogram parsing.
     *
     * @param  {String}  name    The name to append a value on.
     * @param  {Number}  value   The value that should be added.
     */
    that.append = function(name, value) {
        if (!stats.histograms[module][name]) {
            stats.histograms[module][name] = [];
        }
        stats.histograms[module][name].push(value);
    };

    /**
     * Given that the request matches one of the registered URI's,
     * it will perform the following tasks:
     *
     *  * increase the amount of requests for that URI by 1.
     *  * increase the amount of requests for that method by 1.
     *  * measure the time it took for a response to be generated.
     *
     * @param  {Request}    req     The request.
     * @param  {Response}   res     The response
     */
    that.request = function(req, res) {
        if (config.enabled) {
            // Increase the amount of `method` requests.
            that.incr(req.method);

            // Do some time measuring.
            var start = Date.now();
            res.on('header', function(header){
                var duration = Date.now() - start;
                // Increase the amount of requests against this API.
                that.incr(req.method + '.' + req.telemetryUrl + '.count');

                // Measure the response time
                that.append(req.method + '.' +  req.telemetryUrl + '.time', duration);
            });
        }
    };

    return that;
};
