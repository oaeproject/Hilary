/*
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');
var ShortId = require('shortid');
var util = require('util');

var ActivityTestUtil = require('oae-activity/lib/test/util');
var RestAPI = require('oae-rest');
var SearchTestsUtil = require('oae-search/lib/test/util');
var TestsUtil = require('oae-tests');

var Etherpad = require('oae-content/lib/internal/etherpad');

describe('Collaborative documents', function() {

    // Rest context that can be used every time we need to make a request as an anonymous user
    var anonymousRestContext = null;
    // Rest context that can be used every time we need to make a request as a tenant admin
    var camAdminRestContext = null;

    var multipleServers = {
        'apikey': '13SirapH8t3kxUh5T5aqWXhXahMzoZRA',
        'hosts': [
            {
                'host': '127.0.0.1',
                'internalPort': 9001
            },
            {
                'host': '127.0.0.2',
                'internalPort': 9001
            }
        ]
    };

    // Once the server has started up, get the etherpad configuration and store it in this variable
    // as some tests change the configuration.
    var testConfig = null;

    /**
     * Function that will fill up the anonymous and tenant admin REST context
     */
    before(function(callback) {
        // Fill up anonymous rest context
        anonymousRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host);
        // Fill up tenant admin rest contexts
        camAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.cam.host);
        // Get the original test config.
        testConfig = Etherpad.getConfig();
        callback();
    });

    /**
     * Test that verifies the request parameters get validated when joining a collaborative document
     */
    it('verify basic parameter validation when joining a collaborative document', function(callback) {
        TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users) {
            assert.ok(!err);
            var ctx = _.values(users)[0].restContext;

            // Check that we can only join a collaborative document
            RestAPI.Content.createLink(ctx, 'Test Content', 'Test description', 'public', 'http://www.oaeproject.org/', [], [], function(err, link) {
                assert.ok(!err);

                RestAPI.Content.joinCollabDoc(ctx, link.id, function(err) {
                    assert.equal(err.code, 400);

                    RestAPI.Content.createCollabDoc(ctx, 'Test doc', 'description', 'private', [], [], function(err, contentObj) {
                        assert.ok(!err);

                        RestAPI.Content.joinCollabDoc(ctx, ' ', function(err) {
                            assert.equal(err.code, 400);

                            RestAPI.Content.joinCollabDoc(ctx, 'invalid-id', function(err) {
                                assert.equal(err.code, 400);

                                // Sanity check
                                RestAPI.Content.joinCollabDoc(ctx, contentObj.id, function(err, data) {
                                    assert.ok(!err);
                                    assert.ok(data);
                                    callback();
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    /**
     * Test that verifies the request parameters get validated when publishing a collaborative document
     */
    it('verify basic parameter validation when publishing a collaborative document', function(callback) {
        TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users) {
            assert.ok(!err);
            var ctx = _.values(users)[0].restContext;

            // Check that we can only publish a collaborative document
            RestAPI.Content.createLink(ctx, 'Test Content', 'Test description', 'public', 'http://www.oaeproject.org/', [], [], function(err, link) {
                assert.ok(!err);

                RestAPI.Content.publishCollabDoc(ctx, link.id, function(err) {
                    assert.equal(err.code, 400);

                    RestAPI.Content.createCollabDoc(ctx, 'Test doc', 'description', 'private', [], [], function(err, contentObj) {
                        assert.ok(!err);

                        RestAPI.Content.publishCollabDoc(ctx, ' ', function(err) {
                            assert.equal(err.code, 400);

                            RestAPI.Content.publishCollabDoc(ctx, 'invalid-id', function(err) {
                                assert.equal(err.code, 400);

                                // Sanity check
                                RestAPI.Content.publishCollabDoc(ctx, contentObj.id, function(err, data) {
                                    assert.ok(!err);
                                    assert.ok(data);
                                    callback();
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    /**
     * Verifies that the load is balanced based on the content ID.
     */
    it('verify different servers get selected depending on the content ID', function() {
        // Configure Etherpad with 2 servers, rather than the default 1.
        Etherpad.refreshConfiguration(multipleServers);

        var hostA = Etherpad.getPadUrl('c:cam:abc123', 'foo', 'bar');
        var hostB = Etherpad.getPadUrl('c:cam:abc1231', 'foo', 'bar');
        assert.notEqual(hostA, hostB);

        var total = 10000;
        var counts = {};
        for (var i = 0; i < total; i++) {
            var id = util.format('c:cam:%s', ShortId.generate());
            var url = Etherpad.getPadUrl(id, 'foo', 'bar');
            if (!counts[url]) {
                counts[url] = 0;
            }
            counts[url]++;
        }

        // There should only be 2 different base URLs.
        var urls = _.keys(counts);
        assert.strictEqual(urls.length, 2);

        // The URLs should be evenly spread (allow for a maximum 5% deviation)
        var devA = counts[urls[0]] / (total / 2);
        var devB = counts[urls[1]] / (total / 2);
        assert.ok(devA > 0.95, 'Expected a maximum deviation of 5%, deviation was: ' + Math.round((1 - devA) * 100) + '%');
        assert.ok(devB > 0.95, 'Expected a maximum deviation of 5%, deviation was: ' + Math.round((1 - devB) * 100) + '%');

        // Re-configure Etherpad with the defaults.
        Etherpad.refreshConfiguration(testConfig);
    });

    /**
     * Verifies that you can only join a collaborative document if you have manager permissions
     */
    it('verify joining a pad respects the content permissions', function(callback) {
        TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users) {
            assert.ok(!err);
            var simonCtx = _.values(users)[0].restContext;
            var brandenCtx = _.values(users)[1].restContext;

            // Simon creates a collaborative document that's private.
            var name = TestsUtil.generateTestUserId();
            RestAPI.Content.createCollabDoc(simonCtx, name, 'description', 'private', [], [], function(err, contentObj) {
                assert.ok(!err);

                RestAPI.Content.joinCollabDoc(simonCtx, contentObj.id, function(err, data) {
                    assert.ok(!err);
                    assert.ok(data);

                    // Branden has no access yet, so joining should result in a 401
                    RestAPI.Content.joinCollabDoc(brandenCtx, contentObj.id, function(err, data) {
                        assert.equal(err.code, 401);
                        assert.ok(!data);

                        // Share it with branden, viewers still can't edit(=join) though
                        var members = {};
                        members[_.keys(users)[1]] = 'viewer';
                        RestAPI.Content.updateMembers(simonCtx, contentObj.id, members, function(err) {
                            assert.ok(!err);

                            // Branden can see the document, but he cannot join in and start editing it
                            RestAPI.Content.joinCollabDoc(brandenCtx, contentObj.id, function(err, data) {
                                assert.equal(err.code, 401);
                                assert.ok(!data);

                                // Now that we make Branden a manager, he should be able to join
                                members[_.keys(users)[1]] = 'manager';
                                RestAPI.Content.updateMembers(simonCtx, contentObj.id, members, function(err) {
                                    assert.ok(!err);

                                    // Branden should now be able to access it
                                    RestAPI.Content.joinCollabDoc(brandenCtx, contentObj.id, function(err, data) {
                                        assert.ok(!err);
                                        assert.ok(data);
                                        callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    /**
     * Verifies that you can only publish a collaborative document if you have manager permissions
     */
    it('verify publishing a pad respects the content permissions', function(callback) {
        TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users) {
            assert.ok(!err);
            var simonCtx = _.values(users)[0].restContext;
            var brandenCtx = _.values(users)[1].restContext;

            // Simon creates a collaborative document that's private.
            var name = TestsUtil.generateTestUserId();
            RestAPI.Content.createCollabDoc(simonCtx, name, 'description', 'private', [], [], function(err, contentObj) {
                assert.ok(!err);

                var text = 'yadda yadda yadda';
                editAndPublish(simonCtx, contentObj, [text], function() {

                    // Branden has no access yet, so this should be a 401
                    RestAPI.Content.publishCollabDoc(brandenCtx, contentObj.id, function(err, data) {
                        assert.equal(err.code, 401);
                        assert.ok(!data);

                        // Make Branden a viewer.
                        // He should still not be able to publish it.
                        var members = {};
                        members[_.keys(users)[1]] = 'viewer';
                        RestAPI.Content.updateMembers(simonCtx, contentObj.id, members, function(err) {
                            assert.ok(!err);

                            // Branden can't publish this document yet.
                            RestAPI.Content.publishCollabDoc(brandenCtx, contentObj.id, function(err, data) {
                                assert.equal(err.code, 401);
                                assert.ok(!data);

                                // Now make him a manager
                                members[_.keys(users)[1]] = 'manager';
                                RestAPI.Content.updateMembers(simonCtx, contentObj.id, members, function(err) {
                                    assert.ok(!err);

                                    // Branden should now be able to access it.
                                    text = 'Lilalilalila';
                                    editAndPublish(brandenCtx, contentObj, [text], function() {

                                        // By now we should have 3 revisions (not 4, as Branden's first publish was unauthorized)
                                        RestAPI.Content.getRevisions(simonCtx, contentObj.id, null, null, function(err, revisions) {
                                            assert.ok(!err);
                                            assert.equal(revisions.results.length, 3);
                                            callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    /**
     * Set some text in Etherpad.
     *
     * @param  {Content}    contentObj      The content object for which we should update the etherpad text.
     * @param  {String}     text            The text to place in the pad.
     * @param  {Function}   callback        Standard callback method.
     * @param  {Object}     callback.err    Error object, if any.
     */
    var setEtherpadText = function(contentObj, text, callback) {
        var etherpadClient = Etherpad.getClient(contentObj.id);
        var args = {
            'padID': contentObj.etherpadPadId,
            'text': text
        };
        etherpadClient.setText(args, callback);
    };

    /**
     * Get the text that is stored in Etherpad.
     *
     * @param  {Content}    contentObj          The content object for which we should retrieve the etherpad text.
     * @param  {Function}   callback            Standard callback method.
     * @param  {Object}     callback.err        Error object, if any.
     * @param  {Object}     callback.data       Standard Etherpad API response object.
     * @param  {String}     callback.data.text  The actual string of text that is stored in the pad.
     */
    var getEtherpadText = function(contentObj, callback) {
        var etherpadClient = Etherpad.getClient(contentObj.id);
        var args = {
            'padID': contentObj.etherpadPadId
        };
        etherpadClient.getText(args, callback);
    };

    /**
     * Changes the text in the etherpad pad and publishes the document.
     * The amount of edit/publish cycles depends on how many strings there are in the `texts` array.
     * Each string will be placed in the pad and result in a document publish.
     *
     * @param  {Context}    context     The request context to use for publishing the document.
     * @param  {Content}    contentObj  The content object to publish
     * @param  {String[]}   texts       An array of texts that should be placed in the pad. The document will be published for each string in this array.
     * @param  {Function}   callback    Standard callback method.
     */
    var editAndPublish = function(context, contentObj, texts, callback) {
        var done = 0;

        var doEditAndPublish = function() {
            if (done === texts.length) {
                return callback();
            }

            // Do some edits in etherpad.
            setEtherpadText(contentObj, texts[done], function(err) {
                assert.ok(!err);

                RestAPI.Content.publishCollabDoc(context, contentObj.id, function(err, data) {
                    assert.ok(!err);
                    assert.ok(data);
                    done++;
                    doEditAndPublish();
                });
            });
        };
        doEditAndPublish();
    };

    /**
     * Get a piece of content and its latest revision object.
     *
     * @param  {RestContext}    context             The restcontext that should be used to retrieve the content and revision.
     * @param  {String}         contentId           The ID of the piece of content that should be retrieved.
     * @param  {Function}       callback            Standard callback method.
     * @param  {Content}        callback.content    The content object.
     * @param  {Content}        callback.revision   The revision object.
     */
    var getContentWithLatestRevision = function(context, contentId, callback) {
        RestAPI.Content.getContent(context, contentId, function(err, contentObj) {
            assert.ok(!err);

            RestAPI.Content.getRevision(context, contentId, contentObj.latestRevisionId, function(err, revision) {
                assert.ok(!err);
                callback(contentObj, revision);
            });
        });
    };

    /**
     * This test verifies that the latest HTML is retrieved when publishing a collaborative document
     * It does this by creating a pad, submitting some text in etherpad, publishing the document, retrieving the new content object
     * from our API and verifying the new text is there.
     * It also performs some more etherpad edits and verifies these do not get streamed to our API.
     */
    it('verify the correct HTML is retrieved when publishing', function(callback) {
        TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users) {
            assert.ok(!err);
            var simonCtx = _.values(users)[0].restContext;

            // Simon creates a collaborative document that's private.
            var name = TestsUtil.generateTestUserId();
            RestAPI.Content.createCollabDoc(simonCtx, name, 'description', 'private', [], [], function(err, contentObj) {
                assert.ok(!err);

                // Verify there is no HTML present yet.
                getContentWithLatestRevision(simonCtx, contentObj.id, function(contentObj, revision) {
                    assert.ok(!contentObj.latestRevision.etherpadHtml);
                    assert.ok(!revision.etherpadHtml);

                    // Do some edits in etherpad.
                    var text = 'Only two things are infinite, the universe and human stupidity, and I am not sure about the former.';
                    editAndPublish(simonCtx, contentObj, [text], function() {

                        getContentWithLatestRevision(simonCtx, contentObj.id, function(updatedContentObj, updatedRevision) {
                            assert.ok(updatedContentObj.latestRevision.etherpadHtml);
                            assert.ok(updatedRevision.etherpadHtml);
                            assert.notEqual(updatedContentObj.latestRevision.etherpadHtml, revision.etherpadHtml);
                            assert.notEqual(updatedRevision.etherpadHtml, revision.etherpadHtml);

                            // Remove linebreaks and check if the text is correct.
                            var html = updatedRevision.etherpadHtml.replace('<br>', '');
                            assert.equal(html, text);

                            // If we make any further updates in etherpad they shouldn't show up yet from our API.
                            setEtherpadText(contentObj, 'There are no facts, only interpretations.', function(err) {
                                assert.ok(!err);

                                getContentWithLatestRevision(simonCtx, contentObj.id, function(latestContentObj, latestRevision) {
                                    assert.ok(latestContentObj.latestRevision.etherpadHtml);
                                    assert.ok(latestRevision.etherpadHtml);
                                    assert.equal(latestContentObj.latestRevision.etherpadHtml, updatedContentObj.latestRevision.etherpadHtml);
                                    assert.equal(latestRevision.etherpadHtml, updatedRevision.etherpadHtml);
                                    callback();
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    /**
     * Verifies that documents that are published, can be searched on.
     */
    it('verify that published collaborative documents are searchable', function(callback) {
        TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users) {
            assert.ok(!err);
            var simonCtx = _.values(users)[0].restContext;

            // Simon creates a collaborative document that's private.
            var name = TestsUtil.generateTestUserId('collabdoc');
            RestAPI.Content.createCollabDoc(simonCtx, name, 'description', 'private', [], [], function(err, contentObj) {
                assert.ok(!err);

                // Do some edits in etherpad.
                editAndPublish(simonCtx, contentObj, ['Most modern calendars mar the sweet simplicity of our lives by reminding us that each day that passes is the anniversary of some perfectly uninteresting event.'], function() {
                    SearchTestsUtil.searchAll(simonCtx, 'general', null, {'q': 'each day that passes is the anniversary of some perfectly uninteresting event', 'resourceTypes': 'content'}, function(err, data) {
                        assert.ok(!err);
                        assert.equal(data.results.length, 1);
                        assert.equal(data.results[0].id, contentObj.id);
                        callback();
                    });
                });
            });
        });
    });

    /**
     * Verifies that published documents can be restored.
     */
    it('verify that published collaborative documents are restorable', function(callback) {
        TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users) {
            assert.ok(!err);
            var simonCtx = _.values(users)[0].restContext;

            var name = TestsUtil.generateTestUserId('collabdoc');
            RestAPI.Content.createCollabDoc(simonCtx, name, 'description', 'private', [], [], function(err, contentObj) {
                assert.ok(!err);

                var texts = [
                    'Always do sober what you said you\'d do drunk. That will teach you to keep your mouth shut.',
                    'Bill Gates is a very rich man today... and do you want to know why? The answer is one word: versions.',
                    'I don\'t have to play by these rules or do these things... I can actually have my own kind of version.'
                ];
                editAndPublish(simonCtx, contentObj, texts, function() {
                    RestAPI.Content.getRevisions(simonCtx, contentObj.id, null, null, function(err, revisions) {
                        assert.ok(!err);

                        // We published our document 3 times, this should result in 4 revisions. (1 create + 3 publications)
                        assert.equal(revisions.results.length, 4);

                        // Restore the second revision.
                        // The html on the content item and in etherpad should be updated.
                        RestAPI.Content.restoreRevision(simonCtx, contentObj.id, revisions.results[1].revisionId, function(err) {
                            assert.ok(!err);

                            getContentWithLatestRevision(simonCtx, contentObj.id, function(updatedContent, updatedRevision) {
                                // Make sure the revisions feed doesn't have etherpadHtml in it
                                assert.ok(!revisions.results[1].etherpadHtml);
                                // Fetch the individual revision so we can verify the etherpadHtml is correct
                                RestAPI.Content.getRevision(simonCtx, revisions.results[1].contentId, revisions.results[1].revisionId, function(err, fullRev) {
                                    assert.equal(updatedContent.latestRevision.etherpadHtml, fullRev.etherpadHtml);
                                    assert.equal(updatedRevision.etherpadHtml, fullRev.etherpadHtml);

                                    getEtherpadText(contentObj, function(err, data) {
                                        assert.ok(!err);
                                        assert.equal(data.text, texts[1] + '\n');
                                        callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    /**
     * Verifies that restoring collaborative documents is access scoped
     */
    it('verify that restoring collaborative documents is access scoped', function(callback) {
        TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users) {
            assert.ok(!err);
            var simonCtx = _.values(users)[0].restContext;
            var brandenCtx = _.values(users)[1].restContext;

            var name = TestsUtil.generateTestUserId('collabdoc');
            RestAPI.Content.createCollabDoc(simonCtx, name, 'description', 'public', [], [], function(err, contentObj) {
                assert.ok(!err);

                var texts = ['Any sufficiently advanced technology is indistinguishable from magic.'];
                editAndPublish(simonCtx, contentObj, texts, function() {
                    RestAPI.Content.getRevisions(simonCtx, contentObj.id, null, null, function(err, revisions) {
                        assert.ok(!err);
                        assert.equal(revisions.results.length, 2);

                        // Branden is no manager, so he cannot restore anything.
                        RestAPI.Content.restoreRevision(brandenCtx, contentObj.id, revisions.results[0].revisionId, function(err) {
                            assert.equal(err.code, 401);

                            // Sanity check
                            RestAPI.Content.getRevisions(simonCtx, contentObj.id, null, null, function(err, revisions) {
                                assert.ok(!err);
                                assert.equal(revisions.results.length, 2);
                                callback();
                            });
                        });
                    });
                });
            });
        });
    });

    /**
     * Verifies that publishing an unchanged document does not generate a new activity
     */
    it('verify that publishing an unchanged document does not generate a new activity', function(callback) {
        TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users) {
            assert.ok(!err);
            var simonCtx = _.values(users)[0].restContext;

            var name = TestsUtil.generateTestUserId('collabdoc');
            RestAPI.Content.createCollabDoc(simonCtx, name, 'description', 'public', [], [], function(err, contentObj) {
                assert.ok(!err);

                // Publishing now should have no effect.
                RestAPI.Content.publishCollabDoc(simonCtx, contentObj.id, function(err, data) {
                    assert.ok(!err);

                    // Get the activity stream, there should only be one activity in there (content-create).
                    ActivityTestUtil.collectAndGetActivityStream(simonCtx, null, null, function(err, data) {
                        assert.ok(!err);
                        assert.equal(data.items.length, 1);
                        assert.equal(data.items[0]['oae:activityType'], 'content-create');

                        var texts = ['Any sufficiently advanced technology is indistinguishable from magic.'];
                        editAndPublish(simonCtx, contentObj, texts, function() {

                            // Publish again, but with no change
                            RestAPI.Content.publishCollabDoc(simonCtx, contentObj.id, function(err, data) {
                                assert.ok(!err);

                                // Get the activity stream, there should only be one revision update event in there.
                                ActivityTestUtil.collectAndGetActivityStream(simonCtx, null, null, function(err, data) {
                                    assert.ok(!err);
                                    var contentRevisionActivtivies = _.filter(data.items, function(activity) { return activity['oae:activityType'] === 'content-revision'; });
                                    assert.equal(contentRevisionActivtivies.length, 1);
                                    callback();
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    /**
     * Verifies that etherpad related properties such as `etherpadGroupId`, `etherpadPadId`, .. cannot be set.
     */
    it('verify that etherpad related properties cannot be set on the content object', function(callback) {
        TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users) {
            assert.ok(!err);
            var simonCtx = _.values(users)[0].restContext;

            var name = TestsUtil.generateTestUserId('collabdoc');
            RestAPI.Content.createCollabDoc(simonCtx, name, 'description', 'public', [], [], function(err, contentObj) {
                assert.ok(!err);

                // Try updating any of the etherpad properties.
                RestAPI.Content.updateContent(simonCtx, contentObj.id, {'etherpadGroupId': 'bleh'}, function(err) {
                    assert.equal(err.code, 400);
                    RestAPI.Content.updateContent(simonCtx, contentObj.id, {'etherpadPadId': 'bleh'}, function(err) {
                        assert.equal(err.code, 400);
                        // Update a regular property
                        RestAPI.Content.updateContent(simonCtx, contentObj.id, {'displayName': 'bleh'}, function(err, updatedContentObj) {
                            assert.ok(!err);
                            assert.ok(!updatedContentObj.downloadPath);

                            // Double-check the the content item didn't change.
                            RestAPI.Content.getContent(simonCtx, contentObj.id, function(err, latestContentObj) {
                                assert.ok(!err);
                                assert.equal(contentObj.etherpadGroupId, latestContentObj.etherpadGroupId);
                                assert.equal(contentObj.etherpadPadId, latestContentObj.etherpadPadId);
                                callback();
                            });
                        });
                    });
                });
            });
        });
    });
});
