/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var fs = require('fs');
var gm = require('gm');
var Path = require('path');

var ImageUtil = require('oae-util/lib/image');
var IO = require('oae-util/lib/io');
var log = require('oae-logger').logger('oae-preview-processor');

var PreviewConstants = require('oae-preview-processor/lib/constants');


/**
 * @borrows Interface.test as Images.test
 */
var test = module.exports.test = function(ctx, contentObj, callback) {
    if (contentObj.resourceSubType === 'file' && PreviewConstants.TYPES.IMAGE.indexOf(contentObj.mime) !== -1) {
        callback(null, 10);
    } else {
        callback(null, -1);
    }
};

/**
 * @borrows Interface.generatePreviews as Images.generatePreviews
 */
var generatePreviews = module.exports.generatePreviews = function(ctx, contentObj, callback) {
    // Download the file.
    ctx.download(function(err, path) {
        if (err) {
            return callback(err);
        }

        // Although all the utilities we rely on, can fix the EXIF orientation,
        // It's a real pain to figure out what the width/height would be at each point
        // in time. That's why we fix up the source image before we start doing anything else.
        var fixedPath = ctx.baseDir + '/fixed.png';
        gm(path).autoOrient().write(fixedPath, function(err) {
            if (err) {
                return callback({'code': 500, 'msg': 'Could not auto orient based on EXIF data.'});
            }

            // Generate different sizes.
            var sizes = [
                { 'width': PreviewConstants.SIZES.IMAGE.LARGE, 'height': PreviewConstants.SIZES.IMAGE.LARGE, 'size': 'large' },
                { 'width': PreviewConstants.SIZES.IMAGE.MEDIUM, 'height': PreviewConstants.SIZES.IMAGE.MEDIUM, 'size': 'medium' },
                { 'width': PreviewConstants.SIZES.IMAGE.SMALL, 'height': PreviewConstants.SIZES.IMAGE.SMALL, 'size': 'small' }
            ];
            resizeImages(ctx, fixedPath, sizes, function(err) {
                if (err) {
                    return callback(err);
                }

                // Intelligently crop out a part of the image.
                cropThumbnail(ctx, fixedPath, 'CENTER', callback);
            });
        });
    });
};

/**
 * Resizes an image to one or multiple different sizes.
 *
 * @param {PreviewContext}      ctx             The preview context associated to this file.
 * @param {String}              path            The path where the image can be found on disk.
 * @param {Object[]}            sizes           An array of size object. Each object should have a `width`, `height` and `size` key, the `prefix` key is optional.
 * @param {Function}            callback        Standard callback method.
 * @param {Object}              callback.err    Standard error object (if any.)
 */
var resizeImages = module.exports.resizeImages = function(ctx, path, sizes, callback) {
    var todo = sizes.length;
    var called = false;

    // Get the source size first, so we don't accidentally upscale an image that is smaller than the target size.
    gm(path).size(function(err, sourceSize) {
        if (err) {
            called = true;
            log().error({'err': err, 'path': path, 'contentId': ctx.content.id}, 'Could not retrieve the size for this image.');
            return callback({'code': 500, 'msg': err.message});
        }

        sizes.forEach(function(size) {
            var ratio = (sourceSize.height / size.height);
            // If both sides are smaller we don't have to do anything.
            if (size.width > sourceSize.width && size.height > sourceSize.height) {
                ratio = 1;

            // If only the width is larger, we scale it down width-wise
            } else if (sourceSize.width > size.width && sourceSize.height < size.height) {
                ratio = (sourceSize.width / size.width);

            // If only the height is larger, we scale it down height-wise
            } else if (sourceSize.width < size.width && sourceSize.height > size.height) {
                ratio = (sourceSize.height / size.height);
            }

            // Scale the size
            size.width = Math.floor(sourceSize.width / ratio);
            size.height = Math.floor(sourceSize.height / ratio);

            // Perform the actual resize.
            _resize(ctx, path, size, function(err) {
                todo--;
                if (err) {
                    if (!called) {
                        called = true;
                        return callback(err);
                    }
                }

                if (todo === 0 && !called) {
                    called = true;
                    callback();
                }
            });
        });
    });
};

/**
 * Resizes an image to the specified size.
 * The image will be stored at basedir/previews/filename.<size name>.png
 * The filename will be a concatenation of `size.prefix`, `size.size` and `.png`
 *
 * @param {PreviewContext}      ctx             The preview context associated to this file.
 * @param {String}              path            The path where the image can be found on disk.
 * @param {Object}              size            A size object
 * @param {Number}              size.width      The width in pixels.
 * @param {Number}              size.height     The height in pixels.
 * @param {String}              size.size       The size of the desired image. One of 'small', 'medium' or 'large'.
 * @param {String}              [size.prefix]   The prefix that should be used in the filename. The end filename will look like <prefix><size>.png . If no prefix is specified, an empty string will be used.
 * @param {Function}            callback        Standard callback method.
 * @param {Object}              callback.err    Standard error object (if any.)
 * @api private
 */
var _resize = function(ctx, path, size, callback) {
    log().trace({'contentId': ctx.contentId}, 'Resizing image %s to %s x %s', path, size.width, size.height);
    ImageUtil.resizeImage(path, size, function(err, file) {
        if (err) {
            return callback(err);
        }

        // Move the resized image to the base directory for this piece of content.
        var prefix = size.prefix || '';
        var resizedPath = ctx.baseDir + '/' + prefix + size.size + '.png';
        IO.moveFile(file.path, resizedPath, function(err) {
            if (err) {
                return callback(err);
            }

            // Add it to the set of previews that should be attached to it.
            ctx.addPreview(resizedPath, size.size);
            callback();
        });
    });
};

/**
 * Intelligently crops out thumbnail images.
 * Two images will be cropped out.
 *   - thumbnail
 *       A square small image to display in list views
 *   - wide
 *       A rectangle that can be used in activity feeds
 *
 * It's assumed that the EXIF orientation has been fixed by this point.
 *
 * If no cropMode is defined, one will be determined based on the size of the input image.
 * In landscape mode we crop out a box the size of the image height in the (horizontal) center of the image
 * In portrait mode we crop out a box the size of the image width at the top of the image.
 *
 * @param  {PreviewContext}     ctx             The preview context associated to this file.
 * @param  {String}             path            The path where the image can be found on disk.
 * @param  {String}             [cropMode]      Either 'TOP' or 'CENTER'. If left undefined, top will be chosen for portrait images and center for landscape images
 * @param  {Function}           callback        Standard callback method.
 * @param  {Object}             callback.err    Standard error object (if any.)
 */
var cropThumbnail = module.exports.cropThumbnail = function(ctx, path, cropMode, callback) {
    // First, crop the square thumbnail
    // We *always* crop a thumbnail, if the source image is too small, we'll just have to stretch it.
    var opts = {
        'cropMode': cropMode,
        'skipIfTooSmall': false
    };
    _cropIntelligently(ctx, path, PreviewConstants.SIZES.IMAGE.THUMBNAIL, PreviewConstants.SIZES.IMAGE.THUMBNAIL, opts, 'thumbnail.png', function(err, thumbnailPath) {
        if (err) {
            return callback(err);
        } else if (!thumbnailPath) {
            // If we weren't able to generate the thumbnail, that means the source image is too small.
            // There is no point in trying to render the large rectangle.
            return callback();
        }

        // If the source image is smaller then the target rectangle, the path will be null.
        if (thumbnailPath) {
            ctx.setThumbnail(thumbnailPath);
        }

        // Now, crop the large rectangle for activity feeds.
        //
        opts.skipIfTooSmall = true;
        _cropIntelligently(ctx, path, PreviewConstants.SIZES.IMAGE.WIDE_WIDTH, PreviewConstants.SIZES.IMAGE.WIDE_HEIGHT, opts, 'wide.png', function(err, widePath) {
            if (err) {
                return callback(err);
            }

            // If the source image is smaller then the target rectangle, the path will be null.
            if (widePath) {
                ctx.addPreview(widePath, 'wide');
            }
            callback();
        });
    });
};

/**
 * Crops a subimage out of a base image.
 * In landscape mode we crop out a box the size of the image height in the (horizontal) center of the image
 * In portrait mode we crop out a box the size of the image width at the top of the image.
 *
 * @param  {PreviewContext}     ctx                     The preview context associated to this file.
 * @param  {String}             path                    The path where the image can be found on disk.
 * @param  {Number}             width                   The desired width of the subimage.
 * @param  {Number}             height                  The desired height of the subimage.
 * @param  {Object}             [opts]                  Optional arguments
 * @param  {Boolean}            [opts.skipIfTooSmall]   Skip cropping if the image is too small.
 * @param  {String}             [opts.cropMode]         Either 'TOP' or 'CENTER'. If left undefined, top will be chosen for portrait images and center for landscape images
 * @param  {String}             filename                The filename of the generated subimage. The file will be moved to the basedir of the current preview context.
 * @param  {Function}           callback                Standard callback method.
 * @param  {Object}             callback.err            Standard error object, if any.
 * @param  {String}             callback.path           The full path where the subimage can be found. If the base image was too small, this will be null (no error, will be passed)
 * @api private
 */
var _cropIntelligently = function(ctx, path, width, height, opts, filename, callback) {
    opts = opts || {
        'skipIfTooSmall': false
    };
    log().trace({'contentId': ctx.contentId}, 'Cropping image: %s', path);
    gm(path).size(function (err, size) {
        if (err) {
            log().error({'err': err}, 'Could not get the image size for the large image.');
            return callback({'code': 500, 'msg': 'Could not get the image size for the large image.'});
        }

        var imageWidth = size.width;
        var imageHeight = size.height;

        // Ignore if the image is too small.
        if (opts.skipIfTooSmall && (imageWidth < width || imageHeight < height)) {
            return callback(null, null);
        }

        // Find the smallest ratio
        var widthRatio = imageWidth / width;
        var heightRatio = imageHeight / height;
        var ratio = (widthRatio < heightRatio) ? widthRatio : heightRatio;

        var cropWidth = Math.floor(width * ratio);
        var cropHeight = Math.floor(height * ratio);

        if (!opts.cropMode) {
            // In landscape mode we crop out a box the size of the image height in the (absolute) center of the image.
            if (imageWidth > imageHeight) {
                opts.cropMode = 'CENTER';

            // In portrait mode we crop out a box the size of the image width at the top of the image.
            // This is to get the top of the page for content items such as PDFs, Office files, ...
            } else {
                opts.cropMode = 'TOP';
            }
        }

        // TOP cropMode
        var selectedArea = {
            'x': 0,
            'y': 0,
            'width': cropWidth,
            'height': cropHeight
        };

        if (opts.cropMode === 'CENTER') {
            selectedArea.x = Math.floor((imageWidth - cropWidth) / 2);
            selectedArea.y = Math.floor((imageHeight - cropHeight) / 3);
        }

        // Crop the correct square.
        ImageUtil.cropAndResize(path, selectedArea, [ {'width': width, 'height': height} ], function(err, files) {
            if (err) {
                log().error({'err': err}, 'Could not crop the image.');
                return callback(err);
            }

            // Move the files to the thumbnail path
            var key = width + 'x' + height;
            var croppedPath = ctx.baseDir + '/' + filename;
            IO.moveFile(files[key].path, croppedPath, function(err) {
                if (err) {
                    return callback(err);
                }

                callback(null, croppedPath);
            });
        });
    });
};
