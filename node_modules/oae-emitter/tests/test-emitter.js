/*!
 * Copyright 2015 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');

var EmitterAPI = require('oae-emitter');

var EventEmitter = EmitterAPI.EventEmitter;

describe('EventEmitter', function() {
  describe('#on', function() {
    /**
     * Test that verifies that all `on` handlers are invoked just like a regular EventEmitter
     */
    it('verify all "on" handlers are invoked with specified arguments', function(callback) {
      var emitter = new EventEmitter();

      var results = [];

      emitter.on('a', function() {
        results = _.chain(arguments)
          .toArray()
          .union(results)
          .value();
      });

      emitter.on('b', function() {
        results = _.chain(arguments)
          .toArray()
          .union(results)
          .value();
      });

      emitter.emit('a', 1, 2, 3);
      emitter.emit('b', 2, 3, 4);
      emitter.emit('a', 3, 4, 5);
      emitter.emit('c', 4, 5, 6);

      assert.deepEqual(results.sort(), [1, 2, 3, 4, 5]);

      return callback();
    });
  });

  describe('#when', function() {
    /**
     * Test that verifies that both `on` and `when` handlers are invoked with the supplied
     * arguments
     */
    it('verify all "on" and "when" handlers are invoked with specified arguments', function(callback) {
      var emitter = new EventEmitter();

      var results = [];

      emitter.on('a', function(arg) {
        results.push('a1' + arg);
      });

      emitter.when('a', function(arg, done) {
        results.push('a2' + arg);
        return done();
      });

      emitter.when('a', function(arg, done) {
        process.nextTick(function() {
          results.push('a3' + arg);
          return done();
        });
      });

      emitter.on('b', function(arg) {
        results.push('b1' + arg);
      });

      emitter.when('b', function(arg, done) {
        process.nextTick(function() {
          results.push('b2' + arg);
          return done();
        });
      });

      emitter.emit('a', 1, function() {
        emitter.emit('a', 2, function() {
          emitter.emit('b', 3, function() {
            emitter.emit('a', 5, function() {
              results = _.uniq(results).sort();
              assert.deepEqual(results, [
                'a11',
                'a12',
                'a15',
                'a21',
                'a22',
                'a25',
                'a31',
                'a32',
                'a35',
                'b13',
                'b23',
              ]);
              return callback();
            });
          });
        });
      });
    });
  });

  describe('#emit', function() {
    /**
     * Test that verifies that the handler callback gets invoked, even if there are no handlers
     */
    it('verify callback is invoked with no listeners', function(callback) {
      new EventEmitter().emit('a', 'blah', 'blah', function() {
        new EventEmitter().emit('a', 5, function() {
          new EventEmitter().emit(
            'a',
            {},
            [],
            function() {},
            function() {
              return new EventEmitter().emit('a', callback);
            },
          );
        });
      });
    });

    /**
     * Test that verifies that the handler callback gets invoked when there are only `on`
     * listeners bound to the emitter
     */
    it('verify callback is invoked with only "on" listeners', function(callback) {
      var emitter = new EventEmitter();

      emitter.on('a', function() {});
      emitter.on('b', function() {});

      new EventEmitter().emit('a', 'blah', 'blah', function() {
        new EventEmitter().emit('a', 5, function() {
          new EventEmitter().emit(
            'a',
            {},
            [],
            function() {},
            function() {
              return new EventEmitter().emit('a', callback);
            },
          );
        });
      });
    });

    /**
     * Test that verifies that the handler callback gets invoked when there are only `when`
     * handlers bound to the emitter
     */
    it('verify callback is invoked with only "when" handlers', function(callback) {
      var emitter = new EventEmitter();

      emitter.when('a', function(arg0, arg1, arg2, done) {
        return done();
      });
      emitter.when('b', function(arg0, arg1, arg2, done) {
        return done();
      });

      new EventEmitter().emit('a', 'blah', 'blah', 'blah', function() {
        new EventEmitter().emit('a', 5, 4, 3, function() {
          new EventEmitter().emit(
            'a',
            {},
            [],
            function() {},
            function() {
              return new EventEmitter().emit(
                'a',
                null,
                undefined,
                false,
                callback,
              );
            },
          );
        });
      });
    });

    /**
     * Test that verifies that the handler callback gets invoked only after all `when` handlers
     * have finished processing and invoked their callbacks
     */
    it('verify callback is invoked with both "on" and "when" handlers', function(callback) {
      var emitter = new EventEmitter();

      var successfulACounter = 0;

      emitter.on('a', function(arg0, arg1, arg2, done) {});
      emitter.when('a', function(arg0, arg1, arg2, done) {
        process.nextTick(function() {
          successfulACounter++;
          return done();
        });
      });

      emitter.emit('a', 'blah', 'blah', 'blah', function(errs) {
        assert.ok(!errs);
        assert.strictEqual(successfulACounter, 1);
        emitter.emit('a', 5, 4, 3, function(errs) {
          assert.ok(!errs);
          assert.strictEqual(successfulACounter, 2);
          emitter.emit(
            'a',
            {},
            [],
            function() {},
            function(errs) {
              assert.ok(!errs);
              assert.strictEqual(successfulACounter, 3);
              emitter.emit('a', null, undefined, false, function(errs) {
                assert.ok(!errs);
                assert.strictEqual(successfulACounter, 4);
                return callback();
              });
            },
          );
        });
      });
    });

    /**
     * Test that verifies that handler errors will be aggregated and supplied to the emit
     * callback
     */
    it('verify errors from "when" handlers are aggregated', function(callback) {
      var emitter = new EventEmitter();

      var successfulACounter = 0;

      emitter.when('a', function(done) {
        process.nextTick(function() {
          successfulACounter++;
          return done();
        });
      });

      emitter.when('a', function(done) {
        process.nextTick(function() {
          return done('a1');
        });
      });

      emitter.when('a', function(done) {
        process.nextTick(function() {
          successfulACounter++;
          return done();
        });
      });

      emitter.when('a', function(done) {
        process.nextTick(function() {
          return done('a2');
        });
      });

      emitter.when('a', function(done) {
        process.nextTick(function() {
          successfulACounter++;
          return done();
        });
      });

      emitter.emit('a', function(errs) {
        assert.ok(_.isArray(errs));
        assert.deepEqual(errs.sort(), ['a1', 'a2']);
        assert.strictEqual(successfulACounter, 3);
        return callback();
      });
    });
  });
});
