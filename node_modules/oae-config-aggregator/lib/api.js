/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var OAE = require('oae-util/lib/oae');
var IO = require('oae-util/lib/io');
var fs = require('fs');
var Cassandra = require('oae-util/lib/cassandra');
var _ = require('underscore');
var Validator = require('oae-util/lib/validator').Validator;

// Keeps track of the configurableModules
var configurableModules = [];

/**
 * Constructs an UPDATE CQL query with a variable amount of values to set
 * TODO: Remove this and change to Cassandra.constructUpsertCQL
 * @param {Object} configValues configuration values to set
 */
var constructUpdateCQLQuery = function(configValues) {
    var q = {
        'query': '',
        'params': []
    }
    var tempQuery = [];
    for (var i in configValues) {
        tempQuery.push('? = ?');
        q.params.push(i, configValues[i].value);
        tenantid = configValues[i].tenantid;
    }
    q.query = 'UPDATE Config USING CONSISTENCY QUORUM SET ' + tempQuery.join(', ') + ' WHERE tenantid = ?';
    q.params.push(tenantid);
    return q;
};

/**
 * Writes configuration to Cassandra
 * @param {Object} configValues The configuration to store
 * @param {Function} callback Function executed when storing the configuration completes
 */
var writeConfig = module.exports.writeConfig = function(configValues, callback) {
    var validator = new Validator();
    validator.check(_.keys(configValues).length, {'code': 400, 'msg': 'Missing configuration'}).min(1);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    var q = constructUpdateCQLQuery(configValues);
    Cassandra.runQuery(q.query, q.params, function(err) {
        if (!err) {
            callback();
        } else {
            callback(err);
        }
    });
};

/**
 * Checks if a string ends with a certain string
 * @param {String} str String to check in
 * @param {String} suffix String to look for in str
 */
var endsWith = function(str, suffix) {
    return str.indexOf(suffix, str.length - suffix.length) !== -1;
};

/**
 * Merges the different configurations into one. config.json < global config < tenant config
 * @param {Object} config Contains configuration values
 * @param {Object} modules Contains the modules available for configuration
 * @param {Function} callback Function executed when config has been fully merged
 */
var mergeConfigIntoOriginal = module.exports.mergeConfigIntoOriginal = function(config, modules, callback) {
    callback = callback || function() {};

    // Loop over the stored config (this will always be shorter than looping over the config files first)
    for (var i = 0, l = config.count; i < l; i++) {
        // Split the colHash to match to the element IDs
        var colHash = config[i].name.split('/');
        // Loop over the config.json files
        for (var ii = 0, ll = modules.length; ii < ll; ii++) {
            // Only continue if the module ID matches the stored config
            if (modules[ii].id === colHash[0]) {
                // Loop over the elements in the module config
                for (var opt in modules[ii].config.options) {
                    // Only continue if the option ID matches the stored config
                    if (opt === colHash[1]) {
                        // Loop over the elements in the option
                        for (var el in modules[ii].config.options[opt].elements) {
                            // Only continue if the element ID matches the stored config
                            if (el === colHash[2]) {
                                // Overwrite the config.json files with the stored value
                                var value = config[i].value;
                                if (endsWith(colHash[2], 'enabled')) {
                                    modules[ii].config.options[opt].enabled = value;
                                }
                                modules[ii].config.options[opt].elements[el].value = value;
                            }
                        }
                    } else {
                        modules[ii].config.options[opt].enabled = modules[ii].config.options[opt].elements[opt + '-enabled'].value;
                    }
                }
            }
        }
    }
    callback(modules);
};

/**
 * Reads the configuration values
 * @param {String} tenantid The ID of the tenant to get configuration for
 * @param {Function} callback Function executed after config has been read
 */
var readConfig = module.exports.readConfig = function(tenantid, callback) {
    var validator = new Validator();
    validator.check(tenantid, {'code': 400, 'msg': 'Missing tenantid'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    Cassandra.runQuery('SELECT * FROM Config USING CONSISTENCY QUORUM WHERE tenantid = ?', ['global'], function(err, globalRows) {
        if (!err) {
            getModules(function(modules) {
                // Merge the stored config files into the fetched modules data
                // config.json < global config < tenant config
                mergeConfigIntoOriginal(globalRows[0], modules, function(config) {
                    if (!err) {
                        Cassandra.runQuery('SELECT * FROM Config USING CONSISTENCY QUORUM WHERE tenantid = ?', [tenantid], function(err, tenantRows) {
                            mergeConfigIntoOriginal(tenantRows[0], config, function(config) {
                                if (!err) {
                                    callback(false, config);
                                } else {
                                    callback(err);
                                }
                            });
                        });
                    } else {
                        callback(err);
                    }
                });
            });
        } else {
            callback(err);
        }
    });
};

/**
 * Reads the configuration values of a specific module
 * @param {String} tenantid The ID of the tenant to get configuration for
 * @param {Function} callback Function executed after config has been read
 */
var readConfigForModule = module.exports.readConfigForModule = function(tenantid, module, callback) {
    var validator = new Validator();
    validator.check(tenantid, {'code': 400, 'msg': 'Missing tenantid'}).notEmpty();
    validator.check(module, {'code': 400, 'msg': 'Missing moduleid'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    Cassandra.runQuery('SELECT * FROM Config WHERE tenantid = ?', ['global'], function(err, globalRows) {
        if (!err) {
            getSingleModule(module, function(module) {
                // Merge the stored config files into the fetched modules data
                // config.json < global config < tenant config
                mergeConfigIntoOriginal(globalRows[0], module, function(config) {
                    if (!err) {
                        Cassandra.runQuery('SELECT * FROM Config WHERE tenantid = ?', [tenantid], function(err, tenantRows) {
                            mergeConfigIntoOriginal(tenantRows[0], config, function(config) {
                                if (!err) {
                                    callback(false, config);
                                } else {
                                    callback(err);
                                }
                            });
                        });
                    } else {
                        callback(err);
                    }
                });
            });
        } else {
            callback(err);
        }
    });
};

/**
 * Retrieves the available login strategies
 * @param {String} tenantid The ID of the tenant we need strategies for
 * @param {Function} callback Executed after the available login strategies have been retrieved
 */
var getAvailableLoginStrategies = module.exports.getAvailableLoginStrategies = function(tenantid, callback) {
    var validator = new Validator();
    validator.check(tenantid, {'code': 400, 'msg': 'Missing tenantid'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    readConfigForModule(tenantid, 'authentication', function(err, config) {
        if (!err) {
            callback(false, config);
        } else {
            callback(err);
        }
    });
};

 /**
 * Filters out modules that don't have a configuration file in the config directory and fills an Array of modules with configuration.
 * @param {Array} modules Array of strings containing directory names for oae- modules.
 * @param {Function} callback Callback function executed when filtering is complete. Passes through the filtered Array of config objects.
 */
var filterModulesByConfig = function(modules, callback) {

    /**
     * Filters out modules that don't have a configuration file in the config directory
     * @param {Number} i index of the module to filter next
     */
    var doFilter = function(i) {
        if (modules[i]) {
            fs.exists('node_modules/' + modules[i] + '/config/config.json', function(exists) {
                if (exists) {
                    IO.loadJSONConfig('node_modules/' + modules[i] + '/config/config.json', function(configFile) {
                        var configObj = {
                            'id': modules[i],
                            'config': JSON.parse(configFile)
                        }
                        configurableModules.push(configObj);
                        if (modules[i+1]) {
                            doFilter(i += 1);
                        } else {
                            callback(configurableModules);
                        }
                    });
                } else {
                    if (modules[i+1]) {
                        doFilter(i += 1);
                    } else {
                        callback(configurableModules);
                    }
                }
            });
        } else {
            callback(configurableModules);
        }
    };

    doFilter(0);
};


/**
 * Gets a single module
 * @param {Function} callback Function executed when availables modules are retrieved
 */
var getSingleModule = module.exports.getSingleModule = function(module, callback) {
    callback = callback || function(){};

    // Read directories starting with the module name and read the configuration
    // If there's no configuration file the directory is skipped.
    OAE.getSingleModule(module, function(finalModules) {
        configurableModules = [];
        filterModulesByConfig(finalModules, callback);
    });
};

/**
 * Gets the available modules
 * @param {Function} callback Function executed when availables modules are retrieved
 */
var getModules = module.exports.getModules = function(callback) {
    callback = callback || function(){};

    // Read directories starting with oae- and get their configuration files.
    // If there's no configuration file the directory is skipped.
    OAE.getAvailableModules(function(finalModules) {
        configurableModules = [];
        filterModulesByConfig(finalModules, callback);
    });
};
