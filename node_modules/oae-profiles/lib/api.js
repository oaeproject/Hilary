/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * visibilitys and limitations under the License.
 */

var _ = require('underscore');

var Cassandra = require('oae-util/lib/cassandra');
var AuthzUtil = require('oae-authz/lib/util');
var Validator = require('oae-util/lib/validator').Validator;

var ProfileSection = require('./model').ProfileSection;
var Constants = require('./model').Constants;

/**
 * Create or update a principal's profile section.
 * This method supports partial updates. It will merge the old object with the new one if `overwrite` is set to false.
 *
 * @param  {Context}         context             The context
 * @param  {String}          principalId         The principal for who we need to update this section.
 * @param  {String}          sectionName         The name of the section that needs updating.
 * @param  {String}          sectionVisibility   One of "private", "loggedin" or "public"
 * @param  {Object}          sectionData         A JSON object that will be stored in the DB.
 * @param  {Boolean}         overwrite           Specifies whether the profile should be completely overwritten. (default: true)
 * @param  {Function}        callback            A callback method takes argument `err`
 * @param  {Object}          callback.err        An error object (if any)
 */
var setSection = module.exports.setSection = function(context, principalId, sectionName, sectionVisibility, sectionData, overwrite, callback) {
    sectionData = sectionData || {};
    callback = callback || {};
    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'A principal id must be provided'}).notEmpty();
    validator.check(sectionName, {'code': 400, 'msg': 'A section name must be provided'}).notEmpty();
    validator.check(overwrite, {'code': 400, 'msg': 'The overwrite variable must be a boolean'}).isIn([true, false]);
    validator.check(null, {'code': 400, 'msg': 'Only proper objects are accepted as section data'}).isObject(sectionData);
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to change a profile section.'}).isLoggedInUser(context);
    if (sectionVisibility !== undefined) {
        var visibilities = _.values(Constants.visibility);
        validator.check(sectionVisibility, {'code': 400, 'msg': 'Visibility should be one of: ' + visibilities.join(',')}).isIn(visibilities);
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Only the user owner or an admin has access.
    var principalResource = AuthzUtil.getResourceFromUuid(principalId);
    if (context.user().id === principalId || context.user().isAdmin(principalResource.tenantId)) {

        // Get the section in case we're updating.
        getSection(context, principalId, sectionName, function(err, oldProfileSection) {
            if (err && err.code !== 404) {
                return callback(err);
            }

            // Create a new  section or update the old one.
            var profileSection = null;
            if (err.code === 404) {
                // This is a new profile section.
                sectionVisibility = sectionVisibility || Constants.visibility.PUBLIC;
                profileSection = new ProfileSection(principalId, sectionName, sectionData, sectionVisibility);
            } else {
                // This is an update, merge it with the old section.
                var data = oldProfileSection.data || {};
                if (!overwrite) {
                    data = _.extend(data, sectionData);
                } else {
                    data = sectionData;
                }
                var visibility = sectionVisibility || oldProfileSection.visibility;
                profileSection = new ProfileSection(principalId, sectionName, data, visibility);
            }

            // Store the profile section.
            _setSection(principalId, profileSection, callback);
        });
    } else {
        return callback({'code': 403, 'msg': 'You\'re not allowed to change this user\'s profile'});
    }
};

/**
 * Updates a section. This function will not perform any checking on validity of
 * visibility, data, etc.. It's assumed the caller takes care of this.
 *
 * @param  {String}            principalId      The id of the principal to whom this section belongs.
 * @param  {ProfileSection}    profileSection   The profilesection that contains the (updated) data.
 * @param  {Function}          callback         Callback method.
 * @param  {Object}            callback.err     An error object (if any.)
 * @private
 */
var _setSection = function(principalId, profileSection, callback) {
    var columnVisibilityName = profileSection.name + '#visibility';
    var columnDataName = profileSection.name + '#data';
    data = JSON.stringify(profileSection.data);
    Cassandra.runQuery("UPDATE Profiles USING CONSISTENCY QUORUM SET ?=?, ?=? WHERE principalId=?", [columnVisibilityName, profileSection.visibility, columnDataName, data, principalId], callback);
};

/**
 * Gets a section for a principal. If this principal has marked the section as private and is being retrieved by another non-admin user, an error will be passed.
 *
 * @param  {Context}                context         The context
 * @param  {String}                 principalId     The principalId for who we need to retrieve a section.
 * @param  {String}                 sectionName     The name of the section that needs retrieving.
 * @param  {Function}               callback        A callback method takes arguments `err` and `data`
 * @param  {Object}                 callback.err    An error object (if any)
 * @param  {ProfileSection}         callback.data   A ProfileSection object.
 */
var getSection = module.exports.getSection = function(context, principalId, sectionName, callback) {
    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'The anonymous user does not have any profile sections.'}).notNull();
    validator.check(sectionName, {'code': 400, 'msg': 'The sectionName was not provided.'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    var columnVisibilityName = sectionName + '#visibility';
    var columnDataName = sectionName + '#data';
    Cassandra.runQuery("SELECT ?, ? FROM Profiles USING CONSISTENCY QUORUM WHERE principalId = ?", [columnVisibilityName, columnDataName, principalId], function(err, rows) {
        if (err) {
            return callback(err);
        } else if (rows[0].count <= 1) {
            return callback({'code': 404, 'msg': 'Section not found'});
        }

        var visibility = rows[0].get(columnVisibilityName).value;
        // Only actually parse the data when we're sure that the current user can access it.
        var profileSection = new ProfileSection(principalId, sectionName, {}, visibility);
        _hasAccess(context, profileSection, function(err, hasAccess) {
            if (err) {
                return callback(err);
            }

            if (!hasAccess) {
                return callback({'code': 403, 'msg' : 'You don\' t have access to this profile section'});
            }
            try {
                var data = rows[0].get(columnDataName).value;
                profileSection.data = JSON.parse(data);
            } catch (err) {
                return callback({'code': 500, 'msg': 'Couldn\'t parse the data in the DB.'});
            }

            callback(false, profileSection);
        });
    });
};

/**
 * Gets all the profile sections for a principal.
 *
 * @param  {Context}                context         The current user's context
 * @param  {String}                 principalId     The id of the principal for whom the profile should be retrieved.
 * @param  {Function}               callback        A callback method takes arguments `err` and `data`
 * @param  {Object}                 callback.err    An error object (if any)
 * @param  {Profilesection[]}       callback.data   The sections the user has access to.
 */
var getAllSections = module.exports.getAllSections = function(context, principalId, callback) {
    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'The anonymous user does not have any profile sections.'}).notNull();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    
    Cassandra.runQuery("SELECT * FROM Profiles USING CONSISTENCY QUORUM WHERE principalId = ?", [principalId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        // In case there are no sections.
        if (rows[0].count <= 1) {
            return callback(false, []);
        }

        var retrievedSections = 0;
        var allSections = [];
        var checkAccess = function(profileSection, sectionData) {
            _hasAccess(context, profileSection, function(err, hasAccess) {
                retrievedSections++;
                if (!err && hasAccess) {
                    try {
                        profileSection.data = JSON.parse(sectionData);
                    } catch (err) {
                        return callback({'code': 500, 'msg': 'Couldn\'t parse the data in the DB for ' + profileSection.name + '.'});
                    }
                    allSections.push(profileSection);
                }

                if (retrievedSections === Math.floor(rows[0].count / 2)) {
                    callback(false, allSections);
                }
            });
        };

        rows[0].forEach(function(name, value, ts, ttl) {
            if (name === 'principalId') {
                return;
            }
            var parts = name.split('#');
            if (parts[1] === 'data') {
                var sectionName = parts[0];
                var visibility = rows[0].get(sectionName + '#visibility').value;
                var profileSection = new ProfileSection(principalId, sectionName, {}, visibility);
                checkAccess(profileSection, value);
            }
        });
    });
};


/**
 * Checks if the current user has access to this profile section.
 *
 * @param   {Context}                   context             Current user's context
 * @param   {ProfileSection}            profileSection      The section that needs to be checked.
 * @param   {Function}                  callback            Callback method takes arguments `err` and `hasAccess`
 * @param   {Object}                    callback.err        An error object (if any)
 * @param   {Boolean}                   callback.hasAccess  Whether or not the current user can see this profile section.
 * @private
 */
var _hasAccess = function(context, profileSection, callback) {
    if (profileSection.visibility === Constants.visibility.PUBLIC) {
        return callback(false, true);
    }
    // Anonymous users can't see private or logged in sections.
    if (context.user() === null && (profileSection.visibility !== Constants.visibility.PUBLIC)) {
        return callback({'code': 401, 'msg': 'You don\'t have access to this profile section. Try logging in.'});
    }

    var principalResource = AuthzUtil.getResourceFromUuid(profileSection.principalId);
    if (context.user().id === profileSection.principalId || context.user().isAdmin(principalResource.tenantId) || profileSection.visibility !== Constants.visibility.PRIVATE) {
        callback(false, true);
    } else {
        return callback({'code': 403, 'msg': 'You don\'t have access to this profile section.'});
    }
};
