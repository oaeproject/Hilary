/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var ShortId = require('shortid');

var Cassandra = require('oae-util/lib/cassandra');
var log = require('oae-logger').logger('oae-activity');

var Publication = require('oae-publications/lib/model').Publication;


/**
 * Creates a publication record by:
 *  - storing its metadata
 *  - storing its source Ids
 *  - storing its authors
 *
 * @param  {Publication}    publication             The publication to store
 * @param  {String[]}       sourceIds               An array of source IDs
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object (if any)
 * @param  {Publication}    callback.publication    The updated publication
 */
var createPublication = module.exports.createPublication = function(publication, sourceIds, callback) {
    var publicationId = _generatePublicationId();
    var queries = [];

    // 1. Create the publication row
    var publicationRowValues = _publicationToRow(publication);
    queries.push(Cassandra.constructUpsertCQL('Publications', 'publicationId', publicationId, publicationRowValues));

    // 2. Add all the sources where this publication was found in
    _.each(sourceIds, function(sourceId) {
        queries.push(Cassandra.constructUpsertCQL('PublicationsBySource', 'sourceId', sourceId, {'publicationId': publicationId}));
    });

    // 3. Add all the authors for this publication
    var authorRow = {};
    _.each(publication.authors, function(author) {
        authorRow[author] = author;
    });
    queries.push(Cassandra.constructUpsertCQL('PublicationsAuthors', 'publicationId', publicationId, authorRow));

    // Send the queries off to cassandra
    Cassandra.runBatchQuery(queries, 'QUORUM', function(err) {
        if (err) {
            return callback(err);
        }

        publication.id = publicationId;
        return callback(null, publication);
    });
};

/**
 * Updates the metadata for an existing publication and adds the provided sources.
 * This method will *NOT* add new or edit existing authors.
 *
 * @param  {Publication}    newPublication          The publication object that might contain updated information
 * @param  {Publication}    oldPublication          The old publication object
 * @param  {String[]}       sourceIds               An array of source IDs
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object (if any)
 * @param  {Publication}    callback.publication    The updated publication
 */
var updatePublication = module.exports.updatePublication = function(newPublication, oldPublication, sourceIds, callback) {
    var queries = [];

    // 1. Update the record
    newPublication = _.extend({}, oldPublication, newPublication);
    delete newPublication.id;
    var publicationRowValues = _publicationToRow(newPublication);
    queries.push(Cassandra.constructUpsertCQL('Publications', 'publicationId', oldPublication.id, publicationRowValues));

    // 2. Add all the sources where this publication was found in
    _.each(sourceIds, function(sourceId) {
        queries.push(Cassandra.constructUpsertCQL('PublicationsBySource', 'sourceId', sourceId, {'publicationId': oldPublication.id}));
    });

    // Note: We're *NOT* adding authors on update as different sources have different ways of writing author names
    // ex: Some sources would write `Simon Gaeremynck` as `Gaeremynck S`, others would simply write `Gaeremynck`, etc.

    // Send the queries off to cassandra
    Cassandra.runBatchQuery(queries, 'QUORUM', function(err) {
        if (err) {
            return callback(err);
        }

        newPublication.id = oldPublication.id;
        return callback(null, newPublication);
    });
};

/**
 * Links a publications to an OAE user. If an authorName is provided, the OAE user will replace that author
 *
 * @param  {Publication}    publication     The publication for which to link a user
 * @param  {String}         authorName      The name of the author that resembles this user. This plain-text name will be removed from the set and the userId will be injected
 * @param  {String}         userId          The ID of the user that will be linked
 * @param  {Function}       callback        Standard callback function
 * @param  {Object}         callback.err    Standard error object, if any
 */
var linkPublicationToUser = module.exports.linkPublicationToUser = function(publication, authorName, userId, callback) {
    var queries = [];

    // Insert the publication to the list of publications for the userId
    var rowValues = {};

    // If we're dealing with a date that is pre 2001-09-11 it will contain only 12 digits (rather than 13)
    // Because we rely on Cassandra's column ordering, we will need 13 digits here
    var colName = _formatNumber(publication.date) + '#' + publication.id;
    rowValues[colName] = 1;
    queries.push(Cassandra.constructUpsertCQL('PublicationsByUser', 'userId', userId, rowValues));

    // Delete the plain-text author if one was provided
    if (authorName) {
        queries.push({'query': 'DELETE ? FROM PublicationsAuthors WHERE publicationId = ?', 'parameters': [authorName, publication.id]});
    }

    // Add the userId to the CF that maps a publication ID to a set of authors (that are known in OAE)
    var publicationsAuthorRowValues = {};
    publicationsAuthorRowValues[userId] = authorName;
    var q = Cassandra.constructUpsertCQL('PublicationsAuthors', 'publicationId', publication.id, publicationsAuthorRowValues);
    if (q) {
        queries.push(q);
    }

    Cassandra.runBatchQuery(queries, 'QUORUM', callback);
};

/**
 * Gets a set of publications for a given userId
 *
 * @param  {String}         userId                  [description]
 * @param  {String}         start                   The publication ordering token from which to start fetching publications (see `nextToken` in callback params)
 * @param  {Number}         limit                   The number of publications that should be returned
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object, if any
 * @param  {Publication[]}  callback.publications   An array of publication objects
 * @param  {String}         callback.nextToken      The value to provide in the `start` parameter to get the next set of results
 */
var getPublicationsForUser = module.exports.getPublicationsForUser = function(userId, start, limit, callback) {
    // Publications are typically ingested on an interval, so we can relax the consistency requirement
    Cassandra.runPagedColumnQuery('PublicationsByUser', 'userId', userId, start, limit, {'reversed': true, 'consistency': 'ONE'}, function(err, columns, nextToken) {
        if (err) {
            return callback(err);
        }

        if (columns.length === 0) {
            return callback(null, [], null);
        }

        // Get the actual publications
        var publicationsIds = [];
        columns.forEach(function(column) {
            var publicationId = column.name.split('#').slice(1).join('#');
            publicationsIds.push(publicationId);
        });

        Cassandra.runQuery('SELECT * FROM Publications WHERE publicationId IN (?)', [publicationsIds], function(err, publicationRows) {
            if (err) {
                return callback(err);
            }

            var publications = [];
            _.each(publicationRows, function(publicationRow) {
                publications.push(_rowToPublication(publicationRow));
            });

            _getAuthorsForPublications(publications, function(err, publications) {
                if (err) {
                    return callback(err);
                }

                return callback(null, publications, nextToken);
            });
        });
    });
};

/**
 * Get all the publications that match a set of source identifiers
 *
 * @param  {String[]}   sourceIds               A set of source IDs
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            Standard error object, if any
 * @param  {Object}     callback.publications   A hash of publications that are keyed by the source ID
 */
var getPublicationsBySourceIds = module.exports.getPublicationsBySourceIds = function(sourceIds, callback) {
    if (_.isEmpty(sourceIds)) {
        return callback(null, {});
    }

    Cassandra.runQuery('SELECT * FROM PublicationsBySource WHERE sourceId IN (?)', [sourceIds], function(err, sourceRows) {
        if (err) {
            return callback(err);
        }

        var publicationsBySource = {};
        _.each(sourceRows, function(sourceRow) {
            if (sourceRow.get('publicationId')) {
                var sourceId = sourceRow.get('sourceId').value;
                var publicationId = sourceRow.get('publicationId').value;
                publicationsBySource[sourceId] = publicationId;
            }
        });

        var publicationIds = _.chain(publicationsBySource).values().uniq().value();
        if (publicationIds.length === 0) {
            return callback(null, {});
        }

        Cassandra.runQuery('SELECT * FROM Publications WHERE publicationId IN (?)', [publicationIds], function(err, publicationRows) {
            if (err) {
                return callback(err);
            }

            var publications = {};
            _.each(publicationRows, function(publicationRow) {
                var publication = _rowToPublication(publicationRow);
                publications[publication.id] = publication;
            });

            _.each(publicationsBySource, function(publicationId, sourceId) {
                publicationsBySource[sourceId] = publications[publicationId];
            });

            var allPublications = _.values(publications);
            _getAuthorsForPublications(allPublications, function(err, allPublications) {
                if (err) {
                    return callback(err);
                }

                return callback(null, publicationsBySource);
            });
        });
    });
};

/**
 * Get a publication by its ID
 *
 * @param  {String}         publicationId           The ID of the publication to retrieve
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object, if any
 * @param  {Publication}    callback.publication    The publication matching the `publicationId`
 */
var getPublication = module.exports.getPublication = function(publicationId, callback) {
    Cassandra.runQuery('SELECT * FROM Publications WHERE publicationId = ?', [publicationId], function(err, publicationRows) {
        if (err) {
            return callback(err);
        }

        if (publicationRows[0].count <= 1) {
            return callback({'code': 404, 'msg': 'Couldn\'t find publication: ' + publicationId}, null);
        }

        var publication = _rowToPublication(publicationRows[0]);
        _getAuthorsForPublications([publication], function(err, publications) {
            if (err) {
                return callback(err);
            }

            return callback(null, publications[0]);
        });
    });
};

/**
 * Gets the authors for a set of publications and adds them in the `authors` array on each publication object
 *
 * @param  {Publication[]}      publications                A set of publication objects for which the authors should be retrieved
 * @param  {Function}           callback                    Standard callback function
 * @param  {Object}             callback.err                Standard error object, if any
 * @param  {Publication[]}      callback.publications       The publication objects with an `authors` array on each one of them
 * @api private
 */
var _getAuthorsForPublications = function(publications, callback) {
    var publicationsIds = _.map(publications, function(publication) { return publication.id; });

    // Get the authors for each publication
    Cassandra.runQuery('SELECT * FROM PublicationsAuthors WHERE publicationId IN (?)', [publicationsIds], function(err, authorRows) {
        if (err) {
            return callback(err);
        }

        _.each(authorRows, function(authorRow) {
            var publication = _.find(publications, function(publication) { return publication.id === authorRow.get('publicationId').value; });
            publication.authors = [];
            authorRow.forEach(function(columnName, value, ts, ttl) {
                if (columnName !== 'publicationId') {
                    publication.authors.push(columnName);
                }
            });
        });

        return callback(null, publications);
    });
};

////////////////////////
// INTERNAL FUNCTIONS //
////////////////////////

/**
 * Converts a Cassandra row to a publication object
 *
 * @param  {Row}            row     The cassandra row to convert
 * @return {Publication}            The publication object
 * @api private
 */
var _rowToPublication = function(row) {
    var hash = Cassandra.rowToHash(row);
    return new Publication(hash.publicationId, hash.displayName, hash.publicationType, hash.date, hash.thumbnailUri, [], hash.publisher, hash.linkedContentId, hash.extra);
};

/**
 * Converts a publication object to a plain hash that can be stored in the cassandra Publications CF
 *
 * @param  {Publication}    publication     The publication that will be stored
 * @return {Object}                         The object that can be stored
 * @api private
 */
var _publicationToRow = function(publication) {
    var rowValues = _.extend({}, publication);
    delete rowValues.authors;
    return rowValues;
};

/**
 * Generates and returns a publication ID.
 * Publication IDs are not your typical OAE resource identifier as they are not really tied
 * to a particular tenant.
 *
 * @return {String}     The generated publication ID
 * @api private
 */
var _generatePublicationId = function() {
    return 'p:' + ShortId.generate();
};

/**
 * Returns a formatted number so that it always returns 13 digits. A leading 0 will be prepended if necessary.
 *
 * @param  {Number}     nr  The number to format
 * @return {String}         The stringified representation of the passed in number but formatted with 13 digits
 * @api private
 */
var _formatNumber = function(nr) {
    if (nr.toString().length === 12) {
        return '0' + nr;
    } else {
        return nr;
    }
};
