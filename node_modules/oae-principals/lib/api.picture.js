/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var fs = require('fs');
var mime = require('mime');
var path = require('path');

var AuthzUtil = require('oae-authz/lib/util');
var ContentUtil = require('oae-content/lib/internal/util');
var ImageUtil = require('oae-util/lib/image');
var log = require('oae-logger').logger('oae-principals-shared');
var Validator = require('oae-util/lib/validator').Validator;

var GroupAPI = require('./api.group');
var PrincipalsConstants = require('./constants').PrincipalsConstants;
var PrincipalsDAO = require('./internal/dao');
var PrincipalsEmitter = require('./internal/emitter');
var PrincipalsUtil = require('./util');

var ContentAPI = require('oae-content');
var ContentUtil = require('oae-content/lib/internal/util');

/**
 * Store the large picture for a principal that can be re-used later on
 *
 * @param  {Context}        ctx                 Context that holds the current user and tenant
 * @param  {String}         principalId         The ID of the principal you wish to store a picture for
 * @param  {File}           file                An object representing the picture being upload and where to find it on disk
 * @param  {String}         file.name           The name of the file you wish to store
 * @param  {String}         file.type           The mimetype of the file. Only the following mimetypes can be stored: 'image/jpg', 'image/jpeg', 'image/png', 'image/gif' or 'image/bmp'
 * @param  {String}         file.path           The path on disk where the file is stored
 * @param  {Number}         file.size           The filesize. A maximum of 10MB is imposed
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Group|User}     callback.principal  The basic profile of the user or group whose picture was stored
 */
var storePicture = module.exports.storePicture = function(ctx, principalId, file, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Unable to store picture %s for %s', file.path, principalId);
        }
    };

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a picture'}).isLoggedInUser(ctx);
    validator.check(principalId, {'code': 400, 'msg': 'A principal ID must be provided'}).isPrincipalId();
    validator.check(file, {'code': 400, 'msg': 'A file must be provided'}).notNull();
    if (file) {
        validator.check(file.size, {'code': 400, 'msg': 'Missing size on the file object.'}).notEmpty();
        validator.check(file.size, {'code': 400, 'msg': 'The size of a picture has an upper limit of 10MB.'}).max(10485760);
        validator.check(file.name, {'code': 400, 'msg': 'Missing name on the file object.'}).notEmpty();
    }
    if (validator.hasErrors()) {
        return _cleanupOnError(validator.getFirstError(), file, callback);
    }

    // Check if we can edit this principal
    _canManagePrincipal(ctx, principalId, function(err) {
        if (err) {
            return _cleanupOnError(err, file, callback);
        }

        // Detect the mimetype of the file using the file extension, as the one that Express gives us is pulled
        // from the HTTP request. This makes it an untrustworthy piece of information as some browsers are
        // notoriously bad at providing the correct mimetype and it can be spoofed. If the mimetype cannot
        // be determined, the mime utility falls back to application/octet-stream.
        file.type = mime.lookup(file.name);

        // Only images can be uploaded
        if (!_.contains(['image/jpg', 'image/jpeg', 'image/gif', 'image/png', 'image/bmp'], file.type)) {
            return callback({'code': 400, 'msg': 'Only images are accepted files'});
        }

        // Now store and attach the new one
        _storeLargePicture(ctx, principalId, file, function(err) {
            if (err) {
                return _cleanupOnError(err, file, callback);
            }

            return PrincipalsUtil.getPrincipal(ctx, principalId, callback);
        });
    });
};

/**
 * Stores a large picture for a principal and attaches it to the User or Group object in Cassandra. This function
 * assumes that all the parameters have been validated previously. It will auto orient the picture so it can be
 * displayed correctly in all browsers.
 *
 * @param  {Context}        ctx                 Context that holds the current user and tenant
 * @param  {String}         principalId         The id of the principal for which we will store the large picture
 * @param  {File}           file                The file to store
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @api private
 */
var _storeLargePicture = function(ctx, principalId, file, callback) {
    // Auto orient the picture so we can display it in the browser.
    ImageUtil.autoOrient(file.path, {'removeInput': true}, function(err, orientedFile) {
        if (err) {
            return _cleanupOnError(err, file, callback);
        }

        // Convert it to a JPG
        ImageUtil.convertToJPG(orientedFile.path, function(err, convertedFile) {
            if (err) {
                return _cleanupOnError(err, file, callback);
            }

            // Store the oriented file
            var options = _getProfilePictureStorageOptions(principalId, Date.now(), 'large', '.jpg');
            ContentUtil.getStorageBackend(ctx).store(ctx, convertedFile, options, function(err, largePictureUri) {
                if (err) {
                    return _cleanupOnError(err, convertedFile, callback);
                }

                // By this point the temp file has been removed from disk, no need to clean up in error cases below
                return PrincipalsDAO.updatePrincipal(principalId, {'largePictureUri': largePictureUri}, callback);
            });
        });
    });
};

/**
 * Crops a square out of the large picture attached to a principal and generates
 * a small and medium sized version of that square.
 *
 * @param  {Context}     ctx                 Context that holds the current user and tenant
 * @param  {String}      principalId         The ID of the principal to crop the large picture for
 * @param  {Number}      x                   The x coordinate of the topleft corner to start cropping
 * @param  {Number}      y                   The y coordinate of the topleft corner to start cropping
 * @param  {Number}      width               The width of the square that needs to be cropped out
 * @param  {Function}    callback            Standard callback function
 * @param  {Object}      callback.err        An error that occurred, if any
 * @param  {Group|User}  callback.principal  If the principal for which we cropped the picture was a user, it will be the user's basic profile. If a group, it will be the full group profile
 */
var generateSizes = module.exports.generateSizes = function(ctx, principalId, x, y, width, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Unable to crop picture %s for %s', fileUri, principalId);
        }
    };

    // Parameter validation
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a picture'}).isLoggedInUser(ctx);
    validator.check(principalId, {'code': 400, 'msg': 'A principal id must be provided'}).isPrincipalId();
    validator.check(x, {'code': 400, 'msg': 'The x value must be a positive integer'}).isInt();
    validator.check(x, {'code': 400, 'msg': 'The x value must be a positive integer'}).min(0);
    validator.check(y, {'code': 400, 'msg': 'The y value must be a positive integer'}).isInt();
    validator.check(y, {'code': 400, 'msg': 'The y value must be a positive integer'}).min(0);
    validator.check(width, {'code': 400, 'msg': 'The width value must be a positive integer'}).isInt();
    validator.check(width, {'code': 400, 'msg': 'The width value must be a positive integer'}).min(10);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Make sure we can edit this principal
    _canManagePrincipal(ctx, principalId, function(err) {
        if (err) {
            return callback(err);
        }

        PrincipalsDAO.getPrincipal(principalId, function(err, principal) {
            if (err) {
                return callback(err);
            } else if (!principal.picture.largeUri) {
                return callback({'code': 400, 'msg': 'This principal has no large picture'});
            }

            // Generate and store the sizes
            _generateSizes(ctx, principal, x, y, width, function(err, principal) {
                if (err) {
                    return callback(err);
                }

                // For a group we need to return the full group profile, but for a user
                // it seems to be fine that just the basic profile gets returned
                if (PrincipalsUtil.isUser(principalId)) {
                    return PrincipalsUtil.getPrincipal(ctx, principalId, callback);
                } else {
                    return GroupAPI.getFullGroupProfile(ctx, principalId, callback);
                }
            });
        });
    });
};

/**
 * Internal method that retrieves the large picture attached to this principal, crops out the desired square
 * and scales that square to a small and medium sized verison.
 *
 * @param  {Context}     ctx                 Context that holds the current user and tenant
 * @param  {Group|User}  principal           The principal to crop the large picture for
 * @param  {Number}      x                   The x coordinate of the topleft corner to start cropping
 * @param  {Number}      y                   The y coordinate of the topleft corner to start cropping
 * @param  {Number}      width               The width of the square that needs to be cropped out
 * @param  {Function}    callback            Standard callback function
 * @param  {Object}      callback.err        An error that occurred, if any
 * @param  {Group|User}  callback.principal  The updated principal object
 * @api private
 */
var _generateSizes = function(ctx, principal, x, y, width, callback) {
    // Retrieve the raw image.
    ContentUtil.getStorageBackend(ctx, principal.picture.largeUri).get(ctx, principal.picture.largeUri, function(err, file) {
        if (err) {
            return callback(err);
        }

        // Get the resized images
        var selectedArea = {
            'x': parseInt(x, 10),
            'y': parseInt(y, 10),
            'width': parseInt(width, 10),
            'height': parseInt(width, 10)
        };
        var sizes = [
            {'width': PrincipalsConstants.picture.size.SMALL, 'height': PrincipalsConstants.picture.size.SMALL},
            {'width': PrincipalsConstants.picture.size.MEDIUM, 'height': PrincipalsConstants.picture.size.MEDIUM}
        ];
        ImageUtil.cropAndResize(file.path, selectedArea, sizes, function(err, files) {
            // Remove the temp file first
            file.remove(function(removalError) {
                if (err) {
                    return callback(err);
                } else if (removalError) {
                    return callback(removalError);
                }

                // File removed, store and save the cropped and resized images
                return _storeCroppedPictures(ctx, principal, files, callback);
            });
        });
    });
};

/**
 * Store the resized files and save their URIs on the principal object.
 *
 * @param  {Context}     ctx                 Context that holds the current user and tenant
 * @param  {Group|User}  principal           The principal to crop the large picture for
 * @param  {Object}      files               An object with file objects
 * @param  {Function}    callback            Standard callback function
 * @param  {Object}      callback.err        An error that occurred, if any
 * @param  {Group|User}  callback.principal  The updated principal object
 * @api private
 */
var _storeCroppedPictures = function(ctx, principal, files, callback) {
    var backend = ContentUtil.getStorageBackend(ctx);
    var now = Date.now();

    // Get the the small image
    var key = util.format('%sx%s', PrincipalsConstants.picture.size.SMALL, PrincipalsConstants.picture.size.SMALL);
    var smallImage = files[key];

    // Store the image with a correct filename. We explicitly add a correct extension as nginx uses it
    // to determine the mimetype
    var options = _getProfilePictureStorageOptions(principal.id, now, 'small', ImageUtil.getImageExtension(smallImage.filename, '.jpg'));
    backend.store(ctx, smallImage, options, function(err, smallPictureUri) {
        if (err) {
            return callback(err);
        }

        // Get the medium image, determine the correct extension and store it
        key = util.format('%sx%s', PrincipalsConstants.picture.size.MEDIUM, PrincipalsConstants.picture.size.MEDIUM);
        var mediumImage = files[key];

        options = _getProfilePictureStorageOptions(principal.id, now, 'medium', ImageUtil.getImageExtension(mediumImage.filename, '.jpg'));
        backend.store(ctx, mediumImage, options, function(err, mediumPictureUri) {
            if (err) {
                return callback(err);
            }

            // Files stored, save them to the DB
            return _saveCroppedPictureUris(ctx, principal, smallPictureUri, mediumPictureUri, callback);
        });
    });
};

/**
 * Saves the small and medium uris to cassandra and sticks them on the Principal Object
 *
 * @param  {Context}     ctx                 Context that holds the current user and tenant
 * @param  {Group|User}  principal           The principal object to update
 * @param  {String}      smallPictureUri     The URI for the small image
 * @param  {String}      mediumPictureUri    The URI for the large image
 * @param  {Object}      callback.err        An error that occurred, if any
 * @param  {Group|User}  callback.principal  The updated principal object
 * @api private
 */
var _saveCroppedPictureUris = function(ctx, principal, smallPictureUri, mediumPictureUri, callback) {
    // Apply the updates to the `principal` object
    var profileFields = {'smallPictureUri': smallPictureUri, 'mediumPictureUri': mediumPictureUri};
    PrincipalsDAO.updatePrincipal(principal.id, profileFields, function(err) {
        if (err) {
            return callback(err);
        }

        // Get the updated principal
        PrincipalsDAO.getPrincipal(principal.id, function(err, newPrincipal) {
            if (err) {
                return callback(err);
            }

            // Fire the appropriate update event, depending if the principal is a user or a group
            if (PrincipalsUtil.isUser(principal.id)) {
                PrincipalsEmitter.emit(PrincipalsConstants.events.UPDATED_USER, ctx, newPrincipal, principal);
            } else {
                PrincipalsEmitter.emit(PrincipalsConstants.events.UPDATED_GROUP, ctx, newPrincipal, principal);
            }

            return callback(null, newPrincipal);
        });
    });
};

/**
 * Checks if the current user can edit the principal. If they cannot edit the principal, a 401 error object
 * will be returned
 *
 * @param  {Context}     ctx                 Context that holds the current user and tenant
 * @param  {String}      principalId         The ID of the principal to check
 * @param  {Function}    callback            Standard callback function
 * @param  {Object}      callback.err        Standard error object
 * @api private
 */
var _canManagePrincipal = function(ctx, principalId, callback) {
    // Only the current user or an admin can update a user
    var principalResource = AuthzUtil.getResourceFromId(principalId);
    if ((PrincipalsUtil.isUser(principalId) && ctx.user().id === principalId) || ctx.user().isAdmin(principalResource.tenantAlias)) {
        return callback();
    // We'll need to check a group explicitly
    } else if (PrincipalsUtil.isGroup(principalId)) {
        GroupAPI.canManage(ctx, principalId, function(err, canManage) {
            if (err) {
                return callback(err);
            } else if (!canManage) {
                return callback({'code': 401, 'msg': 'You cannot update the picture of this group'});
            }

            return callback();
        });
    } else {
        return callback({'code': 401, 'msg': 'You cannot update the picture of this principal'});
    }
};

/**
 * Given a resource, timestamp, size and extension, return the storage options that will store
 * the resource picture into the appropriate directory
 *
 * @param  {String}         resourceId  The id of the resource for which to store the profile picture
 * @param  {Number|String}  timestamp   The timestamp (millis since the epoch) at which the picture is being stored
 * @param  {String}         size        The size of the picture, one of `small`, `medium` or `large`
 * @param  {String}         extension   The extension of the picture *including* the preceding period (e.g., `.jpg`)
 * @return {Object}                     The storage options object that can be used in the `StorageBackend.store` method
 * @api private
 */
var _getProfilePictureStorageOptions = function(resourceId, timestamp, size, extension) {
    return {
        'resourceId': resourceId,
        'prefix': util.format('profilepictures/%s', timestamp),
        'filename': size + extension
    };
};

/**
 * Removes temp file and logs an error statement.
 *
 * @param  {Object}      error           The error
 * @param  {TempFile}    file            The file that needs to be removed
 * @param  {Function}    callback        Standard callback function
 * @param  {Object}      callback.err    The passed in `error` object
 */
var _cleanupOnError = function(error, file, callback) {
    // If it's a TempFile who has a remove method
    if (file && file.remove) {
        file.remove(function(err) {
            if (err) {
                log().warn({'err': err}, 'Unable to remove an uploaded image.');
            }

            return callback(error);
        });

    // If it's an express file
    } else if (file && file.path) {
        fs.unlink(file.path, function(err) {
            if (err) {
                log().warn({'err': err}, 'Unable to remove an uploaded image.');
            }

            return callback(error);
        });
    } else {
        return callback(error);
    }
};
