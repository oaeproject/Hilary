/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var Validator = require('oae-util/lib/validator').Validator;

var OaeUtil = require('oae-util/lib/util');

var SearchConstants = require('oae-search/lib/constants').SearchConstants;
var SearchModel = require('oae-search/lib/model');

/**
 * Get the standard search parameters from the given request.
 *
 * @param   {Request}   req     The express Request object from which to extract the parameters.
 * @return  {Object}            The parameters extracted from the request that are relevant for search.
 */
var getSearchParams = module.exports.getSearchParams = function(req) {
    if (!req || !req.query) {
        return {};
    }

    return {
        'q': req.query.q,
        'start': req.query.start,
        'limit': req.query.limit,
        'sort': req.query.sort
    };
};

/**
 * Determine if the given parameter is a valid query parameter. If so, simply return the `val`, otherwise, return `defaultVal`.
 *
 * @param   {String}  val           The value to check
 * @param   {String}  [defaultVal]  The value to return if `val` is not valid. Defaults to `SearchConstants.query.ALL`
 * @return  {String}                `val` if it is valid. `defaultVal` otherwise.
 */
var getQueryParam = module.exports.getQueryParam = function(val, defaultVal) {
    defaultVal = defaultVal || SearchConstants.query.ALL;
    return val || defaultVal;
};

/**
 * Determine if the given parameter is a valid sort parameter. If so, simply return the `val`, otherwise, return `defaultVal`.
 *
 * @param   {String}  val           The value to check
 * @param   {String}  [defaultVal]  The value to return if `val` is not valid. Defaults to `SearchConstants.sort.ASC`
 * @return  {String}                `val` if it is valid. `defaultVal` otherwise.
 */
var getSortParam = module.exports.getSortParam = function(val, defaultVal) {
    defaultVal = _.contains(SearchConstants.sort.OPTIONS, defaultVal) ? defaultVal : SearchConstants.sort.ASC;
    return (val && _.contains(SearchConstants.sort.OPTIONS, val)) ? val : defaultVal;
};

/**
 * Transform the raw search `results` from ElasticSearch into a `SearchResult` that can be returned to the client.
 *
 * @param   {Context}       ctx                 The context of the current request
 * @param   {Object}        transformers        An object keyed by the resource type, and the value is the transformer object that can transform a set of search documents into client-viewable documents
 * @param   {Object}        results             The search results sent back from ElasticSearch
 * @param   {Function}      callback            Invoked when the process completes
 * @param   {Object}        callback.err        An error that occurred, if any
 * @param   {SearchResult}  callback.results    The search results that can be sent to the client
 */
var transformSearchResults = module.exports.transformSearchResults = function(ctx, transformers, results, callback) {
    var hits = results.hits;
    if (!hits || !hits.hits || !hits.hits.length) {
        return callback(null, new SearchModel.SearchResult(0, []));
    } else {

        // Aggregate all the documents to be keyed by type
        var total = hits.total;
        var docsByType = {};
        var docIdOrdering = {};
        hits = hits.hits;
        for (var i = 0; i < hits.length; i++) {
            var doc = hits[i];
            var id = doc._id;
            var type = doc.fields.resourceType;

            // If transformer does not exist, pass it through the default "raw" transformer
            if (!transformers[type]) {
                type = '*';
            }

            if (!docsByType[type]) {
                docsByType[type] = {};
            }
            docsByType[type][id] = doc;
            docIdOrdering[id] = i;
        }

        // Run all the documents through the document transformers for their particular type
        var transformersToRun = _.keys(docsByType).length;
        var transformersComplete = 0;
        var transformErr = null;
        var transformedDocs = {};
        var _monitorTransformers = function(err, resourceType, docs) {
            if (transformErr) {
                // Nothing to do, we've already returned because of an error.
            } else if (err) {
                transformErr = err;
                return callback(transformErr);
            } else {

                // If we aren't using the default transformer, ensure the resourceType property by merging it over the doc, it should never change and don't necessarily need to be manually applied by an extension transformer
                if (resourceType !== '*') {
                    var docIds = _.keys(docs);
                    for (var i = 0; i < docIds.length; i++) {
                        var doc = docs[docIds[i]];
                        doc.resourceType = resourceType;
                    }
                }

                // Merge the docs into the transformed docs
                _.extend(transformedDocs, docs);

                transformersComplete++;
                if (transformersComplete >= transformersToRun) {

                    // We've done all transformations, reorder the docs into the original search ordering and send back the response
                    var orderedDocs = _.values(transformedDocs);

                    // Reorder the docs using the ordering hash that was recorded before transformation
                    orderedDocs.sort(function(one, other) {
                        return docIdOrdering[one.id] - docIdOrdering[other.id];
                    });


                    return callback(null, new SearchModel.SearchResult(total, orderedDocs));
                }
            }
        };

        // Execute all transformers asynchronously from one another. _monitorTransformers will keep track fo their completion.
        _.keys(docsByType).forEach(function(type) {
            transformers[type](ctx, docsByType[type], (function(resourceType) {
                // We need to pass the resource type of this iteration on to the monitor
                return function(err, docs) {
                    _monitorTransformers(err, resourceType, docs);
                };
            })(type));
        });
    }
};

/**
 * Converts a query and (optionally) a filter into an appropriate ElasticSearch Query DSL object.
 *
 * @param   {Object}    query               The ElasticSearch query representation.
 * @param   {Object}    [filter]            The ElasticSearch filter to apply. If not specified, then the resulting object will be a simple query.
 * @param   {Object}    [opts]              A set of additional options for the query
 * @param   {Number}    [opts.start]        The starting index of the query for paging
 * @param   {Number}    [opts.limit]        The maximum number of documents to return
 * @param   {String}    [opts.sort]         The sort direction (asc or desc)
 * @param   {Number}    [opts.minScore]     The minimum score for a document to be included in the result set.
 * @return  {Object}                        A valid ElasticSearch Query object that can be sent as a query.
 * @throws  {Error}                         Thrown if the `query` parameter is not an object.
 */
var createQuery = module.exports.createQuery = function(query, filter, opts) {
    opts = opts || {};

    var validator = new Validator();
    validator.check(null, new Error('createQuery expects a query object.')).isObject(query);
    if (validator.hasErrors()) {
        log().error({'err': validator.getFirstError()}, 'Invalid input provided to SearchUtil.createQuery');
        throw validator.getFirstError();
    }

    var data = null;
    if (filter) {
        // If we have filters, we need to create a 'filtered' query
        data = {
            'query': {
                'filtered': {
                    'query': query,
                    'filter': filter
                }
            }
        };
    } else {
        // If it's just a query, we wrap it in a standard query.
        data = {
            'query': query
        };
    }

    // Strip the opts down to the relevant ElasticSearch parameters
    opts = {
        'from': OaeUtil.getNumberParam(opts.start),
        'size': OaeUtil.getNumberParam(opts.limit),
        'sort': [
            {'_score': {'order': 'desc'}},
            {'sort': getSortParam(opts.sort)}
        ],
        'min_score': (_.isNumber(opts.minScore)) ? opts.minScore : SearchConstants.query.MINIMUM_SCORE
    };

    return _.extend(data, opts);
};

/**
 * Create an ElasticSearch bulk index operation from the given array of documents. This splits up the documents automatically into the
 * meta / document sub-parts, and returns the array of documents that can be sent to the elasticsearchclient to be indexed. This does
 * not support bulk delete operations, as it is only for indexing operations.
 *
 * @param   {Object[]}      docs        An array of documents to be indexed
 * @return  {Object[]}      operations  The array of index operations that can be sent to ElasticSearch to perform all the indexing
 */
var createBulkIndexOperations = module.exports.createBulkIndexOperations = function(docs) {
    var cmds = [];

    for (var i = 0; i < docs.length; i++) {
        var doc = docs[i];
        var meta = {
            'index': {
                '_type': doc['_type'] || SearchConstants.resourceMappingName,
                '_id': doc['id'],
                '_parent': doc['_parent']
            }
        };

        // These meta attributes have been promoted and shouldn't be on the core doc anymore
        delete doc.id;
        delete doc._type;
        delete doc._parent;

        cmds.push(meta);
        cmds.push(doc);
    }

    return cmds;
};

/**
 * Create an ElasticSearch "ids" filter, from an array of ids.
 *
 * @param   {String[]}  ids     An array of ids to filter on
 * @return  {Object}            An ElasticSearch "ids" filter
 */
var filterIds = module.exports.filterIds = function(ids) {
    return {
        'ids': {
            'values': ids
        }
    };
};

/**
 * Create an ElasticSearch "exists" filter, which checks if the document has the specified field on it.
 *
 * @param   {String}  field     The field that should be present on the document
 * @return  {Object}            An ElasticSearch "exists" filter
 */
var filterExists = module.exports.filterExists = function(field) {
    return {
        'exists': {
          'field': field
        }
    };
};

/**
 * Create an ElasticSearch 'OR' filter, wrapped around multiple other filters.
 *
 * @param   {Object}  args*     The filter objects to "OR" together
 * @return  {Object}            An ElasticSearch "OR" filter.
 */
var filterOr = module.exports.filterOr = function(/* filter0, filter1, filter2, ... */) {
    if (arguments.length === 0) {
        return null;
    }

    return {'or': _.compact(arguments)};
};

/**
 * Create an ElasticSearch 'AND' filter, wrapped around multiple other filters.
 *
 * @param   {Object}  args*     The filter objects to "AND" together
 * @return  {Object}            An ElasticSearch "AND" filter.
 */
var filterAnd = module.exports.filterAnd = function(/* filter0, filter1, filter2, ... */) {
    if (arguments.length === 0) {
        return null;
    }

    return {'and': _.compact(arguments)};
};

/**
 * Create an ElasticSearch 'NOT' filter, wrapped around one filter.
 *
 * @param   {Object}    filter  The filter object to negate
 * @return  {Object}            An ElasticSearch "NOT" filter
 */
var filterNot = module.exports.filterNot = function(filter) {
    if (!filter) {
        return null;
    }
    return {'not': filter };
};

/**
 * Create an ElasticSearch 'terms' filter, wrapped around an array of values
 *
 * @param   {String}    field   The name of the field this term filters
 * @param   {String[]}  values  The values to filter on
 * @return  {Object}            An ElasticSearch 'terms' filter.
 */
var filterTerms = module.exports.filterTerms = function(field, values) {
    if (!values || values.length === 0) {
        return null;
    }

    var filter = {'terms': {}};
    filter.terms[field] = values;
    return filter;
};

/**
 * Create an ElasticSearch 'term' filter, wrapped around a value
 *
 * @param   {String}    field   The name of the field this term filters
 * @param   {String}    value   The value to match
 * @return  {Object}            An ElasticSearch 'term' filter.
 */
var filterTerm = module.exports.filterTerm = function(field, value) {
    if (!value) {
        return null;
    }

    var filter = {'term': {}};
    filter.term[field] = value;
    return filter;
};

/**
 * Create an ElasticSearch filter that will filter resource documents by their members.
 *
 * @param   {String[]}  members     The members by which to filter
 * @return  {Object}                An ElasticSearch filter that will filter by resource members
 */
var filterMembers = module.exports.filterMembers = function(members) {
    if (!members) {
        return null;
    }

    return {
        'has_child': {
            'type': SearchConstants.resourceMembersMappingName,
            'query': filterTerms('direct_members', members)
        }
    };
};

/**
 * Create an ElasticSearch filter that will filter resource documents by their memberships.
 *
 * @param   {String[]}  memberships The memberships by which to filter
 * @return  {Object}                An ElasticSearch filter that will filter by resource memberships
 */
var filterMemberships = module.exports.filterMemberships = function(memberships) {
    if (!memberships) {
        return null;
    }

    return {
        'has_child': {
            'type': SearchConstants.resourceMembershipsMappingName,
            'query': filterTerms('direct_memberships', memberships)
        }
    };
};

/**
 * Create a full-text query object (just the query portion, not filter) for ElasticSearch from the provided
 * user input. This ensures that the query will be a safe keyword search that supports both "everything" (e.g., *)
 * and user-input search terms.
 *
 * @param   {String}    q       The user-input query to search with
 * @return  {Object}            A Query object that can be used in the query portion of the ElasticSearch Query DSL
 */
var createQueryStringQuery = module.exports.createQueryStringQuery = function(q) {
    q = getQueryParam(q);
    if (q === SearchConstants.query.ALL) {
        // We're searching everything, use query_string syntax
        return {
            'query_string': {
                'fields': ['q_high^2.0', 'q_low^0.5'],
                'query': SearchConstants.query.ALL
            }
        };
    } else {
        // Build a query that will do a full-text search on the "q" fields, giving favour to matches on the title
        return {
            'multi_match': {
                'fields': ['q_high^2.0', 'q_low^0.5'],
                'query': q
            }
        };
    }
};

/**
 * Create a more-like-this query object (just the query portion, not filter) for ElasticSearch from the provided
 * user input.
 * @see http://www.elasticsearch.org/guide/reference/query-dsl/mlt-query.html
 *
 * @param  {String}    like_val     The text that should be fuzzified and to match documents against.
 * @param  {String[]}  [fields]     An array of fields that should match the like_val text. If left blank, the "q_high" field will be used.
 * @return {Object}                 A Query object that can be used in the query portion of the ElasticSearch Query DSL
 */
var createMoreLikeThisQuery = module.exports.createMoreLikeThisQuery = function(val, fields) {
    fields = (!fields || fields.length === 0) ? ['q_high'] : fields;
    return {
        'more_like_this' : {
            'fields' : fields,
            'like_text' : val,
            'min_term_freq': 1,
            'min_doc_freq': 1

        }
    };
};

/**
 * Given a resource document id, return the expected id of its resource members child document.
 *
 * @param   {String}    docId   The id of the parent resource document
 * @return  {String}            The id of the members document. If `docId` is not specified, `undefined` will be returned
 */
var getResourceMembersDocumentId = module.exports.getResourceMembersDocumentId = function(docId) {
    return docId ? docId + '#members' : undefined;
};

/**
 * Given a principal resource document id, return the expected id of its group memberships child document.
 *
 * @param   {String}    docId   The id of the parent resource document
 * @return  {String}            The id of the memberships document. If `docId` is not specified, `undefined` will be returned
 */
var getResourceMembershipsDocumentId = module.exports.getResourceMembershipsDocumentId = function(docId) {
    return docId ? docId + '#memberships' : undefined;
};
