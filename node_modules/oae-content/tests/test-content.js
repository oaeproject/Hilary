/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');
var fs = require('fs');
var temp = require('temp');

var AuthzAPI = require('oae-authz');
var Config = require('oae-config').config('oae-content');
var ConfigTestUtil = require('oae-config/lib/test/util');
var MQ = require('oae-util/lib/mq');
var PreviewConstants = require('oae-preview-processor/lib/constants');
var RestAPI = require('oae-rest');
var RestContext = require('oae-rest/lib/model').RestContext;
var RestUtil = require('oae-rest/lib/util');
var TestsUtil = require('oae-tests');
var User = require('oae-principals/lib/model.user').User;

describe('Content', function() {

    // Rest context that can be used every time we need to make a request as an anonymous user
    var anonymousRestContext = null;
    // Rest contexts that can be used every time we need to make a request as a tenant admin
    var camAdminRestContext = null;
    var gtAdminRestContext = null;
    // Rest context that can be used every time we need to make a request as a global admin
    var globalAdminRestContext = null;

    /**
     * Function that will fill up the anonymous and tenant admin REST context
     */
    before(function(callback) {
        // Fill up anonymous rest context
        anonymousRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host);
        // Fill up tenant admin rest contexts
        camAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.cam.host);
        gtAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.gt.host);
        // Fill up global admin rest context
        globalAdminRestContext = TestsUtil.createGlobalAdminRestContext();

        // Log in the tenant admin so his cookie jar is set up appropriately. This is because TestsUtil.generateTestUsers
        // will concurrently try and create users, which causes race conditions when trying to authenticate the rest
        // context.
        RestAPI.User.getMe(camAdminRestContext, function(err, meObj) {
            assert.ok(!err);

            // Unbind the current handler, if any
            MQ.unbind(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, function(err) {
                assert.ok(!err);

                /*!
                 * Task handler that will just drain the queue.
                 *
                 * @see MQ#bind
                 */
                var _handleTaskDrain = function(data, mqCallback) {
                    // Simply callback, which acknowledges the message without doing anything.
                    mqCallback();
                };

                // Drain the queue
                MQ.bind(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, _handleTaskDrain, null, function(err) {
                    assert.ok(!err);
                    callback();
                });
            });
        });
    });

    /**
     * Function that will clean up any files that we have lingering around.
     */
    after(function() {
        temp.cleanup();
    });


    /**
     * Create a number of users that will be used inside of a test
     * @param  {Function(contexts)}  callback           Standard callback function
     * @param  {Object}              callback.contexts  Object where the keys are identifiers for the created users and the values are an
     *                                                  object with a user key containing the user object for the created user and a restContext key
     *                                                  containing the REST Context for that user
     */
    var setUpUsers = function(callback) {
        var contexts = {};
        var createUser = function(identifier, visibility, displayName) {
            var userId = TestsUtil.generateTestUserId(identifier);
            RestAPI.User.createUser(camAdminRestContext, userId, 'password', displayName, {'visibility': visibility}, function(err, createdUser) {
                if (err) {
                    assert.fail('Could not create test user');
                }
                contexts[identifier] = {
                    'user': createdUser,
                    'restContext': TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, userId, 'password')
                };
                if (_.keys(contexts).length === 6) {
                    callback(contexts);
                }
            });
        };
        
        createUser('nicolaas', 'public', 'Nicolaas Matthijs');
        createUser('simon', 'loggedin', 'Simon Gaeremynck');
        createUser('bert', 'private', 'Bert Pareyn');
        createUser('branden', 'private', 'Branden Visser');
        createUser('anthony', 'public', 'Anthony Whyte');
        createUser('stuart', 'public', 'Stuart Freeman');
    };

    /**
     * Create a number of groups that will be used inside of a test
     * @param  {Array<Context>}      contexts           Array of contexts that represent the users that will be used in the test
     * @param  {Function(groups)}    callback           Standard callback function
     * @param  {Object}              callback.groups    JSON Object where the keys are the group identifiers and the values are the
     *                                                  actual group object
     */
     var setUpGroups = function(contexts, callback) {
        var groups = {};
        // Create UI Dev Group
        // Make Bert a member
        RestAPI.Group.createGroup(contexts['nicolaas'].restContext, TestsUtil.generateTestGroupId('ui-team'), 'UI Dev Team', 'UI Dev Group', 'public', 'yes', [], [contexts['bert'].user.id], function(err, groupObj) {
            groups['ui-team'] = groupObj;
            // Create Back-end Dev Group
            // Make Simon a member
            var simonMember = {};
            simonMember = 'member';
            RestAPI.Group.createGroup(contexts['branden'].restContext, TestsUtil.generateTestGroupId('backend-team'), 'Back-end Dev Team', 'Back-end Dev Group', 'public', 'yes', [], [contexts['simon'].user.id], function(err, groupObj) {
                groups['backend-team'] = groupObj;
                // Create OAE Team Group
                // Make Stuart, UI Dev Group and Back-end Dev Group all members
                RestAPI.Group.createGroup(contexts['anthony'].restContext, TestsUtil.generateTestGroupId('oae-team'), 'OAE Team', 'OAE Team Group', 'public', 'yes', [], [groups['ui-team'].id, groups['backend-team'].id, contexts['stuart'].user.id], function(err, groupObj) {
                    groups['oae-team'] = groupObj;
                    callback(groups);
                });
            });
        });
    };

    /**
     * Run a number of asserts on a piece of content. This function checks whether a user has access to the content and
     * whether or not it can be seen in the library of the creator
     * @param  {RestContext}        restCtx             Standard REST Context object that contains the current tenant URL and the current
     *                                                  user credentials
     * @param  {String}             creator             The user id for which we want to check the library
     * @param  {Content}            contentObj          The content object we'll be running checks for
     * @param  {Boolean}            expectAccess        Whether or not we expect the current user to have access to the piece of content
     * @param  {Boolean}            expectManager       Whether or not we expect the current user to be able to manage the piece of content
     * @param  {Boolean}            expectInLibrary     Whether or not we expect the current user to see the item in the creator's library
     * @param  {Function}           callback            Standard callback function executed when all checks have finished
     */
    var checkPieceOfContent = function(restCtx, libraryToCheck, contentObj, expectAccess, expectManager, expectInLibrary, callback) {
        // Check whether the content can be retrieved
        RestAPI.Content.getContent(restCtx, contentObj.id, function(err, retrievedContent) {
            if (expectAccess) {
                assert.ok(!err);
                assert.ok(retrievedContent.id);
                assert.equal(retrievedContent.tenant, contentObj.tenant);
                assert.equal(retrievedContent.visibility, contentObj.visibility);
                assert.equal(retrievedContent.displayName, contentObj.displayName);
                assert.equal(retrievedContent.description, contentObj.description);
                assert.equal(retrievedContent.resourceSubType, contentObj.resourceSubType);
                assert.equal(retrievedContent.createdBy.id, contentObj.createdBy);
                assert.equal(retrievedContent.created, contentObj.created);
                assert.ok(retrievedContent.lastModified);
                assert.equal(retrievedContent.resourceType, 'content');
                assert.equal(retrievedContent.profilePath, '/content/' + contentObj.id);
                // Check if the canManage check is appropriate
                assert.equal(retrievedContent.isManager, expectManager);
            } else {
                assert.ok(err);
                assert.ok(!retrievedContent);
            }
            // Check if the item comes back in the library
            RestAPI.Content.getLibrary(restCtx, libraryToCheck, null, 10, function(err, contentItems) {
                // If no logged in user is provided, we expect an error
                if (!libraryToCheck) {
                    assert.ok(err);
                } else {
                    assert.ok(!err);
                    if (expectInLibrary) {
                        assert.equal(contentItems.results.length, 1);
                        assert.equal(contentItems.results[0].id, contentObj.id);
                    } else {
                        assert.equal(contentItems.results.length, 0);
                    }
                }
                callback();
            });
        });
    };

    /**
     * @return {Stream}     A stream that points to sakaiger that can be uploaded.
     */
    var getFileStream = function() {
        var file = __dirname + '/data/sakaiger.png';
        return fs.createReadStream(file);
    };

    /**
     * @return {Stream}     A stream that points to the sakai logo that can be uploaded.
     */
    var getSakaiLogoStream = function() {
        var file = __dirname + '/data/sakai-logo.png';
        return fs.createReadStream(file);
    };

    describe('Get content', function() {

        /** 
         * Test that will create a piece of content and try to get it in an invalid
         * and valid way
         */
        it('verify get content', function(callback) {
            setUpUsers(function(contexts) {
                // Create a piece of content
                RestAPI.Content.createLink(contexts['nicolaas'].restContext, 'Test Content 1', 'Test content description 1', 'public', 'http://www.sakaiproject.org/',  [], [], function(err, contentObj) {
                    assert.ok(!err);
                    assert.ok(contentObj);

                    // Try with a missing ID (send a space as otherwise it won't even hit the endpoint)
                    RestAPI.Content.getContent(contexts['nicolaas'].restContext, ' ', function(err, retrievedContentObj) {
                        assert.equal(err.code, 400);
                        assert.ok(!retrievedContentObj);

                        // Try with an invalid ID.
                        RestAPI.Content.getContent(contexts['nicolaas'].restContext, 'invalid-id', function(err, retrievedContentObj) {
                            assert.equal(err.code, 400);
                            assert.ok(!retrievedContentObj);

                            // Get the created piece of content
                            RestAPI.Content.getContent(contexts['nicolaas'].restContext, contentObj.id, function(err, retrievedContentObj) {
                                assert.ok(!err);
                                assert.equal(retrievedContentObj.id, contentObj.id);
                                callback();
                            });
                        });
                    });
                });
            });
        });
    });

    describe('Download content', function() {

        /**
         * Test that will create a piece of content and try to download it in an invalid
         * and valid way.
         */
        it ('verify download content', function(callback) {
            setUpUsers(function(contexts) {
                // Create a piece of content
                RestAPI.Content.createFile(contexts['nicolaas'].restContext, 'Test Content 1', 'Test content description 1', 'private', getFileStream,  [], [], function(err, contentObj) {
                    assert.ok(!err);
                    assert.ok(contentObj);

                    // Verify that the download link gets added to a content object.
                    RestAPI.Content.getContent(contexts['nicolaas'].restContext, contentObj.id, function(err, contentObj) {
                        assert.ok(!err);
                        assert.equal(contentObj.downloadPath, '/api/content/' + contentObj.id + '/download');

                        // Download it.
                        // The App servers don't really stream anything.
                        // In the tests we're using local storage, so this should result in a 204 (empty body) with the link in the x-accel-redirect header.
                        var path = temp.path();
                        RestAPI.Content.download(contexts['nicolaas'].restContext, contentObj.id, null, path, function(err, response) {
                            assert.ok(!err);
                            var headerKeys = _.keys(response.headers);
                            assert.ok(headerKeys.indexOf('x-accel-redirect') !== -1);
                            assert.ok(headerKeys.indexOf('x-sendfile') !== -1);
                            assert.ok(headerKeys.indexOf('x-lighttpd-send-file') !== -1);

                            // Try downloading it as Simon
                            RestAPI.Content.download(contexts['simon'].restContext, contentObj.id, null, path, function(err, body) {
                                assert.equal(err.code, 401);

                                // Share it.
                                RestAPI.Content.shareContent(contexts['nicolaas'].restContext, contentObj.id, [contexts['simon'].user.id], function(err) {
                                    assert.ok(!err);

                                    // Simon should now be able to fetch it.
                                    path = temp.path();
                                    RestAPI.Content.download(contexts['simon'].restContext, contentObj.id, null, path, function(err, response) {
                                        assert.ok(!err);
                                        var headerKeys = _.keys(response.headers);
                                        assert.ok(headerKeys.indexOf('x-accel-redirect') !== -1);
                                        assert.ok(headerKeys.indexOf('x-sendfile') !== -1);
                                        assert.ok(headerKeys.indexOf('x-lighttpd-send-file') !== -1);
                                        callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that will create different versions piece of content and try to download it in an invalid
         * and valid way.
         */
        it('verify versioned download content', function(callback) {
            setUpUsers(function(contexts) {
                // Create a piece of content
                RestAPI.Content.createFile(contexts['nicolaas'].restContext, 'Test Content 1', 'Test content description 1', 'private', getFileStream,  [], [], function(err, contentObj) {
                    assert.ok(!err);
                    assert.ok(contentObj);

                    // Create a new version
                    RestAPI.Content.updateFileBody(contexts['nicolaas'].restContext, contentObj.id, getSakaiLogoStream, function(err) {
                        assert.ok(!err);

                        RestAPI.Content.getRevisions(contexts['nicolaas'].restContext, contentObj.id, null, null, function(err, revisions) {
                            assert.ok(!err);
                            assert.equal(revisions.length, 2);

                            // Download the latest version.
                            var path = temp.path();
                            RestAPI.Content.download(contexts['nicolaas'].restContext, contentObj.id, null, path, function(err, response) {
                                assert.ok(!err);
                                assert.equal(response.statusCode, 204);
                                var url = response.headers['x-accel-redirect'];

                                // Download the oldest version.
                                path = temp.path();
                                RestAPI.Content.download(contexts['nicolaas'].restContext, contentObj.id, revisions[1].revisionId, path, function(err, response) {
                                    assert.ok(!err);
                                    assert.equal(response.statusCode, 204);
                                    var oldUrl = response.headers['x-accel-redirect'];
                                    assert.notEqual(url, oldUrl);
                                    callback();
                                });
                            });
                        });
                    });
                });
            });
        });

        /*
         * Test that will verify the validation of signed urls.
         */
        it('verify validation of signed urls', function(callback) {
            var params = {
                'uri': 'local:2012/12/06',
                'signature': 'foobar',
                'expires': Date.now() + 1000
            };
            RestUtil.RestRequest(anonymousRestContext, '/api/download/signed', 'GET', params, function(err, body, request) {
                assert.equal(err.code, 401);

                // Missing uri.
                params = {
                    'signature': 'foobar',
                    'expires': Date.now() + 1000
                };
                RestUtil.RestRequest(anonymousRestContext, '/api/download/signed', 'GET', params, function(err, body, request) {
                    assert.equal(err.code, 400);

                    // Missing signature.
                    params = {
                        'uri': 'local:2012/12/06',
                        'expires': Date.now() + 1000
                    };
                    RestUtil.RestRequest(anonymousRestContext, '/api/download/signed', 'GET', params, function(err, body, request) {
                        assert.equal(err.code, 400);
                        callback();
                    });
                });
            });
        });
    });

    describe('Tenant separation', function() {

        /**
         * Test that verifies that a user can access a public content item from an external tenant
         */
        it('verify user can access public content from external tenant', function(callback) {
            var usernameA = TestsUtil.generateTestUserId();
            var usernameB = TestsUtil.generateTestUserId();

            // Create user in tenant A (cam)
            RestAPI.User.createUser(camAdminRestContext, usernameA, 'password', 'Public User', null, function(err, userA) {
                assert.ok(!err);
                var restCtxA = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, usernameA, 'password');

                // Create user in tenant B (gt)
                RestAPI.User.createUser(gtAdminRestContext, usernameB, 'password', 'Private User', null, function(err, userB) {
                    assert.ok(!err);
                    var restCtxB = TestsUtil.createTenantRestContext(global.oaeTests.tenants.gt.host, usernameB, 'password');

                    // Create content in tenant B
                    RestAPI.Content.createLink(restCtxB, 'Google', 'Google Website', 'public', 'http://google.com', [userB.id], [], function(err, contentB) {
                        assert.ok(!err);

                        // Access content in tenant B as user from tenant A, it should succeed because content B is public
                        RestAPI.Content.getContent(restCtxA, contentB.id, function(err, contentObj) {
                            assert.ok(!err);
                            assert.ok(contentObj);
                            assert.equal(contentB.id, contentObj.id);
                            callback();
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies a user is unable to access a content item with visibility "loggedin" that belongs to an external tenant.
         */
        it('verify user cannot access loggedin content from external public tenants', function(callback) {
            var usernameA = TestsUtil.generateTestUserId();
            var usernameB = TestsUtil.generateTestUserId();

            // Create user in tenant A (cam)
            RestAPI.User.createUser(camAdminRestContext, usernameA, 'password', 'Public User', null, function(err, userA) {
                assert.ok(!err);
                var restCtxA = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, usernameA, 'password');
                
                // Create user in tenant B (gt)
                RestAPI.User.createUser(gtAdminRestContext, usernameB, 'password', 'Private User', null, function(err, userB) {
                    assert.ok(!err);
                    var restCtxB = TestsUtil.createTenantRestContext(global.oaeTests.tenants.gt.host, usernameB, 'password');

                    // Create "loggedin" content in tenant B
                    RestAPI.Content.createLink(restCtxB, 'Google', 'Google Website', 'loggedin', 'http://google.com', [userB.id], [], function(err, contentB) {
                        assert.ok(!err);

                        // Access content from tenant B as user A. Should fail because content B is "loggedin" and is cross-tenant.
                        RestAPI.Content.getContent(restCtxA, contentB.id, function(err, contentObj) {
                            assert.ok(err);
                            assert.equal(err.code, 401);
                            callback();
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that a content item from a public tenant can be shared with a user from a different public tenant
         */
        it('verify user can share from one public tenant to another', function(callback) {
            var usernameA = TestsUtil.generateTestUserId();
            var usernameB = TestsUtil.generateTestUserId();

            // Create user in tenant A (cam)
            RestAPI.User.createUser(camAdminRestContext, usernameA, 'password', 'Public User', null, function(err, userA) {
                assert.ok(!err);
                var restCtxA = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, usernameA, 'password');

                // Create user in tenant B (gt)
                RestAPI.User.createUser(gtAdminRestContext, usernameB, 'password', 'Private User', null, function(err, userB) {
                    assert.ok(!err);
                    var restCtxB = TestsUtil.createTenantRestContext(global.oaeTests.tenants.gt.host, usernameB, 'password');

                    // Create "loggedin" content in tenant B
                    RestAPI.Content.createLink(restCtxB, 'Google', 'Google Website', 'loggedin', 'http://google.com', [userB.id], [], function(err, contentB) {
                        assert.ok(!err);

                        // User B shares the "loggedin" content with user from tenant A
                        RestAPI.Content.shareContent(restCtxB, contentB.id, [userA.id], function(err) {
                            assert.ok(!err);

                            // User A access content B. Now it is shared, should be accessible
                            RestAPI.Content.getContent(restCtxA, contentB.id, function(err, contentObj) {
                                assert.ok(!err);
                                assert.ok(contentObj);
                                assert.equal(contentB.id, contentObj.id);
                                callback();
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that a user from a private tenant cannot share content to users from other tenants
         */
        it('verify user from private tenant cannot share to public external tenant', function(callback) {
            var tenantAliasB = TestsUtil.generateTestUserId();
            var usernameA = TestsUtil.generateTestUserId();

            // Create user in tenant A
            RestAPI.User.createUser(camAdminRestContext, usernameA, 'password', 'Public User', null, function(err, userA) {
                assert.ok(!err);
                var restCtxA = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, usernameA, 'password');

                // Create tenant B
                TestsUtil.createTenantWithAdmin(tenantAliasB, tenantAliasB, function(err, tenantB, adminBRestContext) {
                    assert.ok(!err);
                    var usernameB = TestsUtil.generateTestUserId();

                    // Make tenant B private
                    ConfigTestUtil.updateConfigAndWait(globalAdminRestContext, tenantAliasB, 'oae-tenants/tenantprivacy/tenantprivate', true, function(err) {
                        assert.ok(!err);

                        // Create user in tenant B
                        RestAPI.User.createUser(adminBRestContext, usernameB, 'password', 'Private User', null, function(err, userB) {
                            assert.ok(!err);
                            var restCtxB = TestsUtil.createTenantRestContext(tenantAliasB, usernameB, 'password');

                            // Create "loggedin" content in tenant B
                            RestAPI.Content.createLink(restCtxB, 'Google', 'Google Website', 'loggedin', 'http://google.com', [userB.id], [], function(err, contentB) {
                                assert.ok(!err);

                                // User B shares the "loggedin" content with user from tenant A. It fails because tenant B is private
                                RestAPI.Content.shareContent(restCtxB, contentB.id, [userA.id], function(err) {
                                    assert.ok(err);
                                    assert.equal(err.code, 401);

                                    // User A accesses content A. Will fail because it is loggedin
                                    RestAPI.Content.getContent(restCtxA, contentB.id, function(err, contentObj) {
                                        assert.ok(err);
                                        assert.equal(err.code, 401);
                                        assert.ok(!contentObj);
                                        callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that content cannot be shared to a user from an external private tenant
         */
        it('verify user from public tenant cannot share to private external tenant', function(callback) {
            var tenantAliasB = TestsUtil.generateTestUserId();
            var usernameA = TestsUtil.generateTestUserId();

            // Create user in tenant A
            RestAPI.User.createUser(camAdminRestContext, usernameA, 'password', 'Public User', null, function(err, userA) {
                assert.ok(!err);
                var restCtxA = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, usernameA, 'password');

                // Create tenant B
                TestsUtil.createTenantWithAdmin(tenantAliasB, tenantAliasB, function(err, tenantB, adminRestCtxB) {
                    assert.ok(!err);
                    var usernameB = TestsUtil.generateTestUserId();

                    // Make tenant B private
                    ConfigTestUtil.updateConfigAndWait(globalAdminRestContext, tenantAliasB, 'oae-tenants/tenantprivacy/tenantprivate', true, function(err) {
                        assert.ok(!err);

                        // Create user in tenant B
                        RestAPI.User.createUser(adminRestCtxB, usernameB, 'password', 'Private User', null, function(err, userB) {
                            assert.ok(!err);
                            var restCtxB = TestsUtil.createTenantRestContext(tenantAliasB, usernameB, 'password');

                            // Create "loggedin" content in tenant A
                            RestAPI.Content.createLink(restCtxA, 'Google', 'Google Website', 'loggedin', 'http://google.com', [userA.id], [], function(err, contentA) {
                                assert.ok(!err);

                                // User A shares the "loggedin" content with user from tenant B. It fails because B is private
                                RestAPI.Content.shareContent(restCtxA, contentA.id, [userB.id], function(err) {
                                    assert.ok(err);
                                    assert.equal(err.code, 401);

                                    // User B access content A, but it should not be accessible because the share failed
                                    RestAPI.Content.getContent(restCtxB, contentA.id, function(err, contentObj) {
                                        assert.ok(err);
                                        assert.equal(err.code, 401);
                                        assert.ok(!contentObj);
                                        callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that a user from an external tenant is limited to only the public content library of users
         */
        it('verify user sees only public libraries of external tenant users', function(callback) {
            var tenantAliasB = TestsUtil.generateTestUserId();
            var usernameA = TestsUtil.generateTestUserId();
            var usernameA2 = TestsUtil.generateTestUserId();
            var usernameB = TestsUtil.generateTestUserId();

            // Create user in tenant A (cam)
            RestAPI.User.createUser(camAdminRestContext, usernameA, 'password', 'Public User', null, function(err, userA) {
                assert.ok(!err);
                var restCtxA = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, usernameA, 'password');

                // Create a second user in tenant A (A2)
                RestAPI.User.createUser(camAdminRestContext, usernameA2, 'password', 'Public User A2', null, function(err, userA2) {
                    assert.ok(!err);
                    var restCtxA2 = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, usernameA2, 'password');

                    // Create user in tenant B (gt)
                    RestAPI.User.createUser(gtAdminRestContext, usernameB, 'password', 'Private User', null, function(err, userB) {
                        assert.ok(!err);
                        var restCtxB = TestsUtil.createTenantRestContext(global.oaeTests.tenants.gt.host, usernameB, 'password');

                        // Create "public" content in tenant A
                        RestAPI.Content.createLink(restCtxA, 'Yahoo', 'Yahoo Website', 'public', 'http://www.yahoo.ca', [userA.id], [], function(err, publicContentA) {
                            assert.ok(!err);

                            // Create "loggedin" content in tenant A
                            RestAPI.Content.createLink(restCtxA, 'Google', 'Google Website', 'loggedin', 'http://google.com', [userA.id], [], function(err, loggedInContentA) {
                                assert.ok(!err);

                                // Verify user A2 can see both public and logged in content items
                                RestAPI.Content.getLibrary(restCtxA2, userA.id, null, 10, function(err, libraryA) {
                                    assert.ok(!err);
                                    assert.equal(libraryA.results.length, 2);

                                    // Verify user B cannot see the loggedin content item, but can see the public content item
                                    RestAPI.Content.getLibrary(restCtxB, userA.id, null, 10, function(err, libraryA) {
                                        assert.ok(!err);
                                        assert.equal(libraryA.results.length, 1);
                                        assert.equal(libraryA.results[0].id, publicContentA.id);
                                        callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that users from an external tenant are limited to a group's public content library
         */
        it('verify user sees only public library of external tenant groups', function(callback) {
            var usernameA = TestsUtil.generateTestUserId();
            var groupNameA = TestsUtil.generateTestUserId();
            var usernameB = TestsUtil.generateTestUserId();

            // Create user in tenant A (cam)
            RestAPI.User.createUser(camAdminRestContext, usernameA, 'password', 'Public User', null, function(err, userA) {
                assert.ok(!err);
                var restCtxA = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, usernameA, 'password');

                // Create a group in tenant A
                RestAPI.Group.createGroup(restCtxA, groupNameA, groupNameA, groupNameA, 'public', 'no', [], [], function(err, groupA) {
                    assert.ok(!err);

                    // Create user in tenant B (gt)
                    RestAPI.User.createUser(gtAdminRestContext, usernameB, 'password', 'Private User', null, function(err, userB) {
                        assert.ok(!err);
                        restCtxB = TestsUtil.createTenantRestContext(global.oaeTests.tenants.gt.host, usernameB, 'password');

                        // Create "public" content in tenant A
                        RestAPI.Content.createLink(restCtxA, 'Yahoo', 'Yahoo Website', 'public', 'http://www.yahoo.ca', [userA.id], [groupA.id], function(err, publicContentA) {
                            assert.ok(!err);

                            // Create "loggedin" content in tenant A
                            RestAPI.Content.createLink(restCtxA, 'Google', 'Google Website', 'loggedin', 'http://google.com', [userA.id], [groupA.id], function(err, loggedInContentA) {
                                assert.ok(!err);

                                // Verfy user A can see both public and logged in content items for the group
                                RestAPI.Content.getLibrary(restCtxA, groupA.id, null, 10, function(err, libraryA) {
                                    assert.ok(!err);
                                    assert.equal(libraryA.results.length, 2);

                                    // Verify user B cannot see the loggedin content item, but can see the public content item
                                    RestAPI.Content.getLibrary(restCtxB, groupA.id, null, 10, function(err, libraryB) {
                                        assert.ok(!err);
                                        assert.equal(libraryB.results.length, 1);
                                        assert.equal(libraryB.results[0].id, publicContentA.id);
                                        callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    describe('Content comments', function() {

        /**
         * Posts a given number of comments on a content item. A random commenter and comment are picked for each comment.
         *
         * @param {Object}    contexts       Object containing REST Contexts
         * @param {String}    contentId      The ID of the content to comment on
         * @param {Number}    numComments    Number of comments to place on the content item
         * @param {String}    [replyTo]      The ID of the comment to reply to
         * @param {Function}  callback       Standard callback function executed when all checks have finished
         */
        var createComments = function(contexts, contentId, numComments, replyTo, callback) {

            var done = 0;
            var contexts = _.toArray(contexts);

            /**
             * Returns a random comment from a predefined list of comments
             * @return    {String}    Random comment to place on the content item
             */
            var getRandomComment = function() {
                var commentArr = [
                    'Thank you for sharing this with the rest of us.',
                    'I added some annotations to help you along.',
                    'This is not the comment you are looking for.',
                    'I\'m bookmarking this!',
                    'Nice work, thanks!',
                    'If only this widget had an upvote button'
                ];
                return commentArr[Math.floor(Math.random() * commentArr.length)];
            };

            /**
             * Returns a random user REST Context from the contexts passed in to `createComments`
             * @return {RestContext}    REST Context object for a user
             */
            var getRandomCommenter = function() {
                return contexts[Math.floor(Math.random() * contexts.length)].restContext;
            };

            /**
             * Verifies that the comment was created successfully and triggers the creation of another comment if necessary.
             * @param {Object}   err   Error object indicating that the comment was successfully created or not.
             */
            var commentCreated = function(err, comment) {
                assert.ok(!err);
                assert.ok(comment);
                if (done !== numComments) {
                    done++;
                    createComment();
                } else {
                    callback();
                }
            };

            /**
             * Posts a comment on a specified contentId and uses a random commenter and comment
             */
            var createComment = function() {
                RestAPI.Content.createComment(getRandomCommenter(), contentId, getRandomComment(), replyTo, commentCreated);
            };

            done++;
            createComment();

        };

        /**
         * Test that will create a comment on content
         */
        it('verify create comment', function(callback) {
            setUpUsers(function(contexts) {
                // Create a piece of content
                RestAPI.Content.createLink(contexts['bert'].restContext, 'Test Content 1', 'Test content description 1', 'public', 'http://www.sakaiproject.org/',  [], [], function(err, contentObj) {
                    assert.ok(!err);
                    assert.ok(contentObj);

                    // Get the created piece of content
                    RestAPI.Content.getContent(contexts['bert'].restContext, contentObj.id, function(err, retrievedContentObj) {
                        assert.ok(!err);
                        assert.equal(retrievedContentObj.id, contentObj.id);

                        // Create 10 comments
                        createComments(contexts, contentObj.id, 10, null, function() {

                            // Create one more and verify that it comes back as the first comment in the list
                            RestAPI.Content.createComment(contexts['bert'].restContext, contentObj.id, 'This comment should be on top of the list', null, function(err, comment) {
                                assert.ok(!err);
                                assert.equal(comment.createdBy.publicAlias, 'Bert Pareyn');
                                assert.equal(comment.level, 0);
                                assert.equal(comment.body, 'This comment should be on top of the list');
                                assert.equal(comment.contentId, contentObj.id);
                                assert.ok(comment.commentId);
                                assert.ok(comment.created);

                                // Get the comments and verify that the item on top of the list is the correct one
                                RestAPI.Content.getComments(contexts['bert'].restContext, contentObj.id, null, 10, function(err, comments) {
                                    assert.ok(!err);
                                    assert.equal(comments.results.length, 10);
                                    assert.equal(comments.results[0].createdBy.publicAlias, 'Bert Pareyn');
                                    assert.equal(comments.results[0].level, 0);
                                    assert.equal(comments.results[0].body, 'This comment should be on top of the list');
                                    assert.equal(comment.contentId, contentObj.id);
                                    assert.ok(comment.commentId);
                                    assert.ok(comment.created);
                                    callback();
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that will create a reply to a comment on content (thread)
         */
        it('verify reply to comment (threaded)', function(callback) {
            setUpUsers(function(contexts) {
                // Create a piece of content
                RestAPI.Content.createLink(contexts['bert'].restContext, 'Test Content 1', 'Test content description 1', 'public', 'http://www.sakaiproject.org/',  [], [], function(err, contentObj) {
                    assert.ok(!err);
                    assert.ok(contentObj);

                    // Get the created piece of content
                    RestAPI.Content.getContent(contexts['bert'].restContext, contentObj.id, function(err, retrievedContentObj) {
                        assert.ok(!err);
                        assert.equal(retrievedContentObj.id, contentObj.id);

                        // Create a comment on the content item
                        RestAPI.Content.createComment(contexts['bert'].restContext, contentObj.id, 'This comment should be second in the list', null, function(err, comment) {
                            assert.ok(!err);
                            assert.ok(comment);

                            // Get the comments to verify that it's been placed correctly
                            RestAPI.Content.getComments(contexts['bert'].restContext, contentObj.id, null, 10, function(err, comments) {
                                assert.ok(!err);
                                assert.equal(comments.results.length, 1);
                                assert.equal(comments.results[0].createdBy.publicAlias, 'Bert Pareyn');

                                // Add a reply to the comment
                                RestAPI.Content.createComment(contexts['bert'].restContext, contentObj.id, 'Reply to second comment in the list', comments.results[0].commentId, function(err, comment) {
                                    assert.ok(!err);
                                    assert.equal(comment.createdBy.publicAlias, 'Bert Pareyn');
                                    assert.equal(comment.level, 1);
                                    assert.equal(comment.body, 'Reply to second comment in the list');
                                    assert.equal(comment.contentId, contentObj.id);
                                    assert.ok(comment.commentId);
                                    assert.ok(comment.created);

                                    RestAPI.Content.getComments(contexts['bert'].restContext, contentObj.id, null, 10, function(err, comments) {
                                        assert.ok(!err);
                                        assert.strictEqual(comments.results[0].level, 0);
                                        assert.strictEqual(comments.results[1].level, 1);

                                        // Add a reply to the first reply
                                        RestAPI.Content.createComment(contexts['bert'].restContext, contentObj.id, 'A reply to the reply on the second comment in the list', comments.results[1].commentId, function(err, comment) {
                                            assert.ok(!err);
                                            assert.ok(comment);

                                            // Add a second comment to the content item
                                            RestAPI.Content.createComment(contexts['bert'].restContext, contentObj.id, 'This comment should be first in the list', null, function(err, comment) {
                                                assert.ok(!err);
                                                assert.ok(comment);

                                                RestAPI.Content.getComments(contexts['bert'].restContext, contentObj.id, null, 10, function(err, comments) {
                                                    assert.ok(!err);

                                                    // Check level of the replies
                                                    assert.strictEqual(comments.results[0].level, 0); // Last level 0 comment made
                                                    assert.strictEqual(comments.results[1].level, 0); // First level 0 comment made
                                                    assert.strictEqual(comments.results[2].level, 1); // First reply to first comment made
                                                    assert.strictEqual(comments.results[3].level, 2); // Reply to the reply

                                                    // Check that replies to a comment reference the correct comment
                                                    assert.equal(comments.results[1].commentId, comments.results[2].replyTo);
                                                    assert.equal(comments.results[2].commentId, comments.results[3].replyTo);

                                                    // Try to post a reply without a content ID
                                                    RestAPI.Content.createComment(contexts['bert'].restContext, null, 'This is an updated comment', '1231654351', function(err, comment) {
                                                        assert.ok(err);
                                                        assert.ok(!comment);

                                                        // Verify that paging results the order of threaded comments
                                                        RestAPI.Content.createLink(contexts['bert'].restContext, 'Test Content', 'Test content description', 'public', 'http://www.sakaiproject.org/',  [], [], function(err, contentObj) {
                                                            assert.ok(!err);
                                                            assert.ok(contentObj.id);

                                                            createComments(contexts, contentObj.id, 10, null, function() {
                                                                RestAPI.Content.getComments(contexts['bert'].restContext, contentObj.id, null, 10, function(err, comments) {
                                                                    assert.ok(!err);
                                                                    assert.equal(comments.results.length, 10);

                                                                    createComments(contexts, contentObj.id, 10, comments.results[5].commentId, function() {
                                                                        RestAPI.Content.getComments(contexts['bert'].restContext, contentObj.id, null, 10, function(err, comments) {
                                                                            assert.ok(!err);
                                                                            assert.equal(comments.results[5].level, 0); // First 6 comments are level 0 comments
                                                                            assert.equal(comments.results[6].level, 1); // 7, 8 and 9 are 3 level 1 replies
                                                                            RestAPI.Content.getComments(contexts['bert'].restContext, contentObj.id, comments.results[9].created, 10, function(err, comments) {
                                                                                assert.ok(!err);
                                                                                assert.equal(comments.results[5].level, 1); // 0, 1, 2, 3, 4 and 5 are 6 level 1 replies making the paged total 10
                                                                                assert.equal(comments.results[6].level, 0); // Original level 0 comments continue from here on
                                                                                callback();
                                                                            });
                                                                        });
                                                                    });
                                                                });
                                                            });
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that will retrieve comments
         */
        it('verify retrieve comments', function(callback) {
            setUpUsers(function(contexts) {
                // Create a piece of content
                RestAPI.Content.createLink(contexts['bert'].restContext, 'Test Content 1', 'Test content description 1', 'public', 'http://www.sakaiproject.org/',  [], [], function(err, contentObj) {
                    assert.ok(!err);
                    assert.ok(contentObj);

                    // Get the created piece of content
                    RestAPI.Content.getContent(contexts['bert'].restContext, contentObj.id, function(err, retrievedContentObj) {
                        assert.ok(!err);
                        assert.equal(retrievedContentObj.id, contentObj.id);

                        // Create one more and verify that it comes back as the first comment in the list
                        RestAPI.Content.createComment(contexts['bert'].restContext, contentObj.id, 'This comment should be on top of the list', null, function(err, comment) {
                            assert.ok(!err);
                            assert.ok(comment);

                            // Get the comments and verify that the item on top of the list is the correct one
                            RestAPI.Content.getComments(contexts['bert'].restContext, contentObj.id, null, 10, function(err, comments) {
                                assert.ok(!err);
                                assert.equal(comments.results.length, 1);
                                assert.equal(comments.results[0].createdBy.publicAlias, 'Bert Pareyn');

                                // Try to get the comments for a content item without specifying the content ID
                                RestAPI.Content.getComments(contexts['bert'].restContext, null, null, 10, function(err, comments) {
                                    assert.ok(err);
                                    assert.equal(err.code, 404);
                                    callback();
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that will delete a comment from content
         */
        it('verify delete comment', function(callback) {
            setUpUsers(function(contexts) {

                // Create a piece of content
                RestAPI.Content.createLink(contexts['bert'].restContext, 'Test Content 1', 'Test content description 1', 'public', 'http://www.sakaiproject.org/',  [], [], function(err, contentObj) {
                    assert.ok(!err);
                    assert.ok(contentObj);

                    // Get the created piece of content
                    RestAPI.Content.getContent(contexts['bert'].restContext, contentObj.id, function(err, retrievedContentObj) {
                        assert.ok(!err);
                        assert.equal(retrievedContentObj.id, contentObj.id);

                        // Create a comment
                        RestAPI.Content.createComment(contexts['bert'].restContext, contentObj.id, 'This comment will be deleted.', null, function(err, comment) {
                            assert.ok(!err);
                            assert.ok(comment);

                            // Get the comments and verify that the new comment was created
                            RestAPI.Content.getComments(contexts['bert'].restContext, contentObj.id, null, 10, function(err, comments) {
                                assert.ok(!err);
                                assert.equal(comments.results.length, 1);
                                assert.equal(comments.results[0].createdBy.publicAlias, 'Bert Pareyn');

                                RestAPI.Content.createComment(contexts['bert'].restContext, contentObj.id, 'This is a reply on the comment that will be deleted.', comments.results[0].commentId, function(err, comment) {
                                    assert.ok(!err);
                                    assert.ok(comment);

                                    // Delete the comment
                                    RestAPI.Content.deleteComment(contexts['bert'].restContext, contentObj.id, comments.results[0].commentId, function(err, softDeleted) {
                                        assert.ok(!err);
                                        assert.equal(softDeleted.deleted, false);
                                        assert.equal(softDeleted.body, null);

                                        // Check that the first comment was not deleted because there was a reply, instead it's marked as deleted
                                        RestAPI.Content.getComments(contexts['bert'].restContext, contentObj.id, null, 10, function(err, comments) {
                                            assert.ok(!err);
                                            assert.equal(comments.results.length, 2);
                                            assert.equal(comments.results[0].deleted, true);

                                            // Create a reply on the reply
                                            RestAPI.Content.createComment(contexts['bert'].restContext, contentObj.id, 'This is a reply on the reply on a comment that will be deleted.', comments.results[1].commentId, function(err, comment) {
                                                assert.ok(!err);
                                                assert.ok(comment);

                                                // Delete reply on comment
                                                RestAPI.Content.deleteComment(contexts['bert'].restContext, contentObj.id, comments.results[1].commentId, function(err, softDeleted) {
                                                    assert.ok(!err);
                                                    assert.equal(softDeleted.deleted, false);

                                                    // Check that the first reply was not deleted because there was a reply, instead it's marked as deleted
                                                    RestAPI.Content.getComments(contexts['bert'].restContext, contentObj.id, null, 10, function(err, comments) {
                                                        assert.ok(!err);
                                                        assert.equal(comments.results.length, 3);
                                                        assert.equal(comments.results[1].deleted, true);
                                                        assert.equal(comments.results[1].contentId, undefined);
                                                        assert.equal(comments.results[1].createdBy, undefined);
                                                        assert.ok(comments.results[1].created);
                                                        assert.equal(comments.results[1].body, undefined);
                                                        assert.equal(comments.results[1].level, 1);
                                                        assert.equal(comments.results[1].commentId, comments.results[1].commentId);

                                                        // Delete reply on reply
                                                        RestAPI.Content.deleteComment(contexts['bert'].restContext, contentObj.id, comments.results[2].commentId, function(err, softDeleted) {
                                                            assert.ok(!err);
                                                            assert.ok(!softDeleted);

                                                            // Delete reply on comment
                                                            RestAPI.Content.deleteComment(contexts['bert'].restContext, contentObj.id, comments.results[1].commentId, function(err, softDeleted) {
                                                                assert.ok(!err);
                                                                assert.ok(!softDeleted);

                                                                // Delete original comment
                                                                RestAPI.Content.deleteComment(contexts['bert'].restContext, contentObj.id, comments.results[0].commentId, function(err, softDeleted) {
                                                                    assert.ok(!err);
                                                                    assert.ok(!softDeleted);

                                                                    // Verify that all comments were deleted
                                                                    RestAPI.Content.getComments(contexts['bert'].restContext, contentObj.id, null, 10, function(err, comments) {
                                                                        assert.ok(!err);
                                                                        assert.equal(comments.results.length, 0);
                                                                        callback();
                                                                    });
                                                                });
                                                            });
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that will verify permissions when deleting comments
         */
        it('verify delete comment permissions', function(callback) {
            setUpUsers(function(contexts) {
                // Create a first piece of content where bert has full access
                RestAPI.Content.createLink(contexts['bert'].restContext, 'Test Content 1', 'Test content description 1', 'public', 'http://www.sakaiproject.org/',  [], [], function(err, publicContentObj) {
                    assert.ok(!err);
                    assert.ok(publicContentObj);
                    // Create a second piece of content where bert is a member
                    RestAPI.Content.createLink(contexts['nicolaas'].restContext, 'Test Content 2', 'Test content description 2', 'private', 'http://www.sakaiproject.org/',  [], [contexts['bert'].user.id], function(err, privateContentObj) {
                        assert.ok(!err);
                        assert.ok(privateContentObj);
                        // Create 2 comments as bert on the private link
                        RestAPI.Content.createComment(contexts['bert'].restContext, privateContentObj.id, 'This is a first comment.', null, function(err, comment) {
                            assert.ok(!err);
                            assert.ok(comment);

                            RestAPI.Content.createComment(contexts['bert'].restContext, privateContentObj.id, 'This is a second comment.', null, function(err, comment) {
                                assert.ok(!err);
                                assert.ok(comment);

                                // Get the comments to verify they were created successfully
                                RestAPI.Content.getComments(contexts['bert'].restContext, privateContentObj.id, null, 10, function(err, comments) {
                                    assert.ok(!err);
                                    assert.equal(comments.results.length, 2);
                                    assert.equal(comments.results[0].createdBy.id, contexts['bert'].user.id);
                                    assert.equal(comments.results[0].body, 'This is a second comment.');
                                    var comment2 = comments.results[0].commentId;
                                    assert.equal(comments.results[1].createdBy.id, contexts['bert'].user.id);
                                    assert.equal(comments.results[1].body, 'This is a first comment.');
                                    var comment1 = comments.results[1].commentId;

                                    // Try to delete a comment
                                    RestAPI.Content.deleteComment(contexts['bert'].restContext, privateContentObj.id, comment2, function(err, softDeleted) {
                                        assert.ok(!err);
                                        assert.ok(!softDeleted);
                                        // Verify that the comment has been deleted
                                        RestAPI.Content.getComments(contexts['bert'].restContext, privateContentObj.id, null, 10, function(err, comments) {
                                            assert.ok(!err);
                                            assert.equal(comments.results.length, 1);
                                            assert.equal(comments.results[0].commentId, comment1);

                                            // Remove bert as a member from the private content
                                            var permissions = {};
                                            permissions[contexts['bert'].user.id] = false;
                                            RestAPI.Content.updateMembers(contexts['nicolaas'].restContext, privateContentObj.id, permissions, function(err) {
                                                assert.ok(!err);

                                                // Try to delete the comment on the private content item by using the public content item's ID and the ID of the comment that was just created
                                                RestAPI.Content.deleteComment(contexts['bert'].restContext, publicContentObj.id, comment1, function(err, softDeleted) {
                                                    assert.ok(err);
                                                    assert.equal(err.code, 400);
                                                    assert.ok(!softDeleted);
                                                    // Get the comment to verify that it wasn't deleted
                                                    RestAPI.Content.getComments(contexts['nicolaas'].restContext, privateContentObj.id, null, 10, function(err, comments) {
                                                        assert.ok(!err);
                                                        assert.equal(comments.results.length, 1);
                                                        assert.equal(comments.results[0].commentId, comment1);
                                                        assert.equal(comments.results[0].createdBy.id, contexts['bert'].user.id);
                                                        assert.equal(comments.results[0].body, 'This is a first comment.');

                                                        // Try to reply to the comment on the private content item by using the public content item's ID and the ID of the comment that was just created
                                                        RestAPI.Content.createComment(contexts['bert'].restContext, publicContentObj.id, 'This reply on the comment shouldn\'t be accepted', comment1, function(err, comment) {
                                                            assert.ok(err);
                                                            assert.equal(err.code, 400);
                                                            assert.ok(!comment);

                                                            // Get the comment to verify that it wasn't created
                                                            RestAPI.Content.getComments(contexts['nicolaas'].restContext, privateContentObj.id, null, 10, function(err, comments) {
                                                                assert.ok(!err);
                                                                assert.equal(comments.results.length, 1);
                                                                assert.equal(comments.results[0].commentId, comment1);
                                                                assert.equal(comments.results[0].createdBy.id, contexts['bert'].user.id);
                                                                assert.equal(comments.results[0].body, 'This is a first comment.');
                                                                callback();
                                                            });
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that will verify delete comment validation
         */
        it('verify delete comment validation', function(callback) {
            setUpUsers(function(contexts) {
                // Create a public piece of content
                RestAPI.Content.createLink(contexts['nicolaas'].restContext, 'Test Content 1', 'Test content description 1', 'public', 'http://www.sakaiproject.org/',  [], [], function(err, contentObj) {
                    assert.ok(!err);
                    assert.ok(contentObj);
                    // Create a comment as bert
                    RestAPI.Content.createComment(contexts['bert'].restContext, contentObj.id, 'This is a comment.', null, function(err, comment) {
                        assert.ok(!err);
                        assert.ok(comment);
                        // Get the comment verify that it was created successfully
                        RestAPI.Content.getComments(contexts['bert'].restContext, contentObj.id, null, 10, function(err, comments) {
                            assert.ok(!err);
                            assert.equal(comments.results.length, 1);
                            assert.equal(comments.results[0].createdBy.id, contexts['bert'].user.id);
                            assert.equal(comments.results[0].body, 'This is a comment.');
                            var commentId = comments.results[0].commentId;
                            callback();
                        });
                    });
                });
            });
        });

        /**
         * Will test if users are able to delete comments from content.
         *
         * @param {Object}    contexts         An object containing generated users
         * @param {String}    visibility       The visibility setting for the content to be created. Can be `private`, `loggedin` or `public`
         * @param {Boolean}   expectedDelete   If it is expected that content can be deleted
         * @param {Function}  callback         Standard callback function that executes after the tests are completed
         * @param {function}  callback.err     Error object coming out of the tests
         */
        var testDeleteCommentPermissions = function(contexts, visibility, expectedDelete, callback) {

            var bert = contexts['bert'];
            var nicolaas = contexts['nicolaas'];
            var simon = contexts['simon'];

            /**
             * Function that creates a piece of content, comments on the content, verifies that the comment exists and deletes the comment before executing a callback.
             *
             * @param {RestContext}   linkContext       The RestContext object of a user to create the content item with
             * @param {RestContext}   commentContext    The RestContext object of a user to comment on the content item with
             * @param {RestContext}   deleteContext     The RestContext object of a user to delete the comment with
             * @param {String}        visibility        The visibility of the content item that will be created ('public', 'loggedin' or 'private')
             * @param {String[]}      managers          An array of user IDs that will be added as managers to the newly created content
             * @param {String[]}      members           An array of user IDs that will be added as members (viewers) to the newly created content
             * @param {Function}      callback          Standard callback function executed after the content has been created, commented on and deleted
             * @param {Object}        callback.err      Error object coming from deleting a comment
             * @api private
             */
            var _canDelete = function(linkContext, commentContext, deleteContext, visibility, managers, members, expectedDelete, callback) {
                RestAPI.Content.createLink(linkContext.restContext, 'Test Content', 'Test content description', visibility, 'http://www.sakaiproject.org/', [], members, function(err, contentObj) {
                    assert.ok(!err);
                    assert.ok(contentObj.id);

                    RestAPI.Content.createComment(commentContext.restContext, contentObj.id, 'Comment to check access', null, function(err, comment) {
                        if (expectedDelete) {
                            assert.ok(!err);
                            assert.ok(comment);
                        } else {
                            assert.ok(err);
                            assert.ok(!comment);
                            return callback(err);
                        }

                        RestAPI.Content.getComments(linkContext.restContext, contentObj.id, null, 10, function(err, comments) {
                            assert.ok(!err);
                            assert.equal(comments.results[0].level, 0);
                            assert.equal(comments.results[0].body, 'Comment to check access');
                            assert.equal(comments.results[0].createdBy.id, commentContext.user.id);

                            RestAPI.Content.deleteComment(deleteContext.restContext || deleteContext, contentObj.id, comments.results[0].commentId, callback);
                        });
                    });
                });
            };

            // Delete own comment as manager on piece of content (--> success)
            _canDelete(bert, bert, bert, visibility, [], [], true, function(err) {
                assert.ok(!err);
                // Delete other's comment as manager on piece of content (--> success)
                _canDelete(bert, simon, bert, visibility, [], [contexts['simon'].user.id], true, function(err, softDeleted) {
                    assert.ok(!err);
                    assert.ok(!softDeleted);
                    // Delete own comment as member on piece of content (--> success)
                    _canDelete(bert, simon, simon, visibility, [], [contexts['simon'].user.id], true, function(err, softDeleted) {
                        assert.ok(!err);
                        assert.ok(!softDeleted);
                        // Delete other's comment as member on piece of content (--> fail)
                        _canDelete(bert, bert, simon, visibility, [], [contexts['simon'].user.id], true, function(err, softDeleted) {
                            assert.ok(err);
                            assert.ok(!softDeleted);
                            // Delete own comment as logged in on piece of content (--> success)
                            _canDelete(bert, simon, simon, visibility, [], [], expectedDelete, function(err, softDeleted) {
                                if (expectedDelete) {
                                    assert.ok(!err);
                                    assert.ok(!softDeleted, true);
                                } else {
                                    assert.ok(err);
                                    assert.ok(!softDeleted);
                                }
                                // Delete comment as anonymous on piece of content (--> fail)
                                _canDelete(bert, bert, anonymousRestContext, visibility, [], [], true, function(err, softDeleted) {
                                    assert.ok(err);
                                    assert.ok(!softDeleted);
                                    callback();
                                });
                            });
                        });
                    });
                });
            });
        };

        /**
         * Test that will verify delete permissions for comments on public content
         */
        it('verify delete comment permissions public', function(callback) {
            setUpUsers(function(contexts) {
                testDeleteCommentPermissions(contexts, 'public', true, callback);
            });
        });

        /**
         * Test that will verify delete permissions for comments on loggedin content
         */
        it('verify delete comment permissions loggedin', function(callback) {
            setUpUsers(function(contexts) {
                testDeleteCommentPermissions(contexts, 'loggedin', true, callback);
            });
        });

        /**
         * Test that will verify delete permissions for comments on private content
         */
        it('verify delete comment permissions private', function(callback) {
            setUpUsers(function(contexts) {
                testDeleteCommentPermissions(contexts, 'private', false, callback);
            });
        });

        /**
         * Test that will verify comment creation validation
         */
        it('verify create comment validation', function(callback) {
            setUpUsers(function(contexts) {
                // Create a piece of content
                RestAPI.Content.createLink(contexts['bert'].restContext, 'Test Content 1', 'Test content description 1', 'public', 'http://www.sakaiproject.org/',  [], [], function(err, contentObj) {
                    assert.ok(!err);
                    assert.ok(contentObj);

                    // Try to create a comment without a contentId
                    RestAPI.Content.createComment(contexts['bert'].restContext, null, 'This comment should be on top of the list', null, function(err, comment) {
                        assert.ok(err);
                        assert.equal(err.code, 404);
                        assert.ok(!comment);
                        // Verify that the comment wasn't created
                        RestAPI.Content.getComments(contexts['bert'].restContext, contentObj.id, null, 10, function(err, comments) {
                            assert.ok(!err);
                            assert.equal(comments.results.length, 0);

                            // Try to create a comment without a comment
                            RestAPI.Content.createComment(contexts['bert'].restContext, contentObj.id, null, null, function(err, comment) {
                                assert.ok(err);
                                assert.equal(err.code, 400);
                                assert.ok(!comment);
                                // Verify that the comment wasn't created
                                RestAPI.Content.getComments(contexts['bert'].restContext, contentObj.id, null, 10, function(err, comments) {
                                    assert.ok(!err);
                                    assert.equal(comments.results.length, 0);

                                    // Try to create a comment as an anonymous user
                                    RestAPI.Content.createComment(anonymousRestContext, contentObj.id, 'This comment should be on top of the list', null, function(err, comment) {
                                        assert.ok(err);
                                        assert.equal(err.code, 401);
                                        assert.ok(!comment);
                                        // Verify that the comment wasn't created
                                        RestAPI.Content.getComments(contexts['bert'].restContext, contentObj.id, null, 10, function(err, comments) {
                                            assert.ok(!err);
                                            assert.equal(comments.results.length, 0);
                                            callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Tests the permissions for creating comments on content
         *
         * @param {Object}      contexts                 Object containing REST Contexts for users
         * @param {String}      visibility               The permissions to apply to the content item (`public`, `loggedin` or `private`)
         * @param {Boolean}     expectLoggedInComment    Indicates if it's expected that a comment will be successfully placed on content using the content permissions provided in `visibility`
         * @param {Function}    callback                 Standard function executed after all tests complete
         */
        var testCommentPermissions = function(contexts, visibility, expectLoggedInComment, callback){
            // Create content with specified visibility
            RestAPI.Content.createLink(contexts['bert'].restContext, 'Test Content 1', 'Test content description 1', visibility, 'http://www.sakaiproject.org/', [], [contexts['nicolaas'].user.id], function(err, contentObj) {
                assert.ok(!err);
                assert.ok(contentObj.id);

                // Try to comment as manager
                RestAPI.Content.createComment(contexts['bert'].restContext, contentObj.id, 'Try to comment as manager', null, function(err, comment) {
                    assert.ok(!err);
                    assert.ok(comment);
                    // Verify that the comment was placed as a manager
                    RestAPI.Content.getComments(contexts['bert'].restContext, contentObj.id, null, 1, function(err, comments) {
                        assert.ok(!err);
                        assert.equal(comments.results[0].body, 'Try to comment as manager');

                        // Try to comment as member
                        RestAPI.Content.createComment(contexts['nicolaas'].restContext, contentObj.id, 'Try to comment as member', null, function(err, comment) {
                            assert.ok(!err);
                            assert.ok(comment);
                            // Verify that the comment was placed as a member
                            RestAPI.Content.getComments(contexts['nicolaas'].restContext, contentObj.id, null, 1, function(err, comments) {
                                assert.ok(!err);
                                assert.equal(comments.results[0].body, 'Try to comment as member');

                                // Try to comment as logged in user
                                RestAPI.Content.createComment(contexts['simon'].restContext, contentObj.id, 'Try to comment as logged in user', null, function(err, comment) {
                                    if (!expectLoggedInComment) {
                                        assert.ok(err);
                                        assert.ok(!comment);
                                    } else {
                                        assert.ok(!err);
                                        assert.ok(comment);
                                    }
                                    // Verify that the comment was placed as a logged in user
                                    RestAPI.Content.getComments(contexts['simon'].restContext, contentObj.id, null, 1, function(err, comments) {
                                        if (!expectLoggedInComment) {
                                            assert.ok(err);
                                        } else {
                                            assert.ok(!err);
                                            assert.equal(comments.results[0].body, 'Try to comment as logged in user');
                                        }

                                        // Try to comment as anonymous user
                                        RestAPI.Content.createComment(anonymousRestContext, contentObj.id, 'Try to comment as an anonymous user', null, function(err, comment) {
                                            assert.ok(err);
                                            assert.ok(!comment);
                                            // Verify that the comment was placed as an anonymous
                                            RestAPI.Content.getComments(contexts['bert'].restContext, contentObj.id, null, 1, function(err, comments) {
                                                assert.ok(!err);
                                                assert.notEqual(comments.results[0].body, 'Try to comment as an anonymous user');
                                                callback();
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        };

        /**
         * Test that will check permissions for placing comments on public content
         */
        it('verify create comment permissions public', function(callback) {
            setUpUsers(function(contexts) {
                testCommentPermissions(contexts, 'public', true, callback);
            });
        });

        /**
         * Test that will check permissions for placing comments on loggedin only content
         */
        it('verify create comment permissions loggedin', function(callback) {
            setUpUsers(function(contexts) {
                testCommentPermissions(contexts, 'loggedin', true, callback);
            });
        });

        /**
         * Test that will check permissions for placing comments on private content
         */
        it('verify create comment permissions private', function(callback) {
            setUpUsers(function(contexts) {
                testCommentPermissions(contexts, 'private', false, callback);
            });
        });
    });


    describe('Create content', function() {

        /**
         * Test that will attempt to create new links with various parameter combinations
         */
        it('verify create link', function(callback) {
            setUpUsers(function(contexts) {
                // Create one as anon user
                RestAPI.Content.createLink(anonymousRestContext, 'Test Content 1', 'Test content description 1', 'public', 'http://www.sakaiproject.org/', [], [], function(err, contentObj) {
                    assert.ok(err);
                    assert.ok(!contentObj);

                    // Create one with all required fields
                    RestAPI.Content.createLink(contexts['nicolaas'].restContext, 'Test Content 2', 'Test content description 2', 'public', 'http://www.sakaiproject.org/', [], [], function(err, contentObj) {
                        assert.ok(!err);
                        assert.ok(contentObj.id);

                        // Create one without description
                        RestAPI.Content.createLink(contexts['nicolaas'].restContext, 'Test Content 3', null, 'public', 'http://www.sakaiproject.org/', [], [], function(err, contentObj) {
                            assert.ok(!err);
                            assert.ok(contentObj.id);

                            // Create one without URL
                            RestAPI.Content.createLink(contexts['nicolaas'].restContext, 'Test Content 4', 'Test content description 4', 'public', null, [], [], function(err, contentObj) {
                                assert.ok(err);
                                assert.ok(!contentObj);

                                // Create one without a valid URL
                                RestAPI.Content.createLink(contexts['nicolaas'].restContext, 'Test Content 5', 'Test content description 5', 'public', 'Just a string', [], [], function(err, contentObj) {
                                    assert.ok(err);
                                    assert.ok(!contentObj);

                                    // Create one without title
                                    RestAPI.Content.createLink(contexts['nicolaas'].restContext, null, 'Test content description 6', 'public', 'http://www.sakaiproject.org/', [], [], function(err, contentObj) {
                                        assert.ok(err);
                                        assert.ok(!contentObj);

                                        // Create one without visibility
                                        RestAPI.Content.createLink(contexts['nicolaas'].restContext, 'Test Content 7', 'Test content description 7', null, 'http://www.sakaiproject.org/', [], [], function(err, contentObj) {
                                            assert.ok(!err);
                                            assert.ok(contentObj.id);
                                            // Check if the visibility has been set to public (default)
                                            RestAPI.Content.getContent(contexts['nicolaas'].restContext, contentObj.id, function(err, contentObj) {
                                                assert.ok(!err);
                                                assert.equal(contentObj.visibility, 'public');
                                                callback();
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    
        /**
         * Test that will attempt to create new files with various parameter combinations
         */
        it('verify create file', function(callback) {
            setUpUsers(function(contexts) {

                // Create one as anon user
                RestAPI.Content.createFile(anonymousRestContext, 'Test Content 1', 'Test content description 1', 'public', getFileStream, [], [], function(err, contentObj) {
                    assert.equal(err.code, 401);
                    assert.ok(!contentObj);

                    // Create one with all required fields
                    RestAPI.Content.createFile(contexts['nicolaas'].restContext, 'Test Content 2', 'Test content description 2', 'public', getFileStream, [], [], function(err, contentObj) {
                        assert.ok(!err);
                        assert.ok(contentObj.id);
                        assert.equal(contentObj.filename, 'sakaiger.png');
                        assert.equal(contentObj.mime, 'image/png');

                        // Create one without description
                        RestAPI.Content.createFile(contexts['nicolaas'].restContext, 'Test Content 3', null, 'public', getFileStream, [], [], function(err, contentObj) {
                            assert.ok(!err);
                            assert.ok(contentObj.id);

                            // Create one without title
                            RestAPI.Content.createFile(contexts['nicolaas'].restContext, null, 'Test content description 4', 'public', getFileStream, [], [], function(err, contentObj) {
                                assert.equal(err.code, 400);
                                assert.ok(!contentObj);

                                // Create one without a file body.
                                RestAPI.Content.createFile(contexts['nicolaas'].restContext, 'Test Content 4', 'Test content description 4', 'public', null, [], [], function(err, contentObj) {
                                    assert.equal(err.code, 400);
                                    assert.ok(!contentObj);

                                    // Create one without visibility
                                    RestAPI.Content.createFile(contexts['nicolaas'].restContext, 'Test Content 5', 'Test content description 6', null, getFileStream, [], [], function(err, contentObj) {
                                        assert.ok(!err);
                                        assert.ok(contentObj.id);
                                        // Check if the visibility has been set to public (default)
                                        RestAPI.Content.getContent(contexts['nicolaas'].restContext, contentObj.id, function(err, contentObj) {
                                            assert.ok(!err);
                                            assert.equal(contentObj.visibility, 'public');
                                            callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
        
        /**
         * Test that will attempt to create new collaborative documents with various parameter combinations
         */
        it('verify create collaborative document', function(callback) {
            setUpUsers(function(contexts) {
                // Create one as anon user
                RestAPI.Content.createCollabDoc(anonymousRestContext, 'Test Content 1', 'Test content description 1', 'public', [], [], function(err, contentObj) {
                    assert.ok(err);
                    assert.ok(!contentObj);

                    // Create one with all required fields
                    RestAPI.Content.createCollabDoc(contexts['nicolaas'].restContext, 'Test Content 2', 'Test content description 2', 'public', [], [], function(err, contentObj) {
                        assert.ok(!err);
                        assert.ok(contentObj.id);

                        // Create one without description
                        RestAPI.Content.createCollabDoc(contexts['nicolaas'].restContext, 'Test Content 3', null, 'public', [], [], function(err, contentObj) {
                            assert.ok(!err);
                            assert.ok(contentObj.id);

                            // Create one without title
                            RestAPI.Content.createCollabDoc(contexts['nicolaas'].restContext, null, 'Test content description 4', 'public', [], [], function(err, contentObj) {
                                assert.ok(err);
                                assert.ok(!contentObj);

                                // Create one without permission
                                RestAPI.Content.createCollabDoc(contexts['nicolaas'].restContext, 'Test Content 5', 'Test content description 5', null, [], [], function(err, contentObj) {
                                    assert.ok(!err);
                                    assert.ok(contentObj.id);
                                    // Check if the permission has been set to private (default)
                                    RestAPI.Content.getContent(contexts['nicolaas'].restContext, contentObj.id, function(err, contentObj) {
                                        assert.ok(!err);
                                        assert.equal(contentObj.visibility, 'private');
                                        callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    
        /**
         * Test that will attempt to create a public content item and will verify direct and library access
         * for various people
         */
        it('verify create public content item', function(callback) {
            setUpUsers(function(contexts) {
                // Create a public content item
                RestAPI.Content.createLink(contexts['nicolaas'].restContext, 'Test Content 1', 'Test content description 1', 'public', 'http://www.sakaiproject.org/', [], [], function(err, contentObj) {
                    assert.ok(!err);
                    assert.ok(contentObj.id);

                    // Get the piece of content as the person who created the content
                    checkPieceOfContent(contexts['nicolaas'].restContext, contexts['nicolaas'].user.id, contentObj, true, true, true, function() {
                        // Get the piece of content as a different logged in user
                        checkPieceOfContent(contexts['simon'].restContext, contexts['nicolaas'].user.id, contentObj, true, false, true, function() {
                            // Get the piece of content as an anonymous user
                            checkPieceOfContent(anonymousRestContext, contexts['nicolaas'].user.id, contentObj, true, false, true, callback);
                        });
                    });
                });
            });
        });
    
        /**
         * Test that will attempt to create a loggedin content item and will verify direct and library access
         * for various people
         */
        it('verify create logged in content item', function(callback) {
            setUpUsers(function(contexts) {
                // Create a logged in content item
                RestAPI.Content.createLink(contexts['nicolaas'].restContext, 'Test Content 1', 'Test content description 1', 'loggedin', 'http://www.sakaiproject.org/', [], [], function(err, contentObj) {    
                    assert.ok(!err);
                    assert.ok(contentObj.id);

                    // Get the piece of content as the person who created the content
                    checkPieceOfContent(contexts['nicolaas'].restContext, contexts['nicolaas'].user.id, contentObj, true, true, true, function() {
                        // Get the piece of content as a different logged in user
                        checkPieceOfContent(contexts['simon'].restContext, contexts['nicolaas'].user.id, contentObj, true, false, true, function() {
                            // Get the piece of content as an anonymous user
                            checkPieceOfContent(anonymousRestContext, contexts['nicolaas'].user.id, contentObj, false, false, false, callback);
                        });
                    });
                });
            });
        });
    
        /**
         * Test that will attempt to create a private content item and will verify direct and library access
         * for various people
         */
        it('verify create private content item', function(callback) {
            setUpUsers(function(contexts) {
                // Create a private content item
                RestAPI.Content.createLink(contexts['nicolaas'].restContext, 'Test Content 1', 'Test content description 1', 'private', 'http://www.sakaiproject.org/', [], [], function(err, contentObj) {    
                    assert.ok(!err);
                    assert.ok(contentObj.id);

                    // Get the piece of content as the person who created the content
                    checkPieceOfContent(contexts['nicolaas'].restContext, contexts['nicolaas'].user.id, contentObj, true, true, true, function() {
                        // Get the piece of content as a different logged in user
                        checkPieceOfContent(contexts['simon'].restContext, contexts['nicolaas'].user.id, contentObj, false, false, false, function() {
                            // Get the piece of content as an anonymous user
                            checkPieceOfContent(anonymousRestContext, contexts['nicolaas'].user.id, contentObj, false, false, false, callback);
                        });
                    });
                });
            });
        });
    
        /**
         * Test whether or not passing in viewers and managers to be added to the content upon link creation works as expected. This test will
         * create a private piece of content that will have 1 additional manager and 1 viewer. We will fetch the content as those people
         * to verify access, and then get the content as a logged in user and an anonymous user to verify they don't have access
         */
        it('verify create content with default members link', function(callback) {
            setUpUsers(function(contexts) {
                // Create a private content item and share with 2 people
                RestAPI.Content.createLink(contexts['nicolaas'].restContext, 'Test Content 1', 'Test content description 1', 'private', 'http://www.sakaiproject.org/', [contexts['simon'].user.id], [contexts['bert'].user.id], function(err, contentObj) {
                    assert.ok(!err);
                    assert.ok(contentObj.id);

                    // Get the piece of content as the person who created the content
                    checkPieceOfContent(contexts['nicolaas'].restContext, contexts['nicolaas'].user.id, contentObj, true, true, true, function() {
                        // Get the piece of content as another manager
                        checkPieceOfContent(contexts['simon'].restContext, contexts['simon'].user.id, contentObj, true, true, true, function() {
                            // Get the piece of content as a viewer
                            checkPieceOfContent(contexts['bert'].restContext, contexts['bert'].user.id, contentObj, true, false, true, function() {
                                // Get the piece of content as a non-member
                                checkPieceOfContent(contexts['branden'].restContext, contexts['branden'].user.id, contentObj, false, false, false, function() {
                                    // Get the piece of content as an anonymous user
                                    checkPieceOfContent(anonymousRestContext, contexts['nicolaas'].user.id, contentObj, false, false, false, callback);
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test whether or not passing in viewers and managers to be added to the content upon file creation works as expected. This test will
         * create a private piece of content that will have 1 additional manager and 1 viewer. We will fetch the content as those people
         * to verify access, and then get the content as a logged in user and an anonymous user to verify they don't have access
         */
        it('verify create content with default members file', function(callback) {
            setUpUsers(function(contexts) {
                // Create a private content item and share with 2 people
                RestAPI.Content.createFile(contexts['nicolaas'].restContext, 'Test Content 2', 'Test content description 2', 'private', getFileStream, [contexts['simon'].user.id], [contexts['bert'].user.id], function(err, contentObj) {
                    assert.ok(!err);
                    assert.ok(contentObj.id);

                    // Get the piece of content as the person who created the content
                    checkPieceOfContent(contexts['nicolaas'].restContext, contexts['nicolaas'].user.id, contentObj, true, true, true, function() {
                        // Get the piece of content as another manager
                        checkPieceOfContent(contexts['simon'].restContext, contexts['simon'].user.id, contentObj, true, true, true, function() {
                            // Get the piece of content as a viewer
                            checkPieceOfContent(contexts['bert'].restContext, contexts['bert'].user.id, contentObj, true, false, true, function() {
                                // Get the piece of content as a non-member
                                checkPieceOfContent(contexts['branden'].restContext, contexts['branden'].user.id, contentObj, false, false, false, function() {
                                    // Get the piece of content as an anonymous user
                                    checkPieceOfContent(anonymousRestContext, contexts['nicolaas'].user.id, contentObj, false, false, false, callback);
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test whether or not passing in viewers and managers to be added to the content upon document creation works as expected. This test will
         * create a private piece of content that will have 1 additional manager and 1 viewer. We will fetch the content as those people
         * to verify access, and then get the content as a logged in user and an anonymous user to verify they don't have access
         */
        it('verify create content with default members collaborative document', function(callback) {
            setUpUsers(function(contexts) {
                // Create a private content item and share with 2 people
                RestAPI.Content.createCollabDoc(contexts['nicolaas'].restContext, 'Test Content 2', 'Test content description 2', 'private', [contexts['simon'].user.id], [contexts['bert'].user.id], function(err, contentObj) {
                    assert.ok(!err);
                    assert.ok(contentObj.id);

                    // Get the piece of content as the person who created the content
                    checkPieceOfContent(contexts['nicolaas'].restContext, contexts['nicolaas'].user.id, contentObj, true, true, true, function() {
                        // Get the piece of content as another manager
                        checkPieceOfContent(contexts['simon'].restContext, contexts['simon'].user.id, contentObj, true, true, true, function() {
                            // Get the piece of content as a viewer
                            checkPieceOfContent(contexts['bert'].restContext, contexts['bert'].user.id, contentObj, true, false, true, function() {
                                // Get the piece of content as a non-member
                                checkPieceOfContent(contexts['branden'].restContext, contexts['branden'].user.id, contentObj, false, false, false, function() {
                                    // Get the piece of content as an anonymous user
                                    checkPieceOfContent(anonymousRestContext, contexts['nicolaas'].user.id, contentObj, false, false, false, callback);
                                });
                            });
                        });
                    });
                });
            });
        });
        
    });

    
    describe('Update content', function() {
    
        /**
         * Utitility function for the update content profile test, that will check whether or not the name and description of a piece
         * of content are as expected for 2 different users.
         * @param  {Object}             contexts            Object where the keys are identifiers for the created users and the values are an
         *                                                  object with a user key containing the user object for the created user and a restContext key
         *                                                  containing the REST Context for that user
         * @param  {String}             contentId           Content id of the content for which the name and description are checked
         * @param  {String}             expectedName        The name the content is supposed to have
         * @param  {String}             expectedDescription The description the content is supposed to have
         * @param  {Function}           callback            Standard callback function
         */
        var checkNameAndDescription = function(contexts, contentId, expectedName, expectedDescription, callback) {
            // Check as user 0
            RestAPI.Content.getContent(contexts['nicolaas'].restContext, contentId, function(err, contentObj) {
                assert.ok(!err);
                assert.equal(contentObj.id, contentId);
                assert.equal(contentObj.displayName, expectedName);
                assert.equal(contentObj.description, expectedDescription);
                assert.equal(contentObj.resourceType, 'content');
                assert.equal(contentObj.profilePath, '/content/' + contentId);
                // Check as user 1
                RestAPI.Content.getContent(contexts['simon'].restContext, contentId, function(err, contentObj) {
                    assert.ok(!err);
                    assert.equal(contentObj.id, contentId);
                    assert.equal(contentObj.displayName, expectedName);
                    assert.equal(contentObj.description, expectedDescription);
                    assert.equal(contentObj.resourceType, 'content');
                    assert.equal(contentObj.profilePath, '/content/' + contentId);
                    callback();
                });
            });
        };
    
        /**
         * Test that will exercise the name and description part of the updateContent profile function. A piece of content will be 
         * updated with invalid parameters, then the name will be updated, the description will be updated, both name and description 
         * will be updated at the same time, and we will attempt to update the profile as a non-manager. After all of these, we'll 
         * check if the correct metadata is still on the content.
         */
        it('verify update content profile', function(callback) {
            // Create a piece of content
            setUpUsers(function(contexts) {
                RestAPI.Content.createLink(contexts['nicolaas'].restContext, 'Test Content 1', 'Test content description 1', 'public', 'http://www.sakaiproject.org/', [], [], function(err, contentObj) {    
                    assert.ok(!err);
                    assert.ok(contentObj.id);
                    // Share it with someone
                    RestAPI.Content.shareContent(contexts['nicolaas'].restContext, contentObj.id, [contexts['simon'].user.id], function(err) {
                        assert.ok(!err);
                        // Invalid content metadata update (empty)
                        RestAPI.Content.updateContent(contexts['nicolaas'].restContext, contentObj.id, {}, function(err) {
                            assert.ok(err);
                            // Invalid content metadata update (unexisting field)
                            RestAPI.Content.updateContent(contexts['nicolaas'].restContext, contentObj.id, {'displayName': 'New Test Content 1', 'nonExisting': 'Non-existing field'}, function(err) {
                                assert.ok(err);
                                // Check name and description are still correct
                                checkNameAndDescription(contexts, contentObj.id, 'Test Content 1', 'Test content description 1', function() {
                                    // Change the name
                                    RestAPI.Content.updateContent(contexts['nicolaas'].restContext, contentObj.id, {'displayName': 'New Test Content 1'}, function(err) {
                                        assert.ok(!err);
                                        // Check the new name comes back
                                        checkNameAndDescription(contexts, contentObj.id, 'New Test Content 1', 'Test content description 1', function() {
                                            // Change the description
                                            RestAPI.Content.updateContent(contexts['nicolaas'].restContext, contentObj.id, {'description': 'New test content description 1'}, function(err) {
                                                assert.ok(!err);
                                                // Check the new description comes back
                                                checkNameAndDescription(contexts, contentObj.id, 'New Test Content 1', 'New test content description 1', function() {
                                                    // Change both at same time
                                                    RestAPI.Content.updateContent(contexts['nicolaas'].restContext, contentObj.id, {'displayName': 'New Test Content 2', 'description': 'New test content description 2'}, function(err) {
                                                        assert.ok(!err);
                                                        // Check the new name and description come back
                                                        checkNameAndDescription(contexts, contentObj.id, 'New Test Content 2', 'New test content description 2', function() {
                                                            // Try updating it as non-manager of the content
                                                            RestAPI.Content.updateContent(contexts['simon'], contentObj.id, {'displayName': 'New Test Content 3'}, function(err) {
                                                                assert.ok(err);
                                                                 // Check that the old values are still in place
                                                                 checkNameAndDescription(contexts, contentObj.id, 'New Test Content 2', 'New test content description 2', callback);
                                                            });
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    
        /**
         * Utility function that will check for content access and library presence for a content manager,
         * a content viewer, a logged in user and the anonymous user
         * @param  {Array<Context>}     contexts                Array of context objects that represent a request cycle and contain
         * @param  {String}             contentId               Content id of the content for which we expect in the access and library checks
         * @param  {Boolean}            expectLoggedInAccess    Whether or not the logged in user is expected to have access to the content
         * @param  {Boolean}            expectAnonAccess        Whether or not the anonymous user is expected to have access to the content
         * @param  {Function}           callback                Standard callback function
         */
        var checkAccessAndLibrary = function(contexts, contentId, expectLoggedInAccess, expectAnonAccess, callback) {
            // Check for the content manager
            RestAPI.Content.getContent(contexts['nicolaas'].restContext, contentId, function(err, contentObj) {
                assert.ok(!err);
                assert.ok(contentObj);
                // Check that it's part of the content manager's library
                RestAPI.Content.getLibrary(contexts['nicolaas'].restContext, contexts['nicolaas'].user.id, null, 10, function(err, items) {
                    assert.ok(!err);
                    assert.equal(items.results.length, 1);
                    assert.equal(items.results[0].id, contentId);

                    // Check for the content viewer
                    RestAPI.Content.getContent(contexts['simon'].restContext, contentId, function(err, contentObj) {
                        assert.ok(!err);
                        assert.ok(contentObj);
                        // Check that it is part of his library
                        RestAPI.Content.getLibrary(contexts['simon'].restContext, contexts['simon'].user.id, null, 10, function(err, items) {
                            assert.ok(!err);
                            assert.equal(items.results.length, 1);
                            assert.equal(items.results[0].id, contentId);
                            // Check that it is visible in the manager's library
                            RestAPI.Content.getLibrary(contexts['simon'].restContext, contexts['nicolaas'].user.id, null, 10, function(err, items) {
                                assert.ok(!err);
                                if (expectLoggedInAccess) {
                                    assert.equal(items.results.length, 1);
                                    assert.equal(items.results[0].id, contentId);
                                } else {
                                    assert.equal(items.results.length, 0);
                                }

                                // Check for the logged in user that's not a viewer
                                RestAPI.Content.getContent(contexts['bert'].restContext, contentId, function(err, contentObj) {
                                    if (expectLoggedInAccess) {
                                        assert.ok(!err);
                                        assert.ok(contentObj);
                                    } else {
                                        assert.ok(err);
                                        assert.ok(!contentObj);
                                    }
                                    // Check that it isn't part of his library
                                    RestAPI.Content.getLibrary(contexts['bert'].restContext, contexts['bert'].user.id, null, 10, function(err, items) {
                                        assert.ok(!err);
                                        assert.equal(items.results.length, 0);
                                        // Check that it is visible in the manager's library
                                        RestAPI.Content.getLibrary(contexts['bert'].restContext, contexts['nicolaas'].user.id, null, 10, function(err, items) {
                                            assert.ok(!err);
                                            if (expectLoggedInAccess) {
                                                assert.equal(items.results.length, 1);
                                                assert.equal(items.results[0].id, contentId);
                                            } else {
                                                assert.equal(items.results.length, 0);
                                            }

                                            // Check for the anonymous user
                                            RestAPI.Content.getContent(anonymousRestContext, contentId, function(err, contentObj) {
                                                if (expectAnonAccess) {
                                                    assert.ok(!err);
                                                    assert.ok(contentObj);
                                                } else {
                                                    assert.ok(err);
                                                    assert.ok(!contentObj);
                                                }
                                                // Check that it is visible in the manager's library
                                                RestAPI.Content.getLibrary(anonymousRestContext, contexts['nicolaas'].user.id, null, 10, function(err, items) {
                                                    assert.ok(!err);
                                                    if (expectAnonAccess) {
                                                        assert.equal(items.results.length, 1);
                                                        assert.equal(items.results[0].id, contentId);
                                                    } else {
                                                        assert.equal(items.results.length, 0);
                                                    }
                                                    callback();
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        };
    
        /**
         * Test that will exercise the visibility part of the updateContentMetadata function for content. This test will create a public 
         * content item, try to give it a non-existing visibility, then make it visible to logged in users, then make it private and 
         * then try to change the visibility as a non-manager. After all of those, we check if the manager, viewer, logged in user and 
         * anonymous user have access as expected.
         */
        it('verify update content visibility', function(callback) {
            // Create a piece of content
            setUpUsers(function(contexts) {
                RestAPI.Content.createLink(contexts['nicolaas'].restContext, 'Test Content 1', 'Test content description 1', 'public', 'http://www.sakaiproject.org/', [], [], function(err, contentObj) {    
                    assert.ok(!err);
                    assert.ok(contentObj.id);
                    // Share the content with one viewer
                    RestAPI.Content.shareContent(contexts['nicolaas'].restContext, contentObj.id, [contexts['simon'].user.id], function(err) {
                        assert.ok(!err);
                        // Check that all of these can get the content as expected, check library presence as expected
                        checkAccessAndLibrary(contexts, contentObj.id, true, true, function() {
                            // Try an invalid update
                            RestAPI.Content.updateContent(contexts['nicolaas'].restContext, contentObj.id, {'visibility': null}, function(err) {
                                assert.ok(err);
                                // Check that the access remains unchanged
                                checkAccessAndLibrary(contexts, contentObj.id, true, true, function() {
                                    // Try an unknown visibility update
                                    RestAPI.Content.updateContent(contexts['nicolaas'].restContext, contentObj.id, {'visibility': 'unknown-option'}, function(err) {
                                        assert.ok(err);
                                        // Check that the access remains unchanged
                                        checkAccessAndLibrary(contexts, contentObj.id, true, true, function() {
                                            // Make the content logged in only
                                            RestAPI.Content.updateContent(contexts['nicolaas'].restContext, contentObj.id, {'visibility': 'loggedin'}, function(err) {
                                                assert.ok(!err);
                                                // Check that everyone can get the content as expected, check library presence as expected
                                                checkAccessAndLibrary(contexts, contentObj.id, true, false, function() {
                                                    // Make the content private
                                                    RestAPI.Content.updateContent(contexts['nicolaas'].restContext, contentObj.id, {'visibility': 'private'}, function(err) {
                                                        assert.ok(!err);
                                                        // Check that everyone can get the content as expected, check library presence as expected
                                                        checkAccessAndLibrary(contexts, contentObj.id, false, false, function() {
                                                            // Try update as non-manager
                                                            RestAPI.Content.updateContent(contexts['simon'].restContext, contentObj.id, {'visibility': 'public'}, function(err) {
                                                                assert.ok(err);
                                                                // Check that everyone can get the content as expected, check library presence as expected
                                                                checkAccessAndLibrary(contexts, contentObj.id, false, false, callback);
                                                            });
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        it('verify file update validation', function(callback) {
             setUpUsers(function(contexts) {
                RestAPI.Content.createLink(contexts['nicolaas'].restContext, 'Test Content 2', 'Test content description 2', 'public', 'http://www.sakaiproject.org', [], [], function(err, contentObj) {
                    assert.ok(!err);
                    assert.ok(contentObj.id);

                    RestAPI.Content.updateFileBody(contexts['nicolaas'].restContext, contentObj.id, getSakaiLogoStream, function(err) {
                        assert.equal(err.code, 400);

                        RestAPI.Content.createFile(contexts['nicolaas'].restContext, 'Test Content 2', 'Test content description 2', 'public', getFileStream, [], [], function(err, contentObj) {
                            assert.ok(!err);
                            assert.ok(contentObj.id);

                            // Try to update without uploading anything.
                            RestAPI.Content.updateFileBody(contexts['nicolaas'].restContext, contentObj.id, null, function(err, revision) {
                                assert.ok(err);
                                assert.ok(!revision);

                                // Try to update by passing a string
                                RestAPI.Content.updateFileBody(contexts['nicolaas'].restContext, contentObj.id, 'haha, no actual file body', function(err) {
                                    assert.ok(err);

                                    // Try updating as a not-related person
                                    RestAPI.Content.updateFileBody(contexts['simon'].restContext, contentObj.id, getSakaiLogoStream, function(err) {
                                        assert.ok(err);

                                        RestAPI.Content.shareContent(contexts['nicolaas'].restContext, contentObj.id, [contexts['simon'].user.id], function(err) {
                                            assert.ok(!err);

                                            // Try updating as a non-manager.
                                            RestAPI.Content.updateFileBody(contexts['simon'].restContext, contentObj.id, getSakaiLogoStream, function(err) {
                                                assert.ok(err);

                                                // Make Simon a manager.
                                                var permissions = {};
                                                permissions[contexts['simon'].user.id] = 'manager';
                                                RestAPI.Content.updateMembers(contexts['nicolaas'].restContext, contentObj.id, permissions, function(err) {
                                                    assert.ok(!err);

                                                    // Ensure that the original owner can still update.
                                                    RestAPI.Content.updateFileBody(contexts['nicolaas'].restContext, contentObj.id, getSakaiLogoStream, function(err) {
                                                        assert.ok(!err);
                                                        callback();
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        it('verify file update', function(callback) {
            setUpUsers(function(contexts) {
                RestAPI.Content.createFile(contexts['nicolaas'].restContext, 'Test Content 2', 'Test content description 2', 'public', getFileStream, [], [], function(err, contentObj) {
                    assert.ok(!err);
                    assert.ok(contentObj.id);

                    // Get all the revisions.
                    RestAPI.Content.getRevisions(contexts['nicolaas'].restContext, contentObj.id, null, null, function(err, revisions) {
                        assert.ok(!err);
                        assert.ok(Array.isArray(revisions));
                        assert.equal(revisions.length, 1);

                        // Verify the revision object.
                        assert.equal(revisions[0].createdBy.displayName, 'Nicolaas Matthijs');
                        assert.equal(revisions[0].createdBy.resourceType, 'user');
                        assert.equal(revisions[0].createdBy.profilePath, '/user/' + revisions[0].createdBy.id);
                        assert.equal(revisions[0].opts.filename, 'sakaiger.png');
                        assert.equal(revisions[0].opts.mime, 'image/png');


                        // Upload a new version.
                        RestAPI.Content.updateFileBody(contexts['nicolaas'].restContext, contentObj.id, getSakaiLogoStream, function(err) {
                            assert.ok(!err);

                            // Get all the revisions.
                            RestAPI.Content.getRevisions(contexts['nicolaas'].restContext, contentObj.id, null, null, function(err, revisions) {
                                assert.ok(!err);
                                assert.ok(Array.isArray(revisions));
                                assert.equal(revisions.length, 2);

                                // Revisions should be sorted as the most recent one first.
                                assert.equal(revisions[0].opts.filename, 'sakai-logo.png');
                                assert.equal(revisions[0].opts.mime, 'image/png');

                                // Get the profile for a content item and ensure the most recent file properties are present.
                                RestAPI.Content.getContent(contexts['nicolaas'].restContext, contentObj.id, function(err, contentObj) {
                                    assert.ok(!err);
                                    assert.equal(contentObj.filename, 'sakai-logo.png');
                                    assert.equal(contentObj.mime, 'image/png');

                                    callback();
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    describe('Revisions', function() {

        it('verify empty revisions', function(callback) {
            setUpUsers(function(contexts) {
                // Create a content item
                RestAPI.Content.createLink(contexts['simon'].restContext, 'Sakai Foundation', 'The Sakai Foundation', 'public', 'http://www.sakaiproject.org/', [], [], function(err, contentObj) {                    
                    assert.ok(!err);
                    // Get the revisions.
                    RestAPI.Content.getRevisions(contexts['simon'].restContext, contentObj.id, null, null, function(err, revisions) {
                        assert.ok(!err);
                        assert.equal(revisions.length, 0);
                        callback();
                    });
                });
            });
        });

        it('verify revision permissions', function(callback) {
            setUpUsers(function(contexts) {
                // Create some content with a couple of revisions.
                RestAPI.Content.createFile(contexts['simon'].restContext, 'Test Content 1', 'Test content description 1', 'private', getFileStream,  [], [], function(err, contentSimon) {
                    assert.ok(!err);
                    assert.ok(contentSimon);

                    RestAPI.Content.updateFileBody(contexts['simon'].restContext, contentSimon.id, getSakaiLogoStream, function(err) {
                        assert.ok(!err);

                        RestAPI.Content.getRevisions(contexts['simon'].restContext, contentSimon.id, null, null, function(err, revisionsSimon) {
                            assert.ok(!err);
                            assert.equal(revisionsSimon.length, 2);

                            // Nico creates a piece of content.
                            RestAPI.Content.createLink(contexts['nicolaas'].restContext, 'Sakai Foundation', 'The Sakai Foundation', 'private', 'http://www.sakaiproject.org/', [], [], function(err, contentNico) {                    
                                assert.ok(!err);

                                // First of all, Nico shouldn't be able to see the revisions.
                                RestAPI.Content.getRevisions(contexts['nicolaas'].restContext, contentSimon.id, null, null, function(err, revisions) {
                                    assert.equal(err.code, 401);
                                    assert.ok(!revisions);

                                    // He also can't download them.
                                    var path = temp.path();
                                    RestAPI.Content.download(contexts['nicolaas'].restContext, contentSimon.id, revisionsSimon[1].revisionId, path, function(err, body) {
                                        assert.equal(err.code, 401);
                                        assert.ok(!body);

                                        // Nico should not be able to download a revision of Simon's file
                                        // by using one of his own content ID's and one of simon's revision ID he got (somehow).
                                        path = temp.path();
                                        RestAPI.Content.download(contexts['nicolaas'].restContext, contentNico.id, revisionsSimon[1].revisionId, path, function(err, body) {
                                            assert.equal(err.code, 401);
                                            assert.ok(!body);
                                            callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        it('verify revision parameter validation', function(callback) {
            setUpUsers(function(contexts) {
                // Create some content with a couple of revisions.
                RestAPI.Content.createFile(contexts['simon'].restContext, 'Test Content 1', 'Test content description 1', 'private', getFileStream,  [], [], function(err, contentObj) {
                    assert.ok(!err);
                    assert.ok(contentObj);

                    RestAPI.Content.updateFileBody(contexts['simon'].restContext, contentObj.id, getSakaiLogoStream, function(err) {
                        assert.ok(!err);

                        // Try to get the revisions with a faulty contentId
                        RestAPI.Content.getRevisions(contexts['simon'].restContext, 'not-a-content-id', null, null, function(err) {
                            assert.equal(err.code, 400);

                            // Get them and try downloading with a faulty revisionId.
                            RestAPI.Content.getRevisions(contexts['simon'].restContext, contentObj.id, null, null, function(err, revisions) {
                                assert.ok(!err);

                                var path = temp.path();
                                RestAPI.Content.download(contexts['simon'].restContext, contentObj.id, 'not-a-revision-id', path, function(err, response) {
                                    assert.equal(err.code, 400);
                                    callback();
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    describe('Delete content', function() {
    
        /**
         * Utitility function for the content delete assert. This function will create a piece of content, add a manager and a viewer using the setPermissions function,
         * share the content with an additional user. After each of these, the expected access will be checked. After that, the test will attempt to delete the content
         * as an anonymous user, a logged in user, a content member and a content manager. After that, the tests check if each of those can still access the content,
         * whether or not all roles have deleted, whether or not all libraries have been updated and whether or not the content members list is no longer available
         * @param  {Array<Context>}     contexts            Array of context objects that represent a request cycle and contain
         *                                                  the current user and the current tenant
         * @param  {User}               privacy             Privacy setting for the piece of content. Can be public, loggedin or private
         * @param  {Function(content)}  callback            Standard callback function
         */
        var prepareDelete = function(contexts, privacy, callback) {
            // Create a content item
            RestAPI.Content.createLink(contexts['nicolaas'].restContext, 'Test Content 1', 'Test content description 1', privacy, 'http://www.sakaiproject.org/', [], [], function(err, contentObj) {
                assert.ok(!err);
                assert.ok(contentObj.id);
                // Get the piece of content as the creator
                checkPieceOfContent(contexts['nicolaas'].restContext, contexts['nicolaas'].user.id, contentObj, true, true, true, function() {

                    // Make a user a manager and make a user a member
                    var permissions = {};
                    permissions[contexts['simon'].user.id] = 'manager';
                    permissions[contexts['bert'].user.id] = 'viewer';
                    RestAPI.Content.updateMembers(contexts['nicolaas'].restContext, contentObj.id, permissions, function(err) {
                        assert.ok(!err);
                        checkPieceOfContent(contexts['simon'].restContext, contexts['simon'].user.id, contentObj, true, true, true, function() {
                            checkPieceOfContent(contexts['bert'].restContext, contexts['bert'].user.id, contentObj, true, false, true, function() {

                                // Share the content with another user
                                RestAPI.Content.shareContent(contexts['simon'].restContext, contentObj.id, [contexts['branden'].user.id], function(err) {
                                    assert.ok(!err);
                                    checkPieceOfContent(contexts['branden'].restContext, contexts['branden'].user.id, contentObj, true, false, true, function() {

                                        // Try to delete the content as an anonymous user
                                        RestAPI.Content.deleteContent(anonymousRestContext, contentObj.id, function(err) {
                                            assert.ok(err);
                                            // Check that it is still around
                                            checkPieceOfContent(contexts['nicolaas'].restContext, contexts['nicolaas'].user.id, contentObj, true, true, true, function() {

                                                // Try to delete the content as a logged in user
                                                RestAPI.Content.deleteContent(contexts['anthony'].restContext, contentObj.id, function(err) {
                                                    assert.ok(err);
                                                    // Check that it is still around
                                                    checkPieceOfContent(contexts['nicolaas'].restContext, contexts['nicolaas'].user.id, contentObj, true, true, true, function() {

                                                        // Try to delete the content as a content member
                                                        RestAPI.Content.deleteContent(contexts['branden'].restContext, contentObj.id, function(err) {
                                                            assert.ok(err);
                                                            // Check that it is still around
                                                            checkPieceOfContent(contexts['nicolaas'].restContext, contexts['nicolaas'].user.id, contentObj, true, true, true, function() {

                                                                // Try to delete the content as a content manager
                                                                RestAPI.Content.deleteContent(contexts['nicolaas'].restContext, contentObj.id, function(err) {
                                                                    assert.ok(!err);
                                                                    // Check to see if the manager, a member, a logged in user and the anonymous user still have access
                                                                    checkPieceOfContent(contexts['nicolaas'].restContext, contexts['nicolaas'].user.id, contentObj, false, false, false, function() {
                                                                        checkPieceOfContent(contexts['bert'].restContext, contexts['bert'].user.id, contentObj, false, false, false, function() {
                                                                            checkPieceOfContent(contexts['anthony'].restContext, contexts['anthony'].user.id, contentObj, false, false, false, function() {
                                                                                checkPieceOfContent(anonymousRestContext, contexts['nicolaas'].user.id, contentObj, false, false, false, function() {
                                                                                    // Check roles api for the role on the content for a manager, a member and a logged in user
                                                                                    AuthzAPI.getAllRoles(contexts['nicolaas'].user.id, contentObj.id, function(err, roles) {
                                                                                        assert.equal(roles.length, 0);
                                                                                        AuthzAPI.getAllRoles(contexts['bert'].user.id, contentObj.id, function(err, roles) {
                                                                                            assert.equal(roles.length, 0);
                                                                                            AuthzAPI.getAllRoles(contexts['anthony'].user.id, contentObj.id, function(err, roles) {
                                                                                                assert.equal(roles.length, 0);
                                                                                                // Check whether the list of members is no longer accessible
                                                                                                RestAPI.Content.getMembers(contexts['nicolaas'].restContext, contentObj.id, null, null, function(err) {
                                                                                                    assert.ok(err);
                                                                                                    callback();
                                                                                                });
                                                                                            });
                                                                                        });
                                                                                    });
                                                                                });
                                                                            });
                                                                        });
                                                                    });
                                                                });
                                                            });
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        };
    
        /**
         * Test that will attempt to create a public piece of content and delete it
         */
        it('verify public delete', function(callback) {
            setUpUsers(function(contexts) {
                prepareDelete(contexts, 'public', callback);
            });
        });
    
        /**
         * Test that will attempt to create a logged in piece of content and delete it
         */
        it('verify logged in delete', function(callback) {
            setUpUsers(function(contexts) {
                prepareDelete(contexts, 'loggedin', callback);
            });
        });
    
        /**
         * Test that will attempt to create a private piece of content and delete it
         */
        it('verify private delete', function(callback) {
            setUpUsers(function(contexts) {
                prepareDelete(contexts, 'private', callback);
            });
        });

        /**
         * Verify file deletion
         */
        it('verify file delete', function(callback) {
            setUpUsers(function(contexts) {
                RestAPI.Content.createFile(contexts['nicolaas'].restContext, 'Test Content 2', 'Test content description 2', 'public', getFileStream, [], [], function(err, contentObj) {
                    assert.ok(!err);
                    assert.ok(contentObj.id);

                    // Get the last revision.
                    RestAPI.Content.getRevisions(contexts['nicolaas'].restContext, contentObj.id, null, 1000, function(err, revisions) {
                        assert.ok(!err);
                
                        RestAPI.Content.deleteContent(contexts['nicolaas'].restContext, contentObj.id, function(err) {
                            assert.ok(!err);

                            // Get the last revision.
                            RestAPI.Content.getRevisions(contexts['nicolaas'].restContext, contentObj.id, null, 1000, function(err, revisions) {
                                assert.equal(err.code, 404);
                                callback();
                            });
                        });
                    });
                });
            });
        });
    });

    
    describe('Content permissions', function() {
    
        /**
         * Utility function that creates a piece of content, make a user a manager, make a user a viewer and test access for all of these as 
         * well as library content and the membership list of the content
         * @param  {Object}             contexts            Object where the keys are identifiers for the created users and the values are an
         *                                                  object with a user key containing the user object for the created user and a restContext key
         *                                                  containing the REST Context for that user
         * @param  {User}               privacy             Privacy setting for the piece of content. Can be public, loggedin or private
         * @param  {Function(content)}  callback            Standard callback function
         * @param  {Content}            callback.content    Content object that has been created as part of this test
         */
        var setUpContentPermissions = function(contexts, privacy, callback) {
            // Create a public content item
            RestAPI.Content.createLink(contexts['nicolaas'].restContext, 'Test Content 1', 'Test content description 1', privacy, 'http://www.sakaiproject.org/', [], [], function(err, contentObj) {    
                assert.ok(!err);
                assert.ok(contentObj.id);

                // Get the piece of content as the person who created the content
                checkPieceOfContent(contexts['nicolaas'].restContext, contexts['nicolaas'].user.id, contentObj, true, true, true, function() {
                    // Check the list of content members
                    RestAPI.Content.getMembers(contexts['nicolaas'].restContext, contentObj.id, null, null, function(err, members) {
                        assert.ok(!err);
                        assert.equal(members.results.length, 1);
                        // Morph results to hash for easy access.
                        var hash = _.groupBy(members.results, function(member) { return member.profile.id; });
                        assert.equal(hash[contexts['nicolaas'].user.id][0].role, 'manager');

                        // Try an invalid set permissions with no principals passed in
                        RestAPI.Content.updateMembers(contexts['nicolaas'].restContext, contentObj.id, {}, function(err) {
                            assert.ok(err);

                            // Make another user manager of the content
                            var permissions = {};
                            permissions[contexts['simon'].user.id] = 'manager';
                            RestAPI.Content.updateMembers(contexts['nicolaas'].restContext, contentObj.id, permissions, function(err) {
                                assert.ok(!err);
                                // Get the piece of content as the newly added manager
                                checkPieceOfContent(contexts['simon'].restContext, contexts['simon'].user.id, contentObj, true, true, true, function() {
                                    RestAPI.Content.getMembers(contexts['nicolaas'].restContext, contentObj.id, null, null, function(err, members) {
                                        assert.ok(!err);
                                        assert.equal(members.results.length, 2);
                                        // Morph results to hash for easy access.
                                        var hash = _.groupBy(members.results, function(member) { return member.profile.id; });
                                        assert.equal(hash[contexts['nicolaas'].user.id][0].role, 'manager');
                                        assert.equal(hash[contexts['simon'].user.id][0].role, 'manager');

                                        // Make another user member of the content
                                        permissions = {};
                                        permissions[contexts['bert'].user.id] = 'viewer';
                                        RestAPI.Content.updateMembers(contexts['nicolaas'].restContext, contentObj.id, permissions, function(err) {
                                            assert.ok(!err);
                                            // Get the piece of content as the added member
                                            checkPieceOfContent(contexts['bert'].restContext, contexts['bert'].user.id, contentObj, true, false, true, function() {
                                                RestAPI.Content.getMembers(contexts['nicolaas'].restContext, contentObj.id, null, null, function(err, members) {
                                                    assert.ok(!err);
                                                    assert.equal(members.results.length, 3);
                                                    // Morph results to hash for easy access.
                                                    var hash = _.groupBy(members.results, function(member) { return member.profile.id; });
                                                    assert.equal(hash[contexts['nicolaas'].user.id][0].role, 'manager');
                                                    assert.equal(hash[contexts['simon'].user.id][0].role, 'manager');
                                                    assert.equal(hash[contexts['bert'].user.id][0].role, 'viewer');

                                                    // Try to add an existing and non-existing user
                                                    permissions = {};
                                                    permissions[contexts['anthony'].user.id] = 'viewer';
                                                    permissions['u:cam:nonExistingUser'] = 'viewer';
                                                    RestAPI.Content.updateMembers(contexts['nicolaas'].restContext, contentObj.id, permissions, function(err) {
                                                        assert.ok(err);
                                                        // Get the piece of content as the member that was part of the invalid setPermissions
                                                        checkPieceOfContent(contexts['anthony'].restContext, contexts['anthony'].user.id, contentObj, privacy === 'private' ? false : true, false, false, function() {
                                                            RestAPI.Content.getMembers(contexts['nicolaas'].restContext, contentObj.id, null, null, function(err, members) {
                                                                assert.ok(!err);
                                                                assert.equal(members.results.length, 3);
                                                                // Morph results to hash for easy access.
                                                                var hash = _.groupBy(members.results, function(member) { return member.profile.id; });
                                                                assert.equal(hash[contexts['nicolaas'].user.id][0].role, 'manager');
                                                                assert.equal(hash[contexts['simon'].user.id][0].role, 'manager');
                                                                assert.equal(hash[contexts['bert'].user.id][0].role, 'viewer');

                                                                // Remove a manager from the content
                                                                permissions = {};
                                                                permissions[contexts['simon'].user.id] = false;
                                                                RestAPI.Content.updateMembers(contexts['nicolaas'].restContext, contentObj.id, permissions, function(err) {
                                                                    assert.ok(!err);
                                                                    // Get the piece of content as the removed manager
                                                                    checkPieceOfContent(contexts['simon'].restContext, contexts['simon'].user.id, contentObj, privacy === 'private' ? false : true, false, false, function() {
                                                                        RestAPI.Content.getMembers(contexts['nicolaas'].restContext, contentObj.id, null, null, function(err, members) {
                                                                            assert.ok(!err);
                                                                            assert.equal(members.results.length, 2);
                                                                            // Morph results to hash for easy access.
                                                                            var hash = _.groupBy(members.results, function(member) { return member.profile.id; });
                                                                            assert.equal(hash[contexts['nicolaas'].user.id][0].role, 'manager');
                                                                            assert.equal(hash[contexts['simon'].user.id], undefined);
                                                                            assert.equal(hash[contexts['bert'].user.id][0].role, 'viewer');

                                                                            // Try setting the permissions with an undefined role
                                                                            permissions = {};
                                                                            permissions[contexts['branden'].user.id] = undefined;
                                                                            RestAPI.Content.updateMembers(contexts['nicolaas'].restContext, contentObj.id, permissions, function(err) {
                                                                                assert.ok(err);

                                                                                // Try to set the permissions on the content as a non-manager of the content
                                                                                permissions = {};
                                                                                permissions[contexts['branden'].user.id] = 'viewer';
                                                                                RestAPI.Content.updateMembers(contexts['simon'].restContext, contentObj.id, permissions, function(err) {
                                                                                    assert.ok(err);
                                                                                    callback(contentObj);
                                                                                });
                                                                            });
                                                                        });
                                                                    });
                                                                });
                                                            });
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        };
    
        /**
         * Test that will attempt to set permissions on a public piece of content
         */
        it('verify public content permissions', function(callback) {
            setUpUsers(function(contexts) {
                setUpContentPermissions(contexts, 'public', function(contentObj) {
                    // Get the piece of content as a non-associated user
                    checkPieceOfContent(contexts['branden'].restContext, contexts['branden'].user.id, contentObj, true, false, false, function() {
                        // Get the piece of content as an anonymous user
                        checkPieceOfContent(anonymousRestContext, contexts['nicolaas'].user.id, contentObj, true, false, true, callback);
                    });
                });
            });
        });
    
        /**
         * Test that will attempt to set permissions on a loggedin piece of content
         */
        it('verify logged in content permissions', function(callback) {
            setUpUsers(function(contexts) {
                setUpContentPermissions(contexts, 'loggedin', function(contentObj) {
                    // Get the piece of content as a non-associated user
                    checkPieceOfContent(contexts['branden'].restContext, contexts['branden'].user.id, contentObj, true, false, false, function() {
                        // Get the piece of content as an anonymous user
                        checkPieceOfContent(anonymousRestContext, contexts['nicolaas'].user.id, contentObj, false, false, false, callback);
                    });
                });
            });
        });
    
        /**
         * Test that will attempt to set permissions on a private piece of content
         */
        it('verify private content permissions', function(callback) {
            setUpUsers(function(contexts) {
                setUpContentPermissions(contexts, 'private', function(contentObj) {
                    // Get the piece of content as a non-associated user
                    checkPieceOfContent(contexts['branden'].restContext, contexts['branden'].user.id, contentObj, false, false, false, function() {
                        // Get the piece of content as an anonymous user
                        checkPieceOfContent(anonymousRestContext, contexts['nicolaas'].user.id, contentObj, false, false, false, callback);
                    });
                });
            });
        });
        
        /**
         * Test that will attempt to set permissions on multiple principals at once. It will add permissions and
         * remove permissions on sets of principals that have all valid principals and some with non-valid principals
         */
        it('verify multiple content permissions', function(callback) {
            setUpUsers(function(contexts) {
                // Create a content item
                RestAPI.Content.createLink(contexts['nicolaas'].restContext, 'Test Content 1', 'Test content description 1', 'public', 'http://www.sakaiproject.org/', [], [], function(err, contentObj) {    
                    assert.ok(!err);
                    assert.ok(contentObj.id);

                    // Set permission on multiple people at the same time (managers and members)
                    var permissions = {};
                    permissions[contexts['simon'].user.id] = 'manager';
                    permissions[contexts['bert'].user.id] = 'viewer';
                    permissions[contexts['branden'].user.id] = 'viewer';
                    RestAPI.Content.updateMembers(contexts['nicolaas'].restContext, contentObj.id, permissions, function(err) {
                        assert.ok(!err);
                        // Verify that the members have been set
                        RestAPI.Content.getMembers(contexts['nicolaas'].restContext, contentObj.id, null, null, function(err, members) {
                            assert.ok(!err);
                            assert.equal(members.results.length, 4);
                            // Morph results to hash for easy access.
                            var hash = _.groupBy(members.results, function(member) { return member.profile.id; });
                            assert.equal(hash[contexts['nicolaas'].user.id][0].role, 'manager');
                            assert.equal(hash[contexts['simon'].user.id][0].role, 'manager');
                            assert.equal(hash[contexts['bert'].user.id][0].role, 'viewer');
                            assert.equal(hash[contexts['branden'].user.id][0].role, 'viewer');

                            // Set permission on multiple people at same time, some remove role
                            permissions = {};
                            permissions[contexts['simon'].user.id] = false;
                            permissions[contexts['bert'].user.id] = false;
                            permissions[contexts['anthony'].user.id] = 'viewer';
                            RestAPI.Content.updateMembers(contexts['nicolaas'].restContext, contentObj.id, permissions, function(err) {
                                assert.ok(!err);
                                // Verify that the members have been set and removed
                                RestAPI.Content.getMembers(contexts['nicolaas'].restContext, contentObj.id, null, null, function(err, members) {
                                    assert.ok(!err);
                                    assert.equal(members.results.length, 3);
                                    // Morph results to hash for easy access.
                                    var hash = _.groupBy(members.results, function(member) { return member.profile.id; });
                                    assert.equal(hash[contexts['nicolaas'].user.id][0].role, 'manager');
                                    assert.equal(hash[contexts['branden'].user.id][0].role, 'viewer');
                                    assert.equal(hash[contexts['anthony'].user.id][0].role, 'viewer');

                                    // Set permission on multiple people at same time (managers and members), some invalid
                                    permissions = {};
                                    permissions[contexts['simon'].user.id] = 'manager';
                                    permissions[contexts['bert'].user.id] = 'viewer';
                                    permissions['u:cam:non-existing-user'] = 'viewer';
                                    RestAPI.Content.updateMembers(contexts['nicolaas'].restContext, contentObj.id, permissions, function(err) {
                                        assert.ok(err);
                                        // Verify that the members have not changed
                                        RestAPI.Content.getMembers(contexts['nicolaas'].restContext, contentObj.id, null, null, function(err, members) {
                                            assert.ok(!err);
                                            assert.equal(members.results.length, 3);
                                            // Morph results to hash for easy access.
                                            var hash = _.groupBy(members.results, function(member) { return member.profile.id; });
                                            assert.equal(hash[contexts['nicolaas'].user.id][0].role, 'manager');
                                            assert.equal(hash[contexts['branden'].user.id][0].role, 'viewer');
                                            assert.equal(hash[contexts['anthony'].user.id][0].role, 'viewer');

                                            // Set permission on multiple people at same time, some remove role, some invalid
                                            permissions = {};
                                            permissions[contexts['branden'].user.id] = false;
                                            permissions[contexts['anthony'].user.id] = false;
                                            permissions['u:cam:non-existing-user'] = false;
                                            RestAPI.Content.updateMembers(contexts['nicolaas'].restContext, contentObj.id, permissions, function(err) {
                                                assert.ok(err);
                                                // Verify that the members have not changed
                                                RestAPI.Content.getMembers(contexts['nicolaas'].restContext, contentObj.id, null, null, function(err, members) {
                                                    assert.ok(!err);
                                                    assert.equal(members.results.length, 3);
                                                    // Morph results to hash for easy access.
                                                    var hash = _.groupBy(members.results, function(member) { return member.profile.id; });
                                                    assert.equal(hash[contexts['nicolaas'].user.id][0].role, 'manager');
                                                    assert.equal(hash[contexts['branden'].user.id][0].role, 'viewer');
                                                    assert.equal(hash[contexts['anthony'].user.id][0].role, 'viewer');
                                                    callback();
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Verifies that you cannot create ghost entities by removing all the managers of a content item.
         */
        it('verify removal of all managers is not possible.', function(callback) {
            setUpUsers(function(contexts) {
                // Create a content item
                RestAPI.Content.createLink(contexts['nicolaas'].restContext, 'Test Content 1', 'Test content description 1', 'public', 'http://www.sakaiproject.org/', [], [], function(err, contentObj) {
                    assert.ok(!err);
                    assert.ok(contentObj.id);

                    // Set permission on multiple people at the same time (managers and members)
                    var permissions = {};
                    permissions[contexts['simon'].user.id] = 'manager';
                    permissions[contexts['bert'].user.id] = 'viewer';
                    permissions[contexts['branden'].user.id] = 'viewer';
                    RestAPI.Content.updateMembers(contexts['nicolaas'].restContext, contentObj.id, permissions, function(err) {
                        assert.ok(!err);

                        // Removing all the managers should not be allowed.
                        permissions = {};
                        permissions[contexts['simon'].user.id] = false;
                        permissions[contexts['nicolaas'].user.id] = false;
                        RestAPI.Content.updateMembers(contexts['nicolaas'].restContext, contentObj.id, permissions, function(err) {
                            assert.equal(err.code, 400);

                            // Making both of them viewer should not work either.
                            permissions = {};
                            permissions[contexts['simon'].user.id] = 'viewer';
                            permissions[contexts['nicolaas'].user.id] = 'viewer';
                            RestAPI.Content.updateMembers(contexts['nicolaas'].restContext, contentObj.id, permissions, function(err) {
                                assert.equal(err.code, 400);

                                // Removing everyone should not be possible
                                permissions = {};
                                permissions[contexts['simon'].user.id] = false;
                                permissions[contexts['nicolaas'].user.id] = false;
                                permissions[contexts['bert'].user.id] = false;
                                permissions[contexts['branden'].user.id] = false;
                                RestAPI.Content.updateMembers(contexts['nicolaas'].restContext, contentObj.id, permissions, function(err) {
                                    assert.equal(err.code, 400);

                                    permissions = {};
                                    permissions[contexts['simon'].user.id] = 'viewer';
                                    permissions[contexts['nicolaas'].user.id] = false;
                                    RestAPI.Content.updateMembers(contexts['nicolaas'].restContext, contentObj.id, permissions, function(err) {
                                        assert.equal(err.code, 400);
                                        callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });


        // TODO: Create unit test for paging on getContentMembers
        // TODO: Test get content members with no provided contentId
        
    });


    describe('Content sharing', function() {
        
        /**
         * Utility function for the sharing tests that will create a new content item, check for successful creation and check that
         * the right set of content members are retrieved
         * @param  {Object}             contexts            Object where the keys are identifiers for the created users and the values are an
         *                                                  object with a user key containing the user object for the created user and a restContext key
         *                                                  containing the REST Context for that user
         * @param  {User}               privacy             Privacy setting for the piece of content. Can be public, loggedin or private
         * @param  {Function(content)}  callback            Standard callback function
         * @param  {Content}            callback.content    Content object that has been created as part of this test
         */
        var prepareSharing = function(contexts, privacy, callback) {
            // Create a content item
            RestAPI.Content.createLink(contexts['nicolaas'].restContext, 'Test Content 1', 'Test content description 1', privacy, 'http://www.sakaiproject.org/', [], [], function(err, contentObj) {    
                assert.ok(!err);
                assert.ok(contentObj.id);
                // Get the piece of content as the creator
                checkPieceOfContent(contexts['nicolaas'].restContext, contexts['nicolaas'].user.id, contentObj, true, true, true, function() {
                    RestAPI.Content.getMembers(contexts['nicolaas'].restContext, contentObj.id, null, null, function(err, members) {
                        assert.ok(!err);
                        assert.equal(members.results.length, 1);
                        // Morph results to hash for easy access.
                        var hash = _.groupBy(members.results, function(member) { return member.profile.id; });
                        assert.equal(hash[contexts['nicolaas'].user.id][0].role, 'manager');
                        callback(contentObj);
                     });
                });
            });
        };
    
        /**
         * Utility function for the sharing tests that will try to share content, will then check for access to the content by the person
         * the content was shared with. Then the test will check whether that person can see the content's membership list and sees the
         * correct list of members in there
         * @param  {Content}        contentObj          Content object that will be shared
         * @param  {Object}         sharer              Object representing the user that will share the content. The object will have a user key containing the user's basic profile and a restContext key containing the user's Rest Context
         * @param  {Object}         shareWith           Object representing the user that the content will be shared with. The object will have a user key containing the user's basic profile and a restContext key containing the user's Rest Context. Content access, library presence and membership checks will be run on this user
         * @param  {Boolean}        expectShare         Whether or not we expect that user 1 will be able to share the content with user 2
         * @param  {Boolean}        expectAccess        Whether or not we expect that user 2 will have access to the content after it's been shared with him
         * @param  {Boolean}        expectManager       Whether or not we expect that user 2 will be able to manage the content after it's been shared with him
         * @param  {Boolean}        expectInLibrary     Whether or not we expect user 2 to be able to see the content in his library after it's been shared with him
         * @param  {Object}         expectedMembers     JSON object representing the members that are expected to be on the content item after sharing. The keys represent the member ids and the values represent the role they should have. 
         * @param  {Function}       callback            Standard callback function
         */
        var testSharing = function(contentObj, sharer, shareWith, expectShare, expectAccess, expectManager, expectInLibrary, expectedMembers, callback) {
            RestAPI.Content.shareContent(sharer.restContext, contentObj.id, [shareWith.user.id], function(err) {
                if (expectShare) {
                    assert.ok(!err);
                } else {
                    assert.ok(err);
                }
                checkPieceOfContent(shareWith.restContext, shareWith.user ? shareWith.user.id : null, contentObj, expectAccess, expectManager, expectInLibrary, function() {
                    RestAPI.Content.getMembers(shareWith.restContext, contentObj.id, null, null, function(err, members) {
                        if (expectedMembers) {
                            assert.ok(!err);
                            assert.equal(members.results.length, _.keys(expectedMembers).length);
                            for (var m = 0; m < members.results.length; m++) {
                                assert.equal(members.results[m].role, expectedMembers[members.results[m].profile.id]);
                            }
                        } else {
                            assert.ok(err);
                        }
                        callback();
                    });
                });
            });
        };
    
        /**
         * Test that will attempt to create a public piece of content, share it as the manager, share it as a member, share it
         * as a non-related user and share it as an anonymous user. For each of those, it will check for content access, library
         * presence and the correct content membership list 
         */
        it('verify public sharing', function(callback) {
            setUpUsers(function(contexts) {
                // Create a public content item
                prepareSharing(contexts, 'public', function(contentObj) {
                    // Share as content owner
                    var expectedMembers = {};
                    expectedMembers[contexts['nicolaas'].user.id] = 'manager';
                    expectedMembers[contexts['simon'].user.id] = 'viewer';
                    testSharing(contentObj, contexts['nicolaas'], contexts['simon'], true, true, false, true, expectedMembers, function() {

                        // Share as content member
                        expectedMembers[contexts['bert'].user.id] = 'viewer';
                        testSharing(contentObj, contexts['simon'], contexts['bert'], true, true, false, true, expectedMembers, function() {

                            // Share as other user, add to own library
                            expectedMembers[contexts['branden'].user.id] = 'viewer';
                            testSharing(contentObj, contexts['bert'], contexts['branden'], true, true, false, true, expectedMembers, function() {

                                // Share with the content manager, making sure that he's still the content manager after sharing
                                testSharing(contentObj, contexts['branden'], contexts['nicolaas'], true, true, true, true, expectedMembers, function() {

                                    // Share as anonymous
                                    testSharing(contentObj, {'restContext': anonymousRestContext}, contexts['anthony'], false, true, false, false, expectedMembers, callback); 
                                });
                            }); 
                        });
                    });
                });
            });
        });
    
        /**
         * Test that will attempt to create a loggedin piece of content, share it as the manager, share it as a member, share it
         * as a non-related user and share it as an anonymous user. For each of those, it will check for content access, library
         * presence and the correct content membership list 
         */
        it('verify logged in sharing', function(callback) {
            setUpUsers(function(contexts) {
                // Create a loggedin content item
                prepareSharing(contexts, 'loggedin', function(contentObj) {
                    // Share as content owner
                    var expectedMembers = {};
                    expectedMembers[contexts['nicolaas'].user.id] = 'manager';
                    expectedMembers[contexts['simon'].user.id] = 'viewer';
                    testSharing(contentObj, contexts['nicolaas'], contexts['simon'], true, true, false, true, expectedMembers, function() {

                        // Share as content member
                        expectedMembers[contexts['bert'].user.id] = 'viewer';
                        testSharing(contentObj, contexts['simon'], contexts['bert'], true, true, false, true, expectedMembers, function() {

                            // Share as other user, add to own library
                            expectedMembers[contexts['branden'].user.id] = 'viewer';
                            testSharing(contentObj, contexts['branden'], contexts['branden'], true, true, false, true, expectedMembers, function() {

                                // Share with the content manager, making sure that he's still the content manager after sharing
                                testSharing(contentObj, contexts['branden'], contexts['nicolaas'], true, true, true, true, expectedMembers, function() {

                                    // Share as anonymous
                                    testSharing(contentObj, {'restContext': anonymousRestContext}, contexts['anthony'], false, true, false, false, expectedMembers, callback);
                                });
                            }); 
                        });
                    });
                });
            });
        });
    
        /**
         * Test that will attempt to create a private piece of content, share it as the manager, share it as a member, share it
         * as a non-related user and share it as an anonymous user. For each of those, it will check for content access, library
         * presence and the correct content membership list 
         */
        it('verify private sharing', function(callback) {
            setUpUsers(function(contexts) {
                // Create a private content item
                prepareSharing(contexts, 'private', function(contentObj) {
                    // Share as content owner
                    var expectedMembers = {};
                    expectedMembers[contexts['nicolaas'].user.id] = 'manager';
                    expectedMembers[contexts['simon'].user.id] = 'viewer';
                    testSharing(contentObj, contexts['nicolaas'], contexts['simon'], true, true, false, true, expectedMembers, function() {

                        // Share as content member
                        testSharing(contentObj, contexts['simon'], contexts['bert'], false, false, false, false, null, function() {

                            // Share as other user, add to own library
                            testSharing(contentObj, contexts['branden'], contexts['branden'], false, false, false, false, null, function() {

                                // Share with the content manager, making sure that he's still the content manager after sharing
                                testSharing(contentObj, contexts['simon'], contexts['nicolaas'], false, true, true, true, expectedMembers, function() {

                                    // Share as anonymous
                                    testSharing(contentObj, {'restContext': anonymousRestContext}, contexts['anthony'], false, false, false, false, null, callback);
                                });
                            }); 
                        });
                    });
                });
            });
        });
        
        /**
         * Test that will attempt to use the shareContent function with multiple people and/or groups at the same time. Invalid
         * principal ids will be added in as well.
         */
        it('verify multiple sharing', function(callback) {
            setUpUsers(function(contexts) {
                // Create a piece of content
                prepareSharing(contexts, 'private', function(contentObj) {
                    // Share with multiple people at the same time
                    var toShare = [contexts['simon'].user.id, contexts['bert'].user.id, contexts['branden'].user.id];
                    RestAPI.Content.shareContent(contexts['nicolaas'].restContext, contentObj.id, toShare, function(err) {
                        assert.ok(!err);

                        // Check that these people have access
                        checkPieceOfContent(contexts['simon'].restContext, contexts['simon'].user.id, contentObj, true, false, true, function() {
                            checkPieceOfContent(contexts['bert'].restContext, contexts['bert'].user.id, contentObj, true, false, true, function() {
                                checkPieceOfContent(contexts['branden'].restContext, contexts['branden'].user.id, contentObj, true, false, true, function() {
                                    checkPieceOfContent(contexts['anthony'].restContext, contexts['anthony'].user.id, contentObj, false, false, false, function() {

                                        // Share with multiple people, of which some are invalid users
                                        toShare = [contexts['anthony'].user.id, 'u:cam:nonExistingUser'];
                                        RestAPI.Content.shareContent(contexts['nicolaas'].restContext, contentObj.id, toShare, function(err) {
                                            assert.ok(err);
                                            checkPieceOfContent(contexts['anthony'].restContext, contexts['anthony'].user.id, contentObj, false, false, false, callback);
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

    });


    describe('Group related content access', function() {
        
        /**
         * Utility function for the for group-related content access. The following situation is assumed:
         * 1) UI Dev Group has 2 members, Nicolaas is a manager, Bert is a manager
         * 2) Back-end Dev Group has 2 members, Branden is a manager, Simon is a member
         * 3) OAE Team Group has 4 members, Anthony is a manager, Stuart is a member
         *    UI Dev Group is a member and Back-end Dev Group is a member
         * 
         * The following steps will be taken:
         * 1) A content item is created with the specified visibility
         * 2) Permissions are set on the content
         *  2.1) The UI Dev Group is made a viewer
         *  2.2) Simon is made a viewer
         *  2.3) We check that the content is part of the UI Dev Group's library
         *  2.4) We verify that Simon has access to content
         *  2.5) We verify that Bert and Nico have access to the content through the UI Dev Group membership
         *  2.6) We verify that the content doesn't show in the library of OAE Team and the Back-end team
         *  2.7) We verify that Stuart and Branden don't have access to the content
         * 3) The content is shared with the OAE Team Group
         *  3.1) We verify that Stuart and Branden now have access to the content
         *  3.2) We verify that the content shows in OAE Team and UI Dev team's library and not in the Back-end Team's library
         * 4) The Back-end Team Group is made a manager of the content
         *  4.1) We verify that Simon and Branden are now a manager
         *  4.2) We verify that Stuart is not a manager
         * 5) The permissions for OAE Team Group and Back-end Team Group are removed from the content
         *  5.1) We verify that Branden no longer has access to the content
         *  5.2) We verify that Simon and Nicolaas still have access to the content
         * @param  {Array<Context>}     contexts            Array of context objects that represent a request cycle and contain
         *                                                  the current user and the current tenant
         * @param  {Array<Group>}       groups              Array of group objects that will be used as part of this test
         * @param  {User}               privacy             Privacy setting for the piece of content. Can be public, loggedin or private
         * @param  {Function}           callback            Standard callback function
         */
        var testGroupAccess = function(contexts, groups, privacy, callback) {
            // Anthony creates a content item
            RestAPI.Content.createLink(contexts['anthony'].restContext, 'Test Content 1', 'Test content description 1', privacy, 'http://www.sakaiproject.org/', [], [], function(err, contentObj) {    
                assert.ok(!err);
                assert.ok(contentObj.id);
        
                // Set permissions on content --> Make UI dev team member, make Simon a member
                var permissions = {};
                permissions[groups['ui-team'].id] = 'viewer';
                permissions[contexts['simon'].user.id] = 'viewer';
                RestAPI.Content.updateMembers(contexts['anthony'].restContext, contentObj.id, permissions, function(err) {
                    assert.ok(!err);
                    // Check that UI Dev Team, Bert, Nico and Simon have member access
                    checkPieceOfContent(contexts['bert'].restContext, groups['ui-team'].id, contentObj, true, false, true, function() {
                        checkPieceOfContent(contexts['nicolaas'].restContext, contexts['nicolaas'].user.id, contentObj, true, false, false, function() {
                            checkPieceOfContent(contexts['bert'].restContext, contexts['bert'].user.id, contentObj, true, false, false, function() {
                                // Check that it shows in UI Dev Team's library
                                RestAPI.Content.getLibrary(contexts['nicolaas'].restContext, groups['ui-team'].id, null, 10, function(err, contentItems) {
                                    assert.ok(!err);
                                    assert.equal(contentItems.results.length, 1);
                                    assert.equal(contentItems.results[0].id, contentObj.id);
                                    // Check that it shows in Simon's library
                                    RestAPI.Content.getLibrary(contexts['simon'].restContext, contexts['simon'].user.id, null, 10, function(err, contentItems) {
                                        assert.ok(!err);
                                        assert.equal(contentItems.results.length, 1);
                                        assert.equal(contentItems.results[0].id, contentObj.id);
                                        // Check that it doesn't show in Nico's library
                                        RestAPI.Content.getLibrary(contexts['nicolaas'].restContext, contexts['nicolaas'].user.id, null, 10, function(err, contentItems) {
                                            assert.ok(!err);
                                            assert.equal(contentItems.results.length, 0);
                                            // Check that it doesn't show in Bert's library
                                            RestAPI.Content.getLibrary(contexts['bert'].restContext, contexts['bert'].user.id, null, 10, function(err, contentItems) {
                                                assert.ok(!err);
                                                assert.equal(contentItems.results.length, 0);
                                                // Check that it doesn't show in OAE Team's and Back-end team's library
                                                RestAPI.Content.getLibrary(contexts['anthony'].restContext, groups['backend-team'].id, null, 10, function(err, contentItems) {
                                                    assert.ok(!err);
                                                    assert.equal(contentItems.results.length, 0);
                                                    RestAPI.Content.getLibrary(contexts['anthony'].restContext, groups['oae-team'].id, null, 10, function(err, contentItems) {
                                                        assert.ok(!err);
                                                        assert.equal(contentItems.results.length, 0);
                                                        // Check that Stuart doesn't have access
                                                        checkPieceOfContent(contexts['stuart'].restContext, contexts['stuart'].user.id, contentObj, privacy === 'private' ? false : true, false, false, function() {
                                                            // Check that Branden doesn't have access
                                                            checkPieceOfContent(contexts['branden'].restContext, contexts['branden'].user.id, contentObj, privacy === 'private' ? false : true, false, false, function() {
        
                                                                // Share with the OAE Team group
                                                                RestAPI.Content.shareContent(contexts['anthony'].restContext, contentObj.id, [groups['oae-team'].id], function(err) {
                                                                    // Check that Stuart has access
                                                                    checkPieceOfContent(contexts['stuart'].restContext, contexts['stuart'].user.id, contentObj, true, false, false, function() {
                                                                        // Check that Branden has access
                                                                        checkPieceOfContent(contexts['branden'].restContext, contexts['branden'].user.id, contentObj, true, false, false, function() {
                                                                            // Check that it shows in OAE Team and UI Dev team's library and not in the Back-End Team's library
                                                                            RestAPI.Content.getLibrary(contexts['anthony'].restContext, groups['oae-team'].id, null, 10, function(err, contentItems) {
                                                                                assert.ok(!err);
                                                                                assert.equal(contentItems.results.length, 1);
                                                                                assert.equal(contentItems.results[0].id, contentObj.id);
                                                                                RestAPI.Content.getLibrary(contexts['nicolaas'].restContext, groups['ui-team'].id, null, 10, function(err, contentItems) {
                                                                                    assert.ok(!err);
                                                                                    assert.equal(contentItems.results.length, 1);
                                                                                    assert.equal(contentItems.results[0].id, contentObj.id);
                                                                                    RestAPI.Content.getLibrary(contexts['simon'].restContext, groups['backend-team'].id, null, 10, function(err, contentItems) {
                                                                                        assert.ok(!err);
                                                                                        assert.equal(contentItems.results.length, 0);
        
                                                                                        // Make Back-end team manager
                                                                                        permissions = {};
                                                                                        permissions[groups['backend-team'].id] = 'manager';
                                                                                        RestAPI.Content.updateMembers(contexts['anthony'].restContext, contentObj.id, permissions, function(err) {
                                                                                            assert.ok(!err);
                                                                                            // Check that Simon and Branden are manager, check that Stuart is not a manager
                                                                                            checkPieceOfContent(contexts['simon'].restContext, contexts['simon'].user.id, contentObj, true, true, true, function() {
                                                                                                checkPieceOfContent(contexts['branden'].restContext, contexts['branden'].user.id, contentObj, true, true, false, function() {
                                                                                                    checkPieceOfContent(contexts['stuart'].restContext, contexts['stuart'].user.id, contentObj, true, false, false, function() {
                                                                                                        
                                                                                                        // Remove permission for Back-end team manager and OAE Team
                                                                                                        permissions = {};
                                                                                                        permissions[groups['backend-team'].id] = false;
                                                                                                        permissions[groups['oae-team'].id] = false;
                                                                                                        RestAPI.Content.updateMembers(contexts['anthony'].restContext, contentObj.id, permissions, function(err) {
                                                                                                            assert.ok(!err);
                                                                                                            // Check that Branden no longer has access, but Simon and Nico still do
                                                                                                            checkPieceOfContent(contexts['nicolaas'].restContext, contexts['nicolaas'].user.id, contentObj, true, false, false, function() {
                                                                                                                checkPieceOfContent(contexts['simon'].restContext, contexts['simon'].user.id, contentObj, true, false, true, function() {
                                                                                                                    checkPieceOfContent(contexts['branden'].restContext, contexts['branden'].user.id, contentObj, privacy === 'private' ? false : true, false, false, callback);
                                                                                                                });
                                                                                                            });
                                                                                                        });
                                                                                                    });
                                                                                                });
                                                                                            });
                                                                                        });
                                                                                    });
                                                                                });
                                                                            });
                                                                        });
                                                                    });
                                                                });
                                                            });
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        };
        
        /**
         * Test that will verify group-related access for public content
         */
        it('verify public content group access', function(callback) {
            setUpUsers(function(contexts) {
                setUpGroups(contexts, function(groups) {
                    testGroupAccess(contexts, groups, 'public', callback);
                });
            });
        });
        
        /**
         * Test that will verify group-related access for logged in content
         */
        it('verify logged in content group access' , function(callback) {
            setUpUsers(function(contexts) {
                setUpGroups(contexts, function(groups) {
                    testGroupAccess(contexts, groups, 'loggedin', callback);
                });
            });
        });
        
        /**
         * Test that will verify group-related access for private content
         */
        it('verify private content group access', function(callback) {
            setUpUsers(function(contexts) {
                setUpGroups(contexts, function(groups) {
                    testGroupAccess(contexts, groups, 'private', callback);
                });
            });
        });
        
    });


    describe('Libraries', function() {
        
        // TODO: Tests around libraries
        // User library
        // Mix of private, public, logged in content
        // Mix of created himself, manager through setPermissions and shared
        // Check the library as user, other user, anonymous
        // Check paging
        // Group library
        // TODO: Get library that doesn't exist
        
        /**
         * Test that will verify if the returned items from the library are sorted by their last modified date.
         */
        it('verify library is sorted on last modified', function(callback) {
            setUpUsers(function(contexts) {
                var items = [];
                RestAPI.Content.createLink(contexts['nicolaas'].restContext, 'Test Content 1', 'Test content description 1', 'public', 'http://www.sakaiproject.org/', [], [], function(err, contentObj) {
                    assert.ok(!err);
                    items.push(contentObj.id);
                    RestAPI.Content.createLink(contexts['nicolaas'].restContext, 'Test Content 1', 'Test content description 1', 'public', 'http://www.sakaiproject.org/', [], [], function(err, contentObj) {
                        assert.ok(!err);
                        items.push(contentObj.id);
                        RestAPI.Content.createLink(contexts['nicolaas'].restContext, 'Test Content 1', 'Test content description 1', 'public', 'http://www.sakaiproject.org/', [], [], function(err, contentObj) {
                            assert.ok(!err);
                            items.push(contentObj.id);

                            // Get the 2 most recent items.
                            RestAPI.Content.getLibrary(contexts['nicolaas'].restContext, contexts['nicolaas'].user.id, null, 2, function(err, data) {
                                assert.ok(!err);
                                var library = data.results;
                                assert.equal(library.length, 2);
                                assert.equal(library[0].id, items[2]);
                                assert.equal(library[1].id, items[1]);

                                // Modify the oldest one.
                                RestAPI.Content.updateContent(contexts['nicolaas'].restContext, items[0], {'description': 'lalila'}, function(err) {
                                    assert.ok(!err);

                                    // When we retrieve the library the just modified one, should be on-top.
                                    RestAPI.Content.getLibrary(contexts['nicolaas'].restContext, contexts['nicolaas'].user.id, null, 2, function(err, data) {
                                        assert.ok(!err);
                                        var library = data.results;
                                        assert.equal(library.length, 2);
                                        assert.equal(library[0].id, items[0]);
                                        assert.equal(library[1].id, items[2]);

                                        callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    describe('Reprocess Previews', function() {

        /**
         * Test that verifies when previews are reprocessed through the REST endpoint, a task is triggered.
         */
        it('verify reprocessing previews triggers an mq task', function(callback) {
            // Unbind the current handler, if any
            MQ.unbind(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, function(err) {
                assert.ok(!err);

                /*!
                 * Simply call the test callback to continue tests. If this is not invoked, the test will timeout
                 * and fail.
                 *
                 * @see MQ#bind
                 */
                var _handleTask = function(data, mqCallback) {
                    mqCallback();
                    callback();
                };

                // Bind the handler to invoke the callback when the test passes
                MQ.bind(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, _handleTask, null, function(err) {
                    assert.ok(!err);

                    // Reprocess previews
                    RestAPI.Content.reprocessPreviews(globalAdminRestContext, function(err) {
                        assert.ok(!err);
                    });
                });
            });
        });

        /**
         * Test that verifies when previews are reprocessed through the REST endpoint, a task is triggered.
         */
        it('verify non-global admin users cannot reprocess previews', function(callback) {
            // Unbind the current handler, if any
            MQ.unbind(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, function(err) {
                assert.ok(!err);

                /*!
                 * Task handler that will fail the test if invoked.
                 *
                 * @see MQ#bind
                 */
                var _handleTaskFail = function(data, mqCallback) {
                    mqCallback();
                    assert.fail('Did not expect the task to be invoked.');
                };

                // Bind a handler to handle the task that invokes an assertion failure, as no task should be triggered from this test
                MQ.bind(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, _handleTaskFail, null, function(err) {
                    assert.ok(!err);

                    // Generate a normal user with which to try and reprocess previews
                    TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users) {
                        assert.ok(!err);

                        var userRestCtx = users[_.keys(users)[0]].restContext;

                        // Verify that an anonymous user-tenant user cannot reprocess previews
                        RestAPI.Content.reprocessPreviews(anonymousRestContext, function(err) {
                            assert.ok(err);

                            // Verify that an anonymous global-tenant user cannot reprocess previews
                            RestAPI.Content.reprocessPreviews(TestsUtil.createGlobalRestContext(), function(err) {
                                assert.ok(err);
                                assert.equal(err.code, 401);

                                // Verify that a regular user cannot generate a task
                                RestAPI.Content.reprocessPreviews(userRestCtx, function(err) {
                                    assert.ok(err);

                                    // Verify that a tenant admin cannot generate a task
                                    RestAPI.Content.reprocessPreviews(camAdminRestContext, function(err) {
                                        assert.ok(err);
                                        callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });
});
