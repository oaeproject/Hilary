/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var Helenus = require('helenus');

var OAE = require('oae-util/lib/oae');
var IO  = require('oae-util/lib/io');

var CONFIG = null;
var pool = null;

/**
 * Initializes the keyspace in config.keyspace with the CF's in all the modules their schema.js code.
 *
 * @param  {Object}         config          A Configuration object that can be used as the Cassandra client config.
 * @param  {Function(err)}  callback        Standard callback method
 * @param  {Object}         callback.err    Error object, containing the error message
 */
module.exports.init = function(config, callback) {
    callback = callback || function(){};
    CONFIG = config;

    var keyspace = CONFIG.keyspace;

    // first connect to the system keyspace to ensure the specified keyspace exists
    CONFIG.keyspace = 'system';
    pool = _createPool(CONFIG);
    pool.connect(function(err) {

        // immediately switch the CONFIG keyspace back to the desired keyspace
        CONFIG.keyspace = keyspace;

        if (err) {
            return callback(err);
        }

        keyspaceExists(keyspace, function(err, exists) {
            if (err) {
                // ensure the pool is closed
                close(function() {
                    return callback(err);
                });
            }

            if (!exists) {
                createKeyspace(keyspace, function(err) {
                    if (err) {
                        close(function() {
                            return callback(err);
                        });
                    }

                    // reconnect the pool now with the desired keyspace
                    _reloadPool(function(err) {
                        if (err) {
                            return callback(err);
                        }

                        module.exports.installModules(callback);
                    });
                });
            } else {
                // reconnect the pool now with the desired keyspace
                _reloadPool(function(err) {
                    module.exports.installModules(callback);
                });
            }
        });
    });
};

/**
 * Initialize the schemas for all of the OAE modules
 * @param  {Function(err)}  callback        Standard callback method
 * @param  {Object}         callback.err    Error object, containing the error message
 */
module.exports.installModules = function(callback) {
    callback = callback || function(){};
    OAE.getAvailableModules(function(modules) {
        console.log('Enabling ' + modules.join(', '));
        _installModules(modules.slice(0), callback);
    });
};

/**
 * Install all the modules given in the 'modules' parameter.
 *
 * @param {Array<String>}   modules         The modules to install.
 * @param {Function(err)}   callback        The function to invoke when the process completes.
 * @param {Object}          callback.err    An error that occurred, if any.
 */
var _installModules = function(modules, callback) {
    if (modules.length === 0) {
        return callback();
    }

    var module = modules.pop();
    var path = "node_modules/" + module + "/lib/schema.js";
    IO.pathExists(path, function(exists) {
        if (exists) {
            require(module + "/lib/schema").ensureSchema(function(err) {
                if (!err) {
                    // recursively install the next module
                    return _installModules(modules, callback);
                } else {
                    return callback(err);
                }
            });
        } else {
            return _installModules(modules, callback);
        }
    });
}

/**
 * Close all the connections in the connection pool.
 *
 * @param {Function(callback)}  callback A standard callback function, invoked when all the connections are closed.
 */
var close = module.exports.close = function(callback) {
    pool.on('close', callback);
    pool.close();
};

/**
 * Create a keyspace if it does not exist. If it does, then this will have no effect.
 * @param {String}                  name                The name of your keyspace
 * @param {Function(err, created)}  callback            Callback method
 * @param {Object}                  callback.err        An error that occurred, if any
 * @param {Boolean}                 callback.created    Specifies whether or not a keyspace was actually created.
 */
var createKeyspace = module.exports.createKeyspace = function(name, callback) {
    callback = callback || function(){};

    var options = {
        name: name, 
        strategy_class: 'SimpleStrategy',
        replication: 1
    };

    // only create it if it exists.
    keyspaceExists(name, function(err, exists) {
        if (!err) {
            if (!exists) {
                pool.createKeyspace(name, function(err) {
                    if (!err) {
                        return callback(null, true);
                    } else {
                        return callback(err);
                    }
                });
            } else {
                return callback(null, false);
            }
        } else {
            callback(err);
        }
    });
};

/**
 * Drops a keyspace
 * @param  {String}   name     The keyspace that should be dropped.
 * @param  {Function(err, dropped)} callback dropped is a boolean that states whether or not a keyspace was dropped.
 * @return {[type]}
 */
var dropKeyspace = module.exports.dropKeyspace = function(name, callback) {
    callback = callback || function(){};
    runQuery("DROP KEYSPACE " + name, false, function(err) {
        if (err) {
            callback(err);
        } else {
            callback(false, true);
        }
    });
};

/**
 * Checks if a keyspace exists or not.
 * @param {String}                  name            The name of the keyspace to check
 * @param {Function(err, exists)}   callback        Gets called with an error object (if any) and a boolean whether or not the keyspace exists.
 * @param {Object}                  callback.err    An error that occurred, if any
 * @param {Boolean}                 callback.exists Whether or not the keyspace existed
 */
var keyspaceExists = module.exports.keyspaceExists = function(name, callback) {
    _describeKeyspace(name, function(err, def) {
        callback(err, def !== null);
    });
};

/**
 * Checks if a CF exists or not.
 * @param  {String}   name     The name of the CF to check.
 * @param  {Function(err, exists)} callback Gets called with an error object (if any) and a boolean whether or not the CF exists.
 */
var columnFamilyExists = module.exports.columnFamilyExists = function(name, callback) {
    _describeKeyspace(CONFIG.keyspace, function(err, definition) {
        if (err) {
            callback(err);
        } else {
            var exists = false;
            for (var i = 0; i < definition.cf_defs.length;i++) {
                if (definition.cf_defs[i].name === name) {
                    exists = true;
                    break;
                }
            }
            callback(false, exists);
        }
    });
};


/**
 * Drops a Column family. A query will only be performed if the CF exists.
 * @param  {String}   name     The name of CF you wish to drop.
 * @param  {Function(err, dropped)} callback Gets called with an error object (if any) and a boolean whether or not the CF was dropped.
 */
var dropColumnFamily = module.exports.dropColumnFamily = function(name, callback) {
    // Only drop if it exists.
    columnFamilyExists(name, function(err, exists) {
        if (err) {
            callback(err);
        } else {
            if (exists) {
                runQuery('DROP COLUMNFAMILY ?', [name], function(err) {
                    if (err) {
                        callback(err);
                    } else {

                        // Helenus caches the CF schema internally.
                        // there is no way of refreshing that (synchronously)
                        // We close the pool and create a new connection.
                        // This makes using this method not suitable for production use!
                        _reloadPool(function(err) {
                            if (!err) {
                                callback(false, true);
                            } else {
                                callback(err);
                            }
                        });               
                    }
                });
            } else {
                callback(false, false);
            }
        }
    });
};

/**
 * Drop a batch of column families. This is a helper method that will be
 * used by various OAE modules when they are initialized. The column families
 * will only be created when they don't exist yet
 * @param  {Array}              families        Array containing the names of all column families that should be dropped
 * @param  {Function(err)}      callback        Standard callback function. Gets called when the process is complete
 * @param  {Object}             callback.err    An error that occurred, if any
 */
module.exports.dropColumnFamilies = function(families, callback) {
    callback = callback || function() {};
    _dropColumnFamilies(families.slice(0), callback);
};

/**
 * Synchronously drop a batch of column families. The array passed in here will be altered in order to recursively
 * drop the column families.
 *
 * @param {Array}           families        Array containing the names of all column families that should be dropped.
 * @param {Function(err)}   callback        Standard callback function. Gets executed when the process is complete
 * @param {Object}          callback.err    An error that occurred, if any
 */
var _dropColumnFamilies = function(families, callback) {
    if (families.length === 0) {
        return callback();
    }

    var family = families.pop();
    dropColumnFamily(family, function(err) {
        if (!err) {
            _dropColumnFamilies(families, callback);
        } else {
            return callback(err);
        }
    })
}

/**
 * Creates a CF if it doesn't exist yet. This is basically a helper method
 * that allows for quick creation of CF if nescecary.
 * Do NOT use this in a concurrent way as the pooled connection will be shut down!
 * 
 * @param  {String}                  name               CF name
 * @param  {String}                  cql                The CQL that can be used to create the CF if it doesn't exist.
 * @param  {Function(err, created)}  callback           Gets called when the CF has been created (or it failed.)
 * @param  {Object)}                 callback.err       Error object containing the error message
 * @param  {Boolean)}                callback.created   Whether or not the column family has actually been created
 */
var createColumnFamily = module.exports.createColumnFamily = function(name, cql, callback) {
    callback = callback || function() {};
    columnFamilyExists(name, function(err, exists) {
        if (err) {
            return callback(err);
        }

        if (!exists) {
            runQuery(cql, false, function(err) {
                if (err) {
                    return callback(err);
                }

                // Helenus caches the CF schema internally.
                // there is no way of refreshing that (synchronously)
                // We close the pool and create a new connection.
                // This makes using this method not suitable for production use!
                _reloadPool(function(err) {
                    if (!err) {
                        callback(false, true);
                    } else {
                        callback(err);
                    }
                });
            });
        } else {
            callback(false, false);
        }
    });
};

/**
 * Create a batch of column families. This is a helper method that will be
 * used by various OAE modules when they are initialized. The column families
 * will only be created when they don't exist yet
 * @param  {Object}             families        JSON object representing the column families that need to be created. The keys 
 *                                              are the names of the CFs, the values are the CQL statements required to create them
 * @param  {Function(err)}      callback        Standard callback functionGets called when the CFs have been created.
 * @param  {Object}             callback.err    An error that occured, if any.
 */
module.exports.createColumnFamilies = function(families, callback) {
    callback = callback || function() {};
    var keys = _.keys(families).slice(0);
    _createColumnFamilies(keys, families, callback);
};

/**
 * Internal version of createColumnFamilies that is equiped to create a set of column families synchronously.
 *
 * @param  {Array<String>}      keys            The key array (keys of the families JSON object) identifying the CF's to create
 * @param  {Object}             families        JSON object representing the column families that need to be created. The keys 
 *                                              are the names of the CFs, the values are the CQL statements required to create them
 * @param  {Function(err)}      callback        Standard callback functionGets called when the CFs have been created.
 * @param  {Object}             callback.err    An error that occurred, if any
 */
var _createColumnFamilies = function(keys, families, callback) {
    if (keys.length === 0 ) {
        return callback();
    }

    var cfKey = keys.pop();
    createColumnFamily(cfKey, families[cfKey], function(err) {
        if (!err) {
            return _createColumnFamilies(keys, families, callback);
        } else {
            return callback(err);
        }
    });
}

/**
 * Run a single Cassandra query.
 * @param  {String}   query      The CQL query
 * @param  {array}    parameters An array of values that can be interpreted by cassandra. If an element is detected as an array the query and parameters will be fixed.
 * @param  {Function} callback   Callback method.
 */
var runQuery = module.exports.runQuery = function(query, parameters, callback) {
    var fixed = fixQuery(query, parameters);
    executeQuery(fixed.query, fixed.parameters, callback);
};

/**
 * Run a batched Cassandra query.
 * @param  {Object[]}   queries  An array of simple hashes. Each hash should contain a query key and parameters key.
 * @param  {Function}   callback Callback method
 */
module.exports.runBatchQuery = function(queries, callback) {
    if (queries.length === 0) {
        return callback();
    }
    var query = 'BEGIN BATCH USING CONSISTENCY ONE \n';
    var parameters = [];
    for (var i = 0; i < queries.length;i++) {
        var fixed = fixQuery(queries[i].query, queries[i].parameters);
        query += fixed.query + "; \n";
        parameters = parameters.concat(fixed.parameters);
    }
    query += 'APPLY BATCH;';
    executeQuery(query, parameters, callback);
};

/**
 * Convert to given cassandra row to a column hash. Keyed by the column name, with value being the column value.
 *
 * @param   {Row}       row     The cassandra Row to convert to a hash
 * @return  {Object}            Return an Object, keyed by the column name, with values being the column value.
 */
module.exports.rowToHash = function(row) {
    var result = {};
    row.forEach(function(name, value) {
        result[name] = value;
    });
    return result;
}

/**
 * Adds the ability to pass in array parameters. If you pass in a parameter that is an array, the apropriate number of question marks will be added in the query.
 * @param  {String}    query      The query
 * @param  {Object[]}  parameters The parameters for this query.
 */
var fixQuery = function(query, parameters) {
    var fixedQuery = "";
    var fixedParameters = [];
    var q = query.indexOf('?');
    var from = 0;
    var i = 0;
    while (q >= 0) {
        fixedQuery += query.slice(from, q);

        // If we passed in an array add n-1 more question marks.
        if (Array.isArray(parameters[i])) {
            for (var c = 0; c < parameters[i].length - 1;c++) {
                fixedQuery += "?, ";
                fixedParameters.push(parameters[i][c]);
            }
            fixedParameters.push(parameters[i][parameters[i].length - 1]);
        }
        else {
            fixedParameters.push(parameters[i]);
        }
        fixedQuery += '?';


        // Next one.
        from = q+1;
        q = query.indexOf('?', from);
        i++;
    }

    // Append the request of the query.
    fixedQuery += query.slice(from);
    return {'query': fixedQuery, 'parameters': fixedParameters};
};

/**
 * Actually executes a query
 * @param  {String}    query       The query
 * @param  {Object[]}  parameters  The parameters that match this query
 * @param  {Function}  callback    Callback
 */
var executeQuery = function(query, parameters, callback) {
    callback = callback || function() {};
    // Check for null parameters that have been passed in. We have to intercept this
    // because otherwise the query will fail and an "All connections are unhealtyh" 
    // error will start coming back for each Cassandra query
    for (var p = 0; p < parameters.length; p++) {
        if (parameters[p] === null || parameters[p] === undefined) {
            return callback({
                'code': 400, 
                'msg': 'An incorrect query has been attempted. The query was "' + query + '" and the parameters that have been passed in were "[' + parameters + ']"'
            });
        }
    };

    pool.cql(query, parameters, callback);
};

/**
 * Describes the keyspace identified by 'keyspace'.
 * @param {String}                      keyspace            The keyspace to describe
 * @param {Function(err, definition)}   callback            Standard callback method
 * @param {Object}                      callback.err        An error that occurred, if any
 * @param {Object}                      callback.definition The keyspace definition. If null, then the keyspace does not exist.
 */
var _describeKeyspace = function(keyspace, callback) {
    pool.getConnection()._client.describe_keyspace(keyspace, function(err, definition) {
        if (err && err.name) {
            if (err.name === "NotFoundException") {
                callback(null, null);
            } else {
                callback(err);
            }
        } else {
            callback(null, definition);
        }
    });
}

/**
 * Close and re-open the cassandra connection pool.
 *
 * @param {Function(err)}   callback        Standard callback function
 * @param {Object}          callback.err    An error that occurred, if any
 */
var _reloadPool = function(callback) {
    close(function() {
        // Initialize the pooled connections immediately.
        pool = _createPool(CONFIG);
        pool.connect(callback);
    });
}

/**
 * Create a cassandra connection pool.
 */
var _createPool = function(config) {
    var _pool = new Helenus.ConnectionPool(config);
    _pool.on('error', function(err) {
        // TODO: introduce an actual async logger for this stuff.
        console.error(err.name, err.message);
        console.error(err.stack);
    });
    return _pool;
}
