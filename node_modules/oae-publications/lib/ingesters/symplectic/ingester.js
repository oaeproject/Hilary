/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var request = require('request');
var util = require('util');
var xml2js = require('xml2js');

var AuthenticationDAO = require('oae-authentication/lib/internal/dao');
var Cassandra = require('oae-util/lib/cassandra');
var ConfigAPI = require('oae-config');
var log = require('oae-logger').logger('oae-publications-symplectic');
var LoginId = require('oae-authentication/lib/model').LoginId;
var PrincipalsAPI = require('oae-principals');
var PrincipalsConstants = require('oae-principals/lib/constants').PrincipalsConstants;
var Telemetry = require('oae-telemetry').telemetry('symplectic');
var TenantsAPI = require('oae-tenants');

var PublicationsAPI = require('oae-publications/lib/api');
var PublicationsConfig = ConfigAPI.config('oae-publications');
var PublicationsConstants = require('oae-publications/lib/constants').PublicationsConstants;

var SymplecticAPI = require('./api');
var SymplecticDAO = require('./dao');

var intervals = null;

var updateTimoutId = null;

/**
 * Refreshes the symplectic ingester
 *
 * @param  {Config}     config          See `config.symplectic` in Hilary's main `config.js`
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    Standard error object, if any
 */
var refreshConfiguration = module.exports.refreshConfiguration = function(config, callback) {
    if (!config.symplectic || !config.symplectic.enabled) {
        return callback();
    }

    // Copy the synchronization intervals
    intervals = _.extend({}, config.symplectic.intervals);

    Cassandra.createColumnFamilies({
        'Symplectic': 'CREATE COLUMNFAMILY Symplectic (tenantAlias text PRIMARY KEY, lastFullRun timestamp, lastIncrementalRun timestamp);',
        'SymplecticUsers': 'CREATE COLUMNFAMILY SymplecticUsers (tenantAlias text PRIMARY KEY);'
    }, function(err) {
        if (err) {
            return callback(err);
        }

        // Disable our timer
        disable();

        // Start our timer
        enable();

        return callback();
    });
};

/**
 * Starts the timer for the next synchronization
 *
 * @api private
 */
var enable = function() {
    updateTimoutId = setTimeout(startIngesting, intervals.incremental * 60 * 60 * 1000);
};

/**
 * Stops the synchronization updates
 *
 * @api private
 */
var disable = function() {
    if (updateTimoutId) {
        clearTimeout(updateTimoutId);
        updateTimoutId = null;
        log().info('Disabled the Symplectic timer');
    }
};

/*!
 * Adds users that get created in OAE to the retry list for the next synchronization
 */
PrincipalsAPI.on(PrincipalsConstants.events.CREATED_USER, function(ctx, user) {
    var symplecticEnabled = PublicationsConfig.getValue(ctx.tenant().alias, 'symplectic', 'enabled');
    if (symplecticEnabled) {
        SymplecticDAO.addUserToRetryList(ctx.tenant().alias, {'oaeUserId': user.id});
    }
});


/////////////////////
// INGESTION LOGIC //
/////////////////////

/**
 * Starts the ingestion process
 *
 * @param  {Function}       callback    Standard callback function
 */
var startIngesting = module.exports.startIngesting = function(callback) {
    callback = callback || function() {};

    // Because this function can be called from outside this module, we stop the timer. Once the ingestion process has completed, a new timer will be started
    disable();

    // Get all the tenants for which we should retrieve data
    var tenants = getSymplecticEnabledTenants();

    var start = Date.now();
    log().info({'tenants': tenants}, 'Starting the ingestion process');
    ingestPublicationsForTenants(tenants, function() {
        log().info({'tenants': tenants, 'time': (Date.now() - start)}, 'Finished ingesting for all tenants');
        Telemetry.appendDuration('total.time', start);

        // Start our timer again
        enable();

        callback();
    });
};

/**
 * Get a set of tenants who have enabled the Symplectic integration
 *
 * @return {String[]}   An array of tenant aliases who have Symplectic enabled
 * @api private
 */
var getSymplecticEnabledTenants = function() {
    // Get all the running tenants
    var tenants = TenantsAPI.getTenants(true);

    // Filter the set of tenants to those who have symplectic enabled
    var symplecticEnabled = _.chain(tenants).keys().filter(function(tenantAlias) {
        return PublicationsConfig.getValue(tenantAlias, 'symplectic', 'enabled');
    }).value();

    return symplecticEnabled;
};

/**
 * Ingests publications for a given set of tenants
 *
 * @param  {String[]}   tenants         A set of tenant aliases
 * @param  {Function}   callback        Standard callback method
 * @api private
 */
var ingestPublicationsForTenants = function(tenants, callback) {
    if (_.isEmpty(tenants)) {
        return callback();
    }

    var tenantAlias = tenants.pop();
    log().info({'tenantAlias': tenantAlias}, 'Starting the ingestion process for a tenant');
    SymplecticDAO.getLastRunTimes(tenantAlias, function(err, lastFullRun, lastIncrementalRun) {
        if (err) {
            log().error({'err': err, 'tenantAlias': tenantAlias}, 'Could not retrieve the last time we did a synchronization');
            return;
        }

        // Try to figure out if we should do a full or incremental run
        var isFullRun = shouldPerformFullRun(lastFullRun, lastIncrementalRun);
        var lastRun = null;
        if (isFullRun) {
            log().info({'tenantAlias': tenantAlias}, 'Doing a full synchronization run');
        } else {
            lastRun = getLastRun(lastFullRun, lastIncrementalRun);
            log().info({'tenantAlias': tenantAlias}, 'Doing an incremental synchronization run');
        }

        // Start ingesting/link publications for this tenant
        var start = Date.now();
        ingestPublicationsForTenant(tenantAlias, isFullRun, lastRun, function(err) {
            if (err) {
                log().error({'err': err, 'tenantAlias': tenantAlias}, 'An error occurred whilst ingesting publications for a tenant');
                return;
            }

            // Remember the time that we started this synchronization
            if (isFullRun) {
                lastFullRun = start;
            } else {
                lastIncrementalRun = start;
            }
            SymplecticDAO.setLastRunTimes(tenantAlias, lastFullRun, lastIncrementalRun, function(err) {
                if (err) {
                    log().error({'err': err, 'tenantAlias': tenantAlias}, 'An error occurred whilst storing the lastRun timestamps');
                    return;
                }

                log().info({'tenantAlias': tenantAlias}, 'Retrieved all publications for tenant in %d ms', (Date.now() - start));
                Telemetry.appendDuration(tenantAlias + '.time', start);

                // Move on to the next one
                ingestPublicationsForTenants(tenants, callback);
            });
        });
    });
};

/**
 * Given the timestamps when we did our last full and/or incremental run we can determine if we need to do a full run.
 *
 * @param  {Number}     [lastFullRun]           The last time we did a full synchronization run
 * @param  {Number}     [lastIncrementalRun]    The last time we did an incremental synchronization run
 * @return {Boolean}                            `true` if we should do a full run, `false` otherwise
 * @api private
 */
var shouldPerformFullRun = function(lastFullRun, lastIncrementalRun) {
    // Do a full run if we've never done one before
    if (!lastFullRun) {
        return true;
    } else {
        // We've done a full run and maybe an incremental run before
        // We can determine if we need to do a new full run if the time between the last time we did a full run
        // and the current point in time is larger than the configured amount of incremtal intervals
        var lastRun = getLastRun(lastFullRun, lastIncrementalRun);

        // Get the difference between now and the last run in hours (as the config intervals are specified in hours)
        var diff = (Date.now() - lastRun) / (60 * 60 * 1000);

        // If we've configured that a full run should occurr after n incrementals update, we need to return true
        return ((diff / intervals.incremental) > intervals.full);
    }
};

/**
 * Given two timestamps, returns the one that happened last. If both are null, null will be returned
 *
 * @param  {Number}     [lastFullRun]           The last time we did a full synchronization run
 * @param  {Number}     [lastIncrementalRun]    The last time we did an incremental synchronization run
 * @return {Boolean}                            The timestamp that ocurred last
 * @api private
 */
var getLastRun = function(lastFullRun, lastIncrementalRun) {
    var lastRun = lastFullRun;
    if (lastIncrementalRun && lastIncrementalRun > lastFullRun) {
        lastRun = lastIncrementalRun;
    }
    return lastRun;
};

/**
 * Ingests publications for a given tenant
 *
 * @param  {String}     tenantAlias     The alias of the tenant for which to ingest the publications
 * @param  {Boolean}    isFullRun       Whether or not a full synchronization run should be performed
 * @param  {Number}     lastUpdate      The timestamp when we last ingested any publications for this tenant
 * @param  {Function}   callback        Standard callback method
 * @param  {Object}     callback.err    Standard error object, if any
 */
var ingestPublicationsForTenant = module.exports.ingestPublicationsForTenant = function(tenantAlias, isFullRun, lastUpdate, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'tenantAlias': tenantAlias}, 'An error occurred whilst ingesting publications for a tenant');
        }
    };

    if (isFullRun) {
        doFullRun(tenantAlias, callback);
    } else {
        doIncrementalRun(tenantAlias, lastUpdate, callback);
    }
};

/**
 * Performs a full synchronization for a tenant
 *
 * @param  {String}     tenantAlias     The alias of the tenant for which to ingest the publications
 * @param  {Function}   callback        Standard callback method
 * @param  {Object}     callback.err    Standard error object, if any
 * @api private
 */
var doFullRun = function(tenantAlias, callback) {
    // Since we're going to do a full dump, we can delete all the users that should be retried/are new
    SymplecticDAO.deleteAllUsersFromRetryList(tenantAlias, function(err) {
        if (err) {
            return callback(err);
        }

        // Ingest all of Symplectic's data
        ingestSymplectic(tenantAlias, null, function(err) {
            if (err) {
                return callback(err);
            }

            log().info({'tenantAlias': tenantAlias}, 'Full Symplectic synchronization completed for tenant');
            return callback();
        });
    });
};

/**
 * Performs an incremental synchronization for a tenant
 *
 * @param  {String}     tenantAlias     The alias of the tenant for which to ingest the publications
 * @param  {Number}     lastUpdate      The timestamp when we last ingested any publications for this tenant
 * @param  {Function}   callback        Standard callback method
 * @param  {Object}     callback.err    Standard error object, if any
 * @api private
 */
var doIncrementalRun = function(tenantAlias, lastUpdate, callback) {
    // Ingest our own new users first
    ingestNewOAEUsers(tenantAlias, function(err) {
        if (err) {
            return callback(err);
        }

        log().info({'tenantAlias': tenantAlias}, 'Incremental run - all new/previously failed OAE users ingested');

        // Ingest any updates from Symplectic
        ingestSymplectic(tenantAlias, lastUpdate, function(err) {
            if (err) {
                return callback(err);
            }

            log().info({'tenantAlias': tenantAlias}, 'Incremental run - all new data in Symplectic ingested');
            return callback();
        });
    });
};

/**
 * Ingests data from Symplectic. If a `lastUpdate` timestamp is provided, only the modifications since that timestamp will be ingested.
 *
 * @param  {String}     tenantAlias     The alias of the tenant for which to ingest the publications
 * @param  {Number}     lastUpdate      The timestamp when we last ingested any publications for this tenant
 * @param  {Function}   callback        Standard callback method
 * @param  {Object}     callback.err    Standard error object, if any
 */
var ingestSymplectic = function(tenantAlias, lastUpdate, callback, _usersPage) {
    _usersPage = _usersPage || 1;
    getUsers(tenantAlias, lastUpdate, _usersPage, function(err, result) {
        if (err) {
            return callback(err);
        }

        // Filter out those users which are not in our system
        var users = _.filter(result.users, function(user) {
            return (!_.isUndefined(user.oaeUserId));
        });

        // Get the publications for each user
        ingestPublicationsForUsers(tenantAlias, users, function(err) {
            if (err) {
                return callback(err);
            }

            log().trace({'tenant': tenantAlias, 'users': result.users}, 'Ingested publications for a set of users');
            if (_usersPage >= result.pagination.pages) {
                return callback();
            } else {
                _usersPage++;
                return ingestSymplectic(tenantAlias, lastUpdate, callback, _usersPage);
            }
        });
    });
};

/**
 * Ingests the new OAE users
 *
 * @param  {String}     tenantAlias     The alias of the tenant for which to ingest the publications
 * @param  {Function}   callback        Standard callback method
 * @param  {Object}     callback.err    Standard error object, if any
 */
var ingestNewOAEUsers = function(tenantAlias, callback, _start) {
    var start = _start || null;

    // Get a set of new users
    SymplecticDAO.getUsersFromRetryList(tenantAlias, start, 25, function(err, users, nextToken) {
        if (err) {
            return callback(err);
        }

        // Ingest the publications for each user
        ingestPublicationsForUsers(tenantAlias, users, function(err, ingestedUsers) {
            if (err) {
                return callback(err);
            }

            // Remove the users for which we succeeded
            var ingestedUserIds = _.map(ingestedUsers, function(ingestedUser) {
                return ingestedUser.oaeUserId;
            });
            SymplecticDAO.deleteUsersFromRetryList(tenantAlias, ingestedUserIds, function(err) {
                if (err) {
                    return callback(err);
                }

                log().trace({'tenant': tenantAlias, 'users': users}, 'Ingested publications for a set of users');
                if (!nextToken) {
                    return callback();
                } else {
                    return ingestNewOAEUsers(tenantAlias, callback, nextToken);
                }
            });
        });
    });
};

/**
 * Given a set of users, it will retrieve all their publications and ingest them
 *
 * @param  {string}     tenantAlias     The alias of the tenant for which to ingest the publications
 * @param  {Object[]}   users           The set of users for which to retrieve the publications
 * @param  {Function}   callback        Standard callback method
 * @param  {Object}     callback.err    Standard error object, if any
 * @api private
 */
var ingestPublicationsForUsers = function(tenantAlias, users, callback, _ingestedUsers) {
    _ingestedUsers = _ingestedUsers || [];
    if (_.isEmpty(users)) {
        return callback(null, _ingestedUsers);
    }

    var user = users.pop();
    ingestPublicationsForUser(tenantAlias, user, function(err) {
        if (err) {
            // Something went wrong for this user somehow, add him to the list to redo later
            log().error({'err': err, 'tenant': tenantAlias, 'user': user}, 'Could not ingest/link the publications for a user. It will be added to the retry list');
            SymplecticDAO.addUserToRetryList(tenantAlias, user, function(err) {
                if (err) {
                    // There isn't much we can do here other than log an error
                    log().error({'err': err, 'tenant': tenantAlias, 'user': user}, 'Could not add a user to the retry list');
                }

                return ingestPublicationsForUsers(tenantAlias, users, callback, _ingestedUsers);
            });
        } else {
            _ingestedUsers.push(user);
            return ingestPublicationsForUsers(tenantAlias, users, callback, _ingestedUsers);
        }
    });
};

/**
 * Given a user, it will retrieve all their publications and ingest them
 *
 * @param  {string}     tenantAlias             The alias of the tenant for which to ingest the publications
 * @param  {Object}     user                    The user for which to retrieve the publications
 * @param  {String}     user.oaeUserId          The user ID of this user within OAE
 * @param  {String}     user.externalUserId     The user ID that identifies this user in Symplectic
 * @param  {Function}   callback                Standard callback method
 * @param  {Object}     callback.err            Standard error object, if any
 * @api private
 */
var ingestPublicationsForUser = function(tenantAlias, user, callback) {
    // 1. Get the user's publications
    getPublicationsForUser(tenantAlias, user.externalUserId, function(err, publications) {
        if (err) {
            return callback(err);
        } else if (_.isEmpty(publications)) {
            return callback();
        }

        // 2. Ingest the publications
        var publicationsToIngest = publications.slice();
        ingestPublications(publicationsToIngest, function(err, ingestedPublications) {
            if (err) {
                return callback(err);
            }

            // 3. Store each ingested publication on the Symplectic publication
            _.each(ingestedPublications, function(ingestedPublication, i) {
                publications[i].ingestedPublication = ingestedPublication;
            });

            // 4. Link the publication for this user
            linkPublicationsToUser(publications, user.oaeUserId, callback);
        });
    });
};

/**
 * Ingests a set of publications
 *
 * @param  {IngesterPublication[]}      publications        The set of publications to ingest
 * @param  {Function}                   callback            Standard callback method
 * @param  {Object}                     callback.err        Standard error object, if any
 * @api private
 */
var ingestPublications = function(publications, callback, _ingestedPublications) {
    _ingestedPublications = _ingestedPublications || [];
    if (_.isEmpty(publications)) {
        return callback(null, _ingestedPublications);
    }

    var ingesterPublication = publications.pop();
    PublicationsAPI.IngesterAPI.ingestPublication(ingesterPublication.publication, ingesterPublication.sourceIds, function(err, ingestedPublication, result) {
        if (err) {
            return callback(err);
        }

        _ingestedPublications.push(ingestedPublication);
        return ingestPublications(publications, callback, _ingestedPublications);
    });
};

/**
 * Links a set of publications with a user. Each publication should have an `ingestedPublication` property that
 * points to an ingested publication with an ID.
 *
 * @param  {IngesterPublication[]}      publications        The set of publications to ingest
 * @param  {String}                     userId              The ID of the user to link the given publications with
 * @param  {Function}                   callback            Standard callback method
 * @param  {Object}                     callback.err        Standard error object, if any
 * @api private
 */
var linkPublicationsToUser = function(publications, userId, callback) {
    if (_.isEmpty(publications)) {
        return callback();
    }

    var publication = publications.pop();
    PublicationsAPI.IngesterAPI.linkPublicationToUser(publication.ingestedPublication.id, publication.authorName, userId, function(err, result) {
        if (err) {
            log().error({'err': err, 'userId': userId, 'publication': publication}, 'Error when linking a publication to a user');
            return callback(err);
        }

        if (result === PublicationsConstants.linkResult.NOTFOUND) {
            log().warn({'userId': userId, 'publication': publication}, 'Could not link a user to a publication');
        }
        if (result === PublicationsConstants.linkResult.LINKED) {
            log().trace({'userId': userId, 'publication': publication}, 'Linked a user to a publication');
        }

        return linkPublicationsToUser(publications, userId, callback);
    });
};


//////////////////////////////
//  SYMPLECTIC RETRIEVAL    //
//////////////////////////////


/**
 * Gets a set if Symplectic users. Each symplectic user will have an `oaeUserId` property added to it that contains
 * the OAE identifier of that user within OAE. If the user could not be found, the value will be `null`.
 *
 * @param  {String}     tenantAlias                         The alias of the tenant for which were retrieving symplectic users
 * @param  {Number}     lastUpdate                          The timestamp when we last retrieved user
 * @param  {Number}     page                                Which page should be retrieved
 * @param  {Function}   callback                            Standard callback function
 * @param  {Object}     callback.err                        Standard error object, if any
 * @param  {Object}     callback.result                     An object containing the users and pagination info
 * @param  {Object}     callback.result.pagination          Contains any pagination info
 * @param  {Number}     callback.result.pagination.total    The total number of users (if `lastUpdate` was null, this will be all the users in symplectic, if a value was provided, this will be the number that have been modified in Symplectic since that value)
 * @param  {Number}     callback.result.pagination.pages    The number of pages that are available
 * @param  {Object[]}   callback.result.users               An array of objects, each one representing a user in Symplectic. Each object will also include a `oaeUserId` providing the OAE user ID
 * @api private
 */
var getUsers = function(tenantAlias, lastUpdate, page, callback) {
    SymplecticAPI.getUsers(tenantAlias, lastUpdate, page, function(err, result) {
        if (err) {
            return callback(err);
        } else if (_.isEmpty(result.users)) {
            return callback(null, result);
        }

        // Get the OAE user ids
        var authenticationStrategy = PublicationsConfig.getValue(tenantAlias, 'symplectic', 'authenticationStrategy');
        var loginIds = [];
        _.each(result.users, function(symplecticUser) {
            loginIds.push(new LoginId(tenantAlias, authenticationStrategy, symplecticUser.externalUserId.toLowerCase()));
        });

        AuthenticationDAO.getUserIdsFromLoginIds(loginIds, function(err, userIds) {
            if (err) {
                return callback(err);
            }

            _.each(result.users, function(symplecticUser, index) {
                symplecticUser.oaeUserId = userIds[index];
            });

            return callback(null, result);
        });
    });
};

/**
 * Gets all the publications from Symplectic for a given username.
 * The provided username should be what Symplectic recognizes as the "external username".
 *
 * @param  {String}                     tenantAlias             The alias of the tenant for which were retrieving the publications
 * @param  {String}                     username                The username that identifies the user with Symplectic
 * @param  {Function}                   callback                Standard callback function
 * @param  {Object}                     callback.err            Standard error object, if any
 * @param  {IngesterPublication[]}      callback.publications   The retrieved publications
 * @api private
 */
var getPublicationsForUser = module.exports.getPublicationsForUser = function(tenantAlias, username, callback) {
    SymplecticAPI.getPublicationsForUser(tenantAlias, 'username-' + username, callback);
};
