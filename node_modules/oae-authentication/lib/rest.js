/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var BasicStrategy = require('passport-http').BasicStrategy;
var FacebookStrategy = require('passport-facebook').Strategy;
var TwitterStrategy = require('passport-twitter').Strategy;
var express = require('express');
var connect = require('connect');

var Context = require('oae-context').Context;
var principalAPI = require('oae-principals');
var User = require('oae-principals/lib/model').User;

var api = require('./api');
var CassandraStore = require('./connect-cassandra-store')(connect);

module.exports = function(tenant) {

    // Configure this tenant's express to use passport for the authentication stuff.
    tenant.server.configure(function() {
        // We'll be using cookies to hash the principal_id.
        // Signing of the cookie will be done by the session middleware.
        tenant.server.use(express.cookieParser());
        tenant.server.use(express.bodyParser());

        // This needs to come BEFORE passport and AFTER cookieParser.
        // The secret will be used to sign the cookie
        // We'll use Cassandra as a store for our sessions.
        tenant.server.use(express.session({ secret: 'this secret is so secret that its totally secret', store: new CassandraStore(), 'tenant': tenant.alias}));

        // Configure passport.
        tenant.server.use(tenant.passport.initialize());
        tenant.server.use(tenant.passport.session());

        // Bind the execution context after authentication
        tenant.server.use(function(req, res, next) {
            try {
                req.ctx = new Context(req.tenant, req.user);
                return next();
            } catch (err) {
                return next(err);
            }
        });

        // do some early-stack error handling.
        tenant.server.use(function(err, req, res, next) {
            console.log('[%s] [%s] Error processing middleware for request: %s', tenant.alias, req.path, err.stack);
        });

    });


    // This method will determine what goes into the cookie.
    // We only need the principal_id in there.
    tenant.passport.serializeUser(function(user, done) {
        done(null, user.id);
    });

    // A user has a cookie with a principal_id in it.
    // By returning the user (from the DB) to the done callback
    // it will be set on the request at request.user
    tenant.passport.deserializeUser(function(principal_id, done) {
        principalAPI.getUser(new Context(tenant, new User(tenant, principal_id)), principal_id, function (err, user) {
            done(err, user);
        });
    });


    // All of the strategies run at some URL under /api/auth/*
    // When a login fails, the user is redirected to / where he
    // will than be shown a login page with all the installed strategies.


    ////////////////////
    //  DIRECT LOGIN  //
    ////////////////////

    var localStrategy = new api.LocalStrategyWrapper(tenant);
    tenant.passport.use(localStrategy);

    tenant.server.post('/api/auth/login', tenant.passport.authenticate(localStrategy.name), function(req, res) {
        // This callback only gets called when we log in succesfully.
        return res.send(200, req.user);
    });


    tenant.server.post('/api/auth/logout', function(req, res) {
        req.logOut();
        res.send(200, {'loggedout': 'true'});
    });




    //////////////
    //  GOOGLE  //
    //////////////

    var googleCallbackWrapper = new api.GoogleCallbackWrapper(tenant);
    var googleStrategy = new api.GoogleStrategyWrapper(tenant, googleCallbackWrapper.callback);
    tenant.passport.use(googleStrategy);

    // Redirect the user to Google for authentication.  When complete, Google
    // will redirect the user back to the application at
    // /api/auth/google/return
    tenant.server.get('/api/auth/google', tenant.passport.authenticate(googleStrategy.name));

    // Google will redirect the user to this URL after authentication.  Finish
    // the process by verifying the assertion.  If valid, the user will be
    // logged in.  Otherwise, authentication has failed.
    tenant.server.get('/api/auth/google/return',
        tenant.passport.authenticate(googleStrategy.name, { 'successRedirect': '/',
                                                            'failureRedirect': '/'  })
    );



    ///////////////
    //  TWITTER  //
    ///////////////

    var twitterCallbackWrapper = new api.TwitterCallbackWrapper(tenant);
    var twitterStrategy = new TwitterStrategy({
            'consumerKey': '8eET3GSaCVE5GVd5kZsw',
            'consumerSecret': 'OIqx7h36fMWqc0Cb3tUI1jzp7bzCbE2F3zJ0Gladc',
            'callbackURL': 'http://' + tenant.baseUrl + '/api/auth/twitter/callback'
        }, twitterCallbackWrapper.callback
    );
    twitterStrategy.name = 'twitter-' + tenant.alias;

    tenant.passport.use(twitterStrategy);

    // Redirect the user to Twitter for authentication.  When complete, Twitter
    // will redirect the user back to the application at
    // /api/auth/twitter/callback
    tenant.server.get('/api/auth/twitter', tenant.passport.authenticate(twitterStrategy.name));

    // Twitter will redirect the user to this URL after approval.  Finish the
    // authentication process by attempting to obtain an access token.  If
    // access was granted, the user will be logged in.  Otherwise,
    // authentication has failed.
    tenant.server.get('/api/auth/twitter/callback',
        tenant.passport.authenticate(twitterStrategy.name, { 'successRedirect': '/',
                                                             'failureRedirect': '/' })
    );



    ////////////////
    //  FACEBOOK  //
    ////////////////

    var facebookCallbackWrapper = new api.FacebookCallbackWrapper(tenant);
    var facebookStrategy = new FacebookStrategy({
            'clientID': '194758077323671',
            'clientSecret': '663d14e7f9ad0baeb4e43390825a659f',
            'callbackURL': 'http://' + tenant.baseUrl + '/api/auth/facebook/callback'
        },
        facebookCallbackWrapper.callback
    );

    facebookStrategy.name = 'facebook-' + tenant.alias;

    tenant.passport.use(facebookStrategy);

    // Redirect the user to Facebook for authentication.  When complete,
    // Facebook will redirect the user back to the application at
    // /api/auth/facebook/callback
    tenant.server.get('/api/auth/facebook', tenant.passport.authenticate(facebookStrategy.name));

    // Facebook will redirect the user to this URL after approval.  Finish the
    // authentication process by attempting to obtain an access token.  If
    // access was granted, the user will be logged in.  Otherwise,
    // authentication has failed.
    tenant.server.get('/api/auth/facebook/callback',
        tenant.passport.authenticate(facebookStrategy.name, { 'successRedirect': '/',
                                                              'failureRedirect': '/' })
    );
};