/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var _ = require('underscore');

var AuthzAPI = require('oae-authz');
var MQ = require('oae-util/lib/mq');
var SearchAPI = require('oae-search');
var SearchConstants = require('oae-search/lib/constants').SearchConstants;

var PrincipalsAPI = require('oae-principals');
var PrincipalsConstants = require('oae-principals/lib/constants').PrincipalsConstants;
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var PrincipalsUtil = require('oae-principals/lib/util');

var User = require('oae-principals/lib/model').User;
var Group = require('oae-principals/lib/model').Group;

////////////////////
// INDEXING TASKS //
////////////////////

PrincipalsAPI.on(PrincipalsConstants.events.CREATED_USER, function(ctx, user) {
    MQ.submit(SearchConstants.mq.TASK_INDEX_DOCUMENT, {
        'resourceType': 'user',
        'resources': [{
            'id': user.id,
            'user': user,
            'opts': {
                'indexResource': true,
                'indexMemberships': false
            }
        }]
    });
});

PrincipalsAPI.on(PrincipalsConstants.events.UPDATED_USER, function(ctx, userId) {
    MQ.submit(SearchConstants.mq.TASK_INDEX_DOCUMENT, {
        'resourceType': 'user',
        'resources': [{
            'id': userId,
            'opts': {
                'indexResource': true,
                'indexMemberships': false
            }
        }]
    });
});

PrincipalsAPI.on(PrincipalsConstants.events.CREATED_GROUP, function(ctx, group, members) {
    MQ.submit(SearchConstants.mq.TASK_INDEX_DOCUMENT, {
        'resourceType': 'group',
        'resources': [{
            'id': group.id,
            'group': group,
            'members': members,
            'opts': {
                'indexResource': true,
                'indexMembers': true,
                'indexMemberships': false
            }
        }]
    });

    // fire additional tasks to update the memberships of the members
    _fireMembershipUpdateTasks(members);
});

PrincipalsAPI.on(PrincipalsConstants.events.UPDATED_GROUP, function(ctx, groupId) {
    MQ.submit(SearchConstants.mq.TASK_INDEX_DOCUMENT, {
        'resourceType': 'group',
        'resources': [{
            'id': groupId,
            'opts': {
                'indexResource': true,
                'indexMembers': false,
                'indexMemberships': false
            }
        }]
    });
});

PrincipalsAPI.on(PrincipalsConstants.events.UPDATED_GROUP_MEMBERS, function(ctx, groupId, memberUpdates) {
    MQ.submit(SearchConstants.mq.TASK_INDEX_DOCUMENT, {
        'resourceType': 'group',
        'resources': [{
            'id': groupId,
            'opts': {
                'indexResource': false,
                'indexMembers': true,
                'indexMemberships': false
            }
        }]
    });

    // fire additional tasks to update the memberships of the members
    _fireMembershipUpdateTasks(memberUpdates);
});

/**
 * Given a hash of membership changes, fire the index tasks required to update the appropriate membership documents.
 *
 * @param   {Object}    members     The hash of membership changes. Keyed by the principalId, the value is the role applied, or `false` if they were removed.
 * @api private
 */
var _fireMembershipUpdateTasks = function(members) {
    // aggregate resource updates for members, to update their memberships
    if (members) {
        var userUpdates = [];
        var groupUpdates = [];

        var memberIds = _.keys(members);
        for(var i = 0; i < memberIds.length; i++) { 
            var memberId = memberIds[i];
            if (PrincipalsUtil.isGroup(memberId)) {
                groupUpdates.push({
                    'id': memberId,
                    'opts': {
                        'indexResource': false,
                        'indexMembers': false,
                        'indexMemberships': true
                    }
                });
            } else {
                userUpdates.push({
                    'id': memberId,
                    'opts': {
                        'indexResource': false,
                        'indexMemberships': true
                    }
                });
            }
        }

        if (userUpdates.length > 0) {
            MQ.submit(SearchConstants.mq.TASK_INDEX_DOCUMENT, {
                'resourceType': 'user',
                'resources': userUpdates
            });
        }

        if (groupUpdates.length > 0) {
            MQ.submit(SearchConstants.mq.TASK_INDEX_DOCUMENT, {
                'resourceType': 'group',
                'resources': groupUpdates
            });
        }
    }
};

/////////////////////
// CUSTOM SEARCHES //
/////////////////////

SearchAPI.registerSearch('members', require('./searches/members'));
SearchAPI.registerSearch('memberships', require('./searches/memberships'));

////////////////////////
// DOCUMENT PRODUCERS //
////////////////////////

/**
 * Given an array of user resource updates, create the search documents that should be updated.
 * 
 * @param   {Object[]}      resources       The resources that represent the user resource updates
 * @param   {Function}      callback        Invoked when the process completes
 * @param   {Object}        callback.err    An error that occurred, if any
 * @param   {Object[]}      callback.docs   The documents to index
 * @api private
 */
var _produceUserSearchDocuments = function(resources, callback, docs) {
    docs = docs || [];
    if (resources.length === 0) {
        return callback(null, docs);
    }

    var resource = resources.shift();
    var userId = resource.id;
    var opts = resource.opts;
    var user = resource.user;

    if (user) {
        docs.push(_produceUserSearchDocument(user));
        return _produceUserSearchDocuments(resources, callback, docs);
    } else {
        PrincipalsDAO.getPrincipal(userId, function(err, user) {
            if (err && err.code !== 404) {
                return callback(err);
            } else if (user) {
                docs.push(_produceUserSearchDocument(user));
            }

            return _produceUserSearchDocuments(resources, callback, docs);
        });
    }
};

/**
 * Given a user, create a search document based on its information.
 *
 * @param   {User}  user    The user document
 * @return  {Object}        The search document that represents the user
 * @api private
 */
var _produceUserSearchDocument = function(user) {
    var general = _.compact([user.displayName, user.publicAlias]).join(' ');
    var searchDoc = {
        'id': user.id,
        'tenantAlias': user.tenant,
        'title': user.displayName,
        'visibility': user.visibility,
        'general': general,
        'sort': general,
        'extra': {
            'publicAlias': user.publicAlias
        }
    };
    if (user.mediumPictureUri) {
        searchDoc.thumbnailUrl = user.mediumPictureUri;
    }
    return searchDoc;
};

/**
 * Given an array of group resource updates, create the search documents that should be updated.
 * 
 * @param   {Object[]}      resources       The resources that represent the group resource updates
 * @param   {Function}      callback        Invoked when the process completes
 * @param   {Object}        callback.err    An error that occurred, if any
 * @param   {Object[]}      callback.docs   The documents to index
 * @api private
 */
var _produceGroupSearchDocuments = function(resources, callback, docs) {
    docs = docs || [];
    if (resources.length === 0) {
        return callback(null, docs);
    }

    var resource = resources.shift();
    var groupId = resource.id;
    var group = resource.group;

    if (group) {
        docs.push(_produceGroupSearchDocument(group));
        return _produceGroupSearchDocuments(resources, callback, docs);
    }

    PrincipalsDAO.getPrincipal(groupId, function(err, group) {
        if (err && err.code !== 404) {
            return callback(err);
        } else if (group) {
            docs.push(_produceGroupSearchDocument(group));
        }

        return _produceGroupSearchDocuments(resources, callback, docs);
    });
};

/**
 * Given a group, create a search document based on its information.
 *
 * @param   {Group}  group  The group document
 * @return  {Object}        The search document that represents the group
 * @api private
 */
var _produceGroupSearchDocument = function(group) {
    var general = _.compact([group.name, group.alias, group.description]).join(' ');

    var searchDoc = {
        'id': group.id,
        'tenantAlias': group.tenant,
        'title': group.name,
        'visibility': group.visibility,
        'joinable': group.joinable,
        'general': general,
        'sort': general,
        'extra': {
            'alias': group.alias
        }
    };

    if (group.mediumPictureUri) {
        searchDoc.thumbnailUrl = group.mediumPictureUri;
    }

    return searchDoc;
};

// bind the document producers
SearchAPI.registerDocumentProducer('user', _produceUserSearchDocuments);
SearchAPI.registerDocumentProducer('group', _produceGroupSearchDocuments);


///////////////////////////
// DOCUMENT TRANSFORMERS //
///////////////////////////

/**
 * Given an array of user search documents, transform them into search documents suitable to be displayed to the user in context.
 *
 * @param   {Context}   ctx             The current context
 * @param   {Object}    docs            A hash, keyed by the document id, while the value is the document to transform
 * @param   {Function}  callback        Invoked when the process completes
 * @param   {Object}    callback.err    An error that occurred, if any
 * @param   {Object}    callback.docs   The transformed docs, in the same form as the `docs` parameter.
 * @api private
 */
var _transformUserDocuments = function(ctx, docs, callback) {
    var transformedDocs = {};
    var docIds = _.keys(docs);
    for (var i = 0; i < docIds.length; i++) {
        var docId = docIds[i];
        var doc = docs[docId];
        var fields = doc.fields
        var user = new User(fields.tenantAlias, docId, fields.title, {
            'visibility': fields.visibility,
            'publicAlias': fields.extra.publicAlias
        });

        // If there is a thumbnail in the search document, we add it on the user object.
        // It will be removed from it if the current user should not be allowed to see it.
        if (fields.thumbnailUrl) {
            user.mediumPictureUri = fields.thumbnailUrl;
        }

        // hide information that is sensitive to the current session, then transform it back into a search document using the producer
        PrincipalsUtil.hideUserData(ctx, user);
        var result = _produceUserSearchDocument(user);

        // If the mediumPictureUri wasn't scrubbed from the user object that means the current user can see it.
        // Generate a downloadable url for it.
        if (user.mediumPictureUri) {
            result.thumbnailUrl = PrincipalsUtil.getSignedPictureUrl(ctx.tenant().alias, user.mediumPictureUri);
        }
        result.resourceType = 'user';

        delete result.general;
        delete result.sort;
        delete result.extra;

        transformedDocs[docId] = result;
    }

    return callback(null, transformedDocs);
};

// bind the transformer to the search API
SearchAPI.registerDocumentTransformer('user', _transformUserDocuments);


/**
 * Given an array of group search documents, transform them into search documents suitable to be displayed to the user in context.
 *
 * @param   {Context}   ctx             The current context
 * @param   {Object}    docs            A hash, keyed by the document id, while the value is the document to transform
 * @param   {Function}  callback        Invoked when the process completes
 * @param   {Object}    callback.err    An error that occurred, if any
 * @param   {Object}    callback.docs   The transformed docs, in the same form as the `docs` parameter.
 * @api private
 */
var _transformGroupDocuments = function(ctx, docs, callback) {
    var transformedDocs = {};
    var docIds = _.keys(docs);
    for (var i = 0; i < docIds.length; i++) {
        var docId = docIds[i];
        var doc = docs[docId];
        var result = _.extend({}, doc.fields, {'id': doc['_id']});

        // Augment it with a downloadable thumbnail url if it has a thumbnail uri.
        // The thumbnail should not be hidden, even if the group is private.
        if (doc.fields.thumbnailUrl) {
            result.thumbnailUrl = PrincipalsUtil.getSignedPictureUrl(ctx.tenant().alias, doc.fields.thumbnailUrl);
        }

        transformedDocs[docId] = result;
    };

    return callback(null, transformedDocs);
};


// bind the transformer to the search API
SearchAPI.registerDocumentTransformer('group', _transformGroupDocuments);
