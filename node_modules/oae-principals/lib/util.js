/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var sanitize = require('validator').sanitize;

var bcrypt = require('bcrypt');
var cassandra = require('oae-util/lib/cassandra');
var GroupAPI = require('oae-principals/lib/api.group');
var AuthzAPI = require('oae-authz');
var AuthzUtil = require('oae-authz/lib/util');
var User = require('./model').User;
var Group = require('./model').Group;
var VISIBILITY_OPTIONS = require('./model').VISIBILITY_OPTIONS;


/**
 * Gets a principal from the DB and converts the returned data to the correct model (user or group).
 * @param  {Context}                    ctx                 The current context
 * @param  {String}                     principalId         The ID of the principal that should be retrieved.
 * @param  {Function(err, principal)}   callback            A callback method.
 * @param  {Object}                     callback.err        An error object (if any)
 * @param  {Object}                     callback.principal  The asked for principal.
 */
module.exports.getPrincipal = function(ctx, principalId, callback) {
    cassandra.runQuery('SELECT * FROM Principals USING CONSISTENCY QUORUM WHERE principal_id = ?', [principalId], function (err, rows) {
        if (err) {
            return callback(err);
        }

        // check if no users were returned
        if (rows[0].count === 1) {
            return callback({'code': 404, 'msg': "Couldn't find principal: " + principalId});
        }

        getPrincipalFromRow(ctx, rows[0], callback);
    });
};

/**
 * Retrieves a principal from a row object. It performs all the visibility checks
 * and takes the current execution context into account. If a user is trying to
 * request a group he hasn't got access to, an error will be passed in the callback method
 *
 * @param  {Context}                    ctx                 The current context
 * @param  {Row}                        row                 A Helenus row object.
 * @param  {Function(err, principal)}   callback            A standard callback method.
 * @param  {Object}                     callback.err        An error object. Gets passed if the current user has no access
 *                                                          to a private group or something went wrong. Check the error code
 *                                                          to determine which case it is.
 * @param  {Object}                     callback.principal  A user or group model object with the private data redacted in case
 *                                                          the visibility has been set to private/loggedin.
 */
var getPrincipalFromRow = function(ctx, row, callback) {
    if (module.exports.isGroup(row.get('principal_id').value)) {
        var group = rowToGroup(row);

        // Admins can see all groups.
        var groupResource = AuthzUtil.getResourceFromUuid(group.id);
        if (ctx.user() && ctx.user().isAdmin(groupResource.tenantId)) {
            return callback(null, group);
        } else if (group.visibility !== VISIBILITY_OPTIONS.PUBLIC && ctx.user() === null) {
            // Anonymous users can't see private or logged in groups.
            return callback({'code': 401, 'msg': 'This group is not visible to you. Try logging in'});
        } else if (group.visibility === VISIBILITY_OPTIONS.PRIVATE) {
            // Check if the current user is a member of this group in case it's private.
            AuthzAPI.isMemberOf(ctx.user().id, group.id, function(err, isMemberOf) {
                if (err) {
                    return callback(err);
                } else if (!isMemberOf) {
                    return callback({'code': 401, 'msg': 'You don\'t have access to this group.'});
                }
                callback(null, group);
            });
        } else {
            // This group is public.
            callback(false, group);
        }
    } else {
        var user = rowToUser(row);

        // Admins can see all users.
        var principalResource = AuthzUtil.getResourceFromUuid(user.id);
        if (ctx.user() && ctx.user().isAdmin(principalResource.tenantId)) {
            return callback(null, user);
        }

        /// Hide the sensitive profile information if needed.
        if ((user.visibility === VISIBILITY_OPTIONS.LOGGEDIN && ctx.user() === null) ||
            (user.visibility === VISIBILITY_OPTIONS.PRIVATE && (ctx.user() === null || ctx.user().id !== user.id))) {
            user.hide();
        }

        callback(false, user);
    }
};

/**
 * Gets a set of principals (user or groups). This method will *not* throw an error if some of the principals
 * don't exist or the current user has no access to them, instead those IDs will be passed as a third parameter.
 *
 * @param  {Context}                    ctx                         The current context
 * @param  {Array<String>}              principalIds                The ID of the principal that should be retrieved.
 * @param  {Function(err, principals)}  callback                    Standard callback function
 * @param  {Object}                     callback.err                Error object containing the error message
 * @param  {Object}                     callback.principals         Object representing the retrieved principals. The keys will be the
 *                                                                  principal ids and the values will be the principal basic profiles
 * @param  {Object}                     callback.missingPrincipals  An array of principal ids that were not found.
 */
module.exports.getPrincipals = function(ctx, principalIds, callback) {
    if (principalIds.length === 0) {
        return callback(false, {});
    }
    cassandra.runQuery("SELECT * FROM Principals USING CONSISTENCY QUORUM WHERE principal_id IN (?)", [principalIds], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var retrievedPrincipals = 0;
        var principals = {};
        var retrievedPrincipal = function(err, principal) {
            retrievedPrincipals++;
            if (!err) {
                principals[principal.id] = principal;
            }

            if (retrievedPrincipals === principalIds.length) {
                return callback(null, principals, _.difference(principalIds, _.keys(principals)));
            }
        };

        rows.forEach(function(row) {
            // An empty row will come back for non-existing principals
            if (row.count > 1) {
                getPrincipalFromRow(ctx, row, retrievedPrincipal);
            } else {
                retrievedPrincipal(true);
            }
        });
    });
};

/**
 * Check if an identifier really is a group identifier.
 * @param  {String}  groupId    An identifier
 * @return {Boolean}            Whether or not the provided identifier is a group identifier.
 */
module.exports.isGroup = function(groupId) {
    var principal = AuthzUtil.getPrincipalFromUuid(groupId);
    return (principal.principalType === "g");
};

/**
 * Check if an identifier really is a user identifier.
 * @param  {String}  userId     An identifier
 * @return {Boolean}            Whether or not the provided identifier is a user identifier.
 */
module.exports.isUser = function(userId) {
    var principal = AuthzUtil.getPrincipalFromUuid(userId);
    return (principal.principalType === "u");
};

/**
 * Hashes a string with bcrypt.
 * @param {String}          password        The passwords that needs to be hashed.
 * @param {Function(hash)}  callback        Gets executed when the hash has been generated.
 * @param {String}          callback.hash   The hashed password.
 */
module.exports.hashPassword = function(password, callback) {
    bcrypt.genSalt(10, function(err, salt) {
        bcrypt.hash(password, salt, function(err, hash) {
            callback(hash);
        });
    });
};

/**
 * Removes wonky characters from a string so it can be used as user/group-name.
 * @param  {String} name    The name that needs to be cleaned.
 * @return {String}         A clean name.
 */
module.exports.cleanName = function(name) {
    return name.replace(/[:;<>#%{}|~`@%&!$,.="'\^\+\/\?\(\)\*\s\\\\\[\]]/gi, '-');
};

/**
 * Creates a Group from a Cassandra row.
 * @param  {Row}    row     Cassandra Row
 * @return {Group}          A group object.
 */
var rowToGroup = function (row) {
    var hash = cassandra.rowToHash(row);
    return new Group(hash.tenant, hash.principal_id, hash.alias, hash.name, hash.description, hash.visibility, hash.joinable);
};

/**
 * Creates a User from a Cassandra row.
 * @param  {Row}    row     Cassandra Row
 * @return {User}           A User object.
 */
var rowToUser = function(row) {
    var hash = cassandra.rowToHash(row);
    var isGlobalAdmin = (row.get('admin:global') && sanitize(row.get('admin:global').value).toBooleanStrict());
    var isTenantAdmin = (row.get('admin:tenant') && sanitize(row.get('admin:tenant').value).toBooleanStrict());
    var user = new User(hash.tenant, hash.principal_id, hash.user_username, hash.visibility, hash.locale, hash.timezone, hash.user_first_name, hash.user_last_name, hash.user_display_name, isGlobalAdmin, isTenantAdmin);
    // The row might contain extra data that we wish to pass back.
    user.extra = {};
    var keys = _.keys(hash);
    var blacklist = ['tenant', 'principal_id', 'user_username', 'user_password', 'visibility', 'locale', 'timezone', 'user_first_name', 'user_last_name', 'user_display_name', 'admin:global', 'admin:tenant'];
    for (var i = 0; i < keys.length; i++) {
        if (blacklist.indexOf(keys[i]) === -1) {
            user.extra[keys[i]] = hash[keys[i]];
        }
    }
    return user;
};
