/*
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');
var async = require('async');
var fs = require('fs');
var jszip = require('jszip');
var util = require('util');

var ContentsTestUtil = require('oae-content/lib/test/util');
var Etherpad = require('oae-content/lib/internal/etherpad');
var RestAPI = require('oae-rest');
var SearchTestsUtil = require('oae-search/lib/test/util');
var TestsUtil = require('oae-tests');

var PrincipalsAPI = require('oae-principals');
var PrincipalsTestUtil = require('oae-principals/lib/test/util');


describe('Export data', function() {

    // Rest contexts that can be used to make requests as different types of users
    var globalAdminRestContext = null;
    var camAdminRestContext = null;
    var camAnonymousRestContext = null;
    var gtAdminRestContext = null;
    var gtAnonymousRestContext = null;

    /**
     * @return {Stream} A stream to jpg image
     * @api private
     */
    var _getPictureStream = function() {
        return fs.createReadStream(util.format('%s/data/restroom.jpg', __dirname));
    };

    /**
     * Set some text in Etherpad.
     *
     * @param  {String}     userId          The ID of the user who wil be changing the text
     * @param  {Content}    contentObj      The content object for which we should update the etherpad text
     * @param  {String}     text            The text to place in the pad
     * @param  {Function}   callback        Standard callback function
     * @param  {Object}     callback.err    An error that occurred, if any
     */
    var _setEtherpadText = function(userId, contentObj, text, callback) {
        var etherpadClient = Etherpad.getClient(contentObj.id);
        var args = {
            'padID': contentObj.etherpadPadId,
            'text': text
        };
        etherpadClient.setText(args, callback);
    };

    /**
     * Get the text that is stored in Etherpad.
     *
     * @param  {Content}    contentObj          The content object for which we should retrieve the etherpad text.
     * @param  {Function}   callback            Standard callback function
     * @param  {Object}     callback.err        An error that occurred, if any
     * @param  {Object}     callback.data       Standard Etherpad API response object.
     * @param  {String}     callback.data.text  The actual string of text that is stored in the pad.
     */
    var _getEtherpadText = function(contentObj, callback) {
        var etherpadClient = Etherpad.getClient(contentObj.id);
        var args = {
            'padID': contentObj.etherpadPadId
        };
        etherpadClient.getText(args, callback);
    };

    /**
     * Changes the text in the etherpad pad and publishes the document.
     * The amount of edit/publish cycles depends on how many strings there are in the `texts` array.
     * Each string will be placed in the pad and result in a document publish.
     *
     * @param  {Object}     user        An object containing the `user` and `restContext` that will be performing the edit and publish
     * @param  {Content}    contentObj  The content object to publish
     * @param  {String[]}   texts       An array of texts that should be placed in the pad. The document will be published for each string in this array.
     * @param  {Function}   callback    Standard callback function
     */
    var _editAndPublish = function(user, contentObj, texts, callback) {
        var done = 0;

        var doEditAndPublish = function() {
            if (done === texts.length) {
                return callback();
            }

            // Do some edits in etherpad
            _setEtherpadText(user.user.id, contentObj, texts[done], function(err) {
                assert.ok(!err);

                ContentsTestUtil.publishCollabDoc(contentObj.id, user.user.id, function() {
                    done++;
                    doEditAndPublish();
                });
            });
        };
        doEditAndPublish();
    };

    /**
     * Function that will fill up the REST and admin contexts
     */
    before(function(callback) {
        // Fill up the request contexts
        camAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.cam.host);
        camAnonymousRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host);
        gtAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.gt.host);
        gtAnonymousRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.gt.host);   
        globalAdminRestContext = TestsUtil.createGlobalAdminRestContext();  
        return callback();
    });

    describe('Export personal data', function() {

        /**
         * Test that will get correct data on get personal data
         */
        it('verify get personal data', function(callback) {
            // Generate user in cam tenant
            TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, brecke) {
                assert.ok(!err);

                brecke.restContext.tenant = function () { return brecke.user.tenant; }
                brecke.restContext.user = function () { return brecke.user; }

                // Export personal data
                PrincipalsAPI.exportData(brecke.restContext, 'invalidUserId', 'personal-data', function(err, zip) {
                    assert.ok(err);
                    assert.equal(400, err.code);
                    PrincipalsAPI.exportData('invalidContext', brecke.user.id, 'personal-data', function(err, zip) {
                        assert.ok(err);
                        assert.equal(401, err.code);
                        PrincipalsAPI.exportData(brecke.restContext, brecke.user.id, 'invalidExportType', function(err, zip) {
                            assert.ok(err);
                            assert.equal(402, err.code);
                            PrincipalsAPI.exportData(brecke.restContext, brecke.user.id, 'personal-data', function(err, zip) {
                                assert.ok(!err);
                                
                                // Verify the personal data on the zip file
                                zip.file('personal_data.txt').async('string')
                                .then(function (content) {
                                    var lines = content.split('\n');
                                    var element = [];
                                    _.each(lines, function(line, i) {
                                        element[i] = line.split(': ').reverse().shift();
                                    });
                                    assert.equal(brecke.user.id, element[0]);
                                    assert.equal(brecke.user.displayName, element[1]);
                                    assert.equal(brecke.user.email, element[2]);
                                    return callback();
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that will get the correct content data (collabdoc, link, uploaded file)
         */
        it('verify get content data (collabdoc, link, uploaded file)', function(callback) {

            /**
             * Return a profile picture stream
             *
             * @return {Stream}     A stream containing an profile picture
             */
            var getPictureStream = function() {
                var file = __dirname + '/data/restroom.jpg';
                return fs.createReadStream(file);
            };

            // Generate user in cam tenant
            ContentsTestUtil.createCollabDoc(camAdminRestContext, 1, 1, function(collabdoc, users, brecke) {

                brecke.restContext.tenant = function () { return brecke.user.tenant; }
                brecke.restContext.user = function () { return brecke.user; }

                ContentsTestUtil.assertCreateLinkSucceeds(brecke.restContext, 'name', '', 'private', 'http://google.com', [], [], [], function(link) {
                    assert.ok(link);

                    // Give one of the users a profile picture
                    var cropArea = {'x': 0, 'y': 0, 'width': 50, 'height': 50};
                    RestAPI.User.uploadPicture(brecke.restContext, brecke.user.id, getPictureStream, cropArea, function(err) {
                        assert.ok(!err);
                    
                        // Export data using 'content' export type
                        PrincipalsAPI.exportData(brecke.restContext, brecke.user.id, 'content', function(err, zip) {
                            assert.ok(!err);

                            // Verify the personal data on the zip file
                            zip.file('link_data/'+ link.displayName +'.txt').async('string')
                            .then(function(zipLink) {
                                var lines = zipLink.split('\n');
                                var element = [];

                                _.each(lines, function(line, i) {
                                    element[i] = line.split(': ').reverse().shift();
                                });

                                assert.equal(link.displayName, element[0]);
                                assert.equal(link.profilePath, element[1]);
                                assert.equal('http://google.com', element[2]);
                                assert.equal(link.visibility, element[3]);
                                assert.equal(link.tenant.displayName, element[4]);

                                // Verify the personal data on the zip file
                                zip.file('collabdoc_data/'+ collabdoc.displayName +'.txt').async('string')
                                .then(function(zipCollabdoc) {
                                    var lines = zipCollabdoc.split('\n');
                                    var element = [];

                                    _.each(lines, function(line, i) {
                                        element[i] = line.split(': ').reverse().shift();
                                    });

                                    assert.equal(collabdoc.displayName, element[0]);
                                    assert.equal(collabdoc.profilePath, element[1]);
                                    assert.equal(collabdoc.visibility, element[2]);
                                    assert.equal(collabdoc.tenant.displayName, element[3]);
                                    assert.equal('undefined', element[4]);

                                    // Verify the personal data on the zip file
                                    zip.file('large.jpg').async('uint8array')
                                    .then(function(zipPicture) {
                                        assert.ok(zipPicture)
                                        return callback();
                                    });
                                });
                            });
                        });   
                    });   
                });
            });
        });

        /**
         * Test that will get the correct discussion data 
         */
        it('verify get discussion data', function(callback) {

            // Generate user in cam tenant
            TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, brecke) {
                assert.ok(!err);

                brecke.restContext.tenant = function () { return brecke.user.tenant; }
                brecke.restContext.user = function () { return brecke.user; }

                // Create one new discussion
                RestAPI.Discussions.createDiscussion(brecke.restContext, 'name', 'description', 'public', null, null, function(err, discussion) {
                    assert.ok(!err);
                    
                    // Export data using 'content' export type
                    PrincipalsAPI.exportData(brecke.restContext, brecke.user.id, 'content', function(err, zip) {
                        assert.ok(!err);

                        // Verify the personal data on the zip file
                        zip.file('discussion_data/'+ discussion.displayName +'.txt').async('string')
                        .then(function(zipDiscussion) {
                            var lines = zipDiscussion.split('\n');
                            var element = [];

                            _.each(lines, function(line, i) {
                                element[i] = line.split(': ').reverse().shift();
                            });

                            assert.equal(discussion.displayName, element[0]);
                            assert.equal(discussion.description, element[1]);
                            assert.equal(discussion.tenant.host + discussion.profilePath, element[2]);
                            assert.equal(discussion.visibility, element[3]);
                            assert.equal(discussion.tenant.displayName, element[4]);

                            return callback();
                        });   
                    });   
                });
            });
        });

        /**
         * Test that will get the correct meeting data 
         */
        it('verify get meeting data', function(callback) {

            // Generate user in cam tenant
            TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, brecke) {
                assert.ok(!err);

                brecke.restContext.tenant = function () { return brecke.user.tenant; }
                brecke.restContext.user = function () { return brecke.user; }

                // Create one new meeting
                RestAPI.MeetingsJitsi.createMeeting(brecke.restContext, 'name', 'description', false, false, 'public', [], [], function (err, meeting) {
                    assert.ok(!err);
                    
                    // Export data using 'content' export type
                    PrincipalsAPI.exportData(brecke.restContext, brecke.user.id, 'content', function(err, zip) {
                        assert.ok(!err);

                        // Verify the personal data on the zip file
                        zip.file('meeting_data/'+ meeting.displayName +'.txt').async('string')
                        .then(function(zipMeeting) {
                            var lines = zipMeeting.split('\n');
                            var element = [];

                            _.each(lines, function(line, i) {
                                element[i] = line.split(': ').reverse().shift();
                            });

                            assert.equal(meeting.displayName, element[0]);
                            assert.equal(meeting.description, element[1]);
                            assert.equal(meeting.tenant.host + meeting.profilePath, element[2]);
                            assert.equal(meeting.visibility, element[3]);
                            assert.equal(meeting.tenant.displayName, element[4]);

                            return callback();
                        });   
                    });   
                });
            });
        });

        /**
         * Test we get the correct meeting using the 'shared' export type
         */
        it('verify get the correct data using \'shared\' export type', function(callback) {

            // Generate user in cam tenant
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, brecke, simon) {
                assert.ok(!err);

                simon.restContext.tenant = function () { return simon.user.tenant; }
                simon.restContext.user = function () { return simon.user; }

                brecke.restContext.tenant = function () { return brecke.user.tenant; }
                brecke.restContext.user = function () { return brecke.user; }

                // Create one new meeting
                RestAPI.MeetingsJitsi.createMeeting(simon.restContext, 'name', 'description', false, false, 'public', [], [brecke.user.id], function (err, meeting) {
                    assert.ok(!err);
                    
                    // Export the data using 'shared' export type 
                    PrincipalsAPI.exportData(brecke.restContext, brecke.user.id, 'shared', function(err, zip) {
                        assert.ok(!err);

                        // Verify the personal data on the zip file
                        assert.ok(zip.files['meeting_data/' + meeting.displayName + '.txt']);

                        return callback();
                    });   
                });
            });
        });

        /**
         * Test that verify we get only personal data with the 'personal-data' export type 
         * and that we get only created data with the 'content' export type 
         */
        it('verify we only get the data asked and not more', function(callback) {

            // Generate user in cam tenant
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, brecke, simon) {
                assert.ok(!err);

                simon.restContext.tenant = function () { return simon.user.tenant; }
                simon.restContext.user = function () { return simon.user; }

                brecke.restContext.tenant = function () { return brecke.user.tenant; }
                brecke.restContext.user = function () { return brecke.user; }

                // Create one new meeting
                RestAPI.MeetingsJitsi.createMeeting(brecke.restContext, 'breckeMeeting', 'description', false, false, 'public', [], [], function (err, breckeMeeting) {
                    assert.ok(!err);

                    // Export personal data and verify we don't get the shared content
                    PrincipalsAPI.exportData(brecke.restContext, brecke.user.id, 'personal-data', function(err, zip) {
                        assert.ok(!err);
                        assert.ok(!zip.files['meeting_data/breckeMeeting.txt']);

                        // Create one new meeting
                        RestAPI.MeetingsJitsi.createMeeting(simon.restContext, 'SimonMeeting', 'description', false, false, 'public', [], [brecke.user.id], function (err, SimonMeeting) {
                            assert.ok(!err);

                            // Export personal data and verify we don't get the shared content
                            PrincipalsAPI.exportData(brecke.restContext, brecke.user.id, 'personal-data', function(err, zip) {
                                assert.ok(!err);
                                assert.ok(!zip.files['meeting_data/SimonMeeting.txt']);

                                // Export content data and verify we don't get the shared content
                                PrincipalsAPI.exportData(brecke.restContext, brecke.user.id, 'content', function(err, zip) {
                                    assert.ok(!err);
                                    assert.ok(!zip.files['meeting_data/SimonMeeting.txt']);

                                    return callback();
                                });   
                            });   
                        });   
                    });   
                });
            });
        });

        /**
         * Test that verify we get the text inside a collabdoc file
         */
        it('verify get the correct data inside a collabdoc', function(callback) {

            // Generate user in cam tenant
            ContentsTestUtil.createCollabDoc(camAdminRestContext, 1, 1, function(collabdoc, users, brecke) {

                brecke.restContext.tenant = function () { return brecke.user.tenant; }
                brecke.restContext.user = function () { return brecke.user; }

                var text = 'Most modern calendars mar the sweet simplicity of our lives by reminding us that each day that passes is the anniversary of some perfectly uninteresting event.';

                // Do some edits in etherpad
                _editAndPublish(brecke, collabdoc, [text], function() {

                    // Export the 'content' data  
                    PrincipalsAPI.exportData(brecke.restContext, brecke.user.id, 'content', function(err, zip) {
                        assert.ok(!err);

                        // Verify the personal data on the zip file
                        zip.file('collabdoc_data/'+ collabdoc.displayName +'.txt').async('string')
                        .then(function(zipCollabdoc) {
                            var lines = zipCollabdoc.split('\n');
                            var element = [];

                            _.each(lines, function(line, i) {
                                element[i] = line.split(': ').reverse().shift();
                            });

                            // Get etharpad text and compare it 
                            _getEtherpadText(collabdoc, function(err, data) {
                                assert.ok(element[4].includes(text))
                                return callback();
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verify we get all the comments related to a resource
         */
        it('verify get the correct comments related to a resource', function(callback) {

            // Generate user in cam tenant
            TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, simon) {
                assert.ok(!err);

                // Generate user and content in cam tenant
                ContentsTestUtil.createCollabDoc(camAdminRestContext, 1, 1, function(collabdoc, users, brecke) {

                    brecke.restContext.tenant = function () { return brecke.user.tenant; }
                    brecke.restContext.user = function () { return brecke.user; }

                    simon.restContext.tenant = function () { return simon.user.tenant; }
                    simon.restContext.user = function () { return simon.user; }
                    
                    // Create one comment
                    RestAPI.Content.createComment(brecke.restContext, collabdoc.id, 'This is a comment', null, function(err, comment) {
                        assert.ok(!err);

                        // Create one more
                        RestAPI.Content.createComment(simon.restContext, collabdoc.id, 'Another comment', null, function(err, anotherComment) {
                            assert.ok(!err);

                            // Export the 'content' data  
                            PrincipalsAPI.exportData(brecke.restContext, brecke.user.id, 'content', function(err, zip) {
                                assert.ok(!err);

                                // Verify the collabdoc data on the zip file
                                zip.file('collabdoc_data/'+ collabdoc.displayName +'.txt').async('string')
                                .then(function(zipCollabdoc) {
                                    var lines = zipCollabdoc.split('\n');
                                    var element = [];
                                    var title = [];

                                    _.each(lines, function(line, i) {
                                        title[i] = line.split(': ').shift();
                                        element[i] = line.split(': ').reverse().shift();
                                    });

                                    // Verify if the comment and the autor of the comment are the same 
                                    assert.equal(element[8], comment.body);
                                    assert.ok(title[8].includes(comment.createdBy.publicAlias));

                                    // Verify if the comment and the autor of the comment are the same 
                                    assert.equal(element[7], anotherComment.body);
                                    assert.ok(title[7].includes(anotherComment.createdBy.publicAlias));

                                    return callback();
                                });
                            });
                        });
                    });
                });
            });
        });

    });
});
