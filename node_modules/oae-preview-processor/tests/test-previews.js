/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');
var fs = require('fs');
var gm = require('gm');
var less = require('less');
var request = require('request');
var ShortId = require('shortid');
var Path = require('path');
var url = require('url');

var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;
var ActivityTestsUtil = require('oae-activity/lib/test/util');
var Cassandra = require('oae-util/lib/cassandra');
var ConfigTestUtil = require('oae-config/lib/test/util');
var Etherpad = require('oae-content/lib/internal/etherpad');
var MQ = require('oae-util/lib/mq');
var MQTestUtil = require('oae-util/lib/test/mq-util');
var RestAPI = require('oae-rest');
var RestContext = require('oae-rest/lib/model').RestContext;
var RestUtil = require('oae-rest/lib/util');
var SearchConstants = require('oae-search/lib/constants').SearchConstants;
var TaskQueue = require('oae-util/lib/taskqueue');
var Tempfile = require('oae-util/lib/tempfile');
var TestsUtil = require('oae-tests/lib/util');

var PreviewAPI = require('oae-preview-processor/lib/api');
var PreviewConstants = require('oae-preview-processor/lib/constants');
var PreviewContext = require('oae-preview-processor/lib/model').PreviewContext;
var PreviewDefaultLinks = require('oae-preview-processor/lib/processors/link/default');
var PreviewImages = require('oae-preview-processor/lib/processors/file/images');
var PreviewOffice = require('oae-preview-processor/lib/processors/file/office');
var PreviewPDF = require('oae-preview-processor/lib/processors/file/pdf');
var PreviewTestUtil = require('oae-preview-processor/lib/test/util');
var PreviewUtil = require('oae-preview-processor/lib/util');

describe('Preview processor', function() {

    // We fill this variable on tests startup with the configuration
    // as specified in the root config.js/beforeTests file.
    var defaultConfig = null;

    // Rest Contexts that can be used for global admin, tenant admin and anonymous users
    var signedAdminRestContext = null;
    var globalAdminRestContext = null;
    var camAdminRestContext = null;
    var anonymousRestContext = null;

    before(function(callback) {
        signedAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.localhost.host);
        globalAdminRestContext = TestsUtil.createGlobalAdminRestContext();
        camAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.cam.host);
        anonymousRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host);

        // Configure the SlideShare & Flickr processors.
        // We also switch the storage mechanism to 'test', so the PP can download the actual files.
        var update = {
            'oae-content/storage/backend': 'test',
            'oae-preview-processor/flickr/apikey': '0d7f5c9bd0277161d65dbea380a41ce2',
            'oae-preview-processor/flickr/apisecret': '14a0bda0b8857ae0',
            'oae-preview-processor/slideshare/sharedsecret': 'CI5h3oQk',
            'oae-preview-processor/slideshare/apikey': 'd1ELqsL0'
        };
        ConfigTestUtil.updateConfigAndWait(globalAdminRestContext, 'admin', update, function(err) {
            assert.ok(!err);

            // Log in the admin so his cookie jar is set up appropriately
            RestAPI.User.getMe(signedAdminRestContext, function(err, meObj) {
                assert.ok(!err);

                defaultConfig = PreviewAPI.getConfiguration();

                callback();
            });
        });
    });

    after(function(callback) {
        // Revert back to local storage.
        var update = {'oae-content/storage/backend': 'local'};
        ConfigTestUtil.updateConfigAndWait(globalAdminRestContext, 'admin', update, function(err) {
            assert.ok(!err);
            callback();
        });
    });

    /**
     * @return {Stream} Returns a stream that points to an image
     */
    var getImageStream = function() {
        return fs.createReadStream(__dirname + '/data/image.png');
    };

    /**
     * @return {Stream} Returns a stream that points to a GIF image
     */
    var getImageGIFStream = function() {
        return fs.createReadStream(__dirname + '/data/image.gif');
    };

    /**
     * @return {Stream} Returns a stream that points to an Office file.
     */
    var getOfficeStream = function() {
        return fs.createReadStream(__dirname + '/data/word.docx');
    };

    /**
     * @return {Stream} Returns a stream that points to a PDF file
     */
    var getPDFStream = function() {
        return fs.createReadStream(__dirname + '/data/pdf.pdf');
    };

    /**
     * @return {Stream} Returns a stream that points to a PDF file with multiple pages in it
     */
    var getMultiplePagesPDFStream = function() {
        return fs.createReadStream(__dirname + '/data/two-pages.pdf');
    };

    /**
     * @return {Stream} Returns a stream that points to a ZIP file
     */
    var getZipStream = function() {
        return fs.createReadStream(__dirname + '/data/foo.zip');
    };

    describe('Processor registration', function() {

        /**
         * Verifies that the processors are unregistered correctly and that the score as returned from the `test` function is respected
         */
        it('verify that processors can be unregistered', function(callback) {
            // Register some processors, each with a different test score
            PreviewAPI.registerProcessor('verify-pp-20', {'testval': 20, 'test': function(ctx, contentObj, callback) { callback(null, 20); }, 'generatePreviews': function() {}});
            PreviewAPI.registerProcessor('verify-pp-30', {'testval': 30, 'test': function(ctx, contentObj, callback) { callback(null, 30); }, 'generatePreviews': function() {}});
            PreviewAPI.registerProcessor('verify-pp--1', {'testval': -1, 'test': function(ctx, contentObj, callback) { callback(null, -1); }, 'generatePreviews': function() {}});

            // Create a piece of content as a regular user
            TestsUtil.generateTestUsers(signedAdminRestContext, 1, function(err, response) {
                assert.ok(!err);
                var restCtx = _.values(response)[0].restContext;
                RestAPI.Content.createFile(restCtx, 'Test Content 1', 'Test content description 1', 'private', getImageStream,  [], [], function(err, contentObj) {
                    assert.ok(!err);

                    // Generate a mock preview context
                    var mockCtx = {
                        'content': contentObj,
                        'revision': {}
                    };
                    // The processor who returns 30 should be on top
                    PreviewAPI.getProcessor(mockCtx, contentObj, function(err, processor) {
                        assert.ok(!err);
                        assert.equal(processor.testval, 30);

                        // Unregister our processors
                        PreviewAPI.unregisterProcessor('verify-pp-20');
                        PreviewAPI.unregisterProcessor('verify-pp-30');
                        PreviewAPI.unregisterProcessor('verify-pp--1');
                        callback();
                    });
                });
            });
        });

        /**
         * Verifies that all required parameters are validated when (un)registering a processor.
         */
        it('verify parameter validation', function() {
            assert.throws(function() { PreviewAPI.registerProcessor(null); }, Error, 'A preview processor needs an ID.');
            assert.throws(function() { PreviewAPI.registerProcessor('test', null); }, Error, 'A preview processor needs to specify an object that has a test and generatePreviews method.');
            assert.throws(function() { PreviewAPI.registerProcessor('test', {}); }, Error, 'A preview processor needs to specify an object that has a test and generatePreviews method.');
            assert.throws(function() { PreviewAPI.registerProcessor('test', {'generatePreviews': function() {}}); }, Error, 'A preview processor needs to specify an object that has a test and generatePreviews method.');
            assert.throws(function() { PreviewAPI.registerProcessor('test', {'test': function() {}}); }, Error, 'A preview processor needs to specify an object that has a test and generatePreviews method.');

            assert.throws(function() { PreviewAPI.unregisterProcessor(null); }, Error, 'An ID needs to be specified when unregistering a processor');
        });
    });

    describe('Preview processor initialization', function() {

        /**
         * Configuring the Office PP with the wrong path to the LibreOffice binary should result in a 500 error.
         */
        it('verify the Office PP can detect if it is configured correctly.', function(callback) {
            var config = {
                'binary': 'some-none-existinant-binary',
                'timeout': 120000
            };
            PreviewOffice.init(config, function(err) {
                assert.ok(err);
                assert.equal(err.code, 500);
                callback();
            });
        });

        /**
         * Configuring the PDF PP with the wrong path to the pdftk binary should result in a 500 error.
         */
        it('verify the PDF PP can detect if it is configured correctly.', function(callback) {
            var config = {
                'pdftk': {
                    'binary': 'some-none-existinant-binary',
                    'timeout': 120000
                },
                'pdf2htmlEX': {
                    'binary': 'some-none-existinant-binary',
                    'timeout': 120000
                }
            };
            PreviewPDF.init(config, function(err) {
                assert.ok(err);
                assert.equal(err.code, 500);
                callback();
            });
        });
    });

    describe('Preview generation', function() {

        /*!
         * Enable the Preview Processor if the config specifies we can run with it enabled
         */
        beforeEach(function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            // Purge anything that is hanging around in the preview processing queues
            PreviewTestUtil.purgePreviewsQueue(function() {
                PreviewTestUtil.purgeRegeneratePreviewsQueue(function() {

                    // Enable the Preview Processor
                    PreviewAPI.enable(function(err) {
                        if (err) {
                            return callback(new Error(err.msg));
                        }

                        return callback();
                    });
                });
            });
        });

        /*!
         * Disable the Preview Processor in case we enabled it earlier
         */
        afterEach(function(callback) {
            // Ignore this test if the PP is disabled
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            // Disable the API
            PreviewAPI.disable(function(err) {
                if (err) {
                    return callback(new Error(err.msg));
                }

                return callback();
            });
        });

        /*!
         * Creates a file and waits till it has been processed.
         *
         * @param  {String}      type       `link` or `file`.
         * @param  {String}      link       The stream that points to the file that should be uploaded.
         * @param  {Stream}      stream     The stream that points to the file that should be uploaded.
         * @param  {Function}    callback   Standard callback method that gets called when the file has previews associated to it.
         */
        var _createContentAndWait = function(type, link, stream, callback) {
            // When the queue is empty, we create a piece of content for which we can generate preview items.
            MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function() {
                TestsUtil.generateTestUsers(signedAdminRestContext, 1, function(err, response) {
                    assert.ok(!err);
                    var restCtx = _.values(response)[0].restContext;
                    var contentCreated = function(err, contentObj) {
                        assert.ok(!err);

                        // Wait till the PP items have been generated.
                        MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function() {
                            // Ensure the preview items are there.
                            RestAPI.Content.getContent(restCtx, contentObj.id, function(err, updatedContent) {
                                assert.ok(!err);
                                callback(restCtx, updatedContent);
                            });
                        });
                    };

                    if (type === 'file') {
                        RestAPI.Content.createFile(restCtx, 'Test Content 1', 'Test content description 1', 'public', stream,  [], [], contentCreated);
                    } else if (type === 'link') {
                        RestAPI.Content.createLink(restCtx, link, null, 'private', link,  [], [], contentCreated);
                    } else if (type === 'collabdoc') {
                        RestAPI.Content.createCollabDoc(restCtx, 'Test document', 'Test document', 'private', [], [], function(err, contentObj) {
                            assert.ok(!err);

                            // Put some text in the document, as we would otherwise
                            // ignore the document.
                            var etherpadClient = Etherpad.getClient(contentObj.id);
                            var args = {
                                'padID': contentObj.etherpadPadId,
                                'text': 'Sweet update'
                            };
                            etherpadClient.setText(args, function(err) {
                                assert.ok(!err);

                                // Create a new revision, as the document would otherwise be ignored by the PP.
                                RestAPI.Content.publishCollabDoc(restCtx, contentObj.id, function(err) {
                                    assert.ok(!err);
                                    contentCreated(err, contentObj);
                                });
                            });
                        });
                    }
                });
            });
        };

        /*!
         * Verifies that the `downloadUrl` can in fact be downloaded.
         *
         * @param  {RestContext}    restContext         The RestContext that we should use to download the file.
         * @param  {String}         downloadUrl         The signed URL that should be verified.
         * @param  {Function}       callback            Standard callback method.
         * @param  {String}         callback.body       The full response body
         * @param  {Response}       callback.response   The full response object
         * @throws {Error}                              An assertion error gets thrown if the file could not be downloaded
         */
        var _verifySignedUriDownload = function(restContext, downloadUrl, callback) {
            // Verify we can download it.
            var parsedUrl = url.parse(downloadUrl, true);
            RestUtil.RestRequest(restContext, '/api/download/signed', 'GET', parsedUrl.query, function(err, body, response) {
                assert.ok(!err);
                assert.equal(response.statusCode, 200);
                assert.ok(body);
                callback(body, response);
            });
        };

        /**
         * Verifies the image processor.
         */
        it('verify image processing works', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            _createContentAndWait('file', null, getImageStream, function(restCtx, content) {
                assert.equal(content.previews.status, 'done');
                // Ensure we have a thumbnail url.
                assert.ok(content.previews.thumbnailUrl);
                assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);
                _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, function() {
                    callback();
                });
            });
        });

        /**
         * Test that verifies that animated images get converted to single frame images for thumbnail images
         */
        it('verify animated images get converted to single frame images for thumbnail images', function(callback) {
            // Ignore this test if the PP is disabled
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            _createContentAndWait('file', null, getImageGIFStream, function(restCtx, content) {
                assert.equal(content.previews.status, 'done');
                // Ensure we have a thumbnail url
                assert.ok(content.previews.thumbnailUrl);
                assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);

                // Download the thumbnail to a temporary file
                var tmpFile = Tempfile.createTempFile();
                var stream = fs.createWriteStream(tmpFile.path);
                request({
                    'jar': restCtx.cookieJar,
                    'url': 'http://localhost:2001' + content.previews.thumbnailUrl,
                    'headers': {
                        'host': restCtx.hostHeader,
                        'referer': '/'
                    }
                }).pipe(stream);
                stream.on('finish', function() {

                    // Verify that this is a JPG image
                    gm(tmpFile.path).identify(function(err, info) {
                        assert.ok(!err);
                        assert.equal(info.format, 'JPEG');

                        // Clean up the temp file
                        tmpFile.remove(function(err) {
                            assert.ok(!err)  ;
                            callback();
                        });
                    });
                });
            });
        });

        /**
         * Verifies the office processor.
         */
        it('verify office processing works', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            // OpenOffice can sometimes be painfully slow to start up.
            this.timeout(30000);

            _createContentAndWait('file', null, getOfficeStream, function(restCtx, content) {
                assert.equal(content.previews.status, 'done');
                // Ensure we have a thumbnail url.
                assert.ok(content.previews.thumbnailUrl);
                assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);
                _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, function() {
                    // Ensure we have small and medium images.
                    assert.ok(content.previews.smallUrl);
                    _verifySignedUriDownload(restCtx, content.previews.smallUrl, function() {
                        assert.ok(content.previews.mediumUrl);
                        _verifySignedUriDownload(restCtx, content.previews.mediumUrl, function() {
                            callback();
                        });
                    });
                });
            });
        });

        /**
         * Verifies the PDF processor
         */
        it('verify pdf processing works', function(callback) {
            // Ignore this test if the PP is disabled
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            // OpenOffice can sometimes be painfully slow to start up
            this.timeout(30000);

            _createContentAndWait('file', null, getPDFStream, function(restCtx, content) {
                assert.equal(content.previews.status, 'done');
                assert.equal(content.previews.pageCount, 1);
                // Ensure we have a thumbnail url
                assert.ok(content.previews.thumbnailUrl);
                assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);
                _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, function() {
                    // Ensure we have small and medium images
                    assert.ok(content.previews.smallUrl);
                    _verifySignedUriDownload(restCtx, content.previews.smallUrl, function() {
                        assert.ok(content.previews.mediumUrl);
                        _verifySignedUriDownload(restCtx, content.previews.mediumUrl, function() {

                            // Verify we have all our files
                            RestAPI.Content.getPreviewItems(restCtx, content.id, content.latestRevisionId, function(err, previews) {
                                assert.ok(!err);

                                // The PDF has 1 page, there should only be 1 corresponding HTML file
                                assert.ok(_.find(previews.files, function(file) { return file.filename === 'page.1.html'; }));
                                assert.ok(!_.find(previews.files, function(file) { return file.filename === 'page.2.html'; }));

                                // There should be a combined CSS file
                                assert.ok(_.find(previews.files, function(file) { return file.filename === 'combined.css'; }));

                                // There should not be any original individual CSS files
                                assert.ok(!_.find(previews.files, function(file) { return file.filename === 'base.css'; }));
                                assert.ok(!_.find(previews.files, function(file) { return file.filename === 'base.min.css'; }));
                                assert.ok(!_.find(previews.files, function(file) { return file.filename === 'fancy.css'; }));
                                assert.ok(!_.find(previews.files, function(file) { return file.filename === 'fancy.min.css'; }));
                                assert.ok(!_.find(previews.files, function(file) { return file.filename === 'lines.css'; }));
                                assert.ok(!_.find(previews.files, function(file) { return file.filename === 'lines.min.css'; }));
                                callback();
                            });
                        });
                    });
                });
            });
        });

        /**
         * Verifies multiple pages with the PDF processor
         */
        it('verify multiple pages pdf processing works', function(callback) {
            // Ignore this test if the PP is disabled
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            // OpenOffice can sometimes be painfully slow to start up
            this.timeout(30000);

            _createContentAndWait('file', null, getMultiplePagesPDFStream, function(restCtx, content) {
                assert.equal(content.previews.status, 'done');
                assert.equal(content.previews.pageCount, 2);
                // Ensure we have a thumbnail url
                assert.ok(content.previews.thumbnailUrl);
                assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);

                _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, function() {

                    // Ensure we have small and medium images
                    assert.ok(content.previews.smallUrl);
                    _verifySignedUriDownload(restCtx, content.previews.smallUrl, function() {
                        assert.ok(content.previews.mediumUrl);
                        _verifySignedUriDownload(restCtx, content.previews.mediumUrl, function() {

                            // Verify we have all our files
                            RestAPI.Content.getPreviewItems(restCtx, content.id, content.latestRevisionId, function(err, previews) {
                                assert.ok(!err);

                                // The PDF has 2 pages, there should be 2 corresponding HTML files
                                assert.ok(_.find(previews.files, function(file) { return file.filename === 'page.1.html'; }));
                                assert.ok(_.find(previews.files, function(file) { return file.filename === 'page.2.html'; }));

                                // There should be a combined CSS file
                                assert.ok(_.find(previews.files, function(file) { return file.filename === 'combined.css'; }));

                                // There should not be any original individual CSS files
                                assert.ok(!_.find(previews.files, function(file) { return file.filename === 'base.css'; }));
                                assert.ok(!_.find(previews.files, function(file) { return file.filename === 'base.min.css'; }));
                                assert.ok(!_.find(previews.files, function(file) { return file.filename === 'fancy.css'; }));
                                assert.ok(!_.find(previews.files, function(file) { return file.filename === 'fancy.min.css'; }));
                                assert.ok(!_.find(previews.files, function(file) { return file.filename === 'lines.css'; }));
                                assert.ok(!_.find(previews.files, function(file) { return file.filename === 'lines.min.css'; }));
                                callback();
                            });

                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that when a PDF is uploaded as the new version of a piece of content, the old previews metadata is overwritten
         */
        it('verify uploading new pdf revision', function(callback) {
            // Ignore this test if the PP is disabled
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            // OpenOffice can sometimes be painfully slow to start up
            this.timeout(50000);

            _createContentAndWait('file', null, getMultiplePagesPDFStream, function(restCtx, content) {
                assert.equal(content.previews.status, 'done');
                assert.equal(content.previews.pageCount, 2);

                // Verify we have all our files
                RestAPI.Content.getPreviewItems(restCtx, content.id, content.latestRevisionId, function(err, previews) {
                    assert.ok(!err);

                    // The PDF has 2 pages, there should be 2 corresponding HTML files
                    assert.ok(_.find(previews.files, function(file) { return file.filename === 'page.1.html'; }));
                    assert.ok(_.find(previews.files, function(file) { return file.filename === 'page.2.html'; }));

                    // Now upload a new revision which only has one page in it
                    RestAPI.Content.updateFileBody(restCtx, content.id, getPDFStream, function(err) {
                        assert.ok(!err);

                        // Wait till the file has been processed
                        MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function() {

                            // Verify the previous metadata is gone
                            RestAPI.Content.getContent(restCtx, content.id, function(err, updatedContentObj) {
                                assert.ok(!err);
                                assert.equal(updatedContentObj.previews.status, 'done');
                                assert.equal(updatedContentObj.previews.pageCount, 1);

                                // Verify the previous preview files are gone
                                RestAPI.Content.getPreviewItems(restCtx, content.id, updatedContentObj.latestRevisionId, function(err, previews) {
                                    assert.ok(!err);

                                    // The PDF has 1 pages, there should only be one corresponding HTML file
                                    assert.ok(_.find(previews.files, function(file) { return file.filename === 'page.1.html'; }));
                                    assert.ok(!_.find(previews.files, function(file) { return file.filename === 'page.2.html'; }));
                                    callback();
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that the CSS rules from PDF previews are scoped
         */
        it('verify CSS rules for PDF previews are scoped', function(callback) {
            // Ignore this test if the PP is disabled
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            // OpenOffice can sometimes be painfully slow to start up
            this.timeout(50000);

            _createContentAndWait('file', null, getMultiplePagesPDFStream, function(restCtx, content) {
                assert.equal(content.previews.status, 'done');
                assert.equal(content.previews.pageCount, 2);
                RestAPI.Content.getRevision(restCtx, content.id, content.latestRevisionId, function(err, revision) {
                    assert.ok(!err);

                    // Verify that the CSS scope class is exposed
                    var cssScopeClass = util.format('%s-%s-pdf2html', content.id.replace(/:/g, '-'),  revision.previewsId.replace(/:/g, '-'));
                    assert.equal(content.previews.cssScopeClass, cssScopeClass);

                    // Download the combined CSS file
                    var params = {
                        'signature': content.signature.signature,
                        'expires': content.signature.expires,
                        'lastmodified': content.signature.lastModified
                    };
                    var url = util.format('/api/content/%s/revisions/%s/previews/combined.css', content.id, content.latestRevisionId);
                    RestUtil.RestRequest(restCtx, url, 'GET', params, function(err, body, response) {
                        assert.ok(!err);
                        assert.equal(response.statusCode, 200);
                        assert.ok(body);

                        // Parse the CSS file with less to assert that all CSS rules are properly scoped
                        var parser = less.Parser({});
                        parser.parse(body, function (err, tree) {
                            assert.ok(!err);

                            _.each(tree.rules, function(rule, index) {
                                if (rule.selectors && rule.selectors[0].elements) {
                                    // Each CSS rule should be of the form `.contentId-previewsId-pdf2html <pdf2html rule>`
                                    assert.strictEqual(rule.selectors[0].elements[0].value, '.' + cssScopeClass, 'Inappropriate scoping for rule ' + index);
                                }
                            });
                            return callback();
                        });
                    });
                });
            });
        });

        /**
         * Verifies the default link processor.
         */
        it('verify default link processing works', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            _createContentAndWait('link', 'http://www.google.com', null, function(restCtx, content) {
                assert.equal(content.previews.status, 'done');
                assert.equal(content.previews.embeddable, false);
                // Ensure we have a thumbnail url.
                assert.ok(content.previews.thumbnailUrl);
                assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);
                _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, function() {
                    // Ensure we have small and medium images.
                    assert.ok(content.previews.smallUrl);
                    _verifySignedUriDownload(restCtx, content.previews.smallUrl, function() {
                        assert.ok(content.previews.mediumUrl);
                        _verifySignedUriDownload(restCtx, content.previews.mediumUrl, function() {
                            callback();
                        });
                    });
                });
            });
        });

        /**
         * Verifies the default link processor checks if the site is embeddable
         */
        it('verify default link processing checks if a url is embeddable in an iframe', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            TestsUtil.createTestServer(function(app, server, port) {

                // Determines whether or not we disallow embedding
                var xFrameOptions = null;

                // Deny iframe embedding for all URLs
                app.use(function(req, res, next) {
                    if (xFrameOptions) {
                        res.set('x-frame-options', xFrameOptions);
                    }
                    return res.send('This is the best page on the webz');
                });

                // Our mocked server will disallow embedding any page in an iframe
                xFrameOptions = 'DENY';
                _createContentAndWait('link', 'http://localhost:' + port, null, function(restCtx, content) {
                    assert.equal(content.previews.status, 'done');
                    assert.equal(content.previews.embeddable, false);

                    // Ensure we have a thumbnail url
                    assert.ok(content.previews.thumbnailUrl);
                    assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);
                    _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, function() {

                        // Remove the embedding restriction from our mocked server, the site should now be embeddable
                        xFrameOptions = null;
                        _createContentAndWait('link', 'http://localhost:' + port, null, function(restCtx, content) {
                            assert.equal(content.previews.status, 'done');
                            assert.equal(content.previews.embeddable, true);

                            // Ensure we have a thumbnail url
                            assert.ok(content.previews.thumbnailUrl);
                            assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);
                            _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, function() {
                                return callback();
                            });
                        });
                    });
                });
            });
        });

        /**
         * Verifies the default link processor checks if the site is available over HTTPS
         */
        it('verify default link processing checks if a url is available over HTTPS', function(callback) {
            // Ignore this test if the PP is disabled
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            _createContentAndWait('link', 'http://www.google.com', null, function(restCtx, content) {
                assert.equal(content.previews.status, 'done');
                assert.equal(content.previews.httpsAccessible, true);

                // Ensure we have a thumbnail url
                assert.ok(content.previews.thumbnailUrl);
                assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);
                _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, function() {

                    // Assert that URLs that are not available on HTTPs get marked as such
                    _createContentAndWait('link', 'http://localhost:2000', null, function(restCtx, content) {
                        assert.equal(content.previews.status, 'done');
                        assert.equal(content.previews.httpsAccessible, false);

                        // Ensure we have a thumbnail url
                        assert.ok(content.previews.thumbnailUrl);
                        assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);
                        _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, function() {
                            return callback();
                        });
                    });
                });
            });
        });

        /**
         * Verifies the default link processor handles HEAD failures
         */
        it('verify default link processing can handle HEAD failures', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            // Create a new express application to a PP
            TestsUtil.createTestServer(function(app, server, port) {

                // Destroy the connection to create an erroneous HEAD request
                app.head('/', function(req, res) {
                    res.connection.destroy();
                });

                app.get('/', function(req, res) {
                    res.send(200);
                });

                // Although the HEAD request fails, the preview processing should complete correctly and the link should be marked as non-embeddable
                _createContentAndWait('link', 'http://localhost:' + port, null, function(restCtx, content) {
                    assert.equal(content.previews.status, 'done');
                    assert.equal(content.previews.embeddable, false);

                    // Ensure we have a thumbnail url
                    assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);

                    _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, function() {
                        // Ensure we have small and medium images
                        assert.ok(content.previews.smallUrl);
                        _verifySignedUriDownload(restCtx, content.previews.smallUrl, function() {
                            assert.ok(content.previews.mediumUrl);
                            _verifySignedUriDownload(restCtx, content.previews.mediumUrl, function() {
                                return server.close(callback);
                            });
                        });
                    });
                });
            });
        });

        /**
         * Verifies the default link processor only handles http urls.
         */
        it('verify default link processing only handles http(s)', function(callback) {
            var content = {'resourceSubType': 'link', 'link': 'file://localhost/etc/passwd'};
            PreviewDefaultLinks.test(null, content, function(err, score) {
                assert.ok(!err);
                assert.strictEqual(score, -1);

                content.link = 'ftp://localhost:21/etc/passwd';
                PreviewDefaultLinks.test(null, content, function(err, score) {
                    assert.ok(!err);
                    assert.strictEqual(score, -1);
                    callback();
                });
            });
        });

        /**
         * Verifies the youtube processor and assures that metadata is retrieved/set.
         */
        it('verify youtube link processing works', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            _createContentAndWait('link', 'http://www.youtube.com/watch?v=lgTQ5I_H4Xk', null, function(restCtx, content) {
                assert.equal(content.previews.status, 'done');
                // Verify the displayName and description are set.
                assert.equal(content.displayName, 'How to prounounce "Apereo"');
                assert.equal(content.description, 'Here is Ian Dolphin, the Executive Director of the Apereo Foundation, with the official pronunciation of the word "Apereo".');
                // Ensure we have a thumbnail url.
                assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);
                _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, function() {
                    // Ensure we have small and medium images.
                    assert.ok(content.previews.smallUrl);
                    _verifySignedUriDownload(restCtx, content.previews.smallUrl, function() {
                        assert.ok(content.previews.mediumUrl);
                        _verifySignedUriDownload(restCtx, content.previews.mediumUrl, function() {
                            callback();
                        });
                    });
                });
            });
        });

        /**
         * Verifies the slideshare processor and assures that metadata is retrieved/set.
         */
        it('verify slideshare link processing works', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            _createContentAndWait('link', 'http://www.slideshare.net/nicolaasmatthijs/apereo-oae-state-of-the-project?search_from=3', null, function(restCtx, content) {
                assert.equal(content.previews.status, 'done');
                // Verify the displayName and description are set.
                assert.equal(content.displayName, 'Apereo OAE - State of the project');
                assert.equal(content.description, 'The Apereo Open Academic Environment is a platform that focusses on group collaboration between researchers, students and lecturers, and strongly embraces openness, creation, re-use, re-mixing and discovery of content, people and groups. This session provides a summary of the revised goals and their motivation, as well as a full demo of the new implemented functionalities.');

                // Ensure we have a thumbnail url.
                assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);
                _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, function() {
                    // Ensure we have small and medium images.
                    assert.ok(content.previews.smallUrl);
                    _verifySignedUriDownload(restCtx, content.previews.smallUrl, function() {
                        assert.ok(content.previews.mediumUrl);
                        _verifySignedUriDownload(restCtx, content.previews.mediumUrl, function() {
                            callback();
                        });
                    });
                });
            });
        });

        /**
         * Verifies the flickr photo processor and assures that metadata is retrieved/set.
         */
        it('verify flickr photo link processing works', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            _createContentAndWait('link', 'http://www.flickr.com/photos/johnalewis/8949876197', null, function(restCtx, content) {
                assert.equal(content.previews.status, 'done');
                // Verify the displayName and description are set.
                assert.equal(content.displayName, 'Apereo Sakai/Jasig Fellows');
                assert.equal(content.description, '');
                // Ensure we have a thumbnail url.
                assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);
                _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, function() {
                    // Ensure we have small and medium images.
                    assert.ok(content.previews.smallUrl);
                    _verifySignedUriDownload(restCtx, content.previews.smallUrl, function() {
                        assert.ok(content.previews.mediumUrl);
                        _verifySignedUriDownload(restCtx, content.previews.mediumUrl, function() {
                            callback();
                        });
                    });
                });
            });
        });

        /**
         * Verifies the flickr set processor and assures that metadata is retrieved/set.
         */
        it('verify flickr set link processing works', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            _createContentAndWait('link', 'http://www.flickr.com/photos/iandolphinconferences/sets/72057594140880342/', null, function(restCtx, content) {
                assert.equal(content.previews.status, 'done');
                // Verify the displayName and description are set.
                assert.equal(content.displayName, 'JA-SIG Denver 03');
                assert.equal(content.description, '');
                // Ensure we have a thumbnail url.
                assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);
                _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, function() {
                    // Ensure we have small and medium images.
                    assert.ok(content.previews.smallUrl);
                    _verifySignedUriDownload(restCtx, content.previews.smallUrl, function() {
                        assert.ok(content.previews.mediumUrl);
                        _verifySignedUriDownload(restCtx, content.previews.mediumUrl, function() {
                            callback();
                        });
                    });
                });
            });
        });

        /**
         * Verifies the vimeo processor and assures that metadata is retrieved/set.
         */
        it('verify vimeo link processing works', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            _createContentAndWait('link', 'https://vimeo.com/17085981', null, function(restCtx, content) {
                assert.equal(content.previews.status, 'done');
                // Verify the displayName and description are set.
                assert.equal(content.displayName, 'Cambridge Montage');
                assert.equal(content.description, 'A brief look at the world of Cambridge University');
                // Ensure we have a thumbnail url.
                assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);
                _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, function() {
                    // Ensure we have small and medium images.
                    assert.ok(content.previews.smallUrl);
                    _verifySignedUriDownload(restCtx, content.previews.smallUrl, function() {
                        assert.ok(content.previews.mediumUrl);
                        _verifySignedUriDownload(restCtx, content.previews.mediumUrl, function() {
                            callback();
                        });
                    });
                });
            });
        });

        /**
         * Verifies the collaborative document processor works.
         */
        it('verify collaborative document processing works', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            _createContentAndWait('collabdoc', null, null, function(restCtx, content) {
                assert.equal(content.previews.status, 'done');
                // Ensure we have a thumbnail url.
                assert.strictEqual(content.previews.thumbnailUrl.indexOf('/api/download/signed'), 0);
                _verifySignedUriDownload(restCtx, content.previews.thumbnailUrl, function() {
                    callback();
                });
            });
        });

        /**
         * Verifies the collaborative document processor works.
         */
        it('verify unpublished collaborative documents are ignored', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            TestsUtil.generateTestUsers(signedAdminRestContext, 1, function(err, response) {
                assert.ok(!err);
                var restCtx = _.values(response)[0].restContext;
                RestAPI.Content.createCollabDoc(restCtx, 'Test document', 'Test document', 'private', [], [], function(err, contentObj) {
                    assert.ok(!err);

                    // Wait till it has been processed.
                    MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function() {
                        // Ensure the preview items are there.
                        RestAPI.Content.getContent(restCtx, contentObj.id, function(err, updatedContent) {
                            assert.ok(!err);
                            assert.equal(updatedContent.previews.status, 'ignored');
                            assert.ok(!updatedContent.previews.thumbnailUrl);
                            callback();
                        });
                    });
                });
            });
        });

        /**
         * Verifies that the preview status of a piece of content is set to ignored if no PP can handle it.
         */
        it('verify zip files get ignored', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            _createContentAndWait('file', null, getZipStream, function(restCtx, content) {
                assert.equal(content.previews.status, 'ignored');
                assert.ok(!content.previews.thumbnailUrl);
                callback();
            });
        });

        /**
         * Verifies that the PP looks at the mime type of the revision rather than looking at the mime type that sits
         * on the content object. This is an important distinction as `content.mime` points to the mimetype of the *latest*
         * revision, which is not necessarily the revision the PP might be processing.
         */
        it('verify content with multiple revisions of different mime types', function(callback) {
            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            // Disable the PP first, so we can generate 2 revisions without the PP starting at the first one
            PreviewAPI.disable(function(err) {
                assert.ok(!err);

                // Create a piece of content with 2 separate mime types
                MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function() {
                    TestsUtil.generateTestUsers(signedAdminRestContext, 1, function(err, response) {
                        assert.ok(!err);
                        var restCtx = _.values(response)[0].restContext;

                        // Create the initial revision as a zip file. ZIP is used as this gets ignored by the
                        // PP so the unit test can end within the test timeout time.
                        RestAPI.Content.createFile(restCtx, 'Test Content 1', 'Test content description 1', 'private', getZipStream,  [], [], function(err, contentObj) {
                            assert.ok(!err);

                            // Create the second revision as an image file.
                            RestAPI.Content.updateFileBody(restCtx, contentObj.id, getImageStream, function(err, updatedContentObj) {
                                assert.ok(!err);

                                // Purge the pending previews from the queue
                                PreviewTestUtil.purgePreviewsQueue(function(err) {
                                    assert.ok(!err);

                                    // Enable previews so we can handle the reprocessing
                                    PreviewAPI.enable(function(err) {
                                        assert.ok(!err);

                                        // Re-process the revisions
                                        RestAPI.Previews.reprocessPreview(signedAdminRestContext, contentObj.id, contentObj.latestRevisionId, function(err) {
                                            assert.ok(!err);
                                            RestAPI.Previews.reprocessPreview(signedAdminRestContext, contentObj.id, updatedContentObj.latestRevisionId, function(err) {
                                                assert.ok(!err);
                                                MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function() {

                                                    // The revisions should have been processed, fetch their metadata.
                                                    RestAPI.Content.getRevision(restCtx, contentObj.id, contentObj.latestRevisionId, function(err, revision) {
                                                        assert.ok(!err);
                                                        assert.equal(revision.previews.status, 'ignored');

                                                        RestAPI.Content.getRevision(restCtx, contentObj.id, updatedContentObj.latestRevisionId, function(err, revision) {
                                                            assert.ok(!err);
                                                            assert.equal(revision.previews.status, 'done');
                                                            callback();
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    describe('Preview Reprocessing', function() {

        /*!
         * Sets up the environment to quickly reprocess content by trashing all the content in the system and purging the previews queue.
         * It will also set up a user who creates two pieces of content (one file and one link) to allow for easy testing
         *
         * @param  {Boolean}    enableProcessor     Whether or not the processor should be enabled before handing control over to the callback
         * @param  {User}       callback.user       The user who created a piece of content
         * @param  {Content}    callback.file       The created file
         * @param  {Content}    callback.link       The created link
         */
        var _setupForReprocessing = function(enableProcessor, callback) {
            // Disable preview processing so we don't immediately process our piece of content
            PreviewAPI.disable(function(err) {
                assert.ok(!err);

                // Purge all task queues
                MQ.purgeAll(function(err) {
                    assert.ok(!err);

                    // Make sure all tasks are done
                    MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function() {
                        MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, function() {
                            MQTestUtil.whenTasksEmpty(SearchConstants.mq.TASK_INDEX_DOCUMENT, function() {
                                MQTestUtil.whenTasksEmpty(ActivityConstants.mq.TASK_ACTIVITY, function() {

                                    // Trash all the content items
                                    Cassandra.runQuery('TRUNCATE "Content"', [], function(err) {
                                        assert.ok(!err);

                                        // Create a piece of content that we can reprocess
                                        TestsUtil.generateTestUsers(signedAdminRestContext, 1, function(err, users, user) {
                                            assert.ok(!err);

                                            RestAPI.Content.createFile(user.restContext, 'Test Content', 'Test content description', 'private', getImageStream, [], [], function(err, content) {
                                                assert.ok(!err);

                                                // Create a link, we'll use it as a sanity check to ensure only file types got reprocessed
                                                RestAPI.Content.createLink(user.restContext, 'Google', 'Google', 'public', 'http://www.google.com', [], [], function(err, link) {

                                                    // Purge everything
                                                    PreviewTestUtil.purgePreviewsQueue(function(err) {
                                                        assert.ok(!err);

                                                        // Enable the preview processor if so desired
                                                        if (enableProcessor) {
                                                            PreviewAPI.enable(function(err) {
                                                                assert.ok(!err);

                                                                return callback(user, content, link);
                                                            });
                                                        } else {
                                                            return callback(user, content, link);
                                                        }
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        };

        /*!
         * Utility function to bind a listener to the preview reprocessing queue and let a
         * consumer handle the data of the resulting message.
         *
         * @param  {RestContext}    restCtx         The rest context with which to invoke the reprocess request. Should be bound to the global admin interface.
         * @param  {Object}         [filters]       The filter parameter of the reprocessing request
         * @param  {Function}       handler         The handler to handle the MQ data
         * @param  {Object}         handler.data    The arbitrary MQ data
         * @param  {Function}       [callback]      Invoked after the reprocessing rest request has been executed
         * @param  {Object}         [callback.err]  An error that occurred invokeing the reprocess previews rest request, if any
         */
        var _reprocessWithHandler = function(restCtx, filters, handler, callback) {
            callback = callback || function(err) { assert.ok(!err); };

            /*!
             * A convenience handler that takes care of invoking the MQ callback to let it acknowledge
             * the request.
             *
             * @param  {Object}     data            The MQ data for the message
             * @param  {Function}   mqCallback      The function to invoke to acknowledge handling the message
             */
            var _handler = function(data, mqCallback) {
                mqCallback();
                return handler(data);
            };

            // Unbind and rebind a process-all handler
            TaskQueue.unbind(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, function(err) {
                assert.ok(!err);

                TaskQueue.bind(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, _handler, null, function(err) {
                    assert.ok(!err);

                    RestAPI.Previews.reprocessPreviews(restCtx, filters, callback);
                });
            });
        };


        /**
         * Verifies that a single content item and revision can be reprocessed
         */
        it('verify reprocess previews validation and authorization', function(callback) {
            // This can run, even if previews are disabled

            // Verify anonymous, regular users and tenant admins from other tenants cannot reprocess previews
            TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users) {
                assert.ok(!err);
                var user = _.values(users)[0];
                RestAPI.Previews.reprocessPreview(user.restContext, 'c:camtest:someContent', 'rev:camtest:someRevision', function(err) {
                    assert.ok(err);
                    assert.equal(err.code, 401);

                    RestAPI.Previews.reprocessPreview(anonymousRestContext, 'c:camtest:someContent', 'rev:camtest:someRevision', function(err) {
                        assert.ok(err);
                        assert.equal(err.code, 401);

                        RestAPI.Previews.reprocessPreview(camAdminRestContext, 'c:other:someContent', 'rev:other:someRevision', function(err) {
                            assert.ok(err);
                            assert.equal(err.code, 401);

                            // Verify validation of content and revision ids
                            RestAPI.Previews.reprocessPreview(camAdminRestContext, 'notAContentId', 'rev:camtest:someRevision', function(err) {
                                assert.ok(err);
                                assert.equal(err.code, 400);

                                RestAPI.Previews.reprocessPreview(camAdminRestContext, 'c:camtest:someContent', 'notARevisionId', function(err) {
                                    assert.ok(err);
                                    assert.equal(err.code, 400);

                                    // Sanity check the validation and authorization
                                    RestAPI.Previews.reprocessPreview(camAdminRestContext, 'c:camtest:someContent', 'rev:camtest:someRevision', function(err) {
                                        assert.ok(!err);
                                        return callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Verify forcing a reprocessing of a preview results in the preview being reprocessed
         */
        it('verify reprocessing a preview processes the revision preview', function(callback) {

            // Ignore this test if the PP is disabled.
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            // Set ourselves up for quick reprocessing
            _setupForReprocessing(true, function(user, content) {

                // Force the previews to generate
                RestAPI.Previews.reprocessPreview(signedAdminRestContext, content.id, content.latestRevisionId, function(err) {
                    assert.ok(!err);

                    // Wait for the preview to finish generating
                    MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function() {

                        RestAPI.Content.getContent(user.restContext, content.id, function(err, content) {
                            assert.ok(!err);
                            assert.ok(content.previews);
                            assert.equal(content.previews.status, 'done');
                            return callback();
                        });
                    });
                });
            });
        });


        /**
         * Test that verifies when previews are reprocessed through the REST endpoint, a task is triggered.
         */
        it('verify reprocessing previews triggers an mq task', function(callback) {

            // Verify sending a single filter with a single value
            var filters = {'content_previewsStatus': 'error'};
            _reprocessWithHandler(globalAdminRestContext, filters, function(data) {
                assert.ok(data);
                assert.ok(data.filters);
                assert.ok(data.filters.content);
                assert.equal(data.filters.content.previewsStatus, 'error');

                // Verify sending a single filter with multiple values
                filters = {'content_previewsStatus': ['error', 'done', 'pending']};
                _reprocessWithHandler(globalAdminRestContext, filters, function(data) {
                    assert.ok(data);
                    assert.ok(data.filters);
                    assert.ok(data.filters.content);
                    assert.ok(data.filters.content.previewsStatus.length, 3);
                    assert.equal(data.filters.content.previewsStatus[0], 'error');
                    assert.equal(data.filters.content.previewsStatus[1], 'done');
                    assert.equal(data.filters.content.previewsStatus[2], 'pending');

                    // Verify sending multiple filters
                    filters = {
                        'content_previewsStatus': ['error', 'done', 'pending'],
                        'content_resourceSubType': ['file', 'link']
                    };
                    _reprocessWithHandler(globalAdminRestContext, filters, function(data) {
                        assert.ok(data);
                        assert.ok(data.filters);
                        assert.ok(data.filters.content);
                        assert.ok(data.filters.content.previewsStatus.length, 3);
                        assert.equal(data.filters.content.previewsStatus[0], 'error');
                        assert.equal(data.filters.content.previewsStatus[1], 'done');
                        assert.equal(data.filters.content.previewsStatus[2], 'pending');
                        assert.ok(data.filters.content.resourceSubType.length, 2);
                        assert.equal(data.filters.content.resourceSubType[0], 'file');
                        assert.equal(data.filters.content.resourceSubType[1], 'link');

                        // Verify sending mixed multiple filters
                        filters = {
                            'content_previewsStatus': ['error', 'done', 'pending'],
                            'content_resourceSubType': ['file', 'link'],
                            'revision_mime': ['application/pdf', 'application/msword']
                        };
                        _reprocessWithHandler(globalAdminRestContext, filters, function(data) {
                            assert.ok(data);
                            assert.ok(data.filters);
                            assert.ok(data.filters.content);
                            assert.ok(data.filters.content.previewsStatus.length, 3);
                            assert.equal(data.filters.content.previewsStatus[0], 'error');
                            assert.equal(data.filters.content.previewsStatus[1], 'done');
                            assert.equal(data.filters.content.previewsStatus[2], 'pending');
                            assert.ok(data.filters.content.resourceSubType.length, 2);
                            assert.equal(data.filters.content.resourceSubType[0], 'file');
                            assert.equal(data.filters.content.resourceSubType[1], 'link');
                            assert.ok(data.filters.revision.mime.length, 2);
                            assert.equal(data.filters.revision.mime[0], 'application/pdf');
                            assert.equal(data.filters.revision.mime[1], 'application/msword');
                            return callback();
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies only global admin users can reprocess previews
         */
        it('verify non-global admin users cannot reprocess previews', function(callback) {

            /*!
             * Task handler that will fail the test if invoked.
             *
             * @see MQ#bind
             */
            var _handleTaskFail = function(data) {
                assert.fail('Did not expect the task to be invoked.');
            };

            // Generate a normal user with which to try and reprocess previews
            TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users) {
                assert.ok(!err);

                var userRestCtx = users[_.keys(users)[0]].restContext;

                // Verify that an anonymous user-tenant user cannot reprocess previews
                _reprocessWithHandler(anonymousRestContext, null, _handleTaskFail, function(err) {
                    assert.ok(err);

                    // Verify that an anonymous global-tenant user cannot reprocess previews
                    RestAPI.Previews.reprocessPreviews(TestsUtil.createGlobalRestContext(), {'content_resourceSubType': 'file'}, function(err) {
                        assert.ok(err);
                        assert.equal(err.code, 401);

                        // Verify that a regular user cannot generate a task
                        RestAPI.Previews.reprocessPreviews(userRestCtx, null, function(err) {
                            assert.ok(err);

                            // Verify that a tenant admin cannot generate a task
                            RestAPI.Previews.reprocessPreviews(camAdminRestContext, null, function(err) {
                                assert.ok(err);

                                // Unbind our handler, so we don't trip over the next test
                                TaskQueue.unbind(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, function(err) {
                                    assert.ok(!err);
                                    return callback();
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies the filters are validated for correctness
         */
        it('verify parameter validation for reprocessing previews requests', function(callback) {

            /*!
             * Task handler that will fail the test if invoked.
             *
             * @see MQ#bind
             */
            var _handleTaskFail = function(data) {
                assert.fail('Did not expect the task to be invoked.');
            };

            // Providing no filters must be an oversight and is invalid
            _reprocessWithHandler(globalAdminRestContext, null, _handleTaskFail, function(err) {
                assert.equal(err.code, 400);

                // Providing unknown filters is totally unacceptable
                RestAPI.Previews.reprocessPreviews(globalAdminRestContext, {'foo': 'bar'}, function(err) {
                    assert.equal(err.code, 400);
                    RestAPI.Previews.reprocessPreviews(globalAdminRestContext, {'content_foo': 'bar'}, function(err) {
                        assert.equal(err.code, 400);
                        RestAPI.Previews.reprocessPreviews(globalAdminRestContext, {'revision_foo': 'bar'}, function(err) {
                            assert.equal(err.code, 400);

                            // Unbind our handler, so we don't trip over the next test
                            TaskQueue.unbind(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, function(err) {
                                assert.ok(!err);
                                return callback();
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that all content is reprocessed
         */
        it('verify validation of reprocessing previews tasks', function(callback) {
            // Purge everything
            PreviewTestUtil.purgePreviewsQueue(function(err) {
                assert.ok(!err);
                // Enable previews so we can handle the reprocessing
                PreviewAPI.enable(function(err) {
                    // Unbind the PP first, so we can listen for incoming generate previews task
                    TaskQueue.unbind(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function(err) {
                        assert.ok(!err);

                        // It's possible the PP started processing on old item, wait till it's done so it doesn't mess up this test
                        MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function() {

                            // Bind our own listener that will keep track of content that needs reprocessing (it should always be empty)
                            var contentToBeReprocessed = [];
                            var reprocessTracker = function(data, callback) {
                                contentToBeReprocessed.push(data);
                                callback();
                            };
                            TaskQueue.bind(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, reprocessTracker, null, function(err) {
                                assert.ok(!err);

                                // Missing filters is invalid
                                TaskQueue.submit(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, {}, function() {
                                    MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, function() {
                                        MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function() {
                                            assert.equal(contentToBeReprocessed.length, 0);

                                            // Unknown content filter is invalid
                                            TaskQueue.submit(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, {'filters': {'content': {'foo': 'bar'}}}, function() {
                                                MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, function() {
                                                    MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function() {
                                                        assert.equal(contentToBeReprocessed.length, 0);

                                                        // Unknown revision filter is invalid
                                                        TaskQueue.submit(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, {'filters': {'revision': {'foo': 'bar'}}}, function() {
                                                            MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, function() {
                                                                MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function() {
                                                                    assert.equal(contentToBeReprocessed.length, 0);
                                                                    return callback();
                                                                });
                                                            });
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that a push notification is sent out on preview generation completion
         */
        it('verify a push notification is sent out on preview generation completion', function(callback) {
            // Ignore this test if the PP is disabled
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            PreviewTestUtil.purgePreviewsQueue(function(err) {
                assert.ok(!err);

                // Re-enable the processor
                PreviewAPI.enable(function(err) {
                    assert.ok(!err);

                    TestsUtil.generateTestUsers(signedAdminRestContext, 1, function(err, users, mrvisser) {
                        assert.ok(!err);

                        RestAPI.User.getMe(mrvisser.restContext, function(err, mrvisserFullMeData) {
                            assert.ok(!err);

                            // Create a file that we can process
                            RestAPI.Content.createFile(mrvisser.restContext, 'Test Content 1', 'Test content description 1', 'private', getImageStream,  [], [], function(err, contentObj) {
                                assert.ok(!err);

                                // Setup a client that listens to the content's activity stream
                                RestAPI.Content.getContent(mrvisser.restContext, contentObj.id, function(err, contentObj) {
                                    assert.ok(!err);
                                    var data = {
                                        'authentication': {
                                            'userId': mrvisserFullMeData.id,
                                            'tenantAlias': mrvisserFullMeData.tenant.alias,
                                            'signature': mrvisserFullMeData.signature
                                        },
                                        'streams': [
                                            {
                                                'resourceId': contentObj.id,
                                                'streamType': 'activity',
                                                'token': contentObj.signature,
                                                'transformer': 'internal'
                                            }
                                        ]
                                    };
                                    ActivityTestsUtil.getFullySetupPushClient(data, function(client) {

                                        // When the item has been processed we route the activities so we can check our push notification
                                        MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function() {
                                            ActivityTestsUtil.collectAndGetActivityStream(mrvisser.restContext, null, null, function() {});

                                            client.on('message', function(message) {
                                                if (message.activity && message.activity['oae:activityType'] === 'previews-finished') {
                                                    assert.equal(message.activity.object.previews.status, 'done');

                                                    // Ensure that the full previews object is returned
                                                    assert.equal(message.activity.object.previews.total, 4);
                                                    assert.ok(message.activity.object.previews.largeUrl);
                                                    assert.ok(message.activity.object.previews.mediumUrl);
                                                    assert.ok(message.activity.object.previews.smallUrl);
                                                    assert.ok(message.activity.object.previews.thumbnailUrl);
                                                    return callback();
                                                }
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });


        /**
         * Test that verifies that previews can be reprocessed by passing in a content filter
         */
        it('verify reprocessing previews with a content filter', function(callback) {
            // Ignore this test if the PP is disabled
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            // Set ourselves up for quick reprocessing
            _setupForReprocessing(true, function(user, content, link) {

                // Reprocess all content items that are files
                RestAPI.Previews.reprocessPreviews(globalAdminRestContext, {'content_resourceSubType': 'file'}, function(err) {
                    MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, function() {
                        MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function() {

                            // Assert that we reprocessed the file content object
                            RestAPI.Content.getContent(user.restContext, content.id, function(err, content) {
                                assert.ok(!err);
                                assert.equal(content.previews.status, 'done');

                                // Assert that we did not reprocess the link object
                                RestAPI.Content.getContent(user.restContext, link.id, function(err, link) {
                                    assert.ok(!err);
                                    assert.equal(link.previews.status, 'pending');
                                    return callback();
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that previews can be reprocessed by passing in a revision filter
         */
        it('verify reprocessing previews with a revision filter', function(callback) {
            // Ignore this test if the PP is disabled
            if (!defaultConfig.previews.enabled) {
                return callback();
            }

            // Set ourselves up for quick reprocessing but don't start processing just yet
            _setupForReprocessing(false, function(user, content) {

                var initialRevisionCreated = content.created;
                var initialRevisionId = content.latestRevisionId;

                // Wait at least 10ms before creating the new revision so we don't accidentally create a second revision at the exact same time as the original one
                setTimeout(function() {

                    // Create a new revision
                    RestAPI.Content.updateFileBody(user.restContext, content.id, getImageGIFStream, function(err, updatedContent) {
                        assert.ok(!err);
                        var secondRevisionCreated = updatedContent.created;
                        var secondRevisionId = updatedContent.latestRevisionId;

                        // Assert nothing has been previewed yet
                        RestAPI.Content.getRevisions(user.restContext, content.id, null, null, function(err, data) {
                            assert.ok(!err);
                            assert.ok(!data.results[0].previews);
                            assert.ok(!data.results[1].previews);


                            // Re-enable the preview processor
                            PreviewAPI.enable(function(err) {
                                assert.ok(!err);

                                // Reprocess all content items that have a revision that was created after our first revision
                                RestAPI.Previews.reprocessPreviews(globalAdminRestContext, {'revision_createdAfter': (secondRevisionCreated - 1)}, function(err) {
                                    MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, function() {
                                        MQTestUtil.whenTasksEmpty(PreviewConstants.MQ.TASK_GENERATE_PREVIEWS, function() {

                                            // Assert that we only reprocessed the last revision
                                            RestAPI.Content.getRevisions(user.restContext, content.id, null, null, function(err, data) {
                                                assert.ok(!err);

                                                // The latest revision (first in the list) should have previews associated to it
                                                assert.ok(data.results[0].previews);
                                                assert.equal(data.results[0].previews.status, 'done');

                                                // The initial revision (second in the list) should not have any previews
                                                assert.ok(!data.results[1].previews);
                                                return callback();
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                }, 10);
            });
        });
    });

    describe('Preview util', function() {

        describe('#downloadRemoteFile', function() {

            /**
             * Test that verifies remote files can be downloaded
             */
            it('verify remote files can be downloaded', function(callback) {
                var tmpFile = Tempfile.createTempFile();
                PreviewUtil.downloadRemoteFile('http://localhost:2000/api/me', tmpFile.path, function(err, path) {
                    assert.ok(!err);
                    fs.readFile(path, 'utf8', function(err, data) {
                        assert.ok(!err);

                        // Verify there is some data there.
                        assert.ok(data);

                        // Verify we don't leak the global session into the download fetcher.
                        data = JSON.parse(data);
                        assert.ok(data.anon);

                        // Remove the temporary file
                        tmpFile.remove(function(err) {
                            assert.ok(!err);
                            callback();
                        });
                    });
                });
            });
        });
    });
});
