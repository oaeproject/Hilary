/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var ShortId = require('shortid');

var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var log = require('oae-logger').logger('discussions-dao');
var TenantsAPI = require('oae-tenants');

var Discussion = require('oae-discussions/lib/model').Discussion;

/**
 * Create a new discussion.
 *
 * @param  {String}     createdBy           The id of the user creating the discussion
 * @param  {String}     displayName         The display name of the discussion
 * @param  {String}     [description]       A longer description for the discussion
 * @param  {String}     [visibility]        The visibility of the discussion. One of public, loggedin, private. Defaults to the configured tenant default.
 * @param  {Object}     [opts]              Additional optional parameters
 * @param  {Number}     [opts.created]      When the discussion was created. If unspecified, will use the current timestamp
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Discussion} callback.discussion The discussion object that was created
 */
var createDiscussion = module.exports.createDiscussion = function(createdBy, displayName, description, visibility, opts, callback) {
    opts = opts || {};

    var created = opts.created || Date.now();

    var tenantAlias = AuthzUtil.getPrincipalFromId(createdBy).tenantAlias;
    var discussionId = _createDiscussionId(tenantAlias);
    var storageHash = {
        'tenantAlias': tenantAlias,
        'createdBy': createdBy,
        'displayName': displayName,
        'description': description,
        'visibility': visibility,
        'created': created,
        'lastModified': created
    };

    var query = Cassandra.constructUpsertCQL('Discussions', 'id', discussionId, storageHash, 'QUORUM');
    Cassandra.runQuery(query.query, query.parameters, function(err) {
        if (err) {
            return callback(err);
        }

        return callback(null, _storageHashToDiscussion(discussionId, storageHash));
    });
};

/**
 * Update the basic profile of the specified discussion.
 *
 * @param  {Discussion} discussion          The discussion to update
 * @param  {Object}     profileFields       An object whose keys are profile field names, and the value is the value to which you wish the field to change
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Discussion} callback.discussion The updated discussion object
 */
var updateDiscussion = module.exports.updateDiscussion = function(discussion, profileFields, callback) {
    var storageHash = _.extend({}, profileFields);
    storageHash.lastModified = storageHash.lastModified || Date.now();

    var query = Cassandra.constructUpsertCQL('Discussions', 'id', discussion.id, storageHash, 'QUORUM');
    Cassandra.runQuery(query.query, query.parameters, function(err) {
        if (err) {
            return callback(err);
        }

        return callback(null, _createUpdatedDiscussionFromStorageHash(discussion, storageHash));
    });
};

/**
 * Get a discussion basic profile by its id.
 *
 * @param  {String}     discussionId        The id of the discussion to get
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Discussion} callback.discussion The discussion object requested
 */
var getDiscussion = module.exports.getDiscussion = function(discussionId, callback) {
    getDiscussionsById([discussionId], function(err, discussions) {
        if (err) {
            return callback(err);
        }

        return callback(null, discussions[0]);
    });
};


/**
 * Delete a discussion profile by its id.
 * This will *NOT* remove the discussion from the members their libraries.
 *
 * @param  {String}     discussionId        The id of the discussion to delete
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 */
var deleteDiscussion = module.exports.deleteDiscussion = function(discussionId, callback) {
    log().info({'discussionId': discussionId}, 'Discussion deleted');
    Cassandra.runQuery('DELETE FROM Discussions WHERE id = ?', [discussionId], callback);
};

/**
 * Get multiple discussions by their ids
 *
 * @param  {String[]}       discussionIds           The ids of the discussions to get
 * @param  {Function}       callback                Invoked when the process completes
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Discussion[]}   callback.discussions    The discussion objects requested, in the same order as the discussion ids
 */
var getDiscussionsById = module.exports.getDiscussionsById = function(discussionIds, callback) {
    if (!discussionIds || discussionIds.length === 0) {
        return callback(null, []);
    }

    Cassandra.runQuery('SELECT * FROM Discussions USING CONSISTENCY QUORUM WHERE id IN (?)', [discussionIds], function(err, rows) {
        if (err) {
            return callback(err);
        }

        // Convert the retrieved storage hashes into the Discussion model
        var discussions = {};
        rows.forEach(function(row) {
            var storageHash = Cassandra.rowToHash(row);
            discussions[row.key] = _storageHashToDiscussion(row.key, storageHash);
        });

        // Order the discussions according to the array of discussion ids
        var orderedDiscussions = [];
        _.each(discussionIds, function(discussionId) {
            orderedDiscussions.push(discussions[discussionId]);
        });

        return callback(null, orderedDiscussions);
    });
};

/**
 * Create a discussion model object from its id and the storage hash.
 *
 * @param  {String}     discussionId    The id of the discussion
 * @param  {Object}     hash            A simple object that represents the stored discussion object
 * @return {Discussion}                 The discussion model object. Returns `null` if this does not represent an existing discussion
 * @api private
 */
var _storageHashToDiscussion = function(discussionId, hash) {

    // Use tenantAlias as a slug column to determine if this discussion actually existed
    if (!hash.tenantAlias) {
        return null;
    }

    return new Discussion(
        TenantsAPI.getCachedTenantByAlias(hash.tenantAlias),
        discussionId,
        hash.createdBy,
        hash.displayName,
        hash.description,
        hash.visibility,
        hash.created,
        hash.lastModified
    );
};

/**
 * Create an updated discussion object from the provided one, with updates from the provided storage hash
 *
 * @param  {Discussion}     discussion  The discussion object to update
 * @param  {Object}         hash        A simple object that represents stored fields for the discussion
 * @return {Discussion}                 The updated discussion object
 * @api private
 */
var _createUpdatedDiscussionFromStorageHash = function(discussion, hash) {
    return new Discussion(
        discussion.tenant,
        discussion.id,
        discussion.createdBy,
        hash.displayName || discussion.displayName,
        hash.description || discussion.description,
        hash.visibility || discussion.visibility,
        discussion.created,
        hash.lastModified || discussion.lastModified
    );

};

/**
 * Generate a new unique discussion id
 *
 * @param  {String}     tenantAlias     The tenant for which to to generate the id
 * @return {String}                     A unique discussion resource id
 * @api private
 */
var _createDiscussionId = function(tenantAlias) {
    return AuthzUtil.toId('d', tenantAlias, ShortId.generate());
};

