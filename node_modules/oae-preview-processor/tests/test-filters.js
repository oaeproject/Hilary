/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');

var Content = require('oae-content/lib/model').Content;
var Revision = require('oae-content/lib/model').Revision;

var FilterGenerator = require('oae-preview-processor/lib/filters').FilterGenerator;

describe('Preview processor - filters', function() {

    // A set of timestamps (ms since epoch) each a day apart (A = 5 days ago against F, B = 4 days ago, etc)
    var times = {
        'A': 1378396474099,
        'B': 1378482876661,
        'C': 1378569279923,
        'D': 1378655682036,
        'E': 1378742084186,
        'F': 1378828613052
    };

    /**
     * Get some mocked content data
     *
     * @return {Object[]} Returns an array of mocked content items that each has at least one revision
     * @api private
     */
    var _getMockData = function() {
        // Fake 5 content items
        var content = [
            new Content('camtest', 'c:camtest:a', 'public', 'A', 'A', 'file', 'u:camtest:simon', times.A, times.E, 'a-3'),
            new Content('camtest', 'c:camtest:b', 'public', 'B', 'B', 'link', 'u:camtest:nico', times.B, times.B, 'b-1'),
            new Content('camtest', 'c:camtest:c', 'public', 'C', 'C', 'collabdoc', 'u:camtest:mrvisser', times.B, times.D, 'c-3'),
            new Content('camtest', 'c:camtest:d', 'public', 'D', 'D', 'file', 'u:camtest:simon', times.C, times.D, 'd-2'),
            new Content('gttest', 'c:gttest:e', 'public', 'E', 'E', 'file', 'u:gttest:stuart', times.D, times.F, 'e-2')
        ];

        // Give each content item a revision
        content[0].previews = {'status': 'error'};
        content[0].revisions = [
            {'revisionId': 'a-1', 'created': times.A, 'createdBy': 'u:camtest:simon', 'mime': 'application/pdf', 'previews': {'status': 'done'}},
            {'revisionId': 'a-2', 'created': times.B, 'createdBy': 'u:camtest:bert', 'mime': 'application/msword', 'previews': {'status': 'error'}},
            {'revisionId': 'a-3', 'created': times.E, 'createdBy': 'u:camtest:bert', 'mime': 'application/excel', 'previews': {'status': 'error'}}
        ];

        content[1].previews = {'status': 'done'};
        content[1].revisions = [
            {'revisionId': 'b-1', 'created': times.B, 'createdBy': 'u:camtest:nico', 'previews': {'status': 'done'}}
        ];
        content[2].previews = {'status': 'done'};
        content[2].revisions = [
            {'revisionId': 'c-1', 'created': times.B, 'createdBy': 'u:camtest:mrvisser', 'etherpadHtml': 'Foo', 'previews': {'status': 'done'}},
            {'revisionId': 'c-2', 'created': times.C, 'createdBy': 'u:camtest:mrvisser', 'etherpadHtml': 'Bar', 'previews': {'status': 'done'}},
            {'revisionId': 'c-3', 'created': times.D, 'createdBy': 'u:camtest:mrvisser', 'etherpadHtml': 'Baz', 'previews': {'status': 'done'}}
        ];
        content[3].previews = {'status': 'ignored'};
        content[3].revisions = [
            {'revisionId': 'd-1', 'created': times.C, 'createdBy': 'u:camtest:simon', 'mime': 'application/zip', 'previews': {'status': 'error'}},
            {'revisionId': 'd-2', 'created': times.D, 'createdBy': 'u:camtest:bert', 'mime': 'application/zip', 'previews': {'status': 'ignored'}}
        ];
        content[4].previews = {'status': 'error'};
        content[4].revisions = [
            {'revisionId': 'e-1', 'created': times.D, 'createdBy': 'u:gttest:stuart', 'mime': 'video/mp4', 'previews': {'status': 'done'}},
            {'revisionId': 'e-2', 'created': times.F, 'createdBy': 'u:camtest:bert', 'mime': 'video/theora', 'previews': {'status': 'error'}}
        ];
        // Populate each piece of content's tenantAlias
        _.each(content, function(c) {
            c.tenantAlias = c.tenant.alias;
        });

        return content;
    };

    describe('Validation', function() {

        /**
         * Test that verifies that at least 1 filter should be specified
         */
        it('Missing filters', function(callback) {
            var filters = {};
            var filterGenerator = new FilterGenerator(filters);
            assert.ok(filterGenerator.hasErrors());
            assert.ok(filterGenerator.getErrors().length > 0);
            assert.equal(filterGenerator.getFirstError().code, 400);
            callback();
        });

        /**
         * Test that verifies that unknown filters trigger a validation error
         */
        it('Unknown filters', function(callback) {
            var filters = {
                'content': {
                    'unknown': 'foo'
                }
            };
            var filterGenerator = new FilterGenerator(filters);
            assert.ok(filterGenerator.hasErrors());
            assert.ok(filterGenerator.getErrors().length > 0);
            assert.equal(filterGenerator.getFirstError().code, 400);

            filters = {
                'revision': {
                    'unknown': 'foo'
                }
            };
            filterGenerator = new FilterGenerator(filters);
            assert.ok(filterGenerator.hasErrors());
            assert.ok(filterGenerator.getErrors().length > 0);
            assert.equal(filterGenerator.getFirstError().code, 400);
            callback();
        });
    });

    describe('Filtering', function() {

        /**
         * Helper function that filters mocked content and verifies the expected results
         *
         * @param  {Object}     filters                         A set of filters as accepted by `FilterGenerator`
         * @param  {Object}     expectations                    A set of expected results
         * @param  {Boolean}    expectations.needsRevisions     `true` if you expect the generator to return `true` for the `.needsRevisions()` call
         * @param  {String[]}   expectations.contentStage       An array of content IDs that should remain after the content filtering stage
         * @param  {Object[]}   expectations.revisionsStage     An array of objects. One object per content item that is supposed to remain after the revision filtering stage. The `contentId` value determines which content ID should remain and the `revisions` holds an array of revision IDs that should remain
         * @api private
         */
        var _filterAndAssert = function(filters, expectations) {
            var filterGenerator = new FilterGenerator(filters);
            assert.ok(!filterGenerator.hasErrors());
            assert.equal(filterGenerator.needsRevisions(), expectations.needsRevisions);

            // Filter some content
            var content = _getMockData();
            var filteredContent = filterGenerator.filterContent(content);
            assert.ok(filteredContent);
            assert.equal(filteredContent.length, expectations.contentStage.length);
            for (var i = 0; i < 0; i++) {
                assert.equal(filteredContent[i].id, expectations.contentStage[i]);
            }

            // Filter the remaining revisions
            filteredContent = filterGenerator.filterRevisions(filteredContent);
            assert.ok(filteredContent);
            assert.equal(filteredContent.length, expectations.revisionStage.length);
            for (i = 0; i <filteredContent.length; i++) {
                assert.equal(filteredContent[i].id, expectations.revisionStage[i].contentId);
                for (var r = 0; r < expectations.revisionStage[i].revisions.length; r++) {
                    assert.equal(filteredContent[i].revisions[r].revisionId, expectations.revisionStage[i].revisions[r]);
                }
            }
        };

        /**
         * Test that verifies you can filter by both content and revision properties
         */
        it('filter by content.resourceSubType and revision.mime', function(callback) {
            var filters = {
                'content': {
                    'resourceSubType': 'file'
                },
                'revision': {
                    'mime': ['application/pdf', 'application/msword']
                }
            };

            _filterAndAssert(filters, {
                'needsRevisions': true,
                'contentStage': ['c:camtest:a', 'c:camtest:d', 'c:camtest:e'],
                'revisionStage': [
                    {'contentId': 'c:camtest:a', 'revisions': ['a-1', 'a-2']}
                ]
            });
            callback();
        });

        /**
         * Test that verifies you can filter by tenant
         */
        it('filter by content.tenantAlias', function(callback) {
            var filters = {
                'content': {
                    'tenant': 'camtest'
                }
            };

            _filterAndAssert(filters, {
                'needsRevisions': false,
                'contentStage': ['c:camtest:a', 'c:camtest:b', 'c:camtest:c', 'c:camtest:d'],
                'revisionStage': [
                    {'contentId': 'c:camtest:a', 'revisions': ['a-1', 'a-2', 'a-3']},
                    {'contentId': 'c:camtest:b', 'revisions': ['b-1']},
                    {'contentId': 'c:camtest:c', 'revisions': ['c-1', 'c-2', 'c-3']},
                    {'contentId': 'c:camtest:d', 'revisions': ['d-1', 'd-2']}
                ]
            });
            callback();
        });

        /**
         * Test that verifies you can filter by the content creator
         */
        it('filter by content.createdBy', function(callback) {
            var filters = {
                'content': {
                    'createdBy': 'u:camtest:simon'
                }
            };

            _filterAndAssert(filters, {
                'needsRevisions': false,
                'contentStage': ['c:camtest:a', 'c:camtest:d'],
                'revisionStage': [
                    {'contentId': 'c:camtest:a', 'revisions': ['a-1', 'a-2', 'a-3']},
                    {'contentId': 'c:camtest:d', 'revisions': ['d-1', 'd-2']}
                ]
            });
            callback();
        });

        /**
         * Test that verifies you can filter by the revision creator
         */
        it('filter by revision.createdBy', function(callback) {
            var filters = {
                'revision': {
                    'createdBy': 'u:camtest:simon'
                }
            };

            _filterAndAssert(filters, {
                'needsRevisions': true,
                'contentStage': ['c:camtest:a', 'c:camtest:b', 'c:camtest:c', 'c:camtest:d', 'c:gttest:e'],
                'revisionStage': [
                    {'contentId': 'c:camtest:a', 'revisions': ['a-1']},
                    {'contentId': 'c:camtest:d', 'revisions': ['d-1']}
                ]
            });
            callback();
        });

        /**
         * Test that verifies you can filter revisions on the created timestamp
         */
        it('filter by revision.createdBefore', function(callback) {
            var filters = {
                'revision': {
                    'createdBefore': times.B
                }
            };
            _filterAndAssert(filters, {
                'needsRevisions': true,
                'contentStage': ['c:camtest:a', 'c:camtest:b', 'c:camtest:c', 'c:camtest:d', 'c:camtest:e'],
                'revisionStage': [
                    {'contentId': 'c:camtest:a', 'revisions': ['a-1']}
                ]
            });
            callback();
        });

        /**
         * Test that verifies you can filter revisions on the created timestamp
         */
        it('filter by revision.createdAfter', function(callback) {
            var filters = {
                'revision': {
                    'createdAfter': times.D
                }
            };
            _filterAndAssert(filters, {
                'needsRevisions': true,
                'contentStage': ['c:camtest:a', 'c:camtest:b', 'c:camtest:c', 'c:camtest:d', 'c:gttest:e'],
                'revisionStage': [
                    {'contentId': 'c:camtest:a', 'revisions': ['a-3']},
                    {'contentId': 'c:gttest:e', 'revisions': ['e-2']}
                ]
            });
            callback();
        });

        /**
         * Test that verifies you can filter revisions on the mimetype
         */
        it('filter by revision.mime', function(callback) {
            var filters = {
                'revision': {
                    'mime': ['application/pdf', 'video/mp4']
                }
            };
            _filterAndAssert(filters, {
                'needsRevisions': true,
                'contentStage': ['c:camtest:a', 'c:camtest:b', 'c:camtest:c', 'c:camtest:d', 'c:camtest:e'],
                'revisionStage': [
                    {'contentId': 'c:camtest:a', 'revisions': ['a-1']},
                    {'contentId': 'c:gttest:e', 'revisions': ['e-1']}
                ]
            });
            callback();
        });

        /**
         * Test that verifies you can filter content on its preview status
         */
        it('filter by content.previews.status', function(callback) {
            var filters = {
                'content': {
                    'previewsStatus': 'error'
                }
            };
            _filterAndAssert(filters, {
                'needsRevisions': false,
                'contentStage': ['c:camtest:a', 'c:gttest:e'],
                'revisionStage': [
                    {'contentId': 'c:camtest:a', 'revisions': ['a-1', 'a-2', 'a-3']},
                    {'contentId': 'c:gttest:e', 'revisions': ['e-1', 'e-2']}
                ]
            });

            // Ensure that content items without a proper previews object get reprocessed
            var content = [new Content('camtest', 'c:camtest:a', 'public', 'A', 'A', 'file', 'u:camtest:simon', times.A, times.E, 'a-3')];
            var filterGenerator = new FilterGenerator(filters);
            assert.ok(!filterGenerator.hasErrors());
            assert.equal(filterGenerator.needsRevisions(), false);

            var filteredContent = filterGenerator.filterContent(content);
            assert.ok(filteredContent);
            assert.equal(filteredContent.length, 1);
            callback();
        });

        /**
         * Test that verifies you can filter revisions on their preview status
         */
        it('filter by revision.previews.status', function(callback) {
            // Filter on pdf and word files
            var filters = {
                'revision': {
                    'previewsStatus': 'error'
                }
            };
            _filterAndAssert(filters, {
                'needsRevisions': true,
                'contentStage': ['c:camtest:a', 'c:camtest:b', 'c:camtest:c', 'c:camtest:d', 'c:camtest:e'],
                'revisionStage': [
                    {'contentId': 'c:camtest:a', 'revisions': ['a-2']},
                    {'contentId': 'c:camtest:d', 'revisions': ['d-1']},
                    {'contentId': 'c:gttest:e', 'revisions': ['e-2']}
                ]
            });

            // Ensure that revision items without a proper previews object get reprocessed
            var content = [new Content('camtest', 'c:camtest:a', 'public', 'A', 'A', 'file', 'u:camtest:simon', times.A, times.E, 'a-3')];
            content[0].revisions = [{'revisionId': 'd-1', 'created': times.C, 'createdBy': 'u:camtest:simon', 'mime': 'application/zip'}];
            var filterGenerator = new FilterGenerator(filters);
            assert.ok(!filterGenerator.hasErrors());
            assert.equal(filterGenerator.needsRevisions(), true);

            var filteredContent = filterGenerator.filterContent(content);
            assert.ok(filteredContent);
            assert.equal(filteredContent.length, 1);
            filteredContent = filterGenerator.filterRevisions(filteredContent);
            assert.ok(filteredContent);
            assert.equal(filteredContent.length, 1);
            callback();
        });
    });
});
