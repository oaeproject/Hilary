var OAE = require('oae-util/lib/OAE');

/**
 * Enumerates the different types of principals that are recognized by the roles module.
 */
var PrincipalTypes = module.exports.PrincipalTypes = { USER: 'u', GROUP: 'g' };

/**
 * Enumerates the different types of objects that are recognized by the roles module.
 */
var ObjectTypes = module.exports.ObjectTypes = { CONTENT: 'content', GROUP: 'group' };

/**
 * A stateful context object that is used to execute role checks on a principal.
 *
 * @param {Object} The `model.Principal` to which the `SecurityContext` is bound 
 * 
 * @return {Object} A `SecurityContext` object that may be used to execute role checks for the principal.
 */
var SecurityContext = module.exports.SecurityContext = function(principal) {

    var rowKey = getPrincipalKey(principal);
    var that = {};

    /**
     * Determine the role of the principal on the specified object instance.
     * 
     * @param {String} objectType The type of object, as specified by `ObjectType`
     * @param {String} objectId The ID of the object instance
     * @param {Function} callback A function(role, err) specifying the role of the user. If the user has no role
     * or there is an `err`or performing the check, `role` will be `null`
     **/
    that.getRole = function(objectType, objectId, callback) {
        var columnName = getColumnName(objectType, objectId);
        var cql = 'select ? from Role where principal = ?';
        OAE.runQuery(cql, [columnName, rowKey], function(err, rows) {
            if (!err) {
                var value = rows[0].colHash[columnName];
                if (value) {
                    callback(value);
                } else {
                    callback(null);
                }
            } else {
                callback(null, err);
            }
        });
    }

    /**
     * Determines whether or not the principal has *any* role associated to the given object instance.
     *
     * @param {String} objectType The type of object, as specified by `ObjectType`
     * @param {String} objectId The ID of the object instance
     * @param {Function} callback A function(hasAnyRole, err) specifying whether or not the user has a role
     */
    that.hasAnyRole = function(objectType, objectId, callback) {
        that.getRole(objectType, objectId, function(role, err) {
            if (!err) {
                callback(role !== null);
            } else {
                callback(false, err);
            }
        });
    }

    /**
     * Determines whether or not the principal has the specified role on the given object instance.
     * 
     * @param {String} objectType The type of object, as specified by `ObjectType`
     * @param {String} objectId The ID of the object instance
     * @param {String} roleId The role to check
     * @param {Function} callback A function(hasRole, err) specifying whether or not the user has the role
     */
    that.hasRole = function(objectType, objectId, roleId, callback) {
        that.getRole(objectType, objectId, function(role, err) {
            if (!err) {
                callback(role === roleId);
            } else {
                callback(false, err);
            }
        });
    }

    /**
     * Given an object type (as determined by `ObjectTypes`), return all `{object id} => {role}` entries that are
     * associated to the principal. The structure of the `entries` result looks like the following:
     * 
     * ```javascript
     * [
     *   {
     *      "id": "<contentId1>",
     *      "role": "<roleId1>"
     *    },
     *    {
     *      "id": "<contentId2>"
     *      "role": "<roleId2>"
     *    }
     * ]
     * ```
     * 
     * @param {String} objectType The object type, as specified by `ObjectTypes`, to search
     * @param {String} start The starting entry on which to begin returning results (used for paging). **This is not a number**. If `null`, then the results will simply begin from the start. If the `object id` is provided, then results will begin from that `object id`s location, exclusively.
     * @param {Number} limit The maximum number of entries to return (used for paging)
     * @param {Function} callback A function(entries, err), providing the list of role entries that match the search
     */
    that.getRolesForObjectType = function(objectType, start, limit, callback) {
        if (isNaN(limit)) {
            callback(null, {why: '"limit" parameter must be a number when searching for active roles'});
            return;
        }

        var firstColumnIndex = 0;
        var columnPrefix = objectType+':';

        if (start === null) {
            start = columnPrefix;    
        } else {
            // the starting point should be ObjectType:ObjectId combo
            start = columnPrefix+start;

            // increment the limit if the user specified the start point, because we skip the first entry to get the EXCLUSIVE
            // page range
            limit++;
            firstColumnIndex = 1;
        }

        var cql = 'select first '+limit+' ? .. \'\' from Role where principal = ?';
        OAE.runQuery(cql, [start, rowKey], function(err, rows) {
            if (!err) {
                var entries = [];
                for (var i = firstColumnIndex; i < rows[0]._colCount; i++) {
                    var col = rows[0].cols[i];

                    // prevents us from overflowing into other object types
                    if (col.name.indexOf(columnPrefix) !== 0)
                        break;

                    // add the column to the entries list, the object id will have the ObjectType prefix stripped away from it
                    var objectId = col.name.substring(columnPrefix.length); 
                    entries.push({ 'id': objectId, 'role': col.value });
                }
                callback(entries);
            } else {
                callback(null, err);
            }
        });
    }

    /**
     * Assign the given principal a role on an object instance. If the user already has a role, it will simply be updated.
     * 
     * @param {String} objectType The type of object, as specified by `ObjectType`
     * @param {String} objectId The ID of the object instance
     * @param {String} roleId The role to assign to the principal
     * @param {Function} callback A function(err) specifying whether or not the operation was successful
     */
    that.addRole = function(objectType, objectId, roleId, callback) {
        var columnName = objectType+':'+objectId;
        var value = roleId;
        var cql = 'update Role set ? = ? where principal = ?';
        OAE.runQuery(cql, [columnName, value, rowKey], callback);
    }

    /**
     * Remove the role assignment of the given principal on an object instance. If the user did not have a role, this will
     * have no effect.
     * 
     * @param {String} objectType The type of object, as specified by `ObjectType`
     * @param {String} objectId The ID of the object instance
     * @param {Function} callback A function(err) specifying whether or not the operation was successful
     */
    that.removeRole = function(objectType, objectId, callback) {
        var columnName = objectType+':'+objectId;
        var cql = 'delete ? from Role where principal = ?';
        OAE.runQuery(cql, [columnName, rowKey ], callback);
    }

    // Determine the column name for the given object instance.
    function getColumnName(objectType, objectId) {
        return objectType+':'+objectId;
    }

    return that;
};

/**
 * Get all principal associations to the `ObjectType` for all the principals in the array of `PrincipalTypes`. This is similar
 * to `SecurityContext.getRolesForObjectType`, except it can be performed on multiple principals at once.
 * 
 * The structure of the resulting entries is simply a hash, indicating all object instance ids that were returned. For example:
 *
 * {
 *   'group-a': true,
 *   'group-b': true
 * }
 *
 * The role is not returned to avoid a misleading anomaly that different users were associated to the same content in different
 * roles. In which case, the role associated to the object instance is rather unpredictable. If you need to get specific roles,
 * consider using `SecurityContext.getRolesForObjectType` instead.
 *
 * @param {Array} principals The array of `PrincipalTypes` to query for
 * @param {String} objectType The object type to query for as determined by `ObjectTypes`
 * @param {Number} limit The maximum number of object instances to return per user
 * @param {Function} callback A `function(entries, err)` providing all the {object instance} -> {role} mappings aggregated
 * for all the provided principals queried
 *
 * @see {SecurityContext.getRolesForObjectType}
 */
module.exports.getAssociationsForPrincipalsAndObjectType = function(principals, objectType, limit, callback) {
    if (isNaN(limit)) {
        callback(null, {why: '"limit" parameter must be a number when searching for active roles'});
        return;
    }

    // we append a '|' to the `end` range, as | has a high ASCII alphabetical ordering. This may not suffice if object ids have
    // multi-byte characters, which is technically possible. Unfortunately, I don't think there is a better way to do this with
    // CQL.
    var columnPrefix = objectType+':';
    var start = columnPrefix;
    var end = start+'|';

    // aggregate the db-level rowKeys from the principals
    var principalKeys = [];
    for (var i = 0; i < principals.length; i++) {
        principalKeys.push(getPrincipalKey(principals[i]));
    }

    var cql = 'select first '+limit+' ? .. ? from Role where principal in (?)';
    OAE.runQuery(cql, [start, end, principalKeys], function(err, rows) {
        if (!err) {
            var entries = {};

            // aggregate all object instances from all the rows (principals) into the entries hash
            for (var r = 0; r < rows.rowCount(); r++) {
                var row = rows[r];
                for (var c = 0; c < row._colCount; c++) {
                    var col = row.cols[c];
                    var objectId = col.name.substring(columnPrefix.length);
                    entries[objectId] = true;
                }
            }
            
            callback(entries);
        } else {
            callback(null, err);
        }
    });
};

function getPrincipalKey(principal) {
    return principal.principalType+':'+principal.tenantId+':'+principal.principalId;
}

