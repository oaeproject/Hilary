/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var AuthzUtil = require('oae-authz/lib/util');
var Validator = require('oae-util/lib/validator').Validator;

var OAuthDAO = require('./internal/dao');


/////////////
// Clients //
/////////////

module.exports.Clients = {};

/**
 * Get all the OAuth clients for a user.
 *
 * @param  {Context}    ctx                 The context of the current request
 * @param  {String}     userId              The ID of the user for which the clients should be retrieved
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Standard error object, if any
 * @param  {Client}     callback.clients    The registerd OAuth clients for this user
 */
var getClients = module.exports.Clients.getClients = function(ctx, userId, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Anonymous users do not have clients'}).isLoggedInUser(ctx);
    validator.check(userId, {'code': 400, 'msg': 'An invalid userId was passed in'}).isUserId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Tenant admins are the only ones who can request another user their clients, provided that they're on the same tenant
    var userTenantAlias = AuthzUtil.getResourceFromId(userId).tenantAlias;
    if (ctx.user().id !== userId && !ctx.user().isAdmin(userTenantAlias)) {
        return callback({'code': 401, 'msg': 'Only administrators can request registered clients of another user'});
    }

    OAuthDAO.Clients.getClientsByUser(userId, callback);
};

/**
 * Creates an OAuth client.
 * Currently, global and/or tenant administrators are the only ones who can create OAuth clients.
 * They can create a client *for another* user if they choose to do so. The access associated to
 * that client will be the full access of the user for which you've created the client.
 *
 * @param  {Context}    ctx                 The context of the current request
 * @param  {String}     userId              The ID of the user for which a client should be created
 * @param  {String}     displayName         The name of the client or application
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Standard error object, if any
 * @param  {Client}     callback.client     The created client
 */
var createClient = module.exports.Clients.createClient = function(ctx, userId, displayName, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Anonymous users cannot create a client'}).isLoggedInUser(ctx);
    validator.check(userId, {'code': 400, 'msg': 'A client must be bound to a user'}).isUserId();
    validator.check(displayName, {'code': 400, 'msg': 'Missing client displayName'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Tenant admins are the only ones who can create a client for a user, provided that they're on the same tenant
    var userTenantAlias = AuthzUtil.getResourceFromId(userId).tenantAlias;
    if (!ctx.user().isAdmin(userTenantAlias)) {
        return callback({'code': 401, 'msg': 'Only administrators can create OAuth clients'});
    }

    // Persist the client
    var id = generateToken(32);
    var secret = generateToken(32);
    OAuthDAO.Clients.createClient(id, displayName, secret, userId, callback);
};

/**
 * Update an existing OAuth client
 *
 * @param  {Context}    ctx                 The context of the current request
 * @param  {String}     clientId            The ID of the client that should be updated
 * @param  {String}     displayName         The new name for the client
 * @param  {String}     secret              The new secret for the client
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Standard error object, if any
 * @param  {Client}     callback.client     The updated client
 */
var updateClient = module.exports.Clients.updateClient = function(ctx, clientId, displayName, secret, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Anonymous users cannot create a client'}).isLoggedInUser(ctx);
    validator.check(clientId, {'code': 400, 'msg': 'Missing client id'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    } else if (!displayName && !secret) {
        return callback({'code': 400, 'msg': 'A displayName and/or secret has to be provided'});
    }

    // Sanity check that the client is owned by the current user, or that he is a tenant administrator
    OAuthDAO.Clients.getClientById(clientId, function(err, client) {
        if (err) {
            return callback(err);
        } else if (!client) {
            return callback({'code': 404, 'msg': 'No client with that id was found'});
        }

        var userTenantAlias = AuthzUtil.getResourceFromId(client.userId).tenantAlias;
        if (client.userId !== ctx.user().id && !ctx.user().isAdmin(userTenantAlias)) {
            return callback({'code': 401, 'msg': 'You cannot update a client that you do not own'});
        }

        displayName = displayName || client.displayName;
        secret = secret || client.secret;
        OAuthDAO.Clients.updateClient(clientId, displayName, secret, function(err) {
            if (err) {
                return callback(err);
            }

            client.displayName = displayName;
            client.secret = secret;
            return callback(null, client);
        });
    });
};

/**
 * Delete an OAuth client
 *
 * @param  {Context}    ctx             The context of the current request
 * @param  {String}     clientId        The ID of the client that should be removed
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    Standard error object, if any
 */
var deleteClient = module.exports.Clients.deleteClient = function(ctx, clientId, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Anonymous users cannot delete a client'}).isLoggedInUser(ctx);
    validator.check(clientId, {'code': 400, 'msg': 'Missing client id'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Sanity check that the client is owned by the current user, or that he is a tenant administrator
    OAuthDAO.Clients.getClientById(clientId, function(err, client) {
        if (err) {
            return callback(err);
        } else if (!client) {
            return callback({'code': 404, 'msg': 'No client with that id was found'});
        }

        var userTenantAlias = AuthzUtil.getResourceFromId(client.userId).tenantAlias;
        if (client.userId !== ctx.user().id && !ctx.user().isAdmin(userTenantAlias)) {
            return callback({'code': 401, 'msg': 'You cannot delete a client that you do not own'});
        }

        OAuthDAO.Clients.deleteClient(clientId, client.userId, callback);
    });
};


///////////////
// Utilities //
///////////////

/**
 * Generates a random string of a given size
 *
 * @param  {Number}   length    The length of the desired random string
 * @return {String}             A randomly generated string of a given length
 */
var generateToken = module.exports.generateToken = function(length) {
    var randomString = '';
    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (var i = 0; i < length; i++) {
        randomString += chars[_.random(0, chars.length -1) ];
    }
    return randomString;
};
